<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sharp/lib/output.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sharp/lib/output.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1414</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">88.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.99</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2013 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0

&#039;use strict&#039;;

const path = require(&#039;path&#039;);
const is = require(&#039;./is&#039;);
const sharp = require(&#039;./sharp&#039;);

const formats = new Map([
  [&#039;heic&#039;, &#039;heif&#039;],
  [&#039;heif&#039;, &#039;heif&#039;],
  [&#039;avif&#039;, &#039;avif&#039;],
  [&#039;jpeg&#039;, &#039;jpeg&#039;],
  [&#039;jpg&#039;, &#039;jpeg&#039;],
  [&#039;jpe&#039;, &#039;jpeg&#039;],
  [&#039;tile&#039;, &#039;tile&#039;],
  [&#039;dz&#039;, &#039;tile&#039;],
  [&#039;png&#039;, &#039;png&#039;],
  [&#039;raw&#039;, &#039;raw&#039;],
  [&#039;tiff&#039;, &#039;tiff&#039;],
  [&#039;tif&#039;, &#039;tiff&#039;],
  [&#039;webp&#039;, &#039;webp&#039;],
  [&#039;gif&#039;, &#039;gif&#039;],
  [&#039;jp2&#039;, &#039;jp2&#039;],
  [&#039;jpx&#039;, &#039;jp2&#039;],
  [&#039;j2k&#039;, &#039;jp2&#039;],
  [&#039;j2c&#039;, &#039;jp2&#039;],
  [&#039;jxl&#039;, &#039;jxl&#039;]
]);

const jp2Regex = /\.(jp[2x]|j2[kc])$/i;

const errJp2Save = () =&gt; new Error(&#039;JP2 output requires libvips with support for OpenJPEG&#039;);

const bitdepthFromColourCount = (colours) =&gt; 1 &lt;&lt; 31 - Math.clz32(Math.ceil(Math.log2(colours)));

/**
 * Write output image data to a file.
 *
 * If an explicit output format is not selected, it will be inferred from the extension,
 * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips&#039; V format supported.
 * Note that raw pixel data is only supported for buffer output.
 *
 * By default all metadata will be removed, which includes EXIF-based orientation.
 * See {@link #withmetadata|withMetadata} for control over this.
 *
 * The caller is responsible for ensuring directory structures and permissions exist.
 *
 * A `Promise` is returned when `callback` is not provided.
 *
 * @example
 * sharp(input)
 *   .toFile(&#039;output.png&#039;, (err, info) =&gt; { ... });
 *
 * @example
 * sharp(input)
 *   .toFile(&#039;output.png&#039;)
 *   .then(info =&gt; { ... })
 *   .catch(err =&gt; { ... });
 *
 * @param {string} fileOut - the path to write the image data to.
 * @param {Function} [callback] - called on completion with two arguments `(err, info)`.
 * `info` contains the output image `format`, `size` (bytes), `width`, `height`,
 * `channels` and `premultiplied` (indicating if premultiplication was used).
 * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.
 * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.
 * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.
 * @returns {Promise&lt;Object&gt;} - when no callback is provided
 * @throws {Error} Invalid parameters
 */
function toFile (fileOut, callback) {
  let err;
  if (!is.string(fileOut)) {
    err = new Error(&#039;Missing output file path&#039;);
  } else if (is.string(this.options.input.file) &amp;&amp; path.resolve(this.options.input.file) === path.resolve(fileOut)) {
    err = new Error(&#039;Cannot use same file for input and output&#039;);
  } else if (jp2Regex.test(path.extname(fileOut)) &amp;&amp; !this.constructor.format.jp2k.output.file) {
    err = errJp2Save();
  }
  if (err) {
    if (is.fn(callback)) {
      callback(err);
    } else {
      return Promise.reject(err);
    }
  } else {
    this.options.fileOut = fileOut;
    return this._pipeline(callback);
  }
  return this;
}

/**
 * Write output to a Buffer.
 * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.
 *
 * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.
 *
 * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.
 *
 * By default all metadata will be removed, which includes EXIF-based orientation.
 * See {@link #withmetadata|withMetadata} for control over this.
 *
 * `callback`, if present, gets three arguments `(err, data, info)` where:
 * - `err` is an error, if any.
 * - `data` is the output image data.
 * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,
 * `channels` and `premultiplied` (indicating if premultiplication was used).
 * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.
 * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.
 *
 * A `Promise` is returned when `callback` is not provided.
 *
 * @example
 * sharp(input)
 *   .toBuffer((err, data, info) =&gt; { ... });
 *
 * @example
 * sharp(input)
 *   .toBuffer()
 *   .then(data =&gt; { ... })
 *   .catch(err =&gt; { ... });
 *
 * @example
 * sharp(input)
 *   .png()
 *   .toBuffer({ resolveWithObject: true })
 *   .then(({ data, info }) =&gt; { ... })
 *   .catch(err =&gt; { ... });
 *
 * @example
 * const { data, info } = await sharp(&#039;my-image.jpg&#039;)
 *   // output the raw pixels
 *   .raw()
 *   .toBuffer({ resolveWithObject: true });
 *
 * // create a more type safe way to work with the raw pixel data
 * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer
 * // so `data` and `pixelArray` point to the same memory location
 * const pixelArray = new Uint8ClampedArray(data.buffer);
 *
 * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input
 * const { width, height, channels } = info;
 * await sharp(pixelArray, { raw: { width, height, channels } })
 *   .toFile(&#039;my-changed-image.jpg&#039;);
 *
 * @param {Object} [options]
 * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.
 * @param {Function} [callback]
 * @returns {Promise&lt;Buffer&gt;} - when no callback is provided
 */
function toBuffer (options, callback) {
  if (is.object(options)) {
    this._setBooleanOption(&#039;resolveWithObject&#039;, options.resolveWithObject);
  } else if (this.options.resolveWithObject) {
    this.options.resolveWithObject = false;
  }
  this.options.fileOut = &#039;&#039;;
  return this._pipeline(is.fn(options) ? options : callback);
}

/**
 * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.
 * This will also convert to and add a web-friendly sRGB ICC profile if appropriate,
 * unless a custom output profile is provided.
 *
 * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent
 * sRGB colour space and strip all metadata, including the removal of any ICC profile.
 *
 * EXIF metadata is unsupported for TIFF output.
 *
 * @example
 * sharp(&#039;input.jpg&#039;)
 *   .withMetadata()
 *   .toFile(&#039;output-with-metadata.jpg&#039;)
 *   .then(info =&gt; { ... });
 *
 * @example
 * // Set output EXIF metadata
 * const data = await sharp(input)
 *   .withMetadata({
 *     exif: {
 *       IFD0: {
 *         Copyright: &#039;The National Gallery&#039;
 *       },
 *       IFD3: {
 *         GPSLatitudeRef: &#039;N&#039;,
 *         GPSLatitude: &#039;51/1 30/1 3230/100&#039;,
 *         GPSLongitudeRef: &#039;W&#039;,
 *         GPSLongitude: &#039;0/1 7/1 4366/100&#039;
 *       }
 *     }
 *   })
 *   .toBuffer();
 *
 * @example
 * // Set output metadata to 96 DPI
 * const data = await sharp(input)
 *   .withMetadata({ density: 96 })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.
 * @param {string} [options.icc=&#039;srgb&#039;] Filesystem path to output ICC profile, relative to `process.cwd()`, defaults to built-in sRGB.
 * @param {Object&lt;Object&gt;} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.
 * @param {number} [options.density] Number of pixels per inch (DPI).
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */
function withMetadata (options) {
  this.options.withMetadata = is.bool(options) ? options : true;
  if (is.object(options)) {
    if (is.defined(options.orientation)) {
      if (is.integer(options.orientation) &amp;&amp; is.inRange(options.orientation, 1, 8)) {
        this.options.withMetadataOrientation = options.orientation;
      } else {
        throw is.invalidParameterError(&#039;orientation&#039;, &#039;integer between 1 and 8&#039;, options.orientation);
      }
    }
    if (is.defined(options.density)) {
      if (is.number(options.density) &amp;&amp; options.density &gt; 0) {
        this.options.withMetadataDensity = options.density;
      } else {
        throw is.invalidParameterError(&#039;density&#039;, &#039;positive number&#039;, options.density);
      }
    }
    if (is.defined(options.icc)) {
      if (is.string(options.icc)) {
        this.options.withMetadataIcc = options.icc;
      } else {
        throw is.invalidParameterError(&#039;icc&#039;, &#039;string filesystem path to ICC profile&#039;, options.icc);
      }
    }
    if (is.defined(options.exif)) {
      if (is.object(options.exif)) {
        for (const [ifd, entries] of Object.entries(options.exif)) {
          if (is.object(entries)) {
            for (const [k, v] of Object.entries(entries)) {
              if (is.string(v)) {
                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;
              } else {
                throw is.invalidParameterError(`exif.${ifd}.${k}`, &#039;string&#039;, v);
              }
            }
          } else {
            throw is.invalidParameterError(`exif.${ifd}`, &#039;object&#039;, entries);
          }
        }
      } else {
        throw is.invalidParameterError(&#039;exif&#039;, &#039;object&#039;, options.exif);
      }
    }
  }
  return this;
}

/**
 * Force output to a given format.
 *
 * @example
 * // Convert any input to PNG output
 * const data = await sharp(input)
 *   .toFormat(&#039;png&#039;)
 *   .toBuffer();
 *
 * @param {(string|Object)} format - as a string or an Object with an &#039;id&#039; attribute
 * @param {Object} options - output options
 * @returns {Sharp}
 * @throws {Error} unsupported format or options
 */
function toFormat (format, options) {
  const actualFormat = formats.get((is.object(format) &amp;&amp; is.string(format.id) ? format.id : format).toLowerCase());
  if (!actualFormat) {
    throw is.invalidParameterError(&#039;format&#039;, `one of: ${[...formats.keys()].join(&#039;, &#039;)}`, format);
  }
  return this[actualFormat](options);
}

/**
 * Use these JPEG options for output image.
 *
 * @example
 * // Convert any input to very high quality JPEG output
 * const data = await sharp(input)
 *   .jpeg({
 *     quality: 100,
 *     chromaSubsampling: &#039;4:4:4&#039;
 *   })
 *   .toBuffer();
 *
 * @example
 * // Use mozjpeg to reduce output JPEG file size (slower)
 * const data = await sharp(input)
 *   .jpeg({ mozjpeg: true })
 *   .toBuffer();
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {boolean} [options.progressive=false] - use progressive (interlace) scan
 * @param {string} [options.chromaSubsampling=&#039;4:2:0&#039;] - set to &#039;4:4:4&#039; to prevent chroma subsampling otherwise defaults to &#039;4:2:0&#039; chroma subsampling
 * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables
 * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding
 * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`
 * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation
 * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing
 * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive
 * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans
 * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8
 * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable
 * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function jpeg (options) {
  if (is.object(options)) {
    if (is.defined(options.quality)) {
      if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 1, 100)) {
        this.options.jpegQuality = options.quality;
      } else {
        throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 1 and 100&#039;, options.quality);
      }
    }
    if (is.defined(options.progressive)) {
      this._setBooleanOption(&#039;jpegProgressive&#039;, options.progressive);
    }
    if (is.defined(options.chromaSubsampling)) {
      if (is.string(options.chromaSubsampling) &amp;&amp; is.inArray(options.chromaSubsampling, [&#039;4:2:0&#039;, &#039;4:4:4&#039;])) {
        this.options.jpegChromaSubsampling = options.chromaSubsampling;
      } else {
        throw is.invalidParameterError(&#039;chromaSubsampling&#039;, &#039;one of: 4:2:0, 4:4:4&#039;, options.chromaSubsampling);
      }
    }
    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;
    if (is.defined(optimiseCoding)) {
      this._setBooleanOption(&#039;jpegOptimiseCoding&#039;, optimiseCoding);
    }
    if (is.defined(options.mozjpeg)) {
      if (is.bool(options.mozjpeg)) {
        if (options.mozjpeg) {
          this.options.jpegTrellisQuantisation = true;
          this.options.jpegOvershootDeringing = true;
          this.options.jpegOptimiseScans = true;
          this.options.jpegProgressive = true;
          this.options.jpegQuantisationTable = 3;
        }
      } else {
        throw is.invalidParameterError(&#039;mozjpeg&#039;, &#039;boolean&#039;, options.mozjpeg);
      }
    }
    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;
    if (is.defined(trellisQuantisation)) {
      this._setBooleanOption(&#039;jpegTrellisQuantisation&#039;, trellisQuantisation);
    }
    if (is.defined(options.overshootDeringing)) {
      this._setBooleanOption(&#039;jpegOvershootDeringing&#039;, options.overshootDeringing);
    }
    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;
    if (is.defined(optimiseScans)) {
      this._setBooleanOption(&#039;jpegOptimiseScans&#039;, optimiseScans);
      if (optimiseScans) {
        this.options.jpegProgressive = true;
      }
    }
    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;
    if (is.defined(quantisationTable)) {
      if (is.integer(quantisationTable) &amp;&amp; is.inRange(quantisationTable, 0, 8)) {
        this.options.jpegQuantisationTable = quantisationTable;
      } else {
        throw is.invalidParameterError(&#039;quantisationTable&#039;, &#039;integer between 0 and 8&#039;, quantisationTable);
      }
    }
  }
  return this._updateFormatOut(&#039;jpeg&#039;, options);
}

/**
 * Use these PNG options for output image.
 *
 * By default, PNG output is full colour at 8 or 16 bits per pixel.
 * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.
 * Set `palette` to `true` for slower, indexed PNG output.
 *
 * @example
 * // Convert any input to full colour PNG output
 * const data = await sharp(input)
 *   .png()
 *   .toBuffer();
 *
 * @example
 * // Convert any input to indexed PNG output (slower)
 * const data = await sharp(input)
 *   .png({ palette: true })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {boolean} [options.progressive=false] - use progressive (interlace) scan
 * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)
 * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering
 * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support
 * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`
 * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`
 * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`
 * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`
 * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`
 * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function png (options) {
  if (is.object(options)) {
    if (is.defined(options.progressive)) {
      this._setBooleanOption(&#039;pngProgressive&#039;, options.progressive);
    }
    if (is.defined(options.compressionLevel)) {
      if (is.integer(options.compressionLevel) &amp;&amp; is.inRange(options.compressionLevel, 0, 9)) {
        this.options.pngCompressionLevel = options.compressionLevel;
      } else {
        throw is.invalidParameterError(&#039;compressionLevel&#039;, &#039;integer between 0 and 9&#039;, options.compressionLevel);
      }
    }
    if (is.defined(options.adaptiveFiltering)) {
      this._setBooleanOption(&#039;pngAdaptiveFiltering&#039;, options.adaptiveFiltering);
    }
    const colours = options.colours || options.colors;
    if (is.defined(colours)) {
      if (is.integer(colours) &amp;&amp; is.inRange(colours, 2, 256)) {
        this.options.pngBitdepth = bitdepthFromColourCount(colours);
      } else {
        throw is.invalidParameterError(&#039;colours&#039;, &#039;integer between 2 and 256&#039;, colours);
      }
    }
    if (is.defined(options.palette)) {
      this._setBooleanOption(&#039;pngPalette&#039;, options.palette);
    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {
      this._setBooleanOption(&#039;pngPalette&#039;, true);
    }
    if (this.options.pngPalette) {
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 0, 100)) {
          this.options.pngQuality = options.quality;
        } else {
          throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 0 and 100&#039;, options.quality);
        }
      }
      if (is.defined(options.effort)) {
        if (is.integer(options.effort) &amp;&amp; is.inRange(options.effort, 1, 10)) {
          this.options.pngEffort = options.effort;
        } else {
          throw is.invalidParameterError(&#039;effort&#039;, &#039;integer between 1 and 10&#039;, options.effort);
        }
      }
      if (is.defined(options.dither)) {
        if (is.number(options.dither) &amp;&amp; is.inRange(options.dither, 0, 1)) {
          this.options.pngDither = options.dither;
        } else {
          throw is.invalidParameterError(&#039;dither&#039;, &#039;number between 0.0 and 1.0&#039;, options.dither);
        }
      }
    }
  }
  return this._updateFormatOut(&#039;png&#039;, options);
}

/**
 * Use these WebP options for output image.
 *
 * @example
 * // Convert any input to lossless WebP output
 * const data = await sharp(input)
 *   .webp({ lossless: true })
 *   .toBuffer();
 *
 * @example
 * // Optimise the file size of an animated WebP
 * const outputWebp = await sharp(inputWebp, { animated: true })
 *   .webp({ effort: 6 })
 *   .toBuffer();
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100
 * @param {boolean} [options.lossless=false] - use lossless compression mode
 * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode
 * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling
 * @param {string} [options.preset=&#039;default&#039;] - named preset for preprocessing/filtering, one of: default, photo, picture, drawing, icon, text
 * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)
 * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)
 * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)
 * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)
 * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function webp (options) {
  if (is.object(options)) {
    if (is.defined(options.quality)) {
      if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 1, 100)) {
        this.options.webpQuality = options.quality;
      } else {
        throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 1 and 100&#039;, options.quality);
      }
    }
    if (is.defined(options.alphaQuality)) {
      if (is.integer(options.alphaQuality) &amp;&amp; is.inRange(options.alphaQuality, 0, 100)) {
        this.options.webpAlphaQuality = options.alphaQuality;
      } else {
        throw is.invalidParameterError(&#039;alphaQuality&#039;, &#039;integer between 0 and 100&#039;, options.alphaQuality);
      }
    }
    if (is.defined(options.lossless)) {
      this._setBooleanOption(&#039;webpLossless&#039;, options.lossless);
    }
    if (is.defined(options.nearLossless)) {
      this._setBooleanOption(&#039;webpNearLossless&#039;, options.nearLossless);
    }
    if (is.defined(options.smartSubsample)) {
      this._setBooleanOption(&#039;webpSmartSubsample&#039;, options.smartSubsample);
    }
    if (is.defined(options.preset)) {
      if (is.string(options.preset) &amp;&amp; is.inArray(options.preset, [&#039;default&#039;, &#039;photo&#039;, &#039;picture&#039;, &#039;drawing&#039;, &#039;icon&#039;, &#039;text&#039;])) {
        this.options.webpPreset = options.preset;
      } else {
        throw is.invalidParameterError(&#039;preset&#039;, &#039;one of: default, photo, picture, drawing, icon, text&#039;, options.preset);
      }
    }
    if (is.defined(options.effort)) {
      if (is.integer(options.effort) &amp;&amp; is.inRange(options.effort, 0, 6)) {
        this.options.webpEffort = options.effort;
      } else {
        throw is.invalidParameterError(&#039;effort&#039;, &#039;integer between 0 and 6&#039;, options.effort);
      }
    }
    if (is.defined(options.minSize)) {
      this._setBooleanOption(&#039;webpMinSize&#039;, options.minSize);
    }
    if (is.defined(options.mixed)) {
      this._setBooleanOption(&#039;webpMixed&#039;, options.mixed);
    }
  }
  trySetAnimationOptions(options, this.options);
  return this._updateFormatOut(&#039;webp&#039;, options);
}

/**
 * Use these GIF options for the output image.
 *
 * The first entry in the palette is reserved for transparency.
 *
 * The palette of the input image will be re-used if possible.
 *
 * @since 0.30.0
 *
 * @example
 * // Convert PNG to GIF
 * await sharp(pngBuffer)
 *   .gif()
 *   .toBuffer();
 *
 * @example
 * // Convert animated WebP to animated GIF
 * await sharp(&#039;animated.webp&#039;, { animated: true })
 *   .toFile(&#039;animated.gif&#039;);
 *
 * @example
 * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF
 * const out = await sharp(&#039;in.gif&#039;, { animated: true })
 *   .resize({ width: 128, height: 128 })
 *   .gif({ dither: 0 })
 *   .toBuffer();
 *
 * @example
 * // Lossy file size reduction of animated GIF
 * await sharp(&#039;in.gif&#039;, { animated: true })
 *   .gif({ interFrameMaxError: 8 })
 *   .toFile(&#039;optim.gif&#039;);
 *
 * @param {Object} [options] - output options
 * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)
 * @param {boolean} [options.progressive=false] - use progressive (interlace) scan
 * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256
 * @param {number} [options.colors=256] - alternative spelling of `options.colours`
 * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)
 * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)
 * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32
 * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256
 * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)
 * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function gif (options) {
  if (is.object(options)) {
    if (is.defined(options.reuse)) {
      this._setBooleanOption(&#039;gifReuse&#039;, options.reuse);
    }
    if (is.defined(options.progressive)) {
      this._setBooleanOption(&#039;gifProgressive&#039;, options.progressive);
    }
    const colours = options.colours || options.colors;
    if (is.defined(colours)) {
      if (is.integer(colours) &amp;&amp; is.inRange(colours, 2, 256)) {
        this.options.gifBitdepth = bitdepthFromColourCount(colours);
      } else {
        throw is.invalidParameterError(&#039;colours&#039;, &#039;integer between 2 and 256&#039;, colours);
      }
    }
    if (is.defined(options.effort)) {
      if (is.number(options.effort) &amp;&amp; is.inRange(options.effort, 1, 10)) {
        this.options.gifEffort = options.effort;
      } else {
        throw is.invalidParameterError(&#039;effort&#039;, &#039;integer between 1 and 10&#039;, options.effort);
      }
    }
    if (is.defined(options.dither)) {
      if (is.number(options.dither) &amp;&amp; is.inRange(options.dither, 0, 1)) {
        this.options.gifDither = options.dither;
      } else {
        throw is.invalidParameterError(&#039;dither&#039;, &#039;number between 0.0 and 1.0&#039;, options.dither);
      }
    }
    if (is.defined(options.interFrameMaxError)) {
      if (is.number(options.interFrameMaxError) &amp;&amp; is.inRange(options.interFrameMaxError, 0, 32)) {
        this.options.gifInterFrameMaxError = options.interFrameMaxError;
      } else {
        throw is.invalidParameterError(&#039;interFrameMaxError&#039;, &#039;number between 0.0 and 32.0&#039;, options.interFrameMaxError);
      }
    }
    if (is.defined(options.interPaletteMaxError)) {
      if (is.number(options.interPaletteMaxError) &amp;&amp; is.inRange(options.interPaletteMaxError, 0, 256)) {
        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;
      } else {
        throw is.invalidParameterError(&#039;interPaletteMaxError&#039;, &#039;number between 0.0 and 256.0&#039;, options.interPaletteMaxError);
      }
    }
  }
  trySetAnimationOptions(options, this.options);
  return this._updateFormatOut(&#039;gif&#039;, options);
}

/* istanbul ignore next */
/**
 * Use these JP2 options for output image.
 *
 * Requires libvips compiled with support for OpenJPEG.
 * The prebuilt binaries do not include this - see
 * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.
 *
 * @example
 * // Convert any input to lossless JP2 output
 * const data = await sharp(input)
 *   .jp2({ lossless: true })
 *   .toBuffer();
 *
 * @example
 * // Convert any input to very high quality JP2 output
 * const data = await sharp(input)
 *   .jp2({
 *     quality: 100,
 *     chromaSubsampling: &#039;4:4:4&#039;
 *   })
 *   .toBuffer();
 *
 * @since 0.29.1
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {boolean} [options.lossless=false] - use lossless compression mode
 * @param {number} [options.tileWidth=512] - horizontal tile size
 * @param {number} [options.tileHeight=512] - vertical tile size
 * @param {string} [options.chromaSubsampling=&#039;4:4:4&#039;] - set to &#039;4:2:0&#039; to use chroma subsampling
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function jp2 (options) {
  if (!this.constructor.format.jp2k.output.buffer) {
    throw errJp2Save();
  }
  if (is.object(options)) {
    if (is.defined(options.quality)) {
      if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 1, 100)) {
        this.options.jp2Quality = options.quality;
      } else {
        throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 1 and 100&#039;, options.quality);
      }
    }
    if (is.defined(options.lossless)) {
      if (is.bool(options.lossless)) {
        this.options.jp2Lossless = options.lossless;
      } else {
        throw is.invalidParameterError(&#039;lossless&#039;, &#039;boolean&#039;, options.lossless);
      }
    }
    if (is.defined(options.tileWidth)) {
      if (is.integer(options.tileWidth) &amp;&amp; is.inRange(options.tileWidth, 1, 32768)) {
        this.options.jp2TileWidth = options.tileWidth;
      } else {
        throw is.invalidParameterError(&#039;tileWidth&#039;, &#039;integer between 1 and 32768&#039;, options.tileWidth);
      }
    }
    if (is.defined(options.tileHeight)) {
      if (is.integer(options.tileHeight) &amp;&amp; is.inRange(options.tileHeight, 1, 32768)) {
        this.options.jp2TileHeight = options.tileHeight;
      } else {
        throw is.invalidParameterError(&#039;tileHeight&#039;, &#039;integer between 1 and 32768&#039;, options.tileHeight);
      }
    }
    if (is.defined(options.chromaSubsampling)) {
      if (is.string(options.chromaSubsampling) &amp;&amp; is.inArray(options.chromaSubsampling, [&#039;4:2:0&#039;, &#039;4:4:4&#039;])) {
        this.options.jp2ChromaSubsampling = options.chromaSubsampling;
      } else {
        throw is.invalidParameterError(&#039;chromaSubsampling&#039;, &#039;one of: 4:2:0, 4:4:4&#039;, options.chromaSubsampling);
      }
    }
  }
  return this._updateFormatOut(&#039;jp2&#039;, options);
}

/**
 * Set animation options if available.
 * @private
 *
 * @param {Object} [source] - output options
 * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)
 * @param {Object} [target] - target object for valid options
 * @throws {Error} Invalid options
 */
function trySetAnimationOptions (source, target) {
  if (is.object(source) &amp;&amp; is.defined(source.loop)) {
    if (is.integer(source.loop) &amp;&amp; is.inRange(source.loop, 0, 65535)) {
      target.loop = source.loop;
    } else {
      throw is.invalidParameterError(&#039;loop&#039;, &#039;integer between 0 and 65535&#039;, source.loop);
    }
  }
  if (is.object(source) &amp;&amp; is.defined(source.delay)) {
    // We allow singular values as well
    if (is.integer(source.delay) &amp;&amp; is.inRange(source.delay, 0, 65535)) {
      target.delay = [source.delay];
    } else if (
      Array.isArray(source.delay) &amp;&amp;
      source.delay.every(is.integer) &amp;&amp;
      source.delay.every(v =&gt; is.inRange(v, 0, 65535))) {
      target.delay = source.delay;
    } else {
      throw is.invalidParameterError(&#039;delay&#039;, &#039;integer or an array of integers between 0 and 65535&#039;, source.delay);
    }
  }
}

/**
 * Use these TIFF options for output image.
 *
 * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}
 * instead of providing `xres` and `yres` in pixels/mm.
 *
 * @example
 * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output
 * sharp(&#039;input.svg&#039;)
 *   .tiff({
 *     compression: &#039;lzw&#039;,
 *     bitdepth: 1
 *   })
 *   .toFile(&#039;1-bpp-output.tiff&#039;)
 *   .then(info =&gt; { ... });
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format
 * @param {string} [options.compression=&#039;jpeg&#039;] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k
 * @param {string} [options.predictor=&#039;horizontal&#039;] - compression predictor options: none, horizontal, float
 * @param {boolean} [options.pyramid=false] - write an image pyramid
 * @param {boolean} [options.tile=false] - write a tiled tiff
 * @param {number} [options.tileWidth=256] - horizontal tile size
 * @param {number} [options.tileHeight=256] - vertical tile size
 * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm
 * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm
 * @param {string} [options.resolutionUnit=&#039;inch&#039;] - resolution unit options: inch, cm
 * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function tiff (options) {
  if (is.object(options)) {
    if (is.defined(options.quality)) {
      if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 1, 100)) {
        this.options.tiffQuality = options.quality;
      } else {
        throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 1 and 100&#039;, options.quality);
      }
    }
    if (is.defined(options.bitdepth)) {
      if (is.integer(options.bitdepth) &amp;&amp; is.inArray(options.bitdepth, [1, 2, 4, 8])) {
        this.options.tiffBitdepth = options.bitdepth;
      } else {
        throw is.invalidParameterError(&#039;bitdepth&#039;, &#039;1, 2, 4 or 8&#039;, options.bitdepth);
      }
    }
    // tiling
    if (is.defined(options.tile)) {
      this._setBooleanOption(&#039;tiffTile&#039;, options.tile);
    }
    if (is.defined(options.tileWidth)) {
      if (is.integer(options.tileWidth) &amp;&amp; options.tileWidth &gt; 0) {
        this.options.tiffTileWidth = options.tileWidth;
      } else {
        throw is.invalidParameterError(&#039;tileWidth&#039;, &#039;integer greater than zero&#039;, options.tileWidth);
      }
    }
    if (is.defined(options.tileHeight)) {
      if (is.integer(options.tileHeight) &amp;&amp; options.tileHeight &gt; 0) {
        this.options.tiffTileHeight = options.tileHeight;
      } else {
        throw is.invalidParameterError(&#039;tileHeight&#039;, &#039;integer greater than zero&#039;, options.tileHeight);
      }
    }
    // pyramid
    if (is.defined(options.pyramid)) {
      this._setBooleanOption(&#039;tiffPyramid&#039;, options.pyramid);
    }
    // resolution
    if (is.defined(options.xres)) {
      if (is.number(options.xres) &amp;&amp; options.xres &gt; 0) {
        this.options.tiffXres = options.xres;
      } else {
        throw is.invalidParameterError(&#039;xres&#039;, &#039;number greater than zero&#039;, options.xres);
      }
    }
    if (is.defined(options.yres)) {
      if (is.number(options.yres) &amp;&amp; options.yres &gt; 0) {
        this.options.tiffYres = options.yres;
      } else {
        throw is.invalidParameterError(&#039;yres&#039;, &#039;number greater than zero&#039;, options.yres);
      }
    }
    // compression
    if (is.defined(options.compression)) {
      if (is.string(options.compression) &amp;&amp; is.inArray(options.compression, [&#039;none&#039;, &#039;jpeg&#039;, &#039;deflate&#039;, &#039;packbits&#039;, &#039;ccittfax4&#039;, &#039;lzw&#039;, &#039;webp&#039;, &#039;zstd&#039;, &#039;jp2k&#039;])) {
        this.options.tiffCompression = options.compression;
      } else {
        throw is.invalidParameterError(&#039;compression&#039;, &#039;one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k&#039;, options.compression);
      }
    }
    // predictor
    if (is.defined(options.predictor)) {
      if (is.string(options.predictor) &amp;&amp; is.inArray(options.predictor, [&#039;none&#039;, &#039;horizontal&#039;, &#039;float&#039;])) {
        this.options.tiffPredictor = options.predictor;
      } else {
        throw is.invalidParameterError(&#039;predictor&#039;, &#039;one of: none, horizontal, float&#039;, options.predictor);
      }
    }
    // resolutionUnit
    if (is.defined(options.resolutionUnit)) {
      if (is.string(options.resolutionUnit) &amp;&amp; is.inArray(options.resolutionUnit, [&#039;inch&#039;, &#039;cm&#039;])) {
        this.options.tiffResolutionUnit = options.resolutionUnit;
      } else {
        throw is.invalidParameterError(&#039;resolutionUnit&#039;, &#039;one of: inch, cm&#039;, options.resolutionUnit);
      }
    }
  }
  return this._updateFormatOut(&#039;tiff&#039;, options);
}

/**
 * Use these AVIF options for output image.
 *
 * Whilst it is possible to create AVIF images smaller than 16x16 pixels,
 * most web browsers do not display these properly.
 *
 * AVIF image sequences are not supported.
 *
 * @example
 * const data = await sharp(input)
 *   .avif({ effort: 2 })
 *   .toBuffer();
 *
 * @example
 * const data = await sharp(input)
 *   .avif({ lossless: true })
 *   .toBuffer();
 *
 * @since 0.27.0
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=50] - quality, integer 1-100
 * @param {boolean} [options.lossless=false] - use lossless compression
 * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)
 * @param {string} [options.chromaSubsampling=&#039;4:4:4&#039;] - set to &#039;4:2:0&#039; to use chroma subsampling
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function avif (options) {
  return this.heif({ ...options, compression: &#039;av1&#039; });
}

/**
 * Use these HEIF options for output image.
 *
 * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a
 * globally-installed libvips compiled with support for libheif, libde265 and x265.
 *
 * @example
 * const data = await sharp(input)
 *   .heif({ compression: &#039;hevc&#039; })
 *   .toBuffer();
 *
 * @since 0.23.0
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=50] - quality, integer 1-100
 * @param {string} [options.compression=&#039;av1&#039;] - compression format: av1, hevc
 * @param {boolean} [options.lossless=false] - use lossless compression
 * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)
 * @param {string} [options.chromaSubsampling=&#039;4:4:4&#039;] - set to &#039;4:2:0&#039; to use chroma subsampling
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function heif (options) {
  if (is.object(options)) {
    if (is.defined(options.quality)) {
      if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 1, 100)) {
        this.options.heifQuality = options.quality;
      } else {
        throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 1 and 100&#039;, options.quality);
      }
    }
    if (is.defined(options.lossless)) {
      if (is.bool(options.lossless)) {
        this.options.heifLossless = options.lossless;
      } else {
        throw is.invalidParameterError(&#039;lossless&#039;, &#039;boolean&#039;, options.lossless);
      }
    }
    if (is.defined(options.compression)) {
      if (is.string(options.compression) &amp;&amp; is.inArray(options.compression, [&#039;av1&#039;, &#039;hevc&#039;])) {
        this.options.heifCompression = options.compression;
      } else {
        throw is.invalidParameterError(&#039;compression&#039;, &#039;one of: av1, hevc&#039;, options.compression);
      }
    }
    if (is.defined(options.effort)) {
      if (is.integer(options.effort) &amp;&amp; is.inRange(options.effort, 0, 9)) {
        this.options.heifEffort = options.effort;
      } else {
        throw is.invalidParameterError(&#039;effort&#039;, &#039;integer between 0 and 9&#039;, options.effort);
      }
    }
    if (is.defined(options.chromaSubsampling)) {
      if (is.string(options.chromaSubsampling) &amp;&amp; is.inArray(options.chromaSubsampling, [&#039;4:2:0&#039;, &#039;4:4:4&#039;])) {
        this.options.heifChromaSubsampling = options.chromaSubsampling;
      } else {
        throw is.invalidParameterError(&#039;chromaSubsampling&#039;, &#039;one of: 4:2:0, 4:4:4&#039;, options.chromaSubsampling);
      }
    }
  }
  return this._updateFormatOut(&#039;heif&#039;, options);
}

/**
 * Use these JPEG-XL (JXL) options for output image.
 *
 * This feature is experimental, please do not use in production systems.
 *
 * Requires libvips compiled with support for libjxl.
 * The prebuilt binaries do not include this - see
 * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.
 *
 * Image metadata (EXIF, XMP) is unsupported.
 *
 * @since 0.31.3
 *
 * @param {Object} [options] - output options
 * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)
 * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified
 * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)
 * @param {boolean} [options.lossless=false] - use lossless compression
 * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function jxl (options) {
  if (is.object(options)) {
    if (is.defined(options.quality)) {
      if (is.integer(options.quality) &amp;&amp; is.inRange(options.quality, 1, 100)) {
        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644
        this.options.jxlDistance = options.quality &gt;= 30
          ? 0.1 + (100 - options.quality) * 0.09
          : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;
      } else {
        throw is.invalidParameterError(&#039;quality&#039;, &#039;integer between 1 and 100&#039;, options.quality);
      }
    } else if (is.defined(options.distance)) {
      if (is.number(options.distance) &amp;&amp; is.inRange(options.distance, 0, 15)) {
        this.options.jxlDistance = options.distance;
      } else {
        throw is.invalidParameterError(&#039;distance&#039;, &#039;number between 0.0 and 15.0&#039;, options.distance);
      }
    }
    if (is.defined(options.decodingTier)) {
      if (is.integer(options.decodingTier) &amp;&amp; is.inRange(options.decodingTier, 0, 4)) {
        this.options.jxlDecodingTier = options.decodingTier;
      } else {
        throw is.invalidParameterError(&#039;decodingTier&#039;, &#039;integer between 0 and 4&#039;, options.decodingTier);
      }
    }
    if (is.defined(options.lossless)) {
      if (is.bool(options.lossless)) {
        this.options.jxlLossless = options.lossless;
      } else {
        throw is.invalidParameterError(&#039;lossless&#039;, &#039;boolean&#039;, options.lossless);
      }
    }
    if (is.defined(options.effort)) {
      if (is.integer(options.effort) &amp;&amp; is.inRange(options.effort, 3, 9)) {
        this.options.jxlEffort = options.effort;
      } else {
        throw is.invalidParameterError(&#039;effort&#039;, &#039;integer between 3 and 9&#039;, options.effort);
      }
    }
  }
  return this._updateFormatOut(&#039;jxl&#039;, options);
}

/**
 * Force output to be raw, uncompressed pixel data.
 * Pixel ordering is left-to-right, top-to-bottom, without padding.
 * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.
 *
 * @example
 * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input
 * const { data, info } = await sharp(&#039;input.jpg&#039;)
 *   .raw()
 *   .toBuffer({ resolveWithObject: true });
 *
 * @example
 * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input
 * const data = await sharp(&#039;input.png&#039;)
 *   .ensureAlpha()
 *   .extractChannel(3)
 *   .toColourspace(&#039;b-w&#039;)
 *   .raw({ depth: &#039;ushort&#039; })
 *   .toBuffer();
 *
 * @param {Object} [options] - output options
 * @param {string} [options.depth=&#039;uchar&#039;] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */
function raw (options) {
  if (is.object(options)) {
    if (is.defined(options.depth)) {
      if (is.string(options.depth) &amp;&amp; is.inArray(options.depth,
        [&#039;char&#039;, &#039;uchar&#039;, &#039;short&#039;, &#039;ushort&#039;, &#039;int&#039;, &#039;uint&#039;, &#039;float&#039;, &#039;complex&#039;, &#039;double&#039;, &#039;dpcomplex&#039;]
      )) {
        this.options.rawDepth = options.depth;
      } else {
        throw is.invalidParameterError(&#039;depth&#039;, &#039;one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex&#039;, options.depth);
      }
    }
  }
  return this._updateFormatOut(&#039;raw&#039;);
}

/**
 * Use tile-based deep zoom (image pyramid) output.
 *
 * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.
 * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.
 *
 * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.
 *
 * Requires libvips compiled with support for libgsf.
 * The prebuilt binaries do not include this - see
 * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.
 *
 * @example
 *  sharp(&#039;input.tiff&#039;)
 *   .png()
 *   .tile({
 *     size: 512
 *   })
 *   .toFile(&#039;output.dz&#039;, function(err, info) {
 *     // output.dzi is the Deep Zoom XML definition
 *     // output_files contains 512x512 tiles grouped by zoom level
 *   });
 *
 * @example
 * const zipFileWithTiles = await sharp(input)
 *   .tile({ basename: &quot;tiles&quot; })
 *   .toBuffer();
 *
 * @example
 * const iiififier = sharp().tile({ layout: &quot;iiif&quot; });
 * readableStream
 *   .pipe(iiififier)
 *   .pipe(writeableStream);
 *
 * @param {Object} [options]
 * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.
 * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.
 * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.
 * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.
 * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.
 * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images
 * @param {string} [options.container=&#039;fs&#039;] tile container, with value `fs` (filesystem) or `zip` (compressed file).
 * @param {string} [options.layout=&#039;dz&#039;] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.
 * @param {boolean} [options.centre=false] centre image in tile.
 * @param {boolean} [options.center=false] alternative spelling of centre.
 * @param {string} [options.id=&#039;https://example.com/iiif&#039;] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`
 * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */
function tile (options) {
  if (is.object(options)) {
    // Size of square tiles, in pixels
    if (is.defined(options.size)) {
      if (is.integer(options.size) &amp;&amp; is.inRange(options.size, 1, 8192)) {
        this.options.tileSize = options.size;
      } else {
        throw is.invalidParameterError(&#039;size&#039;, &#039;integer between 1 and 8192&#039;, options.size);
      }
    }
    // Overlap of tiles, in pixels
    if (is.defined(options.overlap)) {
      if (is.integer(options.overlap) &amp;&amp; is.inRange(options.overlap, 0, 8192)) {
        if (options.overlap &gt; this.options.tileSize) {
          throw is.invalidParameterError(&#039;overlap&#039;, `&lt;= size (${this.options.tileSize})`, options.overlap);
        }
        this.options.tileOverlap = options.overlap;
      } else {
        throw is.invalidParameterError(&#039;overlap&#039;, &#039;integer between 0 and 8192&#039;, options.overlap);
      }
    }
    // Container
    if (is.defined(options.container)) {
      if (is.string(options.container) &amp;&amp; is.inArray(options.container, [&#039;fs&#039;, &#039;zip&#039;])) {
        this.options.tileContainer = options.container;
      } else {
        throw is.invalidParameterError(&#039;container&#039;, &#039;one of: fs, zip&#039;, options.container);
      }
    }
    // Layout
    if (is.defined(options.layout)) {
      if (is.string(options.layout) &amp;&amp; is.inArray(options.layout, [&#039;dz&#039;, &#039;google&#039;, &#039;iiif&#039;, &#039;iiif3&#039;, &#039;zoomify&#039;])) {
        this.options.tileLayout = options.layout;
      } else {
        throw is.invalidParameterError(&#039;layout&#039;, &#039;one of: dz, google, iiif, iiif3, zoomify&#039;, options.layout);
      }
    }
    // Angle of rotation,
    if (is.defined(options.angle)) {
      if (is.integer(options.angle) &amp;&amp; !(options.angle % 90)) {
        this.options.tileAngle = options.angle;
      } else {
        throw is.invalidParameterError(&#039;angle&#039;, &#039;positive/negative multiple of 90&#039;, options.angle);
      }
    }
    // Background colour
    this._setBackgroundColourOption(&#039;tileBackground&#039;, options.background);
    // Depth of tiles
    if (is.defined(options.depth)) {
      if (is.string(options.depth) &amp;&amp; is.inArray(options.depth, [&#039;onepixel&#039;, &#039;onetile&#039;, &#039;one&#039;])) {
        this.options.tileDepth = options.depth;
      } else {
        throw is.invalidParameterError(&#039;depth&#039;, &#039;one of: onepixel, onetile, one&#039;, options.depth);
      }
    }
    // Threshold to skip blank tiles
    if (is.defined(options.skipBlanks)) {
      if (is.integer(options.skipBlanks) &amp;&amp; is.inRange(options.skipBlanks, -1, 65535)) {
        this.options.tileSkipBlanks = options.skipBlanks;
      } else {
        throw is.invalidParameterError(&#039;skipBlanks&#039;, &#039;integer between -1 and 255/65535&#039;, options.skipBlanks);
      }
    } else if (is.defined(options.layout) &amp;&amp; options.layout === &#039;google&#039;) {
      this.options.tileSkipBlanks = 5;
    }
    // Center image in tile
    const centre = is.bool(options.center) ? options.center : options.centre;
    if (is.defined(centre)) {
      this._setBooleanOption(&#039;tileCentre&#039;, centre);
    }
    // @id attribute for IIIF layout
    if (is.defined(options.id)) {
      if (is.string(options.id)) {
        this.options.tileId = options.id;
      } else {
        throw is.invalidParameterError(&#039;id&#039;, &#039;string&#039;, options.id);
      }
    }
    // Basename for zip container
    if (is.defined(options.basename)) {
      if (is.string(options.basename)) {
        this.options.tileBasename = options.basename;
      } else {
        throw is.invalidParameterError(&#039;basename&#039;, &#039;string&#039;, options.basename);
      }
    }
  }
  // Format
  if (is.inArray(this.options.formatOut, [&#039;jpeg&#039;, &#039;png&#039;, &#039;webp&#039;])) {
    this.options.tileFormat = this.options.formatOut;
  } else if (this.options.formatOut !== &#039;input&#039;) {
    throw is.invalidParameterError(&#039;format&#039;, &#039;one of: jpeg, png, webp&#039;, this.options.formatOut);
  }
  return this._updateFormatOut(&#039;dz&#039;);
}

/**
 * Set a timeout for processing, in seconds.
 * Use a value of zero to continue processing indefinitely, the default behaviour.
 *
 * The clock starts when libvips opens an input image for processing.
 * Time spent waiting for a libuv thread to become available is not included.
 *
 * @example
 * // Ensure processing takes no longer than 3 seconds
 * try {
 *   const data = await sharp(input)
 *     .blur(1000)
 *     .timeout({ seconds: 3 })
 *     .toBuffer();
 * } catch (err) {
 *   if (err.message.includes(&#039;timeout&#039;)) { ... }
 * }
 *
 * @since 0.29.2
 *
 * @param {Object} options
 * @param {number} options.seconds - Number of seconds after which processing will be stopped
 * @returns {Sharp}
 */
function timeout (options) {
  if (!is.plainObject(options)) {
    throw is.invalidParameterError(&#039;options&#039;, &#039;object&#039;, options);
  }
  if (is.integer(options.seconds) &amp;&amp; is.inRange(options.seconds, 0, 3600)) {
    this.options.timeoutSeconds = options.seconds;
  } else {
    throw is.invalidParameterError(&#039;seconds&#039;, &#039;integer between 0 and 3600&#039;, options.seconds);
  }
  return this;
}

/**
 * Update the output format unless options.force is false,
 * in which case revert to input format.
 * @private
 * @param {string} formatOut
 * @param {Object} [options]
 * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format
 * @returns {Sharp}
 */
function _updateFormatOut (formatOut, options) {
  if (!(is.object(options) &amp;&amp; options.force === false)) {
    this.options.formatOut = formatOut;
  }
  return this;
}

/**
 * Update a boolean attribute of the this.options Object.
 * @private
 * @param {string} key
 * @param {boolean} val
 * @throws {Error} Invalid key
 */
function _setBooleanOption (key, val) {
  if (is.bool(val)) {
    this.options[key] = val;
  } else {
    throw is.invalidParameterError(key, &#039;boolean&#039;, val);
  }
}

/**
 * Called by a WriteableStream to notify us it is ready for data.
 * @private
 */
function _read () {
  /* istanbul ignore else */
  if (!this.options.streamOut) {
    this.options.streamOut = true;
    this._pipeline();
  }
}

/**
 * Invoke the C++ image processing pipeline
 * Supports callback, stream and promise variants
 * @private
 */
function _pipeline (callback) {
  if (typeof callback === &#039;function&#039;) {
    // output=file/buffer
    if (this._isStreamInput()) {
      // output=file/buffer, input=stream
      this.on(&#039;finish&#039;, () =&gt; {
        this._flattenBufferIn();
        sharp.pipeline(this.options, callback);
      });
    } else {
      // output=file/buffer, input=file/buffer
      sharp.pipeline(this.options, callback);
    }
    return this;
  } else if (this.options.streamOut) {
    // output=stream
    if (this._isStreamInput()) {
      // output=stream, input=stream
      this.once(&#039;finish&#039;, () =&gt; {
        this._flattenBufferIn();
        sharp.pipeline(this.options, (err, data, info) =&gt; {
          if (err) {
            this.emit(&#039;error&#039;, err);
          } else {
            this.emit(&#039;info&#039;, info);
            this.push(data);
          }
          this.push(null);
          this.on(&#039;end&#039;, () =&gt; this.emit(&#039;close&#039;));
        });
      });
      if (this.streamInFinished) {
        this.emit(&#039;finish&#039;);
      }
    } else {
      // output=stream, input=file/buffer
      sharp.pipeline(this.options, (err, data, info) =&gt; {
        if (err) {
          this.emit(&#039;error&#039;, err);
        } else {
          this.emit(&#039;info&#039;, info);
          this.push(data);
        }
        this.push(null);
        this.on(&#039;end&#039;, () =&gt; this.emit(&#039;close&#039;));
      });
    }
    return this;
  } else {
    // output=promise
    if (this._isStreamInput()) {
      // output=promise, input=stream
      return new Promise((resolve, reject) =&gt; {
        this.once(&#039;finish&#039;, () =&gt; {
          this._flattenBufferIn();
          sharp.pipeline(this.options, (err, data, info) =&gt; {
            if (err) {
              reject(err);
            } else {
              if (this.options.resolveWithObject) {
                resolve({ data, info });
              } else {
                resolve(data);
              }
            }
          });
        });
      });
    } else {
      // output=promise, input=file/buffer
      return new Promise((resolve, reject) =&gt; {
        sharp.pipeline(this.options, (err, data, info) =&gt; {
          if (err) {
            reject(err);
          } else {
            if (this.options.resolveWithObject) {
              resolve({ data: data, info: info });
            } else {
              resolve(data);
            }
          }
        });
      });
    }
  }
}

/**
 * Decorate the Sharp prototype with output-related functions.
 * @private
 */
module.exports = function (Sharp) {
  Object.assign(Sharp.prototype, {
    // Public
    toFile,
    toBuffer,
    withMetadata,
    toFormat,
    jpeg,
    jp2,
    png,
    webp,
    tiff,
    avif,
    heif,
    jxl,
    gif,
    raw,
    tile,
    timeout,
    // Private
    _updateFormatOut,
    _setBooleanOption,
    _read,
    _pipeline
  });
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
