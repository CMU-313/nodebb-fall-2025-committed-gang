<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-useless-assignment.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-useless-assignment.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">655</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">70.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview A rule to disallow unnecessary assignments`.
 * @author Yosuke Ota
 */

&quot;use strict&quot;;

const { findVariable } = require(&quot;@eslint-community/eslint-utils&quot;);

//------------------------------------------------------------------------------
// Types
//------------------------------------------------------------------------------

/** @typedef {import(&quot;estree&quot;).Node} ASTNode */
/** @typedef {import(&quot;estree&quot;).Pattern} Pattern */
/** @typedef {import(&quot;estree&quot;).Identifier} Identifier */
/** @typedef {import(&quot;estree&quot;).VariableDeclarator} VariableDeclarator */
/** @typedef {import(&quot;estree&quot;).AssignmentExpression} AssignmentExpression */
/** @typedef {import(&quot;estree&quot;).UpdateExpression} UpdateExpression */
/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;eslint-scope&quot;).Scope} Scope */
/** @typedef {import(&quot;eslint-scope&quot;).Variable} Variable */
/** @typedef {import(&quot;../linter/code-path-analysis/code-path&quot;)} CodePath */
/** @typedef {import(&quot;../linter/code-path-analysis/code-path-segment&quot;)} CodePathSegment */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Extract identifier from the given pattern node used on the left-hand side of the assignment.
 * @param {Pattern} pattern The pattern node to extract identifier
 * @returns {Iterable&lt;Identifier&gt;} The extracted identifier
 */
function* extractIdentifiersFromPattern(pattern) {
	switch (pattern.type) {
		case &quot;Identifier&quot;:
			yield pattern;
			return;
		case &quot;ObjectPattern&quot;:
			for (const property of pattern.properties) {
				yield* extractIdentifiersFromPattern(
					property.type === &quot;Property&quot; ? property.value : property,
				);
			}
			return;
		case &quot;ArrayPattern&quot;:
			for (const element of pattern.elements) {
				if (!element) {
					continue;
				}
				yield* extractIdentifiersFromPattern(element);
			}
			return;
		case &quot;RestElement&quot;:
			yield* extractIdentifiersFromPattern(pattern.argument);
			return;
		case &quot;AssignmentPattern&quot;:
			yield* extractIdentifiersFromPattern(pattern.left);

		// no default
	}
}

/**
 * Checks whether the given identifier node is evaluated after the assignment identifier.
 * @param {AssignmentInfo} assignment The assignment info.
 * @param {Identifier} identifier The identifier to check.
 * @returns {boolean} `true` if the given identifier node is evaluated after the assignment identifier.
 */
function isIdentifierEvaluatedAfterAssignment(assignment, identifier) {
	if (identifier.range[0] &lt; assignment.identifier.range[1]) {
		return false;
	}
	if (
		assignment.expression &amp;&amp;
		assignment.expression.range[0] &lt;= identifier.range[0] &amp;&amp;
		identifier.range[1] &lt;= assignment.expression.range[1]
	) {
		/*
		 * The identifier node is in an expression that is evaluated before the assignment.
		 * e.g. x = id;
		 *          ^^ identifier to check
		 *      ^      assignment identifier
		 */
		return false;
	}

	/*
	 * e.g.
	 *      x = 42; id;
	 *              ^^ identifier to check
	 *      ^          assignment identifier
	 *      let { x, y = id } = obj;
	 *                   ^^  identifier to check
	 *            ^          assignment identifier
	 */
	return true;
}

/**
 * Checks whether the given identifier node is used between the assigned identifier and the equal sign.
 *
 * e.g. let { x, y = x } = obj;
 *                   ^   identifier to check
 *            ^          assigned identifier
 * @param {AssignmentInfo} assignment The assignment info.
 * @param {Identifier} identifier The identifier to check.
 * @returns {boolean} `true` if the given identifier node is used between the assigned identifier and the equal sign.
 */
function isIdentifierUsedBetweenAssignedAndEqualSign(assignment, identifier) {
	if (!assignment.expression) {
		return false;
	}
	return (
		assignment.identifier.range[1] &lt;= identifier.range[0] &amp;&amp;
		identifier.range[1] &lt;= assignment.expression.range[0]
	);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;problem&quot;,

		docs: {
			description:
				&quot;Disallow variable assignments when the value is not used&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/no-useless-assignment&quot;,
		},

		schema: [],

		messages: {
			unnecessaryAssignment:
				&quot;This assigned value is not used in subsequent statements.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		/**
		 * @typedef {Object} ScopeStack
		 * @property {CodePath} codePath The code path of this scope stack.
		 * @property {Scope} scope The scope of this scope stack.
		 * @property {ScopeStack} upper The upper scope stack.
		 * @property {Record&lt;string, ScopeStackSegmentInfo&gt;} segments The map of ScopeStackSegmentInfo.
		 * @property {Set&lt;CodePathSegment&gt;} currentSegments The current CodePathSegments.
		 * @property {Map&lt;Variable, AssignmentInfo[]&gt;} assignments The map of list of AssignmentInfo for each variable.
		 * @property {Array} tryStatementBlocks The array of TryStatement block nodes in this scope stack.
		 */
		/**
		 * @typedef {Object} ScopeStackSegmentInfo
		 * @property {CodePathSegment} segment The code path segment.
		 * @property {Identifier|null} first The first identifier that appears within the segment.
		 * @property {Identifier|null} last The last identifier that appears within the segment.
		 * `first` and `last` are used to determine whether an identifier exists within the segment position range.
		 * Since it is used as a range of segments, we should originally hold all nodes, not just identifiers,
		 * but since the only nodes to be judged are identifiers, it is sufficient to have a range of identifiers.
		 */
		/**
		 * @typedef {Object} AssignmentInfo
		 * @property {Variable} variable The variable that is assigned.
		 * @property {Identifier} identifier The identifier that is assigned.
		 * @property {VariableDeclarator|AssignmentExpression|UpdateExpression} node The node where the variable was updated.
		 * @property {Expression|null} expression The expression that is evaluated before the assignment.
		 * @property {CodePathSegment[]} segments The code path segments where the assignment was made.
		 */

		/** @type {ScopeStack} */
		let scopeStack = null;

		/** @type {Set&lt;Scope&gt;} */
		const codePathStartScopes = new Set();

		/**
		 * Gets the scope of code path start from given scope
		 * @param {Scope} scope The initial scope
		 * @returns {Scope} The scope of code path start
		 * @throws {Error} Unexpected error
		 */
		function getCodePathStartScope(scope) {
			let target = scope;

			while (target) {
				if (codePathStartScopes.has(target)) {
					return target;
				}
				target = target.upper;
			}

			// Should be unreachable
			return null;
		}

		/**
		 * Verify the given scope stack.
		 * @param {ScopeStack} target The scope stack to verify.
		 * @returns {void}
		 */
		function verify(target) {
			/**
			 * Checks whether the given identifier is used in the segment.
			 * @param {CodePathSegment} segment The code path segment.
			 * @param {Identifier} identifier The identifier to check.
			 * @returns {boolean} `true` if the identifier is used in the segment.
			 */
			function isIdentifierUsedInSegment(segment, identifier) {
				const segmentInfo = target.segments[segment.id];

				return (
					segmentInfo.first &amp;&amp;
					segmentInfo.last &amp;&amp;
					segmentInfo.first.range[0] &lt;= identifier.range[0] &amp;&amp;
					identifier.range[1] &lt;= segmentInfo.last.range[1]
				);
			}

			/**
			 * Verifies whether the given assignment info is an used assignment.
			 * Report if it is an unused assignment.
			 * @param {AssignmentInfo} targetAssignment The assignment info to verify.
			 * @param {AssignmentInfo[]} allAssignments The list of all assignment info for variables.
			 * @returns {void}
			 */
			function verifyAssignmentIsUsed(targetAssignment, allAssignments) {
				// Skip assignment if it is in a try block.
				const isAssignmentInTryBlock = target.tryStatementBlocks.some(
					tryBlock =&gt;
						tryBlock.range[0] &lt;=
							targetAssignment.identifier.range[0] &amp;&amp;
						targetAssignment.identifier.range[1] &lt;=
							tryBlock.range[1],
				);

				if (isAssignmentInTryBlock) {
					return;
				}

				/**
				 * @typedef {Object} SubsequentSegmentData
				 * @property {CodePathSegment} segment The code path segment
				 * @property {AssignmentInfo} [assignment] The first occurrence of the assignment within the segment.
				 * There is no need to check if the variable is used after this assignment,
				 * as the value it was assigned will be used.
				 */

				/**
				 * Information used in `getSubsequentSegments()`.
				 * To avoid unnecessary iterations, cache information that has already been iterated over,
				 * and if additional iterations are needed, start iterating from the retained position.
				 */
				const subsequentSegmentData = {
					/**
					 * Cache of subsequent segment information list that have already been iterated.
					 * @type {SubsequentSegmentData[]}
					 */
					results: [],

					/**
					 * Subsequent segments that have already been iterated on. Used to avoid infinite loops.
					 * @type {Set&lt;CodePathSegment&gt;}
					 */
					subsequentSegments: new Set(),

					/**
					 * Unexplored code path segment.
					 * If additional iterations are needed, consume this information and iterate.
					 * @type {CodePathSegment[]}
					 */
					queueSegments: targetAssignment.segments.flatMap(
						segment =&gt; segment.nextSegments,
					),
				};

				/**
				 * Gets the subsequent segments from the segment of
				 * the assignment currently being validated (targetAssignment).
				 * @returns {Iterable&lt;SubsequentSegmentData&gt;} the subsequent segments
				 */
				function* getSubsequentSegments() {
					yield* subsequentSegmentData.results;

					while (subsequentSegmentData.queueSegments.length &gt; 0) {
						const nextSegment =
							subsequentSegmentData.queueSegments.shift();

						if (
							subsequentSegmentData.subsequentSegments.has(
								nextSegment,
							)
						) {
							continue;
						}
						subsequentSegmentData.subsequentSegments.add(
							nextSegment,
						);

						const assignmentInSegment = allAssignments.find(
							otherAssignment =&gt;
								otherAssignment.segments.includes(
									nextSegment,
								) &amp;&amp;
								!isIdentifierUsedBetweenAssignedAndEqualSign(
									otherAssignment,
									targetAssignment.identifier,
								),
						);

						if (!assignmentInSegment) {
							/*
							 * Stores the next segment to explore.
							 * If `assignmentInSegment` exists,
							 * we are guarding it because we don&#039;t need to explore the next segment.
							 */
							subsequentSegmentData.queueSegments.push(
								...nextSegment.nextSegments,
							);
						}

						/** @type {SubsequentSegmentData} */
						const result = {
							segment: nextSegment,
							assignment: assignmentInSegment,
						};

						subsequentSegmentData.results.push(result);
						yield result;
					}
				}

				if (
					targetAssignment.variable.references.some(
						ref =&gt; ref.identifier.type !== &quot;Identifier&quot;,
					)
				) {
					/**
					 * Skip checking for a variable that has at least one non-identifier reference.
					 * It&#039;s generated by plugins and cannot be handled reliably in the core rule.
					 */
					return;
				}

				const readReferences =
					targetAssignment.variable.references.filter(reference =&gt;
						reference.isRead(),
					);

				if (!readReferences.length) {
					/*
					 * It is not just an unnecessary assignment, but an unnecessary (unused) variable
					 * and thus should not be reported by this rule because it is reported by `no-unused-vars`.
					 */
					return;
				}

				/**
				 * Other assignment on the current segment and after current assignment.
				 */
				const otherAssignmentAfterTargetAssignment =
					allAssignments.find(assignment =&gt; {
						if (
							assignment === targetAssignment ||
							(assignment.segments.length &amp;&amp;
								assignment.segments.every(
									segment =&gt;
										!targetAssignment.segments.includes(
											segment,
										),
								))
						) {
							return false;
						}
						if (
							isIdentifierEvaluatedAfterAssignment(
								targetAssignment,
								assignment.identifier,
							)
						) {
							return true;
						}
						if (
							assignment.expression &amp;&amp;
							assignment.expression.range[0] &lt;=
								targetAssignment.identifier.range[0] &amp;&amp;
							targetAssignment.identifier.range[1] &lt;=
								assignment.expression.range[1]
						) {
							/*
							 * The target assignment is in an expression that is evaluated before the assignment.
							 * e.g. x=(x=1);
							 *         ^^^ targetAssignment
							 *      ^^^^^^^ assignment
							 */
							return true;
						}

						return false;
					});

				for (const reference of readReferences) {
					/*
					 * If the scope of the reference is outside the current code path scope,
					 * we cannot track whether this assignment is not used.
					 * For example, it can also be called asynchronously.
					 */
					if (
						target.scope !== getCodePathStartScope(reference.from)
					) {
						return;
					}

					// Checks if it is used in the same segment as the target assignment.
					if (
						isIdentifierEvaluatedAfterAssignment(
							targetAssignment,
							reference.identifier,
						) &amp;&amp;
						(isIdentifierUsedBetweenAssignedAndEqualSign(
							targetAssignment,
							reference.identifier,
						) ||
							targetAssignment.segments.some(segment =&gt;
								isIdentifierUsedInSegment(
									segment,
									reference.identifier,
								),
							))
					) {
						if (
							otherAssignmentAfterTargetAssignment &amp;&amp;
							isIdentifierEvaluatedAfterAssignment(
								otherAssignmentAfterTargetAssignment,
								reference.identifier,
							)
						) {
							// There was another assignment before the reference. Therefore, it has not been used yet.
							continue;
						}

						// Uses in statements after the written identifier.
						return;
					}

					if (otherAssignmentAfterTargetAssignment) {
						/*
						 * The assignment was followed by another assignment in the same segment.
						 * Therefore, there is no need to check the next segment.
						 */
						continue;
					}

					// Check subsequent segments.
					for (const subsequentSegment of getSubsequentSegments()) {
						if (
							isIdentifierUsedInSegment(
								subsequentSegment.segment,
								reference.identifier,
							)
						) {
							if (
								subsequentSegment.assignment &amp;&amp;
								isIdentifierEvaluatedAfterAssignment(
									subsequentSegment.assignment,
									reference.identifier,
								)
							) {
								// There was another assignment before the reference. Therefore, it has not been used yet.
								continue;
							}

							// It is used
							return;
						}
					}
				}
				context.report({
					node: targetAssignment.identifier,
					messageId: &quot;unnecessaryAssignment&quot;,
				});
			}

			// Verify that each assignment in the code path is used.
			for (const assignments of target.assignments.values()) {
				assignments.sort(
					(a, b) =&gt; a.identifier.range[0] - b.identifier.range[0],
				);
				for (const assignment of assignments) {
					verifyAssignmentIsUsed(assignment, assignments);
				}
			}
		}

		return {
			onCodePathStart(codePath, node) {
				const scope = sourceCode.getScope(node);

				scopeStack = {
					upper: scopeStack,
					codePath,
					scope,
					segments: Object.create(null),
					currentSegments: new Set(),
					assignments: new Map(),
					tryStatementBlocks: [],
				};
				codePathStartScopes.add(scopeStack.scope);
			},
			onCodePathEnd() {
				verify(scopeStack);

				scopeStack = scopeStack.upper;
			},
			onCodePathSegmentStart(segment) {
				const segmentInfo = { segment, first: null, last: null };

				scopeStack.segments[segment.id] = segmentInfo;
				scopeStack.currentSegments.add(segment);
			},
			onCodePathSegmentEnd(segment) {
				scopeStack.currentSegments.delete(segment);
			},
			TryStatement(node) {
				scopeStack.tryStatementBlocks.push(node.block);
			},
			Identifier(node) {
				for (const segment of scopeStack.currentSegments) {
					const segmentInfo = scopeStack.segments[segment.id];

					if (!segmentInfo.first) {
						segmentInfo.first = node;
					}
					segmentInfo.last = node;
				}
			},
			&quot;:matches(VariableDeclarator[init!=null], AssignmentExpression, UpdateExpression):exit&quot;(
				node,
			) {
				if (scopeStack.currentSegments.size === 0) {
					// Ignore unreachable segments
					return;
				}

				const assignments = scopeStack.assignments;

				let pattern;
				let expression = null;

				if (node.type === &quot;VariableDeclarator&quot;) {
					pattern = node.id;
					expression = node.init;
				} else if (node.type === &quot;AssignmentExpression&quot;) {
					pattern = node.left;
					expression = node.right;
				} else {
					// UpdateExpression
					pattern = node.argument;
				}

				for (const identifier of extractIdentifiersFromPattern(
					pattern,
				)) {
					const scope = sourceCode.getScope(identifier);

					/** @type {Variable} */
					const variable = findVariable(scope, identifier);

					if (!variable) {
						continue;
					}

					// We don&#039;t know where global variables are used.
					if (
						variable.scope.type === &quot;global&quot; &amp;&amp;
						variable.defs.length === 0
					) {
						continue;
					}

					/*
					 * If the scope of the variable is outside the current code path scope,
					 * we cannot track whether this assignment is not used.
					 */
					if (
						scopeStack.scope !==
						getCodePathStartScope(variable.scope)
					) {
						continue;
					}

					// Variables marked by `markVariableAsUsed()` or
					// exported by &quot;exported&quot; block comment.
					if (variable.eslintUsed) {
						continue;
					}

					// Variables exported by ESM export syntax
					if (variable.scope.type === &quot;module&quot;) {
						if (
							variable.defs.some(
								def =&gt;
									(def.type === &quot;Variable&quot; &amp;&amp;
										def.parent.parent.type ===
											&quot;ExportNamedDeclaration&quot;) ||
									(def.type === &quot;FunctionName&quot; &amp;&amp;
										(def.node.parent.type ===
											&quot;ExportNamedDeclaration&quot; ||
											def.node.parent.type ===
												&quot;ExportDefaultDeclaration&quot;)) ||
									(def.type === &quot;ClassName&quot; &amp;&amp;
										(def.node.parent.type ===
											&quot;ExportNamedDeclaration&quot; ||
											def.node.parent.type ===
												&quot;ExportDefaultDeclaration&quot;)),
							)
						) {
							continue;
						}
						if (
							variable.references.some(
								reference =&gt;
									reference.identifier.parent.type ===
									&quot;ExportSpecifier&quot;,
							)
						) {
							// It have `export { ... }` reference.
							continue;
						}
					}

					let list = assignments.get(variable);

					if (!list) {
						list = [];
						assignments.set(variable, list);
					}
					list.push({
						variable,
						identifier,
						node,
						expression,
						segments: [...scopeStack.currentSegments],
					});
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
