<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sharp/lib/resize.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sharp/lib/resize.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">583</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">48.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2013 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0

&#039;use strict&#039;;

const is = require(&#039;./is&#039;);

/**
 * Weighting to apply when using contain/cover fit.
 * @member
 * @private
 */
const gravity = {
  center: 0,
  centre: 0,
  north: 1,
  east: 2,
  south: 3,
  west: 4,
  northeast: 5,
  southeast: 6,
  southwest: 7,
  northwest: 8
};

/**
 * Position to apply when using contain/cover fit.
 * @member
 * @private
 */
const position = {
  top: 1,
  right: 2,
  bottom: 3,
  left: 4,
  &#039;right top&#039;: 5,
  &#039;right bottom&#039;: 6,
  &#039;left bottom&#039;: 7,
  &#039;left top&#039;: 8
};

/**
 * How to extend the image.
 * @member
 * @private
 */
const extendWith = {
  background: &#039;background&#039;,
  copy: &#039;copy&#039;,
  repeat: &#039;repeat&#039;,
  mirror: &#039;mirror&#039;
};

/**
 * Strategies for automagic cover behaviour.
 * @member
 * @private
 */
const strategy = {
  entropy: 16,
  attention: 17
};

/**
 * Reduction kernels.
 * @member
 * @private
 */
const kernel = {
  nearest: &#039;nearest&#039;,
  cubic: &#039;cubic&#039;,
  mitchell: &#039;mitchell&#039;,
  lanczos2: &#039;lanczos2&#039;,
  lanczos3: &#039;lanczos3&#039;
};

/**
 * Methods by which an image can be resized to fit the provided dimensions.
 * @member
 * @private
 */
const fit = {
  contain: &#039;contain&#039;,
  cover: &#039;cover&#039;,
  fill: &#039;fill&#039;,
  inside: &#039;inside&#039;,
  outside: &#039;outside&#039;
};

/**
 * Map external fit property to internal canvas property.
 * @member
 * @private
 */
const mapFitToCanvas = {
  contain: &#039;embed&#039;,
  cover: &#039;crop&#039;,
  fill: &#039;ignore_aspect&#039;,
  inside: &#039;max&#039;,
  outside: &#039;min&#039;
};

/**
 * @private
 */
function isRotationExpected (options) {
  return (options.angle % 360) !== 0 || options.useExifOrientation === true || options.rotationAngle !== 0;
}

/**
 * @private
 */
function isResizeExpected (options) {
  return options.width !== -1 || options.height !== -1;
}

/**
 * Resize image to `width`, `height` or `width x height`.
 *
 * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:
 * - `cover`: (default) Preserving aspect ratio, attempt to ensure the image covers both provided dimensions by cropping/clipping to fit.
 * - `contain`: Preserving aspect ratio, contain within both provided dimensions using &quot;letterboxing&quot; where necessary.
 * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.
 * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.
 * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.
 *
 * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.
 *
 * &lt;img alt=&quot;Examples of various values for the fit property when resizing&quot; width=&quot;100%&quot; style=&quot;aspect-ratio: 998/243&quot; src=&quot;https://cdn.jsdelivr.net/gh/lovell/sharp@main/docs/image/api-resize-fit.svg&quot;&gt;
 *
 * When using a **fit** of `cover` or `contain`, the default **position** is `centre`. Other options are:
 * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.
 * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.
 * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.
 *
 * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.
 *
 * The experimental strategy-based approach resizes so one dimension is at its target length
 * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.
 * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).
 * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.
 *
 * Possible interpolation kernels are:
 * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).
 * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).
 * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).
 * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.
 * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).
 *
 * Only one resize can occur per pipeline.
 * Previous calls to `resize` in the same pipeline will be ignored.
 *
 * @example
 * sharp(input)
 *   .resize({ width: 100 })
 *   .toBuffer()
 *   .then(data =&gt; {
 *     // 100 pixels wide, auto-scaled height
 *   });
 *
 * @example
 * sharp(input)
 *   .resize({ height: 100 })
 *   .toBuffer()
 *   .then(data =&gt; {
 *     // 100 pixels high, auto-scaled width
 *   });
 *
 * @example
 * sharp(input)
 *   .resize(200, 300, {
 *     kernel: sharp.kernel.nearest,
 *     fit: &#039;contain&#039;,
 *     position: &#039;right top&#039;,
 *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }
 *   })
 *   .toFile(&#039;output.png&#039;)
 *   .then(() =&gt; {
 *     // output.png is a 200 pixels wide and 300 pixels high image
 *     // containing a nearest-neighbour scaled version
 *     // contained within the north-east corner of a semi-transparent white canvas
 *   });
 *
 * @example
 * const transformer = sharp()
 *   .resize({
 *     width: 200,
 *     height: 200,
 *     fit: sharp.fit.cover,
 *     position: sharp.strategy.entropy
 *   });
 * // Read image data from readableStream
 * // Write 200px square auto-cropped image data to writableStream
 * readableStream
 *   .pipe(transformer)
 *   .pipe(writableStream);
 *
 * @example
 * sharp(input)
 *   .resize(200, 200, {
 *     fit: sharp.fit.inside,
 *     withoutEnlargement: true
 *   })
 *   .toFormat(&#039;jpeg&#039;)
 *   .toBuffer()
 *   .then(function(outputBuffer) {
 *     // outputBuffer contains JPEG image data
 *     // no wider and no higher than 200 pixels
 *     // and no larger than the input image
 *   });
 *
 * @example
 * sharp(input)
 *   .resize(200, 200, {
 *     fit: sharp.fit.outside,
 *     withoutReduction: true
 *   })
 *   .toFormat(&#039;jpeg&#039;)
 *   .toBuffer()
 *   .then(function(outputBuffer) {
 *     // outputBuffer contains JPEG image data
 *     // of at least 200 pixels wide and 200 pixels high while maintaining aspect ratio
 *     // and no smaller than the input image
 *   });
 *
 * @example
 * const scaleByHalf = await sharp(input)
 *   .metadata()
 *   .then(({ width }) =&gt; sharp(input)
 *     .resize(Math.round(width * 0.5))
 *     .toBuffer()
 *   );
 *
 * @param {number} [width] - How many pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.
 * @param {number} [height] - How many pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.
 * @param {Object} [options]
 * @param {number} [options.width] - An alternative means of specifying `width`. If both are present this takes priority.
 * @param {number} [options.height] - An alternative means of specifying `height`. If both are present this takes priority.
 * @param {String} [options.fit=&#039;cover&#039;] - How the image should be resized/cropped to fit the target dimension(s), one of `cover`, `contain`, `fill`, `inside` or `outside`.
 * @param {String} [options.position=&#039;centre&#039;] - A position, gravity or strategy to use when `fit` is `cover` or `contain`.
 * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when `fit` is `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.
 * @param {String} [options.kernel=&#039;lanczos3&#039;] - The kernel to use for image reduction. Use the `fastShrinkOnLoad` option to control kernel vs shrink-on-load.
 * @param {Boolean} [options.withoutEnlargement=false] - Do not scale up if the width *or* height are already less than the target dimensions, equivalent to GraphicsMagick&#039;s `&gt;` geometry option. This may result in output dimensions smaller than the target dimensions.
 * @param {Boolean} [options.withoutReduction=false] - Do not scale down if the width *or* height are already greater than the target dimensions, equivalent to GraphicsMagick&#039;s `&lt;` geometry option. This may still result in a crop to reach the target dimensions.
 * @param {Boolean} [options.fastShrinkOnLoad=true] - Take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moir√© pattern or round-down of an auto-scaled dimension.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */
function resize (widthOrOptions, height, options) {
  if (isResizeExpected(this.options)) {
    this.options.debuglog(&#039;ignoring previous resize options&#039;);
  }
  if (is.defined(widthOrOptions)) {
    if (is.object(widthOrOptions) &amp;&amp; !is.defined(options)) {
      options = widthOrOptions;
    } else if (is.integer(widthOrOptions) &amp;&amp; widthOrOptions &gt; 0) {
      this.options.width = widthOrOptions;
    } else {
      throw is.invalidParameterError(&#039;width&#039;, &#039;positive integer&#039;, widthOrOptions);
    }
  } else {
    this.options.width = -1;
  }
  if (is.defined(height)) {
    if (is.integer(height) &amp;&amp; height &gt; 0) {
      this.options.height = height;
    } else {
      throw is.invalidParameterError(&#039;height&#039;, &#039;positive integer&#039;, height);
    }
  } else {
    this.options.height = -1;
  }
  if (is.object(options)) {
    // Width
    if (is.defined(options.width)) {
      if (is.integer(options.width) &amp;&amp; options.width &gt; 0) {
        this.options.width = options.width;
      } else {
        throw is.invalidParameterError(&#039;width&#039;, &#039;positive integer&#039;, options.width);
      }
    }
    // Height
    if (is.defined(options.height)) {
      if (is.integer(options.height) &amp;&amp; options.height &gt; 0) {
        this.options.height = options.height;
      } else {
        throw is.invalidParameterError(&#039;height&#039;, &#039;positive integer&#039;, options.height);
      }
    }
    // Fit
    if (is.defined(options.fit)) {
      const canvas = mapFitToCanvas[options.fit];
      if (is.string(canvas)) {
        this.options.canvas = canvas;
      } else {
        throw is.invalidParameterError(&#039;fit&#039;, &#039;valid fit&#039;, options.fit);
      }
    }
    // Position
    if (is.defined(options.position)) {
      const pos = is.integer(options.position)
        ? options.position
        : strategy[options.position] || position[options.position] || gravity[options.position];
      if (is.integer(pos) &amp;&amp; (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {
        this.options.position = pos;
      } else {
        throw is.invalidParameterError(&#039;position&#039;, &#039;valid position/gravity/strategy&#039;, options.position);
      }
    }
    // Background
    this._setBackgroundColourOption(&#039;resizeBackground&#039;, options.background);
    // Kernel
    if (is.defined(options.kernel)) {
      if (is.string(kernel[options.kernel])) {
        this.options.kernel = kernel[options.kernel];
      } else {
        throw is.invalidParameterError(&#039;kernel&#039;, &#039;valid kernel name&#039;, options.kernel);
      }
    }
    // Without enlargement
    if (is.defined(options.withoutEnlargement)) {
      this._setBooleanOption(&#039;withoutEnlargement&#039;, options.withoutEnlargement);
    }
    // Without reduction
    if (is.defined(options.withoutReduction)) {
      this._setBooleanOption(&#039;withoutReduction&#039;, options.withoutReduction);
    }
    // Shrink on load
    if (is.defined(options.fastShrinkOnLoad)) {
      this._setBooleanOption(&#039;fastShrinkOnLoad&#039;, options.fastShrinkOnLoad);
    }
  }
  if (isRotationExpected(this.options) &amp;&amp; isResizeExpected(this.options)) {
    this.options.rotateBeforePreExtract = true;
  }
  return this;
}

/**
 * Extend / pad / extrude one or more edges of the image with either
 * the provided background colour or pixels derived from the image.
 * This operation will always occur after resizing and extraction, if any.
 *
 * @example
 * // Resize to 140 pixels wide, then add 10 transparent pixels
 * // to the top, left and right edges and 20 to the bottom edge
 * sharp(input)
 *   .resize(140)
 *   .extend({
 *     top: 10,
 *     bottom: 20,
 *     left: 10,
 *     right: 10,
 *     background: { r: 0, g: 0, b: 0, alpha: 0 }
 *   })
 *   ...
 *
* @example
 * // Add a row of 10 red pixels to the bottom
 * sharp(input)
 *   .extend({
 *     bottom: 10,
 *     background: &#039;red&#039;
 *   })
 *   ...
 *
 * @example
 * // Extrude image by 8 pixels to the right, mirroring existing right hand edge
 * sharp(input)
 *   .extend({
 *     right: 8,
 *     background: &#039;mirror&#039;
 *   })
 *   ...
 *
 * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts
 * @param {number} [extend.top=0]
 * @param {number} [extend.left=0]
 * @param {number} [extend.bottom=0]
 * @param {number} [extend.right=0]
 * @param {String} [extend.extendWith=&#039;background&#039;] - populate new pixels using this method, one of: background, copy, repeat, mirror.
 * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
*/
function extend (extend) {
  if (is.integer(extend) &amp;&amp; extend &gt; 0) {
    this.options.extendTop = extend;
    this.options.extendBottom = extend;
    this.options.extendLeft = extend;
    this.options.extendRight = extend;
  } else if (is.object(extend)) {
    if (is.defined(extend.top)) {
      if (is.integer(extend.top) &amp;&amp; extend.top &gt;= 0) {
        this.options.extendTop = extend.top;
      } else {
        throw is.invalidParameterError(&#039;top&#039;, &#039;positive integer&#039;, extend.top);
      }
    }
    if (is.defined(extend.bottom)) {
      if (is.integer(extend.bottom) &amp;&amp; extend.bottom &gt;= 0) {
        this.options.extendBottom = extend.bottom;
      } else {
        throw is.invalidParameterError(&#039;bottom&#039;, &#039;positive integer&#039;, extend.bottom);
      }
    }
    if (is.defined(extend.left)) {
      if (is.integer(extend.left) &amp;&amp; extend.left &gt;= 0) {
        this.options.extendLeft = extend.left;
      } else {
        throw is.invalidParameterError(&#039;left&#039;, &#039;positive integer&#039;, extend.left);
      }
    }
    if (is.defined(extend.right)) {
      if (is.integer(extend.right) &amp;&amp; extend.right &gt;= 0) {
        this.options.extendRight = extend.right;
      } else {
        throw is.invalidParameterError(&#039;right&#039;, &#039;positive integer&#039;, extend.right);
      }
    }
    this._setBackgroundColourOption(&#039;extendBackground&#039;, extend.background);
    if (is.defined(extend.extendWith)) {
      if (is.string(extendWith[extend.extendWith])) {
        this.options.extendWith = extendWith[extend.extendWith];
      } else {
        throw is.invalidParameterError(&#039;extendWith&#039;, &#039;one of: background, copy, repeat, mirror&#039;, extend.extendWith);
      }
    }
  } else {
    throw is.invalidParameterError(&#039;extend&#039;, &#039;integer or object&#039;, extend);
  }
  return this;
}

/**
 * Extract/crop a region of the image.
 *
 * - Use `extract` before `resize` for pre-resize extraction.
 * - Use `extract` after `resize` for post-resize extraction.
 * - Use `extract` before and after for both.
 *
 * @example
 * sharp(input)
 *   .extract({ left: left, top: top, width: width, height: height })
 *   .toFile(output, function(err) {
 *     // Extract a region of the input image, saving in the same format.
 *   });
 * @example
 * sharp(input)
 *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })
 *   .resize(width, height)
 *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })
 *   .toFile(output, function(err) {
 *     // Extract a region, resize, then extract from the resized image
 *   });
 *
 * @param {Object} options - describes the region to extract using integral pixel values
 * @param {number} options.left - zero-indexed offset from left edge
 * @param {number} options.top - zero-indexed offset from top edge
 * @param {number} options.width - width of region to extract
 * @param {number} options.height - height of region to extract
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */
function extract (options) {
  const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? &#039;Post&#039; : &#039;Pre&#039;;
  if (this.options[`width${suffix}`] !== -1) {
    this.options.debuglog(&#039;ignoring previous extract options&#039;);
  }
  [&#039;left&#039;, &#039;top&#039;, &#039;width&#039;, &#039;height&#039;].forEach(function (name) {
    const value = options[name];
    if (is.integer(value) &amp;&amp; value &gt;= 0) {
      this.options[name + (name === &#039;left&#039; || name === &#039;top&#039; ? &#039;Offset&#039; : &#039;&#039;) + suffix] = value;
    } else {
      throw is.invalidParameterError(name, &#039;integer&#039;, value);
    }
  }, this);
  // Ensure existing rotation occurs before pre-resize extraction
  if (isRotationExpected(this.options) &amp;&amp; !isResizeExpected(this.options)) {
    if (this.options.widthPre === -1 || this.options.widthPost === -1) {
      this.options.rotateBeforePreExtract = true;
    }
  }
  return this;
}

/**
 * Trim pixels from all edges that contain values similar to the given background colour, which defaults to that of the top-left pixel.
 *
 * Images with an alpha channel will use the combined bounding box of alpha and non-alpha channels.
 *
 * If the result of this operation would trim an image to nothing then no change is made.
 *
 * The `info` response Object, obtained from callback of `.toFile()` or `.toBuffer()`,
 * will contain `trimOffsetLeft` and `trimOffsetTop` properties.
 *
 * @example
 * // Trim pixels with a colour similar to that of the top-left pixel.
 * sharp(input)
 *   .trim()
 *   .toFile(output, function(err, info) {
 *     ...
 *   });
 * @example
 * // Trim pixels with the exact same colour as that of the top-left pixel.
 * sharp(input)
 *   .trim(0)
 *   .toFile(output, function(err, info) {
 *     ...
 *   });
 * @example
 * // Trim only pixels with a similar colour to red.
 * sharp(input)
 *   .trim(&quot;#FF0000&quot;)
 *   .toFile(output, function(err, info) {
 *     ...
 *   });
 * @example
 * // Trim all &quot;yellow-ish&quot; pixels, being more lenient with the higher threshold.
 * sharp(input)
 *   .trim({
 *     background: &quot;yellow&quot;,
 *     threshold: 42,
 *   })
 *   .toFile(output, function(err, info) {
 *     ...
 *   });
 *
 * @param {string|number|Object} trim - the specific background colour to trim, the threshold for doing so or an Object with both.
 * @param {string|Object} [trim.background=&#039;top-left pixel&#039;] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to that of the top-left pixel.
 * @param {number} [trim.threshold=10] - the allowed difference from the above colour, a positive number.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */
function trim (trim) {
  if (!is.defined(trim)) {
    this.options.trimThreshold = 10;
  } else if (is.string(trim)) {
    this._setBackgroundColourOption(&#039;trimBackground&#039;, trim);
    this.options.trimThreshold = 10;
  } else if (is.number(trim)) {
    if (trim &gt;= 0) {
      this.options.trimThreshold = trim;
    } else {
      throw is.invalidParameterError(&#039;threshold&#039;, &#039;positive number&#039;, trim);
    }
  } else if (is.object(trim)) {
    this._setBackgroundColourOption(&#039;trimBackground&#039;, trim.background);
    if (!is.defined(trim.threshold)) {
      this.options.trimThreshold = 10;
    } else if (is.number(trim.threshold) &amp;&amp; trim.threshold &gt;= 0) {
      this.options.trimThreshold = trim.threshold;
    } else {
      throw is.invalidParameterError(&#039;threshold&#039;, &#039;positive number&#039;, trim);
    }
  } else {
    throw is.invalidParameterError(&#039;trim&#039;, &#039;string, number or object&#039;, trim);
  }
  if (isRotationExpected(this.options)) {
    this.options.rotateBeforePreExtract = true;
  }
  return this;
}

/**
 * Decorate the Sharp prototype with resize-related functions.
 * @private
 */
module.exports = function (Sharp) {
  Object.assign(Sharp.prototype, {
    resize,
    extend,
    extract,
    trim
  });
  // Class attributes
  Sharp.gravity = gravity;
  Sharp.strategy = strategy;
  Sharp.kernel = kernel;
  Sharp.fit = fit;
  Sharp.position = position;
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
