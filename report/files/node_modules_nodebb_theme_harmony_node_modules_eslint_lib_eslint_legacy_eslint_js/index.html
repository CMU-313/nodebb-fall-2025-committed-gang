<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/eslint/legacy-eslint.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/eslint/legacy-eslint.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">787</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">64.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Main API Class
 * @author Kai Cataldo
 * @author Toru Nagashima
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const path = require(&quot;node:path&quot;);
const fs = require(&quot;node:fs&quot;);
const { promisify } = require(&quot;node:util&quot;);
const {
	CLIEngine,
	getCLIEngineInternalSlots,
} = require(&quot;../cli-engine/cli-engine&quot;);
const BuiltinRules = require(&quot;../rules&quot;);
const {
	Legacy: {
		ConfigOps: { getRuleSeverity },
	},
} = require(&quot;@eslint/eslintrc&quot;);
const { version } = require(&quot;../../package.json&quot;);

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @typedef {import(&quot;../cli-engine/cli-engine&quot;).LintReport} CLIEngineLintReport */
/** @typedef {import(&quot;../types&quot;).ESLint.ConfigData} ConfigData */
/** @typedef {import(&quot;../types&quot;).ESLint.DeprecatedRuleUse} DeprecatedRuleInfo */
/** @typedef {import(&quot;../types&quot;).Linter.LintMessage} LintMessage */
/** @typedef {import(&quot;../types&quot;).ESLint.LintResult} LintResult */
/** @typedef {import(&quot;../types&quot;).ESLint.Plugin} Plugin */
/** @typedef {import(&quot;../types&quot;).ESLint.ResultsMeta} ResultsMeta */
/** @typedef {import(&quot;../types&quot;).Rule.RuleModule} Rule */
/** @typedef {import(&quot;../types&quot;).Linter.SuppressedLintMessage} SuppressedLintMessage */

/**
 * The main formatter object.
 * @typedef LoadedFormatter
 * @property {(results: LintResult[], resultsMeta: ResultsMeta) =&gt; string | Promise&lt;string&gt;} format format function.
 */

/**
 * The options with which to configure the LegacyESLint instance.
 * @typedef {Object} LegacyESLintOptions
 * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.
 * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance
 * @property {boolean} [cache] Enable result caching.
 * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.
 * @property {&quot;metadata&quot; | &quot;content&quot;} [cacheStrategy] The strategy used to detect changed files.
 * @property {string} [cwd] The value to use for the current working directory.
 * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn&#039;t throw even if no target files found. Defaults to `true`.
 * @property {string[]} [extensions] An array of file extensions to check.
 * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.
 * @property {string[]} [fixTypes] Array of rule types to apply fixes for.
 * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean} [ignore] False disables use of .eslintignore.
 * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.
 * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance
 * @property {string} [overrideConfigFile] The configuration file to use.
 * @property {Record&lt;string,Plugin&gt;|null} [plugins] Preloaded plugins. This is a map-like object, keys are plugin IDs and each value is implementation.
 * @property {&quot;error&quot; | &quot;warn&quot; | &quot;off&quot;} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.
 * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.
 * @property {string[]} [rulePaths] An array of directories to load custom rules from.
 * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.
 * @property {boolean} [passOnNoPatterns=false] When set to true, missing patterns cause
 *      the linting operation to short circuit and not report any failures.
 */

/**
 * A rules metadata object.
 * @typedef {Object} RulesMeta
 * @property {string} id The plugin ID.
 * @property {Object} definition The plugin definition.
 */

/**
 * Private members for the `ESLint` instance.
 * @typedef {Object} ESLintPrivateMembers
 * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.
 * @property {LegacyESLintOptions} options The options used to instantiate the ESLint instance.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const writeFile = promisify(fs.writeFile);

/**
 * The map with which to store private class members.
 * @type {WeakMap&lt;ESLint, ESLintPrivateMembers&gt;}
 */
const privateMembersMap = new WeakMap();

/**
 * Check if a given value is a non-empty string or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is a non-empty string.
 */
function isNonEmptyString(value) {
	return typeof value === &quot;string&quot; &amp;&amp; value.trim() !== &quot;&quot;;
}

/**
 * Check if a given value is an array of non-empty strings or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is an array of non-empty strings.
 */
function isArrayOfNonEmptyString(value) {
	return (
		Array.isArray(value) &amp;&amp; value.length &amp;&amp; value.every(isNonEmptyString)
	);
}

/**
 * Check if a given value is an empty array or an array of non-empty strings.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is an empty array or an array of non-empty
 *      strings.
 */
function isEmptyArrayOrArrayOfNonEmptyString(value) {
	return Array.isArray(value) &amp;&amp; value.every(isNonEmptyString);
}

/**
 * Check if a given value is a valid fix type or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is valid fix type.
 */
function isFixType(value) {
	return (
		value === &quot;directive&quot; ||
		value === &quot;problem&quot; ||
		value === &quot;suggestion&quot; ||
		value === &quot;layout&quot;
	);
}

/**
 * Check if a given value is an array of fix types or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is an array of fix types.
 */
function isFixTypeArray(value) {
	return Array.isArray(value) &amp;&amp; value.every(isFixType);
}

/**
 * The error for invalid options.
 */
class ESLintInvalidOptionsError extends Error {
	constructor(messages) {
		super(`Invalid Options:\n- ${messages.join(&quot;\n- &quot;)}`);
		this.code = &quot;ESLINT_INVALID_OPTIONS&quot;;
		Error.captureStackTrace(this, ESLintInvalidOptionsError);
	}
}

/**
 * Validates and normalizes options for the wrapped CLIEngine instance.
 * @param {LegacyESLintOptions} options The options to process.
 * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.
 * @returns {LegacyESLintOptions} The normalized options.
 */
function processOptions({
	allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.
	baseConfig = null,
	cache = false,
	cacheLocation = &quot;.eslintcache&quot;,
	cacheStrategy = &quot;metadata&quot;,
	cwd = process.cwd(),
	errorOnUnmatchedPattern = true,
	extensions = null, // ← should be null by default because if it&#039;s an array then it suppresses RFC20 feature.
	fix = false,
	fixTypes = null, // ← should be null by default because if it&#039;s an array then it suppresses rules that don&#039;t have the `meta.type` property.
	flags /* eslint-disable-line no-unused-vars -- leaving for compatibility with ESLint#hasFlag */,
	globInputPaths = true,
	ignore = true,
	ignorePath = null, // ← should be null by default because if it&#039;s a string then it may throw ENOENT.
	overrideConfig = null,
	overrideConfigFile = null,
	plugins = {},
	reportUnusedDisableDirectives = null, // ← should be null by default because if it&#039;s a string then it overrides the &#039;reportUnusedDisableDirectives&#039; setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.
	resolvePluginsRelativeTo = null, // ← should be null by default because if it&#039;s a string then it suppresses RFC47 feature.
	rulePaths = [],
	useEslintrc = true,
	passOnNoPatterns = false,
	...unknownOptions
}) {
	const errors = [];
	const unknownOptionKeys = Object.keys(unknownOptions);

	if (unknownOptionKeys.length &gt;= 1) {
		errors.push(`Unknown options: ${unknownOptionKeys.join(&quot;, &quot;)}`);
		if (unknownOptionKeys.includes(&quot;cacheFile&quot;)) {
			errors.push(
				&quot;&#039;cacheFile&#039; has been removed. Please use the &#039;cacheLocation&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;configFile&quot;)) {
			errors.push(
				&quot;&#039;configFile&#039; has been removed. Please use the &#039;overrideConfigFile&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;envs&quot;)) {
			errors.push(
				&quot;&#039;envs&#039; has been removed. Please use the &#039;overrideConfig.env&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;globals&quot;)) {
			errors.push(
				&quot;&#039;globals&#039; has been removed. Please use the &#039;overrideConfig.globals&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;ignorePattern&quot;)) {
			errors.push(
				&quot;&#039;ignorePattern&#039; has been removed. Please use the &#039;overrideConfig.ignorePatterns&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;parser&quot;)) {
			errors.push(
				&quot;&#039;parser&#039; has been removed. Please use the &#039;overrideConfig.parser&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;parserOptions&quot;)) {
			errors.push(
				&quot;&#039;parserOptions&#039; has been removed. Please use the &#039;overrideConfig.parserOptions&#039; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;rules&quot;)) {
			errors.push(
				&quot;&#039;rules&#039; has been removed. Please use the &#039;overrideConfig.rules&#039; option instead.&quot;,
			);
		}
	}
	if (typeof allowInlineConfig !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;allowInlineConfig&#039; must be a boolean.&quot;);
	}
	if (typeof baseConfig !== &quot;object&quot;) {
		errors.push(&quot;&#039;baseConfig&#039; must be an object or null.&quot;);
	}
	if (typeof cache !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;cache&#039; must be a boolean.&quot;);
	}
	if (!isNonEmptyString(cacheLocation)) {
		errors.push(&quot;&#039;cacheLocation&#039; must be a non-empty string.&quot;);
	}
	if (cacheStrategy !== &quot;metadata&quot; &amp;&amp; cacheStrategy !== &quot;content&quot;) {
		errors.push(&#039;\&#039;cacheStrategy\&#039; must be any of &quot;metadata&quot;, &quot;content&quot;.&#039;);
	}
	if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {
		errors.push(&quot;&#039;cwd&#039; must be an absolute path.&quot;);
	}
	if (typeof errorOnUnmatchedPattern !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;errorOnUnmatchedPattern&#039; must be a boolean.&quot;);
	}
	if (
		!isEmptyArrayOrArrayOfNonEmptyString(extensions) &amp;&amp;
		extensions !== null
	) {
		errors.push(
			&quot;&#039;extensions&#039; must be an array of non-empty strings or null.&quot;,
		);
	}
	if (typeof fix !== &quot;boolean&quot; &amp;&amp; typeof fix !== &quot;function&quot;) {
		errors.push(&quot;&#039;fix&#039; must be a boolean or a function.&quot;);
	}
	if (fixTypes !== null &amp;&amp; !isFixTypeArray(fixTypes)) {
		errors.push(
			&#039;\&#039;fixTypes\&#039; must be an array of any of &quot;directive&quot;, &quot;problem&quot;, &quot;suggestion&quot;, and &quot;layout&quot;.&#039;,
		);
	}
	if (typeof globInputPaths !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;globInputPaths&#039; must be a boolean.&quot;);
	}
	if (typeof ignore !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;ignore&#039; must be a boolean.&quot;);
	}
	if (!isNonEmptyString(ignorePath) &amp;&amp; ignorePath !== null) {
		errors.push(&quot;&#039;ignorePath&#039; must be a non-empty string or null.&quot;);
	}
	if (typeof overrideConfig !== &quot;object&quot;) {
		errors.push(&quot;&#039;overrideConfig&#039; must be an object or null.&quot;);
	}
	if (!isNonEmptyString(overrideConfigFile) &amp;&amp; overrideConfigFile !== null) {
		errors.push(&quot;&#039;overrideConfigFile&#039; must be a non-empty string or null.&quot;);
	}
	if (typeof plugins !== &quot;object&quot;) {
		errors.push(&quot;&#039;plugins&#039; must be an object or null.&quot;);
	} else if (plugins !== null &amp;&amp; Object.keys(plugins).includes(&quot;&quot;)) {
		errors.push(&quot;&#039;plugins&#039; must not include an empty string.&quot;);
	}
	if (Array.isArray(plugins)) {
		errors.push(
			&quot;&#039;plugins&#039; doesn&#039;t add plugins to configuration to load. Please use the &#039;overrideConfig.plugins&#039; option instead.&quot;,
		);
	}
	if (
		reportUnusedDisableDirectives !== &quot;error&quot; &amp;&amp;
		reportUnusedDisableDirectives !== &quot;warn&quot; &amp;&amp;
		reportUnusedDisableDirectives !== &quot;off&quot; &amp;&amp;
		reportUnusedDisableDirectives !== null
	) {
		errors.push(
			&#039;\&#039;reportUnusedDisableDirectives\&#039; must be any of &quot;error&quot;, &quot;warn&quot;, &quot;off&quot;, and null.&#039;,
		);
	}
	if (
		!isNonEmptyString(resolvePluginsRelativeTo) &amp;&amp;
		resolvePluginsRelativeTo !== null
	) {
		errors.push(
			&quot;&#039;resolvePluginsRelativeTo&#039; must be a non-empty string or null.&quot;,
		);
	}
	if (!isEmptyArrayOrArrayOfNonEmptyString(rulePaths)) {
		errors.push(&quot;&#039;rulePaths&#039; must be an array of non-empty strings.&quot;);
	}
	if (typeof useEslintrc !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;useEslintrc&#039; must be a boolean.&quot;);
	}
	if (typeof passOnNoPatterns !== &quot;boolean&quot;) {
		errors.push(&quot;&#039;passOnNoPatterns&#039; must be a boolean.&quot;);
	}

	if (errors.length &gt; 0) {
		throw new ESLintInvalidOptionsError(errors);
	}

	return {
		allowInlineConfig,
		baseConfig,
		cache,
		cacheLocation,
		cacheStrategy,
		configFile: overrideConfigFile,
		cwd: path.normalize(cwd),
		errorOnUnmatchedPattern,
		extensions,
		fix,
		fixTypes,
		flags: [], // LegacyESLint does not support flags, so just ignore them.
		globInputPaths,
		ignore,
		ignorePath,
		reportUnusedDisableDirectives,
		resolvePluginsRelativeTo,
		rulePaths,
		useEslintrc,
		passOnNoPatterns,
	};
}

/**
 * Check if a value has one or more properties and that value is not undefined.
 * @param {any} obj The value to check.
 * @returns {boolean} `true` if `obj` has one or more properties that value is not undefined.
 */
function hasDefinedProperty(obj) {
	if (typeof obj === &quot;object&quot; &amp;&amp; obj !== null) {
		for (const key in obj) {
			if (typeof obj[key] !== &quot;undefined&quot;) {
				return true;
			}
		}
	}
	return false;
}

/**
 * Create rulesMeta object.
 * @param {Map&lt;string,Rule&gt;} rules a map of rules from which to generate the object.
 * @returns {Object} metadata for all enabled rules.
 */
function createRulesMeta(rules) {
	return Array.from(rules).reduce((retVal, [id, rule]) =&gt; {
		retVal[id] = rule.meta;
		return retVal;
	}, {});
}

/** @type {WeakMap&lt;ExtractedConfig, DeprecatedRuleInfo[]&gt;} */
const usedDeprecatedRulesCache = new WeakMap();

/**
 * Create used deprecated rule list.
 * @param {CLIEngine} cliEngine The CLIEngine instance.
 * @param {string} maybeFilePath The absolute path to a lint target file or `&quot;&lt;text&gt;&quot;`.
 * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.
 */
function getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {
	const {
		configArrayFactory,
		options: { cwd },
	} = getCLIEngineInternalSlots(cliEngine);
	const filePath = path.isAbsolute(maybeFilePath)
		? maybeFilePath
		: path.join(cwd, &quot;__placeholder__.js&quot;);
	const configArray = configArrayFactory.getConfigArrayForFile(filePath);
	const config = configArray.extractConfig(filePath);

	// Most files use the same config, so cache it.
	if (!usedDeprecatedRulesCache.has(config)) {
		const pluginRules = configArray.pluginRules;
		const retv = [];

		for (const [ruleId, ruleConf] of Object.entries(config.rules)) {
			if (getRuleSeverity(ruleConf) === 0) {
				continue;
			}
			const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);
			const meta = rule &amp;&amp; rule.meta;

			if (meta &amp;&amp; meta.deprecated) {
				retv.push({ ruleId, replacedBy: meta.replacedBy || [] });
			}
		}

		usedDeprecatedRulesCache.set(config, Object.freeze(retv));
	}

	return usedDeprecatedRulesCache.get(config);
}

/**
 * Processes the linting results generated by a CLIEngine linting report to
 * match the ESLint class&#039;s API.
 * @param {CLIEngine} cliEngine The CLIEngine instance.
 * @param {CLIEngineLintReport} report The CLIEngine linting report to process.
 * @returns {LintResult[]} The processed linting results.
 */
function processCLIEngineLintReport(cliEngine, { results }) {
	const descriptor = {
		configurable: true,
		enumerable: true,
		get() {
			return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);
		},
	};

	for (const result of results) {
		Object.defineProperty(result, &quot;usedDeprecatedRules&quot;, descriptor);
	}

	return results;
}

/**
 * An Array.prototype.sort() compatible compare function to order results by their file path.
 * @param {LintResult} a The first lint result.
 * @param {LintResult} b The second lint result.
 * @returns {number} An integer representing the order in which the two results should occur.
 */
function compareResultsByFilePath(a, b) {
	if (a.filePath &lt; b.filePath) {
		return -1;
	}

	if (a.filePath &gt; b.filePath) {
		return 1;
	}

	return 0;
}

/**
 * Main API.
 */
class LegacyESLint {
	/**
	 * The type of configuration used by this class.
	 * @type {string}
	 */
	static configType = &quot;eslintrc&quot;;

	/**
	 * Creates a new instance of the main ESLint API.
	 * @param {LegacyESLintOptions} options The options for this instance.
	 */
	constructor(options = {}) {
		const processedOptions = processOptions(options);
		const cliEngine = new CLIEngine(processedOptions, {
			preloadedPlugins: options.plugins,
		});
		const { configArrayFactory, lastConfigArrays } =
			getCLIEngineInternalSlots(cliEngine);
		let updated = false;

		/*
		 * Address `overrideConfig` to set override config.
		 * Operate the `configArrayFactory` internal slot directly because this
		 * functionality doesn&#039;t exist as the public API of CLIEngine.
		 */
		if (hasDefinedProperty(options.overrideConfig)) {
			configArrayFactory.setOverrideConfig(options.overrideConfig);
			updated = true;
		}

		// Update caches.
		if (updated) {
			configArrayFactory.clearCache();
			lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();
		}

		// Initialize private properties.
		privateMembersMap.set(this, {
			cliEngine,
			options: processedOptions,
		});
	}

	/**
	 * The version text.
	 * @type {string}
	 */
	static get version() {
		return version;
	}

	/**
	 * Outputs fixes from the given results to files.
	 * @param {LintResult[]} results The lint results.
	 * @returns {Promise&lt;void&gt;} Returns a promise that is used to track side effects.
	 */
	static async outputFixes(results) {
		if (!Array.isArray(results)) {
			throw new Error(&quot;&#039;results&#039; must be an array&quot;);
		}

		await Promise.all(
			results
				.filter(result =&gt; {
					if (typeof result !== &quot;object&quot; || result === null) {
						throw new Error(&quot;&#039;results&#039; must include only objects&quot;);
					}
					return (
						typeof result.output === &quot;string&quot; &amp;&amp;
						path.isAbsolute(result.filePath)
					);
				})
				.map(r =&gt; writeFile(r.filePath, r.output)),
		);
	}

	/**
	 * Returns results that only contains errors.
	 * @param {LintResult[]} results The results to filter.
	 * @returns {LintResult[]} The filtered results.
	 */
	static getErrorResults(results) {
		return CLIEngine.getErrorResults(results);
	}

	/**
	 * Returns meta objects for each rule represented in the lint results.
	 * @param {LintResult[]} results The results to fetch rules meta for.
	 * @returns {Object} A mapping of ruleIds to rule meta objects.
	 */
	getRulesMetaForResults(results) {
		const resultRuleIds = new Set();

		// first gather all ruleIds from all results

		for (const result of results) {
			for (const { ruleId } of result.messages) {
				resultRuleIds.add(ruleId);
			}
			for (const { ruleId } of result.suppressedMessages) {
				resultRuleIds.add(ruleId);
			}
		}

		// create a map of all rules in the results

		const { cliEngine } = privateMembersMap.get(this);
		const rules = cliEngine.getRules();
		const resultRules = new Map();

		for (const [ruleId, rule] of rules) {
			if (resultRuleIds.has(ruleId)) {
				resultRules.set(ruleId, rule);
			}
		}

		return createRulesMeta(resultRules);
	}

	/* eslint-disable no-unused-vars, class-methods-use-this -- leaving for compatibility with ESLint#hasFlag */
	/**
	 * Indicates if the given feature flag is enabled for this instance. For this
	 * class, this always returns `false` because it does not support feature flags.
	 * @param {string} flag The feature flag to check.
	 * @returns {boolean} Always false.
	 */
	hasFlag(flag) {
		return false;
	}
	/* eslint-enable no-unused-vars, class-methods-use-this -- reenable rules for the rest of the file */

	/**
	 * Executes the current configuration on an array of file and directory names.
	 * @param {string[]} patterns An array of file and directory names.
	 * @returns {Promise&lt;LintResult[]&gt;} The results of linting the file patterns given.
	 */
	async lintFiles(patterns) {
		const { cliEngine, options } = privateMembersMap.get(this);

		if (
			options.passOnNoPatterns &amp;&amp;
			(patterns === &quot;&quot; ||
				(Array.isArray(patterns) &amp;&amp; patterns.length === 0))
		) {
			return [];
		}

		if (!isNonEmptyString(patterns) &amp;&amp; !isArrayOfNonEmptyString(patterns)) {
			throw new Error(
				&quot;&#039;patterns&#039; must be a non-empty string or an array of non-empty strings&quot;,
			);
		}

		return processCLIEngineLintReport(
			cliEngine,
			cliEngine.executeOnFiles(patterns),
		);
	}

	/**
	 * Executes the current configuration on text.
	 * @param {string} code A string of JavaScript code to lint.
	 * @param {Object} [options] The options.
	 * @param {string} [options.filePath] The path to the file of the source code.
	 * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.
	 * @returns {Promise&lt;LintResult[]&gt;} The results of linting the string of code given.
	 */
	async lintText(code, options = {}) {
		if (typeof code !== &quot;string&quot;) {
			throw new Error(&quot;&#039;code&#039; must be a string&quot;);
		}
		if (typeof options !== &quot;object&quot;) {
			throw new Error(&quot;&#039;options&#039; must be an object, null, or undefined&quot;);
		}
		const {
			filePath,
			warnIgnored = false,
			...unknownOptions
		} = options || {};

		const unknownOptionKeys = Object.keys(unknownOptions);

		if (unknownOptionKeys.length &gt; 0) {
			throw new Error(
				`&#039;options&#039; must not include the unknown option(s): ${unknownOptionKeys.join(&quot;, &quot;)}`,
			);
		}

		if (filePath !== void 0 &amp;&amp; !isNonEmptyString(filePath)) {
			throw new Error(
				&quot;&#039;options.filePath&#039; must be a non-empty string or undefined&quot;,
			);
		}
		if (typeof warnIgnored !== &quot;boolean&quot;) {
			throw new Error(
				&quot;&#039;options.warnIgnored&#039; must be a boolean or undefined&quot;,
			);
		}

		const { cliEngine } = privateMembersMap.get(this);

		return processCLIEngineLintReport(
			cliEngine,
			cliEngine.executeOnText(code, filePath, warnIgnored),
		);
	}

	/**
	 * Returns the formatter representing the given formatter name.
	 * @param {string} [name] The name of the formatter to load.
	 * The following values are allowed:
	 * - `undefined` ... Load `stylish` builtin formatter.
	 * - A builtin formatter name ... Load the builtin formatter.
	 * - A third-party formatter name:
	 *   - `foo` → `eslint-formatter-foo`
	 *   - `@foo` → `@foo/eslint-formatter`
	 *   - `@foo/bar` → `@foo/eslint-formatter-bar`
	 * - A file path ... Load the file.
	 * @returns {Promise&lt;LoadedFormatter&gt;} A promise resolving to the formatter object.
	 * This promise will be rejected if the given formatter was not found or not
	 * a function.
	 */
	async loadFormatter(name = &quot;stylish&quot;) {
		if (typeof name !== &quot;string&quot;) {
			throw new Error(&quot;&#039;name&#039; must be a string&quot;);
		}

		const { cliEngine, options } = privateMembersMap.get(this);
		const formatter = cliEngine.getFormatter(name);

		if (typeof formatter !== &quot;function&quot;) {
			throw new Error(
				`Formatter must be a function, but got a ${typeof formatter}.`,
			);
		}

		return {
			/**
			 * The main formatter method.
			 * @param {LintResult[]} results The lint results to format.
			 * @param {ResultsMeta} resultsMeta Warning count and max threshold.
			 * @returns {string | Promise&lt;string&gt;} The formatted lint results.
			 */
			format(results, resultsMeta) {
				let rulesMeta = null;

				results.sort(compareResultsByFilePath);

				return formatter(results, {
					...resultsMeta,
					get cwd() {
						return options.cwd;
					},
					get rulesMeta() {
						if (!rulesMeta) {
							rulesMeta = createRulesMeta(cliEngine.getRules());
						}

						return rulesMeta;
					},
				});
			},
		};
	}

	/**
	 * Returns a configuration object for the given file based on the CLI options.
	 * This is the same logic used by the ESLint CLI executable to determine
	 * configuration for each file it processes.
	 * @param {string} filePath The path of the file to retrieve a config object for.
	 * @returns {Promise&lt;ConfigData&gt;} A configuration object for the file.
	 */
	async calculateConfigForFile(filePath) {
		if (!isNonEmptyString(filePath)) {
			throw new Error(&quot;&#039;filePath&#039; must be a non-empty string&quot;);
		}
		const { cliEngine } = privateMembersMap.get(this);

		return cliEngine.getConfigForFile(filePath);
	}

	/**
	 * Checks if a given path is ignored by ESLint.
	 * @param {string} filePath The path of the file to check.
	 * @returns {Promise&lt;boolean&gt;} Whether or not the given path is ignored.
	 */
	async isPathIgnored(filePath) {
		if (!isNonEmptyString(filePath)) {
			throw new Error(&quot;&#039;filePath&#039; must be a non-empty string&quot;);
		}
		const { cliEngine } = privateMembersMap.get(this);

		return cliEngine.isPathIgnored(filePath);
	}
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
	LegacyESLint,

	/**
	 * Get the private class members of a given ESLint instance for tests.
	 * @param {ESLint} instance The ESLint instance to get.
	 * @returns {ESLintPrivateMembers} The instance&#039;s private class members.
	 */
	getESLintPrivateMembers(instance) {
		return privateMembersMap.get(instance);
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
