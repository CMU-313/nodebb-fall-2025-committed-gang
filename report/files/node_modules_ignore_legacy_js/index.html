<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ignore/legacy.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ignore/legacy.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">560</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

function _typeof(obj) { &quot;@babel/helpers - typeof&quot;; return _typeof = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, &quot;prototype&quot;, { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, &quot;string&quot;); return _typeof(key) === &quot;symbol&quot; ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== &quot;object&quot; || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || &quot;default&quot;); if (_typeof(res) !== &quot;object&quot;) return res; throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;); } return (hint === &quot;string&quot; ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === &quot;string&quot;) return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === &quot;Object&quot; &amp;&amp; o.constructor) n = o.constructor.name; if (n === &quot;Map&quot; || n === &quot;Set&quot;) return Array.from(o); if (n === &quot;Arguments&quot; || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len &gt; arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i &lt; len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : &quot;undefined&quot; != typeof Symbol &amp;&amp; arr[Symbol.iterator] || arr[&quot;@@iterator&quot;]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) &amp;&amp; (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n &amp;&amp; null != _i[&quot;return&quot;] &amp;&amp; (_r = _i[&quot;return&quot;](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
// A simple implementation of make-array
function makeArray(subject) {
  return Array.isArray(subject) ? subject : [subject];
}
var EMPTY = &#039;&#039;;
var SPACE = &#039; &#039;;
var ESCAPE = &#039;\\&#039;;
var REGEX_TEST_BLANK_LINE = /^\s+$/;
var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
var REGEX_SPLITALL_CRLF = /\r?\n/g;
// /foo,
// ./foo,
// ../foo,
// .
// ..
var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
var SLASH = &#039;/&#039;;

// Do not use ternary expression here, since &quot;istanbul ignore next&quot; is buggy
var TMP_KEY_IGNORE = &#039;node-ignore&#039;;
/* istanbul ignore else */
if (typeof Symbol !== &#039;undefined&#039;) {
  TMP_KEY_IGNORE = Symbol[&quot;for&quot;](&#039;node-ignore&#039;);
}
var KEY_IGNORE = TMP_KEY_IGNORE;
var define = function define(object, key, value) {
  return Object.defineProperty(object, key, {
    value: value
  });
};
var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
var RETURN_FALSE = function RETURN_FALSE() {
  return false;
};

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
var sanitizeRange = function sanitizeRange(range) {
  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {
    return from.charCodeAt(0) &lt;= to.charCodeAt(0) ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY;
  });
};

// See fixtures #59
var cleanRangeBackSlash = function cleanRangeBackSlash(slashes) {
  var length = slashes.length;
  return slashes.slice(0, length - length % 2);
};

// &gt; If the pattern ends with a slash,
// &gt; it is removed for the purpose of the following description,
// &gt; but it would only find a match with a directory.
// &gt; In other words, foo/ will match a directory foo and paths underneath it,
// &gt; but will not match a regular file or a symbolic link foo
// &gt;  (this is consistent with the way how pathspec works in general in Git).
// &#039;`foo/`&#039; will not match regular file &#039;`foo`&#039; or symbolic link &#039;`foo`&#039;
// -&gt; ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// &#039;`foo/`&#039; should not continue with the &#039;`..`&#039;
var REPLACERS = [[
// remove BOM
// TODO:
// Other similar zero-width characters?
/^\uFEFF/, function () {
  return EMPTY;
}],
// &gt; Trailing spaces are ignored unless they are quoted with backslash (&quot;\&quot;)
[
// (a\ ) -&gt; (a )
// (a  ) -&gt; (a)
// (a ) -&gt; (a)
// (a \ ) -&gt; (a  )
/((?:\\\\)*?)(\\?\s+)$/, function (_, m1, m2) {
  return m1 + (m2.indexOf(&#039;\\&#039;) === 0 ? SPACE : EMPTY);
}],
// replace (\ ) with &#039; &#039;
// (\ ) -&gt; &#039; &#039;
// (\\ ) -&gt; &#039;\\ &#039;
// (\\\ ) -&gt; &#039;\\ &#039;
[/(\\+?)\s/g, function (_, m1) {
  var length = m1.length;
  return m1.slice(0, length - length % 2) + SPACE;
}],
// Escape metacharacters
// which is written down by users but means special for regular expressions.

// &gt; There are 12 characters with special meanings:
// &gt; - the backslash \,
// &gt; - the caret ^,
// &gt; - the dollar sign $,
// &gt; - the period or dot .,
// &gt; - the vertical bar or pipe symbol |,
// &gt; - the question mark ?,
// &gt; - the asterisk or star *,
// &gt; - the plus sign +,
// &gt; - the opening parenthesis (,
// &gt; - the closing parenthesis ),
// &gt; - and the opening square bracket [,
// &gt; - the opening curly brace {,
// &gt; These special characters are often called &quot;metacharacters&quot;.
[/[\\$.|*+(){^]/g, function (match) {
  return &quot;\\&quot;.concat(match);
}], [
// &gt; a question mark (?) matches a single character
/(?!\\)\?/g, function () {
  return &#039;[^/]&#039;;
}],
// leading slash
[
// &gt; A leading slash matches the beginning of the pathname.
// &gt; For example, &quot;/*.c&quot; matches &quot;cat-file.c&quot; but not &quot;mozilla-sha1/sha1.c&quot;.
// A leading slash matches the beginning of the pathname
/^\//, function () {
  return &#039;^&#039;;
}],
// replace special metacharacter slash after the leading slash
[/\//g, function () {
  return &#039;\\/&#039;;
}], [
// &gt; A leading &quot;**&quot; followed by a slash means match in all directories.
// &gt; For example, &quot;**/foo&quot; matches file or directory &quot;foo&quot; anywhere,
// &gt; the same as pattern &quot;foo&quot;.
// &gt; &quot;**/foo/bar&quot; matches file or directory &quot;bar&quot; anywhere that is directly
// &gt;   under directory &quot;foo&quot;.
// Notice that the &#039;*&#039;s have been replaced as &#039;\\*&#039;
/^\^*\\\*\\\*\\\//,
// &#039;**/foo&#039; &lt;-&gt; &#039;foo&#039;
function () {
  return &#039;^(?:.*\\/)?&#039;;
}],
// starting
[
// there will be no leading &#039;/&#039;
//   (which has been replaced by section &quot;leading slash&quot;)
// If starts with &#039;**&#039;, adding a &#039;^&#039; to the regular expression also works
/^(?=[^^])/, function startingReplacer() {
  // If has a slash `/` at the beginning or middle
  return !/\/(?!$)/.test(this)
  // &gt; Prior to 2.22.1
  // &gt; If the pattern does not contain a slash /,
  // &gt;   Git treats it as a shell glob pattern
  // Actually, if there is only a trailing slash,
  //   git also treats it as a shell glob pattern

  // After 2.22.1 (compatible but clearer)
  // &gt; If there is a separator at the beginning or middle (or both)
  // &gt; of the pattern, then the pattern is relative to the directory
  // &gt; level of the particular .gitignore file itself.
  // &gt; Otherwise the pattern may also match at any level below
  // &gt; the .gitignore level.
  ? &#039;(?:^|\\/)&#039;

  // &gt; Otherwise, Git treats the pattern as a shell glob suitable for
  // &gt;   consumption by fnmatch(3)
  : &#039;^&#039;;
}],
// two globstars
[
// Use lookahead assertions so that we could match more than one `&#039;/**&#039;`
/\\\/\\\*\\\*(?=\\\/|$)/g,
// Zero, one or several directories
// should not use &#039;*&#039;, or it will be replaced by the next replacer

// Check if it is not the last `&#039;/**&#039;`
function (_, index, str) {
  return index + 6 &lt; str.length

  // case: /**/
  // &gt; A slash followed by two consecutive asterisks then a slash matches
  // &gt;   zero or more directories.
  // &gt; For example, &quot;a/**/b&quot; matches &quot;a/b&quot;, &quot;a/x/b&quot;, &quot;a/x/y/b&quot; and so on.
  // &#039;/**/&#039;
  ? &#039;(?:\\/[^\\/]+)*&#039;

  // case: /**
  // &gt; A trailing `&quot;/**&quot;` matches everything inside.

  // #21: everything inside but it should not include the current folder
  : &#039;\\/.+&#039;;
}],
// normal intermediate wildcards
[
// Never replace escaped &#039;*&#039;
// ignore rule &#039;\*&#039; will match the path &#039;*&#039;

// &#039;abc.*/&#039; -&gt; go
// &#039;abc.*&#039;  -&gt; skip this rule,
//    coz trailing single wildcard will be handed by [trailing wildcard]
/(^|[^\\]+)(\\\*)+(?=.+)/g,
// &#039;*.js&#039; matches &#039;.js&#039;
// &#039;*.js&#039; doesn&#039;t match &#039;abc&#039;
function (_, p1, p2) {
  // 1.
  // &gt; An asterisk &quot;*&quot; matches anything except a slash.
  // 2.
  // &gt; Other consecutive asterisks are considered regular asterisks
  // &gt; and will match according to the previous rules.
  var unescaped = p2.replace(/\\\*/g, &#039;[^\\/]*&#039;);
  return p1 + unescaped;
}], [
// unescape, revert step 3 except for back slash
// For example, if a user escape a &#039;\\*&#039;,
// after step 3, the result will be &#039;\\\\\\*&#039;
/\\\\\\(?=[$.|*+(){^])/g, function () {
  return ESCAPE;
}], [
// &#039;\\\\&#039; -&gt; &#039;\\&#039;
/\\\\/g, function () {
  return ESCAPE;
}], [
// &gt; The range notation, e.g. [a-zA-Z],
// &gt; can be used to match one of the characters in a range.

// `\` is escaped by step 3
/(\\)?\[([^\]/]*?)(\\*)($|\])/g, function (match, leadEscape, range, endEscape, close) {
  return leadEscape === ESCAPE
  // &#039;\\[bar]&#039; -&gt; &#039;\\\\[bar\\]&#039;
  ? &quot;\\[&quot;.concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === &#039;]&#039; ? endEscape.length % 2 === 0
  // A normal case, and it is a range notation
  // &#039;[bar]&#039;
  // &#039;[bar\\\\]&#039;
  ? &quot;[&quot;.concat(sanitizeRange(range)).concat(endEscape, &quot;]&quot;) // Invalid range notaton
  // &#039;[bar\\]&#039; -&gt; &#039;[bar\\\\]&#039;
  : &#039;[]&#039; : &#039;[]&#039;;
}],
// ending
[
// &#039;js&#039; will not match &#039;js.&#039;
// &#039;ab&#039; will not match &#039;abc&#039;
/(?:[^*])$/,
// WTF!
// https://git-scm.com/docs/gitignore
// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
// which re-fixes #24, #38

// &gt; If there is a separator at the end of the pattern then the pattern
// &gt; will only match directories, otherwise the pattern can match both
// &gt; files and directories.

// &#039;js*&#039; will not match &#039;a.js&#039;
// &#039;js/&#039; will not match &#039;a.js&#039;
// &#039;js&#039; will match &#039;a.js&#039; and &#039;a.js/&#039;
function (match) {
  return /\/$/.test(match)
  // foo/ will not match &#039;foo&#039;
  ? &quot;&quot;.concat(match, &quot;$&quot;) // foo matches &#039;foo&#039; and &#039;foo/&#039;
  : &quot;&quot;.concat(match, &quot;(?=$|\\/$)&quot;);
}],
// trailing wildcard
[/(\^|\\\/)?\\\*$/, function (_, p1) {
  var prefix = p1
  // &#039;\^&#039;:
  // &#039;/*&#039; does not match EMPTY
  // &#039;/*&#039; does not match everything

  // &#039;\\\/&#039;:
  // &#039;abc/*&#039; does not match &#039;abc/&#039;
  ? &quot;&quot;.concat(p1, &quot;[^/]+&quot;) // &#039;a*&#039; matches &#039;a&#039;
  // &#039;a*&#039; matches &#039;aa&#039;
  : &#039;[^/]*&#039;;
  return &quot;&quot;.concat(prefix, &quot;(?=$|\\/$)&quot;);
}]];

// A simple cache, because an ignore rule only has only one certain meaning
var regexCache = Object.create(null);

// @param {pattern}
var makeRegex = function makeRegex(pattern, ignoreCase) {
  var source = regexCache[pattern];
  if (!source) {
    source = REPLACERS.reduce(function (prev, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        matcher = _ref2[0],
        replacer = _ref2[1];
      return prev.replace(matcher, replacer.bind(pattern));
    }, pattern);
    regexCache[pattern] = source;
  }
  return ignoreCase ? new RegExp(source, &#039;i&#039;) : new RegExp(source);
};
var isString = function isString(subject) {
  return typeof subject === &#039;string&#039;;
};

// &gt; A blank line matches no files, so it can serve as a separator for readability.
var checkPattern = function checkPattern(pattern) {
  return pattern &amp;&amp; isString(pattern) &amp;&amp; !REGEX_TEST_BLANK_LINE.test(pattern) &amp;&amp; !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)

  // &gt; A line starting with # serves as a comment.
  &amp;&amp; pattern.indexOf(&#039;#&#039;) !== 0;
};
var splitPattern = function splitPattern(pattern) {
  return pattern.split(REGEX_SPLITALL_CRLF);
};
var IgnoreRule = /*#__PURE__*/_createClass(function IgnoreRule(origin, pattern, negative, regex) {
  _classCallCheck(this, IgnoreRule);
  this.origin = origin;
  this.pattern = pattern;
  this.negative = negative;
  this.regex = regex;
});
var createRule = function createRule(pattern, ignoreCase) {
  var origin = pattern;
  var negative = false;

  // &gt; An optional prefix &quot;!&quot; which negates the pattern;
  if (pattern.indexOf(&#039;!&#039;) === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }
  pattern = pattern
  // &gt; Put a backslash (&quot;\&quot;) in front of the first &quot;!&quot; for patterns that
  // &gt;   begin with a literal &quot;!&quot;, for example, `&quot;\!important!.txt&quot;`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, &#039;!&#039;)
  // &gt; Put a backslash (&quot;\&quot;) in front of the first hash for patterns that
  // &gt;   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, &#039;#&#039;);
  var regex = makeRegex(pattern, ignoreCase);
  return new IgnoreRule(origin, pattern, negative, regex);
};
var throwError = function throwError(message, Ctor) {
  throw new Ctor(message);
};
var checkPath = function checkPath(path, originalPath, doThrow) {
  if (!isString(path)) {
    return doThrow(&quot;path must be a string, but got `&quot;.concat(originalPath, &quot;`&quot;), TypeError);
  }

  // We don&#039;t know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(&quot;path must not be empty&quot;, TypeError);
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    var r = &#039;`path.relative()`d&#039;;
    return doThrow(&quot;path should be a &quot;.concat(r, &quot; string, but got \&quot;&quot;).concat(originalPath, &quot;\&quot;&quot;), RangeError);
  }
  return true;
};
var isNotRelative = function isNotRelative(path) {
  return REGEX_TEST_INVALID_PATH.test(path);
};
checkPath.isNotRelative = isNotRelative;
checkPath.convert = function (p) {
  return p;
};
var Ignore = /*#__PURE__*/function () {
  function Ignore() {
    var _ref3 = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {},
      _ref3$ignorecase = _ref3.ignorecase,
      ignorecase = _ref3$ignorecase === void 0 ? true : _ref3$ignorecase,
      _ref3$ignoreCase = _ref3.ignoreCase,
      ignoreCase = _ref3$ignoreCase === void 0 ? ignorecase : _ref3$ignoreCase,
      _ref3$allowRelativePa = _ref3.allowRelativePaths,
      allowRelativePaths = _ref3$allowRelativePa === void 0 ? false : _ref3$allowRelativePa;
    _classCallCheck(this, Ignore);
    define(this, KEY_IGNORE, true);
    this._rules = [];
    this._ignoreCase = ignoreCase;
    this._allowRelativePaths = allowRelativePaths;
    this._initCache();
  }
  _createClass(Ignore, [{
    key: &quot;_initCache&quot;,
    value: function _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
  }, {
    key: &quot;_addPattern&quot;,
    value: function _addPattern(pattern) {
      // #32
      if (pattern &amp;&amp; pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern)) {
        var rule = createRule(pattern, this._ignoreCase);
        this._added = true;
        this._rules.push(rule);
      }
    }

    // @param {Array&lt;string&gt; | string | Ignore} pattern
  }, {
    key: &quot;add&quot;,
    value: function add(pattern) {
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);

      // Some rules have just added to the ignore,
      // making the behavior changed.
      if (this._added) {
        this._initCache();
      }
      return this;
    }

    // legacy
  }, {
    key: &quot;addPattern&quot;,
    value: function addPattern(pattern) {
      return this.add(pattern);
    }

    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X

    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen

    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.

    // @returns {TestResult} true if a file is ignored
  }, {
    key: &quot;_testOne&quot;,
    value: function _testOne(path, checkUnignored) {
      var ignored = false;
      var unignored = false;
      this._rules.forEach(function (rule) {
        var negative = rule.negative;
        if (unignored === negative &amp;&amp; ignored !== unignored || negative &amp;&amp; !ignored &amp;&amp; !unignored &amp;&amp; !checkUnignored) {
          return;
        }
        var matched = rule.regex.test(path);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored: ignored,
        unignored: unignored
      };
    }

    // @returns {TestResult}
  }, {
    key: &quot;_test&quot;,
    value: function _test(originalPath, cache, checkUnignored, slices) {
      var path = originalPath
      // Supports nullable path
      &amp;&amp; checkPath.convert(originalPath);
      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
      return this._t(path, cache, checkUnignored, slices);
    }
  }, {
    key: &quot;_t&quot;,
    value: function _t(path, cache, checkUnignored, slices) {
      if (path in cache) {
        return cache[path];
      }
      if (!slices) {
        // path/to/a.js
        // [&#039;path&#039;, &#039;to&#039;, &#039;a.js&#039;]
        slices = path.split(SLASH);
      }
      slices.pop();

      // If the path has no parent directory, just test it
      if (!slices.length) {
        return cache[path] = this._testOne(path, checkUnignored);
      }
      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);

      // If the path contains a parent directory, check the parent first
      return cache[path] = parent.ignored
      // &gt; It is not possible to re-include a file if a parent directory of
      // &gt;   that file is excluded.
      ? parent : this._testOne(path, checkUnignored);
    }
  }, {
    key: &quot;ignores&quot;,
    value: function ignores(path) {
      return this._test(path, this._ignoreCache, false).ignored;
    }
  }, {
    key: &quot;createFilter&quot;,
    value: function createFilter() {
      var _this = this;
      return function (path) {
        return !_this.ignores(path);
      };
    }
  }, {
    key: &quot;filter&quot;,
    value: function filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }

    // @returns {TestResult}
  }, {
    key: &quot;test&quot;,
    value: function test(path) {
      return this._test(path, this._testCache, true);
    }
  }]);
  return Ignore;
}();
var factory = function factory(options) {
  return new Ignore(options);
};
var isPathValid = function isPathValid(path) {
  return checkPath(path &amp;&amp; checkPath.convert(path), path, RETURN_FALSE);
};
factory.isPathValid = isPathValid;

// Fixes typescript
factory[&quot;default&quot;] = factory;
module.exports = factory;

// Windows
// --------------------------------------------------------------
/* istanbul ignore if */
if (
// Detect `process` so that it can run in browsers.
typeof process !== &#039;undefined&#039; &amp;&amp; (process.env &amp;&amp; process.env.IGNORE_TEST_WIN32 || process.platform === &#039;win32&#039;)) {
  /* eslint no-control-regex: &quot;off&quot; */
  var makePosix = function makePosix(str) {
    return /^\\\\\?\\/.test(str) || /[\0-\x1F&quot;&lt;&gt;\|]+/.test(str) ? str : str.replace(/\\/g, &#039;/&#039;);
  };
  checkPath.convert = makePosix;

  // &#039;C:\\foo&#039;     &lt;- &#039;C:\\foo&#039; has been converted to &#039;C:/&#039;
  // &#039;d:\\foo&#039;
  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
  checkPath.isNotRelative = function (path) {
    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
  };
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
