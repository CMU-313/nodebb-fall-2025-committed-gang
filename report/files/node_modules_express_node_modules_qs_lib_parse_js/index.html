<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/express/node_modules/qs/lib/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/express/node_modules/qs/lib/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">297</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.65</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var utils = require(&#039;./utils&#039;);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: &#039;utf-8&#039;,
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: &#039;&amp;&#039;,
    depth: 5,
    duplicates: &#039;combine&#039;,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&amp;#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val &amp;&amp; typeof val === &#039;string&#039; &amp;&amp; options.comma &amp;&amp; val.indexOf(&#039;,&#039;) &gt; -1) {
        return val.split(&#039;,&#039;);
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = &#039;utf8=%26%2310003%3B&#039;; // encodeURIComponent(&#039;&amp;#10003;&#039;)

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = &#039;utf8=%E2%9C%93&#039;; // encodeURIComponent(&#039;✓&#039;)

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, &#039;&#039;) : str;
    cleanStr = cleanStr.replace(/%5B/gi, &#039;[&#039;).replace(/%5D/gi, &#039;]&#039;);
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i &lt; parts.length; ++i) {
            if (parts[i].indexOf(&#039;utf8=&#039;) === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = &#039;utf-8&#039;;
                } else if (parts[i] === isoSentinel) {
                    charset = &#039;iso-8859-1&#039;;
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i &lt; parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(&#039;]=&#039;);
        var pos = bracketEqualsPos === -1 ? part.indexOf(&#039;=&#039;) : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, &#039;key&#039;);
            val = options.strictNullHandling ? null : &#039;&#039;;
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, &#039;key&#039;);
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, &#039;value&#039;);
                }
            );
        }

        if (val &amp;&amp; options.interpretNumericEntities &amp;&amp; charset === &#039;iso-8859-1&#039;) {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf(&#039;[]=&#039;) &gt; -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing &amp;&amp; options.duplicates === &#039;combine&#039;) {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === &#039;last&#039;) {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i &gt;= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === &#039;[]&#039; &amp;&amp; options.parseArrays) {
            obj = options.allowEmptyArrays &amp;&amp; (leaf === &#039;&#039; || (options.strictNullHandling &amp;&amp; leaf === null))
                ? []
                : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === &#039;[&#039; &amp;&amp; root.charAt(root.length - 1) === &#039;]&#039; ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, &#039;.&#039;) : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays &amp;&amp; decodedRoot === &#039;&#039;) {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                &amp;&amp; root !== decodedRoot
                &amp;&amp; String(index) === decodedRoot
                &amp;&amp; index &gt;= 0
                &amp;&amp; (options.parseArrays &amp;&amp; index &lt;= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== &#039;__proto__&#039;) {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, &#039;[$1]&#039;) : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth &gt; 0 &amp;&amp; brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren&#039;t using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects &amp;&amp; has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth &gt; 0 &amp;&amp; (segment = child.exec(key)) !== null &amp;&amp; i &lt; options.depth) {
        i += 1;
        if (!options.plainObjects &amp;&amp; has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there&#039;s a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError(&#039;Input depth exceeded depth option of &#039; + options.depth + &#039; and strictDepth is true&#039;);
        }
        keys.push(&#039;[&#039; + key.slice(segment.index) + &#039;]&#039;);
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== &#039;undefined&#039; &amp;&amp; typeof opts.allowEmptyArrays !== &#039;boolean&#039;) {
        throw new TypeError(&#039;`allowEmptyArrays` option can only be `true` or `false`, when provided&#039;);
    }

    if (typeof opts.decodeDotInKeys !== &#039;undefined&#039; &amp;&amp; typeof opts.decodeDotInKeys !== &#039;boolean&#039;) {
        throw new TypeError(&#039;`decodeDotInKeys` option can only be `true` or `false`, when provided&#039;);
    }

    if (opts.decoder !== null &amp;&amp; typeof opts.decoder !== &#039;undefined&#039; &amp;&amp; typeof opts.decoder !== &#039;function&#039;) {
        throw new TypeError(&#039;Decoder has to be a function.&#039;);
    }

    if (typeof opts.charset !== &#039;undefined&#039; &amp;&amp; opts.charset !== &#039;utf-8&#039; &amp;&amp; opts.charset !== &#039;iso-8859-1&#039;) {
        throw new TypeError(&#039;The charset option must be either utf-8, iso-8859-1, or undefined&#039;);
    }
    var charset = typeof opts.charset === &#039;undefined&#039; ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === &#039;undefined&#039; ? defaults.duplicates : opts.duplicates;

    if (duplicates !== &#039;combine&#039; &amp;&amp; duplicates !== &#039;first&#039; &amp;&amp; duplicates !== &#039;last&#039;) {
        throw new TypeError(&#039;The duplicates option must be either combine, first, or last&#039;);
    }

    var allowDots = typeof opts.allowDots === &#039;undefined&#039; ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === &#039;boolean&#039; ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === &#039;boolean&#039; ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === &#039;boolean&#039; ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === &#039;number&#039; ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === &#039;boolean&#039; ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === &#039;boolean&#039; ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === &#039;boolean&#039; ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === &#039;function&#039; ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === &#039;string&#039; || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === &#039;number&#039; || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === &#039;boolean&#039; ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === &#039;number&#039; ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === &#039;boolean&#039; ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === &#039;boolean&#039; ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === &#039;boolean&#039; ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === &#039;&#039; || str === null || typeof str === &#039;undefined&#039;) {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === &#039;string&#039; ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i &lt; keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === &#039;string&#039;);
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
