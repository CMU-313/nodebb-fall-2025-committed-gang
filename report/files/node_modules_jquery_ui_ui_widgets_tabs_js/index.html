<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jquery-ui/ui/widgets/tabs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jquery-ui/ui/widgets/tabs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">893</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">89.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * jQuery UI Tabs 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//&gt;&gt;label: Tabs
//&gt;&gt;group: Widgets
//&gt;&gt;description: Transforms a set of container elements into a tab structure.
//&gt;&gt;docs: https://api.jqueryui.com/tabs/
//&gt;&gt;demos: https://jqueryui.com/tabs/
//&gt;&gt;css.structure: ../../themes/base/core.css
//&gt;&gt;css.structure: ../../themes/base/tabs.css
//&gt;&gt;css.theme: ../../themes/base/theme.css

( function( factory ) {
	&quot;use strict&quot;;

	if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {

		// AMD. Register as an anonymous module.
		define( [
			&quot;jquery&quot;,
			&quot;../keycode&quot;,
			&quot;../unique-id&quot;,
			&quot;../version&quot;,
			&quot;../widget&quot;
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
} )( function( $ ) {
&quot;use strict&quot;;

$.widget( &quot;ui.tabs&quot;, {
	version: &quot;1.14.1&quot;,
	delay: 300,
	options: {
		active: null,
		classes: {
			&quot;ui-tabs&quot;: &quot;ui-corner-all&quot;,
			&quot;ui-tabs-nav&quot;: &quot;ui-corner-all&quot;,
			&quot;ui-tabs-panel&quot;: &quot;ui-corner-bottom&quot;,
			&quot;ui-tabs-tab&quot;: &quot;ui-corner-top&quot;
		},
		collapsible: false,
		event: &quot;click&quot;,
		heightStyle: &quot;content&quot;,
		hide: null,
		show: null,

		// Callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: ( function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			anchorUrl = anchor.href.replace( rhash, &quot;&quot; );
			locationUrl = location.href.replace( rhash, &quot;&quot; );

			// Decoding may throw an error if the URL isn&#039;t UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length &gt; 1 &amp;&amp; anchorUrl === locationUrl;
		};
	} )(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this._addClass( &quot;ui-tabs&quot;, &quot;ui-widget ui-widget-content&quot; );
		this._toggleClass( &quot;ui-tabs-collapsible&quot;, null, options.collapsible );

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( Array.isArray( options.disabled ) ) {
			options.disabled = $.uniqueSort( options.disabled.concat(
				$.map( this.tabs.filter( &quot;.ui-state-disabled&quot; ), function( li ) {
					return that.tabs.index( li );
				} )
			) ).sort();
		}

		// Check for length avoids error when initializing empty list
		if ( this.options.active !== false &amp;&amp; this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHashDecoded = decodeURIComponent( location.hash.substring( 1 ) );

		if ( active === null ) {

			// check the fragment identifier in the URL
			if ( locationHashDecoded ) {
				this.tabs.each( function( i, tab ) {
					if ( $( tab ).attr( &quot;aria-controls&quot; ) === locationHashDecoded ) {
						active = i;
						return false;
					}
				} );
			}

			// Check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( &quot;.ui-tabs-active&quot; ) );
			}

			// No active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// Handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// Don&#039;t allow collapsible: false and active: false
		if ( !collapsible &amp;&amp; active === false &amp;&amp; this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[ 0 ].activeElement ).closest( &quot;li&quot; ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.RIGHT:
		case $.ui.keyCode.DOWN:
			selectedIndex++;
			break;
		case $.ui.keyCode.UP:
		case $.ui.keyCode.LEFT:
			goingForward = false;
			selectedIndex--;
			break;
		case $.ui.keyCode.END:
			selectedIndex = this.anchors.length - 1;
			break;
		case $.ui.keyCode.HOME:
			selectedIndex = 0;
			break;
		case $.ui.keyCode.SPACE:

			// Activate only, no collapsing
			event.preventDefault();
			clearTimeout( this.activating );
			this._activate( selectedIndex );
			return;
		case $.ui.keyCode.ENTER:

			// Toggle (cancel delayed activation, allow collapsing)
			event.preventDefault();
			clearTimeout( this.activating );

			// Determine if we should collapse or activate
			this._activate( selectedIndex === this.options.active ? false : selectedIndex );
			return;
		default:
			return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control/command key will prevent automatic activation
		if ( !event.ctrlKey &amp;&amp; !event.metaKey ) {

			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( &quot;aria-selected&quot;, &quot;false&quot; );
			this.tabs.eq( selectedIndex ).attr( &quot;aria-selected&quot;, &quot;true&quot; );

			this.activating = this._delay( function() {
				this.option( &quot;active&quot;, selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey &amp;&amp; event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.trigger( &quot;focus&quot; );
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey &amp;&amp; event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey &amp;&amp; event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index &gt; lastTabIndex ) {
				index = 0;
			}
			if ( index &lt; 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).trigger( &quot;focus&quot; );
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === &quot;active&quot; ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		this._super( key, value );

		if ( key === &quot;collapsible&quot; ) {
			this._toggleClass( &quot;ui-tabs-collapsible&quot;, null, value );

			// Setting collapsible: false while collapsed; open first panel
			if ( !value &amp;&amp; this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === &quot;event&quot; ) {
			this._setupEvents( value );
		}

		if ( key === &quot;heightStyle&quot; ) {
			this._setupHeightStyle( value );
		}
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( &quot;:has(a[href])&quot; );

		// Get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( &quot;.ui-state-disabled&quot; ), function( tab ) {
			return lis.index( tab );
		} );

		this._processTabs();

		// Was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();

		// was active, but active tab is gone
		} else if ( this.active.length &amp;&amp; !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {

			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();

			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}

		// was active, active tab still exists
		} else {

			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setOptionDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr( {
			&quot;aria-selected&quot;: &quot;false&quot;,
			&quot;aria-expanded&quot;: &quot;false&quot;,
			tabIndex: -1
		} );
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr( {
				&quot;aria-hidden&quot;: &quot;true&quot;
			} );

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( &quot;tabIndex&quot;, 0 );
		} else {
			this.active
				.attr( {
					&quot;aria-selected&quot;: &quot;true&quot;,
					&quot;aria-expanded&quot;: &quot;true&quot;,
					tabIndex: 0
				} );
			this._addClass( this.active, &quot;ui-tabs-active&quot;, &quot;ui-state-active&quot; );
			this._getPanelForTab( this.active )
				.show()
				.attr( {
					&quot;aria-hidden&quot;: &quot;false&quot;
				} );
		}
	},

	_processTabs: function() {
		var that = this,
			prevTabs = this.tabs,
			prevAnchors = this.anchors,
			prevPanels = this.panels;

		this.tablist = this._getList().attr( &quot;role&quot;, &quot;tablist&quot; );
		this._addClass( this.tablist, &quot;ui-tabs-nav&quot;,
			&quot;ui-helper-reset ui-helper-clearfix ui-widget-header&quot; );

		// Prevent users from focusing disabled tabs via click
		this.tablist
			.on( &quot;mousedown&quot; + this.eventNamespace, &quot;&gt; li&quot;, function( event ) {
				if ( $( this ).is( &quot;.ui-state-disabled&quot; ) ) {
					event.preventDefault();
				}
			} );

		this.tabs = this.tablist.find( &quot;&gt; li:has(a[href])&quot; )
			.attr( {
				role: &quot;tab&quot;,
				tabIndex: -1
			} );
		this._addClass( this.tabs, &quot;ui-tabs-tab&quot;, &quot;ui-state-default&quot; );

		this.anchors = this.tabs.map( function() {
			return $( &quot;a&quot;, this )[ 0 ];
		} )
			.attr( {
				tabIndex: -1
			} );
		this._addClass( this.anchors, &quot;ui-tabs-anchor&quot; );

		this.panels = $();

		this.anchors.each( function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( &quot;id&quot; ),
				tab = $( anchor ).closest( &quot;li&quot; ),
				originalAriaControls = tab.attr( &quot;aria-controls&quot; );

			// Inline tab
			if ( that._isLocal( anchor ) ) {
				selector = decodeURIComponent( anchor.hash );
				panelId = selector.substring( 1 );
				panel = that.element.find( &quot;#&quot; + CSS.escape( panelId ) );

			// remote tab
			} else {

				// If the tab doesn&#039;t already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( &quot;aria-controls&quot; ) || $( {} ).uniqueId()[ 0 ].id;
				selector = &quot;#&quot; + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( &quot;aria-live&quot;, &quot;polite&quot; );
			}

			if ( panel.length ) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( &quot;ui-tabs-aria-controls&quot;, originalAriaControls );
			}
			tab.attr( {
				&quot;aria-controls&quot;: panelId,
				&quot;aria-labelledby&quot;: anchorId
			} );
			panel.attr( &quot;aria-labelledby&quot;, anchorId );
		} );

		this.panels.attr( &quot;role&quot;, &quot;tabpanel&quot; );
		this._addClass( this.panels, &quot;ui-tabs-panel&quot;, &quot;ui-widget-content&quot; );

		// Avoid memory leaks (#10056)
		if ( prevTabs ) {
			this._off( prevTabs.not( this.tabs ) );
			this._off( prevAnchors.not( this.anchors ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	// Allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( &quot;ol, ul&quot; ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( &quot;&lt;div&gt;&quot; )
			.attr( &quot;id&quot;, id )
			.data( &quot;ui-tabs-destroy&quot;, true );
	},

	_setOptionDisabled: function( disabled ) {
		var currentItem, li, i;

		if ( Array.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// Disable tabs
		for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {
			currentItem = $( li );
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				currentItem.attr( &quot;aria-disabled&quot;, &quot;true&quot; );
				this._addClass( currentItem, null, &quot;ui-state-disabled&quot; );
			} else {
				currentItem.removeAttr( &quot;aria-disabled&quot; );
				this._removeClass( currentItem, null, &quot;ui-state-disabled&quot; );
			}
		}

		this.options.disabled = disabled;

		this._toggleClass( this.widget(), this.widgetFullName + &quot;-disabled&quot;, null,
			disabled === true );
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split( &quot; &quot; ), function( index, eventName ) {
				events[ eventName ] = &quot;_eventHandler&quot;;
			} );
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );

		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		} );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: &quot;_tabKeydown&quot; } );
		this._on( this.panels, { keydown: &quot;_panelKeydown&quot; } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === &quot;fill&quot; ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( &quot;:visible&quot; ).each( function() {
				var elem = $( this ),
					position = elem.css( &quot;position&quot; );

				if ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.element.children().not( this.panels ).each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.panels.each( function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			} )
				.css( &quot;overflow&quot;, &quot;auto&quot; );
		} else if ( heightStyle === &quot;auto&quot; ) {
			maxHeight = 0;
			this.panels.each( function() {
				maxHeight = Math.max( maxHeight, $( this ).height( &quot;&quot; ).height() );
			} ).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( &quot;li&quot; ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive &amp;&amp; options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( &quot;ui-state-disabled&quot; ) ||

				// tab is already loading
				tab.hasClass( &quot;ui-tabs-loading&quot; ) ||

				// can&#039;t switch durning an animation
				this.running ||

				// click on active header, but not collapsible
				( clickedIsActive &amp;&amp; !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( &quot;beforeActivate&quot;, event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length &amp;&amp; !toShow.length ) {
			$.error( &quot;jQuery UI Tabs: Mismatching fragment identifier.&quot; );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// Handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( &quot;activate&quot;, event, eventData );
		}

		function show() {
			that._addClass( eventData.newTab.closest( &quot;li&quot; ), &quot;ui-tabs-active&quot;, &quot;ui-state-active&quot; );

			if ( toShow.length &amp;&amp; that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// Start out by hiding, then showing, then completing
		if ( toHide.length &amp;&amp; this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				that._removeClass( eventData.oldTab.closest( &quot;li&quot; ),
					&quot;ui-tabs-active&quot;, &quot;ui-state-active&quot; );
				show();
			} );
		} else {
			this._removeClass( eventData.oldTab.closest( &quot;li&quot; ),
				&quot;ui-tabs-active&quot;, &quot;ui-state-active&quot; );
			toHide.hide();
			show();
		}

		toHide.attr( &quot;aria-hidden&quot;, &quot;true&quot; );
		eventData.oldTab.attr( {
			&quot;aria-selected&quot;: &quot;false&quot;,
			&quot;aria-expanded&quot;: &quot;false&quot;
		} );

		// If we&#039;re switching tabs, remove the old tab from the tab order.
		// If we&#039;re opening from collapsed state, remove the previous tab from the tab order.
		// If we&#039;re collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length &amp;&amp; toHide.length ) {
			eventData.oldTab.attr( &quot;tabIndex&quot;, -1 );
		} else if ( toShow.length ) {
			this.tabs.filter( function() {
				return $( this ).attr( &quot;tabIndex&quot; ) === 0;
			} )
				.attr( &quot;tabIndex&quot;, -1 );
		}

		toShow.attr( &quot;aria-hidden&quot;, &quot;false&quot; );
		eventData.newTab.attr( {
			&quot;aria-selected&quot;: &quot;true&quot;,
			&quot;aria-expanded&quot;: &quot;true&quot;,
			tabIndex: 0
		} );
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// Trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( &quot;.ui-tabs-anchor&quot; )[ 0 ];
		this._eventHandler( {
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		} );
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {

		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === &quot;string&quot; ) {
			index = this.anchors.index( this.anchors.filter( &quot;[href$=&#039;&quot; +
				CSS.escape( index ) + &quot;&#039;]&quot; ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.tablist
			.removeAttr( &quot;role&quot; )
			.off( this.eventNamespace );

		this.anchors
			.removeAttr( &quot;role tabIndex&quot; )
			.removeUniqueId();

		this.tabs.add( this.panels ).each( function() {
			if ( $.data( this, &quot;ui-tabs-destroy&quot; ) ) {
				$( this ).remove();
			} else {
				$( this ).removeAttr( &quot;role tabIndex &quot; +
					&quot;aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded&quot; );
			}
		} );

		this.tabs.each( function() {
			var li = $( this ),
				prev = li.data( &quot;ui-tabs-aria-controls&quot; );
			if ( prev ) {
				li
					.attr( &quot;aria-controls&quot;, prev )
					.removeData( &quot;ui-tabs-aria-controls&quot; );
			} else {
				li.removeAttr( &quot;aria-controls&quot; );
			}
		} );

		this.panels.show();

		if ( this.options.heightStyle !== &quot;content&quot; ) {
			this.panels.css( &quot;height&quot;, &quot;&quot; );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( Array.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				} );
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				} );
			}
		}
		this._setOptionDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( Array.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setOptionDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( &quot;.ui-tabs-anchor&quot; ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			},
			complete = function( jqXHR, status ) {
				if ( status === &quot;abort&quot; ) {
					that.panels.stop( false, true );
				}

				that._removeClass( tab, &quot;ui-tabs-loading&quot; );
				panel.removeAttr( &quot;aria-busy&quot; );

				if ( jqXHR === that.xhr ) {
					delete that.xhr;
				}
			};

		// Not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		if ( this.xhr.statusText !== &quot;canceled&quot; ) {
			this._addClass( tab, &quot;ui-tabs-loading&quot; );
			panel.attr( &quot;aria-busy&quot;, &quot;true&quot; );

			this.xhr
				.done( function( response, status, jqXHR ) {
					panel.html( response );
					that._trigger( &quot;load&quot;, event, eventData );

					complete( jqXHR, status );
				} )
				.fail( function( jqXHR, status ) {
					complete( jqXHR, status );
				} );
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( &quot;href&quot; ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( &quot;beforeLoad&quot;, event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( &quot;aria-controls&quot; );
		return this.element.find( &quot;#&quot; + CSS.escape( id ) );
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat === true ) {

	// Backcompat for ui-tab class (now ui-tabs-tab)
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		_processTabs: function() {
			this._superApply( arguments );
			this._addClass( this.tabs, &quot;ui-tab&quot; );
		}
	} );
}

return $.ui.tabs;

} );
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
