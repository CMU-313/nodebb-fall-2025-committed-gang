<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/mocha/node_modules/minimatch/minimatch.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/mocha/node_modules/minimatch/minimatch.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.24</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">945</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">129.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.72</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">const minimatch = module.exports = (p, pattern, options = {}) =&gt; {
  assertValidPattern(pattern)

  // shortcut: comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

module.exports = minimatch

const path = require(&#039;./lib/path.js&#039;)
minimatch.sep = path.sep

const GLOBSTAR = Symbol(&#039;globstar **&#039;)
minimatch.GLOBSTAR = GLOBSTAR
const expand = require(&#039;brace-expansion&#039;)

const plTypes = {
  &#039;!&#039;: { open: &#039;(?:(?!(?:&#039;, close: &#039;))[^/]*?)&#039;},
  &#039;?&#039;: { open: &#039;(?:&#039;, close: &#039;)?&#039; },
  &#039;+&#039;: { open: &#039;(?:&#039;, close: &#039;)+&#039; },
  &#039;*&#039;: { open: &#039;(?:&#039;, close: &#039;)*&#039; },
  &#039;@&#039;: { open: &#039;(?:&#039;, close: &#039;)&#039; }
}

// any single thing other than /
// don&#039;t need to escape / when using new RegExp()
const qmark = &#039;[^/]&#039;

// * =&gt; any number of characters
const star = qmark + &#039;*?&#039;

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = &#039;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&#039;

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = &#039;(?:(?!(?:\\\/|^)\\.).)*?&#039;

// &quot;abc&quot; -&gt; { a:true, b:true, c:true }
const charSet = s =&gt; s.split(&#039;&#039;).reduce((set, c) =&gt; {
  set[c] = true
  return set
}, {})

// characters that need to be escaped in RegExp.
const reSpecials = charSet(&#039;().*{}+?[]^$\\!&#039;)

// characters that indicate we have to add the pattern start
const addPatternStartSet = charSet(&#039;[.(&#039;)

// normalizes slashes.
const slashSplit = /\/+/

minimatch.filter = (pattern, options = {}) =&gt;
  (p, i, list) =&gt; minimatch(p, pattern, options)

const ext = (a, b = {}) =&gt; {
  const t = {}
  Object.keys(a).forEach(k =&gt; t[k] = a[k])
  Object.keys(b).forEach(k =&gt; t[k] = b[k])
  return t
}

minimatch.defaults = def =&gt; {
  if (!def || typeof def !== &#039;object&#039; || !Object.keys(def).length) {
    return minimatch
  }

  const orig = minimatch

  const m = (p, pattern, options) =&gt; orig(p, pattern, ext(def, options))
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor (pattern, options) {
      super(pattern, ext(def, options))
    }
  }
  m.Minimatch.defaults = options =&gt; orig.defaults(ext(def, options)).Minimatch
  m.filter = (pattern, options) =&gt; orig.filter(pattern, ext(def, options))
  m.defaults = options =&gt; orig.defaults(ext(def, options))
  m.makeRe = (pattern, options) =&gt; orig.makeRe(pattern, ext(def, options))
  m.braceExpand = (pattern, options) =&gt; orig.braceExpand(pattern, ext(def, options))
  m.match = (list, pattern, options) =&gt; orig.match(list, pattern, ext(def, options))

  return m
}





// Brace expansion:
// a{b,c}d -&gt; abd acd
// a{b,}c -&gt; abc ac
// a{0..3}d -&gt; a0d a1d a2d a3d
// a{b,c{d,e}f}g -&gt; abg acdfg acefg
// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -&gt; a{2..}b
// a{b}c -&gt; a{b}c
minimatch.braceExpand = (pattern, options) =&gt; braceExpand(pattern, options)

const braceExpand = (pattern, options = {}) =&gt; {
  assertValidPattern(pattern)

  // Thanks to Yeting Li &lt;https://github.com/yetingli&gt; for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

const MAX_PATTERN_LENGTH = 1024 * 64
const assertValidPattern = pattern =&gt; {
  if (typeof pattern !== &#039;string&#039;) {
    throw new TypeError(&#039;invalid pattern&#039;)
  }

  if (pattern.length &gt; MAX_PATTERN_LENGTH) {
    throw new TypeError(&#039;pattern is too long&#039;)
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain &quot;/&quot; in it
// so we&#039;re going to return a 2d array, where each entry is the full
// pattern, split on &#039;/&#039;, and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const SUBPARSE = Symbol(&#039;subparse&#039;)

minimatch.makeRe = (pattern, options) =&gt;
  new Minimatch(pattern, options || {}).makeRe()

minimatch.match = (list, pattern, options = {}) =&gt; {
  const mm = new Minimatch(pattern, options)
  list = list.filter(f =&gt; mm.match(f))
  if (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  return list
}

// replace stuff like \* with *
const globUnescape = s =&gt; s.replace(/\\(.)/g, &#039;$1&#039;)
const charUnescape = s =&gt; s.replace(/\\([^-\]])/g, &#039;$1&#039;)
const regExpEscape = s =&gt; s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &#039;\\$&amp;&#039;)
const braExpEscape = s =&gt; s.replace(/[[\]\\]/g, &#039;\\$&amp;&#039;)

class Minimatch {
  constructor (pattern, options) {
    assertValidPattern(pattern)

    if (!options) options = {}

    this.options = options
    this.set = []
    this.pattern = pattern
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||
      options.allowWindowsEscape === false
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, &#039;/&#039;)
    }
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false
    this.partial = !!options.partial

    // make the set of regexps etc.
    this.make()
  }

  debug () {}

  make () {
    const pattern = this.pattern
    const options = this.options

    // empty patterns and comments match nothing.
    if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

    // step 2: expand braces
    let set = this.globSet = this.braceExpand()

    if (options.debug) this.debug = (...args) =&gt; console.error(...args)

    this.debug(this.pattern, set)

    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of &quot;**&quot;, which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(s =&gt; s.split(slashSplit))

    this.debug(this.pattern, set)

    // glob --&gt; regexps
    set = set.map((s, si, set) =&gt; s.map(this.parse, this))

    this.debug(this.pattern, set)

    // filter out everything that didn&#039;t compile properly.
    set = set.filter(s =&gt; s.indexOf(false) === -1)

    this.debug(this.pattern, set)

    this.set = set
  }

  parseNegate () {
    if (this.options.nonegate) return

    const pattern = this.pattern
    let negate = false
    let negateOffset = 0

    for (let i = 0; i &lt; pattern.length &amp;&amp; pattern.charAt(i) === &#039;!&#039;; i++) {
      negate = !negate
      negateOffset++
    }

    if (negateOffset) this.pattern = pattern.slice(negateOffset)
    this.negate = negate
  }

  // set partial to true to test if, for example,
  // &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;
  // Partial means, if you run out of file before you run
  // out of pattern, then that&#039;s fine, as long as all
  // the parts match.
  matchOne (file, pattern, partial) {
    var options = this.options

    this.debug(&#039;matchOne&#039;,
      { &#039;this&#039;: this, file: file, pattern: pattern })

    this.debug(&#039;matchOne&#039;, file.length, pattern.length)

    for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length
        ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
        ; fi++, pi++) {
      this.debug(&#039;matchOne loop&#039;)
      var p = pattern[pi]
      var f = file[fi]

      this.debug(pattern, p, f)

      // should be impossible.
      // some invalid regexp stuff in the set.
      /* istanbul ignore if */
      if (p === false) return false

      if (p === GLOBSTAR) {
        this.debug(&#039;GLOBSTAR&#039;, [pattern, p, f])

        // &quot;**&quot;
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** &quot;swallows&quot; a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -&gt; no
        //       - matchOne(y/z/c, c) -&gt; no
        //       - matchOne(z/c, c) -&gt; no
        //       - matchOne(c, c) yes, hit
        var fr = fi
        var pr = pi + 1
        if (pr === pl) {
          this.debug(&#039;** at the end&#039;)
          // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.
          for (; fi &lt; fl; fi++) {
            if (file[fi] === &#039;.&#039; || file[fi] === &#039;..&#039; ||
              (!options.dot &amp;&amp; file[fi].charAt(0) === &#039;.&#039;)) return false
          }
          return true
        }

        // ok, let&#039;s see if we can swallow whatever we can.
        while (fr &lt; fl) {
          var swallowee = file[fr]

          this.debug(&#039;\nglobstar while&#039;, file, fr, pattern, pr, swallowee)

          // XXX remove this slice.  Just pass the start index.
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug(&#039;globstar found match!&#039;, fr, fl, swallowee)
            // found a match.
            return true
          } else {
            // can&#039;t swallow &quot;.&quot; or &quot;..&quot; ever.
            // can only swallow &quot;.foo&quot; when explicitly asked.
            if (swallowee === &#039;.&#039; || swallowee === &#039;..&#039; ||
              (!options.dot &amp;&amp; swallowee.charAt(0) === &#039;.&#039;)) {
              this.debug(&#039;dot detected!&#039;, file, fr, pattern, pr)
              break
            }

            // ** swallows a segment, and continue.
            this.debug(&#039;globstar swallow a segment, and continue&#039;)
            fr++
          }
        }

        // no match was found.
        // However, in partial mode, we can&#039;t say this is necessarily over.
        // If there&#039;s more *pattern* left, then
        /* istanbul ignore if */
        if (partial) {
          // ran out of file
          this.debug(&#039;\n&gt;&gt;&gt; no match, partial?&#039;, file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === &#039;string&#039;) {
        hit = f === p
        this.debug(&#039;string match&#039;, p, f, hit)
      } else {
        hit = f.match(p)
        this.debug(&#039;pattern match&#039;, p, f, hit)
      }

      if (!hit) return false
    }

    // Note: ending in / means that we&#039;ll get a final &quot;&quot;
    // at the end of the pattern.  This can only match a
    // corresponding &quot;&quot; at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn&#039;t have any more for it. But, a/b/ should *not*
    // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we&#039;re done.
    if (fi === fl &amp;&amp; pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we&#039;re doing the match as part of
      // a glob fs traversal.
      return partial
    } else /* istanbul ignore else */ if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we&#039;re on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return (fi === fl - 1) &amp;&amp; (file[fi] === &#039;&#039;)
    }

    // should be unreachable.
    /* istanbul ignore next */
    throw new Error(&#039;wtf?&#039;)
  }

  braceExpand () {
    return braceExpand(this.pattern, this.options)
  }

  parse (pattern, isSub) {
    assertValidPattern(pattern)

    const options = this.options

    // shortcuts
    if (pattern === &#039;**&#039;) {
      if (!options.noglobstar)
        return GLOBSTAR
      else
        pattern = &#039;*&#039;
    }
    if (pattern === &#039;&#039;) return &#039;&#039;

    let re = &#039;&#039;
    let hasMagic = false
    let escaping = false
    // ? =&gt; one single character
    const patternListStack = []
    const negativeLists = []
    let stateChar
    let inClass = false
    let reClassStart = -1
    let classStart = -1
    let cs
    let pl
    let sp
    // . and .. never match anything that doesn&#039;t start with .,
    // even when options.dot is set.  However, if the pattern
    // starts with ., then traversal patterns can match.
    let dotTravAllowed = pattern.charAt(0) === &#039;.&#039;
    let dotFileAllowed = options.dot || dotTravAllowed
    const patternStart = () =&gt;
      dotTravAllowed
        ? &#039;&#039;
        : dotFileAllowed
        ? &#039;(?!(?:^|\\/)\\.{1,2}(?:$|\\/))&#039;
        : &#039;(?!\\.)&#039;
    const subPatternStart = (p) =&gt;
      p.charAt(0) === &#039;.&#039;
        ? &#039;&#039;
        : options.dot
        ? &#039;(?!(?:^|\\/)\\.{1,2}(?:$|\\/))&#039;
        : &#039;(?!\\.)&#039;


    const clearStateChar = () =&gt; {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn&#039;t consumed by this pass.
        switch (stateChar) {
          case &#039;*&#039;:
            re += star
            hasMagic = true
          break
          case &#039;?&#039;:
            re += qmark
            hasMagic = true
          break
          default:
            re += &#039;\\&#039; + stateChar
          break
        }
        this.debug(&#039;clearStateChar %j %j&#039;, stateChar, re)
        stateChar = false
      }
    }

    for (let i = 0, c; (i &lt; pattern.length) &amp;&amp; (c = pattern.charAt(i)); i++) {
      this.debug(&#039;%s\t%s %s %j&#039;, pattern, i, re, c)

      // skip over any that are escaped.
      if (escaping) {
        /* istanbul ignore next - completely not allowed, even escaped. */
        if (c === &#039;/&#039;) {
          return false
        }

        if (reSpecials[c]) {
          re += &#039;\\&#039;
        }
        re += c
        escaping = false
        continue
      }

      switch (c) {
        /* istanbul ignore next */
        case &#039;/&#039;: {
          // Should already be path-split by now.
          return false
        }

        case &#039;\\&#039;:
          if (inClass &amp;&amp; pattern.charAt(i + 1) === &#039;-&#039;) {
            re += c
            continue
          }

          clearStateChar()
          escaping = true
        continue

        // the various stateChar values
        // for the &quot;extglob&quot; stuff.
        case &#039;?&#039;:
        case &#039;*&#039;:
        case &#039;+&#039;:
        case &#039;@&#039;:
        case &#039;!&#039;:
          this.debug(&#039;%s\t%s %s %j &lt;-- stateChar&#039;, pattern, i, re, c)

          // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp
          if (inClass) {
            this.debug(&#039;  in class&#039;)
            if (c === &#039;!&#039; &amp;&amp; i === classStart + 1) c = &#039;^&#039;
            re += c
            continue
          }

          // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.
          this.debug(&#039;call clearStateChar %j&#039;, stateChar)
          clearStateChar()
          stateChar = c
          // if extglob is disabled, then +(asdf|foo) isn&#039;t a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.
          if (options.noext) clearStateChar()
        continue

        case &#039;(&#039;: {
          if (inClass) {
            re += &#039;(&#039;
            continue
          }

          if (!stateChar) {
            re += &#039;\\(&#039;
            continue
          }

          const plEntry = {
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close,
          }
          this.debug(this.pattern, &#039;\t&#039;, plEntry)
          patternListStack.push(plEntry)
          // negation is (?:(?!(?:js)(?:&lt;rest&gt;))[^/]*)
          re += plEntry.open
          // next entry starts with a dot maybe?
          if (plEntry.start === 0 &amp;&amp; plEntry.type !== &#039;!&#039;) {
            dotTravAllowed = true
            re += subPatternStart(pattern.slice(i + 1))
          }
          this.debug(&#039;plType %j %j&#039;, stateChar, re)
          stateChar = false
          continue
        }

        case &#039;)&#039;: {
          const plEntry = patternListStack[patternListStack.length - 1]
          if (inClass || !plEntry) {
            re += &#039;\\)&#039;
            continue
          }
          patternListStack.pop()

          // closing an extglob
          clearStateChar()
          hasMagic = true
          pl = plEntry
          // negation is (?:(?!js)[^/]*)
          // The others are (?:&lt;pattern&gt;)&lt;type&gt;
          re += pl.close
          if (pl.type === &#039;!&#039;) {
            negativeLists.push(Object.assign(pl, { reEnd: re.length }))
          }
          continue
        }

        case &#039;|&#039;: {
          const plEntry = patternListStack[patternListStack.length - 1]
          if (inClass || !plEntry) {
            re += &#039;\\|&#039;
            continue
          }

          clearStateChar()
          re += &#039;|&#039;
          // next subpattern can start with a dot?
          if (plEntry.start === 0 &amp;&amp; plEntry.type !== &#039;!&#039;) {
            dotTravAllowed = true
            re += subPatternStart(pattern.slice(i + 1))
          }
          continue
        }

        // these are mostly the same in regexp and glob
        case &#039;[&#039;:
          // swallow any state-tracking char before the [
          clearStateChar()

          if (inClass) {
            re += &#039;\\&#039; + c
            continue
          }

          inClass = true
          classStart = i
          reClassStart = re.length
          re += c
        continue

        case &#039;]&#039;:
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += &#039;\\&#039; + c
            continue
          }

          // split where the last [ was, make sure we don&#039;t have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it&#039;s tricky
          // to do safely.  For now, this is safe and works.
          cs = pattern.substring(classStart + 1, i)
          try {
            RegExp(&#039;[&#039; + braExpEscape(charUnescape(cs)) + &#039;]&#039;)
            // looks good, finish up the class.
            re += c
          } catch (er) {
            // out of order ranges in JS are errors, but in glob syntax,
            // they&#039;re just a range that matches nothing.
            re = re.substring(0, reClassStart) + &#039;(?:$.)&#039; // match nothing ever
          }
          hasMagic = true
          inClass = false
        continue

        default:
          // swallow any state char that wasn&#039;t consumed
          clearStateChar()

          if (reSpecials[c] &amp;&amp; !(c === &#039;^&#039; &amp;&amp; inClass)) {
            re += &#039;\\&#039;
          }

          re += c
          break

      } // switch
    } // for

    // handle the case where we left a class open.
    // &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.slice(classStart + 1)
      sp = this.parse(cs, SUBPARSE)
      re = re.substring(0, reClassStart) + &#039;\\[&#039; + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail
      tail = re.slice(pl.reStart + pl.open.length)
      this.debug(&#039;setting tail&#039;, re, pl)
      // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) =&gt; {
        /* istanbul ignore else - should already be done */
        if (!$2) {
          // the | isn&#039;t already escaped, so escape it.
          $2 = &#039;\\&#039;
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That&#039;s why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + &#039;|&#039;
      })

      this.debug(&#039;tail=%j\n   %s&#039;, tail, tail, pl, re)
      const t = pl.type === &#039;*&#039; ? star
        : pl.type === &#039;?&#039; ? qmark
        : &#039;\\&#039; + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart) + t + &#039;\\(&#039; + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += &#039;\\\\&#039;
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    const addPatternStart = addPatternStartSet[re.charAt(0)]

    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like &#039;a.xyz.yz&#039; doesn&#039;t match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for (let n = negativeLists.length - 1; n &gt; -1; n--) {
      const nl = negativeLists[n]

      const nlBefore = re.slice(0, nl.reStart)
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
      let nlAfter = re.slice(nl.reEnd)
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter

      // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // &quot;after&quot; the negated section.
      const closeParensBefore = nlBefore.split(&#039;)&#039;).length
      const openParensBefore = nlBefore.split(&#039;(&#039;).length - closeParensBefore
      let cleanAfter = nlAfter
      for (let i = 0; i &lt; openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, &#039;&#039;)
      }
      nlAfter = cleanAfter

      const dollar = nlAfter === &#039;&#039; &amp;&amp; isSub !== SUBPARSE ? &#039;(?:$|\\/)&#039; : &#039;&#039;

      re = nlBefore + nlFirst + nlAfter + dollar + nlLast
    }

    // if the re is not &quot;&quot; at this point, then we need to make sure
    // it doesn&#039;t match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== &#039;&#039; &amp;&amp; hasMagic) {
      re = &#039;(?=.)&#039; + re
    }

    if (addPatternStart) {
      re = patternStart() + re
    }

    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [re, hasMagic]
    }

    // if it&#039;s nocase, and the lcase/uppercase don&#039;t match, it&#039;s magic
    if (options.nocase &amp;&amp; !hasMagic) {
      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it&#039;ll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    const flags = options.nocase ? &#039;i&#039; : &#039;&#039;
    try {
      return Object.assign(new RegExp(&#039;^&#039; + re + &#039;$&#039;, flags), {
        _glob: pattern,
        _src: re,
      })
    } catch (er) /* istanbul ignore next - should be impossible */ {
      // If it was an invalid regular expression, then it can&#039;t match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it&#039;s not a /m regex.
      return new RegExp(&#039;$.&#039;)
    }
  }

  makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

    // at this point, this.set is a 2d array of partial
    // pattern strings, or &quot;**&quot;.
    //
    // It&#039;s better to use .match().  This function shouldn&#039;t
    // be used, really, but it&#039;s pretty convenient sometimes,
    // when you just want to work with a regex.
    const set = this.set

    if (!set.length) {
      this.regexp = false
      return this.regexp
    }
    const options = this.options

    const twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    const flags = options.nocase ? &#039;i&#039; : &#039;&#039;

    // coalesce globstars and regexpify non-globstar patterns
    // if it&#039;s the only item, then we just do one twoStar
    // if it&#039;s the first, and there are more, prepend (\/|twoStar\/)? to next
    // if it&#039;s the last, append (\/twoStar|) to previous
    // if it&#039;s in the middle, append (\/|\/twoStar\/) to previous
    // then filter out GLOBSTAR symbols
    let re = set.map(pattern =&gt; {
      pattern = pattern.map(p =&gt;
        typeof p === &#039;string&#039; ? regExpEscape(p)
        : p === GLOBSTAR ? GLOBSTAR
        : p._src
      ).reduce((set, p) =&gt; {
        if (!(set[set.length - 1] === GLOBSTAR &amp;&amp; p === GLOBSTAR)) {
          set.push(p)
        }
        return set
      }, [])
      pattern.forEach((p, i) =&gt; {
        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {
          return
        }
        if (i === 0) {
          if (pattern.length &gt; 1) {
            pattern[i+1] = &#039;(?:\\\/|&#039; + twoStar + &#039;\\\/)?&#039; + pattern[i+1]
          } else {
            pattern[i] = twoStar
          }
        } else if (i === pattern.length - 1) {
          pattern[i-1] += &#039;(?:\\\/|&#039; + twoStar + &#039;)?&#039;
        } else {
          pattern[i-1] += &#039;(?:\\\/|\\\/&#039; + twoStar + &#039;\\\/)&#039; + pattern[i+1]
          pattern[i+1] = GLOBSTAR
        }
      })
      return pattern.filter(p =&gt; p !== GLOBSTAR).join(&#039;/&#039;)
    }).join(&#039;|&#039;)

    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = &#039;^(?:&#039; + re + &#039;)$&#039;

    // can match anything, as long as it&#039;s not this.
    if (this.negate) re = &#039;^(?!&#039; + re + &#039;).*$&#039;

    try {
      this.regexp = new RegExp(re, flags)
    } catch (ex) /* istanbul ignore next - should be impossible */ {
      this.regexp = false
    }
    return this.regexp
  }

  match (f, partial = this.partial) {
    this.debug(&#039;match&#039;, f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === &#039;&#039;

    if (f === &#039;/&#039; &amp;&amp; partial) return true

    const options = this.options

    // windows: need to use /, not \
    if (path.sep !== &#039;/&#039;) {
      f = f.split(path.sep).join(&#039;/&#039;)
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    this.debug(this.pattern, &#039;split&#039;, f)

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    const set = this.set
    this.debug(this.pattern, &#039;set&#039;, set)

    // Find the basename of the path by looking for the last non-empty segment
    let filename
    for (let i = f.length - 1; i &gt;= 0; i--) {
      filename = f[i]
      if (filename) break
    }

    for (let i = 0; i &lt; set.length; i++) {
      const pattern = set[i]
      let file = f
      if (options.matchBase &amp;&amp; pattern.length === 1) {
        file = [filename]
      }
      const hit = this.matchOne(file, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn&#039;t get any hits.  this is success if it&#039;s a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

  static defaults (def) {
    return minimatch.defaults(def).Minimatch
  }
}

minimatch.Minimatch = Minimatch
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
