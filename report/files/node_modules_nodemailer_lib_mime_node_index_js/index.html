<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodemailer/lib/mime-node/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodemailer/lib/mime-node/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.58</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1315</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">119.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */

&#039;use strict&#039;;

const crypto = require(&#039;crypto&#039;);
const fs = require(&#039;fs&#039;);
const punycode = require(&#039;../punycode&#039;);
const PassThrough = require(&#039;stream&#039;).PassThrough;
const shared = require(&#039;../shared&#039;);

const mimeFuncs = require(&#039;../mime-funcs&#039;);
const qp = require(&#039;../qp&#039;);
const base64 = require(&#039;../base64&#039;);
const addressparser = require(&#039;../addressparser&#039;);
const nmfetch = require(&#039;../fetch&#039;);
const LastNewline = require(&#039;./last-newline&#039;);

const LeWindows = require(&#039;./le-windows&#039;);
const LeUnix = require(&#039;./le-unix&#039;);

/**
 * Creates a new mime tree node. Assumes &#039;multipart/*&#039; as the content type
 * if it is a branch, anything else counts as leaf. If rootNode is missing from
 * the options, assumes this is the root.
 *
 * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)
 * @param {Object} [options] optional options
 * @param {Object} [options.rootNode] root node for this tree
 * @param {Object} [options.parentNode] immediate parent for this node
 * @param {Object} [options.filename] filename for an attachment node
 * @param {String} [options.baseBoundary] shared part of the unique multipart boundary
 * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers
 * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing
 * @param {String} [options.textEncoding] either &#039;Q&#039; (the default) or &#039;B&#039;
 */
class MimeNode {
    constructor(contentType, options) {
        this.nodeCounter = 0;

        options = options || {};

        /**
         * shared part of the unique multipart boundary
         */
        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString(&#039;hex&#039;);
        this.boundaryPrefix = options.boundaryPrefix || &#039;--_NmP&#039;;

        this.disableFileAccess = !!options.disableFileAccess;
        this.disableUrlAccess = !!options.disableUrlAccess;

        this.normalizeHeaderKey = options.normalizeHeaderKey;

        /**
         * If date headers is missing and current node is the root, this value is used instead
         */
        this.date = new Date();

        /**
         * Root node for current mime tree
         */
        this.rootNode = options.rootNode || this;

        /**
         * If true include Bcc in generated headers (if available)
         */
        this.keepBcc = !!options.keepBcc;

        /**
         * If filename is specified but contentType is not (probably an attachment)
         * detect the content type from filename extension
         */
        if (options.filename) {
            /**
             * Filename for this node. Useful with attachments
             */
            this.filename = options.filename;
            if (!contentType) {
                contentType = mimeFuncs.detectMimeType(this.filename.split(&#039;.&#039;).pop());
            }
        }

        /**
         * Indicates which encoding should be used for header strings: &quot;Q&quot; or &quot;B&quot;
         */
        this.textEncoding = (options.textEncoding || &#039;&#039;).toString().trim().charAt(0).toUpperCase();

        /**
         * Immediate parent for this node (or undefined if not set)
         */
        this.parentNode = options.parentNode;

        /**
         * Hostname for default message-id values
         */
        this.hostname = options.hostname;

        /**
         * If set to &#039;win&#039; then uses \r\n, if &#039;linux&#039; then \n. If not set (or `raw` is used) then newlines are kept as is.
         */
        this.newline = options.newline;

        /**
         * An array for possible child nodes
         */
        this.childNodes = [];

        /**
         * Used for generating unique boundaries (prepended to the shared base)
         */
        this._nodeId = ++this.rootNode.nodeCounter;

        /**
         * A list of header values for this node in the form of [{key:&#039;&#039;, value:&#039;&#039;}]
         */
        this._headers = [];

        /**
         * True if the content only uses ASCII printable characters
         * @type {Boolean}
         */
        this._isPlainText = false;

        /**
         * True if the content is plain text but has longer lines than allowed
         * @type {Boolean}
         */
        this._hasLongLines = false;

        /**
         * If set, use instead this value for envelopes instead of generating one
         * @type {Boolean}
         */
        this._envelope = false;

        /**
         * If set then use this value as the stream content instead of building it
         * @type {String|Buffer|Stream}
         */
        this._raw = false;

        /**
         * Additional transform streams that the message will be piped before
         * exposing by createReadStream
         * @type {Array}
         */
        this._transforms = [];

        /**
         * Additional process functions that the message will be piped through before
         * exposing by createReadStream. These functions are run after transforms
         * @type {Array}
         */
        this._processFuncs = [];

        /**
         * If content type is set (or derived from the filename) add it to headers
         */
        if (contentType) {
            this.setHeader(&#039;Content-Type&#039;, contentType);
        }
    }

    /////// PUBLIC METHODS

    /**
     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
     *
     * @param {String} [contentType] Optional content type
     * @param {Object} [options] Optional options object
     * @return {Object} Created node object
     */
    createChild(contentType, options) {
        if (!options &amp;&amp; typeof contentType === &#039;object&#039;) {
            options = contentType;
            contentType = undefined;
        }
        let node = new MimeNode(contentType, options);
        this.appendChild(node);
        return node;
    }

    /**
     * Appends an existing node to the mime tree. Removes the node from an existing
     * tree if needed
     *
     * @param {Object} childNode node to be appended
     * @return {Object} Appended node object
     */
    appendChild(childNode) {
        if (childNode.rootNode !== this.rootNode) {
            childNode.rootNode = this.rootNode;
            childNode._nodeId = ++this.rootNode.nodeCounter;
        }

        childNode.parentNode = this;

        this.childNodes.push(childNode);
        return childNode;
    }

    /**
     * Replaces current node with another node
     *
     * @param {Object} node Replacement node
     * @return {Object} Replacement node
     */
    replace(node) {
        if (node === this) {
            return this;
        }

        this.parentNode.childNodes.forEach((childNode, i) =&gt; {
            if (childNode === this) {
                node.rootNode = this.rootNode;
                node.parentNode = this.parentNode;
                node._nodeId = this._nodeId;

                this.rootNode = this;
                this.parentNode = undefined;

                node.parentNode.childNodes[i] = node;
            }
        });

        return node;
    }

    /**
     * Removes current node from the mime tree
     *
     * @return {Object} removed node
     */
    remove() {
        if (!this.parentNode) {
            return this;
        }

        for (let i = this.parentNode.childNodes.length - 1; i &gt;= 0; i--) {
            if (this.parentNode.childNodes[i] === this) {
                this.parentNode.childNodes.splice(i, 1);
                this.parentNode = undefined;
                this.rootNode = this;
                return this;
            }
        }
    }

    /**
     * Sets a header value. If the value for selected key exists, it is overwritten.
     * You can set multiple values as well by using [{key:&#039;&#039;, value:&#039;&#039;}] or
     * {key: &#039;value&#039;} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */
    setHeader(key, value) {
        let added = false,
            headerValue;

        // Allow setting multiple headers at once
        if (!value &amp;&amp; key &amp;&amp; typeof key === &#039;object&#039;) {
            // allow {key:&#039;content-type&#039;, value: &#039;text/plain&#039;}
            if (key.key &amp;&amp; &#039;value&#039; in key) {
                this.setHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:&#039;content-type&#039;, value: &#039;text/plain&#039;}]
                key.forEach(i =&gt; {
                    this.setHeader(i.key, i.value);
                });
            } else {
                // allow {&#039;content-type&#039;: &#039;text/plain&#039;}
                Object.keys(key).forEach(i =&gt; {
                    this.setHeader(i, key[i]);
                });
            }
            return this;
        }

        key = this._normalizeHeaderKey(key);

        headerValue = {
            key,
            value
        };

        // Check if the value exists and overwrite
        for (let i = 0, len = this._headers.length; i &lt; len; i++) {
            if (this._headers[i].key === key) {
                if (!added) {
                    // replace the first match
                    this._headers[i] = headerValue;
                    added = true;
                } else {
                    // remove following matches
                    this._headers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }

        // match not found, append the value
        if (!added) {
            this._headers.push(headerValue);
        }

        return this;
    }

    /**
     * Adds a header value. If the value for selected key exists, the value is appended
     * as a new field and old one is not touched.
     * You can set multiple values as well by using [{key:&#039;&#039;, value:&#039;&#039;}] or
     * {key: &#039;value&#039;} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */
    addHeader(key, value) {
        // Allow setting multiple headers at once
        if (!value &amp;&amp; key &amp;&amp; typeof key === &#039;object&#039;) {
            // allow {key:&#039;content-type&#039;, value: &#039;text/plain&#039;}
            if (key.key &amp;&amp; key.value) {
                this.addHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:&#039;content-type&#039;, value: &#039;text/plain&#039;}]
                key.forEach(i =&gt; {
                    this.addHeader(i.key, i.value);
                });
            } else {
                // allow {&#039;content-type&#039;: &#039;text/plain&#039;}
                Object.keys(key).forEach(i =&gt; {
                    this.addHeader(i, key[i]);
                });
            }
            return this;
        } else if (Array.isArray(value)) {
            value.forEach(val =&gt; {
                this.addHeader(key, val);
            });
            return this;
        }

        this._headers.push({
            key: this._normalizeHeaderKey(key),
            value
        });

        return this;
    }

    /**
     * Retrieves the first mathcing value of a selected key
     *
     * @param {String} key Key to search for
     * @retun {String} Value for the key
     */
    getHeader(key) {
        key = this._normalizeHeaderKey(key);
        for (let i = 0, len = this._headers.length; i &lt; len; i++) {
            if (this._headers[i].key === key) {
                return this._headers[i].value;
            }
        }
    }

    /**
     * Sets body content for current node. If the value is a string, charset is added automatically
     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
     * the charset yourself
     *
     * @param (String|Buffer) content Body content
     * @return {Object} current node
     */
    setContent(content) {
        this.content = content;
        if (typeof this.content.pipe === &#039;function&#039;) {
            // pre-stream handler. might be triggered if a stream is set as content
            // and &#039;error&#039; fires before anything is done with this stream
            this._contentErrorHandler = err =&gt; {
                this.content.removeListener(&#039;error&#039;, this._contentErrorHandler);
                this.content = err;
            };
            this.content.once(&#039;error&#039;, this._contentErrorHandler);
        } else if (typeof this.content === &#039;string&#039;) {
            this._isPlainText = mimeFuncs.isPlainText(this.content);
            if (this._isPlainText &amp;&amp; mimeFuncs.hasLongerLines(this.content, 76)) {
                // If there are lines longer than 76 symbols/bytes do not use 7bit
                this._hasLongLines = true;
            }
        }
        return this;
    }

    build(callback) {
        let promise;

        if (!callback) {
            promise = new Promise((resolve, reject) =&gt; {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        let stream = this.createReadStream();
        let buf = [];
        let buflen = 0;
        let returned = false;

        stream.on(&#039;readable&#039;, () =&gt; {
            let chunk;

            while ((chunk = stream.read()) !== null) {
                buf.push(chunk);
                buflen += chunk.length;
            }
        });

        stream.once(&#039;error&#039;, err =&gt; {
            if (returned) {
                return;
            }
            returned = true;

            return callback(err);
        });

        stream.once(&#039;end&#039;, chunk =&gt; {
            if (returned) {
                return;
            }
            returned = true;

            if (chunk &amp;&amp; chunk.length) {
                buf.push(chunk);
                buflen += chunk.length;
            }
            return callback(null, Buffer.concat(buf, buflen));
        });

        return promise;
    }

    getTransferEncoding() {
        let transferEncoding = false;
        let contentType = (this.getHeader(&#039;Content-Type&#039;) || &#039;&#039;).toString().toLowerCase().trim();

        if (this.content) {
            transferEncoding = (this.getHeader(&#039;Content-Transfer-Encoding&#039;) || &#039;&#039;).toString().toLowerCase().trim();
            if (!transferEncoding || ![&#039;base64&#039;, &#039;quoted-printable&#039;].includes(transferEncoding)) {
                if (/^text\//i.test(contentType)) {
                    // If there are no special symbols, no need to modify the text
                    if (this._isPlainText &amp;&amp; !this._hasLongLines) {
                        transferEncoding = &#039;7bit&#039;;
                    } else if (typeof this.content === &#039;string&#039; || this.content instanceof Buffer) {
                        // detect preferred encoding for string value
                        transferEncoding = this._getTextEncoding(this.content) === &#039;Q&#039; ? &#039;quoted-printable&#039; : &#039;base64&#039;;
                    } else {
                        // we can not check content for a stream, so either use preferred encoding or fallback to QP
                        transferEncoding = this.textEncoding === &#039;B&#039; ? &#039;base64&#039; : &#039;quoted-printable&#039;;
                    }
                } else if (!/^(multipart|message)\//i.test(contentType)) {
                    transferEncoding = transferEncoding || &#039;base64&#039;;
                }
            }
        }
        return transferEncoding;
    }

    /**
     * Builds the header block for the mime node. Append \r\n\r\n before writing the content
     *
     * @returns {String} Headers
     */
    buildHeaders() {
        let transferEncoding = this.getTransferEncoding();
        let headers = [];

        if (transferEncoding) {
            this.setHeader(&#039;Content-Transfer-Encoding&#039;, transferEncoding);
        }

        if (this.filename &amp;&amp; !this.getHeader(&#039;Content-Disposition&#039;)) {
            this.setHeader(&#039;Content-Disposition&#039;, &#039;attachment&#039;);
        }

        // Ensure mandatory header fields
        if (this.rootNode === this) {
            if (!this.getHeader(&#039;Date&#039;)) {
                this.setHeader(&#039;Date&#039;, this.date.toUTCString().replace(/GMT/, &#039;+0000&#039;));
            }

            // ensure that Message-Id is present
            this.messageId();

            if (!this.getHeader(&#039;MIME-Version&#039;)) {
                this.setHeader(&#039;MIME-Version&#039;, &#039;1.0&#039;);
            }

            // Ensure that Content-Type is the last header for the root node
            for (let i = this._headers.length - 2; i &gt;= 0; i--) {
                let header = this._headers[i];
                if (header.key === &#039;Content-Type&#039;) {
                    this._headers.splice(i, 1);
                    this._headers.push(header);
                }
            }
        }

        this._headers.forEach(header =&gt; {
            let key = header.key;
            let value = header.value;
            let structured;
            let param;
            let options = {};
            let formattedHeaders = [&#039;From&#039;, &#039;Sender&#039;, &#039;To&#039;, &#039;Cc&#039;, &#039;Bcc&#039;, &#039;Reply-To&#039;, &#039;Date&#039;, &#039;References&#039;];

            if (value &amp;&amp; typeof value === &#039;object&#039; &amp;&amp; !formattedHeaders.includes(key)) {
                Object.keys(value).forEach(key =&gt; {
                    if (key !== &#039;value&#039;) {
                        options[key] = value[key];
                    }
                });
                value = (value.value || &#039;&#039;).toString();
                if (!value.trim()) {
                    return;
                }
            }

            if (options.prepared) {
                // header value is
                if (options.foldLines) {
                    headers.push(mimeFuncs.foldLines(key + &#039;: &#039; + value));
                } else {
                    headers.push(key + &#039;: &#039; + value);
                }
                return;
            }

            switch (header.key) {
                case &#039;Content-Disposition&#039;:
                    structured = mimeFuncs.parseHeaderValue(value);
                    if (this.filename) {
                        structured.params.filename = this.filename;
                    }
                    value = mimeFuncs.buildHeaderValue(structured);
                    break;

                case &#039;Content-Type&#039;:
                    structured = mimeFuncs.parseHeaderValue(value);

                    this._handleContentType(structured);

                    if (structured.value.match(/^text\/plain\b/) &amp;&amp; typeof this.content === &#039;string&#039; &amp;&amp; /[\u0080-\uFFFF]/.test(this.content)) {
                        structured.params.charset = &#039;utf-8&#039;;
                    }

                    value = mimeFuncs.buildHeaderValue(structured);

                    if (this.filename) {
                        // add support for non-compliant clients like QQ webmail
                        // we can&#039;t build the value with buildHeaderValue as the value is non standard and
                        // would be converted to parameter continuation encoding that we do not want
                        param = this._encodeWords(this.filename);

                        if (param !== this.filename || /[\s&#039;&quot;\\;:/=(),&lt;&gt;@[\]?]|^-/.test(param)) {
                            // include value in quotes if needed
                            param = &#039;&quot;&#039; + param + &#039;&quot;&#039;;
                        }
                        value += &#039;; name=&#039; + param;
                    }
                    break;

                case &#039;Bcc&#039;:
                    if (!this.keepBcc) {
                        // skip BCC values
                        return;
                    }
                    break;
            }

            value = this._encodeHeaderValue(key, value);

            // skip empty lines
            if (!(value || &#039;&#039;).toString().trim()) {
                return;
            }

            if (typeof this.normalizeHeaderKey === &#039;function&#039;) {
                let normalized = this.normalizeHeaderKey(key, value);
                if (normalized &amp;&amp; typeof normalized === &#039;string&#039; &amp;&amp; normalized.length) {
                    key = normalized;
                }
            }

            headers.push(mimeFuncs.foldLines(key + &#039;: &#039; + value, 76));
        });

        return headers.join(&#039;\r\n&#039;);
    }

    /**
     * Streams the rfc2822 message from the current node. If this is a root node,
     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
     *
     * @return {String} Compiled message
     */
    createReadStream(options) {
        options = options || {};

        let stream = new PassThrough(options);
        let outputStream = stream;
        let transform;

        this.stream(stream, options, err =&gt; {
            if (err) {
                outputStream.emit(&#039;error&#039;, err);
                return;
            }
            stream.end();
        });

        for (let i = 0, len = this._transforms.length; i &lt; len; i++) {
            transform = typeof this._transforms[i] === &#039;function&#039; ? this._transforms[i]() : this._transforms[i];
            outputStream.once(&#039;error&#039;, err =&gt; {
                transform.emit(&#039;error&#039;, err);
            });
            outputStream = outputStream.pipe(transform);
        }

        // ensure terminating newline after possible user transforms
        transform = new LastNewline();
        outputStream.once(&#039;error&#039;, err =&gt; {
            transform.emit(&#039;error&#039;, err);
        });
        outputStream = outputStream.pipe(transform);

        // dkim and stuff
        for (let i = 0, len = this._processFuncs.length; i &lt; len; i++) {
            transform = this._processFuncs[i];
            outputStream = transform(outputStream);
        }

        if (this.newline) {
            const winbreak = [&#039;win&#039;, &#039;windows&#039;, &#039;dos&#039;, &#039;\r\n&#039;].includes(this.newline.toString().toLowerCase());
            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();

            const stream = outputStream.pipe(newlineTransform);
            outputStream.on(&#039;error&#039;, err =&gt; stream.emit(&#039;error&#039;, err));
            return stream;
        }

        return outputStream;
    }

    /**
     * Appends a transform stream object to the transforms list. Final output
     * is passed through this stream before exposing
     *
     * @param {Object} transform Read-Write stream
     */
    transform(transform) {
        this._transforms.push(transform);
    }

    /**
     * Appends a post process function. The functon is run after transforms and
     * uses the following syntax
     *
     *   processFunc(input) -&gt; outputStream
     *
     * @param {Object} processFunc Read-Write stream
     */
    processFunc(processFunc) {
        this._processFuncs.push(processFunc);
    }

    stream(outputStream, options, done) {
        let transferEncoding = this.getTransferEncoding();
        let contentStream;
        let localStream;

        // protect actual callback against multiple triggering
        let returned = false;
        let callback = err =&gt; {
            if (returned) {
                return;
            }
            returned = true;
            done(err);
        };

        // for multipart nodes, push child nodes
        // for content nodes end the stream
        let finalize = () =&gt; {
            let childId = 0;
            let processChildNode = () =&gt; {
                if (childId &gt;= this.childNodes.length) {
                    outputStream.write(&#039;\r\n--&#039; + this.boundary + &#039;--\r\n&#039;);
                    return callback();
                }
                let child = this.childNodes[childId++];
                outputStream.write((childId &gt; 1 ? &#039;\r\n&#039; : &#039;&#039;) + &#039;--&#039; + this.boundary + &#039;\r\n&#039;);
                child.stream(outputStream, options, err =&gt; {
                    if (err) {
                        return callback(err);
                    }
                    setImmediate(processChildNode);
                });
            };

            if (this.multipart) {
                setImmediate(processChildNode);
            } else {
                return callback();
            }
        };

        // pushes node content
        let sendContent = () =&gt; {
            if (this.content) {
                if (Object.prototype.toString.call(this.content) === &#039;[object Error]&#039;) {
                    // content is already errored
                    return callback(this.content);
                }

                if (typeof this.content.pipe === &#039;function&#039;) {
                    this.content.removeListener(&#039;error&#039;, this._contentErrorHandler);
                    this._contentErrorHandler = err =&gt; callback(err);
                    this.content.once(&#039;error&#039;, this._contentErrorHandler);
                }

                let createStream = () =&gt; {
                    if ([&#039;quoted-printable&#039;, &#039;base64&#039;].includes(transferEncoding)) {
                        contentStream = new (transferEncoding === &#039;base64&#039; ? base64 : qp).Encoder(options);

                        contentStream.pipe(outputStream, {
                            end: false
                        });
                        contentStream.once(&#039;end&#039;, finalize);
                        contentStream.once(&#039;error&#039;, err =&gt; callback(err));

                        localStream = this._getStream(this.content);
                        localStream.pipe(contentStream);
                    } else {
                        // anything that is not QP or Base54 passes as-is
                        localStream = this._getStream(this.content);
                        localStream.pipe(outputStream, {
                            end: false
                        });
                        localStream.once(&#039;end&#039;, finalize);
                    }

                    localStream.once(&#039;error&#039;, err =&gt; callback(err));
                };

                if (this.content._resolve) {
                    let chunks = [];
                    let chunklen = 0;
                    let returned = false;
                    let sourceStream = this._getStream(this.content);
                    sourceStream.on(&#039;error&#039;, err =&gt; {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        callback(err);
                    });
                    sourceStream.on(&#039;readable&#039;, () =&gt; {
                        let chunk;
                        while ((chunk = sourceStream.read()) !== null) {
                            chunks.push(chunk);
                            chunklen += chunk.length;
                        }
                    });
                    sourceStream.on(&#039;end&#039;, () =&gt; {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        this.content._resolve = false;
                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);
                        setImmediate(createStream);
                    });
                } else {
                    setImmediate(createStream);
                }
                return;
            } else {
                return setImmediate(finalize);
            }
        };

        if (this._raw) {
            setImmediate(() =&gt; {
                if (Object.prototype.toString.call(this._raw) === &#039;[object Error]&#039;) {
                    // content is already errored
                    return callback(this._raw);
                }

                // remove default error handler (if set)
                if (typeof this._raw.pipe === &#039;function&#039;) {
                    this._raw.removeListener(&#039;error&#039;, this._contentErrorHandler);
                }

                let raw = this._getStream(this._raw);
                raw.pipe(outputStream, {
                    end: false
                });
                raw.on(&#039;error&#039;, err =&gt; outputStream.emit(&#039;error&#039;, err));
                raw.on(&#039;end&#039;, finalize);
            });
        } else {
            outputStream.write(this.buildHeaders() + &#039;\r\n\r\n&#039;);
            setImmediate(sendContent);
        }
    }

    /**
     * Sets envelope to be used instead of the generated one
     *
     * @return {Object} SMTP envelope in the form of {from: &#039;from@example.com&#039;, to: [&#039;to@example.com&#039;]}
     */
    setEnvelope(envelope) {
        let list;

        this._envelope = {
            from: false,
            to: []
        };

        if (envelope.from) {
            list = [];
            this._convertAddresses(this._parseAddresses(envelope.from), list);
            list = list.filter(address =&gt; address &amp;&amp; address.address);
            if (list.length &amp;&amp; list[0]) {
                this._envelope.from = list[0].address;
            }
        }
        [&#039;to&#039;, &#039;cc&#039;, &#039;bcc&#039;].forEach(key =&gt; {
            if (envelope[key]) {
                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
            }
        });

        this._envelope.to = this._envelope.to.map(to =&gt; to.address).filter(address =&gt; address);

        let standardFields = [&#039;to&#039;, &#039;cc&#039;, &#039;bcc&#039;, &#039;from&#039;];
        Object.keys(envelope).forEach(key =&gt; {
            if (!standardFields.includes(key)) {
                this._envelope[key] = envelope[key];
            }
        });

        return this;
    }

    /**
     * Generates and returns an object with parsed address fields
     *
     * @return {Object} Address object
     */
    getAddresses() {
        let addresses = {};

        this._headers.forEach(header =&gt; {
            let key = header.key.toLowerCase();
            if ([&#039;from&#039;, &#039;sender&#039;, &#039;reply-to&#039;, &#039;to&#039;, &#039;cc&#039;, &#039;bcc&#039;].includes(key)) {
                if (!Array.isArray(addresses[key])) {
                    addresses[key] = [];
                }

                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
            }
        });

        return addresses;
    }

    /**
     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
     *
     * @return {Object} SMTP envelope in the form of {from: &#039;from@example.com&#039;, to: [&#039;to@example.com&#039;]}
     */
    getEnvelope() {
        if (this._envelope) {
            return this._envelope;
        }

        let envelope = {
            from: false,
            to: []
        };
        this._headers.forEach(header =&gt; {
            let list = [];
            if (header.key === &#039;From&#039; || (!envelope.from &amp;&amp; [&#039;Reply-To&#039;, &#039;Sender&#039;].includes(header.key))) {
                this._convertAddresses(this._parseAddresses(header.value), list);
                if (list.length &amp;&amp; list[0]) {
                    envelope.from = list[0].address;
                }
            } else if ([&#039;To&#039;, &#039;Cc&#039;, &#039;Bcc&#039;].includes(header.key)) {
                this._convertAddresses(this._parseAddresses(header.value), envelope.to);
            }
        });

        envelope.to = envelope.to.map(to =&gt; to.address);

        return envelope;
    }

    /**
     * Returns Message-Id value. If it does not exist, then creates one
     *
     * @return {String} Message-Id value
     */
    messageId() {
        let messageId = this.getHeader(&#039;Message-ID&#039;);
        // You really should define your own Message-Id field!
        if (!messageId) {
            messageId = this._generateMessageId();
            this.setHeader(&#039;Message-ID&#039;, messageId);
        }
        return messageId;
    }

    /**
     * Sets pregenerated content that will be used as the output of this node
     *
     * @param {String|Buffer|Stream} Raw MIME contents
     */
    setRaw(raw) {
        this._raw = raw;

        if (this._raw &amp;&amp; typeof this._raw.pipe === &#039;function&#039;) {
            // pre-stream handler. might be triggered if a stream is set as content
            // and &#039;error&#039; fires before anything is done with this stream
            this._contentErrorHandler = err =&gt; {
                this._raw.removeListener(&#039;error&#039;, this._contentErrorHandler);
                this._raw = err;
            };
            this._raw.once(&#039;error&#039;, this._contentErrorHandler);
        }

        return this;
    }

    /////// PRIVATE METHODS

    /**
     * Detects and returns handle to a stream related with the content.
     *
     * @param {Mixed} content Node content
     * @returns {Object} Stream object
     */
    _getStream(content) {
        let contentStream;

        if (content._resolvedValue) {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();

            setImmediate(() =&gt; {
                try {
                    contentStream.end(content._resolvedValue);
                } catch (err) {
                    contentStream.emit(&#039;error&#039;, err);
                }
            });

            return contentStream;
        } else if (typeof content.pipe === &#039;function&#039;) {
            // assume as stream
            return content;
        } else if (content &amp;&amp; typeof content.path === &#039;string&#039; &amp;&amp; !content.href) {
            if (this.disableFileAccess) {
                contentStream = new PassThrough();
                setImmediate(() =&gt; contentStream.emit(&#039;error&#039;, new Error(&#039;File access rejected for &#039; + content.path)));
                return contentStream;
            }
            // read file
            return fs.createReadStream(content.path);
        } else if (content &amp;&amp; typeof content.href === &#039;string&#039;) {
            if (this.disableUrlAccess) {
                contentStream = new PassThrough();
                setImmediate(() =&gt; contentStream.emit(&#039;error&#039;, new Error(&#039;Url access rejected for &#039; + content.href)));
                return contentStream;
            }
            // fetch URL
            return nmfetch(content.href, { headers: content.httpHeaders });
        } else {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();

            setImmediate(() =&gt; {
                try {
                    contentStream.end(content || &#039;&#039;);
                } catch (err) {
                    contentStream.emit(&#039;error&#039;, err);
                }
            });
            return contentStream;
        }
    }

    /**
     * Parses addresses. Takes in a single address or an array or an
     * array of address arrays (eg. To: [[first group], [second group],...])
     *
     * @param {Mixed} addresses Addresses to be parsed
     * @return {Array} An array of address objects
     */
    _parseAddresses(addresses) {
        return [].concat.apply(
            [],
            [].concat(addresses).map(address =&gt; {
                // eslint-disable-line prefer-spread
                if (address &amp;&amp; address.address) {
                    address.address = this._normalizeAddress(address.address);
                    address.name = address.name || &#039;&#039;;
                    return [address];
                }
                return addressparser(address);
            })
        );
    }

    /**
     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
     *
     * @param {String} key Key to be normalized
     * @return {String} key in Camel-Case form
     */
    _normalizeHeaderKey(key) {
        key = (key || &#039;&#039;)
            .toString()
            // no newlines in keys
            .replace(/\r?\n|\r/g, &#039; &#039;)
            .trim()
            .toLowerCase()
            // use uppercase words, except MIME
            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c =&gt; c.toUpperCase())
            // special case
            .replace(/^Content-Features$/i, &#039;Content-features&#039;);

        return key;
    }

    /**
     * Checks if the content type is multipart and defines boundary if needed.
     * Doesn&#039;t return anything, modifies object argument instead.
     *
     * @param {Object} structured Parsed header value for &#039;Content-Type&#039; key
     */
    _handleContentType(structured) {
        this.contentType = structured.value.trim().toLowerCase();

        this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf(&#039;/&#039;) + 1) : false;

        if (this.multipart) {
            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
        } else {
            this.boundary = false;
        }
    }

    /**
     * Generates a multipart boundary value
     *
     * @return {String} boundary value
     */
    _generateBoundary() {
        return this.rootNode.boundaryPrefix + &#039;-&#039; + this.rootNode.baseBoundary + &#039;-Part_&#039; + this._nodeId;
    }

    /**
     * Encodes a header value for use in the generated rfc2822 email.
     *
     * @param {String} key Header key
     * @param {String} value Header value
     */
    _encodeHeaderValue(key, value) {
        key = this._normalizeHeaderKey(key);

        switch (key) {
            // Structured headers
            case &#039;From&#039;:
            case &#039;Sender&#039;:
            case &#039;To&#039;:
            case &#039;Cc&#039;:
            case &#039;Bcc&#039;:
            case &#039;Reply-To&#039;:
                return this._convertAddresses(this._parseAddresses(value));

            // values enclosed in &lt;&gt;
            case &#039;Message-ID&#039;:
            case &#039;In-Reply-To&#039;:
            case &#039;Content-Id&#039;:
                value = (value || &#039;&#039;).toString().replace(/\r?\n|\r/g, &#039; &#039;);

                if (value.charAt(0) !== &#039;&lt;&#039;) {
                    value = &#039;&lt;&#039; + value;
                }

                if (value.charAt(value.length - 1) !== &#039;&gt;&#039;) {
                    value = value + &#039;&gt;&#039;;
                }
                return value;

            // space separated list of values enclosed in &lt;&gt;
            case &#039;References&#039;:
                value = [].concat
                    .apply(
                        [],
                        [].concat(value || &#039;&#039;).map(elm =&gt; {
                            // eslint-disable-line prefer-spread
                            elm = (elm || &#039;&#039;)
                                .toString()
                                .replace(/\r?\n|\r/g, &#039; &#039;)
                                .trim();
                            return elm.replace(/&lt;[^&gt;]*&gt;/g, str =&gt; str.replace(/\s/g, &#039;&#039;)).split(/\s+/);
                        })
                    )
                    .map(elm =&gt; {
                        if (elm.charAt(0) !== &#039;&lt;&#039;) {
                            elm = &#039;&lt;&#039; + elm;
                        }
                        if (elm.charAt(elm.length - 1) !== &#039;&gt;&#039;) {
                            elm = elm + &#039;&gt;&#039;;
                        }
                        return elm;
                    });

                return value.join(&#039; &#039;).trim();

            case &#039;Date&#039;:
                if (Object.prototype.toString.call(value) === &#039;[object Date]&#039;) {
                    return value.toUTCString().replace(/GMT/, &#039;+0000&#039;);
                }

                value = (value || &#039;&#039;).toString().replace(/\r?\n|\r/g, &#039; &#039;);
                return this._encodeWords(value);

            case &#039;Content-Type&#039;:
            case &#039;Content-Disposition&#039;:
                // if it includes a filename then it is already encoded
                return (value || &#039;&#039;).toString().replace(/\r?\n|\r/g, &#039; &#039;);

            default:
                value = (value || &#039;&#039;).toString().replace(/\r?\n|\r/g, &#039; &#039;);
                // encodeWords only encodes if needed, otherwise the original string is returned
                return this._encodeWords(value);
        }
    }

    /**
     * Rebuilds address object using punycode and other adjustments
     *
     * @param {Array} addresses An array of address objects
     * @param {Array} [uniqueList] An array to be populated with addresses
     * @return {String} address string
     */
    _convertAddresses(addresses, uniqueList) {
        let values = [];

        uniqueList = uniqueList || [];

        [].concat(addresses || []).forEach(address =&gt; {
            if (address.address) {
                address.address = this._normalizeAddress(address.address);

                if (!address.name) {
                    values.push(address.address.indexOf(&#039; &#039;) &gt;= 0 ? `&lt;${address.address}&gt;` : `${address.address}`);
                } else if (address.name) {
                    values.push(`${this._encodeAddressName(address.name)} &lt;${address.address}&gt;`);
                }

                if (address.address) {
                    if (!uniqueList.filter(a =&gt; a.address === address.address).length) {
                        uniqueList.push(address);
                    }
                }
            } else if (address.group) {
                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : &#039;&#039;).trim();
                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
            }
        });

        return values.join(&#039;, &#039;);
    }

    /**
     * Normalizes an email address
     *
     * @param {Array} address An array of address objects
     * @return {String} address string
     */
    _normalizeAddress(address) {
        address = (address || &#039;&#039;)
            .toString()
            .replace(/[\x00-\x1F&lt;&gt;]+/g, &#039; &#039;) // remove unallowed characters
            .trim();

        let lastAt = address.lastIndexOf(&#039;@&#039;);
        if (lastAt &lt; 0) {
            // Bare username
            return address;
        }

        let user = address.substr(0, lastAt);
        let domain = address.substr(lastAt + 1);

        // Usernames are not touched and are kept as is even if these include unicode
        // Domains are punycoded by default
        // &#039;jõgeva.ee&#039; will be converted to &#039;xn--jgeva-dua.ee&#039;
        // non-unicode domains are left as is

        let encodedDomain;

        try {
            encodedDomain = punycode.toASCII(domain.toLowerCase());
        } catch (err) {
            // keep as is?
        }

        if (user.indexOf(&#039; &#039;) &gt;= 0) {
            if (user.charAt(0) !== &#039;&quot;&#039;) {
                user = &#039;&quot;&#039; + user;
            }
            if (user.substr(-1) !== &#039;&quot;&#039;) {
                user = user + &#039;&quot;&#039;;
            }
        }

        return `${user}@${encodedDomain}`;
    }

    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */
    _encodeAddressName(name) {
        if (!/^[\w ]*$/.test(name)) {
            if (/^[\x20-\x7e]*$/.test(name)) {
                return &#039;&quot;&#039; + name.replace(/([\\&quot;])/g, &#039;\\$1&#039;) + &#039;&quot;&#039;;
            } else {
                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
            }
        }
        return name;
    }

    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */
    _encodeWords(value) {
        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,
        // by default only words that include non-ascii should be converted into encoded words
        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace
        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
    }

    /**
     * Detects best mime encoding for a text value
     *
     * @param {String} value Value to check for
     * @return {String} either &#039;Q&#039; or &#039;B&#039;
     */
    _getTextEncoding(value) {
        value = (value || &#039;&#039;).toString();

        let encoding = this.textEncoding;
        let latinLen;
        let nonLatinLen;

        if (!encoding) {
            // count latin alphabet symbols and 8-bit range symbols + control symbols
            // if there are more latin characters, then use quoted-printable
            // encoding, otherwise use base64
            nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex
            latinLen = (value.match(/[a-z]/gi) || []).length;
            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B
            encoding = nonLatinLen &lt; latinLen ? &#039;Q&#039; : &#039;B&#039;;
        }
        return encoding;
    }

    /**
     * Generates a message id
     *
     * @return {String} Random Message-ID value
     */
    _generateMessageId() {
        return (
            &#039;&lt;&#039; +
            [2, 2, 2, 6].reduce(
                // crux to generate UUID-like random strings
                (prev, len) =&gt; prev + &#039;-&#039; + crypto.randomBytes(len).toString(&#039;hex&#039;),
                crypto.randomBytes(4).toString(&#039;hex&#039;)
            ) +
            &#039;@&#039; +
            // try to use the domain of the FROM address or fallback to server hostname
            (this.getEnvelope().from || this.hostname || &#039;localhost&#039;).split(&#039;@&#039;).pop() +
            &#039;&gt;&#039;
        );
    }
}

module.exports = MimeNode;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
