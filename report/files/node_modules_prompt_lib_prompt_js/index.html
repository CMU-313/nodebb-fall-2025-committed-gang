<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/prompt/lib/prompt.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/prompt/lib/prompt.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">823</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">97.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * prompt.js: Simple prompt for prompting information from the command line
 *
 * (C) 2010, Nodejitsu Inc.
 *
 */

var events = require(&#039;events&#039;),
    readline = require(&#039;readline&#039;),
    eachSeries = require(&#039;async/eachSeries&#039;),
    rejectSeries = require(&#039;async/rejectSeries&#039;),
    read = require(&#039;read&#039;),
    validate = require(&#039;revalidator&#039;).validate,
    winston = require(&#039;winston&#039;),
    colors = require(&#039;@colors/colors/safe&#039;);

//
// Monkey-patch readline.Interface to work-around
// https://github.com/joyent/node/issues/3860
//
readline.Interface.prototype.setPrompt = function(prompt, length) {
  this._prompt = prompt;
  if (length) {
    this._promptLength = length;
  } else {
    var lines = prompt.split(/[\r\n]/);
    var lastLine = lines[lines.length - 1];
    this._promptLength = lastLine.replace(/\u001b\[(\d+(;\d+)*)?m/g, &#039;&#039;).length;
  }
};

//
// Expose version using `pkginfo`
//
module.exports.version = require(&#039;../package.json&#039;).version;

var stdin, stdout, history = [];
var prompt = module.exports = Object.create(events.EventEmitter.prototype);
var logger = prompt.logger = new winston.Logger({
  transports: [new (winston.transports.Console)()]
});

prompt.started    = false;
prompt.paused     = false;
prompt.stopped    = true;
prompt.allowEmpty = false;
prompt.message    = &#039;prompt&#039;;
prompt.delimiter  = &#039;: &#039;;
prompt.colors     = true;

//
// Create an empty object for the properties
// known to `prompt`
//
prompt.properties = {};

//
// Setup the default winston logger to use
// the `cli` levels and colors.
//
logger.cli();

//
// ### function start (options)
// #### @options {Object} **Optional** Options to consume by prompt
// Starts the prompt by listening to the appropriate events on `options.stdin`
// and `options.stdout`. If no streams are supplied, then `process.stdin`
// and `process.stdout` are used, respectively.
//
prompt.start = function (options) {
  if (prompt.started) {
    return;
  }

  options = options        || {};
  stdin   = options.stdin  || process.stdin;
  stdout  = options.stdout || process.stdout;

  //
  // By default: Remember the last `10` prompt property /
  // answer pairs and don&#039;t allow empty responses globally.
  //
  prompt.memory     = options.memory     || 10;
  prompt.allowEmpty = options.allowEmpty || false;
  prompt.message    = options.message    || prompt.message;
  prompt.delimiter  = options.delimiter  || prompt.delimiter;
  prompt.colors     = options.colors     || prompt.colors;

  if (!options.noHandleSIGINT) {
    if (process.platform !== &#039;win32&#039;) {
      // windows falls apart trying to deal with SIGINT
      process.on(&#039;SIGINT&#039;, function () {
        stdout.write(&#039;\n&#039;);
        process.exit(1);
      });
    } else {
      // listen for the &quot;Ctrl+C&quot; key combination and trigger process event.
      // See https://stackoverflow.com/questions/10021373/what-is-the-windows-equivalent-of-process-onsigint-in-node-js
      stdin.on(&#039;keypress&#039;, function(char, key) {
        if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &#039;c&#039;) {
          stdout.write(&#039;\n&#039;);
          process.emit(&quot;SIGINT&quot;);
          process.exit(1);
        }
      });
    }
  }

  prompt.emit(&#039;start&#039;);
  prompt.started = true;
  prompt.stopped = false;
  return prompt;
};

//
// ### function pause ()
// Pauses input coming in from stdin
//
prompt.pause = function () {
  if (!prompt.started || prompt.stopped || prompt.paused) {
    return;
  }

  stdin.pause();
  prompt.emit(&#039;pause&#039;);
  prompt.paused = true;
  return prompt;
};

//
// ### function stop ()
// Stops input coming in from stdin
//
prompt.stop = function () {
    if (prompt.stopped || !prompt.started) {
        return;
    }

    stdin.destroy();
    prompt.emit(&#039;stop&#039;);
    prompt.stopped = true;
    prompt.started = false;
    prompt.paused = false;
    return prompt;
}

//
// ### function resume ()
// Resumes input coming in from stdin
//
prompt.resume = function () {
  if (!prompt.started || !prompt.paused) {
    return;
  }

  stdin.resume();
  prompt.emit(&#039;resume&#039;);
  prompt.paused = false;
  return prompt;
};

//
// ### function history (search)
// #### @search {Number|string} Index or property name to find.
// Returns the `property:value` pair from within the prompts
// `history` array.
//
prompt.history = function (search) {
  if (typeof search === &#039;number&#039;) {
    return history[search] || {};
  }

  var names = history.map(function (pair) {
    return typeof pair.property === &#039;string&#039;
      ? pair.property
      : pair.property.name;
  });

  if (!~names.indexOf(search)) {
    return null;
  }

  return history.filter(function (pair) {
    return typeof pair.property === &#039;string&#039;
      ? pair.property === search
      : pair.property.name === search;
  })[0];
};

//
// ### function get (schema, callback)
// #### @schema {Array|Object|string} Set of variables to get input for.
// #### @callback {function} Continuation to pass control to when complete.
// Gets input from the user via stdin for the specified message(s) `msg`.
//
prompt.get = function (schema, callback) {
  if (typeof callback === &#039;function&#039;) return prompt._get(schema, callback);

  return new Promise(function (resolve, reject) {
    prompt._get(schema, function (err, result) {
      return err ? reject(err) : resolve(result);
    });
  });
};

prompt._get = function (schema, callback) {
  //
  // Transforms a full JSON-schema into an array describing path and sub-schemas.
  // Used for iteration purposes.
  //
  function untangle(schema, path) {
    var results = [];
    path = path || [];

    if (schema.properties) {
      //
      // Iterate over the properties in the schema and use recursion
      // to process sub-properties.
      //
      Object.keys(schema.properties).forEach(function (key) {
        var obj = {};
        obj[key] = schema.properties[key];

        //
        // Concat a sub-untangling to the results.
        //
        results = results.concat(untangle(obj[key], path.concat(key)));
      });

      // Return the results.
      return results;
    }

    //
    // This is a schema &quot;leaf&quot;.
    //
    return {
      path: path,
      schema: schema
    };
  }

  //
  // Iterate over the values in the schema, represented as
  // a legit single-property object subschemas. Accepts `schema`
  // of the forms:
  //
  //    &#039;prop-name&#039;
  //
  //    [&#039;string-name&#039;, { path: [&#039;or-well-formed-subschema&#039;], properties: ... }]
  //
  //    { path: [&#039;or-well-formed-subschema&#039;], properties: ... ] }
  //
  //    { properties: { &#039;schema-with-no-path&#039; } }
  //
  // And transforms them all into
  //
  //    { path: [&#039;path&#039;, &#039;to&#039;, &#039;property&#039;], properties: { path: { to: ...} } }
  //
  function iterate(schema, get, done) {
    var iterator = [],
        result = {};

    if (typeof schema === &#039;string&#039;) {
      //
      // We can iterate over a single string.
      //
      iterator.push({
        path: [schema],
        schema: prompt.properties[schema.toLowerCase()] || {}
      });
    }
    else if (Array.isArray(schema)) {
      //
      // An array of strings and/or single-prop schema and/or no-prop schema.
      //
      iterator = schema.map(function (element) {
        if (typeof element === &#039;string&#039;) {
          return {
            path: [element],
            schema: prompt.properties[element.toLowerCase()] || {}
          };
        }
        else if (element.properties) {
          return {
            path: [Object.keys(element.properties)[0]],
            schema: element.properties[Object.keys(element.properties)[0]]
          };
        }
        else if (element.path &amp;&amp; element.schema) {
          return element;
        }
        else {
          return {
            path: [element.name || &#039;question&#039;],
            schema: element
          };
        }
      });
    }
    else if (schema.properties) {
      //
      // Or a complete schema `untangle` it for use.
      //
      iterator = untangle(schema);
    }
    else {
      //
      // Or a partial schema and path.
      // TODO: Evaluate need for this option.
      //
      iterator = [{
        schema: schema.schema ? schema.schema : schema,
        path: schema.path || [schema.name || &#039;question&#039;]
      }];
    }

    //
    // Now, iterate and assemble the result.
    //
    eachSeries(iterator, function (branch, next) {
      get(branch, function assembler(err, line) {
        if (err) {
          return next(err);
        }

        function build(path, line) {
          var obj = {};
          if (path.length) {
            obj[path[0]] = build(path.slice(1), line);
            return obj;
          }

          return line;
        }

        function attach(obj, attr) {
          var keys;
          if (typeof attr !== &#039;object&#039; || attr instanceof Array) {
            return attr;
          }

          keys = Object.keys(attr);
          if (keys.length) {
            if (!obj[keys[0]]) {
              obj[keys[0]] = {};
            }
            obj[keys[0]] = attach(obj[keys[0]], attr[keys[0]]);
          }

          return obj;
        }

        result = attach(result, build(branch.path, line));
        next();
      });
    }, function (err) {
      return err ? done(err) : done(null, result);
    });
  }

  iterate(schema, function get(target, next) {
    prompt.getInput(target, function (err, line) {
      return err ? next(err) : next(null, line);
    });
  }, callback);

  return prompt;
};

//
// ### function confirm (msg, callback)
// #### @msg {Array|Object|string} set of message to confirm
// #### @callback {function} Continuation to pass control to when complete.
// Confirms a single or series of messages by prompting the user for a Y/N response.
// Returns `true` if ALL messages are answered in the affirmative, otherwise `false`
//
// `msg` can be a string, or object (or array of strings/objects).
// An object may have the following properties:
//
//    {
//      description: &#039;yes/no&#039; // message to prompt user
//      pattern: /^[yntf]{1}/i // optional - regex defining acceptable responses
//      yes: /^[yt]{1}/i // optional - regex defining `affirmative` responses
//      message: &#039;yes/no&#039; // optional - message to display for invalid responses
//    }
//
prompt.confirm = function (/* msg, options, callback */) {
  var args     = Array.prototype.slice.call(arguments),
      msg      = args.shift(),
      callback = args.pop(),
      opts     = args.shift(),
      vars     = !Array.isArray(msg) ? [msg] : msg,
      RX_Y     = /^[yt]{1}/i,
      RX_YN    = /^[yntf]{1}/i;

  function confirm(target, next) {
    var yes = target.yes || RX_Y,
      options = {
        description: typeof target === &#039;string&#039; ? target : target.description || &#039;yes/no&#039;,
        pattern: target.pattern || RX_YN,
        name: &#039;confirm&#039;,
        message: target.message || &#039;yes/no&#039;
      };

    for (var k in (opts || {})) {
      if (opts.hasOwnProperty(k)) {
        options[k] = opts[k];
      }
    }

    prompt.get([options], function (err, result) {
      next(null, err ? false : yes.test(result[options.name]));
    });
  }

  rejectSeries(vars, confirm, function(err, result) {
    callback(null, result.length===0);
  });
};


// Variables needed outside of getInput for multiline arrays.
var tmp = [];


// ### function getInput (prop, callback)
// #### @prop {Object|string} Variable to get input for.
// #### @callback {function} Continuation to pass control to when complete.
// Gets input from the user via stdin for the specified message `msg`.
//
prompt.getInput = function (prop, callback) {
  var schema = prop.schema || prop,
      propName = prop.path &amp;&amp; prop.path.join(&#039;:&#039;) || prop,
      storedSchema = prompt.properties[propName.toLowerCase()],
      delim = prompt.delimiter,
      defaultLine,
      against,
      hidden,
      length,
      valid,
      name,
      raw,
      msg;

  //
  // If there is a stored schema for `propName` in `propmpt.properties`
  // then use it.
  //
  if (schema instanceof Object &amp;&amp; !Object.keys(schema).length &amp;&amp;
    typeof storedSchema !== &#039;undefined&#039;) {
    schema = storedSchema;
  }

  //
  // Build a proper validation schema if we just have a string
  // and no `storedSchema`.
  //
  if (typeof prop === &#039;string&#039; &amp;&amp; !storedSchema) {
    schema = {};
  }

  schema = convert(schema);
  defaultLine = schema.default;
  name = prop.description || schema.description || propName;
  raw = prompt.colors
    ? [colors.grey(name), colors.grey(delim)]
    : [name, delim];

  if (prompt.message)
    raw.unshift(prompt.message, delim);

  prop = {
    schema: schema,
    path: propName.split(&#039;:&#039;)
  };

  //
  // If the schema has no `properties` value then set
  // it to an object containing the current schema
  // for `propName`.
  //
  if (!schema.properties) {
    schema = (function () {
      var obj = { properties: {} };
      obj.properties[propName] = schema;
      return obj;
    })();
  }

  //
  // Handle overrides here.
  // TODO: Make overrides nestable
  //
  if (prompt.override &amp;&amp; prompt.override.hasOwnProperty(propName)) {
    if (prompt._performValidation(name, prop, prompt.override, schema, -1, callback)) {
      return callback(null, prompt.override[propName]);
    }

    delete prompt.override[propName];
  }

  //
  // Check if we should skip this prompt
  //
  if (typeof prop.schema.ask === &#039;function&#039; &amp;&amp;
    !prop.schema.ask()) {
    return callback(null, prop.schema.default || &#039;&#039;);
  }

  var type = (schema.properties &amp;&amp; schema.properties[propName] &amp;&amp;
              schema.properties[propName].type || &#039;&#039;).toLowerCase().trim(),
      wait = type === &#039;array&#039;;

  if (type === &#039;array&#039;) {
    length = prop.schema.maxItems;
    if (length) {
      msg = (tmp.length + 1).toString() + &#039;/&#039; + length.toString();
    }
    else {
      msg = (tmp.length + 1).toString();
    }
    msg += delim;
    raw.push(prompt.colors ? colors.grey(msg) : msg);
  }

  //
  // Calculate the raw length and colorize the prompt
  //
  length = raw.join(&#039;&#039;).length;
  // raw[0] = raw[0];
  msg = raw.join(&#039;&#039;);

  if (schema.help) {
    schema.help.forEach(function (line) {
      logger.help(line);
    });
  }

  //
  // Emit a &quot;prompting&quot; event
  //
  prompt.emit(&#039;prompt&#039;, prop);

  //
  // If defaultLine is a function, execute it and store it back to defaultLine
  //
  if(typeof defaultLine === &#039;function&#039;) {
    defaultLine = defaultLine();
  }

  //
  // If there is no default line, set it to an empty string
  //
  if(typeof defaultLine === &#039;undefined&#039;) {
    defaultLine = &#039;&#039;;
  }

  //
  // set to string for readline ( will not accept Numbers )
  //
  defaultLine = defaultLine.toString();

  //
  // Make the actual read
  //
  read({
    prompt: msg,
    silent: prop.schema &amp;&amp; prop.schema.hidden,
    replace: prop.schema &amp;&amp; prop.schema.replace,
    default: defaultLine,
    input: stdin,
    output: stdout
  }, function (err, line) {
    if (err &amp;&amp; wait === false) {
      return callback(err);
    }

    var against = {},
        numericInput,
        isValid;

    if (line !== &#039;&#039;) {

      if (schema.properties[propName]) {
        var type = (schema.properties[propName].type || &#039;&#039;).toLowerCase().trim() || undefined;

        //
        // If type is some sort of numeric create a Number object to pass to revalidator
        //
        if (type === &#039;number&#039; || type === &#039;integer&#039;) {
          line = Number(line);
        }

        //
        // Attempt to parse input as a boolean if the schema expects a boolean
        //
        if (type == &#039;boolean&#039;) {
          if(line.toLowerCase() === &quot;true&quot; || line.toLowerCase() === &#039;t&#039;) {
            line = true;
          } else if(line.toLowerCase() === &quot;false&quot; || line.toLowerCase() === &#039;f&#039;) {
            line = false;
          }
        }

        //
        // If the type is an array, wait for the end. Fixes #54
        //
        if (type == &#039;array&#039;) {
          var length = prop.schema.maxItems;
          if (err) {
            if (err.message == &#039;canceled&#039;) {
              wait = false;
              stdout.write(&#039;\n&#039;);
            }
          }
          else {
            if (length) {
              if (tmp.length + 1 &lt; length) {
                isValid = false;
                wait = true;
              }
              else {
                isValid = true;
                wait = false;
              }
            }
            else {
              isValid = false;
              wait = true;
            }
            tmp.push(line);
          }
          line = tmp;
        }
      }

      against[propName] = line;
    }

    if (prop &amp;&amp; prop.schema.before) {
      line = prop.schema.before(line);
    }

    // Validate
    if (isValid === undefined) isValid = prompt._performValidation(name, prop, against, schema, line, callback);

    if (!isValid) {
      return prompt.getInput(prop, callback);
    }

    //
    // Log the resulting line, append this `property:value`
    // pair to the history for `prompt` and respond to
    // the callback.
    //
    logger.input(line.yellow);
    prompt._remember(propName, line);
    callback(null, line);

    // Make sure `tmp` is emptied
    tmp = [];
  });
};

//
// ### function performValidation (name, prop, against, schema, line, callback)
// #### @name {Object} Variable name
// #### @prop {Object|string} Variable to get input for.
// #### @against {Object} Input
// #### @schema {Object} Validation schema
// #### @line {String|Boolean} Input line
// #### @callback {function} Continuation to pass control to when complete.
// Perfoms user input validation, print errors if needed and returns value according to validation
//
prompt._performValidation = function (name, prop, against, schema, line, callback) {
  var numericInput, valid, msg;
  try {
    valid = validate(against, schema);
  }
  catch (err) {
    return (line !== -1) ? callback(err) : false;
  }

  if (!valid.valid) {
    if (prop.schema.message) {
      logger.error(prop.schema.message);
    } else {
      msg = line !== -1 ? &#039;Invalid input for &#039; : &#039;Invalid command-line input for &#039;;

      if (prompt.colors) {
        logger.error(msg + colors.grey(name));
      }
      else {
        logger.error(msg + name);
      }
    }

    prompt.emit(&#039;invalid&#039;, prop, line);
  }

  return valid.valid;
};

//
// ### function addProperties (obj, properties, callback)
// #### @obj {Object} Object to add properties to
// #### @properties {Array} List of properties to get values for
// #### @callback {function} Continuation to pass control to when complete.
// Prompts the user for values each of the `properties` if `obj` does not already
// have a value for the property. Responds with the modified object.
//
prompt.addProperties = function (obj, properties, callback) {
  properties = properties.filter(function (prop) {
    return typeof obj[prop] === &#039;undefined&#039;;
  });

  if (properties.length === 0) {
    return callback(null, obj);
  }

  prompt.get(properties, function (err, results) {
    if (err) {
      return callback(err);
    }
    else if (!results) {
      return callback(null, obj);
    }

    function putNested (obj, path, value) {
      var last = obj, key;

      while (path.length &gt; 1) {
        key = path.shift();
        if (!last[key]) {
          last[key] = {};
        }

        last = last[key];
      }

      last[path.shift()] = value;
    }

    Object.keys(results).forEach(function (key) {
      putNested(obj, key.split(&#039;.&#039;), results[key]);
    });

    callback(null, obj);
  });

  return prompt;
};

//
// ### @private function _remember (property, value)
// #### @property {Object|string} Property that the value is in response to.
// #### @value {string} User input captured by `prompt`.
// Prepends the `property:value` pair into the private `history` Array
// for `prompt` so that it can be accessed later.
//
prompt._remember = function (property, value) {
  history.unshift({
    property: property,
    value: value
  });

  //
  // If the length of the `history` Array
  // has exceeded the specified length to remember,
  // `prompt.memory`, truncate it.
  //
  if (history.length &gt; prompt.memory) {
    history.splice(prompt.memory, history.length - prompt.memory);
  }
};

//
// ### @private function convert (schema)
// #### @schema {Object} Schema for a property
// Converts the schema into new format if it is in old format
//
function convert(schema) {
  var newProps = Object.keys(validate.messages),
      newSchema = false,
      key;

  newProps = newProps.concat([&#039;description&#039;, &#039;dependencies&#039;]);

  for (key in schema) {
    if (newProps.indexOf(key) &gt; 0) {
      newSchema = true;
      break;
    }
  }

  if (!newSchema || schema.validator || schema.warning || typeof schema.empty !== &#039;undefined&#039;) {
    if(typeof schema.message !== &#039;undefined&#039;){
      schema.description = schema.message;
    }

    if(typeof schema.warning !== &#039;undefined&#039;){
      schema.message = schema.warning;
    }

    if (typeof schema.validator === &#039;function&#039;) {
      schema.conform = schema.validator;
    } else {
      schema.pattern = schema.validator;
    }

    if (typeof schema.empty !== &#039;undefined&#039;) {
      schema.required = !(schema.empty);
    }

    delete schema.warning;
    delete schema.validator;
    delete schema.empty;
  }

  return schema;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
