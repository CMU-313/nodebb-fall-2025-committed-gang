<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/mousetrap/tests/test.mousetrap.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/mousetrap/tests/test.mousetrap.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">773</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">81.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * The following strategy of importing modules allows the tests to be run in a browser environment.
 * Test libraries like `mocha`, `sinon`, etc. are expected to be loaded before this file.
 */
var sinon = sinon || require(&#039;sinon&#039;);
var chai = chai || require(&#039;chai&#039;);
var expect = chai.expect;

if (typeof window === &#039;undefined&#039;) {
  require(&#039;mocha&#039;);
  require(&#039;jsdom-global&#039;)();
}

// Load libraries that require access to the DOM after `jsdom-global`
var Mousetrap = Mousetrap || require(&#039;./../mousetrap&#039;);
var KeyEvent = KeyEvent || require(&#039;./libs/key-event&#039;);



// Reset Mousetrap after each test
afterEach(function () {
  Mousetrap.reset();
});

describe(&#039;Mousetrap.bind&#039;, function () {
  describe(&#039;basic&#039;, function () {
    it(&#039;z key fires when pressing z&#039;, function () {
      var spy = sinon.spy();

      Mousetrap.bind(&#039;z&#039;, spy);

      KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90);

      // really slow for some reason
      // expect(spy).to.have.been.calledOnce;
      expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
      expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
      expect(spy.args[0][1]).to.equal(&#039;z&#039;, &#039;second argument should be key combo&#039;);
    });

    it(&#039;z key fires from keydown&#039;, function () {
      var spy = sinon.spy();

      Mousetrap.bind(&#039;z&#039;, spy, &#039;keydown&#039;);

      KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90);

      // really slow for some reason
      // expect(spy).to.have.been.calledOnce;
      expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
      expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
      expect(spy.args[0][1]).to.equal(&#039;z&#039;, &#039;second argument should be key combo&#039;);
    });

    it(&#039;z key does not fire when pressing b&#039;, function () {
      var spy = sinon.spy();

      Mousetrap.bind(&#039;z&#039;, spy);

      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66);

      expect(spy.callCount).to.equal(0);
    });

    it(&#039;z key does not fire when holding a modifier key&#039;, function () {
      var spy = sinon.spy();
      var modifiers = [&#039;ctrl&#039;, &#039;alt&#039;, &#039;meta&#039;, &#039;shift&#039;];
      var charCode;
      var modifier;

      Mousetrap.bind(&#039;z&#039;, spy);

      for (var i = 0; i &lt; 4; i++) {
        modifier = modifiers[i];
        charCode = &#039;Z&#039;.charCodeAt(0);

        // character code is different when alt is pressed
        if (modifier == &#039;alt&#039;) {
          charCode = &#039;Î©&#039;.charCodeAt(0);
        }

        spy.resetHistory();

        KeyEvent.simulate(charCode, 90, [modifier]);

        expect(spy.callCount).to.equal(0);
      }
    });

    it(&#039;z key does not fire when inside an input element in an open shadow dom&#039;, function() {
      var spy = sinon.spy();

      var shadowHost = document.createElement(&#039;div&#039;);
      var shadowRoot = shadowHost.attachShadow({ mode: &#039;open&#039; });
      document.body.appendChild(shadowHost);

      var inputElement = document.createElement(&#039;input&#039;);
      shadowRoot.appendChild(inputElement);
      expect(shadowHost.shadowRoot).to.equal(shadowRoot, &#039;shadow root accessible&#039;);

      Mousetrap.bind(&#039;z&#039;, spy);
      KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90, [], inputElement, 1, { shadowHost: shadowHost });
      document.body.removeChild(shadowHost);
      expect(spy.callCount).to.equal(0, &#039;callback should not have fired&#039;);
    });

    it(&#039;z key does fire when inside an input element in a closed shadow dom&#039;, function() {
      var spy = sinon.spy();

      var shadowHost = document.createElement(&#039;div&#039;);
      var shadowRoot = shadowHost.attachShadow({ mode: &#039;closed&#039; });
      document.body.appendChild(shadowHost);

      var inputElement = document.createElement(&#039;input&#039;);
      shadowRoot.appendChild(inputElement);
      expect(shadowHost.shadowRoot).to.equal(null, &#039;shadow root unaccessible&#039;);

      Mousetrap.bind(&#039;z&#039;, spy);
      KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90, [], inputElement, 1, { shadowHost: shadowHost });
      document.body.removeChild(shadowHost);
      expect(spy.callCount).to.equal(1, &#039;callback should have fired once&#039;);
    });

    it(&#039;keyup events should fire&#039;, function() {
      var spy = sinon.spy();

      Mousetrap.bind(&#039;z&#039;, spy, &#039;keyup&#039;);

      KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90);

      expect(spy.callCount).to.equal(1, &#039;keyup event for &quot;z&quot; should fire&#039;);

      // for key held down we should only get one key up
      KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90, [], document, 10);
      expect(spy.callCount).to.equal(2, &#039;keyup event for &quot;z&quot; should fire once for held down key&#039;);
    });

    it(&#039;keyup event for 0 should fire&#039;, function () {
      var spy = sinon.spy();

      Mousetrap.bind(&#039;0&#039;, spy, &#039;keyup&#039;);

      KeyEvent.simulate(0, 48);

      expect(spy.callCount).to.equal(1, &#039;keyup event for &quot;0&quot; should fire&#039;);
    });

    it(&#039;rebinding a key overwrites the callback for that key&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();
      Mousetrap.bind(&#039;x&#039;, spy1);
      Mousetrap.bind(&#039;x&#039;, spy2);

      KeyEvent.simulate(&#039;X&#039;.charCodeAt(0), 88);

      expect(spy1.callCount).to.equal(0, &#039;original callback should not fire&#039;);
      expect(spy2.callCount).to.equal(1, &#039;new callback should fire&#039;);
    });

    it(&#039;binding an array of keys&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], spy);

      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      expect(spy.callCount).to.equal(1, &#039;new callback was called&#039;);
      expect(spy.args[0][1]).to.equal(&#039;a&#039;, &#039;callback should match &quot;a&quot;&#039;);

      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66);
      expect(spy.callCount).to.equal(2, &#039;new callback was called twice&#039;);
      expect(spy.args[1][1]).to.equal(&#039;b&#039;, &#039;callback should match &quot;b&quot;&#039;);

      KeyEvent.simulate(&#039;C&#039;.charCodeAt(0), 67);
      expect(spy.callCount).to.equal(3, &#039;new callback was called three times&#039;);
      expect(spy.args[2][1]).to.equal(&#039;c&#039;, &#039;callback should match &quot;c&quot;&#039;);
    });

    it(&#039;return false should prevent default and stop propagation&#039;, function () {
      var spy = sinon.spy(function () {
        return false;
      });

      Mousetrap.bind(&#039;command+s&#039;, spy);

      KeyEvent.simulate(&#039;S&#039;.charCodeAt(0), 83, [&#039;meta&#039;]);

      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);

      expect(spy.args[0][0].defaultPrevented).to.be.true;

      // cancelBubble is not correctly set to true in webkit/blink
      //
      // @see https://code.google.com/p/chromium/issues/detail?id=162270
      // expect(spy.args[0][0].cancelBubble).to.be.true;

      // try without return false
      spy = sinon.spy();
      Mousetrap.bind(&#039;command+s&#039;, spy);
      KeyEvent.simulate(&#039;S&#039;.charCodeAt(0), 83, [&#039;meta&#039;]);

      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
      expect(spy.args[0][0].cancelBubble).to.be.false;
      expect(spy.args[0][0].defaultPrevented).to.be.false;
    });

    it(&#039;capslock key is ignored&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;a&#039;, spy);

      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      expect(spy.callCount).to.equal(1, &#039;callback should fire for lowercase a&#039;);

      spy.resetHistory();
      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      expect(spy.callCount).to.equal(1, &#039;callback should fire for capslock A&#039;);

      spy.resetHistory();
      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65, [&#039;shift&#039;]);
      expect(spy.callCount).to.equal(0, &#039;callback should not fire fort shift+a&#039;);
    });
  });

  describe(&#039;special characters&#039;, function () {
    it(&#039;binding special characters&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;*&#039;, spy);

      KeyEvent.simulate(&#039;*&#039;.charCodeAt(0), 56, [&#039;shift&#039;]);

      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;*&#039;, &#039;callback should match *&#039;);
    });

    it(&#039;binding special characters keyup&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;*&#039;, spy, &#039;keyup&#039;);

      KeyEvent.simulate(&#039;*&#039;.charCodeAt(0), 56, [&#039;shift&#039;]);

      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;*&#039;, &#039;callback should match &quot;*&quot;&#039;);
    });

    it(&#039;binding keys with no associated charCode&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;left&#039;, spy);

      KeyEvent.simulate(0, 37);

      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;left&#039;, &#039;callback should match &quot;left&quot;&#039;);
    });

    it(&#039;binding plus key alone should work&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;+&#039;, spy);

      // fires for regular + character
      KeyEvent.simulate(&#039;+&#039;.charCodeAt(0), 43);

      // and for shift+=
      KeyEvent.simulate(43, 187, [&#039;shift&#039;]);

      expect(spy.callCount).to.equal(2, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;+&#039;, &#039;callback should match &quot;+&quot;&#039;);
    });

    it(&#039;binding plus key as &quot;plus&quot; should work&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;plus&#039;, spy);

      // fires for regular + character
      KeyEvent.simulate(&#039;+&#039;.charCodeAt(0), 43);

      // and for shift+=
      KeyEvent.simulate(43, 187, [&#039;shift&#039;]);

      expect(spy.callCount).to.equal(2, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;plus&#039;, &#039;callback should match &quot;plus&quot;&#039;);
    });

    it(&#039;binding to alt++ should work&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;alt++&#039;, spy);

      KeyEvent.simulate(&#039;+&#039;.charCodeAt(0), 43, [&#039;alt&#039;]);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;alt++&#039;, &#039;callback should match &quot;alt++&quot;&#039;);
    });

    it(&#039;binding to alt+shift++ should work as well&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;alt+shift++&#039;, spy);

      KeyEvent.simulate(&#039;+&#039;.charCodeAt(0), 43, [&#039;shift&#039;, &#039;alt&#039;]);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;alt+shift++&#039;, &#039;callback should match &quot;alt++&quot;&#039;);

    });
  });

  describe(&#039;combos with modifiers&#039;, function () {
    it(&#039;binding key combinations&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;command+o&#039;, spy);

      KeyEvent.simulate(&#039;O&#039;.charCodeAt(0), 79, [&#039;meta&#039;]);

      expect(spy.callCount).to.equal(1, &#039;command+o callback should fire&#039;);
      expect(spy.args[0][1]).to.equal(&#039;command+o&#039;, &#039;keyboard string returned is correct&#039;);
    });

    it(&#039;binding key combos with multiple modifiers&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;command+shift+o&#039;, spy);
      KeyEvent.simulate(&#039;O&#039;.charCodeAt(0), 79, [&#039;meta&#039;]);
      expect(spy.callCount).to.equal(0, &#039;command+o callback should not fire&#039;);

      KeyEvent.simulate(&#039;O&#039;.charCodeAt(0), 79, [&#039;meta&#039;, &#039;shift&#039;]);
      expect(spy.callCount).to.equal(1, &#039;command+o callback should fire&#039;);
    });

    it(&#039;should fire callback when ctrl+numpad 0 is pressed&#039;, function () {
      var spy = sinon.spy();

      Mousetrap.bind(&#039;ctrl+0&#039;, spy);

      // numpad 0 keycode
      KeyEvent.simulate(96, 96, [&#039;ctrl&#039;]);

      expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
      expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
      expect(spy.args[0][1]).to.equal(&#039;ctrl+0&#039;, &#039;second argument should be key combo&#039;);
    });
  });

  describe(&#039;sequences&#039;, function () {
    it(&#039;binding sequences&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;g i&#039;, spy);

      KeyEvent.simulate(&#039;G&#039;.charCodeAt(0), 71);
      expect(spy.callCount).to.equal(0, &#039;callback should not fire&#039;);

      KeyEvent.simulate(&#039;I&#039;.charCodeAt(0), 73);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
    });

    it(&#039;binding sequences with mixed types&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;g o enter&#039;, spy);

      KeyEvent.simulate(&#039;G&#039;.charCodeAt(0), 71);
      expect(spy.callCount).to.equal(0, &#039;callback should not fire&#039;);

      KeyEvent.simulate(&#039;O&#039;.charCodeAt(0), 79);
      expect(spy.callCount).to.equal(0, &#039;callback should not fire&#039;);

      KeyEvent.simulate(0, 13);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
    });

    it(&#039;binding sequences starting with modifier keys&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;option enter&#039;, spy);
      KeyEvent.simulate(0, 18, [&#039;alt&#039;]);
      KeyEvent.simulate(0, 13);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);

      spy = sinon.spy();
      Mousetrap.bind(&#039;command enter&#039;, spy);
      KeyEvent.simulate(0, 91, [&#039;meta&#039;]);
      KeyEvent.simulate(0, 13);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);

      spy = sinon.spy();
      Mousetrap.bind(&#039;escape enter&#039;, spy);
      KeyEvent.simulate(0, 27);
      KeyEvent.simulate(0, 13);
      expect(spy.callCount).to.equal(1, &#039;callback should fire&#039;);
    });

    it(&#039;key within sequence should not fire&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();
      Mousetrap.bind(&#039;a&#039;, spy1);
      Mousetrap.bind(&#039;c a t&#039;, spy2);

      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      expect(spy1.callCount).to.equal(1, &#039;callback 1 should fire&#039;);
      spy1.resetHistory();

      KeyEvent.simulate(&#039;C&#039;.charCodeAt(0), 67);
      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;T&#039;.charCodeAt(0), 84);
      expect(spy1.callCount).to.equal(0, &#039;callback for &quot;a&quot; key should not fire&#039;);
      expect(spy2.callCount).to.equal(1, &#039;callback for &quot;c a t&quot; sequence should fire&#039;);
    });

    it(&#039;keyup at end of sequence should not fire&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();

      Mousetrap.bind(&#039;t&#039;, spy1, &#039;keyup&#039;);
      Mousetrap.bind(&#039;b a t&#039;, spy2);

      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;T&#039;.charCodeAt(0), 84);

      expect(spy1.callCount).to.equal(0, &#039;callback for &quot;t&quot; keyup should not fire&#039;);
      expect(spy2.callCount).to.equal(1, &#039;callback for &quot;b a t&quot; sequence should fire&#039;);
    });

    it(&#039;keyup sequences should work&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;b a t&#039;, spy, &#039;keyup&#039;);

      KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);

      // hold the last key down for a while
      KeyEvent.simulate(&#039;t&#039;.charCodeAt(0), 84, [], document, 10);

      expect(spy.callCount).to.equal(1, &#039;callback for &quot;b a t&quot; sequence should fire on keyup&#039;);
    });

    it(&#039;extra spaces in sequences should be ignored&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;b   a  t&#039;, spy);

      KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;t&#039;.charCodeAt(0), 84);

      expect(spy.callCount).to.equal(1, &#039;callback for &quot;b a t&quot; sequence should fire&#039;);
    });

    it(&#039;modifiers and sequences play nicely&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();

      Mousetrap.bind(&#039;ctrl a&#039;, spy1);
      Mousetrap.bind(&#039;ctrl+b&#039;, spy2);

      KeyEvent.simulate(0, 17, [&#039;ctrl&#039;]);
      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      expect(spy1.callCount).to.equal(1, &#039;&quot;ctrl a&quot; should fire&#039;);

      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66, [&#039;ctrl&#039;]);
      expect(spy2.callCount).to.equal(1, &#039;&quot;ctrl+b&quot; should fire&#039;);
    });

    it(&#039;sequences that start the same work&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();

      Mousetrap.bind(&#039;g g l&#039;, spy2);
      Mousetrap.bind(&#039;g g o&#039;, spy1);

      KeyEvent.simulate(&#039;g&#039;.charCodeAt(0), 71);
      KeyEvent.simulate(&#039;g&#039;.charCodeAt(0), 71);
      KeyEvent.simulate(&#039;o&#039;.charCodeAt(0), 79);
      expect(spy1.callCount).to.equal(1, &#039;&quot;g g o&quot; should fire&#039;);
      expect(spy2.callCount).to.equal(0, &#039;&quot;g g l&quot; should not fire&#039;);

      spy1.resetHistory();
      spy2.resetHistory();
      KeyEvent.simulate(&#039;g&#039;.charCodeAt(0), 71);
      KeyEvent.simulate(&#039;g&#039;.charCodeAt(0), 71);
      KeyEvent.simulate(&#039;l&#039;.charCodeAt(0), 76);
      expect(spy1.callCount).to.equal(0, &#039;&quot;g g o&quot; should not fire&#039;);
      expect(spy2.callCount).to.equal(1, &#039;&quot;g g l&quot; should fire&#039;);
    });

    it(&#039;sequences should not fire subsequences&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();

      Mousetrap.bind(&#039;a b c&#039;, spy1);
      Mousetrap.bind(&#039;b c&#039;, spy2);

      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;C&#039;.charCodeAt(0), 67);

      expect(spy1.callCount).to.equal(1, &#039;&quot;a b c&quot; should fire&#039;);
      expect(spy2.callCount).to.equal(0, &#039;&quot;b c&quot; should not fire&#039;);

      spy1.resetHistory();
      spy2.resetHistory();
      Mousetrap.bind(&#039;option b&#039;, spy1);
      Mousetrap.bind(&#039;a option b&#039;, spy2);

      KeyEvent.simulate(&#039;A&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(0, 18, [&#039;alt&#039;]);
      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66);

      expect(spy1.callCount).to.equal(0, &#039;&quot;option b&quot; should not fire&#039;);
      expect(spy2.callCount).to.equal(1, &#039;&quot;a option b&quot; should fire&#039;);
    });

    it(&#039;rebinding same sequence should override previous&#039;, function () {
      var spy1 = sinon.spy();
      var spy2 = sinon.spy();
      Mousetrap.bind(&#039;a b c&#039;, spy1);
      Mousetrap.bind(&#039;a b c&#039;, spy2);

      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;c&#039;.charCodeAt(0), 67);

      expect(spy1.callCount).to.equal(0, &#039;first callback should not fire&#039;);
      expect(spy2.callCount).to.equal(1, &#039;second callback should fire&#039;);
    });

    it(&#039;broken sequences&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;h a t&#039;, spy);

      KeyEvent.simulate(&#039;h&#039;.charCodeAt(0), 72);
      KeyEvent.simulate(&#039;e&#039;.charCodeAt(0), 69);
      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;r&#039;.charCodeAt(0), 82);
      KeyEvent.simulate(&#039;t&#039;.charCodeAt(0), 84);

      expect(spy.callCount).to.equal(0, &#039;sequence for &quot;h a t&quot; should not fire for &quot;h e a r t&quot;&#039;);
    });

    it(&#039;sequences containing combos should work&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;a ctrl+b&#039;, spy);

      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(&#039;B&#039;.charCodeAt(0), 66, [&#039;ctrl&#039;]);

      expect(spy.callCount).to.equal(1, &#039;&quot;a ctrl+b&quot; should fire&#039;);

      Mousetrap.unbind(&#039;a ctrl+b&#039;);

      spy = sinon.spy();
      Mousetrap.bind(&#039;ctrl+b a&#039;, spy);

      KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66, [&#039;ctrl&#039;]);
      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);

      expect(spy.callCount).to.equal(1, &#039;&quot;ctrl+b a&quot; should fire&#039;);
    });

    it(&#039;sequences starting with spacebar should work&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;a space b c&#039;, spy);

      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(32, 32);
      KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;c&#039;.charCodeAt(0), 67);

      expect(spy.callCount).to.equal(1, &#039;&quot;a space b c&quot; should fire&#039;);
    });

    it(&#039;konami code&#039;, function () {
      var spy = sinon.spy();
      Mousetrap.bind(&#039;up up down down left right left right b a enter&#039;, spy);

      KeyEvent.simulate(0, 38);
      KeyEvent.simulate(0, 38);
      KeyEvent.simulate(0, 40);
      KeyEvent.simulate(0, 40);
      KeyEvent.simulate(0, 37);
      KeyEvent.simulate(0, 39);
      KeyEvent.simulate(0, 37);
      KeyEvent.simulate(0, 39);
      KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      KeyEvent.simulate(0, 13);

      expect(spy.callCount).to.equal(1, &#039;konami code should fire&#039;);
    });

    it(&#039;sequence timer resets&#039;, function () {
      var spy = sinon.spy();
      var clock = sinon.useFakeTimers();

      Mousetrap.bind(&#039;h a t&#039;, spy);

      KeyEvent.simulate(&#039;h&#039;.charCodeAt(0), 72);
      clock.tick(600);
      KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
      clock.tick(900);
      KeyEvent.simulate(&#039;t&#039;.charCodeAt(0), 84);

      expect(spy.callCount).to.equal(1, &#039;sequence should fire after waiting&#039;);
      clock.restore();
    });

    it(&#039;sequences timeout&#039;, function () {
      var spy = sinon.spy();
      var clock = sinon.useFakeTimers();

      Mousetrap.bind(&#039;g t&#039;, spy);
      KeyEvent.simulate(&#039;g&#039;.charCodeAt(0), 71);
      clock.tick(1000);
      KeyEvent.simulate(&#039;t&#039;.charCodeAt(0), 84);

      expect(spy.callCount).to.equal(0, &#039;sequence callback should not fire&#039;);
      clock.restore();
    });
  });

  describe(&#039;default actions&#039;, function () {
    var keys = {
      keypress: [
        [&#039;a&#039;, 65],
        [&#039;A&#039;, 65, [&#039;shift&#039;]],
        [&#039;7&#039;, 55],
        [&#039;?&#039;, 191],
        [&#039;*&#039;, 56],
        [&#039;+&#039;, 187],
        [&#039;$&#039;, 52],
        [&#039;[&#039;, 219],
        [&#039;.&#039;, 190]
      ],
      keydown: [
        [&#039;shift+\&#039;&#039;, 222, [&#039;shift&#039;]],
        [&#039;shift+a&#039;, 65, [&#039;shift&#039;]],
        [&#039;shift+5&#039;, 53, [&#039;shift&#039;]],
        [&#039;command+shift+p&#039;, 80, [&#039;meta&#039;, &#039;shift&#039;]],
        [&#039;space&#039;, 32],
        [&#039;left&#039;, 37]
      ]
    };

    function getCallback(key, keyCode, type, modifiers) {
      return function () {
        var spy = sinon.spy();
        Mousetrap.bind(key, spy);

        KeyEvent.simulate(key.charCodeAt(0), keyCode, modifiers);
        expect(spy.callCount).to.equal(1);
        expect(spy.args[0][0].type).to.equal(type);
      };
    }

    for (var type in keys) {
      for (var i = 0; i &lt; keys[type].length; i++) {
        var key = keys[type][i][0];
        var keyCode = keys[type][i][1];
        var modifiers = keys[type][i][2] || [];
        it(&#039;&quot;&#039; + key + &#039;&quot; uses &quot;&#039; + type + &#039;&quot;&#039;, getCallback(key, keyCode, type, modifiers));
      }
    }
  });
});

describe(&#039;Mousetrap.unbind&#039;, function () {
  it(&#039;unbind works&#039;, function () {
    var spy = sinon.spy();
    Mousetrap.bind(&#039;a&#039;, spy);
    KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
    expect(spy.callCount).to.equal(1, &#039;callback for a should fire&#039;);

    Mousetrap.unbind(&#039;a&#039;);
    KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
    expect(spy.callCount).to.equal(1, &#039;callback for a should not fire after unbind&#039;);
  });

  it(&#039;unbind accepts an array&#039;, function () {
    var spy = sinon.spy();
    Mousetrap.bind([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], spy);
    KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
    KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
    KeyEvent.simulate(&#039;c&#039;.charCodeAt(0), 67);
    expect(spy.callCount).to.equal(3, &#039;callback should have fired 3 times&#039;);

    Mousetrap.unbind([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]);
    KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);
    KeyEvent.simulate(&#039;b&#039;.charCodeAt(0), 66);
    KeyEvent.simulate(&#039;c&#039;.charCodeAt(0), 67);
    expect(spy.callCount).to.equal(3, &#039;callback should not fire after unbind&#039;);
  });
});

describe(&#039;wrapping a specific element&#039;, function () {
  // Prepare the DOM for these tests.
  document.body.insertAdjacentHTML(&#039;afterbegin&#039;, `
    &lt;form style=&quot;display: none;&quot;&gt;
      &lt;textarea&gt;&lt;/textarea&gt;
    &lt;/form&gt;
  `);

  var form = document.querySelector(&#039;form&#039;);
  var textarea = form.querySelector(&#039;textarea&#039;);

  it(&#039;z key fires when pressing z in the target element&#039;, function () {
    var spy = sinon.spy();

    Mousetrap(form).bind(&#039;z&#039;, spy);

    KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90, [], form);

    expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
    expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
    expect(spy.args[0][1]).to.equal(&#039;z&#039;, &#039;second argument should be key combo&#039;);
  });

  it(&#039;z key fires when pressing z in a child of the target element&#039;, function () {
    var spy = sinon.spy();

    Mousetrap(form).bind(&#039;z&#039;, spy);

    KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90, [], textarea);

    expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
    expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
    expect(spy.args[0][1]).to.equal(&#039;z&#039;, &#039;second argument should be key combo&#039;);
  });

  it(&#039;z key does not fire when pressing z outside the target element&#039;, function () {
    var spy = sinon.spy();

    Mousetrap(textarea).bind(&#039;z&#039;, spy);

    KeyEvent.simulate(&#039;Z&#039;.charCodeAt(0), 90);

    expect(spy.callCount).to.equal(0, &#039;callback should not have fired&#039;);
  });

  it(&#039;should work when constructing a new mousetrap object&#039;, function () {
    var spy = sinon.spy();

    var mousetrap = new Mousetrap(form);
    mousetrap.bind(&#039;a&#039;, spy);

    KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65, [], textarea);

    expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
    expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
    expect(spy.args[0][1]).to.equal(&#039;a&#039;, &#039;second argument should be key combo&#039;);
  });

  it(&#039;should allow you to create an empty mousetrap constructor&#039;, function () {
    var spy = sinon.spy();

    var mousetrap = new Mousetrap();
    mousetrap.bind(&#039;a&#039;, spy);

    KeyEvent.simulate(&#039;a&#039;.charCodeAt(0), 65);

    expect(spy.callCount).to.equal(1, &#039;callback should fire once&#039;);
    expect(spy.args[0][0]).to.be.an.instanceOf(Event, &#039;first argument should be Event&#039;);
    expect(spy.args[0][1]).to.equal(&#039;a&#039;, &#039;second argument should be key combo&#039;);
  });
});

describe(&#039;Mouestrap.addKeycodes&#039;, function () {
  it(&#039;should properly recognize non-default mapping&#039;, function () {
    const spy = sinon.spy();

    Mousetrap.addKeycodes({
      144: &#039;num&#039;,
    });

    Mousetrap.bind(&#039;num&#039;, spy);

    KeyEvent.simulate(144, 144);
    expect(spy.callCount).to.equal(1, &#039;callback should fire for num&#039;);

    spy.resetHistory();
  });
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
