<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/iroh/node_modules/acorn/dist/acorn.es.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/iroh/node_modules/acorn/dist/acorn.es.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">5317</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">184.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">88.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Reserved word lists for various dialects of the language

var reservedWords = {
  3: &quot;abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile&quot;,
  5: &quot;class enum extends super const export import&quot;,
  6: &quot;enum&quot;,
  strict: &quot;implements interface let package private protected public static yield&quot;,
  strictBind: &quot;eval arguments&quot;
};

// And the keywords

var ecma5AndLessKeywords = &quot;break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this&quot;;

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + &quot; const class extends export import super&quot;
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = &quot;\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc&quot;;
var nonASCIIidentifierChars = &quot;\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f&quot;;

var nonASCIIidentifierStart = new RegExp(&quot;[&quot; + nonASCIIidentifierStartChars + &quot;]&quot;);
var nonASCIIidentifier = new RegExp(&quot;[&quot; + nonASCIIidentifierStartChars + nonASCIIidentifierChars + &quot;]&quot;);

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// &gt;0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i &lt; set.length; i += 2) {
    pos += set[i];
    if (pos &gt; code) { return false }
    pos += set[i + 1];
    if (pos &gt;= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code &lt; 65) { return code === 36 }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code &lt; 48) { return code === 36 }
  if (code &lt; 58) { return true }
  if (code &lt; 65) { return false }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType(&quot;num&quot;, startsExpr),
  regexp: new TokenType(&quot;regexp&quot;, startsExpr),
  string: new TokenType(&quot;string&quot;, startsExpr),
  name: new TokenType(&quot;name&quot;, startsExpr),
  eof: new TokenType(&quot;eof&quot;),

  // Punctuation token types.
  bracketL: new TokenType(&quot;[&quot;, {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType(&quot;]&quot;),
  braceL: new TokenType(&quot;{&quot;, {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType(&quot;}&quot;),
  parenL: new TokenType(&quot;(&quot;, {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(&quot;)&quot;),
  comma: new TokenType(&quot;,&quot;, beforeExpr),
  semi: new TokenType(&quot;;&quot;, beforeExpr),
  colon: new TokenType(&quot;:&quot;, beforeExpr),
  dot: new TokenType(&quot;.&quot;),
  question: new TokenType(&quot;?&quot;, beforeExpr),
  arrow: new TokenType(&quot;=&gt;&quot;, beforeExpr),
  template: new TokenType(&quot;template&quot;),
  invalidTemplate: new TokenType(&quot;invalidTemplate&quot;),
  ellipsis: new TokenType(&quot;...&quot;, beforeExpr),
  backQuote: new TokenType(&quot;`&quot;, startsExpr),
  dollarBraceL: new TokenType(&quot;${&quot;, {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType(&quot;=&quot;, {beforeExpr: true, isAssign: true}),
  assign: new TokenType(&quot;_=&quot;, {beforeExpr: true, isAssign: true}),
  incDec: new TokenType(&quot;++/--&quot;, {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType(&quot;!/~&quot;, {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop(&quot;||&quot;, 1),
  logicalAND: binop(&quot;&amp;&amp;&quot;, 2),
  bitwiseOR: binop(&quot;|&quot;, 3),
  bitwiseXOR: binop(&quot;^&quot;, 4),
  bitwiseAND: binop(&quot;&amp;&quot;, 5),
  equality: binop(&quot;==/!=/===/!==&quot;, 6),
  relational: binop(&quot;&lt;/&gt;/&lt;=/&gt;=&quot;, 7),
  bitShift: binop(&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;, 8),
  plusMin: new TokenType(&quot;+/-&quot;, {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop(&quot;%&quot;, 10),
  star: binop(&quot;*&quot;, 10),
  slash: binop(&quot;/&quot;, 10),
  starstar: new TokenType(&quot;**&quot;, {beforeExpr: true}),

  // Keyword token types.
  _break: kw(&quot;break&quot;),
  _case: kw(&quot;case&quot;, beforeExpr),
  _catch: kw(&quot;catch&quot;),
  _continue: kw(&quot;continue&quot;),
  _debugger: kw(&quot;debugger&quot;),
  _default: kw(&quot;default&quot;, beforeExpr),
  _do: kw(&quot;do&quot;, {isLoop: true, beforeExpr: true}),
  _else: kw(&quot;else&quot;, beforeExpr),
  _finally: kw(&quot;finally&quot;),
  _for: kw(&quot;for&quot;, {isLoop: true}),
  _function: kw(&quot;function&quot;, startsExpr),
  _if: kw(&quot;if&quot;),
  _return: kw(&quot;return&quot;, beforeExpr),
  _switch: kw(&quot;switch&quot;),
  _throw: kw(&quot;throw&quot;, beforeExpr),
  _try: kw(&quot;try&quot;),
  _var: kw(&quot;var&quot;),
  _const: kw(&quot;const&quot;),
  _while: kw(&quot;while&quot;, {isLoop: true}),
  _with: kw(&quot;with&quot;),
  _new: kw(&quot;new&quot;, {beforeExpr: true, startsExpr: true}),
  _this: kw(&quot;this&quot;, startsExpr),
  _super: kw(&quot;super&quot;, startsExpr),
  _class: kw(&quot;class&quot;, startsExpr),
  _extends: kw(&quot;extends&quot;, beforeExpr),
  _export: kw(&quot;export&quot;),
  _import: kw(&quot;import&quot;),
  _null: kw(&quot;null&quot;, startsExpr),
  _true: kw(&quot;true&quot;, startsExpr),
  _false: kw(&quot;false&quot;, startsExpr),
  _in: kw(&quot;in&quot;, {beforeExpr: true, binop: 7}),
  _instanceof: kw(&quot;instanceof&quot;, {beforeExpr: true, binop: 7}),
  _typeof: kw(&quot;typeof&quot;, {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw(&quot;void&quot;, {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw(&quot;delete&quot;, {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, &quot;g&quot;);

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String &amp;&amp; (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === &quot;[object Array]&quot;
); });

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match &amp;&amp; match.index &lt; offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `&quot;script&quot;` or `&quot;module&quot;`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: &quot;script&quot;,
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion &gt;= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value &quot;never&quot;, reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node&#039;s `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts &amp;&amp; has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion &gt;= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion &lt; 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? &quot;Block&quot; : &quot;Line&quot;,
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Registered plugins
var plugins = {};

function keywordRegexp(words) {
  return new RegExp(&quot;^(?:&quot; + words.replace(/ /g, &quot;|&quot;) + &quot;)$&quot;)
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : 5]);
  var reserved = &quot;&quot;;
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === &quot;module&quot;) { reserved += &quot; await&quot;; }
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + &quot; &quot; : &quot;&quot;) + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + &quot; &quot; + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Load plugins
  this.loadPlugins(options.plugins);

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it&#039;s a module code.
  this.inModule = options.sourceType === &quot;module&quot;;
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false;
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterFunctionScope();

  // For RegExp validation
  this.regexpState = null;
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };

Parser.prototype.extend = function extend (name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];
    if (!plugin) { throw new Error(&quot;Plugin &#039;&quot; + name + &quot;&#039; not found&quot;) }
    plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:&#039;((?:\\.|[^&#039;])*?)&#039;|&quot;((?:\\.|[^&quot;])*?)&quot;|;)/;
pp.strictDirective = function(start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === &quot;use strict&quot;) { return true }
    start += match[0].length;
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, &quot;Comma is not permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign &gt;= 0 || doubleProto &gt;= 0 }
  if (shorthandAssign &gt;= 0)
    { this.raise(shorthandAssign, &quot;Shorthand property assignments are valid only in destructuring patterns&quot;); }
  if (doubleProto &gt;= 0)
    { this.raiseRecoverable(doubleProto, &quot;Redefinition of __proto__ property&quot;); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos &amp;&amp; (!this.awaitPos || this.yieldPos &lt; this.awaitPos))
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion &gt;= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;};
var switchLabel = {kind: &quot;switch&quot;};

pp$1.isLet = function() {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 123) { return true } // &#039;{&#039; and &#039;[&#039;
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check &#039;async [no LineTerminator here] function&#039;
// - &#039;async /*foo*/ function&#039; is OK.
// - &#039;async /*\n*/ function&#039; is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion &lt; 8 || !this.isContextual(&quot;async&quot;))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &amp;&amp;
    this.input.slice(next, next + 8) === &quot;function&quot; &amp;&amp;
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet()) {
    starttype = types._var;
    kind = &quot;let&quot;;
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    if (!declaration &amp;&amp; this.options.ecmaVersion &gt;= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false)
  case types._class:
    if (!declaration) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (!declaration &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock()
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, &quot;&#039;import&#039; and &#039;export&#039; may only appear at the top level&quot;); }
      if (!this.inModule)
        { this.raise(this.start, &quot;&#039;import&#039; and &#039;export&#039; may appear only with &#039;sourceType: module&#039;&quot;); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it&#039;s an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (!declaration) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var this$1 = this;

  var isBreak = keyword === &quot;break&quot;;
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i &lt; this.labels.length; ++i) {
    var lab = this$1.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === &quot;loop&quot;)) { break }
      if (node.label &amp;&amp; isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, &quot;Unsyntactic &quot; + keyword); }
  return this.finishNode(node, isBreak ? &quot;BreakStatement&quot; : &quot;ContinueStatement&quot;)
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, &quot;DebuggerStatement&quot;)
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction)) &amp;&amp; this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, &quot;VariableDeclaration&quot;);
    if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init$1.declarations.length === 1 &amp;&amp;
        !(kind !== &quot;var&quot; &amp;&amp; init$1.declarations[0].init)) {
      if (this.options.ecmaVersion &gt;= 9) {
        if (this.type === types._in) {
          if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt &gt; -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict &amp;&amp; this.type === types._function);
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict &amp;&amp; this.type === types._function) : null;
  return this.finishNode(node, &quot;IfStatement&quot;)
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, &quot;&#039;return&#039; outside of function&quot;); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, &quot;ReturnStatement&quot;)
};

pp$1.parseSwitchStatement = function(node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope();

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;
      if (cur) { this$1.finishNode(cur, &quot;SwitchCase&quot;); }
      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();
      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, &quot;Multiple default clauses&quot;); }
        sawDefault = true;
        cur.test = null;
      }
      this$1.expect(types.colon);
    } else {
      if (!cur) { this$1.unexpected(); }
      cur.consequent.push(this$1.parseStatement(true));
    }
  }
  this.exitLexicalScope();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, &quot;Illegal newline after throw&quot;); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, &quot;ThrowStatement&quot;)
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      this.enterLexicalScope();
      this.checkLVal(clause.param, &quot;let&quot;);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
      clause.param = null;
      this.enterLexicalScope();
    }
    clause.body = this.parseBlock(false);
    this.exitLexicalScope();
    node.handler = this.finishNode(clause, &quot;CatchClause&quot;);
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler &amp;&amp; !node.finalizer)
    { this.raise(node.start, &quot;Missing catch or finally clause&quot;); }
  return this.finishNode(node, &quot;TryStatement&quot;)
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, &quot;VariableDeclaration&quot;)
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, &quot;WhileStatement&quot;)
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, &quot;&#039;with&#039; in strict mode&quot;); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, &quot;WithStatement&quot;)
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, &quot;EmptyStatement&quot;)
};

pp$1.parseLabeledStatement = function(node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 &lt; list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this$1.raise(expr.start, &quot;Label &#039;&quot; + maybeName + &quot;&#039; is already declared&quot;);
  } }
  var kind = this.type.isLoop ? &quot;loop&quot; : this.type === types._switch ? &quot;switch&quot; : null;
  for (var i = this.labels.length - 1; i &gt;= 0; i--) {
    var label$1 = this$1.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(true);
  if (node.body.type === &quot;ClassDeclaration&quot; ||
      node.body.type === &quot;VariableDeclaration&quot; &amp;&amp; node.body.kind !== &quot;var&quot; ||
      node.body.type === &quot;FunctionDeclaration&quot; &amp;&amp; (this.strict || node.body.generator || node.body.async))
    { this.raiseRecoverable(node.body.start, &quot;Invalid labeled declaration&quot;); }
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, &quot;LabeledStatement&quot;)
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, &quot;ExpressionStatement&quot;)
};

// Parse a semicolon-enclosed block of statements, handling `&quot;use
// strict&quot;` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;

  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) {
    this.enterLexicalScope();
  }
  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) {
    this.exitLexicalScope();
  }
  return this.finishNode(node, &quot;BlockStatement&quot;)
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, &quot;ForStatement&quot;)
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser&#039;s perspective.

pp$1.parseForIn = function(node, init) {
  var type = this.type === types._in ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;;
  this.next();
  if (type === &quot;ForInStatement&quot;) {
    if (init.type === &quot;AssignmentPattern&quot; ||
      (init.type === &quot;VariableDeclaration&quot; &amp;&amp; init.declarations[0].init != null &amp;&amp;
       (this.strict || init.declarations[0].id.type !== &quot;Identifier&quot;)))
      { this.raise(init.start, &quot;Invalid assignment in for-in loop head&quot;); }
  }
  node.left = init;
  node.right = type === &quot;ForInStatement&quot; ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type)
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);
    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this$1.type === types._in || (this$1.options.ecmaVersion &gt;= 6 &amp;&amp; this$1.isContextual(&quot;of&quot;)))) {
      this$1.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this$1.type === types._in || this$1.isContextual(&quot;of&quot;)))) {
      this$1.raise(this$1.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
      decl.init = null;
    }
    node.declarations.push(this$1.finishNode(decl, &quot;VariableDeclarator&quot;));
    if (!this$1.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync)
    { node.generator = this.eat(types.star); }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  if (isStatement) {
    node.id = isStatement === &quot;nullableID&quot; &amp;&amp; this.type !== types.name ? null : this.parseIdent();
    if (node.id) {
      this.checkLVal(node.id, this.inModule &amp;&amp; !this.inFunction ? &quot;let&quot; : &quot;var&quot;);
    }
  }

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement)
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  var this$1 = this;

  this.next();

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var member = this$1.parseClassMember(classBody);
    if (member &amp;&amp; member.type === &quot;MethodDefinition&quot; &amp;&amp; member.kind === &quot;constructor&quot;) {
      if (hadConstructor) { this$1.raise(member.start, &quot;Duplicate constructor in the same class&quot;); }
      hadConstructor = true;
    }
  }
  node.body = this.finishNode(classBody, &quot;ClassBody&quot;);
  return this.finishNode(node, isStatement ? &quot;ClassDeclaration&quot; : &quot;ClassExpression&quot;)
};

pp$1.parseClassMember = function(classBody) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, &quot;Identifier&quot;);
    return false
  };

  method.kind = &quot;method&quot;;
  method.static = tryContextual(&quot;static&quot;);
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; tryContextual(&quot;async&quot;, true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    } else if (tryContextual(&quot;get&quot;)) {
      method.kind = &quot;get&quot;;
    } else if (tryContextual(&quot;set&quot;)) {
      method.kind = &quot;set&quot;;
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor&quot; ||
      key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
    if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&#039;t have get/set modifier&quot;); }
    if (isGenerator) { this.raise(key.start, &quot;Constructor can&#039;t be a generator&quot;); }
    if (isAsync) { this.raise(key.start, &quot;Constructor can&#039;t be an async method&quot;); }
    method.kind = &quot;constructor&quot;;
  } else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
    this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
  }
  this.parseClassMethod(classBody, method, isGenerator, isAsync);
  if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
};

pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, &quot;MethodDefinition&quot;));
};

pp$1.parseClassId = function(node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  var this$1 = this;

  this.next();
  // export * from &#039;...&#039;
  if (this.eat(types.star)) {
    this.expectContextual(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, &quot;nullableID&quot;, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, &quot;nullableID&quot;);
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    if (node.declaration.type === &quot;VariableDeclaration&quot;)
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from &#039;...&#039;]
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual(&quot;from&quot;)) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
        var spec = list[i];

        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, &quot;Duplicate export &#039;&quot; + name + &quot;&#039;&quot;); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type === &quot;Identifier&quot;)
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === &quot;ObjectPattern&quot;)
    { for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
      {
        var prop = list[i];

        this$1.checkPatternExport(exports, prop);
      } }
  else if (type === &quot;ArrayPattern&quot;)
    { for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this$1.checkPatternExport(exports, elt); }
    } }
  else if (type === &quot;Property&quot;)
    { this.checkPatternExport(exports, pat.value); }
  else if (type === &quot;AssignmentPattern&quot;)
    { this.checkPatternExport(exports, pat.left); }
  else if (type === &quot;RestElement&quot;)
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === &quot;ParenthesizedExpression&quot;)
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  var this$1 = this;

  if (!exports) { return }
  for (var i = 0, list = decls; i &lt; list.length; i += 1)
    {
    var decl = list[i];

    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === &quot;var&quot; ||
    this.type.keyword === &quot;const&quot; ||
    this.type.keyword === &quot;class&quot; ||
    this.type.keyword === &quot;function&quot; ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var this$1 = this;

  var nodes = [], first = true;
  // export { x, y as z } [from &#039;...&#039;]
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual(&quot;as&quot;) ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, &quot;ExportSpecifier&quot;));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import &#039;...&#039;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var this$1 = this;

  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from &#039;...&#039;
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, &quot;let&quot;);
    nodes.push(this.finishNode(node, &quot;ImportDefaultSpecifier&quot;));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual(&quot;as&quot;);
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, &quot;let&quot;);
    nodes.push(this.finishNode(node$1, &quot;ImportNamespaceSpecifier&quot;));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);
    if (this$1.eatContextual(&quot;as&quot;)) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this$1.checkLVal(node$2.local, &quot;let&quot;);
    nodes.push(this$1.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
    typeof statement.expression.value === &quot;string&quot; &amp;&amp;
    // Reject parenthesized strings.
    (this.input[statement.start] === &quot;\&quot;&quot; || this.input[statement.start] === &quot;&#039;&quot;)
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  var this$1 = this;

  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; node) {
    switch (node.type) {
    case &quot;Identifier&quot;:
      if (this.inAsync &amp;&amp; node.name === &quot;await&quot;)
        { this.raise(node.start, &quot;Can not use &#039;await&#039; as identifier inside an async function&quot;); }
      break

    case &quot;ObjectPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;RestElement&quot;:
      break

    case &quot;ObjectExpression&quot;:
      node.type = &quot;ObjectPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
        var prop = list[i];

      this$1.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === &quot;RestElement&quot; &amp;&amp;
          (prop.argument.type === &quot;ArrayPattern&quot; || prop.argument.type === &quot;ObjectPattern&quot;)
        ) {
          this$1.raise(prop.argument.start, &quot;Unexpected token&quot;);
        }
      }
      break

    case &quot;Property&quot;:
      // AssignmentProperty has type === &quot;Property&quot;
      if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&#039;t contain getter or setter&quot;); }
      this.toAssignable(node.value, isBinding);
      break

    case &quot;ArrayExpression&quot;:
      node.type = &quot;ArrayPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case &quot;SpreadElement&quot;:
      node.type = &quot;RestElement&quot;;
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === &quot;AssignmentPattern&quot;)
        { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
      break

    case &quot;AssignmentExpression&quot;:
      if (node.operator !== &quot;=&quot;) { this.raise(node.left.end, &quot;Only &#039;=&#039; operator can be used for specifying default value.&quot;); }
      node.type = &quot;AssignmentPattern&quot;;
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case &quot;AssignmentPattern&quot;:
      break

    case &quot;ParenthesizedExpression&quot;:
      this.toAssignable(node.expression, isBinding);
      break

    case &quot;MemberExpression&quot;:
      if (!isBinding) { break }

    default:
      this.raise(node.start, &quot;Assigning to rvalue&quot;);
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  for (var i = 0; i &lt; end; i++) {
    var elt = exprList[i];
    if (elt) { this$1.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 &amp;&amp; isBinding &amp;&amp; last &amp;&amp; last.type === &quot;RestElement&quot; &amp;&amp; last.argument.type !== &quot;Identifier&quot;)
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, &quot;SpreadElement&quot;)
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 &amp;&amp; this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, &quot;RestElement&quot;)
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion &gt;= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this$1.expect(types.comma); }
    if (allowEmpty &amp;&amp; this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma &amp;&amp; this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);
      if (this$1.type === types.comma) { this$1.raise(this$1.start, &quot;Comma is not permitted after the rest element&quot;); }
      this$1.expect(close);
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion &lt; 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, &quot;AssignmentPattern&quot;)
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// &#039;var&#039; indicating that the lval creates a &#039;var&#039; binding
// &#039;let&#039; indicating that the lval creates a lexical (&#039;let&#039; or &#039;const&#039;) binding
// &#039;none&#039; indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case &quot;Identifier&quot;:
    if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in strict mode&quot;); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
      checkClashes[expr.name] = true;
    }
    if (bindingType &amp;&amp; bindingType !== &quot;none&quot;) {
      if (
        bindingType === &quot;var&quot; &amp;&amp; !this.canDeclareVarName(expr.name) ||
        bindingType !== &quot;var&quot; &amp;&amp; !this.canDeclareLexicalName(expr.name)
      ) {
        this.raiseRecoverable(expr.start, (&quot;Identifier &#039;&quot; + (expr.name) + &quot;&#039; has already been declared&quot;));
      }
      if (bindingType === &quot;var&quot;) {
        this.declareVarName(expr.name);
      } else {
        this.declareLexicalName(expr.name);
      }
    }
    break

  case &quot;MemberExpression&quot;:
    if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
    break

  case &quot;ObjectPattern&quot;:
    for (var i = 0, list = expr.properties; i &lt; list.length; i += 1)
      {
    var prop = list[i];

    this$1.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case &quot;Property&quot;:
    // AssignmentProperty has type === &quot;Property&quot;
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case &quot;ArrayPattern&quot;:
    for (var i$1 = 0, list$1 = expr.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case &quot;AssignmentPattern&quot;:
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case &quot;RestElement&quot;:
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case &quot;ParenthesizedExpression&quot;:
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? &quot;Binding&quot; : &quot;Assigning to&quot;) + &quot; rvalue&quot;);
  }
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it&#039;ll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; prop.type === &quot;SpreadElement&quot;)
    { return }
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case &quot;Identifier&quot;: name = key.name; break
  case &quot;Literal&quot;: name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion &gt;= 6) {
    if (name === &quot;__proto__&quot; &amp;&amp; kind === &quot;init&quot;) {
      if (propHash.proto) {
        if (refDestructuringErrors &amp;&amp; refDestructuringErrors.doubleProto &lt; 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, &quot;Redefinition of __proto__ property&quot;); }
      }
      propHash.proto = true;
    }
    return
  }
  name = &quot;$&quot; + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === &quot;init&quot;) {
      redefinition = this.strict &amp;&amp; other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, &quot;Redefinition of property&quot;); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// &#039;atomic&#039;, nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing &#039;=&#039; operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it&#039;s possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, &quot;SequenceExpression&quot;)
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator &amp;&amp; this.isContextual(&quot;yield&quot;)) { return this.parseYield() }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;AssignmentExpression&quot;)
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign &gt; -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma &gt; -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;ConditionalExpression&quot;)
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? &quot;LogicalExpression&quot; : &quot;BinaryExpression&quot;)
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict &amp;&amp; node.operator === &quot;delete&quot; &amp;&amp;
             node.argument.type === &quot;Identifier&quot;)
      { this.raiseRecoverable(node.start, &quot;Deleting local variable in strict mode&quot;); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? &quot;UpdateExpression&quot; : &quot;UnaryExpression&quot;);
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix &amp;&amp; !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, &quot;UpdateExpression&quot;);
    }
  }

  if (!sawUnary &amp;&amp; this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), &quot;**&quot;, false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &quot;async&quot;;
  for (var computed = (void 0);;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;
      if (computed) { this$1.expect(types.bracketR); }
      base = this$1.finishNode(node, &quot;MemberExpression&quot;);
    } else if (!noCalls &amp;&amp; this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion &gt;= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow &amp;&amp; !this$1.canInsertSemicolon() &amp;&amp; this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, &quot;CallExpression&quot;);
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({isTagged: true});
      base = this$1.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
    } else {
      return base
    }
  }
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.inFunction)
      { this.raise(this.start, &quot;&#039;super&#039; outside of function or class&quot;); }
    node = this.startNode();
    this.next();
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot &amp;&amp; this.type !== types.bracketL &amp;&amp; this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, &quot;Super&quot;)

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, &quot;ThisExpression&quot;)

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(this.type !== types.name);
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; !containsEsc &amp;&amp; id.name === &quot;async&quot; &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }
    if (canBeArrow &amp;&amp; !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion &gt;= 8 &amp;&amp; id.name === &quot;async&quot; &amp;&amp; this.type === types.name &amp;&amp; !containsEsc) {
        id = this.parseIdent();
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, &quot;Literal&quot;)

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind &lt; 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, &quot;ArrayExpression&quot;)

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, false)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected();
  }
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion &gt;= 8;
  if (this.options.ecmaVersion &gt;= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
        if (this$1.type === types.comma) { this$1.raise(this$1.start, &quot;Comma is not permitted after the rest element&quot;); }
        break
      } else {
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length &gt; 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, &quot;ParenthesizedExpression&quot;)
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New&#039;s precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== &quot;target&quot; || containsEsc)
      { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
    if (!this.inFunction)
      { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
    return this.finishNode(node, &quot;MetaProperty&quot;)
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, &quot;NewExpression&quot;)
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, &quot;Bad escape sequence in untagged template literal&quot;);
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, &quot;\n&quot;),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, &quot;TemplateElement&quot;)
};

pp$3.parseTemplate = function(ref) {
  var this$1 = this;
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this$1.type === types.eof) { this$1.raise(this$1.pos, &quot;Unterminated template literal&quot;); }
    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, &quot;TemplateLiteral&quot;)
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp; prop.key.name === &quot;async&quot; &amp;&amp;
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.type === types.star)) &amp;&amp;
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;);
      }
      return this.finishNode(prop, &quot;RestElement&quot;)
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind &lt; 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma &amp;&amp; refDestructuringErrors &amp;&amp; refDestructuringErrors.trailingComma &lt; 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, &quot;SpreadElement&quot;)
  }
  if (this.options.ecmaVersion &gt;= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = &quot;init&quot;;
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = &quot;init&quot;;
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern &amp;&amp; !containsEsc &amp;&amp;
             this.options.ecmaVersion &gt;= 5 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp;
             (prop.key.name === &quot;get&quot; || prop.key.name === &quot;set&quot;) &amp;&amp;
             (this.type !== types.comma &amp;&amp; this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === &quot;get&quot; ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === &quot;get&quot;)
        { this.raiseRecoverable(start, &quot;getter should have no params&quot;); }
      else
        { this.raiseRecoverable(start, &quot;setter should have exactly one param&quot;); }
    } else {
      if (prop.kind === &quot;set&quot; &amp;&amp; prop.value.params[0].type === &quot;RestElement&quot;)
        { this.raiseRecoverable(prop.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
    }
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot;) {
    this.checkUnreserved(prop.key);
    prop.kind = &quot;init&quot;;
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign &lt; 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion &gt;= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion &gt;= 6) {
    node.generator = false;
    node.expression = false;
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, &quot;FunctionExpression&quot;)
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.enterFunctionScope();
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, &quot;ArrowFunctionExpression&quot;)
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction) {
  var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict &amp;&amp; nonSimple)
        { this.raiseRecoverable(node.start, &quot;Illegal &#039;use strict&#039; directive in function with non-simple parameter list&quot;); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &amp;&amp; !useStrict &amp;&amp; !isArrowFunction &amp;&amp; this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitFunctionScope();

  if (this.strict &amp;&amp; node.id) {
    // Ensure the function name isn&#039;t a forbidden identifier in strict mode, e.g. &#039;eval&#039;
    this.checkLVal(node.id, &quot;none&quot;);
  }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== &quot;Identifier&quot;) { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using &quot;eval&quot;
// or &quot;arguments&quot; and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    this$1.checkLVal(param, &quot;var&quot;, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this$1.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty &amp;&amp; this$1.type === types.comma)
      { elt = null; }
    else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors &amp;&amp; this$1.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
        { refDestructuringErrors.trailingComma = this$1.start; }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator &amp;&amp; name === &quot;yield&quot;)
    { this.raiseRecoverable(start, &quot;Can not use &#039;yield&#039; as identifier inside a generator&quot;); }
  if (this.inAsync &amp;&amp; name === &quot;await&quot;)
    { this.raiseRecoverable(start, &quot;Can not use &#039;await&#039; as identifier inside an async function&quot;); }
  if (this.isKeyword(name))
    { this.raise(start, (&quot;Unexpected keyword &#039;&quot; + name + &quot;&#039;&quot;)); }
  if (this.options.ecmaVersion &lt; 6 &amp;&amp;
    this.input.slice(start, end).indexOf(&quot;\\&quot;) !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync &amp;&amp; name === &quot;await&quot;)
      { this.raiseRecoverable(start, &quot;Can not use keyword &#039;await&#039; outside an async function&quot;); }
    this.raiseRecoverable(start, (&quot;The keyword &#039;&quot; + name + &quot;&#039; is reserved&quot;));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (liberal &amp;&amp; this.options.allowReserved === &quot;never&quot;) { liberal = false; }
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === &quot;class&quot; || node.name === &quot;function&quot;) &amp;&amp;
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, &quot;Identifier&quot;);
  if (!liberal) { this.checkUnreserved(node); }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function() {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star &amp;&amp; !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, &quot;YieldExpression&quot;)
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, &quot;AwaitExpression&quot;)
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

// Object.assign polyfill
var assign = Object.assign || function(target) {
  var sources = [], len = arguments.length - 1;
  while ( len-- &gt; 0 ) sources[ len ] = arguments[ len + 1 ];

  for (var i = 0, list = sources; i &lt; list.length; i += 1) {
    var source = list[i];

    for (var key in source) {
      if (has(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterFunctionScope = function() {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});
};

pp$5.exitFunctionScope = function() {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function() {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function() {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};

/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */
pp$5.canDeclareVarName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) &amp;&amp; !has(currentScope.parentLexical, name)
};

/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */
pp$5.canDeclareLexicalName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) &amp;&amp; !has(currentScope.var, name) &amp;&amp; !has(currentScope.childVar, name)
};

pp$5.declareVarName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = &quot;&quot;;
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js&#039; approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext(&quot;{&quot;, false),
  b_expr: new TokContext(&quot;{&quot;, true),
  b_tmpl: new TokContext(&quot;${&quot;, false),
  p_stat: new TokContext(&quot;(&quot;, false),
  p_expr: new TokContext(&quot;(&quot;, true),
  q_tmpl: new TokContext(&quot;`&quot;, true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext(&quot;function&quot;, false),
  f_expr: new TokContext(&quot;function&quot;, true),
  f_expr_gen: new TokContext(&quot;function&quot;, true, false, null, true),
  f_gen: new TokContext(&quot;function&quot;, false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name &amp;&amp; this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  var this$1 = this;

  for (var i = this.context.length - 1; i &gt;= 1; i--) {
    var context = this$1.context[i];
    if (context.token === &quot;function&quot;)
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword &amp;&amp; prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat &amp;&amp; this.curContext().token === &quot;function&quot;) {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr &amp;&amp; prevType !== types.semi &amp;&amp; prevType !== types._else &amp;&amp;
      !((prevType === types.colon || prevType === types.braceL) &amp;&amp; this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; prevType !== types.dot) {
    if (this.value === &quot;of&quot; &amp;&amp; !this.exprAllowed ||
        this.value === &quot;yield&quot; &amp;&amp; this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

var data = {
  &quot;$LONE&quot;: [
    &quot;ASCII&quot;,
    &quot;ASCII_Hex_Digit&quot;,
    &quot;AHex&quot;,
    &quot;Alphabetic&quot;,
    &quot;Alpha&quot;,
    &quot;Any&quot;,
    &quot;Assigned&quot;,
    &quot;Bidi_Control&quot;,
    &quot;Bidi_C&quot;,
    &quot;Bidi_Mirrored&quot;,
    &quot;Bidi_M&quot;,
    &quot;Case_Ignorable&quot;,
    &quot;CI&quot;,
    &quot;Cased&quot;,
    &quot;Changes_When_Casefolded&quot;,
    &quot;CWCF&quot;,
    &quot;Changes_When_Casemapped&quot;,
    &quot;CWCM&quot;,
    &quot;Changes_When_Lowercased&quot;,
    &quot;CWL&quot;,
    &quot;Changes_When_NFKC_Casefolded&quot;,
    &quot;CWKCF&quot;,
    &quot;Changes_When_Titlecased&quot;,
    &quot;CWT&quot;,
    &quot;Changes_When_Uppercased&quot;,
    &quot;CWU&quot;,
    &quot;Dash&quot;,
    &quot;Default_Ignorable_Code_Point&quot;,
    &quot;DI&quot;,
    &quot;Deprecated&quot;,
    &quot;Dep&quot;,
    &quot;Diacritic&quot;,
    &quot;Dia&quot;,
    &quot;Emoji&quot;,
    &quot;Emoji_Component&quot;,
    &quot;Emoji_Modifier&quot;,
    &quot;Emoji_Modifier_Base&quot;,
    &quot;Emoji_Presentation&quot;,
    &quot;Extender&quot;,
    &quot;Ext&quot;,
    &quot;Grapheme_Base&quot;,
    &quot;Gr_Base&quot;,
    &quot;Grapheme_Extend&quot;,
    &quot;Gr_Ext&quot;,
    &quot;Hex_Digit&quot;,
    &quot;Hex&quot;,
    &quot;IDS_Binary_Operator&quot;,
    &quot;IDSB&quot;,
    &quot;IDS_Trinary_Operator&quot;,
    &quot;IDST&quot;,
    &quot;ID_Continue&quot;,
    &quot;IDC&quot;,
    &quot;ID_Start&quot;,
    &quot;IDS&quot;,
    &quot;Ideographic&quot;,
    &quot;Ideo&quot;,
    &quot;Join_Control&quot;,
    &quot;Join_C&quot;,
    &quot;Logical_Order_Exception&quot;,
    &quot;LOE&quot;,
    &quot;Lowercase&quot;,
    &quot;Lower&quot;,
    &quot;Math&quot;,
    &quot;Noncharacter_Code_Point&quot;,
    &quot;NChar&quot;,
    &quot;Pattern_Syntax&quot;,
    &quot;Pat_Syn&quot;,
    &quot;Pattern_White_Space&quot;,
    &quot;Pat_WS&quot;,
    &quot;Quotation_Mark&quot;,
    &quot;QMark&quot;,
    &quot;Radical&quot;,
    &quot;Regional_Indicator&quot;,
    &quot;RI&quot;,
    &quot;Sentence_Terminal&quot;,
    &quot;STerm&quot;,
    &quot;Soft_Dotted&quot;,
    &quot;SD&quot;,
    &quot;Terminal_Punctuation&quot;,
    &quot;Term&quot;,
    &quot;Unified_Ideograph&quot;,
    &quot;UIdeo&quot;,
    &quot;Uppercase&quot;,
    &quot;Upper&quot;,
    &quot;Variation_Selector&quot;,
    &quot;VS&quot;,
    &quot;White_Space&quot;,
    &quot;space&quot;,
    &quot;XID_Continue&quot;,
    &quot;XIDC&quot;,
    &quot;XID_Start&quot;,
    &quot;XIDS&quot;
  ],
  &quot;General_Category&quot;: [
    &quot;Cased_Letter&quot;,
    &quot;LC&quot;,
    &quot;Close_Punctuation&quot;,
    &quot;Pe&quot;,
    &quot;Connector_Punctuation&quot;,
    &quot;Pc&quot;,
    &quot;Control&quot;,
    &quot;Cc&quot;,
    &quot;cntrl&quot;,
    &quot;Currency_Symbol&quot;,
    &quot;Sc&quot;,
    &quot;Dash_Punctuation&quot;,
    &quot;Pd&quot;,
    &quot;Decimal_Number&quot;,
    &quot;Nd&quot;,
    &quot;digit&quot;,
    &quot;Enclosing_Mark&quot;,
    &quot;Me&quot;,
    &quot;Final_Punctuation&quot;,
    &quot;Pf&quot;,
    &quot;Format&quot;,
    &quot;Cf&quot;,
    &quot;Initial_Punctuation&quot;,
    &quot;Pi&quot;,
    &quot;Letter&quot;,
    &quot;L&quot;,
    &quot;Letter_Number&quot;,
    &quot;Nl&quot;,
    &quot;Line_Separator&quot;,
    &quot;Zl&quot;,
    &quot;Lowercase_Letter&quot;,
    &quot;Ll&quot;,
    &quot;Mark&quot;,
    &quot;M&quot;,
    &quot;Combining_Mark&quot;,
    &quot;Math_Symbol&quot;,
    &quot;Sm&quot;,
    &quot;Modifier_Letter&quot;,
    &quot;Lm&quot;,
    &quot;Modifier_Symbol&quot;,
    &quot;Sk&quot;,
    &quot;Nonspacing_Mark&quot;,
    &quot;Mn&quot;,
    &quot;Number&quot;,
    &quot;N&quot;,
    &quot;Open_Punctuation&quot;,
    &quot;Ps&quot;,
    &quot;Other&quot;,
    &quot;C&quot;,
    &quot;Other_Letter&quot;,
    &quot;Lo&quot;,
    &quot;Other_Number&quot;,
    &quot;No&quot;,
    &quot;Other_Punctuation&quot;,
    &quot;Po&quot;,
    &quot;Other_Symbol&quot;,
    &quot;So&quot;,
    &quot;Paragraph_Separator&quot;,
    &quot;Zp&quot;,
    &quot;Private_Use&quot;,
    &quot;Co&quot;,
    &quot;Punctuation&quot;,
    &quot;P&quot;,
    &quot;punct&quot;,
    &quot;Separator&quot;,
    &quot;Z&quot;,
    &quot;Space_Separator&quot;,
    &quot;Zs&quot;,
    &quot;Spacing_Mark&quot;,
    &quot;Mc&quot;,
    &quot;Surrogate&quot;,
    &quot;Cs&quot;,
    &quot;Symbol&quot;,
    &quot;S&quot;,
    &quot;Titlecase_Letter&quot;,
    &quot;Lt&quot;,
    &quot;Unassigned&quot;,
    &quot;Cn&quot;,
    &quot;Uppercase_Letter&quot;,
    &quot;Lu&quot;
  ],
  &quot;Script&quot;: [
    &quot;Adlam&quot;,
    &quot;Adlm&quot;,
    &quot;Ahom&quot;,
    &quot;Anatolian_Hieroglyphs&quot;,
    &quot;Hluw&quot;,
    &quot;Arabic&quot;,
    &quot;Arab&quot;,
    &quot;Armenian&quot;,
    &quot;Armn&quot;,
    &quot;Avestan&quot;,
    &quot;Avst&quot;,
    &quot;Balinese&quot;,
    &quot;Bali&quot;,
    &quot;Bamum&quot;,
    &quot;Bamu&quot;,
    &quot;Bassa_Vah&quot;,
    &quot;Bass&quot;,
    &quot;Batak&quot;,
    &quot;Batk&quot;,
    &quot;Bengali&quot;,
    &quot;Beng&quot;,
    &quot;Bhaiksuki&quot;,
    &quot;Bhks&quot;,
    &quot;Bopomofo&quot;,
    &quot;Bopo&quot;,
    &quot;Brahmi&quot;,
    &quot;Brah&quot;,
    &quot;Braille&quot;,
    &quot;Brai&quot;,
    &quot;Buginese&quot;,
    &quot;Bugi&quot;,
    &quot;Buhid&quot;,
    &quot;Buhd&quot;,
    &quot;Canadian_Aboriginal&quot;,
    &quot;Cans&quot;,
    &quot;Carian&quot;,
    &quot;Cari&quot;,
    &quot;Caucasian_Albanian&quot;,
    &quot;Aghb&quot;,
    &quot;Chakma&quot;,
    &quot;Cakm&quot;,
    &quot;Cham&quot;,
    &quot;Cherokee&quot;,
    &quot;Cher&quot;,
    &quot;Common&quot;,
    &quot;Zyyy&quot;,
    &quot;Coptic&quot;,
    &quot;Copt&quot;,
    &quot;Qaac&quot;,
    &quot;Cuneiform&quot;,
    &quot;Xsux&quot;,
    &quot;Cypriot&quot;,
    &quot;Cprt&quot;,
    &quot;Cyrillic&quot;,
    &quot;Cyrl&quot;,
    &quot;Deseret&quot;,
    &quot;Dsrt&quot;,
    &quot;Devanagari&quot;,
    &quot;Deva&quot;,
    &quot;Duployan&quot;,
    &quot;Dupl&quot;,
    &quot;Egyptian_Hieroglyphs&quot;,
    &quot;Egyp&quot;,
    &quot;Elbasan&quot;,
    &quot;Elba&quot;,
    &quot;Ethiopic&quot;,
    &quot;Ethi&quot;,
    &quot;Georgian&quot;,
    &quot;Geor&quot;,
    &quot;Glagolitic&quot;,
    &quot;Glag&quot;,
    &quot;Gothic&quot;,
    &quot;Goth&quot;,
    &quot;Grantha&quot;,
    &quot;Gran&quot;,
    &quot;Greek&quot;,
    &quot;Grek&quot;,
    &quot;Gujarati&quot;,
    &quot;Gujr&quot;,
    &quot;Gurmukhi&quot;,
    &quot;Guru&quot;,
    &quot;Han&quot;,
    &quot;Hani&quot;,
    &quot;Hangul&quot;,
    &quot;Hang&quot;,
    &quot;Hanunoo&quot;,
    &quot;Hano&quot;,
    &quot;Hatran&quot;,
    &quot;Hatr&quot;,
    &quot;Hebrew&quot;,
    &quot;Hebr&quot;,
    &quot;Hiragana&quot;,
    &quot;Hira&quot;,
    &quot;Imperial_Aramaic&quot;,
    &quot;Armi&quot;,
    &quot;Inherited&quot;,
    &quot;Zinh&quot;,
    &quot;Qaai&quot;,
    &quot;Inscriptional_Pahlavi&quot;,
    &quot;Phli&quot;,
    &quot;Inscriptional_Parthian&quot;,
    &quot;Prti&quot;,
    &quot;Javanese&quot;,
    &quot;Java&quot;,
    &quot;Kaithi&quot;,
    &quot;Kthi&quot;,
    &quot;Kannada&quot;,
    &quot;Knda&quot;,
    &quot;Katakana&quot;,
    &quot;Kana&quot;,
    &quot;Kayah_Li&quot;,
    &quot;Kali&quot;,
    &quot;Kharoshthi&quot;,
    &quot;Khar&quot;,
    &quot;Khmer&quot;,
    &quot;Khmr&quot;,
    &quot;Khojki&quot;,
    &quot;Khoj&quot;,
    &quot;Khudawadi&quot;,
    &quot;Sind&quot;,
    &quot;Lao&quot;,
    &quot;Laoo&quot;,
    &quot;Latin&quot;,
    &quot;Latn&quot;,
    &quot;Lepcha&quot;,
    &quot;Lepc&quot;,
    &quot;Limbu&quot;,
    &quot;Limb&quot;,
    &quot;Linear_A&quot;,
    &quot;Lina&quot;,
    &quot;Linear_B&quot;,
    &quot;Linb&quot;,
    &quot;Lisu&quot;,
    &quot;Lycian&quot;,
    &quot;Lyci&quot;,
    &quot;Lydian&quot;,
    &quot;Lydi&quot;,
    &quot;Mahajani&quot;,
    &quot;Mahj&quot;,
    &quot;Malayalam&quot;,
    &quot;Mlym&quot;,
    &quot;Mandaic&quot;,
    &quot;Mand&quot;,
    &quot;Manichaean&quot;,
    &quot;Mani&quot;,
    &quot;Marchen&quot;,
    &quot;Marc&quot;,
    &quot;Masaram_Gondi&quot;,
    &quot;Gonm&quot;,
    &quot;Meetei_Mayek&quot;,
    &quot;Mtei&quot;,
    &quot;Mende_Kikakui&quot;,
    &quot;Mend&quot;,
    &quot;Meroitic_Cursive&quot;,
    &quot;Merc&quot;,
    &quot;Meroitic_Hieroglyphs&quot;,
    &quot;Mero&quot;,
    &quot;Miao&quot;,
    &quot;Plrd&quot;,
    &quot;Modi&quot;,
    &quot;Mongolian&quot;,
    &quot;Mong&quot;,
    &quot;Mro&quot;,
    &quot;Mroo&quot;,
    &quot;Multani&quot;,
    &quot;Mult&quot;,
    &quot;Myanmar&quot;,
    &quot;Mymr&quot;,
    &quot;Nabataean&quot;,
    &quot;Nbat&quot;,
    &quot;New_Tai_Lue&quot;,
    &quot;Talu&quot;,
    &quot;Newa&quot;,
    &quot;Nko&quot;,
    &quot;Nkoo&quot;,
    &quot;Nushu&quot;,
    &quot;Nshu&quot;,
    &quot;Ogham&quot;,
    &quot;Ogam&quot;,
    &quot;Ol_Chiki&quot;,
    &quot;Olck&quot;,
    &quot;Old_Hungarian&quot;,
    &quot;Hung&quot;,
    &quot;Old_Italic&quot;,
    &quot;Ital&quot;,
    &quot;Old_North_Arabian&quot;,
    &quot;Narb&quot;,
    &quot;Old_Permic&quot;,
    &quot;Perm&quot;,
    &quot;Old_Persian&quot;,
    &quot;Xpeo&quot;,
    &quot;Old_South_Arabian&quot;,
    &quot;Sarb&quot;,
    &quot;Old_Turkic&quot;,
    &quot;Orkh&quot;,
    &quot;Oriya&quot;,
    &quot;Orya&quot;,
    &quot;Osage&quot;,
    &quot;Osge&quot;,
    &quot;Osmanya&quot;,
    &quot;Osma&quot;,
    &quot;Pahawh_Hmong&quot;,
    &quot;Hmng&quot;,
    &quot;Palmyrene&quot;,
    &quot;Palm&quot;,
    &quot;Pau_Cin_Hau&quot;,
    &quot;Pauc&quot;,
    &quot;Phags_Pa&quot;,
    &quot;Phag&quot;,
    &quot;Phoenician&quot;,
    &quot;Phnx&quot;,
    &quot;Psalter_Pahlavi&quot;,
    &quot;Phlp&quot;,
    &quot;Rejang&quot;,
    &quot;Rjng&quot;,
    &quot;Runic&quot;,
    &quot;Runr&quot;,
    &quot;Samaritan&quot;,
    &quot;Samr&quot;,
    &quot;Saurashtra&quot;,
    &quot;Saur&quot;,
    &quot;Sharada&quot;,
    &quot;Shrd&quot;,
    &quot;Shavian&quot;,
    &quot;Shaw&quot;,
    &quot;Siddham&quot;,
    &quot;Sidd&quot;,
    &quot;SignWriting&quot;,
    &quot;Sgnw&quot;,
    &quot;Sinhala&quot;,
    &quot;Sinh&quot;,
    &quot;Sora_Sompeng&quot;,
    &quot;Sora&quot;,
    &quot;Soyombo&quot;,
    &quot;Soyo&quot;,
    &quot;Sundanese&quot;,
    &quot;Sund&quot;,
    &quot;Syloti_Nagri&quot;,
    &quot;Sylo&quot;,
    &quot;Syriac&quot;,
    &quot;Syrc&quot;,
    &quot;Tagalog&quot;,
    &quot;Tglg&quot;,
    &quot;Tagbanwa&quot;,
    &quot;Tagb&quot;,
    &quot;Tai_Le&quot;,
    &quot;Tale&quot;,
    &quot;Tai_Tham&quot;,
    &quot;Lana&quot;,
    &quot;Tai_Viet&quot;,
    &quot;Tavt&quot;,
    &quot;Takri&quot;,
    &quot;Takr&quot;,
    &quot;Tamil&quot;,
    &quot;Taml&quot;,
    &quot;Tangut&quot;,
    &quot;Tang&quot;,
    &quot;Telugu&quot;,
    &quot;Telu&quot;,
    &quot;Thaana&quot;,
    &quot;Thaa&quot;,
    &quot;Thai&quot;,
    &quot;Tibetan&quot;,
    &quot;Tibt&quot;,
    &quot;Tifinagh&quot;,
    &quot;Tfng&quot;,
    &quot;Tirhuta&quot;,
    &quot;Tirh&quot;,
    &quot;Ugaritic&quot;,
    &quot;Ugar&quot;,
    &quot;Vai&quot;,
    &quot;Vaii&quot;,
    &quot;Warang_Citi&quot;,
    &quot;Wara&quot;,
    &quot;Yi&quot;,
    &quot;Yiii&quot;,
    &quot;Zanabazar_Square&quot;,
    &quot;Zanb&quot;
  ]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;

var pp$9 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = &quot;gim&quot; + (parser.options.ecmaVersion &gt;= 6 ? &quot;uy&quot; : &quot;&quot;) + (parser.options.ecmaVersion &gt;= 9 ? &quot;s&quot; : &quot;&quot;);
  this.source = &quot;&quot;;
  this.flags = &quot;&quot;;
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = &quot;&quot;;
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf(&quot;u&quot;) !== -1;
  this.start = start | 0;
  this.source = pattern + &quot;&quot;;
  this.flags = flags;
  this.switchU = unicode &amp;&amp; this.parser.options.ecmaVersion &gt;= 6;
  this.switchN = unicode &amp;&amp; this.parser.options.ecmaVersion &gt;= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, (&quot;Invalid regular expression: /&quot; + (this.source) + &quot;/: &quot; + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i &gt;= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c &lt;= 0xD7FF || c &gt;= 0xE000 || i + 1 &gt;= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next &gt;= 0xDC00 &amp;&amp; next &lt;= 0xDFFF ? (c &lt;&lt; 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i &gt;= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!this.switchU || c &lt;= 0xD7FF || c &gt;= 0xE000 || i + 1 &gt;= l ||
      (next = s.charCodeAt(i + 1)) &lt; 0xDC00 || next &gt; 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString$1(ch) {
  if (ch &lt;= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch &gt;&gt; 10) + 0xD800, (ch &amp; 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpFlags = function(state) {
  var this$1 = this;

  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i &lt; flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this$1.raise(state.start, &quot;Invalid regular expression flag&quot;);
    }
    if (flags.indexOf(flag, i + 1) &gt; -1) {
      this$1.raise(state.start, &quot;Duplicate regular expression flag&quot;);
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$9.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = &quot;&quot;;
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise(&quot;Unmatched &#039;)&#039;&quot;);
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise(&quot;Lone quantifier brackets&quot;);
    }
  }
  if (state.maxBackReference &gt; state.numCapturingParens) {
    state.raise(&quot;Invalid escape&quot;);
  }
  for (var i = 0, list = state.backReferenceNames; i &lt; list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise(&quot;Invalid named capture referenced&quot;);
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$9.regexp_disjunction = function(state) {
  var this$1 = this;

  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this$1.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$9.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    {  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$9.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$9.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) &amp;&amp; state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion &gt;= 9) {
      lookbehind = state.eat(0x3C /* &lt; */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise(&quot;Unterminated group&quot;);
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$9.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$9.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$9.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
          state.raise(&quot;numbers out of order in {} quantifier&quot;);
        }
        return true
      }
    }
    if (state.switchU &amp;&amp; !noError) {
      state.raise(&quot;Incomplete quantifier&quot;);
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$9.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) &amp;&amp; state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise(&quot;Unterminated group&quot;);
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise(&quot;Unterminated group&quot;);
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$9.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$9.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$9.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch &gt;= 0x28 /* ( */ &amp;&amp; ch &lt;= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch &gt;= 0x5B /* [ */ &amp;&amp; ch &lt;= 0x5E /* ^ */ ||
    ch &gt;= 0x7B /* { */ &amp;&amp; ch &lt;= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$9.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 &amp;&amp; !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$9.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &amp;&amp;
    ch !== 0x24 /* $ */ &amp;&amp;
    !(ch &gt;= 0x28 /* ( */ &amp;&amp; ch &lt;= 0x2B /* + */) &amp;&amp;
    ch !== 0x2E /* . */ &amp;&amp;
    ch !== 0x3F /* ? */ &amp;&amp;
    ch !== 0x5B /* [ */ &amp;&amp;
    ch !== 0x5E /* ^ */ &amp;&amp;
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$9.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
  }
};

// GroupName[U] ::
//   `&lt;` RegExpIdentifierName[?U] `&gt;`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatGroupName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.regexp_eatRegExpIdentifierName(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString$1(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString$1(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$9.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   &lt;ZWNJ&gt;
//   &lt;ZWJ&gt;
pp$9.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch === 0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$9.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
};
pp$9.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n &lt;= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise(&quot;Invalid named reference&quot;);
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$9.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$9.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ &amp;&amp; !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$9.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$9.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch &gt;= 0x41 /* A */ &amp;&amp; ch &lt;= 0x5A /* Z */) ||
    (ch &gt;= 0x61 /* a */ &amp;&amp; ch &lt;= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &amp;&amp;
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatHexDigits(state) &amp;&amp;
      state.eat(0x7D /* } */) &amp;&amp;
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch &gt;= 0 &amp;&amp; ch &lt;= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$9.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ &amp;&amp; (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$9.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch &gt;= 0x31 /* 1 */ &amp;&amp; ch &lt;= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$9.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &amp;&amp;
    this.options.ecmaVersion &gt;= 9 &amp;&amp;
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatUnicodePropertyValueExpression(state) &amp;&amp;
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise(&quot;Invalid property name&quot;);
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
    state.raise(&quot;Invalid property name&quot;);
  }
};
pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (data.$LONE.indexOf(nameOrValue) === -1) {
    state.raise(&quot;Invalid property name&quot;);
  }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$9.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$9.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$9.regexp_classRanges = function(state) {
  var this$1 = this;

  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this$1.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
        state.raise(&quot;Range out of order in character class&quot;);
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$9.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise(&quot;Invalid class escape&quot;);
      }
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$9.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* &lt;BS&gt; */
    return true
  }

  if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$9.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$9.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$9.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x39 /* 9 */) ||
    (ch &gt;= 0x41 /* A */ &amp;&amp; ch &lt;= 0x46 /* F */) ||
    (ch &gt;= 0x61 /* a */ &amp;&amp; ch &lt;= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch &gt;= 0x41 /* A */ &amp;&amp; ch &lt;= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch &gt;= 0x61 /* a */ &amp;&amp; ch &lt;= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$9.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i &lt; length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$8 = Parser.prototype;

// Move to the next token

pp$8.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function() {
  this.next();
  return new Token(this)
};

// If we&#039;re in an ES6 environment, make parsers iterable
if (typeof Symbol !== &quot;undefined&quot;)
  { pp$8[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`&quot;use strict&quot;; 010;` should fail).

pp$8.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object&#039;s token-related
// properties.

pp$8.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$8.readToken = function(code) {
  // Identifier or keyword. &#039;\uXXXX&#039; sequences are allowed in
  // identifiers, so &#039;\&#039; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &#039;\&#039; */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$8.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
};

pp$8.skipBlockComment = function() {
  var this$1 = this;

  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var start = this.pos, end = this.input.indexOf(&quot;*/&quot;, this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, &quot;Unterminated comment&quot;); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) &amp;&amp; match.index &lt; this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$8.skipLineComment = function(startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos &lt; this.input.length &amp;&amp; !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$8.skipSpace = function() {
  var this$1 = this;

  loop: while (this.pos &lt; this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);
    switch (ch) {
    case 32: case 160: // &#039; &#039;
      ++this$1.pos;
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos;
      }
    case 10: case 8232: case 8233:
      ++this$1.pos;
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      break
    case 47: // &#039;/&#039;
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // &#039;*&#039;
        this$1.skipBlockComment();
        break
      case 47:
        this$1.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch &gt; 8 &amp;&amp; ch &lt; 14 || ch &gt;= 5760 &amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one&#039;s `start` will point at the
// right position.

pp$8.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$8.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &#039;.&#039;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$8.readToken_slash = function() { // &#039;/&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$8.readToken_mult_modulo_exp = function(code) { // &#039;%*&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion &gt;= 7 &amp;&amp; code === 42 &amp;&amp; next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$8.readToken_pipe_amp = function(code) { // &#039;|&amp;&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$8.readToken_caret = function() { // &#039;^&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$8.readToken_plus_min = function(code) { // &#039;+-&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 &amp;&amp;
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `--&gt;` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$8.readToken_lt_gt = function(code) { // &#039;&lt;&gt;&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 &amp;&amp; code === 60 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 45 &amp;&amp;
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `&lt;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$8.readToken_eq_excl = function(code) { // &#039;=!&#039;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 &amp;&amp; next === 62 &amp;&amp; this.options.ecmaVersion &gt;= 6) { // &#039;=&gt;&#039;
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$8.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // &#039;.&#039;
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // &#039;`&#039;
    if (this.options.ecmaVersion &lt; 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // &#039;0&#039;
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // &#039;0x&#039;, &#039;0X&#039; - hex number
    if (this.options.ecmaVersion &gt;= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &#039;0o&#039;, &#039;0O&#039; - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &#039;0b&#039;, &#039;0B&#039; - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // &#039;&quot;&#039;, &quot;&#039;&quot;
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. &#039;=&#039; (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // &#039;/&#039;
    return this.readToken_slash()

  case 37: case 42: // &#039;%*&#039;
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // &#039;|&amp;&#039;
    return this.readToken_pipe_amp(code)

  case 94: // &#039;^&#039;
    return this.readToken_caret()

  case 43: case 45: // &#039;+-&#039;
    return this.readToken_plus_min(code)

  case 60: case 62: // &#039;&lt;&gt;&#039;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &#039;=!&#039;
    return this.readToken_eq_excl(code)

  case 126: // &#039;~&#039;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &#039;&quot; + codePointToString(code) + &quot;&#039;&quot;);
};

pp$8.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$8.readRegexp = function() {
  var this$1 = this;

  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this$1.pos &gt;= this$1.input.length) { this$1.raise(start, &quot;Unterminated regular expression&quot;); }
    var ch = this$1.input.charAt(this$1.pos);
    if (lineBreak.test(ch)) { this$1.raise(start, &quot;Unterminated regular expression&quot;); }
    if (!escaped) {
      if (ch === &quot;[&quot;) { inClass = true; }
      else if (ch === &quot;]&quot; &amp;&amp; inClass) { inClass = false; }
      else if (ch === &quot;/&quot; &amp;&amp; !inClass) { break }
      escaped = ch === &quot;\\&quot;;
    } else { escaped = false; }
    ++this$1.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$8.readInt = function(radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
    if (code &gt;= 97) { val = code - 97 + 10; } // a
    else if (code &gt;= 65) { val = code - 65 + 10; } // A
    else if (code &gt;= 48 &amp;&amp; code &lt;= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val &gt;= radix) { break }
    ++this$1.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null &amp;&amp; this.pos - start !== len) { return null }

  return total
};

pp$8.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$8.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot &amp;&amp; this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  var octal = this.pos - start &gt;= 2 &amp;&amp; this.input.charCodeAt(start) === 48;
  if (octal &amp;&amp; this.strict) { this.raise(start, &quot;Invalid number&quot;); }
  if (octal &amp;&amp; /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 &amp;&amp; !octal) { // &#039;.&#039;
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) &amp;&amp; !octal) { // &#039;eE&#039;
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // &#039;+-&#039;
    if (this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$8.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &#039;{&#039;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code &lt;= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code &gt;&gt; 10) + 0xD800, (code &amp; 1023) + 0xDC00)
}

pp$8.readString = function(quote) {
  var this$1 = this;

  var out = &quot;&quot;, chunkStart = ++this.pos;
  for (;;) {
    if (this$1.pos &gt;= this$1.input.length) { this$1.raise(this$1.start, &quot;Unterminated string constant&quot;); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === quote) { break }
    if (ch === 92) { // &#039;\&#039;
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch, this$1.options.ecmaVersion &gt;= 10)) { this$1.raise(this$1.start, &quot;Unterminated string constant&quot;); }
      ++this$1.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function(position, message) {
  if (this.inTemplateElement &amp;&amp; this.options.ecmaVersion &gt;= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function() {
  var this$1 = this;

  var out = &quot;&quot;, chunkStart = this.pos;
  for (;;) {
    if (this$1.pos &gt;= this$1.input.length) { this$1.raise(this$1.start, &quot;Unterminated template&quot;); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === 96 || ch === 36 &amp;&amp; this$1.input.charCodeAt(this$1.pos + 1) === 123) { // &#039;`&#039;, &#039;${&#039;
      if (this$1.pos === this$1.start &amp;&amp; (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL)
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out)
    }
    if (ch === 92) { // &#039;\&#039;
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
      case 10:
        out += &quot;\n&quot;;
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$8.readInvalidTemplateToken = function() {
  var this$1 = this;

  for (; this.pos &lt; this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
    case &quot;\\&quot;:
      ++this$1.pos;
      break

    case &quot;$&quot;:
      if (this$1.input[this$1.pos + 1] !== &quot;{&quot;) {
        break
      }
    // falls through

    case &quot;`&quot;:
      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))

    // no default
    }
  }
  this.raise(this.start, &quot;Unterminated template&quot;);
};

// Used to read escaped characters

pp$8.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return &quot;\n&quot; // &#039;n&#039; -&gt; &#039;\n&#039;
  case 114: return &quot;\r&quot; // &#039;r&#039; -&gt; &#039;\r&#039;
  case 120: return String.fromCharCode(this.readHexChar(2)) // &#039;x&#039;
  case 117: return codePointToString(this.readCodePoint()) // &#039;u&#039;
  case 116: return &quot;\t&quot; // &#039;t&#039; -&gt; &#039;\t&#039;
  case 98: return &quot;\b&quot; // &#039;b&#039; -&gt; &#039;\b&#039;
  case 118: return &quot;\u000b&quot; // &#039;v&#039; -&gt; &#039;\u000b&#039;
  case 102: return &quot;\f&quot; // &#039;f&#039; -&gt; &#039;\f&#039;
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &#039;\r\n&#039;
  case 10: // &#039; \n&#039;
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return &quot;&quot;
  default:
    if (ch &gt;= 48 &amp;&amp; ch &lt;= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal &gt; 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== &quot;0&quot; || ch === 56 || ch === 57) &amp;&amp; (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? &quot;Octal literal in template string&quot;
            : &quot;Octal literal in strict mode&quot;
        );
      }
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences (&#039;\x&#039;, &#039;\u&#039;, &#039;\U&#039;).

pp$8.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, &quot;Bad character escape sequence&quot;); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a &#039;\u&#039; escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$8.readWord1 = function() {
  var this$1 = this;

  this.containsEsc = false;
  var word = &quot;&quot;, first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion &gt;= 6;
  while (this.pos &lt; this.input.length) {
    var ch = this$1.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch &lt;= 0xffff ? 1 : 2;
    } else if (ch === 92) { // &quot;\&quot;
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;
      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // &quot;u&quot;
        { this$1.invalidStringToken(this$1.pos, &quot;Expecting Unicode escape sequence \\uXXXX&quot;); }
      ++this$1.pos;
      var esc = this$1.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this$1.invalidStringToken(escStart, &quot;Invalid Unicode escape&quot;); }
      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$8.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, &quot;Escape sequence in keyword &quot; + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

var version = &quot;5.7.3&quot;;

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return new Parser(options, input).parse()
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression()
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return new Parser(options, input)
}

// This is a terrible kludge to support the existing, pre-ES6
// interface where the loose parser module retroactively adds exports
// to this module.
var parse_dammit;
var LooseParser;
var pluginsLoose; // eslint-disable-line camelcase
function addLooseExports(parse, Parser$$1, plugins$$1) {
  parse_dammit = parse; // eslint-disable-line camelcase
  LooseParser = Parser$$1;
  pluginsLoose = plugins$$1;
}

export { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
