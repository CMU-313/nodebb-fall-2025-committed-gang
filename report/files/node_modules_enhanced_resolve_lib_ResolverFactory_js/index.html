<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/enhanced-resolve/lib/ResolverFactory.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/enhanced-resolve/lib/ResolverFactory.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">47.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">732</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">54.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.61</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

// eslint-disable-next-line n/prefer-global/process
const { versions } = require(&quot;process&quot;);

const AliasFieldPlugin = require(&quot;./AliasFieldPlugin&quot;);
const AliasPlugin = require(&quot;./AliasPlugin&quot;);
const AppendPlugin = require(&quot;./AppendPlugin&quot;);
const ConditionalPlugin = require(&quot;./ConditionalPlugin&quot;);
const DescriptionFilePlugin = require(&quot;./DescriptionFilePlugin&quot;);
const DirectoryExistsPlugin = require(&quot;./DirectoryExistsPlugin&quot;);
const ExportsFieldPlugin = require(&quot;./ExportsFieldPlugin&quot;);
const ExtensionAliasPlugin = require(&quot;./ExtensionAliasPlugin&quot;);
const FileExistsPlugin = require(&quot;./FileExistsPlugin&quot;);
const ImportsFieldPlugin = require(&quot;./ImportsFieldPlugin&quot;);
const JoinRequestPartPlugin = require(&quot;./JoinRequestPartPlugin&quot;);
const JoinRequestPlugin = require(&quot;./JoinRequestPlugin&quot;);
const MainFieldPlugin = require(&quot;./MainFieldPlugin&quot;);
const ModulesInHierarchicalDirectoriesPlugin = require(&quot;./ModulesInHierarchicalDirectoriesPlugin&quot;);
const ModulesInRootPlugin = require(&quot;./ModulesInRootPlugin&quot;);
const NextPlugin = require(&quot;./NextPlugin&quot;);
const ParsePlugin = require(&quot;./ParsePlugin&quot;);
const PnpPlugin = require(&quot;./PnpPlugin&quot;);
const Resolver = require(&quot;./Resolver&quot;);
const RestrictionsPlugin = require(&quot;./RestrictionsPlugin&quot;);
const ResultPlugin = require(&quot;./ResultPlugin&quot;);
const RootsPlugin = require(&quot;./RootsPlugin&quot;);
const SelfReferencePlugin = require(&quot;./SelfReferencePlugin&quot;);
const SymlinkPlugin = require(&quot;./SymlinkPlugin&quot;);
const SyncAsyncFileSystemDecorator = require(&quot;./SyncAsyncFileSystemDecorator&quot;);
const TryNextPlugin = require(&quot;./TryNextPlugin&quot;);
const UnsafeCachePlugin = require(&quot;./UnsafeCachePlugin&quot;);
const UseFilePlugin = require(&quot;./UseFilePlugin&quot;);
const { PathType, getType } = require(&quot;./util/path&quot;);

/** @typedef {import(&quot;./AliasPlugin&quot;).AliasOption} AliasOptionEntry */
/** @typedef {import(&quot;./ExtensionAliasPlugin&quot;).ExtensionAliasOption} ExtensionAliasOption */
/** @typedef {import(&quot;./PnpPlugin&quot;).PnpApiImpl} PnpApi */
/** @typedef {import(&quot;./Resolver&quot;).EnsuredHooks} EnsuredHooks */
/** @typedef {import(&quot;./Resolver&quot;).FileSystem} FileSystem */
/** @typedef {import(&quot;./Resolver&quot;).KnownHooks} KnownHooks */
/** @typedef {import(&quot;./Resolver&quot;).ResolveRequest} ResolveRequest */
/** @typedef {import(&quot;./Resolver&quot;).SyncFileSystem} SyncFileSystem */
/** @typedef {import(&quot;./UnsafeCachePlugin&quot;).Cache} Cache */

/** @typedef {string | string[] | false} AliasOptionNewRequest */
/** @typedef {{ [k: string]: AliasOptionNewRequest }} AliasOptions */
/** @typedef {{ [k: string]: string|string[] }} ExtensionAliasOptions */
/** @typedef {false | 0 | &quot;&quot; | null | undefined} Falsy */
/** @typedef {{apply: (resolver: Resolver) =&gt; void} | ((this: Resolver, resolver: Resolver) =&gt; void) | Falsy} Plugin */

/**
 * @typedef {object} UserResolveOptions
 * @property {(AliasOptions | AliasOptionEntry[])=} alias A list of module alias configurations or an object which maps key to value
 * @property {(AliasOptions | AliasOptionEntry[])=} fallback A list of module alias configurations or an object which maps key to value, applied only after modules option
 * @property {ExtensionAliasOptions=} extensionAlias An object which maps extension to extension aliases
 * @property {(string | string[])[]=} aliasFields A list of alias fields in description files
 * @property {((predicate: ResolveRequest) =&gt; boolean)=} cachePredicate A function which decides whether a request should be cached or not. An object is passed with at least `path` and `request` properties.
 * @property {boolean=} cacheWithContext Whether or not the unsafeCache should include request context as part of the cache key.
 * @property {string[]=} descriptionFiles A list of description files to read from
 * @property {string[]=} conditionNames A list of exports field condition names.
 * @property {boolean=} enforceExtension Enforce that a extension from extensions must be used
 * @property {(string | string[])[]=} exportsFields A list of exports fields in description files
 * @property {(string | string[])[]=} importsFields A list of imports fields in description files
 * @property {string[]=} extensions A list of extensions which should be tried for files
 * @property {FileSystem} fileSystem The file system which should be used
 * @property {(Cache | boolean)=} unsafeCache Use this cache object to unsafely cache the successful requests
 * @property {boolean=} symlinks Resolve symlinks to their symlinked location
 * @property {Resolver=} resolver A prepared Resolver to which the plugins are attached
 * @property {string[] | string=} modules A list of directories to resolve modules from, can be absolute path or folder name
 * @property {(string | string[] | {name: string | string[], forceRelative: boolean})[]=} mainFields A list of main fields in description files
 * @property {string[]=} mainFiles A list of main files in directories
 * @property {Plugin[]=} plugins A list of additional resolve plugins which should be applied
 * @property {PnpApi | null=} pnpApi A PnP API that should be used - null is &quot;never&quot;, undefined is &quot;auto&quot;
 * @property {string[]=} roots A list of root paths
 * @property {boolean=} fullySpecified The request is already fully specified and no extensions or directories are resolved for it
 * @property {boolean=} resolveToContext Resolve to a context instead of a file
 * @property {(string|RegExp)[]=} restrictions A list of resolve restrictions
 * @property {boolean=} useSyncFileSystemCalls Use only the sync constraints of the file system calls
 * @property {boolean=} preferRelative Prefer to resolve module requests as relative requests before falling back to modules
 * @property {boolean=} preferAbsolute Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots
 */

/**
 * @typedef {object} ResolveOptions
 * @property {AliasOptionEntry[]} alias alias
 * @property {AliasOptionEntry[]} fallback fallback
 * @property {Set&lt;string | string[]&gt;} aliasFields alias fields
 * @property {ExtensionAliasOption[]} extensionAlias extension alias
 * @property {(predicate: ResolveRequest) =&gt; boolean} cachePredicate cache predicate
 * @property {boolean} cacheWithContext cache with context
 * @property {Set&lt;string&gt;} conditionNames A list of exports field condition names.
 * @property {string[]} descriptionFiles description files
 * @property {boolean} enforceExtension enforce extension
 * @property {Set&lt;string | string[]&gt;} exportsFields exports fields
 * @property {Set&lt;string | string[]&gt;} importsFields imports fields
 * @property {Set&lt;string&gt;} extensions extensions
 * @property {FileSystem} fileSystem fileSystem
 * @property {Cache | false} unsafeCache unsafe cache
 * @property {boolean} symlinks symlinks
 * @property {Resolver=} resolver resolver
 * @property {Array&lt;string | string[]&gt;} modules modules
 * @property {{ name: string[], forceRelative: boolean }[]} mainFields main fields
 * @property {Set&lt;string&gt;} mainFiles main files
 * @property {Plugin[]} plugins plugins
 * @property {PnpApi | null} pnpApi pnp API
 * @property {Set&lt;string&gt;} roots roots
 * @property {boolean} fullySpecified fully specified
 * @property {boolean} resolveToContext resolve to context
 * @property {Set&lt;string | RegExp&gt;} restrictions restrictions
 * @property {boolean} preferRelative prefer relative
 * @property {boolean} preferAbsolute prefer absolute
 */

/**
 * @param {PnpApi | null=} option option
 * @returns {PnpApi | null} processed option
 */
function processPnpApiOption(option) {
	if (
		option === undefined &amp;&amp;
		/** @type {NodeJS.ProcessVersions &amp; {pnp: string}} */ versions.pnp
	) {
		const _findPnpApi =
			/** @type {(issuer: string) =&gt; PnpApi | null}} */
			(
				// @ts-expect-error maybe nothing
				require(&quot;module&quot;).findPnpApi
			);

		if (_findPnpApi) {
			return {
				resolveToUnqualified(request, issuer, opts) {
					const pnpapi = _findPnpApi(issuer);

					if (!pnpapi) {
						// Issuer isn&#039;t managed by PnP
						return null;
					}

					return pnpapi.resolveToUnqualified(request, issuer, opts);
				},
			};
		}
	}

	return option || null;
}

/**
 * @param {AliasOptions | AliasOptionEntry[] | undefined} alias alias
 * @returns {AliasOptionEntry[]} normalized aliases
 */
function normalizeAlias(alias) {
	return typeof alias === &quot;object&quot; &amp;&amp; !Array.isArray(alias) &amp;&amp; alias !== null
		? Object.keys(alias).map((key) =&gt; {
				/** @type {AliasOptionEntry} */
				const obj = { name: key, onlyModule: false, alias: alias[key] };

				if (/\$$/.test(key)) {
					obj.onlyModule = true;
					obj.name = key.slice(0, -1);
				}

				return obj;
			})
		: /** @type {Array&lt;AliasOptionEntry&gt;} */ (alias) || [];
}

/**
 * Merging filtered elements
 * @param {string[]} array source array
 * @param {(item: string) =&gt; boolean} filter predicate
 * @returns {Array&lt;string | string[]&gt;} merge result
 */
function mergeFilteredToArray(array, filter) {
	/** @type {Array&lt;string | string[]&gt;} */
	const result = [];
	const set = new Set(array);

	for (const item of set) {
		if (filter(item)) {
			const lastElement =
				result.length &gt; 0 ? result[result.length - 1] : undefined;
			if (Array.isArray(lastElement)) {
				lastElement.push(item);
			} else {
				result.push([item]);
			}
		} else {
			result.push(item);
		}
	}

	return result;
}

/**
 * @param {UserResolveOptions} options input options
 * @returns {ResolveOptions} output options
 */
function createOptions(options) {
	const mainFieldsSet = new Set(options.mainFields || [&quot;main&quot;]);
	/** @type {ResolveOptions[&quot;mainFields&quot;]} */
	const mainFields = [];

	for (const item of mainFieldsSet) {
		if (typeof item === &quot;string&quot;) {
			mainFields.push({
				name: [item],
				forceRelative: true,
			});
		} else if (Array.isArray(item)) {
			mainFields.push({
				name: item,
				forceRelative: true,
			});
		} else {
			mainFields.push({
				name: Array.isArray(item.name) ? item.name : [item.name],
				forceRelative: item.forceRelative,
			});
		}
	}

	return {
		alias: normalizeAlias(options.alias),
		fallback: normalizeAlias(options.fallback),
		aliasFields: new Set(options.aliasFields),
		cachePredicate:
			options.cachePredicate ||
			function trueFn() {
				return true;
			},
		cacheWithContext:
			typeof options.cacheWithContext !== &quot;undefined&quot;
				? options.cacheWithContext
				: true,
		exportsFields: new Set(options.exportsFields || [&quot;exports&quot;]),
		importsFields: new Set(options.importsFields || [&quot;imports&quot;]),
		conditionNames: new Set(options.conditionNames),
		descriptionFiles: [
			...new Set(options.descriptionFiles || [&quot;package.json&quot;]),
		],
		enforceExtension:
			options.enforceExtension === undefined
				? Boolean(options.extensions &amp;&amp; options.extensions.includes(&quot;&quot;))
				: options.enforceExtension,
		extensions: new Set(options.extensions || [&quot;.js&quot;, &quot;.json&quot;, &quot;.node&quot;]),
		extensionAlias: options.extensionAlias
			? Object.keys(options.extensionAlias).map((k) =&gt; ({
					extension: k,
					alias: /** @type {ExtensionAliasOptions} */ (options.extensionAlias)[
						k
					],
				}))
			: [],
		fileSystem: options.useSyncFileSystemCalls
			? new SyncAsyncFileSystemDecorator(
					/** @type {SyncFileSystem} */ (
						/** @type {unknown} */ (options.fileSystem)
					),
				)
			: options.fileSystem,
		unsafeCache:
			options.unsafeCache &amp;&amp; typeof options.unsafeCache !== &quot;object&quot;
				? /** @type {Cache} */ ({})
				: options.unsafeCache || false,
		symlinks: typeof options.symlinks !== &quot;undefined&quot; ? options.symlinks : true,
		resolver: options.resolver,
		modules: mergeFilteredToArray(
			Array.isArray(options.modules)
				? options.modules
				: options.modules
					? [options.modules]
					: [&quot;node_modules&quot;],
			(item) =&gt; {
				const type = getType(item);
				return type === PathType.Normal || type === PathType.Relative;
			},
		),
		mainFields,
		mainFiles: new Set(options.mainFiles || [&quot;index&quot;]),
		plugins: options.plugins || [],
		pnpApi: processPnpApiOption(options.pnpApi),
		roots: new Set(options.roots || undefined),
		fullySpecified: options.fullySpecified || false,
		resolveToContext: options.resolveToContext || false,
		preferRelative: options.preferRelative || false,
		preferAbsolute: options.preferAbsolute || false,
		restrictions: new Set(options.restrictions),
	};
}

/**
 * @param {UserResolveOptions} options resolve options
 * @returns {Resolver} created resolver
 */
module.exports.createResolver = function createResolver(options) {
	const normalizedOptions = createOptions(options);

	const {
		alias,
		fallback,
		aliasFields,
		cachePredicate,
		cacheWithContext,
		conditionNames,
		descriptionFiles,
		enforceExtension,
		exportsFields,
		extensionAlias,
		importsFields,
		extensions,
		fileSystem,
		fullySpecified,
		mainFields,
		mainFiles,
		modules,
		plugins: userPlugins,
		pnpApi,
		resolveToContext,
		preferRelative,
		preferAbsolute,
		symlinks,
		unsafeCache,
		resolver: customResolver,
		restrictions,
		roots,
	} = normalizedOptions;

	const plugins = [...userPlugins];

	const resolver =
		customResolver || new Resolver(fileSystem, normalizedOptions);

	// // pipeline ////

	resolver.ensureHook(&quot;resolve&quot;);
	resolver.ensureHook(&quot;internalResolve&quot;);
	resolver.ensureHook(&quot;newInternalResolve&quot;);
	resolver.ensureHook(&quot;parsedResolve&quot;);
	resolver.ensureHook(&quot;describedResolve&quot;);
	resolver.ensureHook(&quot;rawResolve&quot;);
	resolver.ensureHook(&quot;normalResolve&quot;);
	resolver.ensureHook(&quot;internal&quot;);
	resolver.ensureHook(&quot;rawModule&quot;);
	resolver.ensureHook(&quot;alternateRawModule&quot;);
	resolver.ensureHook(&quot;module&quot;);
	resolver.ensureHook(&quot;resolveAsModule&quot;);
	resolver.ensureHook(&quot;undescribedResolveInPackage&quot;);
	resolver.ensureHook(&quot;resolveInPackage&quot;);
	resolver.ensureHook(&quot;resolveInExistingDirectory&quot;);
	resolver.ensureHook(&quot;relative&quot;);
	resolver.ensureHook(&quot;describedRelative&quot;);
	resolver.ensureHook(&quot;directory&quot;);
	resolver.ensureHook(&quot;undescribedExistingDirectory&quot;);
	resolver.ensureHook(&quot;existingDirectory&quot;);
	resolver.ensureHook(&quot;undescribedRawFile&quot;);
	resolver.ensureHook(&quot;rawFile&quot;);
	resolver.ensureHook(&quot;file&quot;);
	resolver.ensureHook(&quot;finalFile&quot;);
	resolver.ensureHook(&quot;existingFile&quot;);
	resolver.ensureHook(&quot;resolved&quot;);

	// TODO remove in next major
	// cspell:word Interal
	// Backward-compat
	// @ts-expect-error
	resolver.hooks.newInteralResolve = resolver.hooks.newInternalResolve;

	// resolve
	for (const { source, resolveOptions } of [
		{ source: &quot;resolve&quot;, resolveOptions: { fullySpecified } },
		{ source: &quot;internal-resolve&quot;, resolveOptions: { fullySpecified: false } },
	]) {
		if (unsafeCache) {
			plugins.push(
				new UnsafeCachePlugin(
					source,
					cachePredicate,
					/** @type {import(&quot;./UnsafeCachePlugin&quot;).Cache} */ (unsafeCache),
					cacheWithContext,
					`new-${source}`,
				),
			);
			plugins.push(
				new ParsePlugin(`new-${source}`, resolveOptions, &quot;parsed-resolve&quot;),
			);
		} else {
			plugins.push(new ParsePlugin(source, resolveOptions, &quot;parsed-resolve&quot;));
		}
	}

	// parsed-resolve
	plugins.push(
		new DescriptionFilePlugin(
			&quot;parsed-resolve&quot;,
			descriptionFiles,
			false,
			&quot;described-resolve&quot;,
		),
	);
	plugins.push(new NextPlugin(&quot;after-parsed-resolve&quot;, &quot;described-resolve&quot;));

	// described-resolve
	plugins.push(new NextPlugin(&quot;described-resolve&quot;, &quot;raw-resolve&quot;));
	if (fallback.length &gt; 0) {
		plugins.push(
			new AliasPlugin(&quot;described-resolve&quot;, fallback, &quot;internal-resolve&quot;),
		);
	}

	// raw-resolve
	if (alias.length &gt; 0) {
		plugins.push(new AliasPlugin(&quot;raw-resolve&quot;, alias, &quot;internal-resolve&quot;));
	}
	for (const item of aliasFields) {
		plugins.push(new AliasFieldPlugin(&quot;raw-resolve&quot;, item, &quot;internal-resolve&quot;));
	}
	for (const item of extensionAlias) {
		plugins.push(
			new ExtensionAliasPlugin(&quot;raw-resolve&quot;, item, &quot;normal-resolve&quot;),
		);
	}
	plugins.push(new NextPlugin(&quot;raw-resolve&quot;, &quot;normal-resolve&quot;));

	// normal-resolve
	if (preferRelative) {
		plugins.push(new JoinRequestPlugin(&quot;after-normal-resolve&quot;, &quot;relative&quot;));
	}
	plugins.push(
		new ConditionalPlugin(
			&quot;after-normal-resolve&quot;,
			{ module: true },
			&quot;resolve as module&quot;,
			false,
			&quot;raw-module&quot;,
		),
	);
	plugins.push(
		new ConditionalPlugin(
			&quot;after-normal-resolve&quot;,
			{ internal: true },
			&quot;resolve as internal import&quot;,
			false,
			&quot;internal&quot;,
		),
	);
	if (preferAbsolute) {
		plugins.push(new JoinRequestPlugin(&quot;after-normal-resolve&quot;, &quot;relative&quot;));
	}
	if (roots.size &gt; 0) {
		plugins.push(new RootsPlugin(&quot;after-normal-resolve&quot;, roots, &quot;relative&quot;));
	}
	if (!preferRelative &amp;&amp; !preferAbsolute) {
		plugins.push(new JoinRequestPlugin(&quot;after-normal-resolve&quot;, &quot;relative&quot;));
	}

	// internal
	for (const importsField of importsFields) {
		plugins.push(
			new ImportsFieldPlugin(
				&quot;internal&quot;,
				conditionNames,
				importsField,
				&quot;relative&quot;,
				&quot;internal-resolve&quot;,
			),
		);
	}

	// raw-module
	for (const exportsField of exportsFields) {
		plugins.push(
			new SelfReferencePlugin(&quot;raw-module&quot;, exportsField, &quot;resolve-as-module&quot;),
		);
	}
	for (const item of modules) {
		if (Array.isArray(item)) {
			if (item.includes(&quot;node_modules&quot;) &amp;&amp; pnpApi) {
				plugins.push(
					new ModulesInHierarchicalDirectoriesPlugin(
						&quot;raw-module&quot;,
						item.filter((i) =&gt; i !== &quot;node_modules&quot;),
						&quot;module&quot;,
					),
				);
				plugins.push(
					new PnpPlugin(
						&quot;raw-module&quot;,
						pnpApi,
						&quot;undescribed-resolve-in-package&quot;,
						&quot;alternate-raw-module&quot;,
					),
				);

				plugins.push(
					new ModulesInHierarchicalDirectoriesPlugin(
						&quot;alternate-raw-module&quot;,
						[&quot;node_modules&quot;],
						&quot;module&quot;,
					),
				);
			} else {
				plugins.push(
					new ModulesInHierarchicalDirectoriesPlugin(
						&quot;raw-module&quot;,
						item,
						&quot;module&quot;,
					),
				);
			}
		} else {
			plugins.push(new ModulesInRootPlugin(&quot;raw-module&quot;, item, &quot;module&quot;));
		}
	}

	// module
	plugins.push(new JoinRequestPartPlugin(&quot;module&quot;, &quot;resolve-as-module&quot;));

	// resolve-as-module
	if (!resolveToContext) {
		plugins.push(
			new ConditionalPlugin(
				&quot;resolve-as-module&quot;,
				{ directory: false, request: &quot;.&quot; },
				&quot;single file module&quot;,
				true,
				&quot;undescribed-raw-file&quot;,
			),
		);
	}
	plugins.push(
		new DirectoryExistsPlugin(
			&quot;resolve-as-module&quot;,
			&quot;undescribed-resolve-in-package&quot;,
		),
	);

	// undescribed-resolve-in-package
	plugins.push(
		new DescriptionFilePlugin(
			&quot;undescribed-resolve-in-package&quot;,
			descriptionFiles,
			false,
			&quot;resolve-in-package&quot;,
		),
	);
	plugins.push(
		new NextPlugin(
			&quot;after-undescribed-resolve-in-package&quot;,
			&quot;resolve-in-package&quot;,
		),
	);

	// resolve-in-package
	for (const exportsField of exportsFields) {
		plugins.push(
			new ExportsFieldPlugin(
				&quot;resolve-in-package&quot;,
				conditionNames,
				exportsField,
				&quot;relative&quot;,
			),
		);
	}
	plugins.push(
		new NextPlugin(&quot;resolve-in-package&quot;, &quot;resolve-in-existing-directory&quot;),
	);

	// resolve-in-existing-directory
	plugins.push(
		new JoinRequestPlugin(&quot;resolve-in-existing-directory&quot;, &quot;relative&quot;),
	);

	// relative
	plugins.push(
		new DescriptionFilePlugin(
			&quot;relative&quot;,
			descriptionFiles,
			true,
			&quot;described-relative&quot;,
		),
	);
	plugins.push(new NextPlugin(&quot;after-relative&quot;, &quot;described-relative&quot;));

	// described-relative
	if (resolveToContext) {
		plugins.push(new NextPlugin(&quot;described-relative&quot;, &quot;directory&quot;));
	} else {
		plugins.push(
			new ConditionalPlugin(
				&quot;described-relative&quot;,
				{ directory: false },
				null,
				true,
				&quot;raw-file&quot;,
			),
		);
		plugins.push(
			new ConditionalPlugin(
				&quot;described-relative&quot;,
				{ fullySpecified: false },
				&quot;as directory&quot;,
				true,
				&quot;directory&quot;,
			),
		);
	}

	// directory
	plugins.push(
		new DirectoryExistsPlugin(&quot;directory&quot;, &quot;undescribed-existing-directory&quot;),
	);

	if (resolveToContext) {
		// undescribed-existing-directory
		plugins.push(new NextPlugin(&quot;undescribed-existing-directory&quot;, &quot;resolved&quot;));
	} else {
		// undescribed-existing-directory
		plugins.push(
			new DescriptionFilePlugin(
				&quot;undescribed-existing-directory&quot;,
				descriptionFiles,
				false,
				&quot;existing-directory&quot;,
			),
		);
		for (const item of mainFiles) {
			plugins.push(
				new UseFilePlugin(
					&quot;undescribed-existing-directory&quot;,
					item,
					&quot;undescribed-raw-file&quot;,
				),
			);
		}

		// described-existing-directory
		for (const item of mainFields) {
			plugins.push(
				new MainFieldPlugin(
					&quot;existing-directory&quot;,
					item,
					&quot;resolve-in-existing-directory&quot;,
				),
			);
		}
		for (const item of mainFiles) {
			plugins.push(
				new UseFilePlugin(&quot;existing-directory&quot;, item, &quot;undescribed-raw-file&quot;),
			);
		}

		// undescribed-raw-file
		plugins.push(
			new DescriptionFilePlugin(
				&quot;undescribed-raw-file&quot;,
				descriptionFiles,
				true,
				&quot;raw-file&quot;,
			),
		);
		plugins.push(new NextPlugin(&quot;after-undescribed-raw-file&quot;, &quot;raw-file&quot;));

		// raw-file
		plugins.push(
			new ConditionalPlugin(
				&quot;raw-file&quot;,
				{ fullySpecified: true },
				null,
				false,
				&quot;file&quot;,
			),
		);
		if (!enforceExtension) {
			plugins.push(new TryNextPlugin(&quot;raw-file&quot;, &quot;no extension&quot;, &quot;file&quot;));
		}
		for (const item of extensions) {
			plugins.push(new AppendPlugin(&quot;raw-file&quot;, item, &quot;file&quot;));
		}

		// file
		if (alias.length &gt; 0) {
			plugins.push(new AliasPlugin(&quot;file&quot;, alias, &quot;internal-resolve&quot;));
		}
		for (const item of aliasFields) {
			plugins.push(new AliasFieldPlugin(&quot;file&quot;, item, &quot;internal-resolve&quot;));
		}
		plugins.push(new NextPlugin(&quot;file&quot;, &quot;final-file&quot;));

		// final-file
		plugins.push(new FileExistsPlugin(&quot;final-file&quot;, &quot;existing-file&quot;));

		// existing-file
		if (symlinks) {
			plugins.push(new SymlinkPlugin(&quot;existing-file&quot;, &quot;existing-file&quot;));
		}
		plugins.push(new NextPlugin(&quot;existing-file&quot;, &quot;resolved&quot;));
	}

	const { resolved } =
		/** @type {KnownHooks &amp; EnsuredHooks} */
		(resolver.hooks);

	// resolved
	if (restrictions.size &gt; 0) {
		plugins.push(new RestrictionsPlugin(resolved, restrictions));
	}

	plugins.push(new ResultPlugin(resolved));

	// // RESOLVER ////

	for (const plugin of plugins) {
		if (typeof plugin === &quot;function&quot;) {
			/** @type {(this: Resolver, resolver: Resolver) =&gt; void} */
			(plugin).call(resolver, resolver);
		} else if (plugin) {
			plugin.apply(resolver);
		}
	}

	return resolver;
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
