<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/activitypub/notes.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/activitypub/notes.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">793</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">83.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.09</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const nconf = require(&#039;nconf&#039;);

const db = require(&#039;../mocks/databasemock&#039;);
const meta = require(&#039;../../src/meta&#039;);
const install = require(&#039;../../src/install&#039;);
const user = require(&#039;../../src/user&#039;);
const categories = require(&#039;../../src/categories&#039;);
const posts = require(&#039;../../src/posts&#039;);
const topics = require(&#039;../../src/topics&#039;);
const api = require(&#039;../../src/api&#039;);
const activitypub = require(&#039;../../src/activitypub&#039;);
const utils = require(&#039;../../src/utils&#039;);

const helpers = require(&#039;./helpers&#039;);

describe.skip(&#039;Notes&#039;, () =&gt; {
	before(async () =&gt; {
		meta.config.activitypubEnabled = 1;
		await install.giveWorldPrivileges();
	});

	describe(&#039;Assertion&#039;, () =&gt; {
		describe(&#039;Public objects&#039;, () =&gt; {
			it(&#039;should pull a remote root-level object by its id and create a new topic&#039;, async () =&gt; {
				const { id } = helpers.mocks.note();
				const assertion = await activitypub.notes.assert(0, id, { skipChecks: true });
				assert(assertion);

				const { tid, count } = assertion;
				assert(tid);
				assert.strictEqual(count, 1);

				const exists = await topics.exists(tid);
				assert(exists);
			});

			it(&#039;should assert if the cc property is missing&#039;, async () =&gt; {
				const { id } = helpers.mocks.note({ cc: &#039;remove&#039; });
				const assertion = await activitypub.notes.assert(0, id, { skipChecks: true });
				assert(assertion);

				const { tid, count } = assertion;
				assert(tid);
				assert.strictEqual(count, 1);

				const exists = await topics.exists(tid);
				assert(exists);
			});

			it(&#039;should assert if the object is of type Video&#039;, async () =&gt; {
				const { id } = helpers.mocks.note({
					type: &#039;Video&#039;,
				});
				const assertion = await activitypub.notes.assert(0, id, { skipChecks: true });
				assert(assertion);

				const { tid, count } = assertion;
				assert(tid);
				assert.strictEqual(count, 1);

				const exists = await topics.exists(tid);
				assert(exists);
			});

			describe(&#039;Category-specific behaviours&#039;, () =&gt; {
				it(&#039;should slot newly created topic in local category if addressed&#039;, async () =&gt; {
					const { cid } = await categories.create({ name: utils.generateUUID() });
					const { id } = helpers.mocks.note({
						cc: [`${nconf.get(&#039;url&#039;)}/category/${cid}`],
					});

					const assertion = await activitypub.notes.assert(0, id);
					assert(assertion);

					const { tid, count } = assertion;
					assert(tid);
					assert.strictEqual(count, 1);

					const topic = await topics.getTopicData(tid);
					assert.strictEqual(topic.cid, cid);
				});

				it(&#039;should add a remote category topic to a user\&#039;s inbox if they are following the category&#039;, async () =&gt; {
					const { id: cid, actor } = helpers.mocks.group();
					await activitypub.actors.assertGroup([cid]);

					const uid = await user.create({ username: utils.generateUUID() });
					await api.categories.setWatchState({ uid }, { cid, state: categories.watchStates.tracking });

					const { id } = helpers.mocks.note({
						cc: [cid],
					});
					const { tid } = await activitypub.notes.assert(0, id, { cid });

					const inInbox = await db.isSortedSetMember(`uid:${uid}:inbox`, tid);
					assert(inInbox);
				});
			});

			describe(&#039;User-specific behaviours&#039;, () =&gt; {
				let remoteCid;
				let uid;

				before(async () =&gt; {
					// Remote
					const { id, actor } = helpers.mocks.group();
					remoteCid = id;
					await activitypub.actors.assertGroup([id]);

					// User
					uid = await user.create({ username: utils.generateUUID() });
					await topics.markAllRead(uid);
				});

				it(&#039;should not show up in my unread if it is in cid -1&#039;, async () =&gt; {
					const { id } = helpers.mocks.note();
					const assertion = await activitypub.notes.assert(0, id, { skipChecks: 1 });
					assert(assertion);

					const unread = await topics.getTotalUnread(uid);
					assert.strictEqual(unread, 0);
				});

				it(&#039;should show up in my recent/unread if I am tracking the remote category&#039;, async () =&gt; {
					await api.categories.setWatchState({ uid }, {
						cid: remoteCid,
						state: categories.watchStates.tracking,
						uid,
					});

					const { id } = helpers.mocks.note({
						cc: [remoteCid],
					});
					const assertion = await activitypub.notes.assert(0, id, { cid: remoteCid });
					assert(assertion);

					const unread = await topics.getTotalUnread(uid);
					assert.strictEqual(unread, 1);

					await topics.markAllRead(uid);
				});

				it(&#039;should show up in recent/unread and notify me if I am watching the remote category&#039;, async () =&gt; {
					await api.categories.setWatchState({ uid }, {
						cid: remoteCid,
						state: categories.watchStates.watching,
						uid,
					});

					const { id, note } = helpers.mocks.note({
						cc: [remoteCid],
					});
					const assertion = await activitypub.notes.assert(0, id, { cid: remoteCid });
					assert(assertion);

					const unread = await topics.getTotalUnread(uid);
					assert.strictEqual(unread, 1);

					// Notification inbox delivery is async so can&#039;t test directly
					const exists = await db.exists(`notifications:new_topic:tid:${assertion.tid}:uid:${note.attributedTo}`);
					assert(exists);

					await topics.markAllRead(uid);
				});

				it(&#039;should not show up in recent/unread if I am ignoring the remote category&#039;, async () =&gt; {
					await api.categories.setWatchState({ uid }, {
						cid: remoteCid,
						state: categories.watchStates.ignoring,
						uid,
					});

					const { id, note } = helpers.mocks.note({
						cc: [remoteCid],
					});
					const assertion = await activitypub.notes.assert(0, id, { cid: remoteCid });
					assert(assertion);

					const unread = await topics.getTotalUnread(uid);
					assert.strictEqual(unread, 0);
				});
			});
		});

		describe(&#039;Private objects&#039;, () =&gt; {
			let recipientUid;

			before(async () =&gt; {
				recipientUid = await user.create({ username: utils.generateUUID().slice(0, 8) });
			});

			it(&#039;should NOT create a new topic or post when asserting a private note&#039;, async () =&gt; {
				const { id, note } = helpers.mocks.note({
					to: [`${nconf.get(&#039;url&#039;)}/uid/${recipientUid}`],
					cc: [],
				});
				const { activity } = helpers.mocks.create(note);
				const { roomId } = await activitypub.inbox.create({ body: activity });
				assert(roomId);
				assert(utils.isNumber(roomId));

				const exists = await posts.exists(id);
				assert(!exists);
			});

			it(&#039;should still assert if the cc property is missing&#039;, async () =&gt; {
				const { id, note } = helpers.mocks.note({
					to: [`${nconf.get(&#039;url&#039;)}/uid/${recipientUid}`],
					cc: &#039;remove&#039;,
				});
				const { activity } = helpers.mocks.create(note);
				const { roomId } = await activitypub.inbox.create({ body: activity });
				assert(roomId);
				assert(utils.isNumber(roomId));
			});
		});
	});

	describe(&#039;Creation&#039;, () =&gt; {
		let uid;

		before(async () =&gt; {
			uid = await user.create({ username: utils.generateUUID() });
		});

		describe(&#039;Local categories&#039;, () =&gt; {
			let cid;

			before(async () =&gt; {
				({ cid } = await categories.create({ name: utils.generateUUID() }));
				activitypub._sent.clear();
			});

			afterEach(() =&gt; {
				activitypub._sent.clear();
			});

			describe(&#039;new topics&#039;, () =&gt; {
				let activity;

				before(async () =&gt; {
					const { tid } = await api.topics.create({ uid }, {
						cid,
						title: utils.generateUUID(),
						content: utils.generateUUID(),
					});

					assert(tid);
					assert.strictEqual(activitypub._sent.size, 1);
					const key = Array.from(activitypub._sent.keys())[0];
					activity = activitypub._sent.get(key);
				});

				it(&#039;should federate out a Create activity&#039;, () =&gt; {
					assert(activity &amp;&amp; activity.to);
					assert.strictEqual(activity.type, &#039;Create&#039;);
				});

				it(&#039;should have the local category addressed&#039;, () =&gt; {
					const addressees = new Set([
						...(activity.to || []),
						...(activity.cc || []),
						...(activity.bcc || []),
						...(activity.object.to || []),
						...(activity.object.cc || []),
						...(activity.object.bcc || []),
					]);

					assert(addressees.has(`${nconf.get(&#039;url&#039;)}/category/${cid}`));
				});

				it(&#039;should federate out an activity with object of type &quot;Article&quot;&#039;, () =&gt; {
					assert(activity.object &amp;&amp; activity.object.type);
					assert.strictEqual(activity.object.type, &#039;Article&#039;);
				});
			});

			describe(&#039;new reply&#039;, () =&gt; {
				let activity;

				before(async () =&gt; {
					const { tid } = await api.topics.create({ uid }, {
						cid,
						title: utils.generateUUID(),
						content: utils.generateUUID(),
					});
					activitypub._sent.clear();

					const { pid } = await api.topics.reply({ uid }, {
						tid,
						content: utils.generateUUID(),
					});

					const key = Array.from(activitypub._sent.keys())[0];
					activity = activitypub._sent.get(key);
				});

				it(&#039;should federate out an activity with object of type &quot;Note&quot;&#039;, () =&gt; {
					assert(activity.object &amp;&amp; activity.object.type);
					assert.strictEqual(activity.object.type, &#039;Note&#039;);
				});
			});
		});

		describe(&#039;Remote Categories&#039;, () =&gt; {
			let cid;

			before(async () =&gt; {
				({ id: cid } = helpers.mocks.group());
				await activitypub.actors.assert([cid]);
			});

			afterEach(() =&gt; {
				activitypub._sent.clear();
			});

			describe(&#039;new topics&#039;, () =&gt; {
				it(&#039;should federate out a Create activity with the remote community addressed&#039;, async () =&gt; {
					const { tid } = await api.topics.create({ uid }, {
						cid,
						title: utils.generateUUID(),
						content: utils.generateUUID(),
					});

					assert(tid);
					assert.strictEqual(activitypub._sent.size, 1);

					const key = Array.from(activitypub._sent.keys())[0];
					const activity = activitypub._sent.get(key);
					assert(activity &amp;&amp; activity.to);
					assert.strictEqual(activity.type, &#039;Create&#039;);

					const addressees = new Set([
						...(activity.to || []),
						...(activity.cc || []),
						...(activity.bcc || []),
						...(activity.object.to || []),
						...(activity.object.cc || []),
						...(activity.object.bcc || []),
					]);

					assert(addressees.has(cid));
				});
			});

			describe(&#039;replies&#039;, () =&gt; {
				it(&#039;should federate out a Create activity with the remote community addressed&#039;, async () =&gt; {
					const { tid } = await api.topics.create({ uid }, {
						cid,
						title: utils.generateUUID(),
						content: utils.generateUUID(),
					});

					activitypub._sent.clear();

					const postData = await api.topics.reply({ uid }, {
						tid,
						content: utils.generateUUID(),
					});

					assert(postData);
					assert.strictEqual(activitypub._sent.size, 1);

					const key = Array.from(activitypub._sent.keys())[0];
					const activity = activitypub._sent.get(key);
					assert(activity &amp;&amp; activity.to);
					assert.strictEqual(activity.type, &#039;Create&#039;);

					const addressees = new Set([
						...(activity.to || []),
						...(activity.cc || []),
						...(activity.bcc || []),
						...(activity.object.to || []),
						...(activity.object.cc || []),
						...(activity.object.bcc || []),
					]);

					assert(addressees.has(cid));
				});
			});
		});
	});

	describe(&#039;Inbox handling&#039;, () =&gt; {
		describe(&#039;helper self-check&#039;, () =&gt; {
			it(&#039;should generate a Like activity&#039;, () =&gt; {
				const object = utils.generateUUID();
				const { id: actor } = helpers.mocks.person();
				const { activity } = helpers.mocks.like({
					object,
					actor,
				});

				assert.deepStrictEqual(activity, {
					&#039;@context&#039;: &#039;https://www.w3.org/ns/activitystreams&#039;,
					id: `${helpers.mocks._baseUrl}/like/${encodeURIComponent(object)}`,
					type: &#039;Like&#039;,
					actor,
					object,
				});
			});

			it(&#039;should generate an Announce activity wrapping a Like activity&#039;, () =&gt; {
				const object = utils.generateUUID();
				const { id: actor } = helpers.mocks.person();
				const { activity: like } = helpers.mocks.like({
					object,
					actor,
				});
				const { id: gActor } = helpers.mocks.group();
				const { activity } = helpers.mocks.announce({
					actor: gActor,
					object: like,
				});

				assert.deepStrictEqual(activity, {
					&#039;@context&#039;: &#039;https://www.w3.org/ns/activitystreams&#039;,
					id: `${helpers.mocks._baseUrl}/announce/${encodeURIComponent(like.id)}`,
					type: &#039;Announce&#039;,
					to: [ &#039;https://www.w3.org/ns/activitystreams#Public&#039; ],
					cc: [
						`${gActor}/followers`,
					],
					actor: gActor,
					object: like,
				});
			});
		});

		describe(&#039;Create&#039;, () =&gt; {
			let uid;

			before(async () =&gt; {
				uid = await user.create({ username: utils.generateUUID() });
			});

			describe(&#039;(Note)&#039;, () =&gt; {
				it(&#039;should create a new topic in cid -1&#039;, async () =&gt; {
					const { note, id } = helpers.mocks.note();
					const { activity } = helpers.mocks.create(note);

					await db.sortedSetAdd(`followersRemote:${note.attributedTo}`, Date.now(), uid);
					await activitypub.inbox.create({ body: activity });

					assert(await posts.exists(id));

					const cid = await posts.getCidByPid(id);
					assert.strictEqual(cid, -1);
				});

				it(&#039;should create a new topic in a remote category if addressed (category same-origin)&#039;, async () =&gt; {
					const { id: remoteCid } = helpers.mocks.group();
					const { note, id } = helpers.mocks.note({
						audience: [remoteCid],
					});
					const { activity } = helpers.mocks.create(note);

					await activitypub.inbox.create({ body: activity });

					assert(await posts.exists(id));

					const cid = await posts.getCidByPid(id);
					assert.strictEqual(cid, remoteCid);
				});

				it(&#039;should create a new topic in cid -1 if a non-same origin remote category is addressed&#039;, async function () {
					this.timeout(60000);
					const { id: remoteCid } = helpers.mocks.group({
						id: `https://example.com/${utils.generateUUID()}`,
					});
					const { note, id } = helpers.mocks.note({
						audience: [remoteCid],
					});
					const { activity } = helpers.mocks.create(note);

					await activitypub.inbox.create({ body: activity });

					assert(await posts.exists(id));

					const cid = await posts.getCidByPid(id);
					assert.strictEqual(cid, -1);
				});
			});
		});

		describe(&#039;Announce&#039;, () =&gt; {
			let cid;

			before(async () =&gt; {
				({ cid } = await categories.create({ name: utils.generateUUID().slice(0, 8) }));
			});

			describe(&#039;(Create)&#039;, () =&gt; {
				it(&#039;should create a new topic in a remote category if addressed&#039;, async () =&gt; {
					const { id: remoteCid } = helpers.mocks.group();
					const { id, note } = helpers.mocks.note({
						audience: [remoteCid],
					});
					let { activity } = helpers.mocks.create(note);
					({ activity } = helpers.mocks.announce({ actor: remoteCid, object: activity }));

					await activitypub.inbox.announce({ body: activity });

					assert(await posts.exists(id));

					const cid = await posts.getCidByPid(id);
					assert.strictEqual(cid, remoteCid);
				});
			});

			describe(&#039;(Create) or (Note) referencing local post&#039;, () =&gt; {
				let uid;
				let topicData;
				let postData;
				let localNote;
				let announces = 0;

				before(async () =&gt; {
					uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
					({ topicData, postData } = await topics.post({
						cid,
						uid,
						title: utils.generateUUID(),
						content: utils.generateUUID(),
					}));
					localNote = await activitypub.mocks.notes.public(postData);
				});

				it(&#039;should increment announces counter when a remote user shares&#039;, async () =&gt; {
					const { id } = helpers.mocks.person();
					const { activity } = helpers.mocks.announce({
						actor: id,
						object: localNote,
						cc: [`${nconf.get(&#039;url&#039;)}/uid/${topicData.uid}`],
					});

					await activitypub.inbox.announce({ body: activity });
					announces += 1;

					const count = await posts.getPostField(topicData.mainPid, &#039;announces&#039;);
					assert.strictEqual(count, announces);
				});

				it(&#039;should contain the remote user announcer id in the post announces zset&#039;, async () =&gt; {
					const { id } = helpers.mocks.person();
					const { activity } = helpers.mocks.announce({
						actor: id,
						object: localNote,
						cc: [`${nconf.get(&#039;url&#039;)}/uid/${topicData.uid}`],
					});

					await activitypub.inbox.announce({ body: activity });
					announces += 1;

					const exists = await db.isSortedSetMember(`pid:${topicData.mainPid}:announces`, id);
					assert(exists);
				});

				it(&#039;should NOT increment announces counter when a remote category shares&#039;, async () =&gt; {
					const { id } = helpers.mocks.group();
					const { activity } = helpers.mocks.announce({
						actor: id,
						object: localNote,
						cc: [`${nconf.get(&#039;url&#039;)}/uid/${topicData.uid}`],
					});

					await activitypub.inbox.announce({ body: activity });

					const count = await posts.getPostField(topicData.mainPid, &#039;announces&#039;);
					assert.strictEqual(count, announces);
				});

				it(&#039;should NOT contain the remote category announcer id in the post announces zset&#039;, async () =&gt; {
					const { id } = helpers.mocks.group();
					const { activity } = helpers.mocks.announce({
						actor: id,
						object: localNote,
						cc: [`${nconf.get(&#039;url&#039;)}/uid/${topicData.uid}`],
					});

					await activitypub.inbox.announce({ body: activity });

					const exists = await db.isSortedSetMember(`pid:${topicData.mainPid}:announces`, id);
					assert(!exists);
				});
			});

			describe(&#039;(Note)&#039;, () =&gt; {
				it(&#039;should create a new topic in cid -1 if category not addressed&#039;, async () =&gt; {
					const { note } = helpers.mocks.note();
					await activitypub.actors.assert([note.attributedTo]);
					const { activity } = helpers.mocks.announce({
						object: note,
					});
					const uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
					await db.sortedSetAdd(`followersRemote:${activity.actor}`, Date.now(), uid);

					const beforeCount = await db.sortedSetCard(`cid:-1:tids`);
					await activitypub.inbox.announce({ body: activity });
					const count = await db.sortedSetCard(`cid:-1:tids`);

					assert.strictEqual(count, beforeCount + 1);
				});

				it(&#039;should create a new topic in local category&#039;, async () =&gt; {
					const { note } = helpers.mocks.note({
						cc: [`${nconf.get(&#039;url&#039;)}/category/${cid}`],
					});
					await activitypub.actors.assert([note.attributedTo]);
					const { activity } = helpers.mocks.announce({
						object: note,
					});
					const uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
					await db.sortedSetAdd(`followersRemote:${activity.actor}`, Date.now(), uid);

					const beforeCount = await db.sortedSetCard(`cid:${cid}:tids`);
					await activitypub.inbox.announce({ body: activity });
					const count = await db.sortedSetCard(`cid:${cid}:tids`);

					assert.strictEqual(count, beforeCount + 1);
				});
			});

			describe(&#039;(Like)&#039;, () =&gt; {
				it(&#039;should upvote a local post&#039;, async () =&gt; {
					const uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
					const { postData } = await topics.post({
						cid,
						uid,
						title: utils.generateUUID(),
						content: utils.generateUUID(),
					});

					const { activity: like } = helpers.mocks.like({
						object: `${nconf.get(&#039;url&#039;)}/post/${postData.pid}`,
					});
					const { activity } = helpers.mocks.announce({
						object: like,
					});

					let { upvotes } = await posts.getPostFields(postData.pid, &#039;upvotes&#039;);
					assert.strictEqual(upvotes, 0);

					await activitypub.inbox.announce({ body: activity });
					({ upvotes } = await posts.getPostFields(postData.pid, &#039;upvotes&#039;));
					assert.strictEqual(upvotes, 1);
				});

				it(&#039;should upvote an asserted remote post&#039;, async () =&gt; {
					const { id } = helpers.mocks.note();
					await activitypub.notes.assert(0, [id], { skipChecks: true });
					const { activity: like } = helpers.mocks.like({
						object: id,
					});
					const { activity } = helpers.mocks.announce({
						object: like,
					});

					let { upvotes } = await posts.getPostFields(id, &#039;upvotes&#039;);
					assert.strictEqual(upvotes, 0);

					await activitypub.inbox.announce({ body: activity });

					({ upvotes } = await posts.getPostFields(id, &#039;upvotes&#039;));
					assert.strictEqual(upvotes, 1);
				});
			});

			describe(&#039;(Update)&#039;, () =&gt; {
				it(&#039;should update a note\&#039;s content&#039;, async () =&gt; {
					const { id: actor } = helpers.mocks.person();
					const { id, note } = helpers.mocks.note({ attributedTo: actor });
					await activitypub.notes.assert(0, [id], { skipChecks: true });
					note.content = utils.generateUUID();
					const { activity: update } = helpers.mocks.update({ object: note });
					const { activity } = helpers.mocks.announce({ object: update });

					await activitypub.inbox.announce({ body: activity });

					const content = await posts.getPostField(id, &#039;content&#039;);
					assert.strictEqual(content, note.content);
				});
			});
		});
	});

	describe(&#039;Inbox Synchronization&#039;, () =&gt; {
		let cid;
		let uid;
		let topicData;

		before(async () =&gt; {
			({ cid } = await categories.create({ name: utils.generateUUID().slice(0, 8) }));
		});

		beforeEach(async () =&gt; {
			uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
			({ topicData } = await topics.post({
				cid,
				uid,
				title: utils.generateUUID(),
				content: utils.generateUUID(),
			}));
		});

		it(&#039;should add a topic to a user\&#039;s inbox if user is a recipient in OP&#039;, async () =&gt; {
			await db.setAdd(`post:${topicData.mainPid}:recipients`, [uid]);
			await activitypub.notes.syncUserInboxes(topicData.tid);
			const inboxed = await db.isSortedSetMember(`uid:${uid}:inbox`, topicData.tid);

			assert.strictEqual(inboxed, true);
		});

		it(&#039;should add a topic to a user\&#039;s inbox if a user is a recipient in a reply&#039;, async () =&gt; {
			const uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
			const { pid } = await topics.reply({
				tid: topicData.tid,
				uid,
				content: utils.generateUUID(),
			});
			await db.setAdd(`post:${pid}:recipients`, [uid]);
			await activitypub.notes.syncUserInboxes(topicData.tid);
			const inboxed = await db.isSortedSetMember(`uid:${uid}:inbox`, topicData.tid);

			assert.strictEqual(inboxed, true);
		});

		it(&#039;should maintain a list of recipients at the topic level&#039;, async () =&gt; {
			await db.setAdd(`post:${topicData.mainPid}:recipients`, [uid]);
			await activitypub.notes.syncUserInboxes(topicData.tid);
			const [isRecipient, count] = await Promise.all([
				db.isSetMember(`tid:${topicData.tid}:recipients`, uid),
				db.setCount(`tid:${topicData.tid}:recipients`),
			]);

			assert(isRecipient);
			assert.strictEqual(count, 1);
		});

		it(&#039;should add topic to a user\&#039;s inbox if it is explicitly passed in as an argument&#039;, async () =&gt; {
			await activitypub.notes.syncUserInboxes(topicData.tid, uid);
			const inboxed = await db.isSortedSetMember(`uid:${uid}:inbox`, topicData.tid);

			assert.strictEqual(inboxed, true);
		});

		it(&#039;should remove a topic from a user\&#039;s inbox if that user is no longer a recipient in any contained posts&#039;, async () =&gt; {
			await activitypub.notes.syncUserInboxes(topicData.tid, uid);
			await activitypub.notes.syncUserInboxes(topicData.tid);
			const inboxed = await db.isSortedSetMember(`uid:${uid}:inbox`, topicData.tid);

			assert.strictEqual(inboxed, false);
		});
	});

	describe(&#039;Deletion&#039;, () =&gt; {
		let cid;
		let uid;
		let topicData;

		before(async () =&gt; {
			({ cid } = await categories.create({ name: utils.generateUUID().slice(0, 8) }));
		});

		beforeEach(async () =&gt; {
			uid = await user.create({ username: utils.generateUUID().slice(0, 10) });
			({ topicData } = await topics.post({
				cid,
				uid,
				title: utils.generateUUID(),
				content: utils.generateUUID(),
			}));
		});

		it(&#039;should clean up recipient sets for the post&#039;, async () =&gt; {
			const { pid } = await topics.reply({
				pid: `https://example.org/${utils.generateUUID().slice(0, 8)}`,
				tid: topicData.tid,
				uid,
				content: utils.generateUUID(),
			});
			await db.setAdd(`post:${pid}:recipients`, [uid]);
			await activitypub.notes.delete([pid]);

			const inboxed = await db.isSetMember(`post:${pid}:recipients`, uid);
			assert(!inboxed);
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
