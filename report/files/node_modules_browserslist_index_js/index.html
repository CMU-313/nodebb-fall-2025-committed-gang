<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/browserslist/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/browserslist/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1324</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">128.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">15.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var bbm = require(&#039;baseline-browser-mapping&#039;)
var jsReleases = require(&#039;node-releases/data/processed/envs.json&#039;)
var agents = require(&#039;caniuse-lite/dist/unpacker/agents&#039;).agents
var e2c = require(&#039;electron-to-chromium/versions&#039;)
var jsEOL = require(&#039;node-releases/data/release-schedule/release-schedule.json&#039;)
var path = require(&#039;path&#039;)

var BrowserslistError = require(&#039;./error&#039;)
var env = require(&#039;./node&#039;)
var parseWithoutCache = require(&#039;./parse&#039;) // Will load browser.js in webpack

var YEAR = 365.259641 * 24 * 60 * 60 * 1000
var ANDROID_EVERGREEN_FIRST = &#039;37&#039;
var OP_MOB_BLINK_FIRST = 14

// Helpers

function isVersionsMatch(versionA, versionB) {
  return (versionA + &#039;.&#039;).indexOf(versionB + &#039;.&#039;) === 0
}

function isEolReleased(name) {
  var version = name.slice(1)
  return browserslist.nodeVersions.some(function (i) {
    return isVersionsMatch(i, version)
  })
}

function normalize(versions) {
  return versions.filter(function (version) {
    return typeof version === &#039;string&#039;
  })
}

function normalizeElectron(version) {
  var versionToUse = version
  if (version.split(&#039;.&#039;).length === 3) {
    versionToUse = version.split(&#039;.&#039;).slice(0, -1).join(&#039;.&#039;)
  }
  return versionToUse
}

function nameMapper(name) {
  return function mapName(version) {
    return name + &#039; &#039; + version
  }
}

function getMajor(version) {
  return parseInt(version.split(&#039;.&#039;)[0])
}

function getMajorVersions(released, number) {
  if (released.length === 0) return []
  var majorVersions = uniq(released.map(getMajor))
  var minimum = majorVersions[majorVersions.length - number]
  if (!minimum) {
    return released
  }
  var selected = []
  for (var i = released.length - 1; i &gt;= 0; i--) {
    if (minimum &gt; getMajor(released[i])) break
    selected.unshift(released[i])
  }
  return selected
}

function uniq(array) {
  var filtered = []
  for (var i = 0; i &lt; array.length; i++) {
    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])
  }
  return filtered
}

function fillUsage(result, name, data) {
  for (var i in data) {
    result[name + &#039; &#039; + i] = data[i]
  }
}

function generateFilter(sign, version) {
  version = parseFloat(version)
  if (sign === &#039;&gt;&#039;) {
    return function (v) {
      return parseLatestFloat(v) &gt; version
    }
  } else if (sign === &#039;&gt;=&#039;) {
    return function (v) {
      return parseLatestFloat(v) &gt;= version
    }
  } else if (sign === &#039;&lt;&#039;) {
    return function (v) {
      return parseFloat(v) &lt; version
    }
  } else {
    return function (v) {
      return parseFloat(v) &lt;= version
    }
  }

  function parseLatestFloat(v) {
    return parseFloat(v.split(&#039;-&#039;)[1] || v)
  }
}

function generateSemverFilter(sign, version) {
  version = version.split(&#039;.&#039;).map(parseSimpleInt)
  version[1] = version[1] || 0
  version[2] = version[2] || 0
  if (sign === &#039;&gt;&#039;) {
    return function (v) {
      v = v.split(&#039;.&#039;).map(parseSimpleInt)
      return compareSemver(v, version) &gt; 0
    }
  } else if (sign === &#039;&gt;=&#039;) {
    return function (v) {
      v = v.split(&#039;.&#039;).map(parseSimpleInt)
      return compareSemver(v, version) &gt;= 0
    }
  } else if (sign === &#039;&lt;&#039;) {
    return function (v) {
      v = v.split(&#039;.&#039;).map(parseSimpleInt)
      return compareSemver(version, v) &gt; 0
    }
  } else {
    return function (v) {
      v = v.split(&#039;.&#039;).map(parseSimpleInt)
      return compareSemver(version, v) &gt;= 0
    }
  }
}

function parseSimpleInt(x) {
  return parseInt(x)
}

function compare(a, b) {
  if (a &lt; b) return -1
  if (a &gt; b) return +1
  return 0
}

function compareSemver(a, b) {
  return (
    compare(parseInt(a[0]), parseInt(b[0])) ||
    compare(parseInt(a[1] || &#039;0&#039;), parseInt(b[1] || &#039;0&#039;)) ||
    compare(parseInt(a[2] || &#039;0&#039;), parseInt(b[2] || &#039;0&#039;))
  )
}

// this follows the npm-like semver behavior
function semverFilterLoose(operator, range) {
  range = range.split(&#039;.&#039;).map(parseSimpleInt)
  if (typeof range[1] === &#039;undefined&#039;) {
    range[1] = &#039;x&#039;
  }
  // ignore any patch version because we only return minor versions
  // range[2] = &#039;x&#039;
  switch (operator) {
    case &#039;&lt;=&#039;:
      return function (version) {
        version = version.split(&#039;.&#039;).map(parseSimpleInt)
        return compareSemverLoose(version, range) &lt;= 0
      }
    case &#039;&gt;=&#039;:
    default:
      return function (version) {
        version = version.split(&#039;.&#039;).map(parseSimpleInt)
        return compareSemverLoose(version, range) &gt;= 0
      }
  }
}

// this follows the npm-like semver behavior
function compareSemverLoose(version, range) {
  if (version[0] !== range[0]) {
    return version[0] &lt; range[0] ? -1 : +1
  }
  if (range[1] === &#039;x&#039;) {
    return 0
  }
  if (version[1] !== range[1]) {
    return version[1] &lt; range[1] ? -1 : +1
  }
  return 0
}

function resolveVersion(data, version) {
  if (data.versions.indexOf(version) !== -1) {
    return version
  } else if (browserslist.versionAliases[data.name][version]) {
    return browserslist.versionAliases[data.name][version]
  } else {
    return false
  }
}

function normalizeVersion(data, version) {
  var resolved = resolveVersion(data, version)
  if (resolved) {
    return resolved
  } else if (data.versions.length === 1) {
    return data.versions[0]
  } else {
    return false
  }
}

function filterByYear(since, context) {
  since = since / 1000
  return Object.keys(agents).reduce(function (selected, name) {
    var data = byName(name, context)
    if (!data) return selected
    var versions = Object.keys(data.releaseDate).filter(function (v) {
      var date = data.releaseDate[v]
      return date !== null &amp;&amp; date &gt;= since
    })
    return selected.concat(versions.map(nameMapper(data.name)))
  }, [])
}

function cloneData(data) {
  return {
    name: data.name,
    versions: data.versions,
    released: data.released,
    releaseDate: data.releaseDate
  }
}

function byName(name, context) {
  name = name.toLowerCase()
  name = browserslist.aliases[name] || name
  if (context.mobileToDesktop &amp;&amp; browserslist.desktopNames[name]) {
    var desktop = browserslist.data[browserslist.desktopNames[name]]
    if (name === &#039;android&#039;) {
      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)
    } else {
      var cloned = cloneData(desktop)
      cloned.name = name
      return cloned
    }
  }
  return browserslist.data[name]
}

function normalizeAndroidVersions(androidVersions, chromeVersions) {
  var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST)
  return androidVersions
    .filter(function (version) {
      return /^(?:[2-4]\.|[34]$)/.test(version)
    })
    .concat(chromeVersions.slice(iFirstEvergreen))
}

function copyObject(obj) {
  var copy = {}
  for (var key in obj) {
    copy[key] = obj[key]
  }
  return copy
}

function normalizeAndroidData(android, chrome) {
  android.released = normalizeAndroidVersions(android.released, chrome.released)
  android.versions = normalizeAndroidVersions(android.versions, chrome.versions)
  android.releaseDate = copyObject(android.releaseDate)
  android.released.forEach(function (v) {
    if (android.releaseDate[v] === undefined) {
      android.releaseDate[v] = chrome.releaseDate[v]
    }
  })
  return android
}

function checkName(name, context) {
  var data = byName(name, context)
  if (!data) throw new BrowserslistError(&#039;Unknown browser &#039; + name)
  return data
}

function unknownQuery(query) {
  return new BrowserslistError(
    &#039;Unknown browser query `&#039; +
      query +
      &#039;`. &#039; +
      &#039;Maybe you are using old Browserslist or made typo in query.&#039;
  )
}

// Adjusts last X versions queries for some mobile browsers,
// where caniuse data jumps from a legacy version to the latest
function filterJumps(list, name, nVersions, context) {
  var jump = 1
  switch (name) {
    case &#039;android&#039;:
      if (context.mobileToDesktop) return list
      var released = browserslist.data.chrome.released
      jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST)
      break
    case &#039;op_mob&#039;:
      var latest = browserslist.data.op_mob.released.slice(-1)[0]
      jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1
      break
    default:
      return list
  }
  if (nVersions &lt;= jump) {
    return list.slice(-1)
  }
  return list.slice(jump - 1 - nVersions)
}

function isSupported(flags, withPartial) {
  return (
    typeof flags === &#039;string&#039; &amp;&amp;
    (flags.indexOf(&#039;y&#039;) &gt;= 0 || (withPartial &amp;&amp; flags.indexOf(&#039;a&#039;) &gt;= 0))
  )
}

function resolve(queries, context) {
  return parseQueries(queries).reduce(function (result, node, index) {
    if (node.not &amp;&amp; index === 0) {
      throw new BrowserslistError(
        &#039;Write any browsers query (for instance, `defaults`) &#039; +
          &#039;before `&#039; +
          node.query +
          &#039;`&#039;
      )
    }
    var type = QUERIES[node.type]
    var array = type.select.call(browserslist, context, node).map(function (j) {
      var parts = j.split(&#039; &#039;)
      if (parts[1] === &#039;0&#039;) {
        return parts[0] + &#039; &#039; + byName(parts[0], context).versions[0]
      } else {
        return j
      }
    })

    if (node.compose === &#039;and&#039;) {
      if (node.not) {
        return result.filter(function (j) {
          return array.indexOf(j) === -1
        })
      } else {
        return result.filter(function (j) {
          return array.indexOf(j) !== -1
        })
      }
    } else {
      if (node.not) {
        var filter = {}
        array.forEach(function (j) {
          filter[j] = true
        })
        return result.filter(function (j) {
          return !filter[j]
        })
      }
      return result.concat(array)
    }
  }, [])
}

function prepareOpts(opts) {
  if (typeof opts === &#039;undefined&#039;) opts = {}

  if (typeof opts.path === &#039;undefined&#039;) {
    opts.path = path.resolve ? path.resolve(&#039;.&#039;) : &#039;.&#039;
  }

  return opts
}

function prepareQueries(queries, opts) {
  if (typeof queries === &#039;undefined&#039; || queries === null) {
    var config = browserslist.loadConfig(opts)
    if (config) {
      queries = config
    } else {
      queries = browserslist.defaults
    }
  }

  return queries
}

function checkQueries(queries) {
  if (!(typeof queries === &#039;string&#039; || Array.isArray(queries))) {
    throw new BrowserslistError(
      &#039;Browser queries must be an array or string. Got &#039; + typeof queries + &#039;.&#039;
    )
  }
}

var cache = {}
var parseCache = {}

function browserslist(queries, opts) {
  opts = prepareOpts(opts)
  queries = prepareQueries(queries, opts)
  checkQueries(queries)

  var needsPath = parseQueries(queries).some(function (node) {
    return QUERIES[node.type].needsPath
  })
  var context = {
    ignoreUnknownVersions: opts.ignoreUnknownVersions,
    dangerousExtend: opts.dangerousExtend,
    throwOnMissing: opts.throwOnMissing,
    mobileToDesktop: opts.mobileToDesktop,
    env: opts.env
  }
  // Removing to avoid using context.path without marking query as needsPath
  if (needsPath) {
    context.path = opts.path
  }

  env.oldDataWarning(browserslist.data)
  var stats = env.getStat(opts, browserslist.data)
  if (stats) {
    context.customUsage = {}
    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser])
    }
  }

  var cacheKey = JSON.stringify([queries, context])
  if (cache[cacheKey]) return cache[cacheKey]

  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {
    name1 = name1.split(&#039; &#039;)
    name2 = name2.split(&#039; &#039;)
    if (name1[0] === name2[0]) {
      // assumptions on caniuse data
      // 1) version ranges never overlaps
      // 2) if version is not a range, it never contains `-`
      var version1 = name1[1].split(&#039;-&#039;)[0]
      var version2 = name2[1].split(&#039;-&#039;)[0]
      return compareSemver(version2.split(&#039;.&#039;), version1.split(&#039;.&#039;))
    } else {
      return compare(name1[0], name2[0])
    }
  })
  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
    cache[cacheKey] = result
  }
  return result
}

function parseQueries(queries) {
  var cacheKey = JSON.stringify(queries)
  if (cacheKey in parseCache) return parseCache[cacheKey]
  var result = parseWithoutCache(QUERIES, queries)
  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
    parseCache[cacheKey] = result
  }
  return result
}

function loadCustomUsage(context, config) {
  var stats = env.loadStat(context, config, browserslist.data)
  if (stats) {
    context.customUsage = {}
    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser])
    }
  }
  if (!context.customUsage) {
    throw new BrowserslistError(&#039;Custom usage statistics was not provided&#039;)
  }
  return context.customUsage
}

browserslist.parse = function (queries, opts) {
  opts = prepareOpts(opts)
  queries = prepareQueries(queries, opts)
  checkQueries(queries)
  return parseQueries(queries)
}

// Will be filled by Can I Use data below
browserslist.cache = {}
browserslist.data = {}
browserslist.usage = {
  global: {},
  custom: null
}

// Default browsers query
browserslist.defaults = [&#039;&gt; 0.5%&#039;, &#039;last 2 versions&#039;, &#039;Firefox ESR&#039;, &#039;not dead&#039;]

// Browser names aliases
browserslist.aliases = {
  fx: &#039;firefox&#039;,
  ff: &#039;firefox&#039;,
  ios: &#039;ios_saf&#039;,
  explorer: &#039;ie&#039;,
  blackberry: &#039;bb&#039;,
  explorermobile: &#039;ie_mob&#039;,
  operamini: &#039;op_mini&#039;,
  operamobile: &#039;op_mob&#039;,
  chromeandroid: &#039;and_chr&#039;,
  firefoxandroid: &#039;and_ff&#039;,
  ucandroid: &#039;and_uc&#039;,
  qqandroid: &#039;and_qq&#039;
}

// Can I Use only provides a few versions for some browsers (e.g. and_chr).
// Fallback to a similar browser for unknown versions
// Note op_mob is not included as its chromium versions are not in sync with Opera desktop
browserslist.desktopNames = {
  and_chr: &#039;chrome&#039;,
  and_ff: &#039;firefox&#039;,
  ie_mob: &#039;ie&#039;,
  android: &#039;chrome&#039; // has extra processing logic
}

// Aliases to work with joined versions like `ios_saf 7.0-7.1`
browserslist.versionAliases = {}

browserslist.clearCaches = env.clearCaches
browserslist.parseConfig = env.parseConfig
browserslist.readConfig = env.readConfig
browserslist.findConfigFile = env.findConfigFile
browserslist.findConfig = env.findConfig
browserslist.loadConfig = env.loadConfig

browserslist.coverage = function (browsers, stats) {
  var data
  if (typeof stats === &#039;undefined&#039;) {
    data = browserslist.usage.global
  } else if (stats === &#039;my stats&#039;) {
    var opts = {}
    opts.path = path.resolve ? path.resolve(&#039;.&#039;) : &#039;.&#039;
    var customStats = env.getStat(opts)
    if (!customStats) {
      throw new BrowserslistError(&#039;Custom usage statistics was not provided&#039;)
    }
    data = {}
    for (var browser in customStats) {
      fillUsage(data, browser, customStats[browser])
    }
  } else if (typeof stats === &#039;string&#039;) {
    if (stats.length &gt; 2) {
      stats = stats.toLowerCase()
    } else {
      stats = stats.toUpperCase()
    }
    env.loadCountry(browserslist.usage, stats, browserslist.data)
    data = browserslist.usage[stats]
  } else {
    if (&#039;dataByBrowser&#039; in stats) {
      stats = stats.dataByBrowser
    }
    data = {}
    for (var name in stats) {
      for (var version in stats[name]) {
        data[name + &#039; &#039; + version] = stats[name][version]
      }
    }
  }

  return browsers.reduce(function (all, i) {
    var usage = data[i]
    if (usage === undefined) {
      usage = data[i.replace(/ \S+$/, &#039; 0&#039;)]
    }
    return all + (usage || 0)
  }, 0)
}

function nodeQuery(context, node) {
  var matched = browserslist.nodeVersions.filter(function (i) {
    return isVersionsMatch(i, node.version)
  })
  if (matched.length === 0) {
    if (context.ignoreUnknownVersions) {
      return []
    } else {
      throw new BrowserslistError(
        &#039;Unknown version &#039; + node.version + &#039; of Node.js&#039;
      )
    }
  }
  return [&#039;node &#039; + matched[matched.length - 1]]
}

function sinceQuery(context, node) {
  var year = parseInt(node.year)
  var month = parseInt(node.month || &#039;01&#039;) - 1
  var day = parseInt(node.day || &#039;01&#039;)
  return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context)
}

function bbmTransform(bbmVersions) {
  var browsers = {
    chrome: &#039;chrome&#039;,
    chrome_android: &#039;and_chr&#039;,
    edge: &#039;edge&#039;,
    firefox: &#039;firefox&#039;,
    firefox_android: &#039;and_ff&#039;,
    safari: &#039;safari&#039;,
    safari_ios: &#039;ios_saf&#039;,
    webview_android: &#039;android&#039;,
    samsunginternet_android: &#039;samsung&#039;,
    opera_android: &#039;op_mob&#039;,
    opera: &#039;opera&#039;,
    qq_android: &#039;and_qq&#039;,
    uc_android: &#039;and_uc&#039;,
    kai_os: &#039;kaios&#039;
  }

  return bbmVersions
    .filter(function (version) {
      return Object.keys(browsers).indexOf(version.browser) !== -1
    })
    .map(function (version) {
      return browsers[version.browser] + &#039; &gt;= &#039; + version.version
    })
}

function coverQuery(context, node) {
  var coverage = parseFloat(node.coverage)
  var usage = browserslist.usage.global
  if (node.place) {
    if (node.place.match(/^my\s+stats$/i)) {
      if (!context.customUsage) {
        throw new BrowserslistError(&#039;Custom usage statistics was not provided&#039;)
      }
      usage = context.customUsage
    } else {
      var place
      if (node.place.length === 2) {
        place = node.place.toUpperCase()
      } else {
        place = node.place.toLowerCase()
      }
      env.loadCountry(browserslist.usage, place, browserslist.data)
      usage = browserslist.usage[place]
    }
  } else if (node.config) {
    usage = loadCustomUsage(context, node.config)
  }
  var versions = Object.keys(usage).sort(function (a, b) {
    return usage[b] - usage[a]
  })
  var covered = 0
  var result = []
  var version
  for (var i = 0; i &lt; versions.length; i++) {
    version = versions[i]
    if (usage[version] === 0) break
    covered += usage[version]
    result.push(version)
    if (covered &gt;= coverage) break
  }
  return result
}

var QUERIES = {
  last_major_versions: {
    matches: [&#039;versions&#039;],
    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
    select: function (context, node) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = getMajorVersions(data.released, node.versions)
        list = list.map(nameMapper(data.name))
        list = filterJumps(list, data.name, node.versions, context)
        return selected.concat(list)
      }, [])
    }
  },
  last_versions: {
    matches: [&#039;versions&#039;],
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function (context, node) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = data.released.slice(-node.versions)
        list = list.map(nameMapper(data.name))
        list = filterJumps(list, data.name, node.versions, context)
        return selected.concat(list)
      }, [])
    }
  },
  last_electron_major_versions: {
    matches: [&#039;versions&#039;],
    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
    select: function (context, node) {
      var validVersions = getMajorVersions(Object.keys(e2c), node.versions)
      return validVersions.map(function (i) {
        return &#039;chrome &#039; + e2c[i]
      })
    }
  },
  last_node_major_versions: {
    matches: [&#039;versions&#039;],
    regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
    select: function (context, node) {
      return getMajorVersions(browserslist.nodeVersions, node.versions).map(
        function (version) {
          return &#039;node &#039; + version
        }
      )
    }
  },
  last_browser_major_versions: {
    matches: [&#039;versions&#039;, &#039;browser&#039;],
    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      var validVersions = getMajorVersions(data.released, node.versions)
      var list = validVersions.map(nameMapper(data.name))
      list = filterJumps(list, data.name, node.versions, context)
      return list
    }
  },
  last_electron_versions: {
    matches: [&#039;versions&#039;],
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function (context, node) {
      return Object.keys(e2c)
        .slice(-node.versions)
        .map(function (i) {
          return &#039;chrome &#039; + e2c[i]
        })
    }
  },
  last_node_versions: {
    matches: [&#039;versions&#039;],
    regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
    select: function (context, node) {
      return browserslist.nodeVersions
        .slice(-node.versions)
        .map(function (version) {
          return &#039;node &#039; + version
        })
    }
  },
  last_browser_versions: {
    matches: [&#039;versions&#039;, &#039;browser&#039;],
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      var list = data.released.slice(-node.versions).map(nameMapper(data.name))
      list = filterJumps(list, data.name, node.versions, context)
      return list
    }
  },
  unreleased_versions: {
    matches: [],
    regexp: /^unreleased\s+versions$/i,
    select: function (context) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1
        })
        list = list.map(nameMapper(data.name))
        return selected.concat(list)
      }, [])
    }
  },
  unreleased_electron_versions: {
    matches: [],
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function () {
      return []
    }
  },
  unreleased_browser_versions: {
    matches: [&#039;browser&#039;],
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      return data.versions
        .filter(function (v) {
          return data.released.indexOf(v) === -1
        })
        .map(nameMapper(data.name))
    }
  },
  last_years: {
    matches: [&#039;years&#039;],
    regexp: /^last\s+((\d+\.)?\d+)\s+years?$/i,
    select: function (context, node) {
      return filterByYear(Date.now() - YEAR * node.years, context)
    }
  },
  since_y: {
    matches: [&#039;year&#039;],
    regexp: /^since (\d+)$/i,
    select: sinceQuery
  },
  since_y_m: {
    matches: [&#039;year&#039;, &#039;month&#039;],
    regexp: /^since (\d+)-(\d+)$/i,
    select: sinceQuery
  },
  since_y_m_d: {
    matches: [&#039;year&#039;, &#039;month&#039;, &#039;day&#039;],
    regexp: /^since (\d+)-(\d+)-(\d+)$/i,
    select: sinceQuery
  },
  baseline: {
    matches: [&#039;year&#039;, &#039;availability&#039;, &#039;date&#039;, &#039;downstream&#039;, &#039;kaios&#039;],
    // Matches:
    //   baseline 2024
    //   baseline newly available
    //   baseline widely available
    //   baseline widely available on 2024-06-01
    //   ...with downstream
    //   ...including kaios
    regexp:
      /^baseline\s+(?:(\d+)|(newly|widely)\s+available(?:\s+on\s+(\d{4}-\d{2}-\d{2}))?)?(\s+with\s+downstream)?(\s+including\s+kaios)?$/i,
    select: function (context, node) {
      var baselineVersions
      var includeDownstream = !!node.downstream
      var includeKaiOS = !!node.kaios
      if (node.availability === &#039;newly&#039; &amp;&amp; node.date) {
        throw new BrowserslistError(
          &#039;Using newly available with a date is not supported, please use &quot;widely available on YYYY-MM-DD&quot; and add 30 months to the date you specified.&#039;
        )
      }
      if (node.year) {
        baselineVersions = bbm.getCompatibleVersions({
          targetYear: node.year,
          includeDownstreamBrowsers: includeDownstream,
          includeKaiOS: includeKaiOS
        })
      } else if (node.date) {
        baselineVersions = bbm.getCompatibleVersions({
          widelyAvailableOnDate: node.date,
          includeDownstreamBrowsers: includeDownstream,
          includeKaiOS: includeKaiOS
        })
      } else if (node.availability === &#039;newly&#039;) {
        var future30months = new Date().setMonth(new Date().getMonth() + 30)
        baselineVersions = bbm.getCompatibleVersions({
          widelyAvailableOnDate: future30months,
          includeDownstreamBrowsers: includeDownstream,
          includeKaiOS: includeKaiOS
        })
      } else {
        baselineVersions = bbm.getCompatibleVersions({
          includeDownstreamBrowsers: includeDownstream,
          includeKaiOS: includeKaiOS
        })
      }
      return resolve(bbmTransform(baselineVersions), context)
    }
  },
  popularity: {
    matches: [&#039;sign&#039;, &#039;popularity&#039;],
    regexp: /^(&gt;=?|&lt;=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      var usage = browserslist.usage.global
      return Object.keys(usage).reduce(function (result, version) {
        if (node.sign === &#039;&gt;&#039;) {
          if (usage[version] &gt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;&#039;) {
          if (usage[version] &lt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;=&#039;) {
          if (usage[version] &lt;= popularity) {
            result.push(version)
          }
        } else if (usage[version] &gt;= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  popularity_in_my_stats: {
    matches: [&#039;sign&#039;, &#039;popularity&#039;],
    regexp: /^(&gt;=?|&lt;=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      if (!context.customUsage) {
        throw new BrowserslistError(&#039;Custom usage statistics was not provided&#039;)
      }
      var usage = context.customUsage
      return Object.keys(usage).reduce(function (result, version) {
        var percentage = usage[version]
        if (percentage == null) {
          return result
        }

        if (node.sign === &#039;&gt;&#039;) {
          if (percentage &gt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;&#039;) {
          if (percentage &lt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;=&#039;) {
          if (percentage &lt;= popularity) {
            result.push(version)
          }
        } else if (percentage &gt;= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  popularity_in_config_stats: {
    matches: [&#039;sign&#039;, &#039;popularity&#039;, &#039;config&#039;],
    regexp: /^(&gt;=?|&lt;=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      var usage = loadCustomUsage(context, node.config)
      return Object.keys(usage).reduce(function (result, version) {
        var percentage = usage[version]
        if (percentage == null) {
          return result
        }

        if (node.sign === &#039;&gt;&#039;) {
          if (percentage &gt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;&#039;) {
          if (percentage &lt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;=&#039;) {
          if (percentage &lt;= popularity) {
            result.push(version)
          }
        } else if (percentage &gt;= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  popularity_in_place: {
    matches: [&#039;sign&#039;, &#039;popularity&#039;, &#039;place&#039;],
    regexp: /^(&gt;=?|&lt;=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      var place = node.place
      if (place.length === 2) {
        place = place.toUpperCase()
      } else {
        place = place.toLowerCase()
      }
      env.loadCountry(browserslist.usage, place, browserslist.data)
      var usage = browserslist.usage[place]
      return Object.keys(usage).reduce(function (result, version) {
        var percentage = usage[version]
        if (percentage == null) {
          return result
        }

        if (node.sign === &#039;&gt;&#039;) {
          if (percentage &gt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;&#039;) {
          if (percentage &lt; popularity) {
            result.push(version)
          }
        } else if (node.sign === &#039;&lt;=&#039;) {
          if (percentage &lt;= popularity) {
            result.push(version)
          }
        } else if (percentage &gt;= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  cover: {
    matches: [&#039;coverage&#039;],
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
    select: coverQuery
  },
  cover_in: {
    matches: [&#039;coverage&#039;, &#039;place&#039;],
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
    select: coverQuery
  },
  cover_config: {
    matches: [&#039;coverage&#039;, &#039;config&#039;],
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/i,
    select: coverQuery
  },
  supports: {
    matches: [&#039;supportType&#039;, &#039;feature&#039;],
    regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
    select: function (context, node) {
      env.loadFeature(browserslist.cache, node.feature)
      var withPartial = node.supportType !== &#039;fully&#039;
      var features = browserslist.cache[node.feature]
      var result = []
      for (var name in features) {
        var data = byName(name, context)
        // Only check desktop when latest released mobile has support
        var iMax = data.released.length - 1
        while (iMax &gt;= 0) {
          if (data.released[iMax] in features[name]) break
          iMax--
        }
        var checkDesktop =
          context.mobileToDesktop &amp;&amp;
          name in browserslist.desktopNames &amp;&amp;
          isSupported(features[name][data.released[iMax]], withPartial)
        data.versions.forEach(function (version) {
          var flags = features[name][version]
          if (flags === undefined &amp;&amp; checkDesktop) {
            flags = features[browserslist.desktopNames[name]][version]
          }
          if (isSupported(flags, withPartial)) {
            result.push(name + &#039; &#039; + version)
          }
        })
      }
      return result
    }
  },
  electron_range: {
    matches: [&#039;from&#039;, &#039;to&#039;],
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, node) {
      var fromToUse = normalizeElectron(node.from)
      var toToUse = normalizeElectron(node.to)
      var from = parseFloat(node.from)
      var to = parseFloat(node.to)
      if (!e2c[fromToUse]) {
        throw new BrowserslistError(&#039;Unknown version &#039; + from + &#039; of electron&#039;)
      }
      if (!e2c[toToUse]) {
        throw new BrowserslistError(&#039;Unknown version &#039; + to + &#039; of electron&#039;)
      }
      return Object.keys(e2c)
        .filter(function (i) {
          var parsed = parseFloat(i)
          return parsed &gt;= from &amp;&amp; parsed &lt;= to
        })
        .map(function (i) {
          return &#039;chrome &#039; + e2c[i]
        })
    }
  },
  node_range: {
    matches: [&#039;from&#039;, &#039;to&#039;],
    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, node) {
      return browserslist.nodeVersions
        .filter(semverFilterLoose(&#039;&gt;=&#039;, node.from))
        .filter(semverFilterLoose(&#039;&lt;=&#039;, node.to))
        .map(function (v) {
          return &#039;node &#039; + v
        })
    }
  },
  browser_range: {
    matches: [&#039;browser&#039;, &#039;from&#039;, &#039;to&#039;],
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      var from = parseFloat(normalizeVersion(data, node.from) || node.from)
      var to = parseFloat(normalizeVersion(data, node.to) || node.to)
      function filter(v) {
        var parsed = parseFloat(v)
        return parsed &gt;= from &amp;&amp; parsed &lt;= to
      }
      return data.released.filter(filter).map(nameMapper(data.name))
    }
  },
  electron_ray: {
    matches: [&#039;sign&#039;, &#039;version&#039;],
    regexp: /^electron\s*(&gt;=?|&lt;=?)\s*([\d.]+)$/i,
    select: function (context, node) {
      var versionToUse = normalizeElectron(node.version)
      return Object.keys(e2c)
        .filter(generateFilter(node.sign, versionToUse))
        .map(function (i) {
          return &#039;chrome &#039; + e2c[i]
        })
    }
  },
  node_ray: {
    matches: [&#039;sign&#039;, &#039;version&#039;],
    regexp: /^node\s*(&gt;=?|&lt;=?)\s*([\d.]+)$/i,
    select: function (context, node) {
      return browserslist.nodeVersions
        .filter(generateSemverFilter(node.sign, node.version))
        .map(function (v) {
          return &#039;node &#039; + v
        })
    }
  },
  browser_ray: {
    matches: [&#039;browser&#039;, &#039;sign&#039;, &#039;version&#039;],
    regexp: /^(\w+)\s*(&gt;=?|&lt;=?)\s*([\d.]+)$/,
    select: function (context, node) {
      var version = node.version
      var data = checkName(node.browser, context)
      var alias = browserslist.versionAliases[data.name][version]
      if (alias) version = alias
      return data.released
        .filter(generateFilter(node.sign, version))
        .map(function (v) {
          return data.name + &#039; &#039; + v
        })
    }
  },
  firefox_esr: {
    matches: [],
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function () {
      return [&#039;firefox 140&#039;]
    }
  },
  opera_mini_all: {
    matches: [],
    regexp: /(operamini|op_mini)\s+all/i,
    select: function () {
      return [&#039;op_mini all&#039;]
    }
  },
  electron_version: {
    matches: [&#039;version&#039;],
    regexp: /^electron\s+([\d.]+)$/i,
    select: function (context, node) {
      var versionToUse = normalizeElectron(node.version)
      var chrome = e2c[versionToUse]
      if (!chrome) {
        throw new BrowserslistError(
          &#039;Unknown version &#039; + node.version + &#039; of electron&#039;
        )
      }
      return [&#039;chrome &#039; + chrome]
    }
  },
  node_major_version: {
    matches: [&#039;version&#039;],
    regexp: /^node\s+(\d+)$/i,
    select: nodeQuery
  },
  node_minor_version: {
    matches: [&#039;version&#039;],
    regexp: /^node\s+(\d+\.\d+)$/i,
    select: nodeQuery
  },
  node_patch_version: {
    matches: [&#039;version&#039;],
    regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
    select: nodeQuery
  },
  current_node: {
    matches: [],
    regexp: /^current\s+node$/i,
    select: function (context) {
      return [env.currentNode(resolve, context)]
    }
  },
  maintained_node: {
    matches: [],
    regexp: /^maintained\s+node\s+versions$/i,
    select: function (context) {
      var now = Date.now()
      var queries = Object.keys(jsEOL)
        .filter(function (key) {
          return (
            now &lt; Date.parse(jsEOL[key].end) &amp;&amp;
            now &gt; Date.parse(jsEOL[key].start) &amp;&amp;
            isEolReleased(key)
          )
        })
        .map(function (key) {
          return &#039;node &#039; + key.slice(1)
        })
      return resolve(queries, context)
    }
  },
  phantomjs_1_9: {
    matches: [],
    regexp: /^phantomjs\s+1.9$/i,
    select: function () {
      return [&#039;safari 5&#039;]
    }
  },
  phantomjs_2_1: {
    matches: [],
    regexp: /^phantomjs\s+2.1$/i,
    select: function () {
      return [&#039;safari 6&#039;]
    }
  },
  browser_version: {
    matches: [&#039;browser&#039;, &#039;version&#039;],
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function (context, node) {
      var version = node.version
      if (/^tp$/i.test(version)) version = &#039;TP&#039;
      var data = checkName(node.browser, context)
      var alias = normalizeVersion(data, version)
      if (alias) {
        version = alias
      } else {
        if (version.indexOf(&#039;.&#039;) === -1) {
          alias = version + &#039;.0&#039;
        } else {
          alias = version.replace(/\.0$/, &#039;&#039;)
        }
        alias = normalizeVersion(data, alias)
        if (alias) {
          version = alias
        } else if (context.ignoreUnknownVersions) {
          return []
        } else {
          throw new BrowserslistError(
            &#039;Unknown version &#039; + version + &#039; of &#039; + node.browser
          )
        }
      }
      return [data.name + &#039; &#039; + version]
    }
  },
  browserslist_config: {
    matches: [],
    regexp: /^browserslist config$/i,
    needsPath: true,
    select: function (context) {
      return browserslist(undefined, context)
    }
  },
  extends: {
    matches: [&#039;config&#039;],
    regexp: /^extends (.+)$/i,
    needsPath: true,
    select: function (context, node) {
      return resolve(env.loadQueries(context, node.config), context)
    }
  },
  defaults: {
    matches: [],
    regexp: /^defaults$/i,
    select: function (context) {
      return resolve(browserslist.defaults, context)
    }
  },
  dead: {
    matches: [],
    regexp: /^dead$/i,
    select: function (context) {
      var dead = [
        &#039;Baidu &gt;= 0&#039;,
        &#039;ie &lt;= 11&#039;,
        &#039;ie_mob &lt;= 11&#039;,
        &#039;bb &lt;= 10&#039;,
        &#039;op_mob &lt;= 12.1&#039;,
        &#039;samsung 4&#039;
      ]
      return resolve(dead, context)
    }
  },
  unknown: {
    matches: [],
    regexp: /^(\w+)$/i,
    select: function (context, node) {
      if (byName(node.query, context)) {
        throw new BrowserslistError(
          &#039;Specify versions in Browserslist query for browser &#039; + node.query
        )
      } else {
        throw unknownQuery(node.query)
      }
    }
  }
}

// Get and convert Can I Use data

;(function () {
  for (var name in agents) {
    var browser = agents[name]
    browserslist.data[name] = {
      name: name,
      versions: normalize(agents[name].versions),
      released: normalize(agents[name].versions.slice(0, -3)),
      releaseDate: agents[name].release_date
    }
    fillUsage(browserslist.usage.global, name, browser.usage_global)

    browserslist.versionAliases[name] = {}
    for (var i = 0; i &lt; browser.versions.length; i++) {
      var full = browser.versions[i]
      if (!full) continue

      if (full.indexOf(&#039;-&#039;) !== -1) {
        var interval = full.split(&#039;-&#039;)
        for (var j = 0; j &lt; interval.length; j++) {
          browserslist.versionAliases[name][interval[j]] = full
        }
      }
    }
  }

  browserslist.nodeVersions = jsReleases.map(function (release) {
    return release.version
  })
})()

module.exports = browserslist
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
