<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/xregexp/lib/addons/matchrecursive.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/xregexp/lib/addons/matchrecursive.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">43.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">254</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">59.94</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

var _Object$defineProperty = require(&quot;@babel/runtime-corejs3/core-js-stable/object/define-property&quot;);
var _interopRequireDefault = require(&quot;@babel/runtime-corejs3/helpers/interopRequireDefault&quot;);
_Object$defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports[&quot;default&quot;] = void 0;
var _indexOf = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/index-of&quot;));
var _concat = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/concat&quot;));
var _slice = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/slice&quot;));
/*!
 * XRegExp.matchRecursive 5.1.2
 * &lt;xregexp.com&gt;
 * Steven Levithan (c) 2009-present MIT License
 */
var _default = exports[&quot;default&quot;] = function _default(XRegExp) {
  /**
   * Returns a match detail object composed of the provided values.
   *
   * @private
   */
  function row(name, value, start, end) {
    return {
      name: name,
      value: value,
      start: start,
      end: end
    };
  }

  /**
   * Returns an array of match strings between outermost left and right delimiters, or an array of
   * objects with detailed match parts and position data. By default, an error is thrown if
   * delimiters are unbalanced within the subject string.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {String} left Left delimiter as an XRegExp pattern.
   * @param {String} right Right delimiter as an XRegExp pattern.
   * @param {String} [flags] Any combination of XRegExp flags, used for the left and right delimiters.
   * @param {Object} [options] Options object with optional properties:
   *   - `valueNames` {Array} Providing `valueNames` changes the return value from an array of
   *     matched strings to an array of objects that provide the value and start/end positions
   *     for the matched strings as well as the matched delimiters and unmatched string segments.
   *     To use this extended information mode, provide an array of 4 strings that name the parts
   *     to be returned:
   *     1. String segments outside of (before, between, and after) matches.
   *     2. Matched outermost left delimiters.
   *     3. Matched text between the outermost left and right delimiters.
   *     4. Matched outermost right delimiters.
   *     Taken together, these parts include the entire subject string if used with flag g.
   *     Use `null` for any of these values to omit unneeded parts from the returned results.
   *   - `escapeChar` {String} Single char used to escape delimiters within the subject string.
   *   - `unbalanced` {String} Handling mode for unbalanced delimiters. Options are:
   *     - &#039;error&#039; - throw (default)
   *     - &#039;skip&#039; - unbalanced delimiters are treated as part of the text between delimiters, and
   *       searches continue at the end of the unbalanced delimiter.
   *     - &#039;skip-lazy&#039; - unbalanced delimiters are treated as part of the text between delimiters,
   *       and searches continue one character after the start of the unbalanced delimiter.
   * @returns {Array} Array of matches, or an empty array.
   * @example
   *
   * // Basic usage
   * const str1 = &#039;(t((e))s)t()(ing)&#039;;
   * XRegExp.matchRecursive(str1, &#039;\\(&#039;, &#039;\\)&#039;, &#039;g&#039;);
   * // -&gt; [&#039;t((e))s&#039;, &#039;&#039;, &#039;ing&#039;]
   *
   * // Extended information mode with valueNames
   * const str2 = &#039;Here is &lt;div&gt; &lt;div&gt;an&lt;/div&gt;&lt;/div&gt; example&#039;;
   * XRegExp.matchRecursive(str2, &#039;&lt;div\\s*&gt;&#039;, &#039;&lt;/div&gt;&#039;, &#039;gi&#039;, {
   *   valueNames: [&#039;between&#039;, &#039;left&#039;, &#039;match&#039;, &#039;right&#039;]
   * });
   * // -&gt; [
   * // {name: &#039;between&#039;, value: &#039;Here is &#039;,       start: 0,  end: 8},
   * // {name: &#039;left&#039;,    value: &#039;&lt;div&gt;&#039;,          start: 8,  end: 13},
   * // {name: &#039;match&#039;,   value: &#039; &lt;div&gt;an&lt;/div&gt;&#039;, start: 13, end: 27},
   * // {name: &#039;right&#039;,   value: &#039;&lt;/div&gt;&#039;,         start: 27, end: 33},
   * // {name: &#039;between&#039;, value: &#039; example&#039;,       start: 33, end: 41}
   * // ]
   *
   * // Omitting unneeded parts with null valueNames, and using escapeChar
   * const str3 = &#039;...{1}.\\{{function(x,y){return {y:x}}}&#039;;
   * XRegExp.matchRecursive(str3, &#039;{&#039;, &#039;}&#039;, &#039;g&#039;, {
   *   valueNames: [&#039;literal&#039;, null, &#039;value&#039;, null],
   *   escapeChar: &#039;\\&#039;
   * });
   * // -&gt; [
   * // {name: &#039;literal&#039;, value: &#039;...&#039;,  start: 0, end: 3},
   * // {name: &#039;value&#039;,   value: &#039;1&#039;,    start: 4, end: 5},
   * // {name: &#039;literal&#039;, value: &#039;.\\{&#039;, start: 6, end: 9},
   * // {name: &#039;value&#039;,   value: &#039;function(x,y){return {y:x}}&#039;, start: 10, end: 37}
   * // ]
   *
   * // Sticky mode via flag y
   * const str4 = &#039;&lt;1&gt;&lt;&lt;&lt;2&gt;&gt;&gt;&lt;3&gt;4&lt;5&gt;&#039;;
   * XRegExp.matchRecursive(str4, &#039;&lt;&#039;, &#039;&gt;&#039;, &#039;gy&#039;);
   * // -&gt; [&#039;1&#039;, &#039;&lt;&lt;2&gt;&gt;&#039;, &#039;3&#039;]
   *
   * // Skipping unbalanced delimiters instead of erroring
   * const str5 = &#039;Here is &lt;div&gt; &lt;div&gt;an&lt;/div&gt; unbalanced example&#039;;
   * XRegExp.matchRecursive(str5, &#039;&lt;div\\s*&gt;&#039;, &#039;&lt;/div&gt;&#039;, &#039;gi&#039;, {
   *     unbalanced: &#039;skip&#039;
   * });
   * // -&gt; [&#039;an&#039;]
   */
  XRegExp.matchRecursive = function (str, left, right, flags, options) {
    flags = flags || &#039;&#039;;
    options = options || {};
    var global = (0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;g&#039;) !== -1;
    var sticky = (0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;y&#039;) !== -1;
    // Flag `y` is handled manually
    var basicFlags = flags.replace(/y/g, &#039;&#039;);
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);
    var esc;
    var _options = options,
      escapeChar = _options.escapeChar;
    if (escapeChar) {
      var _context, _context2;
      if (escapeChar.length &gt; 1) {
        throw new Error(&#039;Cannot use more than one escape character&#039;);
      }
      escapeChar = XRegExp.escape(escapeChar);
      // Example of concatenated `esc` regex:
      // `escapeChar`: &#039;%&#039;
      // `left`: &#039;&lt;&#039;
      // `right`: &#039;&gt;&#039;
      // Regex is: /(?:%[\S\s]|(?:(?!&lt;|&gt;)[^%])+)+/
      esc = new RegExp((0, _concat[&quot;default&quot;])(_context = (0, _concat[&quot;default&quot;])(_context2 = &quot;(?:&quot;.concat(escapeChar, &quot;[\\S\\s]|(?:(?!&quot;)).call(_context2,
      // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
      // transformation resulting from those flags was already applied to `left` and
      // `right` when they were passed through the XRegExp constructor above.
      XRegExp.union([left, right], &#039;&#039;, {
        conjunction: &#039;or&#039;
      }).source, &quot;)[^&quot;)).call(_context, escapeChar, &quot;])+)+&quot;),
      // Flags `dgy` not needed here
      flags.replace(XRegExp._hasNativeFlag(&#039;s&#039;) ? /[^imsu]/g : /[^imu]/g, &#039;&#039;));
    }
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var vN = options.valueNames;
    var output = [];
    while (true) {
      // If using an escape character, advance to the delimiter&#039;s next starting position,
      // skipping any escaped characters in between
      if (escapeChar) {
        delimEnd += (XRegExp.exec(str, esc, delimEnd, &#039;sticky&#039;) || [&#039;&#039;])[0].length;
      }
      leftMatch = XRegExp.exec(str, left, delimEnd);
      rightMatch = XRegExp.exec(str, right, delimEnd);
      // Keep the leftmost match only
      if (leftMatch &amp;&amp; rightMatch) {
        if (leftMatch.index &lt;= rightMatch.index) {
          rightMatch = null;
        } else {
          leftMatch = null;
        }
      }

      // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
      // LM | RM | OT | Result
      // 1  | 0  | 1  | loop
      // 1  | 0  | 0  | loop
      // 0  | 1  | 1  | loop
      // 0  | 1  | 0  | throw
      // 0  | 0  | 1  | throw
      // 0  | 0  | 0  | break
      // The paths above don&#039;t include the sticky mode special case. The loop ends after the
      // first completed match if not `global`.
      if (leftMatch || rightMatch) {
        delimStart = (leftMatch || rightMatch).index;
        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
      } else if (!openTokens) {
        break;
      }
      if (sticky &amp;&amp; !openTokens &amp;&amp; delimStart &gt; lastOuterEnd) {
        break;
      }
      if (leftMatch) {
        if (!openTokens) {
          outerStart = delimStart;
          innerStart = delimEnd;
        }
        openTokens += 1;
      } else if (rightMatch &amp;&amp; openTokens) {
        openTokens -= 1;
        if (!openTokens) {
          if (vN) {
            if (vN[0] &amp;&amp; outerStart &gt; lastOuterEnd) {
              output.push(row(vN[0], (0, _slice[&quot;default&quot;])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));
            }
            if (vN[1]) {
              output.push(row(vN[1], (0, _slice[&quot;default&quot;])(str).call(str, outerStart, innerStart), outerStart, innerStart));
            }
            if (vN[2]) {
              output.push(row(vN[2], (0, _slice[&quot;default&quot;])(str).call(str, innerStart, delimStart), innerStart, delimStart));
            }
            if (vN[3]) {
              output.push(row(vN[3], (0, _slice[&quot;default&quot;])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));
            }
          } else {
            output.push((0, _slice[&quot;default&quot;])(str).call(str, innerStart, delimStart));
          }
          lastOuterEnd = delimEnd;
          if (!global) {
            break;
          }
        }
        // Found unbalanced delimiter
      } else {
        var unbalanced = options.unbalanced || &#039;error&#039;;
        if (unbalanced === &#039;skip&#039; || unbalanced === &#039;skip-lazy&#039;) {
          if (rightMatch) {
            rightMatch = null;
            // No `leftMatch` for unbalanced left delimiter because we&#039;ve reached the string end
          } else {
            if (unbalanced === &#039;skip&#039;) {
              var outerStartDelimLength = XRegExp.exec(str, left, outerStart, &#039;sticky&#039;)[0].length;
              delimEnd = outerStart + (outerStartDelimLength || 1);
            } else {
              delimEnd = outerStart + 1;
            }
            openTokens = 0;
          }
        } else if (unbalanced === &#039;error&#039;) {
          var _context3;
          var delimSide = rightMatch ? &#039;right&#039; : &#039;left&#039;;
          var errorPos = rightMatch ? delimStart : outerStart;
          throw new Error((0, _concat[&quot;default&quot;])(_context3 = &quot;Unbalanced &quot;.concat(delimSide, &quot; delimiter found in string at position &quot;)).call(_context3, errorPos));
        } else {
          throw new Error(&quot;Unsupported value for unbalanced: &quot;.concat(unbalanced));
        }
      }

      // If the delimiter matched an empty string, avoid an infinite loop
      if (delimStart === delimEnd) {
        delimEnd += 1;
      }
    }
    if (global &amp;&amp; output.length &gt; 0 &amp;&amp; !sticky &amp;&amp; vN &amp;&amp; vN[0] &amp;&amp; str.length &gt; lastOuterEnd) {
      output.push(row(vN[0], (0, _slice[&quot;default&quot;])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));
    }
    return output;
  };
};
module.exports = exports.default;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
