<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/workerpool/dist/worker.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/workerpool/dist/worker.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">686</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.38</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * workerpool.js
 * https://github.com/josdejong/workerpool
 *
 * Offload tasks to a pool of workers on node.js and in the browser.
 *
 * @version 9.2.0
 * @date    2024-10-11
 *
 * @license
 * Copyright (C) 2014-2022 Jos de Jong &lt;wjosdejong@gmail.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

(function (global, factory) {
  typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? module.exports = factory() :
  typeof define === &#039;function&#039; &amp;&amp; define.amd ? define(factory) :
  (global = typeof globalThis !== &#039;undefined&#039; ? globalThis : global || self, global.worker = factory());
})(this, (function () { &#039;use strict&#039;;

  function _typeof(o) {
    &quot;@babel/helpers - typeof&quot;;

    return _typeof = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? &quot;symbol&quot; : typeof o;
    }, _typeof(o);
  }

  function getDefaultExportFromCjs (x) {
  	return x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x, &#039;default&#039;) ? x[&#039;default&#039;] : x;
  }

  var worker$1 = {};

  /**
   * The helper class for transferring data from the worker to the main thread.
   *
   * @param {Object} message The object to deliver to the main thread.
   * @param {Object[]} transfer An array of transferable Objects to transfer ownership of.
   */
  function Transfer(message, transfer) {
    this.message = message;
    this.transfer = transfer;
  }
  var transfer = Transfer;

  var _Promise = {};

  /**
   * Promise
   *
   * Inspired by https://gist.github.com/RubaXa/8501359 from RubaXa &lt;trash@rubaxa.org&gt;
   * @template T
   * @template [E=Error]
   * @param {Function} handler   Called as handler(resolve: Function, reject: Function)
   * @param {Promise} [parent]   Parent promise for propagation of cancel and timeout
   */
  function Promise$1(handler, parent) {
    var me = this;
    if (!(this instanceof Promise$1)) {
      throw new SyntaxError(&#039;Constructor must be called with the new operator&#039;);
    }
    if (typeof handler !== &#039;function&#039;) {
      throw new SyntaxError(&#039;Function parameter handler(resolve, reject) missing&#039;);
    }
    var _onSuccess = [];
    var _onFail = [];

    // status
    /**
     * @readonly
     */
    this.resolved = false;
    /**
     * @readonly
     */
    this.rejected = false;
    /**
     * @readonly
     */
    this.pending = true;

    /**
     * Process onSuccess and onFail callbacks: add them to the queue.
     * Once the promise is resolved, the function _promise is replace.
     * @param {Function} onSuccess
     * @param {Function} onFail
     * @private
     */
    var _process = function _process(onSuccess, onFail) {
      _onSuccess.push(onSuccess);
      _onFail.push(onFail);
    };

    /**
     * Add an onSuccess callback and optionally an onFail callback to the Promise
     * @template TT
     * @template [TE=never]
     * @param {(r: T) =&gt; TT | PromiseLike&lt;TT&gt;} onSuccess
     * @param {(r: E) =&gt; TE | PromiseLike&lt;TE&gt;} [onFail]
     * @returns {Promise&lt;TT | TE, any&gt;} promise
     */
    this.then = function (onSuccess, onFail) {
      return new Promise$1(function (resolve, reject) {
        var s = onSuccess ? _then(onSuccess, resolve, reject) : resolve;
        var f = onFail ? _then(onFail, resolve, reject) : reject;
        _process(s, f);
      }, me);
    };

    /**
     * Resolve the promise
     * @param {*} result
     * @type {Function}
     */
    var _resolve2 = function _resolve(result) {
      // update status
      me.resolved = true;
      me.rejected = false;
      me.pending = false;
      _onSuccess.forEach(function (fn) {
        fn(result);
      });
      _process = function _process(onSuccess, onFail) {
        onSuccess(result);
      };
      _resolve2 = _reject2 = function _reject() {};
      return me;
    };

    /**
     * Reject the promise
     * @param {Error} error
     * @type {Function}
     */
    var _reject2 = function _reject(error) {
      // update status
      me.resolved = false;
      me.rejected = true;
      me.pending = false;
      _onFail.forEach(function (fn) {
        fn(error);
      });
      _process = function _process(onSuccess, onFail) {
        onFail(error);
      };
      _resolve2 = _reject2 = function _reject() {};
      return me;
    };

    /**
     * Cancel the promise. This will reject the promise with a CancellationError
     * @returns {this} self
     */
    this.cancel = function () {
      if (parent) {
        parent.cancel();
      } else {
        _reject2(new CancellationError());
      }
      return me;
    };

    /**
     * Set a timeout for the promise. If the promise is not resolved within
     * the time, the promise will be cancelled and a TimeoutError is thrown.
     * If the promise is resolved in time, the timeout is removed.
     * @param {number} delay     Delay in milliseconds
     * @returns {this} self
     */
    this.timeout = function (delay) {
      if (parent) {
        parent.timeout(delay);
      } else {
        var timer = setTimeout(function () {
          _reject2(new TimeoutError(&#039;Promise timed out after &#039; + delay + &#039; ms&#039;));
        }, delay);
        me.always(function () {
          clearTimeout(timer);
        });
      }
      return me;
    };

    // attach handler passing the resolve and reject functions
    handler(function (result) {
      _resolve2(result);
    }, function (error) {
      _reject2(error);
    });
  }

  /**
   * Execute given callback, then call resolve/reject based on the returned result
   * @param {Function} callback
   * @param {Function} resolve
   * @param {Function} reject
   * @returns {Function}
   * @private
   */
  function _then(callback, resolve, reject) {
    return function (result) {
      try {
        var res = callback(result);
        if (res &amp;&amp; typeof res.then === &#039;function&#039; &amp;&amp; typeof res[&#039;catch&#039;] === &#039;function&#039;) {
          // method returned a promise
          res.then(resolve, reject);
        } else {
          resolve(res);
        }
      } catch (error) {
        reject(error);
      }
    };
  }

  /**
   * Add an onFail callback to the Promise
   * @template TT
   * @param {(error: E) =&gt; TT | PromiseLike&lt;TT&gt;} onFail
   * @returns {Promise&lt;T | TT&gt;} promise
   */
  Promise$1.prototype[&#039;catch&#039;] = function (onFail) {
    return this.then(null, onFail);
  };

  // TODO: add support for Promise.catch(Error, callback)
  // TODO: add support for Promise.catch(Error, Error, callback)

  /**
   * Execute given callback when the promise either resolves or rejects.
   * @template TT
   * @param {() =&gt; Promise&lt;TT&gt;} fn
   * @returns {Promise&lt;TT&gt;} promise
   */
  Promise$1.prototype.always = function (fn) {
    return this.then(fn, fn);
  };

  /**
    * Execute given callback when the promise either resolves or rejects.
    * Same semantics as Node&#039;s Promise.finally()
    * @param {Function} fn
    * @returns {Promise} promise
    */
  Promise$1.prototype.finally = function (fn) {
    var me = this;
    var final = function final() {
      return new Promise$1(function (resolve) {
        return resolve();
      }).then(fn).then(function () {
        return me;
      });
    };
    return this.then(final, final);
  };

  /**
   * Create a promise which resolves when all provided promises are resolved,
   * and fails when any of the promises resolves.
   * @param {Promise[]} promises
   * @returns {Promise&lt;any[], any&gt;} promise
   */
  Promise$1.all = function (promises) {
    return new Promise$1(function (resolve, reject) {
      var remaining = promises.length,
        results = [];
      if (remaining) {
        promises.forEach(function (p, i) {
          p.then(function (result) {
            results[i] = result;
            remaining--;
            if (remaining == 0) {
              resolve(results);
            }
          }, function (error) {
            remaining = 0;
            reject(error);
          });
        });
      } else {
        resolve(results);
      }
    });
  };

  /**
   * Create a promise resolver
   * @returns {{promise: Promise, resolve: Function, reject: Function}} resolver
   */
  Promise$1.defer = function () {
    var resolver = {};
    resolver.promise = new Promise$1(function (resolve, reject) {
      resolver.resolve = resolve;
      resolver.reject = reject;
    });
    return resolver;
  };

  /**
   * Create a cancellation error
   * @param {String} [message]
   * @extends Error
   */
  function CancellationError(message) {
    this.message = message || &#039;promise cancelled&#039;;
    this.stack = new Error().stack;
  }
  CancellationError.prototype = new Error();
  CancellationError.prototype.constructor = Error;
  CancellationError.prototype.name = &#039;CancellationError&#039;;
  Promise$1.CancellationError = CancellationError;

  /**
   * Create a timeout error
   * @param {String} [message]
   * @extends Error
   */
  function TimeoutError(message) {
    this.message = message || &#039;timeout exceeded&#039;;
    this.stack = new Error().stack;
  }
  TimeoutError.prototype = new Error();
  TimeoutError.prototype.constructor = Error;
  TimeoutError.prototype.name = &#039;TimeoutError&#039;;
  Promise$1.TimeoutError = TimeoutError;
  _Promise.Promise = Promise$1;

  (function (exports) {
    var Transfer = transfer;

    /**
     * worker must handle async cleanup handlers. Use custom Promise implementation. 
    */
    var Promise = _Promise.Promise;
    /**
     * Special message sent by parent which causes the worker to terminate itself.
     * Not a &quot;message object&quot;; this string is the entire message.
     */
    var TERMINATE_METHOD_ID = &#039;__workerpool-terminate__&#039;;

    /**
     * Special message by parent which causes a child process worker to perform cleaup
     * steps before determining if the child process worker should be terminated.
    */
    var CLEANUP_METHOD_ID = &#039;__workerpool-cleanup__&#039;;
    // var nodeOSPlatform = require(&#039;./environment&#039;).nodeOSPlatform;

    var TIMEOUT_DEFAULT = 1000;

    // create a worker API for sending and receiving messages which works both on
    // node.js and in the browser
    var worker = {
      exit: function exit() {}
    };

    // api for in worker communication with parent process
    // works in both node.js and the browser
    var publicWorker = {
      /**
       * 
       * @param {() =&gt; Promise&lt;void&gt;} listener 
       */
      addAbortListener: function addAbortListener(listener) {
        worker.abortListeners.push(listener);
      },
      emit: worker.emit
    };
    if (typeof self !== &#039;undefined&#039; &amp;&amp; typeof postMessage === &#039;function&#039; &amp;&amp; typeof addEventListener === &#039;function&#039;) {
      // worker in the browser
      worker.on = function (event, callback) {
        addEventListener(event, function (message) {
          callback(message.data);
        });
      };
      worker.send = function (message, transfer) {
        transfer ? postMessage(message, transfer) : postMessage(message);
      };
    } else if (typeof process !== &#039;undefined&#039;) {
      // node.js

      var WorkerThreads;
      try {
        WorkerThreads = require(&#039;worker_threads&#039;);
      } catch (error) {
        if (_typeof(error) === &#039;object&#039; &amp;&amp; error !== null &amp;&amp; error.code === &#039;MODULE_NOT_FOUND&#039;) ; else {
          throw error;
        }
      }
      if (WorkerThreads &amp;&amp; /* if there is a parentPort, we are in a WorkerThread */
      WorkerThreads.parentPort !== null) {
        var parentPort = WorkerThreads.parentPort;
        worker.send = parentPort.postMessage.bind(parentPort);
        worker.on = parentPort.on.bind(parentPort);
        worker.exit = process.exit.bind(process);
      } else {
        worker.on = process.on.bind(process);
        // ignore transfer argument since it is not supported by process
        worker.send = function (message) {
          process.send(message);
        };
        // register disconnect handler only for subprocess worker to exit when parent is killed unexpectedly
        worker.on(&#039;disconnect&#039;, function () {
          process.exit(1);
        });
        worker.exit = process.exit.bind(process);
      }
    } else {
      throw new Error(&#039;Script must be executed as a worker&#039;);
    }
    function convertError(error) {
      return Object.getOwnPropertyNames(error).reduce(function (product, name) {
        return Object.defineProperty(product, name, {
          value: error[name],
          enumerable: true
        });
      }, {});
    }

    /**
     * Test whether a value is a Promise via duck typing.
     * @param {*} value
     * @returns {boolean} Returns true when given value is an object
     *                    having functions `then` and `catch`.
     */
    function isPromise(value) {
      return value &amp;&amp; typeof value.then === &#039;function&#039; &amp;&amp; typeof value.catch === &#039;function&#039;;
    }

    // functions available externally
    worker.methods = {};

    /**
     * Execute a function with provided arguments
     * @param {String} fn     Stringified function
     * @param {Array} [args]  Function arguments
     * @returns {*}
     */
    worker.methods.run = function run(fn, args) {
      var f = new Function(&#039;return (&#039; + fn + &#039;).apply(this, arguments);&#039;);
      f.worker = publicWorker;
      return f.apply(f, args);
    };

    /**
     * Get a list with methods available on this worker
     * @return {String[]} methods
     */
    worker.methods.methods = function methods() {
      return Object.keys(worker.methods);
    };

    /**
     * Custom handler for when the worker is terminated.
     */
    worker.terminationHandler = undefined;
    worker.abortListenerTimeout = TIMEOUT_DEFAULT;

    /**
     * Abort handlers for resolving errors which may cause a timeout or cancellation
     * to occur from a worker context
     */
    worker.abortListeners = [];

    /**
     * Cleanup and exit the worker.
     * @param {Number} code 
     * @returns {Promise&lt;void&gt;}
     */
    worker.terminateAndExit = function (code) {
      var _exit = function _exit() {
        worker.exit(code);
      };
      if (!worker.terminationHandler) {
        return _exit();
      }
      var result = worker.terminationHandler(code);
      if (isPromise(result)) {
        result.then(_exit, _exit);
        return result;
      } else {
        _exit();
        return new Promise(function (_resolve, reject) {
          reject(new Error(&quot;Worker terminating&quot;));
        });
      }
    };

    /**
      * Called within the worker message handler to run abort handlers if registered to perform cleanup operations.
      * @param {Integer} [requestId] id of task which is currently executing in the worker
      * @return {Promise&lt;void&gt;}
    */
    worker.cleanup = function (requestId) {
      if (!worker.abortListeners.length) {
        worker.send({
          id: requestId,
          method: CLEANUP_METHOD_ID,
          error: convertError(new Error(&#039;Worker terminating&#039;))
        });

        // If there are no handlers registered, reject the promise with an error as we want the handler to be notified
        // that cleanup should begin and the handler should be GCed.
        return new Promise(function (resolve) {
          resolve();
        });
      }
      var _exit = function _exit() {
        worker.exit();
      };
      var _abort = function _abort() {
        if (!worker.abortListeners.length) {
          worker.abortListeners = [];
        }
      };
      var promises = worker.abortListeners.map(function (listener) {
        return listener();
      });
      var timerId;
      var timeoutPromise = new Promise(function (_resolve, reject) {
        timerId = setTimeout(function () {
          reject(new Error(&#039;Timeout occured waiting for abort handler, killing worker&#039;));
        }, worker.abortListenerTimeout);
      });

      // Once a promise settles we need to clear the timeout to prevet fulfulling the promise twice 
      var settlePromise = Promise.all(promises).then(function () {
        clearTimeout(timerId);
        _abort();
      }, function () {
        clearTimeout(timerId);
        _exit();
      });

      // Returns a promise which will result in one of the following cases
      // - Resolve once all handlers resolve
      // - Reject if one or more handlers exceed the &#039;abortListenerTimeout&#039; interval
      // - Reject if one or more handlers reject
      // Upon one of the above cases a message will be sent to the handler with the result of the handler execution
      // which will either kill the worker if the result contains an error, or 
      return Promise.all([settlePromise, timeoutPromise]).then(function () {
        worker.send({
          id: requestId,
          method: CLEANUP_METHOD_ID,
          error: null
        });
      }, function (err) {
        worker.send({
          id: requestId,
          method: CLEANUP_METHOD_ID,
          error: err ? convertError(err) : null
        });
      });
    };
    var currentRequestId = null;
    worker.on(&#039;message&#039;, function (request) {
      if (request === TERMINATE_METHOD_ID) {
        return worker.terminateAndExit(0);
      }
      if (request.method === CLEANUP_METHOD_ID) {
        return worker.cleanup(request.id);
      }
      try {
        var method = worker.methods[request.method];
        if (method) {
          currentRequestId = request.id;

          // execute the function
          var result = method.apply(method, request.params);
          if (isPromise(result)) {
            // promise returned, resolve this and then return
            result.then(function (result) {
              if (result instanceof Transfer) {
                worker.send({
                  id: request.id,
                  result: result.message,
                  error: null
                }, result.transfer);
              } else {
                worker.send({
                  id: request.id,
                  result: result,
                  error: null
                });
              }
              currentRequestId = null;
            }).catch(function (err) {
              worker.send({
                id: request.id,
                result: null,
                error: convertError(err)
              });
              currentRequestId = null;
            });
          } else {
            // immediate result
            if (result instanceof Transfer) {
              worker.send({
                id: request.id,
                result: result.message,
                error: null
              }, result.transfer);
            } else {
              worker.send({
                id: request.id,
                result: result,
                error: null
              });
            }
            currentRequestId = null;
          }
        } else {
          throw new Error(&#039;Unknown method &quot;&#039; + request.method + &#039;&quot;&#039;);
        }
      } catch (err) {
        worker.send({
          id: request.id,
          result: null,
          error: convertError(err)
        });
      }
    });

    /**
     * Register methods to the worker
     * @param {Object} [methods]
     * @param {import(&#039;./types.js&#039;).WorkerRegisterOptions} [options]
     */
    worker.register = function (methods, options) {
      if (methods) {
        for (var name in methods) {
          if (methods.hasOwnProperty(name)) {
            worker.methods[name] = methods[name];
            worker.methods[name].worker = publicWorker;
          }
        }
      }
      if (options) {
        worker.terminationHandler = options.onTerminate;
        // register listener timeout or default to 1 second
        worker.abortListenerTimeout = options.abortListenerTimeout || TIMEOUT_DEFAULT;
      }
      worker.send(&#039;ready&#039;);
    };
    worker.emit = function (payload) {
      if (currentRequestId) {
        if (payload instanceof Transfer) {
          worker.send({
            id: currentRequestId,
            isEvent: true,
            payload: payload.message
          }, payload.transfer);
          return;
        }
        worker.send({
          id: currentRequestId,
          isEvent: true,
          payload: payload
        });
      }
    };
    {
      exports.add = worker.register;
      exports.emit = worker.emit;
    }
  })(worker$1);
  var worker = /*@__PURE__*/getDefaultExportFromCjs(worker$1);

  return worker;

}));
//# sourceMappingURL=worker.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
