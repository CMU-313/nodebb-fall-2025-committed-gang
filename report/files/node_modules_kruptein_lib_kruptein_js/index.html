<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/kruptein/lib/kruptein.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/kruptein/lib/kruptein.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">417</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">57.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.24</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * kruptein
 * Copyright(c) 2019 Jason Gerfen &lt;jason.gerfen@gmail.com&gt;
 * License: MIT
 */
&quot;use strict&quot;;

class Kruptein {

  constructor(options) {
    options = options || {};

    this.crypto = require(&quot;crypto&quot;);

    // Set defaults if the user didn&#039;t supply any
    this._algorithm = options.algorithm || &quot;aes-256-gcm&quot;;
    this._hashing = options.hashing || &quot;sha384&quot;;
    this._encodeas = options.encodeas || &quot;base64&quot;;
    this._use_asn1 = options.use_asn1 || true;

    // Are we using AEAD mode (authenticated ciphers)?
    this._aead_mode = this._algorithm.match(/ccm|gcm|ocb/) ? true : false;

    // Set some defaults based on the algorithm used
    let defaults = this._matrix(this._algorithm);
    this._at_size = options._at_size || defaults._at_size;
    this._iv_size = options._iv_size || defaults._iv_size;
    this._key_size = options._key_size || defaults._key_size;

    // Replace pbkdf2 with scrypt for key derivation?
    this._use_scrypt = options.use_scrypt || false;

    // Use asn.1 encoding?
    if (this._use_asn1) {
      this.asn1 = require(&quot;asn1.js&quot;);
      this.schema = this._schema();
    }
  }


  set(secret, plaintext, aad, cb) {
    // If non-aead cipher then expect 3 vs. 4 args
    cb = cb || aad;

    // Initialize some defaults
    let iv, ct, hmac, obj, key;

    // Bail if using weak cipher algorithm modes
    if (this._validator())
      return cb(&quot;Insecure cipher mode not supported!&quot;);

    // Bail if secret is not provided
    if (!secret)
      return cb(&quot;Must supply a secret!&quot;);

    // Derive a stronger key from secret;
    this._derive_key(secret, (err, secret) =&gt; {
      if (err)
        return cb(&quot;Unable to derive key!&quot;);

      key = secret;
    });

    // Generate a random IV based on the algorithms IV size
    iv = this._iv(this._iv_size);

    // Are we dealing with an object?
    let pt = plaintext;
    try {
      plaintext = Buffer.from(JSON.stringify(pt));
    } catch(err) {
      plaintext = Buffer.from(pt);
    }

    // If AEAD mode cipher used and an AAD not provided, create one
    if (this._aead_mode &amp;&amp; typeof aad === &quot;function&quot;) {
      this._digest(this._iv(128), plaintext, this._hashing, this._encodeas, (err, res) =&gt; {
        if (err)
          return cb(&quot;Unable to generate AAD!&quot;);

        aad = res;
      });
    }

    // Create ciphertext from plaintext with derived key
    this._encrypt(key.key, plaintext, this._algorithm, this._encodeas, iv, aad, (err, ciphertext) =&gt; {
      if (err)
        return cb(&quot;Unable to create ciphertext!&quot;);

      ct = ciphertext;
    });

    // Create an HMAC from the resulting ciphertext
    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, digest) =&gt; {
      if (err)
        return cb(&quot;Unable to create digest!&quot;);

      hmac = digest;
    });

    // Create an object to pass back
    obj = {
      hmac: hmac,
      ct: ct.ct,
      iv: iv,
      salt: key.salt
    };

    // If AEAD mode include the AAD
    if (aad)
      obj.aad = aad;

    // If AEAD mode include the AT
    if (ct.at)
      obj.at = ct.at;

    // Make sure the retured object is encoded property
    return (this._use_asn1) ?
      cb(null, this.schema.encode(obj).toString(this._encodeas)) :
      cb(null, JSON.stringify(obj));
  }


  get(secret, ciphertext, opts, cb) {
    // If non-aead cipher then expect 3 vs. 4 args
    cb = cb || opts;

    // Initialize some defaults
    let ct, hmac, pt, key;

    // Bail if using weak cipher algorithm modes
    if (this._validator())
      return cb(&quot;Insecure cipher mode not supported!&quot;);

    // Bail if secret is not provided
    if (!secret)
      return cb(&quot;Must supply a secret!&quot;);

    // Parse the provided ciphertext object or bail
    try {
      if (this._use_asn1) {
        ct = this.schema.decode(Buffer.from(ciphertext, this._encodeas));

        if (ct.at)
          ct.ct = ct.ct.toString();

        if (ct.aad)
          ct.aad = ct.aad.toString();
      } else {
        ct = JSON.parse(ciphertext);
      }
    } catch (err) {
      return cb(&quot;Unable to parse ciphertext object!&quot;);
    }

    // Derive a stronger key from secret;
    this._derive_key(secret, ct.salt, (err, secret) =&gt; {
      if (err)
        return cb(&quot;Unable to derive key!&quot;);

      key = secret;
    });

    // Create an HMAC from the ciphertext HMAC value
    this._digest(key.key, ct.ct, this._hashing, this._encodeas, (err, res) =&gt; {
      if (err)
        cb(&quot;Unable to generate HMAC!&quot;);

      hmac = res;
    });


    // Compare computed from included &amp; bail if not identical
    if (hmac !== ct.hmac.toString())
      return cb(&quot;Encrypted session was tampered with!&quot;);

    // If provided get the AAD &amp;/or AT values
    if (opts) {
      ct.aad = (opts.aad) ? opts.aad :
        (ct.aad) ? ct.aad : false;

      ct.at = (opts.at &amp;&amp; !ct.at) ?
        opts.at : (ct.at) ?
        ct.at : false;
    }

    // Convert the AT to a buffer
    if (ct.at)
      ct.at = Buffer.from(ct.at, this._encodeas);

    // Create plaintext from ciphertext with derived key
    this._decrypt(key.key, ct.ct, this._algorithm, this._encodeas, Buffer.from(ct.iv, this._encodeas), ct.at, ct.aad, (err, res) =&gt; {
      if (err)
        return cb(&quot;Unable to decrypt ciphertext!&quot;);

      pt = res;
    });

    return cb(null, pt);
  }

  _encrypt(key, pt, algo, encodeas, iv, aad, cb) {
    // If non-aead cipher then expect 6 vs. 7 args
    cb = cb || aad;

    // Initialize some defaults
    let cipher, ct, at;

    // Create a new cipher object using algorithm, derived key &amp; iv
    cipher = this.crypto.createCipheriv(algo, key, iv, {
      authTagLength: this._at_size
    });

    // If an AEAD cipher is used &amp; an AAD supplied, include it
    if (this._aead_mode &amp;&amp; typeof aad !== &quot;function&quot;) {
      try {
        cipher.setAAD(Buffer.from(aad, encodeas), {
          plaintextLength: Buffer.byteLength(pt)
        });
      } catch (err) {
        return cb(&quot;Unable to set AAD!&quot;);
      }
    }

    // Add our plaintext; encode &amp; pad the resulting cipher text
    ct = cipher.update(Buffer.from(pt, encodeas), &quot;utf8&quot;, encodeas);
    cipher.setAutoPadding(true);
    ct += cipher.final(encodeas);

    // If an AEAD cipher is used, retrieve the authentication tag
    if (this._aead_mode) {
      try {
        at = cipher.getAuthTag();
      } catch (err) {
        return cb(&quot;Unable to obtain authentication tag&quot;);
      }
    }

    // Return the object
    return cb(null, (at) ? { &quot;ct&quot;: ct, &quot;at&quot;: at } : { &quot;ct&quot;: ct });
  }


  _decrypt(key, ct, algo, encodeas, iv, at, aad, cb) {
    // If non-aead cipher then expect 6 vs. 7 args
    cb = cb || aad;

    // Initialize some defaults
    let cipher, pt;

    // Create a new de-cipher object using algorithm, derived key &amp; iv
    cipher = this.crypto.createDecipheriv(algo, key, iv, {
      authTagLength: this._at_size
    });

    // If an AEAD cipher is used &amp; an AT supplied, include it
    if (this._aead_mode &amp;&amp; at) {
      try {
        cipher.setAuthTag(Buffer.from(at, encodeas));
      } catch (err) {
        return cb(&quot;Unable to set authentication tag&quot;);
      }
    }

    // If an AEAD cipher is used &amp; an AAD supplied, include it
    if (this._aead_mode &amp;&amp; typeof aad !== &quot;function&quot;) {
      try {
        cipher.setAAD(Buffer.from(aad, encodeas), {
          plaintextLength: ct.length
        });
      } catch (err) {
        return cb(&quot;Unable to set additional authentication data&quot;);
      }
    }

    // Add our ciphertext &amp; encode
    try {
      pt = cipher.update(ct.toString(), encodeas, &quot;utf8&quot;);
      pt += cipher.final(&quot;utf8&quot;);
    } catch(err) {
      return cb(&quot;Unable to decrypt ciphertext!&quot;);
    }

    // return the plaintext
    return cb(null, pt);
  }


  _derive_key(secret, salt, cb) {
    // If salt not supplied then expect 2 vs. 3 args
    cb = cb || salt;

    // Initialize some defaults
    let key, opts = {};

    // If secret is an object then extract the parts; test harness only
    if (typeof secret === &quot;object&quot;) {
      opts = secret.opts;
      secret = secret.secret;
    }

    // If a salt was NOT supplied, create one
    salt = (typeof salt !== &quot;function&quot;) ?
      Buffer.from(salt) : this.crypto.randomBytes(128);

    // PBKDF2 or scrypt key derivation logic
    try {
      if (!this._use_scrypt || typeof this.crypto.scryptSync !== &quot;function&quot;) {
        key = this.crypto.pbkdf2Sync(secret, salt, 15000, this._key_size, this._hashing);
      } else {
        key = this.crypto.scryptSync(secret, salt, this._key_size, opts);
      }
    } catch (err) {
      return cb(&quot;Unable to derive key!&quot;);
    }

    // Return the derived key and salt
    return cb(null, {
      key: key,
      salt: salt
    });
  }


  _digest(key, obj, hashing, encodeas, cb) {

    // Initialize some defaults
    let hmac;

    // Create an HMAC from the supplied data
    try {
      hmac = this.crypto.createHmac(hashing, key);
      hmac.setEncoding(encodeas);
      hmac.write(obj);
      hmac.end();
    } catch (err) {
      return cb(&quot;Unable to generate digest!&quot;);
    }

    // Return digest
    return cb(null, hmac.read().toString(encodeas));
  }


  _iv(iv_size) {
    return this.crypto.randomBytes(iv_size);
  }


  _matrix(algo) {
    let obj = {
      _at_size: 16,
      _iv_size: 16,
      _key_size: 32
    };

    if (algo.match(/ccm|ocb|gcm/i))
      obj._iv_size = 12;

    if (algo.match(/aes/) &amp;&amp; algo.match(/128/))
      obj._key_size = 16;

    if (algo.match(/aes/) &amp;&amp; algo.match(/192/))
      obj._key_size = 24;

    if (algo.match(/aes/) &amp;&amp; algo.match(/xts/))
      obj._key_size = 32;

    if (algo.match(/aes/) &amp;&amp; algo.match(/xts/) &amp;&amp; algo.match(/256/))
      obj._key_size = 64;

    return obj;
  }


  _validator() {
    return (this._algorithm.match(/ccm|ecb|ocb2|xts/));
  }


  _schema() {
    let schema;
    if (!this._aead_mode) {

      schema = this.asn1.define(&#039;schema&#039;, function() {
        this.seq().obj(
          this.key(&quot;ct&quot;).octstr(),
          this.key(&quot;hmac&quot;).octstr(),
          this.key(&quot;iv&quot;).octstr(),
          this.key(&quot;salt&quot;).octstr()
        );
      });

    } else {

      schema = this.asn1.define(&#039;schema&#039;, function() {
        this.seq().obj(
          this.key(&quot;ct&quot;).octstr(),
          this.key(&quot;hmac&quot;).octstr(),
          this.key(&quot;iv&quot;).octstr(),
          this.key(&quot;salt&quot;).octstr(),
          this.key(&quot;at&quot;).octstr(),
          this.key(&quot;aad&quot;).octstr()
        );
      });
    }

    return schema;
  }
}


// Robot, do work
module.exports = function(options) {
  return new Kruptein(options || {});
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
