<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@stylistic/eslint-plugin-js/dist/rules/max-len.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@stylistic/eslint-plugin-js/dist/rules/max-len.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">239</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">76.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.73</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { c as createRule } from &#039;../utils.js&#039;;
import &#039;eslint-visitor-keys&#039;;
import &#039;espree&#039;;

const OPTIONS_SCHEMA = {
  type: &quot;object&quot;,
  properties: {
    code: {
      type: &quot;integer&quot;,
      minimum: 0
    },
    comments: {
      type: &quot;integer&quot;,
      minimum: 0
    },
    tabWidth: {
      type: &quot;integer&quot;,
      minimum: 0
    },
    ignorePattern: {
      type: &quot;string&quot;
    },
    ignoreComments: {
      type: &quot;boolean&quot;
    },
    ignoreStrings: {
      type: &quot;boolean&quot;
    },
    ignoreUrls: {
      type: &quot;boolean&quot;
    },
    ignoreTemplateLiterals: {
      type: &quot;boolean&quot;
    },
    ignoreRegExpLiterals: {
      type: &quot;boolean&quot;
    },
    ignoreTrailingComments: {
      type: &quot;boolean&quot;
    }
  },
  additionalProperties: false
};
const OPTIONS_OR_INTEGER_SCHEMA = {
  anyOf: [
    OPTIONS_SCHEMA,
    {
      type: &quot;integer&quot;,
      minimum: 0
    }
  ]
};
var maxLen = createRule({
  name: &quot;max-len&quot;,
  package: &quot;js&quot;,
  meta: {
    type: &quot;layout&quot;,
    docs: {
      description: &quot;Enforce a maximum line length&quot;
    },
    schema: [
      OPTIONS_OR_INTEGER_SCHEMA,
      OPTIONS_OR_INTEGER_SCHEMA,
      OPTIONS_SCHEMA
    ],
    messages: {
      max: &quot;This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.&quot;,
      maxComment: &quot;This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.&quot;
    }
  },
  create(context) {
    const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;
    const sourceCode = context.sourceCode;
    function computeLineLength(line, tabWidth2) {
      let extraCharacterCount = 0;
      line.replace(/\t/gu, (_, offset) =&gt; {
        const totalOffset = offset + extraCharacterCount;
        const previousTabStopOffset = tabWidth2 ? totalOffset % tabWidth2 : 0;
        const spaceCount = tabWidth2 - previousTabStopOffset;
        extraCharacterCount += spaceCount - 1;
        return &quot;&quot;;
      });
      return Array.from(line).length + extraCharacterCount;
    }
    const options = Object.assign({}, context.options[context.options.length - 1]);
    if (typeof context.options[0] === &quot;number&quot;)
      options.code = context.options[0];
    if (typeof context.options[1] === &quot;number&quot;)
      options.tabWidth = context.options[1];
    const maxLength = typeof options.code === &quot;number&quot; ? options.code : 80;
    const tabWidth = typeof options.tabWidth === &quot;number&quot; ? options.tabWidth : 4;
    const ignoreComments = !!options.ignoreComments;
    const ignoreStrings = !!options.ignoreStrings;
    const ignoreTemplateLiterals = !!options.ignoreTemplateLiterals;
    const ignoreRegExpLiterals = !!options.ignoreRegExpLiterals;
    const ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments;
    const ignoreUrls = !!options.ignoreUrls;
    const maxCommentLength = options.comments;
    let ignorePattern = null;
    if (options.ignorePattern)
      ignorePattern = new RegExp(options.ignorePattern, &quot;u&quot;);
    function isTrailingComment(line, lineNumber, comment) {
      return comment &amp;&amp; (comment.loc.start.line === lineNumber &amp;&amp; lineNumber &lt;= comment.loc.end.line) &amp;&amp; (comment.loc.end.line &gt; lineNumber || comment.loc.end.column === line.length);
    }
    function isFullLineComment(line, lineNumber, comment) {
      const start = comment.loc.start;
      const end = comment.loc.end;
      const isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
      return comment &amp;&amp; (start.line &lt; lineNumber || start.line === lineNumber &amp;&amp; isFirstTokenOnLine) &amp;&amp; (end.line &gt; lineNumber || end.line === lineNumber &amp;&amp; end.column === line.length);
    }
    function isJSXEmptyExpressionInSingleLineContainer(node) {
      if (!node || !node.parent || node.type !== &quot;JSXEmptyExpression&quot; || node.parent.type !== &quot;JSXExpressionContainer&quot;)
        return false;
      const parent = node.parent;
      return parent.loc.start.line === parent.loc.end.line;
    }
    function stripTrailingComment(line, comment) {
      return line.slice(0, comment.loc.start.column).replace(/\s+$/u, &quot;&quot;);
    }
    function ensureArrayAndPush(object, key, value) {
      if (!Array.isArray(object[key]))
        object[key] = [];
      object[key].push(value);
    }
    function getAllStrings() {
      return sourceCode.ast.tokens.filter((token) =&gt; token.type === &quot;String&quot; || token.type === &quot;JSXText&quot; &amp;&amp; sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === &quot;JSXAttribute&quot;);
    }
    function getAllTemplateLiterals() {
      return sourceCode.ast.tokens.filter((token) =&gt; token.type === &quot;Template&quot;);
    }
    function getAllRegExpLiterals() {
      return sourceCode.ast.tokens.filter((token) =&gt; token.type === &quot;RegularExpression&quot;);
    }
    function groupArrayByLineNumber(arr) {
      const obj = {};
      for (let i = 0; i &lt; arr.length; i++) {
        const node = arr[i];
        for (let j = node.loc.start.line; j &lt;= node.loc.end.line; ++j)
          ensureArrayAndPush(obj, j, node);
      }
      return obj;
    }
    function getAllComments() {
      const comments = [];
      sourceCode.getAllComments().forEach((commentNode) =&gt; {
        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);
        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
          if (comments[comments.length - 1] !== containingNode.parent)
            comments.push(containingNode.parent);
        } else {
          comments.push(commentNode);
        }
      });
      return comments;
    }
    function checkProgramForMaxLength(node) {
      const lines = sourceCode.lines;
      const comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];
      let commentsIndex = 0;
      const strings = getAllStrings();
      const stringsByLine = groupArrayByLineNumber(strings);
      const templateLiterals = getAllTemplateLiterals();
      const templateLiteralsByLine = groupArrayByLineNumber(templateLiterals);
      const regExpLiterals = getAllRegExpLiterals();
      const regExpLiteralsByLine = groupArrayByLineNumber(regExpLiterals);
      lines.forEach((line, i) =&gt; {
        const lineNumber = i + 1;
        let lineIsComment = false;
        let textToMeasure;
        if (commentsIndex &lt; comments.length) {
          let comment = null;
          do
            comment = comments[++commentsIndex];
          while (comment &amp;&amp; comment.loc.start.line &lt;= lineNumber);
          comment = comments[--commentsIndex];
          if (isFullLineComment(line, lineNumber, comment)) {
            lineIsComment = true;
            textToMeasure = line;
          } else if (ignoreTrailingComments &amp;&amp; isTrailingComment(line, lineNumber, comment)) {
            textToMeasure = stripTrailingComment(line, comment);
            let lastIndex = commentsIndex;
            while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex]))
              textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);
          } else {
            textToMeasure = line;
          }
        } else {
          textToMeasure = line;
        }
        if (ignorePattern &amp;&amp; ignorePattern.test(textToMeasure) || ignoreUrls &amp;&amp; URL_REGEXP.test(textToMeasure) || ignoreStrings &amp;&amp; stringsByLine[lineNumber] || ignoreTemplateLiterals &amp;&amp; templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals &amp;&amp; regExpLiteralsByLine[lineNumber]) {
          return;
        }
        const lineLength = computeLineLength(textToMeasure, tabWidth);
        const commentLengthApplies = lineIsComment &amp;&amp; maxCommentLength;
        if (lineIsComment &amp;&amp; ignoreComments)
          return;
        const loc = {
          start: {
            line: lineNumber,
            column: 0
          },
          end: {
            line: lineNumber,
            column: textToMeasure.length
          }
        };
        if (commentLengthApplies) {
          if (lineLength &gt; maxCommentLength) {
            context.report({
              node,
              loc,
              messageId: &quot;maxComment&quot;,
              data: {
                lineLength,
                maxCommentLength
              }
            });
          }
        } else if (lineLength &gt; maxLength) {
          context.report({
            node,
            loc,
            messageId: &quot;max&quot;,
            data: {
              lineLength,
              maxLength
            }
          });
        }
      });
    }
    return {
      Program: checkProgramForMaxLength
    };
  }
});

export { maxLen as default };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
