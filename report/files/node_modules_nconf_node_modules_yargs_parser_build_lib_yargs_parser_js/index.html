<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nconf/node_modules/yargs-parser/build/lib/yargs-parser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nconf/node_modules/yargs-parser/build/lib/yargs-parser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1038</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">189.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
import { tokenizeArgString } from &#039;./tokenize-arg-string.js&#039;;
import { DefaultValuesForTypeKey } from &#039;./yargs-parser-types.js&#039;;
import { camelCase, decamelize, looksLikeNumber } from &#039;./string-utils.js&#039;;
let mixin;
export class YargsParser {
    constructor(_mixin) {
        mixin = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        // allow a string argument to be passed in rather
        // than an argv array.
        const args = tokenizeArgString(argsInput);
        // aliases might have transitive relationships, normalize this.
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            &#039;boolean-negation&#039;: true,
            &#039;camel-case-expansion&#039;: true,
            &#039;combine-arrays&#039;: false,
            &#039;dot-notation&#039;: true,
            &#039;duplicate-arguments-array&#039;: true,
            &#039;flatten-duplicate-arrays&#039;: true,
            &#039;greedy-arrays&#039;: true,
            &#039;halt-at-non-option&#039;: false,
            &#039;nargs-eats-options&#039;: false,
            &#039;negation-prefix&#039;: &#039;no-&#039;,
            &#039;parse-numbers&#039;: true,
            &#039;parse-positional-numbers&#039;: true,
            &#039;populate--&#039;: false,
            &#039;set-placeholder-key&#039;: false,
            &#039;short-option-groups&#039;: true,
            &#039;strip-aliased&#039;: false,
            &#039;strip-dashed&#039;: false,
            &#039;unknown-options-as-args&#039;: false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration[&#039;populate--&#039;];
        const notFlagsArgv = notFlagsOption ? &#039;--&#039; : &#039;_&#039;;
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        // allow a i18n handler to be passed in, default to a fake one (util.format).
        const __ = opts.__ || mixin.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp(&#039;^--&#039; + configuration[&#039;negation-prefix&#039;] + &#039;(.+)&#039;);
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
            const key = typeof opt === &#039;object&#039; ? opt.key : opt;
            // assign to flags[bools|strings|numbers]
            const assignment = Object.keys(opt).map(function (key) {
                const arrayFlagKeys = {
                    boolean: &#039;bools&#039;,
                    string: &#039;strings&#039;,
                    number: &#039;numbers&#039;
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            // assign key to be coerced
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === &#039;object&#039;) {
            Object.entries(opts.narg).forEach(([key, value]) =&gt; {
                if (typeof value === &#039;number&#039;) {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === &#039;object&#039;) {
            Object.entries(opts.coerce).forEach(([key, value]) =&gt; {
                if (typeof value === &#039;function&#039;) {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== &#039;undefined&#039;) {
            if (Array.isArray(opts.config) || typeof opts.config === &#039;string&#039;) {
                ;
                [].concat(opts.config).filter(Boolean).forEach(function (key) {
                    flags.configs[key] = true;
                });
            }
            else if (typeof opts.config === &#039;object&#039;) {
                Object.entries(opts.config).forEach(([key, value]) =&gt; {
                    if (typeof value === &#039;boolean&#039; || typeof value === &#039;function&#039;) {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        // create a lookup table that takes into account all
        // combinations of aliases: {f: [&#039;foo&#039;], foo: [&#039;f&#039;]}
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        // apply default values to all aliases.
        Object.keys(defaults).forEach(function (key) {
            (flags.aliases[key] || []).forEach(function (alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), { _: [] });
        // TODO(bcoe): for the first pass at removing object prototype  we didn&#039;t
        // remove all prototypes from objects returned by this API, we might want
        // to gradually move towards doing so.
        const argvReturn = {};
        for (let i = 0; i &lt; args.length; i++) {
            const arg = args[i];
            const truncatedArg = arg.replace(/^-{3,}/, &#039;---&#039;);
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            // any unknown option (except for end-of-options, &quot;--&quot;)
            if (arg !== &#039;--&#039; &amp;&amp; isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
                // ---, ---=, ----, etc,
            }
            else if (truncatedArg.match(/---+(=|$)/)) {
                // options without key name are invalid.
                pushPositional(arg);
                continue;
                // -- separated by =
            }
            else if (arg.match(/^--.+=/) || (!configuration[&#039;short-option-groups&#039;] &amp;&amp; arg.match(/^-.+=/))) {
                // Using [\s\S] instead of . because js doesn&#039;t support the
                // &#039;dotall&#039; regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                // arrays format = &#039;--f=a b c&#039;
                if (m !== null &amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    }
                    else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        // nargs format = &#039;--f=monkey washing cat&#039;
                        i = eatNargs(i, m[1], args, m[2]);
                    }
                    else {
                        setArg(m[1], m[2]);
                    }
                }
            }
            else if (arg.match(negatedBoolean) &amp;&amp; configuration[&#039;boolean-negation&#039;]) {
                m = arg.match(negatedBoolean);
                if (m !== null &amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
                }
                // -- separated by space.
            }
            else if (arg.match(/^--.+/) || (!configuration[&#039;short-option-groups&#039;] &amp;&amp; arg.match(/^-[^-]+/))) {
                m = arg.match(/^--?(.+)/);
                if (m !== null &amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        // array format = &#039;--foo a b c&#039;
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        // nargs format = &#039;--foo a b c&#039;
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined &amp;&amp; (!next.match(/^-/) ||
                            next.match(negative)) &amp;&amp;
                            !checkAllAliases(key, flags.bools) &amp;&amp;
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
                // dot-notation flag separated by &#039;=&#039;.
            }
            else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null &amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= 3) {
                    setArg(m[1], m[2]);
                }
                // dot-notation flag separated by space.
            }
            else if (arg.match(/^-.\..+/) &amp;&amp; !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null &amp;&amp; Array.isArray(m) &amp;&amp; m.length &gt;= 2) {
                    key = m[1];
                    if (next !== undefined &amp;&amp; !next.match(/^-/) &amp;&amp;
                        !checkAllAliases(key, flags.bools) &amp;&amp;
                        !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    }
                    else {
                        setArg(key, defaultValue(key));
                    }
                }
            }
            else if (arg.match(/^-[^-]+/) &amp;&amp; !arg.match(negative)) {
                letters = arg.slice(1, -1).split(&#039;&#039;);
                broken = false;
                for (let j = 0; j &lt; letters.length; j++) {
                    next = arg.slice(j + 2);
                    if (letters[j + 1] &amp;&amp; letters[j + 1] === &#039;=&#039;) {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            // array format = &#039;-f=a b c&#039;
                            i = eatArray(i, key, args, value);
                        }
                        else if (checkAllAliases(key, flags.nargs) !== false) {
                            // nargs format = &#039;-f=monkey washing cat&#039;
                            i = eatNargs(i, key, args, value);
                        }
                        else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === &#039;-&#039;) {
                        setArg(letters[j], next);
                        continue;
                    }
                    // current letter is an alphabetic character and next value is a number
                    if (/[A-Za-z]/.test(letters[j]) &amp;&amp;
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &amp;&amp;
                        checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] &amp;&amp; letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken &amp;&amp; key !== &#039;-&#039;) {
                    if (checkAllAliases(key, flags.arrays)) {
                        // array format = &#039;-f a b c&#039;
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        // nargs format = &#039;-f a b c&#039;
                        // should be truthy even if: flags.nargs[key] === 0
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined &amp;&amp; (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &amp;&amp;
                            !checkAllAliases(key, flags.bools) &amp;&amp;
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-[0-9]$/) &amp;&amp;
                arg.match(negative) &amp;&amp;
                checkAllAliases(arg.slice(1), flags.bools)) {
                // single-digit boolean alias, e.g: xargs -0
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            }
            else if (arg === &#039;--&#039;) {
                notFlags = args.slice(i + 1);
                break;
            }
            else if (configuration[&#039;halt-at-non-option&#039;]) {
                notFlags = args.slice(i);
                break;
            }
            else {
                pushPositional(arg);
            }
        }
        // order of precedence:
        // 1. command line arg
        // 2. value from env var
        // 3. value from config file
        // 4. value from config objects
        // 5. configured default value
        applyEnvVars(argv, true); // special case: check env vars that point to config file
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration[&#039;set-placeholder-key&#039;])
            setPlaceholderKeys(argv);
        // for any counts either not in args or without an explicit default, set to 0
        Object.keys(flags.counts).forEach(function (key) {
            if (!hasKey(argv, key.split(&#039;.&#039;)))
                setArg(key, 0);
        });
        // &#039;--&#039; defaults to undefined.
        if (notFlagsOption &amp;&amp; notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration[&#039;camel-case-expansion&#039;] &amp;&amp; configuration[&#039;strip-dashed&#039;]) {
            Object.keys(argv).filter(key =&gt; key !== &#039;--&#039; &amp;&amp; key.includes(&#039;-&#039;)).forEach(key =&gt; {
                delete argv[key];
            });
        }
        if (configuration[&#039;strip-aliased&#039;]) {
            ;
            [].concat(...Object.keys(aliases).map(k =&gt; aliases[k])).forEach(alias =&gt; {
                if (configuration[&#039;camel-case-expansion&#039;] &amp;&amp; alias.includes(&#039;-&#039;)) {
                    delete argv[alias.split(&#039;.&#039;).map(prop =&gt; camelCase(prop)).join(&#039;.&#039;)];
                }
                delete argv[alias];
            });
        }
        // Push argument into positional array, applying numeric coercion:
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber(&#039;_&#039;, arg);
            if (typeof maybeCoercedNumber === &#039;string&#039; || typeof maybeCoercedNumber === &#039;number&#039;) {
                argv._.push(maybeCoercedNumber);
            }
        }
        // how many arguments should we consume, based
        // on the nargs option?
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            // NaN has a special meaning for the array type, indicating that one or
            // more values are expected.
            toEat = typeof toEat !== &#039;number&#039; || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__(&#039;Argument unexpected for: %s&#039;, key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration[&#039;nargs-eats-options&#039;]) {
                // classic behavior, yargs eats positional and dash arguments.
                if (args.length - (i + 1) + available &lt; toEat) {
                    error = Error(__(&#039;Not enough arguments following: %s&#039;, key));
                }
                available = toEat;
            }
            else {
                // nargs will not consume flag arguments, e.g., -abc, --foo,
                // and terminates when one is observed.
                for (ii = i + 1; ii &lt; args.length; ii++) {
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
                }
                if (available &lt; toEat)
                    error = Error(__(&#039;Not enough arguments following: %s&#039;, key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) &amp;&amp; consumed &gt; 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for (ii = i + 1; ii &lt; (consumed + i + 1); ii++) {
                setArg(key, args[ii]);
            }
            return (i + consumed);
        }
        // if an option is an array, eat all non-hyphenated arguments
        // following it... YUM!
        // e.g., --foo apple banana cat becomes [&quot;apple&quot;, &quot;banana&quot;, &quot;cat&quot;]
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            // If both array and nargs are configured, enforce the nargs count:
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) &amp;&amp; !(/^(true|false)$/.test(next))) {
                argsToSet.push(true);
            }
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) &amp;&amp; /^-/.test(next) &amp;&amp; !negative.test(next) &amp;&amp; !isUnknownOptionAsArg(next))) {
                // for keys without value ==&gt; argsToSet remains an empty []
                // set user default value, if available
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
                }
            }
            else {
                // value in --option=value is eaten as is
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign));
                }
                for (let ii = i + 1; ii &lt; args.length; ii++) {
                    if ((!configuration[&#039;greedy-arrays&#039;] &amp;&amp; argsToSet.length &gt; 0) ||
                        (nargsCount &amp;&amp; typeof nargsCount === &#039;number&#039; &amp;&amp; argsToSet.length &gt;= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) &amp;&amp; !negative.test(next) &amp;&amp; !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next));
                }
            }
            // If both array and nargs are configured, create an error if less than
            // nargs positionals were found. NaN has special meaning, indicating
            // that at least one value is required (more are okay).
            if (typeof nargsCount === &#039;number&#039; &amp;&amp; ((nargsCount &amp;&amp; argsToSet.length &lt; nargsCount) ||
                (isNaN(nargsCount) &amp;&amp; argsToSet.length === 0))) {
                error = Error(__(&#039;Not enough arguments following: %s&#039;, key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val) {
            if (/-/.test(key) &amp;&amp; configuration[&#039;camel-case-expansion&#039;]) {
                const alias = key.split(&#039;.&#039;).map(function (prop) {
                    return camelCase(prop);
                }).join(&#039;.&#039;);
                addNewAlias(key, alias);
            }
            const value = processValue(key, val);
            const splitKey = key.split(&#039;.&#039;);
            setKey(argv, splitKey, value);
            // handle populating aliases of the full key
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function (x) {
                    const keyProperties = x.split(&#039;.&#039;);
                    setKey(argv, keyProperties, value);
                });
            }
            // handle populating aliases of the first element of the dot-notation key
            if (splitKey.length &gt; 1 &amp;&amp; configuration[&#039;dot-notation&#039;]) {
                ;
                (flags.aliases[splitKey[0]] || []).forEach(function (x) {
                    let keyProperties = x.split(&#039;.&#039;);
                    // expand alias with nested objects in key
                    const a = [].concat(splitKey);
                    a.shift(); // nuke the old key.
                    keyProperties = keyProperties.concat(a);
                    // populate alias only if is not already an alias of the full key
                    // (already populated above)
                    if (!(flags.aliases[key] || []).includes(keyProperties.join(&#039;.&#039;))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            // Set normalize getter and setter when key is in &#039;normalize&#039; but isn&#039;t an array
            if (checkAllAliases(key, flags.normalize) &amp;&amp; !checkAllAliases(key, flags.arrays)) {
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get() {
                            return val;
                        },
                        set(value) {
                            val = typeof value === &#039;string&#039; ? mixin.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] &amp;&amp; flags.aliases[key].length)) {
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] &amp;&amp; flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val) {
            // strings may be quoted, clean this up as we assign values.
            if (typeof val === &#039;string&#039; &amp;&amp;
                (val[0] === &quot;&#039;&quot; || val[0] === &#039;&quot;&#039;) &amp;&amp;
                val[val.length - 1] === val[0]) {
                val = val.substring(1, val.length - 1);
            }
            // handle parsing boolean arguments --foo=true --bar false.
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === &#039;string&#039;)
                    val = val === &#039;true&#039;;
            }
            let value = Array.isArray(val)
                ? val.map(function (v) { return maybeCoerceNumber(key, v); })
                : maybeCoerceNumber(key, val);
            // increment a count given as arg (either no value or value parsed as boolean)
            if (checkAllAliases(key, flags.counts) &amp;&amp; (isUndefined(value) || typeof value === &#039;boolean&#039;)) {
                value = increment();
            }
            // Set normalized value when key is in &#039;normalize&#039; and in &#039;arrays&#039;
            if (checkAllAliases(key, flags.normalize) &amp;&amp; checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val))
                    value = val.map((val) =&gt; { return mixin.normalize(val); });
                else
                    value = mixin.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration[&#039;parse-positional-numbers&#039;] &amp;&amp; key === &#039;_&#039;)
                return value;
            if (!checkAllAliases(key, flags.strings) &amp;&amp; !checkAllAliases(key, flags.bools) &amp;&amp; !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) &amp;&amp; configuration[&#039;parse-numbers&#039;] &amp;&amp; (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));
                if (shouldCoerceNumber || (!isUndefined(value) &amp;&amp; checkAllAliases(key, flags.numbers))) {
                    value = Number(value);
                }
            }
            return value;
        }
        // set args from config.json file, this should be
        // applied last so that defaults can be applied.
        function setConfig(argv) {
            const configLookup = Object.create(null);
            // expand defaults/aliases, in-case any happen to reference
            // the config.json file.
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === &#039;function&#039;) {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            }
                            catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        }
                        else {
                            config = mixin.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    }
                    catch (ex) {
                        // Deno will receive a PermissionDenied error if an attempt is
                        // made to load config without the --allow-read flag:
                        if (ex.name === &#039;PermissionDenied&#039;)
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__(&#039;Invalid JSON config file: %s&#039;, configPath));
                    }
                }
            });
        }
        // set args from config object.
        // it recursively checks nested objects.
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function (key) {
                const value = config[key];
                const fullKey = prev ? prev + &#039;.&#039; + key : key;
                // if the value is an inner object and we have dot-notation
                // enabled, treat inner objects in config the same as
                // heavily nested dot notations (foo.bar.apple).
                if (typeof value === &#039;object&#039; &amp;&amp; value !== null &amp;&amp; !Array.isArray(value) &amp;&amp; configuration[&#039;dot-notation&#039;]) {
                    // if the value is an object but not an array, check nested object
                    setConfigObject(value, fullKey);
                }
                else {
                    // setting arguments via CLI takes precedence over
                    // values within the config file.
                    if (!hasKey(argv, fullKey.split(&#039;.&#039;)) || (checkAllAliases(fullKey, flags.arrays) &amp;&amp; configuration[&#039;combine-arrays&#039;])) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        // set all config objects passed in opts
        function setConfigObjects() {
            if (typeof configObjects !== &#039;undefined&#039;) {
                configObjects.forEach(function (configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === &#039;undefined&#039;)
                return;
            const prefix = typeof envPrefix === &#039;string&#039; ? envPrefix : &#039;&#039;;
            const env = mixin.env();
            Object.keys(env).forEach(function (envVar) {
                if (prefix === &#039;&#039; || envVar.lastIndexOf(prefix, 0) === 0) {
                    // get array of nested keys and convert them to camel case
                    const keys = envVar.split(&#039;__&#039;).map(function (key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if (((configOnly &amp;&amp; flags.configs[keys.join(&#039;.&#039;)]) || !configOnly) &amp;&amp; !hasKey(argv, keys)) {
                        setArg(keys.join(&#039;.&#039;), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) {
                if (!applied.has(key)) { // If we haven&#039;t already coerced this option via one of its aliases
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === &#039;function&#039;) {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali =&gt; {
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        }
                        catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key) =&gt; {
                // don&#039;t set placeholder keys for dot notation options &#039;foo.bar&#039;.
                if (~key.indexOf(&#039;.&#039;))
                    return;
                if (typeof argv[key] === &#039;undefined&#039;)
                    argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function (key) {
                if (!hasKey(obj, key.split(&#039;.&#039;))) {
                    setKey(obj, key.split(&#039;.&#039;), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) {
                        if (hasKey(obj, x.split(&#039;.&#039;)))
                            return;
                        setKey(obj, x.split(&#039;.&#039;), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration[&#039;dot-notation&#039;])
                keys = [keys.join(&#039;.&#039;)];
            keys.slice(0, -1).forEach(function (key) {
                o = (o[key] || {});
            });
            const key = keys[keys.length - 1];
            if (typeof o !== &#039;object&#039;)
                return false;
            else
                return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration[&#039;dot-notation&#039;])
                keys = [keys.join(&#039;.&#039;)];
            keys.slice(0, -1).forEach(function (key) {
                // TODO(bcoe): in the next major version of yargs, switch to
                // Object.create(null) for dot notation:
                key = sanitizeKey(key);
                if (typeof o === &#039;object&#039; &amp;&amp; o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== &#039;object&#039; || Array.isArray(o[key])) {
                    // ensure that o[key] is an array, and that the last item is an empty object.
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    }
                    else {
                        o[key] = [o[key], {}];
                    }
                    // we want to update the empty object at the end of the o[key] array, so set o to that object
                    o = o[key][o[key].length - 1];
                }
                else {
                    o = o[key];
                }
            });
            // TODO(bcoe): in the next major version of yargs, switch to
            // Object.create(null) for dot notation:
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join(&#039;.&#039;), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration[&#039;duplicate-arguments-array&#039;];
            // nargs has higher priority than duplicate
            if (!duplicate &amp;&amp; checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if ((!isUndefined(o[key]) &amp;&amp; flags.nargs[key] === 1) || (Array.isArray(o[key]) &amp;&amp; o[key].length === flags.nargs[key])) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            }
            else if (Array.isArray(o[key])) {
                if (duplicate &amp;&amp; isTypeArray &amp;&amp; isValueArray) {
                    o[key] = configuration[&#039;flatten-duplicate-arrays&#039;] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
                }
                else if (!duplicate &amp;&amp; Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                }
                else {
                    o[key] = o[key].concat([value]);
                }
            }
            else if (o[key] === undefined &amp;&amp; isTypeArray) {
                o[key] = isValueArray ? value : [value];
            }
            else if (duplicate &amp;&amp; !(o[key] === undefined ||
                checkAllAliases(key, flags.counts) ||
                checkAllAliases(key, flags.bools))) {
                o[key] = [o[key], value];
            }
            else {
                o[key] = value;
            }
        }
        // extend the aliases list with inferred aliases.
        function extendAliases(...args) {
            args.forEach(function (obj) {
                Object.keys(obj || {}).forEach(function (key) {
                    // short-circuit if we&#039;ve already added a key
                    // to the aliases array, for example it might
                    // exist in both &#039;opts.default&#039; and &#039;opts.key&#039;.
                    if (flags.aliases[key])
                        return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    // For &quot;--option-name&quot;, also set argv.optionName
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (/-/.test(x) &amp;&amp; configuration[&#039;camel-case-expansion&#039;]) {
                            const c = camelCase(x);
                            if (c !== key &amp;&amp; flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    // For &quot;--optionName&quot;, also set argv[&#039;option-name&#039;]
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (x.length &gt; 1 &amp;&amp; /[A-Z]/.test(x) &amp;&amp; configuration[&#039;camel-case-expansion&#039;]) {
                            const c = decamelize(x, &#039;-&#039;);
                            if (c !== key &amp;&amp; flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function (x) {
                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find(key =&gt; keys.includes(key));
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map(k =&gt; flags[k]));
            return toCheck.some(function (flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function (pattern) {
                const match = arg.match(pattern);
                return match &amp;&amp; hasAnyFlag(match[1]);
            });
        }
        // based on a simplified version of the short flag group parsing logic
        function hasAllShortFlags(arg) {
            // if this is a negative number, or doesn&#039;t start with a single hyphen, it&#039;s not a short flag group
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split(&#039;&#039;);
            for (let j = 0; j &lt; letters.length; j++) {
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if ((letters[j + 1] &amp;&amp; letters[j + 1] === &#039;=&#039;) ||
                    next === &#039;-&#039; ||
                    (/[A-Za-z]/.test(letters[j]) &amp;&amp; /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
                    (letters[j + 1] &amp;&amp; letters[j + 1].match(/\W/))) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration[&#039;unknown-options-as-args&#039;] &amp;&amp; isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            arg = arg.replace(/^-{3,}/, &#039;--&#039;);
            // ignore negative numbers
            if (arg.match(negative)) {
                return false;
            }
            // if this is a short option group and all of them are configured, it isn&#039;t unknown
            if (hasAllShortFlags(arg)) {
                return false;
            }
            // e.g. &#039;--count=2&#039;
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            // e.g. &#039;-a&#039; or &#039;--arg&#039;
            const normalFlag = /^-+([^=]+?)$/;
            // e.g. &#039;-a-&#039;
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            // e.g. &#039;-abc123&#039;
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            // e.g. &#039;-a/usr/local&#039;
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        // make a best effort to pick a default value
        // for an option based on name and type.
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) &amp;&amp;
                !checkAllAliases(key, flags.counts) &amp;&amp;
                `${key}` in defaults) {
                return defaults[key];
            }
            else {
                return defaultForType(guessType(key));
            }
        }
        // return a default value, given the type of a flag.,
        function defaultForType(type) {
            const def = {
                [DefaultValuesForTypeKey.BOOLEAN]: true,
                [DefaultValuesForTypeKey.STRING]: &#039;&#039;,
                [DefaultValuesForTypeKey.NUMBER]: undefined,
                [DefaultValuesForTypeKey.ARRAY]: []
            };
            return def[type];
        }
        // given a flag, enforce a default type.
        function guessType(key) {
            let type = DefaultValuesForTypeKey.BOOLEAN;
            if (checkAllAliases(key, flags.strings))
                type = DefaultValuesForTypeKey.STRING;
            else if (checkAllAliases(key, flags.numbers))
                type = DefaultValuesForTypeKey.NUMBER;
            else if (checkAllAliases(key, flags.bools))
                type = DefaultValuesForTypeKey.BOOLEAN;
            else if (checkAllAliases(key, flags.arrays))
                type = DefaultValuesForTypeKey.ARRAY;
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        // check user configuration settings for inconsistencies
        function checkConfiguration() {
            // count keys should not be set as array/narg
            Object.keys(flags.counts).find(key =&gt; {
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__(&#039;Invalid configuration: %s, opts.count excludes opts.array.&#039;, key));
                    return true;
                }
                else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__(&#039;Invalid configuration: %s, opts.count excludes opts.narg.&#039;, key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({}, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({}, defaulted),
            error: error,
            newAliases: Object.assign({}, newAliases)
        };
    }
}
// if any aliases reference each other, we should
// merge them together.
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    // turn alias lookup hash {key: [&#039;alias1&#039;, &#039;alias2&#039;]} into
    // a simple array [&#039;key&#039;, &#039;alias1&#039;, &#039;alias2&#039;]
    Object.keys(aliases).forEach(function (key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    // combine arrays until zero changes are
    // made in an iteration.
    while (change) {
        change = false;
        for (let i = 0; i &lt; aliasArrays.length; i++) {
            for (let ii = i + 1; ii &lt; aliasArrays.length; ii++) {
                const intersect = aliasArrays[i].filter(function (v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    // map arrays back to the hash-lookup (de-dupe while
    // we&#039;re at it).
    aliasArrays.forEach(function (aliasArray) {
        aliasArray = aliasArray.filter(function (v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined &amp;&amp; typeof lastAlias === &#039;string&#039;) {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey(key) {
    if (key === &#039;__proto__&#039;)
        return &#039;___proto___&#039;;
    return key;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
