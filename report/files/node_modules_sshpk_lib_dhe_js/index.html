<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sshpk/lib/dhe.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sshpk/lib/dhe.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">398</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">64.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.25</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2017 Joyent, Inc.

module.exports = {
	DiffieHellman: DiffieHellman,
	generateECDSA: generateECDSA,
	generateED25519: generateED25519
};

var assert = require(&#039;assert-plus&#039;);
var crypto = require(&#039;crypto&#039;);
var Buffer = require(&#039;safer-buffer&#039;).Buffer;
var algs = require(&#039;./algs&#039;);
var utils = require(&#039;./utils&#039;);
var nacl = require(&#039;tweetnacl&#039;);

var Key = require(&#039;./key&#039;);
var PrivateKey = require(&#039;./private-key&#039;);

var CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);

var ecdh = require(&#039;ecc-jsbn&#039;);
var ec = require(&#039;ecc-jsbn/lib/ec&#039;);
var jsbn = require(&#039;jsbn&#039;).BigInteger;

function DiffieHellman(key) {
	utils.assertCompatible(key, Key, [1, 4], &#039;key&#039;);
	this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
	this._algo = key.type;
	this._curve = key.curve;
	this._key = key;
	if (key.type === &#039;dsa&#039;) {
		if (!CRYPTO_HAVE_ECDH) {
			throw (new Error(&#039;Due to bugs in the node 0.10 &#039; +
			    &#039;crypto API, node 0.12.x or later is required &#039; +
			    &#039;to use DH&#039;));
		}
		this._dh = crypto.createDiffieHellman(
		    key.part.p.data, undefined,
		    key.part.g.data, undefined);
		this._p = key.part.p;
		this._g = key.part.g;
		if (this._isPriv)
			this._dh.setPrivateKey(key.part.x.data);
		this._dh.setPublicKey(key.part.y.data);

	} else if (key.type === &#039;ecdsa&#039;) {
		if (!CRYPTO_HAVE_ECDH) {
			this._ecParams = new X9ECParameters(this._curve);

			if (this._isPriv) {
				this._priv = new ECPrivate(
				    this._ecParams, key.part.d.data);
			}
			return;
		}

		var curve = {
			&#039;nistp256&#039;: &#039;prime256v1&#039;,
			&#039;nistp384&#039;: &#039;secp384r1&#039;,
			&#039;nistp521&#039;: &#039;secp521r1&#039;
		}[key.curve];
		this._dh = crypto.createECDH(curve);
		if (typeof (this._dh) !== &#039;object&#039; ||
		    typeof (this._dh.setPrivateKey) !== &#039;function&#039;) {
			CRYPTO_HAVE_ECDH = false;
			DiffieHellman.call(this, key);
			return;
		}
		if (this._isPriv)
			this._dh.setPrivateKey(key.part.d.data);
		this._dh.setPublicKey(key.part.Q.data);

	} else if (key.type === &#039;curve25519&#039;) {
		if (this._isPriv) {
			utils.assertCompatible(key, PrivateKey, [1, 5], &#039;key&#039;);
			this._priv = key.part.k.data;
		}

	} else {
		throw (new Error(&#039;DH not supported for &#039; + key.type + &#039; keys&#039;));
	}
}

DiffieHellman.prototype.getPublicKey = function () {
	if (this._isPriv)
		return (this._key.toPublic());
	return (this._key);
};

DiffieHellman.prototype.getPrivateKey = function () {
	if (this._isPriv)
		return (this._key);
	else
		return (undefined);
};
DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;

DiffieHellman.prototype._keyCheck = function (pk, isPub) {
	assert.object(pk, &#039;key&#039;);
	if (!isPub)
		utils.assertCompatible(pk, PrivateKey, [1, 3], &#039;key&#039;);
	utils.assertCompatible(pk, Key, [1, 4], &#039;key&#039;);

	if (pk.type !== this._algo) {
		throw (new Error(&#039;A &#039; + pk.type + &#039; key cannot be used in &#039; +
		    this._algo + &#039; Diffie-Hellman&#039;));
	}

	if (pk.curve !== this._curve) {
		throw (new Error(&#039;A key from the &#039; + pk.curve + &#039; curve &#039; +
		    &#039;cannot be used with a &#039; + this._curve +
		    &#039; Diffie-Hellman&#039;));
	}

	if (pk.type === &#039;dsa&#039;) {
		assert.deepEqual(pk.part.p, this._p,
		    &#039;DSA key prime does not match&#039;);
		assert.deepEqual(pk.part.g, this._g,
		    &#039;DSA key generator does not match&#039;);
	}
};

DiffieHellman.prototype.setKey = function (pk) {
	this._keyCheck(pk);

	if (pk.type === &#039;dsa&#039;) {
		this._dh.setPrivateKey(pk.part.x.data);
		this._dh.setPublicKey(pk.part.y.data);

	} else if (pk.type === &#039;ecdsa&#039;) {
		if (CRYPTO_HAVE_ECDH) {
			this._dh.setPrivateKey(pk.part.d.data);
			this._dh.setPublicKey(pk.part.Q.data);
		} else {
			this._priv = new ECPrivate(
			    this._ecParams, pk.part.d.data);
		}

	} else if (pk.type === &#039;curve25519&#039;) {
		var k = pk.part.k;
		if (!pk.part.k)
			k = pk.part.r;
		this._priv = k.data;
		if (this._priv[0] === 0x00)
			this._priv = this._priv.slice(1);
		this._priv = this._priv.slice(0, 32);
	}
	this._key = pk;
	this._isPriv = true;
};
DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;

DiffieHellman.prototype.computeSecret = function (otherpk) {
	this._keyCheck(otherpk, true);
	if (!this._isPriv)
		throw (new Error(&#039;DH exchange has not been initialized with &#039; +
		    &#039;a private key yet&#039;));

	var pub;
	if (this._algo === &#039;dsa&#039;) {
		return (this._dh.computeSecret(
		    otherpk.part.y.data));

	} else if (this._algo === &#039;ecdsa&#039;) {
		if (CRYPTO_HAVE_ECDH) {
			return (this._dh.computeSecret(
			    otherpk.part.Q.data));
		} else {
			pub = new ECPublic(
			    this._ecParams, otherpk.part.Q.data);
			return (this._priv.deriveSharedSecret(pub));
		}

	} else if (this._algo === &#039;curve25519&#039;) {
		pub = otherpk.part.A.data;
		while (pub[0] === 0x00 &amp;&amp; pub.length &gt; 32)
			pub = pub.slice(1);
		var priv = this._priv;
		assert.strictEqual(pub.length, 32);
		assert.strictEqual(priv.length, 32);

		var secret = nacl.box.before(new Uint8Array(pub),
		    new Uint8Array(priv));

		return (Buffer.from(secret));
	}

	throw (new Error(&#039;Invalid algorithm: &#039; + this._algo));
};

DiffieHellman.prototype.generateKey = function () {
	var parts = [];
	var priv, pub;
	if (this._algo === &#039;dsa&#039;) {
		this._dh.generateKeys();

		parts.push({name: &#039;p&#039;, data: this._p.data});
		parts.push({name: &#039;q&#039;, data: this._key.part.q.data});
		parts.push({name: &#039;g&#039;, data: this._g.data});
		parts.push({name: &#039;y&#039;, data: this._dh.getPublicKey()});
		parts.push({name: &#039;x&#039;, data: this._dh.getPrivateKey()});
		this._key = new PrivateKey({
			type: &#039;dsa&#039;,
			parts: parts
		});
		this._isPriv = true;
		return (this._key);

	} else if (this._algo === &#039;ecdsa&#039;) {
		if (CRYPTO_HAVE_ECDH) {
			this._dh.generateKeys();

			parts.push({name: &#039;curve&#039;,
			    data: Buffer.from(this._curve)});
			parts.push({name: &#039;Q&#039;, data: this._dh.getPublicKey()});
			parts.push({name: &#039;d&#039;, data: this._dh.getPrivateKey()});
			this._key = new PrivateKey({
				type: &#039;ecdsa&#039;,
				curve: this._curve,
				parts: parts
			});
			this._isPriv = true;
			return (this._key);

		} else {
			var n = this._ecParams.getN();
			var r = new jsbn(crypto.randomBytes(n.bitLength()));
			var n1 = n.subtract(jsbn.ONE);
			priv = r.mod(n1).add(jsbn.ONE);
			pub = this._ecParams.getG().multiply(priv);

			priv = Buffer.from(priv.toByteArray());
			pub = Buffer.from(this._ecParams.getCurve().
			    encodePointHex(pub), &#039;hex&#039;);

			this._priv = new ECPrivate(this._ecParams, priv);

			parts.push({name: &#039;curve&#039;,
			    data: Buffer.from(this._curve)});
			parts.push({name: &#039;Q&#039;, data: pub});
			parts.push({name: &#039;d&#039;, data: priv});

			this._key = new PrivateKey({
				type: &#039;ecdsa&#039;,
				curve: this._curve,
				parts: parts
			});
			this._isPriv = true;
			return (this._key);
		}

	} else if (this._algo === &#039;curve25519&#039;) {
		var pair = nacl.box.keyPair();
		priv = Buffer.from(pair.secretKey);
		pub = Buffer.from(pair.publicKey);
		priv = Buffer.concat([priv, pub]);
		assert.strictEqual(priv.length, 64);
		assert.strictEqual(pub.length, 32);

		parts.push({name: &#039;A&#039;, data: pub});
		parts.push({name: &#039;k&#039;, data: priv});
		this._key = new PrivateKey({
			type: &#039;curve25519&#039;,
			parts: parts
		});
		this._isPriv = true;
		return (this._key);
	}

	throw (new Error(&#039;Invalid algorithm: &#039; + this._algo));
};
DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;

/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */

function X9ECParameters(name) {
	var params = algs.curves[name];
	assert.object(params);

	var p = new jsbn(params.p);
	var a = new jsbn(params.a);
	var b = new jsbn(params.b);
	var n = new jsbn(params.n);
	var h = jsbn.ONE;
	var curve = new ec.ECCurveFp(p, a, b);
	var G = curve.decodePointHex(params.G.toString(&#039;hex&#039;));

	this.curve = curve;
	this.g = G;
	this.n = n;
	this.h = h;
}
X9ECParameters.prototype.getCurve = function () { return (this.curve); };
X9ECParameters.prototype.getG = function () { return (this.g); };
X9ECParameters.prototype.getN = function () { return (this.n); };
X9ECParameters.prototype.getH = function () { return (this.h); };

function ECPublic(params, buffer) {
	this._params = params;
	if (buffer[0] === 0x00)
		buffer = buffer.slice(1);
	this._pub = params.getCurve().decodePointHex(buffer.toString(&#039;hex&#039;));
}

function ECPrivate(params, buffer) {
	this._params = params;
	this._priv = new jsbn(utils.mpNormalize(buffer));
}
ECPrivate.prototype.deriveSharedSecret = function (pubKey) {
	assert.ok(pubKey instanceof ECPublic);
	var S = pubKey._pub.multiply(this._priv);
	return (Buffer.from(S.getX().toBigInteger().toByteArray()));
};

function generateED25519() {
	var pair = nacl.sign.keyPair();
	var priv = Buffer.from(pair.secretKey);
	var pub = Buffer.from(pair.publicKey);
	assert.strictEqual(priv.length, 64);
	assert.strictEqual(pub.length, 32);

	var parts = [];
	parts.push({name: &#039;A&#039;, data: pub});
	parts.push({name: &#039;k&#039;, data: priv.slice(0, 32)});
	var key = new PrivateKey({
		type: &#039;ed25519&#039;,
		parts: parts
	});
	return (key);
}

/* Generates a new ECDSA private key on a given curve. */
function generateECDSA(curve) {
	var parts = [];
	var key;

	if (CRYPTO_HAVE_ECDH) {
		/*
		 * Node crypto doesn&#039;t expose key generation directly, but the
		 * ECDH instances can generate keys. It turns out this just
		 * calls into the OpenSSL generic key generator, and we can
		 * read its output happily without doing an actual DH. So we
		 * use that here.
		 */
		var osCurve = {
			&#039;nistp256&#039;: &#039;prime256v1&#039;,
			&#039;nistp384&#039;: &#039;secp384r1&#039;,
			&#039;nistp521&#039;: &#039;secp521r1&#039;
		}[curve];

		var dh = crypto.createECDH(osCurve);
		dh.generateKeys();

		parts.push({name: &#039;curve&#039;,
		    data: Buffer.from(curve)});
		parts.push({name: &#039;Q&#039;, data: dh.getPublicKey()});
		parts.push({name: &#039;d&#039;, data: dh.getPrivateKey()});

		key = new PrivateKey({
			type: &#039;ecdsa&#039;,
			curve: curve,
			parts: parts
		});
		return (key);
	} else {

		var ecParams = new X9ECParameters(curve);

		/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */
		var n = ecParams.getN();
		/*
		 * The crypto.randomBytes() function can only give us whole
		 * bytes, so taking a nod from X9.62, we round up.
		 */
		var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
		var c = new jsbn(crypto.randomBytes(cByteLen));

		var n1 = n.subtract(jsbn.ONE);
		var priv = c.mod(n1).add(jsbn.ONE);
		var pub = ecParams.getG().multiply(priv);

		priv = Buffer.from(priv.toByteArray());
		pub = Buffer.from(ecParams.getCurve().
		    encodePointHex(pub), &#039;hex&#039;);

		parts.push({name: &#039;curve&#039;, data: Buffer.from(curve)});
		parts.push({name: &#039;Q&#039;, data: pub});
		parts.push({name: &#039;d&#039;, data: priv});

		key = new PrivateKey({
			type: &#039;ecdsa&#039;,
			curve: curve,
			parts: parts
		});
		return (key);
	}
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
