<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/json5/lib/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/json5/lib/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1115</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">102.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.56</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">const util = require(&#039;./util&#039;)

let source
let parseState
let stack
let pos
let line
let column
let token
let key
let root

module.exports = function parse (text, reviver) {
    source = String(text)
    parseState = &#039;start&#039;
    stack = []
    pos = 0
    line = 1
    column = 0
    token = undefined
    key = undefined
    root = undefined

    do {
        token = lex()

        // This code is unreachable.
        // if (!parseStates[parseState]) {
        //     throw invalidParseState()
        // }

        parseStates[parseState]()
    } while (token.type !== &#039;eof&#039;)

    if (typeof reviver === &#039;function&#039;) {
        return internalize({&#039;&#039;: root}, &#039;&#039;, reviver)
    }

    return root
}

function internalize (holder, name, reviver) {
    const value = holder[name]
    if (value != null &amp;&amp; typeof value === &#039;object&#039;) {
        if (Array.isArray(value)) {
            for (let i = 0; i &lt; value.length; i++) {
                const key = String(i)
                const replacement = internalize(value, key, reviver)
                if (replacement === undefined) {
                    delete value[key]
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    })
                }
            }
        } else {
            for (const key in value) {
                const replacement = internalize(value, key, reviver)
                if (replacement === undefined) {
                    delete value[key]
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    })
                }
            }
        }
    }

    return reviver.call(holder, name, value)
}

let lexState
let buffer
let doubleQuote
let sign
let c

function lex () {
    lexState = &#039;default&#039;
    buffer = &#039;&#039;
    doubleQuote = false
    sign = 1

    for (;;) {
        c = peek()

        // This code is unreachable.
        // if (!lexStates[lexState]) {
        //     throw invalidLexState(lexState)
        // }

        const token = lexStates[lexState]()
        if (token) {
            return token
        }
    }
}

function peek () {
    if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos))
    }
}

function read () {
    const c = peek()

    if (c === &#039;\n&#039;) {
        line++
        column = 0
    } else if (c) {
        column += c.length
    } else {
        column++
    }

    if (c) {
        pos += c.length
    }

    return c
}

const lexStates = {
    default () {
        switch (c) {
        case &#039;\t&#039;:
        case &#039;\v&#039;:
        case &#039;\f&#039;:
        case &#039; &#039;:
        case &#039;\u00A0&#039;:
        case &#039;\uFEFF&#039;:
        case &#039;\n&#039;:
        case &#039;\r&#039;:
        case &#039;\u2028&#039;:
        case &#039;\u2029&#039;:
            read()
            return

        case &#039;/&#039;:
            read()
            lexState = &#039;comment&#039;
            return

        case undefined:
            read()
            return newToken(&#039;eof&#039;)
        }

        if (util.isSpaceSeparator(c)) {
            read()
            return
        }

        // This code is unreachable.
        // if (!lexStates[parseState]) {
        //     throw invalidLexState(parseState)
        // }

        return lexStates[parseState]()
    },

    comment () {
        switch (c) {
        case &#039;*&#039;:
            read()
            lexState = &#039;multiLineComment&#039;
            return

        case &#039;/&#039;:
            read()
            lexState = &#039;singleLineComment&#039;
            return
        }

        throw invalidChar(read())
    },

    multiLineComment () {
        switch (c) {
        case &#039;*&#039;:
            read()
            lexState = &#039;multiLineCommentAsterisk&#039;
            return

        case undefined:
            throw invalidChar(read())
        }

        read()
    },

    multiLineCommentAsterisk () {
        switch (c) {
        case &#039;*&#039;:
            read()
            return

        case &#039;/&#039;:
            read()
            lexState = &#039;default&#039;
            return

        case undefined:
            throw invalidChar(read())
        }

        read()
        lexState = &#039;multiLineComment&#039;
    },

    singleLineComment () {
        switch (c) {
        case &#039;\n&#039;:
        case &#039;\r&#039;:
        case &#039;\u2028&#039;:
        case &#039;\u2029&#039;:
            read()
            lexState = &#039;default&#039;
            return

        case undefined:
            read()
            return newToken(&#039;eof&#039;)
        }

        read()
    },

    value () {
        switch (c) {
        case &#039;{&#039;:
        case &#039;[&#039;:
            return newToken(&#039;punctuator&#039;, read())

        case &#039;n&#039;:
            read()
            literal(&#039;ull&#039;)
            return newToken(&#039;null&#039;, null)

        case &#039;t&#039;:
            read()
            literal(&#039;rue&#039;)
            return newToken(&#039;boolean&#039;, true)

        case &#039;f&#039;:
            read()
            literal(&#039;alse&#039;)
            return newToken(&#039;boolean&#039;, false)

        case &#039;-&#039;:
        case &#039;+&#039;:
            if (read() === &#039;-&#039;) {
                sign = -1
            }

            lexState = &#039;sign&#039;
            return

        case &#039;.&#039;:
            buffer = read()
            lexState = &#039;decimalPointLeading&#039;
            return

        case &#039;0&#039;:
            buffer = read()
            lexState = &#039;zero&#039;
            return

        case &#039;1&#039;:
        case &#039;2&#039;:
        case &#039;3&#039;:
        case &#039;4&#039;:
        case &#039;5&#039;:
        case &#039;6&#039;:
        case &#039;7&#039;:
        case &#039;8&#039;:
        case &#039;9&#039;:
            buffer = read()
            lexState = &#039;decimalInteger&#039;
            return

        case &#039;I&#039;:
            read()
            literal(&#039;nfinity&#039;)
            return newToken(&#039;numeric&#039;, Infinity)

        case &#039;N&#039;:
            read()
            literal(&#039;aN&#039;)
            return newToken(&#039;numeric&#039;, NaN)

        case &#039;&quot;&#039;:
        case &quot;&#039;&quot;:
            doubleQuote = (read() === &#039;&quot;&#039;)
            buffer = &#039;&#039;
            lexState = &#039;string&#039;
            return
        }

        throw invalidChar(read())
    },

    identifierNameStartEscape () {
        if (c !== &#039;u&#039;) {
            throw invalidChar(read())
        }

        read()
        const u = unicodeEscape()
        switch (u) {
        case &#039;$&#039;:
        case &#039;_&#039;:
            break

        default:
            if (!util.isIdStartChar(u)) {
                throw invalidIdentifier()
            }

            break
        }

        buffer += u
        lexState = &#039;identifierName&#039;
    },

    identifierName () {
        switch (c) {
        case &#039;$&#039;:
        case &#039;_&#039;:
        case &#039;\u200C&#039;:
        case &#039;\u200D&#039;:
            buffer += read()
            return

        case &#039;\\&#039;:
            read()
            lexState = &#039;identifierNameEscape&#039;
            return
        }

        if (util.isIdContinueChar(c)) {
            buffer += read()
            return
        }

        return newToken(&#039;identifier&#039;, buffer)
    },

    identifierNameEscape () {
        if (c !== &#039;u&#039;) {
            throw invalidChar(read())
        }

        read()
        const u = unicodeEscape()
        switch (u) {
        case &#039;$&#039;:
        case &#039;_&#039;:
        case &#039;\u200C&#039;:
        case &#039;\u200D&#039;:
            break

        default:
            if (!util.isIdContinueChar(u)) {
                throw invalidIdentifier()
            }

            break
        }

        buffer += u
        lexState = &#039;identifierName&#039;
    },

    sign () {
        switch (c) {
        case &#039;.&#039;:
            buffer = read()
            lexState = &#039;decimalPointLeading&#039;
            return

        case &#039;0&#039;:
            buffer = read()
            lexState = &#039;zero&#039;
            return

        case &#039;1&#039;:
        case &#039;2&#039;:
        case &#039;3&#039;:
        case &#039;4&#039;:
        case &#039;5&#039;:
        case &#039;6&#039;:
        case &#039;7&#039;:
        case &#039;8&#039;:
        case &#039;9&#039;:
            buffer = read()
            lexState = &#039;decimalInteger&#039;
            return

        case &#039;I&#039;:
            read()
            literal(&#039;nfinity&#039;)
            return newToken(&#039;numeric&#039;, sign * Infinity)

        case &#039;N&#039;:
            read()
            literal(&#039;aN&#039;)
            return newToken(&#039;numeric&#039;, NaN)
        }

        throw invalidChar(read())
    },

    zero () {
        switch (c) {
        case &#039;.&#039;:
            buffer += read()
            lexState = &#039;decimalPoint&#039;
            return

        case &#039;e&#039;:
        case &#039;E&#039;:
            buffer += read()
            lexState = &#039;decimalExponent&#039;
            return

        case &#039;x&#039;:
        case &#039;X&#039;:
            buffer += read()
            lexState = &#039;hexadecimal&#039;
            return
        }

        return newToken(&#039;numeric&#039;, sign * 0)
    },

    decimalInteger () {
        switch (c) {
        case &#039;.&#039;:
            buffer += read()
            lexState = &#039;decimalPoint&#039;
            return

        case &#039;e&#039;:
        case &#039;E&#039;:
            buffer += read()
            lexState = &#039;decimalExponent&#039;
            return
        }

        if (util.isDigit(c)) {
            buffer += read()
            return
        }

        return newToken(&#039;numeric&#039;, sign * Number(buffer))
    },

    decimalPointLeading () {
        if (util.isDigit(c)) {
            buffer += read()
            lexState = &#039;decimalFraction&#039;
            return
        }

        throw invalidChar(read())
    },

    decimalPoint () {
        switch (c) {
        case &#039;e&#039;:
        case &#039;E&#039;:
            buffer += read()
            lexState = &#039;decimalExponent&#039;
            return
        }

        if (util.isDigit(c)) {
            buffer += read()
            lexState = &#039;decimalFraction&#039;
            return
        }

        return newToken(&#039;numeric&#039;, sign * Number(buffer))
    },

    decimalFraction () {
        switch (c) {
        case &#039;e&#039;:
        case &#039;E&#039;:
            buffer += read()
            lexState = &#039;decimalExponent&#039;
            return
        }

        if (util.isDigit(c)) {
            buffer += read()
            return
        }

        return newToken(&#039;numeric&#039;, sign * Number(buffer))
    },

    decimalExponent () {
        switch (c) {
        case &#039;+&#039;:
        case &#039;-&#039;:
            buffer += read()
            lexState = &#039;decimalExponentSign&#039;
            return
        }

        if (util.isDigit(c)) {
            buffer += read()
            lexState = &#039;decimalExponentInteger&#039;
            return
        }

        throw invalidChar(read())
    },

    decimalExponentSign () {
        if (util.isDigit(c)) {
            buffer += read()
            lexState = &#039;decimalExponentInteger&#039;
            return
        }

        throw invalidChar(read())
    },

    decimalExponentInteger () {
        if (util.isDigit(c)) {
            buffer += read()
            return
        }

        return newToken(&#039;numeric&#039;, sign * Number(buffer))
    },

    hexadecimal () {
        if (util.isHexDigit(c)) {
            buffer += read()
            lexState = &#039;hexadecimalInteger&#039;
            return
        }

        throw invalidChar(read())
    },

    hexadecimalInteger () {
        if (util.isHexDigit(c)) {
            buffer += read()
            return
        }

        return newToken(&#039;numeric&#039;, sign * Number(buffer))
    },

    string () {
        switch (c) {
        case &#039;\\&#039;:
            read()
            buffer += escape()
            return

        case &#039;&quot;&#039;:
            if (doubleQuote) {
                read()
                return newToken(&#039;string&#039;, buffer)
            }

            buffer += read()
            return

        case &quot;&#039;&quot;:
            if (!doubleQuote) {
                read()
                return newToken(&#039;string&#039;, buffer)
            }

            buffer += read()
            return

        case &#039;\n&#039;:
        case &#039;\r&#039;:
            throw invalidChar(read())

        case &#039;\u2028&#039;:
        case &#039;\u2029&#039;:
            separatorChar(c)
            break

        case undefined:
            throw invalidChar(read())
        }

        buffer += read()
    },

    start () {
        switch (c) {
        case &#039;{&#039;:
        case &#039;[&#039;:
            return newToken(&#039;punctuator&#039;, read())

        // This code is unreachable since the default lexState handles eof.
        // case undefined:
        //     return newToken(&#039;eof&#039;)
        }

        lexState = &#039;value&#039;
    },

    beforePropertyName () {
        switch (c) {
        case &#039;$&#039;:
        case &#039;_&#039;:
            buffer = read()
            lexState = &#039;identifierName&#039;
            return

        case &#039;\\&#039;:
            read()
            lexState = &#039;identifierNameStartEscape&#039;
            return

        case &#039;}&#039;:
            return newToken(&#039;punctuator&#039;, read())

        case &#039;&quot;&#039;:
        case &quot;&#039;&quot;:
            doubleQuote = (read() === &#039;&quot;&#039;)
            lexState = &#039;string&#039;
            return
        }

        if (util.isIdStartChar(c)) {
            buffer += read()
            lexState = &#039;identifierName&#039;
            return
        }

        throw invalidChar(read())
    },

    afterPropertyName () {
        if (c === &#039;:&#039;) {
            return newToken(&#039;punctuator&#039;, read())
        }

        throw invalidChar(read())
    },

    beforePropertyValue () {
        lexState = &#039;value&#039;
    },

    afterPropertyValue () {
        switch (c) {
        case &#039;,&#039;:
        case &#039;}&#039;:
            return newToken(&#039;punctuator&#039;, read())
        }

        throw invalidChar(read())
    },

    beforeArrayValue () {
        if (c === &#039;]&#039;) {
            return newToken(&#039;punctuator&#039;, read())
        }

        lexState = &#039;value&#039;
    },

    afterArrayValue () {
        switch (c) {
        case &#039;,&#039;:
        case &#039;]&#039;:
            return newToken(&#039;punctuator&#039;, read())
        }

        throw invalidChar(read())
    },

    end () {
        // This code is unreachable since it&#039;s handled by the default lexState.
        // if (c === undefined) {
        //     read()
        //     return newToken(&#039;eof&#039;)
        // }

        throw invalidChar(read())
    },
}

function newToken (type, value) {
    return {
        type,
        value,
        line,
        column,
    }
}

function literal (s) {
    for (const c of s) {
        const p = peek()

        if (p !== c) {
            throw invalidChar(read())
        }

        read()
    }
}

function escape () {
    const c = peek()
    switch (c) {
    case &#039;b&#039;:
        read()
        return &#039;\b&#039;

    case &#039;f&#039;:
        read()
        return &#039;\f&#039;

    case &#039;n&#039;:
        read()
        return &#039;\n&#039;

    case &#039;r&#039;:
        read()
        return &#039;\r&#039;

    case &#039;t&#039;:
        read()
        return &#039;\t&#039;

    case &#039;v&#039;:
        read()
        return &#039;\v&#039;

    case &#039;0&#039;:
        read()
        if (util.isDigit(peek())) {
            throw invalidChar(read())
        }

        return &#039;\0&#039;

    case &#039;x&#039;:
        read()
        return hexEscape()

    case &#039;u&#039;:
        read()
        return unicodeEscape()

    case &#039;\n&#039;:
    case &#039;\u2028&#039;:
    case &#039;\u2029&#039;:
        read()
        return &#039;&#039;

    case &#039;\r&#039;:
        read()
        if (peek() === &#039;\n&#039;) {
            read()
        }

        return &#039;&#039;

    case &#039;1&#039;:
    case &#039;2&#039;:
    case &#039;3&#039;:
    case &#039;4&#039;:
    case &#039;5&#039;:
    case &#039;6&#039;:
    case &#039;7&#039;:
    case &#039;8&#039;:
    case &#039;9&#039;:
        throw invalidChar(read())

    case undefined:
        throw invalidChar(read())
    }

    return read()
}

function hexEscape () {
    let buffer = &#039;&#039;
    let c = peek()

    if (!util.isHexDigit(c)) {
        throw invalidChar(read())
    }

    buffer += read()

    c = peek()
    if (!util.isHexDigit(c)) {
        throw invalidChar(read())
    }

    buffer += read()

    return String.fromCodePoint(parseInt(buffer, 16))
}

function unicodeEscape () {
    let buffer = &#039;&#039;
    let count = 4

    while (count-- &gt; 0) {
        const c = peek()
        if (!util.isHexDigit(c)) {
            throw invalidChar(read())
        }

        buffer += read()
    }

    return String.fromCodePoint(parseInt(buffer, 16))
}

const parseStates = {
    start () {
        if (token.type === &#039;eof&#039;) {
            throw invalidEOF()
        }

        push()
    },

    beforePropertyName () {
        switch (token.type) {
        case &#039;identifier&#039;:
        case &#039;string&#039;:
            key = token.value
            parseState = &#039;afterPropertyName&#039;
            return

        case &#039;punctuator&#039;:
            // This code is unreachable since it&#039;s handled by the lexState.
            // if (token.value !== &#039;}&#039;) {
            //     throw invalidToken()
            // }

            pop()
            return

        case &#039;eof&#039;:
            throw invalidEOF()
        }

        // This code is unreachable since it&#039;s handled by the lexState.
        // throw invalidToken()
    },

    afterPropertyName () {
        // This code is unreachable since it&#039;s handled by the lexState.
        // if (token.type !== &#039;punctuator&#039; || token.value !== &#039;:&#039;) {
        //     throw invalidToken()
        // }

        if (token.type === &#039;eof&#039;) {
            throw invalidEOF()
        }

        parseState = &#039;beforePropertyValue&#039;
    },

    beforePropertyValue () {
        if (token.type === &#039;eof&#039;) {
            throw invalidEOF()
        }

        push()
    },

    beforeArrayValue () {
        if (token.type === &#039;eof&#039;) {
            throw invalidEOF()
        }

        if (token.type === &#039;punctuator&#039; &amp;&amp; token.value === &#039;]&#039;) {
            pop()
            return
        }

        push()
    },

    afterPropertyValue () {
        // This code is unreachable since it&#039;s handled by the lexState.
        // if (token.type !== &#039;punctuator&#039;) {
        //     throw invalidToken()
        // }

        if (token.type === &#039;eof&#039;) {
            throw invalidEOF()
        }

        switch (token.value) {
        case &#039;,&#039;:
            parseState = &#039;beforePropertyName&#039;
            return

        case &#039;}&#039;:
            pop()
        }

        // This code is unreachable since it&#039;s handled by the lexState.
        // throw invalidToken()
    },

    afterArrayValue () {
        // This code is unreachable since it&#039;s handled by the lexState.
        // if (token.type !== &#039;punctuator&#039;) {
        //     throw invalidToken()
        // }

        if (token.type === &#039;eof&#039;) {
            throw invalidEOF()
        }

        switch (token.value) {
        case &#039;,&#039;:
            parseState = &#039;beforeArrayValue&#039;
            return

        case &#039;]&#039;:
            pop()
        }

        // This code is unreachable since it&#039;s handled by the lexState.
        // throw invalidToken()
    },

    end () {
        // This code is unreachable since it&#039;s handled by the lexState.
        // if (token.type !== &#039;eof&#039;) {
        //     throw invalidToken()
        // }
    },
}

function push () {
    let value

    switch (token.type) {
    case &#039;punctuator&#039;:
        switch (token.value) {
        case &#039;{&#039;:
            value = {}
            break

        case &#039;[&#039;:
            value = []
            break
        }

        break

    case &#039;null&#039;:
    case &#039;boolean&#039;:
    case &#039;numeric&#039;:
    case &#039;string&#039;:
        value = token.value
        break

    // This code is unreachable.
    // default:
    //     throw invalidToken()
    }

    if (root === undefined) {
        root = value
    } else {
        const parent = stack[stack.length - 1]
        if (Array.isArray(parent)) {
            parent.push(value)
        } else {
            Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true,
            })
        }
    }

    if (value !== null &amp;&amp; typeof value === &#039;object&#039;) {
        stack.push(value)

        if (Array.isArray(value)) {
            parseState = &#039;beforeArrayValue&#039;
        } else {
            parseState = &#039;beforePropertyName&#039;
        }
    } else {
        const current = stack[stack.length - 1]
        if (current == null) {
            parseState = &#039;end&#039;
        } else if (Array.isArray(current)) {
            parseState = &#039;afterArrayValue&#039;
        } else {
            parseState = &#039;afterPropertyValue&#039;
        }
    }
}

function pop () {
    stack.pop()

    const current = stack[stack.length - 1]
    if (current == null) {
        parseState = &#039;end&#039;
    } else if (Array.isArray(current)) {
        parseState = &#039;afterArrayValue&#039;
    } else {
        parseState = &#039;afterPropertyValue&#039;
    }
}

// This code is unreachable.
// function invalidParseState () {
//     return new Error(`JSON5: invalid parse state &#039;${parseState}&#039;`)
// }

// This code is unreachable.
// function invalidLexState (state) {
//     return new Error(`JSON5: invalid lex state &#039;${state}&#039;`)
// }

function invalidChar (c) {
    if (c === undefined) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
    }

    return syntaxError(`JSON5: invalid character &#039;${formatChar(c)}&#039; at ${line}:${column}`)
}

function invalidEOF () {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
}

// This code is unreachable.
// function invalidToken () {
//     if (token.type === &#039;eof&#039;) {
//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
//     }

//     const c = String.fromCodePoint(token.value.codePointAt(0))
//     return syntaxError(`JSON5: invalid character &#039;${formatChar(c)}&#039; at ${line}:${column}`)
// }

function invalidIdentifier () {
    column -= 5
    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)
}

function separatorChar (c) {
    console.warn(`JSON5: &#039;${formatChar(c)}&#039; in strings is not valid ECMAScript; consider escaping`)
}

function formatChar (c) {
    const replacements = {
        &quot;&#039;&quot;: &quot;\\&#039;&quot;,
        &#039;&quot;&#039;: &#039;\\&quot;&#039;,
        &#039;\\&#039;: &#039;\\\\&#039;,
        &#039;\b&#039;: &#039;\\b&#039;,
        &#039;\f&#039;: &#039;\\f&#039;,
        &#039;\n&#039;: &#039;\\n&#039;,
        &#039;\r&#039;: &#039;\\r&#039;,
        &#039;\t&#039;: &#039;\\t&#039;,
        &#039;\v&#039;: &#039;\\v&#039;,
        &#039;\0&#039;: &#039;\\0&#039;,
        &#039;\u2028&#039;: &#039;\\u2028&#039;,
        &#039;\u2029&#039;: &#039;\\u2029&#039;,
    }

    if (replacements[c]) {
        return replacements[c]
    }

    if (c &lt; &#039; &#039;) {
        const hexString = c.charCodeAt(0).toString(16)
        return &#039;\\x&#039; + (&#039;00&#039; + hexString).substring(hexString.length)
    }

    return c
}

function syntaxError (message) {
    const err = new SyntaxError(message)
    err.lineNumber = line
    err.columnNumber = column
    return err
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
