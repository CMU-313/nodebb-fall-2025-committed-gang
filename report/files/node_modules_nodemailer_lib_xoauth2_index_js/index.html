<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodemailer/lib/xoauth2/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodemailer/lib/xoauth2/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">377</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">54.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const Stream = require(&#039;stream&#039;).Stream;
const nmfetch = require(&#039;../fetch&#039;);
const crypto = require(&#039;crypto&#039;);
const shared = require(&#039;../shared&#039;);

/**
 * XOAUTH2 access_token generator for Gmail.
 * Create client ID for web applications in Google API console to use it.
 * See Offline Access for receiving the needed refreshToken for an user
 * https://developers.google.com/accounts/docs/OAuth2WebServer#offline
 *
 * Usage for generating access tokens with a custom method using provisionCallback:
 * provisionCallback(user, renew, callback)
 *   * user is the username to get the token for
 *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed
 *   * callback is the callback to run with (error, accessToken [, expires])
 *     * accessToken is a string
 *     * expires is an optional expire time in milliseconds
 * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself
 *
 * @constructor
 * @param {Object} options Client information for token generation
 * @param {String} options.user User e-mail address
 * @param {String} options.clientId Client ID value
 * @param {String} options.clientSecret Client secret value
 * @param {String} options.refreshToken Refresh token for an user
 * @param {String} options.accessUrl Endpoint for token generation, defaults to &#039;https://accounts.google.com/o/oauth2/token&#039;
 * @param {String} options.accessToken An existing valid accessToken
 * @param {String} options.privateKey Private key for JSW
 * @param {Number} options.expires Optional Access Token expire time in ms
 * @param {Number} options.timeout Optional TTL for Access Token in seconds
 * @param {Function} options.provisionCallback Function to run when a new access token is required
 */
class XOAuth2 extends Stream {
    constructor(options, logger) {
        super();

        this.options = options || {};

        if (options &amp;&amp; options.serviceClient) {
            if (!options.privateKey || !options.user) {
                setImmediate(() =&gt; this.emit(&#039;error&#039;, new Error(&#039;Options &quot;privateKey&quot; and &quot;user&quot; are required for service account!&#039;)));
                return;
            }

            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
        }

        this.logger = shared.getLogger(
            {
                logger
            },
            {
                component: this.options.component || &#039;OAuth2&#039;
            }
        );

        this.provisionCallback = typeof this.options.provisionCallback === &#039;function&#039; ? this.options.provisionCallback : false;

        this.options.accessUrl = this.options.accessUrl || &#039;https://accounts.google.com/o/oauth2/token&#039;;
        this.options.customHeaders = this.options.customHeaders || {};
        this.options.customParams = this.options.customParams || {};

        this.accessToken = this.options.accessToken || false;

        if (this.options.expires &amp;&amp; Number(this.options.expires)) {
            this.expires = this.options.expires;
        } else {
            let timeout = Math.max(Number(this.options.timeout) || 0, 0);
            this.expires = (timeout &amp;&amp; Date.now() + timeout * 1000) || 0;
        }
    }

    /**
     * Returns or generates (if previous has expired) a XOAuth2 token
     *
     * @param {Boolean} renew If false then use cached access token (if available)
     * @param {Function} callback Callback function with error object and token string
     */
    getToken(renew, callback) {
        if (!renew &amp;&amp; this.accessToken &amp;&amp; (!this.expires || this.expires &gt; Date.now())) {
            return callback(null, this.accessToken);
        }

        let generateCallback = (...args) =&gt; {
            if (args[0]) {
                this.logger.error(
                    {
                        err: args[0],
                        tnx: &#039;OAUTH2&#039;,
                        user: this.options.user,
                        action: &#039;renew&#039;
                    },
                    &#039;Failed generating new Access Token for %s&#039;,
                    this.options.user
                );
            } else {
                this.logger.info(
                    {
                        tnx: &#039;OAUTH2&#039;,
                        user: this.options.user,
                        action: &#039;renew&#039;
                    },
                    &#039;Generated new Access Token for %s&#039;,
                    this.options.user
                );
            }
            callback(...args);
        };

        if (this.provisionCallback) {
            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) =&gt; {
                if (!err &amp;&amp; accessToken) {
                    this.accessToken = accessToken;
                    this.expires = expires || 0;
                }
                generateCallback(err, accessToken);
            });
        } else {
            this.generateToken(generateCallback);
        }
    }

    /**
     * Updates token values
     *
     * @param {String} accessToken New access token
     * @param {Number} timeout Access token lifetime in seconds
     *
     * Emits &#039;token&#039;: { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
     */
    updateToken(accessToken, timeout) {
        this.accessToken = accessToken;
        timeout = Math.max(Number(timeout) || 0, 0);
        this.expires = (timeout &amp;&amp; Date.now() + timeout * 1000) || 0;

        this.emit(&#039;token&#039;, {
            user: this.options.user,
            accessToken: accessToken || &#039;&#039;,
            expires: this.expires
        });
    }

    /**
     * Generates a new XOAuth2 token with the credentials provided at initialization
     *
     * @param {Function} callback Callback function with error object and token string
     */
    generateToken(callback) {
        let urlOptions;
        let loggedUrlOptions;
        if (this.options.serviceClient) {
            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount
            let iat = Math.floor(Date.now() / 1000); // unix time
            let tokenData = {
                iss: this.options.serviceClient,
                scope: this.options.scope || &#039;https://mail.google.com/&#039;,
                sub: this.options.user,
                aud: this.options.accessUrl,
                iat,
                exp: iat + this.options.serviceRequestTimeout
            };
            let token;
            try {
                token = this.jwtSignRS256(tokenData);
            } catch (err) {
                return callback(new Error(&#039;Can\x27t generate token. Check your auth options&#039;));
            }

            urlOptions = {
                grant_type: &#039;urn:ietf:params:oauth:grant-type:jwt-bearer&#039;,
                assertion: token
            };

            loggedUrlOptions = {
                grant_type: &#039;urn:ietf:params:oauth:grant-type:jwt-bearer&#039;,
                assertion: tokenData
            };
        } else {
            if (!this.options.refreshToken) {
                return callback(new Error(&#039;Can\x27t create new access token for user&#039;));
            }

            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer
            urlOptions = {
                client_id: this.options.clientId || &#039;&#039;,
                client_secret: this.options.clientSecret || &#039;&#039;,
                refresh_token: this.options.refreshToken,
                grant_type: &#039;refresh_token&#039;
            };

            loggedUrlOptions = {
                client_id: this.options.clientId || &#039;&#039;,
                client_secret: (this.options.clientSecret || &#039;&#039;).substr(0, 6) + &#039;...&#039;,
                refresh_token: (this.options.refreshToken || &#039;&#039;).substr(0, 6) + &#039;...&#039;,
                grant_type: &#039;refresh_token&#039;
            };
        }

        Object.keys(this.options.customParams).forEach(key =&gt; {
            urlOptions[key] = this.options.customParams[key];
            loggedUrlOptions[key] = this.options.customParams[key];
        });

        this.logger.debug(
            {
                tnx: &#039;OAUTH2&#039;,
                user: this.options.user,
                action: &#039;generate&#039;
            },
            &#039;Requesting token using: %s&#039;,
            JSON.stringify(loggedUrlOptions)
        );

        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) =&gt; {
            let data;

            if (error) {
                return callback(error);
            }

            try {
                data = JSON.parse(body.toString());
            } catch (E) {
                return callback(E);
            }

            if (!data || typeof data !== &#039;object&#039;) {
                this.logger.debug(
                    {
                        tnx: &#039;OAUTH2&#039;,
                        user: this.options.user,
                        action: &#039;post&#039;
                    },
                    &#039;Response: %s&#039;,
                    (body || &#039;&#039;).toString()
                );
                return callback(new Error(&#039;Invalid authentication response&#039;));
            }

            let logData = {};
            Object.keys(data).forEach(key =&gt; {
                if (key !== &#039;access_token&#039;) {
                    logData[key] = data[key];
                } else {
                    logData[key] = (data[key] || &#039;&#039;).toString().substr(0, 6) + &#039;...&#039;;
                }
            });

            this.logger.debug(
                {
                    tnx: &#039;OAUTH2&#039;,
                    user: this.options.user,
                    action: &#039;post&#039;
                },
                &#039;Response: %s&#039;,
                JSON.stringify(logData)
            );

            if (data.error) {
                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2
                let errorMessage = data.error;
                if (data.error_description) {
                    errorMessage += &#039;: &#039; + data.error_description;
                }
                if (data.error_uri) {
                    errorMessage += &#039; (&#039; + data.error_uri + &#039;)&#039;;
                }
                return callback(new Error(errorMessage));
            }

            if (data.access_token) {
                this.updateToken(data.access_token, data.expires_in);
                return callback(null, this.accessToken);
            }

            return callback(new Error(&#039;No access token&#039;));
        });
    }

    /**
     * Converts an access_token and user id into a base64 encoded XOAuth2 token
     *
     * @param {String} [accessToken] Access token string
     * @return {String} Base64 encoded token for IMAP or SMTP login
     */
    buildXOAuth2Token(accessToken) {
        let authData = [&#039;user=&#039; + (this.options.user || &#039;&#039;), &#039;auth=Bearer &#039; + (accessToken || this.accessToken), &#039;&#039;, &#039;&#039;];
        return Buffer.from(authData.join(&#039;\x01&#039;), &#039;utf-8&#039;).toString(&#039;base64&#039;);
    }

    /**
     * Custom POST request handler.
     * This is only needed to keep paths short in Windows – usually this module
     * is a dependency of a dependency and if it tries to require something
     * like the request module the paths get way too long to handle for Windows.
     * As we do only a simple POST request we do not actually require complicated
     * logic support (no redirects, no nothing) anyway.
     *
     * @param {String} url Url to POST to
     * @param {String|Buffer} payload Payload to POST
     * @param {Function} callback Callback function with (err, buff)
     */
    postRequest(url, payload, params, callback) {
        let returned = false;

        let chunks = [];
        let chunklen = 0;

        let req = nmfetch(url, {
            method: &#039;post&#039;,
            headers: params.customHeaders,
            body: payload,
            allowErrorResponse: true
        });

        req.on(&#039;readable&#039;, () =&gt; {
            let chunk;
            while ((chunk = req.read()) !== null) {
                chunks.push(chunk);
                chunklen += chunk.length;
            }
        });

        req.once(&#039;error&#039;, err =&gt; {
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        });

        req.once(&#039;end&#039;, () =&gt; {
            if (returned) {
                return;
            }
            returned = true;
            return callback(null, Buffer.concat(chunks, chunklen));
        });
    }

    /**
     * Encodes a buffer or a string into Base64url format
     *
     * @param {Buffer|String} data The data to convert
     * @return {String} The encoded string
     */
    toBase64URL(data) {
        if (typeof data === &#039;string&#039;) {
            data = Buffer.from(data);
        }

        return data
            .toString(&#039;base64&#039;)
            .replace(/[=]+/g, &#039;&#039;) // remove &#039;=&#039;s
            .replace(/\+/g, &#039;-&#039;) // &#039;+&#039; → &#039;-&#039;
            .replace(/\//g, &#039;_&#039;); // &#039;/&#039; → &#039;_&#039;
    }

    /**
     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
     *
     * @param {Object} payload The payload to include in the generated token
     * @return {String} The generated and signed token
     */
    jwtSignRS256(payload) {
        payload = [&#039;{&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}&#039;, JSON.stringify(payload)].map(val =&gt; this.toBase64URL(val)).join(&#039;.&#039;);
        let signature = crypto.createSign(&#039;RSA-SHA256&#039;).update(payload).sign(this.options.privateKey);
        return payload + &#039;.&#039; + this.toBase64URL(signature);
    }
}

module.exports = XOAuth2;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
