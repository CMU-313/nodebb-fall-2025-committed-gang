<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/picomatch/lib/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/picomatch/lib/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">42.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1092</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">171.99</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.47</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const constants = require(&#039;./constants&#039;);
const utils = require(&#039;./utils&#039;);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) =&gt; {
  if (typeof options.expandRange === &#039;function&#039;) {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join(&#039;-&#039;)}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v =&gt; utils.escapeRegex(v)).join(&#039;..&#039;);
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) =&gt; {
  return `Missing ${type}: &quot;${char}&quot; - use &quot;\\\\${char}&quot; to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) =&gt; {
  if (typeof input !== &#039;string&#039;) {
    throw new TypeError(&#039;Expected a string&#039;);
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === &#039;number&#039; ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len &gt; max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: &#039;bos&#039;, value: &#039;&#039;, output: opts.prepend || &#039;&#039; };
  const tokens = [bos];

  const capture = opts.capture ? &#039;&#039; : &#039;?:&#039;;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts =&gt; {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? &#039;&#039; : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === &#039;boolean&#039;) {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: &#039;&#039;,
    output: &#039;&#039;,
    prefix: &#039;&#039;,
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () =&gt; state.index === len - 1;
  const peek = state.peek = (n = 1) =&gt; input[state.index + n];
  const advance = state.advance = () =&gt; input[++state.index] || &#039;&#039;;
  const remaining = () =&gt; input.slice(state.index + 1);
  const consume = (value = &#039;&#039;, num = 0) =&gt; {
    state.consumed += value;
    state.index += num;
  };

  const append = token =&gt; {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () =&gt; {
    let count = 1;

    while (peek() === &#039;!&#039; &amp;&amp; (peek(2) !== &#039;(&#039; || peek(3) === &#039;?&#039;)) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type =&gt; {
    state[type]++;
    stack.push(type);
  };

  const decrement = type =&gt; {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok =&gt; {
    if (prev.type === &#039;globstar&#039;) {
      const isBrace = state.braces &gt; 0 &amp;&amp; (tok.type === &#039;comma&#039; || tok.type === &#039;brace&#039;);
      const isExtglob = tok.extglob === true || (extglobs.length &amp;&amp; (tok.type === &#039;pipe&#039; || tok.type === &#039;paren&#039;));

      if (tok.type !== &#039;slash&#039; &amp;&amp; tok.type !== &#039;paren&#039; &amp;&amp; !isBrace &amp;&amp; !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = &#039;star&#039;;
        prev.value = &#039;*&#039;;
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length &amp;&amp; tok.type !== &#039;paren&#039;) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev &amp;&amp; prev.type === &#039;text&#039; &amp;&amp; tok.type === &#039;text&#039;) {
      prev.value += tok.value;
      prev.output = (prev.output || &#039;&#039;) + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) =&gt; {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: &#039;&#039; };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? &#039;(&#039; : &#039;&#039;) + token.open;

    increment(&#039;parens&#039;);
    push({ type, value, output: state.output ? &#039;&#039; : ONE_CHAR });
    push({ type: &#039;paren&#039;, extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token =&gt; {
    let output = token.close + (opts.capture ? &#039;)&#039; : &#039;&#039;);
    let rest;

    if (token.type === &#039;negate&#039;) {
      let extglobStar = star;

      if (token.inner &amp;&amp; token.inner.length &gt; 1 &amp;&amp; token.inner.includes(&#039;/&#039;)) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes(&#039;*&#039;) &amp;&amp; (rest = remaining()) &amp;&amp; /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === &#039;bos&#039;) {
        state.negatedExtglob = true;
      }
    }

    push({ type: &#039;paren&#039;, extglob: true, value, output });
    decrement(&#039;parens&#039;);
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false &amp;&amp; !/(^[*!]|[/()[\]{}&quot;])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) =&gt; {
      if (first === &#039;\\&#039;) {
        backslashes = true;
        return m;
      }

      if (first === &#039;?&#039;) {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : &#039;&#039;);
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : &#039;&#039;);
        }
        return QMARK.repeat(chars.length);
      }

      if (first === &#039;.&#039;) {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === &#039;*&#039;) {
        if (esc) {
          return esc + first + (rest ? star : &#039;&#039;);
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, &#039;&#039;);
      } else {
        output = output.replace(/\\+/g, m =&gt; {
          return m.length % 2 === 0 ? &#039;\\\\&#039; : (m ? &#039;\\&#039; : &#039;&#039;);
        });
      }
    }

    if (output === input &amp;&amp; opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === &#039;\u0000&#039;) {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === &#039;\\&#039;) {
      const next = peek();

      if (next === &#039;/&#039; &amp;&amp; opts.bash !== true) {
        continue;
      }

      if (next === &#039;.&#039; || next === &#039;;&#039;) {
        continue;
      }

      if (!next) {
        value += &#039;\\&#039;;
        push({ type: &#039;text&#039;, value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match &amp;&amp; match[0].length &gt; 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += &#039;\\&#039;;
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: &#039;text&#039;, value });
        continue;
      }
    }

    /**
     * If we&#039;re inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets &gt; 0 &amp;&amp; (value !== &#039;]&#039; || prev.value === &#039;[&#039; || prev.value === &#039;[^&#039;)) {
      if (opts.posix !== false &amp;&amp; value === &#039;:&#039;) {
        const inner = prev.value.slice(1);
        if (inner.includes(&#039;[&#039;)) {
          prev.posix = true;

          if (inner.includes(&#039;:&#039;)) {
            const idx = prev.value.lastIndexOf(&#039;[&#039;);
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output &amp;&amp; tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === &#039;[&#039; &amp;&amp; peek() !== &#039;:&#039;) || (value === &#039;-&#039; &amp;&amp; peek() === &#039;]&#039;)) {
        value = `\\${value}`;
      }

      if (value === &#039;]&#039; &amp;&amp; (prev.value === &#039;[&#039; || prev.value === &#039;[^&#039;)) {
        value = `\\${value}`;
      }

      if (opts.posix === true &amp;&amp; value === &#039;!&#039; &amp;&amp; prev.value === &#039;[&#039;) {
        value = &#039;^&#039;;
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we&#039;re inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 &amp;&amp; value !== &#039;&quot;&#039;) {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === &#039;&quot;&#039;) {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: &#039;text&#039;, value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === &#039;(&#039;) {
      increment(&#039;parens&#039;);
      push({ type: &#039;paren&#039;, value });
      continue;
    }

    if (value === &#039;)&#039;) {
      if (state.parens === 0 &amp;&amp; opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError(&#039;opening&#039;, &#039;(&#039;));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob &amp;&amp; state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: &#039;paren&#039;, value, output: state.parens ? &#039;)&#039; : &#039;\\)&#039; });
      decrement(&#039;parens&#039;);
      continue;
    }

    /**
     * Square brackets
     */

    if (value === &#039;[&#039;) {
      if (opts.nobracket === true || !remaining().includes(&#039;]&#039;)) {
        if (opts.nobracket !== true &amp;&amp; opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError(&#039;closing&#039;, &#039;]&#039;));
        }

        value = `\\${value}`;
      } else {
        increment(&#039;brackets&#039;);
      }

      push({ type: &#039;bracket&#039;, value });
      continue;
    }

    if (value === &#039;]&#039;) {
      if (opts.nobracket === true || (prev &amp;&amp; prev.type === &#039;bracket&#039; &amp;&amp; prev.value.length === 1)) {
        push({ type: &#039;text&#039;, value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError(&#039;opening&#039;, &#039;[&#039;));
        }

        push({ type: &#039;text&#039;, value, output: `\\${value}` });
        continue;
      }

      decrement(&#039;brackets&#039;);

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true &amp;&amp; prevValue[0] === &#039;^&#039; &amp;&amp; !prevValue.includes(&#039;/&#039;)) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === &#039;{&#039; &amp;&amp; opts.nobrace !== true) {
      increment(&#039;braces&#039;);

      const open = {
        type: &#039;brace&#039;,
        value,
        output: &#039;(&#039;,
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === &#039;}&#039;) {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: &#039;text&#039;, value, output: value });
        continue;
      }

      let output = &#039;)&#039;;

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i &gt;= 0; i--) {
          tokens.pop();
          if (arr[i].type === &#039;brace&#039;) {
            break;
          }
          if (arr[i].type !== &#039;dots&#039;) {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true &amp;&amp; brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = &#039;\\{&#039;;
        value = output = &#039;\\}&#039;;
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: &#039;brace&#039;, value, output });
      decrement(&#039;braces&#039;);
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === &#039;|&#039;) {
      if (extglobs.length &gt; 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: &#039;text&#039;, value });
      continue;
    }

    /**
     * Commas
     */

    if (value === &#039;,&#039;) {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace &amp;&amp; stack[stack.length - 1] === &#039;braces&#039;) {
        brace.comma = true;
        output = &#039;|&#039;;
      }

      push({ type: &#039;comma&#039;, value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === &#039;/&#039;) {
      // if the beginning of the glob is &quot;./&quot;, advance the start
      // to the current index, and don&#039;t add the &quot;./&quot; characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like &quot;!&quot; and &quot;.&quot; (not &quot;./&quot;)
      if (prev.type === &#039;dot&#039; &amp;&amp; state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = &#039;&#039;;
        state.output = &#039;&#039;;
        tokens.pop();
        prev = bos; // reset &quot;prev&quot; to the first token
        continue;
      }

      push({ type: &#039;slash&#039;, value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === &#039;.&#039;) {
      if (state.braces &gt; 0 &amp;&amp; prev.type === &#039;dot&#039;) {
        if (prev.value === &#039;.&#039;) prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = &#039;dots&#039;;
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 &amp;&amp; prev.type !== &#039;bos&#039; &amp;&amp; prev.type !== &#039;slash&#039;) {
        push({ type: &#039;text&#039;, value, output: DOT_LITERAL });
        continue;
      }

      push({ type: &#039;dot&#039;, value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === &#039;?&#039;) {
      const isGroup = prev &amp;&amp; prev.value === &#039;(&#039;;
      if (!isGroup &amp;&amp; opts.noextglob !== true &amp;&amp; peek() === &#039;(&#039; &amp;&amp; peek(2) !== &#039;?&#039;) {
        extglobOpen(&#039;qmark&#039;, value);
        continue;
      }

      if (prev &amp;&amp; prev.type === &#039;paren&#039;) {
        const next = peek();
        let output = value;

        if (next === &#039;&lt;&#039; &amp;&amp; !utils.supportsLookbehinds()) {
          throw new Error(&#039;Node.js v10 or higher is required for regex lookbehinds&#039;);
        }

        if ((prev.value === &#039;(&#039; &amp;&amp; !/[!=&lt;:]/.test(next)) || (next === &#039;&lt;&#039; &amp;&amp; !/&lt;([!=]|\w+&gt;)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: &#039;text&#039;, value, output });
        continue;
      }

      if (opts.dot !== true &amp;&amp; (prev.type === &#039;slash&#039; || prev.type === &#039;bos&#039;)) {
        push({ type: &#039;qmark&#039;, value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: &#039;qmark&#039;, value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === &#039;!&#039;) {
      if (opts.noextglob !== true &amp;&amp; peek() === &#039;(&#039;) {
        if (peek(2) !== &#039;?&#039; || !/[!=&lt;:]/.test(peek(3))) {
          extglobOpen(&#039;negate&#039;, value);
          continue;
        }
      }

      if (opts.nonegate !== true &amp;&amp; state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === &#039;+&#039;) {
      if (opts.noextglob !== true &amp;&amp; peek() === &#039;(&#039; &amp;&amp; peek(2) !== &#039;?&#039;) {
        extglobOpen(&#039;plus&#039;, value);
        continue;
      }

      if ((prev &amp;&amp; prev.value === &#039;(&#039;) || opts.regex === false) {
        push({ type: &#039;plus&#039;, value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev &amp;&amp; (prev.type === &#039;bracket&#039; || prev.type === &#039;paren&#039; || prev.type === &#039;brace&#039;)) || state.parens &gt; 0) {
        push({ type: &#039;plus&#039;, value });
        continue;
      }

      push({ type: &#039;plus&#039;, value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === &#039;@&#039;) {
      if (opts.noextglob !== true &amp;&amp; peek() === &#039;(&#039; &amp;&amp; peek(2) !== &#039;?&#039;) {
        push({ type: &#039;at&#039;, extglob: true, value, output: &#039;&#039; });
        continue;
      }

      push({ type: &#039;text&#039;, value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== &#039;*&#039;) {
      if (value === &#039;$&#039; || value === &#039;^&#039;) {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: &#039;text&#039;, value });
      continue;
    }

    /**
     * Stars
     */

    if (prev &amp;&amp; (prev.type === &#039;globstar&#039; || prev.star === true)) {
      prev.type = &#039;star&#039;;
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true &amp;&amp; /^\([^?]/.test(rest)) {
      extglobOpen(&#039;star&#039;, value);
      continue;
    }

    if (prev.type === &#039;star&#039;) {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === &#039;slash&#039; || prior.type === &#039;bos&#039;;
      const afterStar = before &amp;&amp; (before.type === &#039;star&#039; || before.type === &#039;globstar&#039;);

      if (opts.bash === true &amp;&amp; (!isStart || (rest[0] &amp;&amp; rest[0] !== &#039;/&#039;))) {
        push({ type: &#039;star&#039;, value, output: &#039;&#039; });
        continue;
      }

      const isBrace = state.braces &gt; 0 &amp;&amp; (prior.type === &#039;comma&#039; || prior.type === &#039;brace&#039;);
      const isExtglob = extglobs.length &amp;&amp; (prior.type === &#039;pipe&#039; || prior.type === &#039;paren&#039;);
      if (!isStart &amp;&amp; prior.type !== &#039;paren&#039; &amp;&amp; !isBrace &amp;&amp; !isExtglob) {
        push({ type: &#039;star&#039;, value, output: &#039;&#039; });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === &#039;/**&#039;) {
        const after = input[state.index + 4];
        if (after &amp;&amp; after !== &#039;/&#039;) {
          break;
        }
        rest = rest.slice(3);
        consume(&#039;/**&#039;, 3);
      }

      if (prior.type === &#039;bos&#039; &amp;&amp; eos()) {
        prev.type = &#039;globstar&#039;;
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === &#039;slash&#039; &amp;&amp; prior.prev.type !== &#039;bos&#039; &amp;&amp; !afterStar &amp;&amp; eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = &#039;globstar&#039;;
        prev.output = globstar(opts) + (opts.strictSlashes ? &#039;)&#039; : &#039;|$)&#039;);
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === &#039;slash&#039; &amp;&amp; prior.prev.type !== &#039;bos&#039; &amp;&amp; rest[0] === &#039;/&#039;) {
        const end = rest[1] !== void 0 ? &#039;|$&#039; : &#039;&#039;;

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = &#039;globstar&#039;;
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: &#039;slash&#039;, value: &#039;/&#039;, output: &#039;&#039; });
        continue;
      }

      if (prior.type === &#039;bos&#039; &amp;&amp; rest[0] === &#039;/&#039;) {
        prev.type = &#039;globstar&#039;;
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: &#039;slash&#039;, value: &#039;/&#039;, output: &#039;&#039; });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = &#039;globstar&#039;;
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: &#039;star&#039;, value, output: star };

    if (opts.bash === true) {
      token.output = &#039;.*?&#039;;
      if (prev.type === &#039;bos&#039; || prev.type === &#039;slash&#039;) {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev &amp;&amp; (prev.type === &#039;bracket&#039; || prev.type === &#039;paren&#039;) &amp;&amp; opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === &#039;slash&#039; || prev.type === &#039;dot&#039;) {
      if (prev.type === &#039;dot&#039;) {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== &#039;*&#039;) {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets &gt; 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError(&#039;closing&#039;, &#039;]&#039;));
    state.output = utils.escapeLast(state.output, &#039;[&#039;);
    decrement(&#039;brackets&#039;);
  }

  while (state.parens &gt; 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError(&#039;closing&#039;, &#039;)&#039;));
    state.output = utils.escapeLast(state.output, &#039;(&#039;);
    decrement(&#039;parens&#039;);
  }

  while (state.braces &gt; 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError(&#039;closing&#039;, &#039;}&#039;));
    state.output = utils.escapeLast(state.output, &#039;{&#039;);
    decrement(&#039;braces&#039;);
  }

  if (opts.strictSlashes !== true &amp;&amp; (prev.type === &#039;star&#039; || prev.type === &#039;bracket&#039;)) {
    push({ type: &#039;maybe_slash&#039;, value: &#039;&#039;, output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = &#039;&#039;;

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) =&gt; {
  const opts = { ...options };
  const max = typeof opts.maxLength === &#039;number&#039; ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len &gt; max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? &#039;&#039; : &#039;?:&#039;;
  const state = { negated: false, prefix: &#039;&#039; };
  let star = opts.bash === true ? &#039;.*?&#039; : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts =&gt; {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str =&gt; {
    switch (str) {
      case &#039;*&#039;:
        return `${nodot}${ONE_CHAR}${star}`;

      case &#039;.*&#039;:
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case &#039;*.*&#039;:
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case &#039;*/*&#039;:
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case &#039;**&#039;:
        return nodot + globstar(opts);

      case &#039;**/*&#039;:
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case &#039;**/*.*&#039;:
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case &#039;**/.*&#039;:
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source &amp;&amp; opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
