<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/database/hash.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/database/hash.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">76.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">682</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">58.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.68</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;


const async = require(&#039;async&#039;);
const assert = require(&#039;assert&#039;);
const db = require(&#039;../mocks/databasemock&#039;);

describe(&#039;Hash methods&#039;, () =&gt; {
	const testData = {
		name: &#039;baris&#039;,
		lastname: &#039;usakli&#039;,
		age: 99,
	};

	beforeEach((done) =&gt; {
		db.setObject(&#039;hashTestObject&#039;, testData, done);
	});

	describe(&#039;setObject()&#039;, () =&gt; {
		it(&#039;should create a object&#039;, (done) =&gt; {
			db.setObject(&#039;testObject1&#039;, { foo: &#039;baris&#039;, bar: 99 }, function (err) {
				assert.ifError(err);
				assert(arguments.length &lt; 2);
				done();
			});
		});

		it(&#039;should set two objects to same data&#039;, async () =&gt; {
			const data = { foo: &#039;baz&#039;, test: &#039;1&#039; };
			await db.setObject([&#039;multiObject1&#039;, &#039;multiObject2&#039;], data);
			const result = await db.getObjects([&#039;multiObject1&#039;, &#039;multiObject2&#039;]);
			assert.deepStrictEqual(result[0], data);
			assert.deepStrictEqual(result[1], data);
		});

		it(&#039;should do nothing if key is falsy&#039;, (done) =&gt; {
			db.setObject(&#039;&#039;, { foo: 1, derp: 2 }, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should do nothing if data is falsy&#039;, (done) =&gt; {
			db.setObject(&#039;falsy&#039;, null, (err) =&gt; {
				assert.ifError(err);
				db.exists(&#039;falsy&#039;, (err, exists) =&gt; {
					assert.ifError(err);
					assert.equal(exists, false);
					done();
				});
			});
		});

		it(&#039;should not error if a key is empty string&#039;, (done) =&gt; {
			db.setObject(&#039;emptyField&#039;, { &#039;&#039;: &#039;&#039;, b: 1 }, (err) =&gt; {
				assert.ifError(err);
				db.getObject(&#039;emptyField&#039;, (err, data) =&gt; {
					assert.ifError(err);
					done();
				});
			});
		});

		it(&#039;should work for field names with &quot;.&quot; in them&#039;, (done) =&gt; {
			db.setObject(&#039;dotObject&#039;, { &#039;my.dot.field&#039;: &#039;foo&#039; }, (err) =&gt; {
				assert.ifError(err);
				db.getObject(&#039;dotObject&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data[&#039;my.dot.field&#039;], &#039;foo&#039;);
					done();
				});
			});
		});

		it(&#039;should set multiple keys to different objects&#039;, async () =&gt; {
			await db.setObjectBulk([
				[&#039;bulkKey1&#039;, { foo: &#039;1&#039; }],
				[&#039;bulkKey2&#039;, { baz: &#039;baz&#039; }],
			]);
			const result = await db.getObjects([&#039;bulkKey1&#039;, &#039;bulkKey2&#039;]);
			assert.deepStrictEqual(result, [{ foo: &#039;1&#039; }, { baz: &#039;baz&#039; }]);
		});

		it(&#039;should not error if object is empty&#039;, async () =&gt; {
			await db.setObjectBulk([
				[&#039;bulkKey3&#039;, { foo: &#039;1&#039; }],
				[&#039;bulkKey4&#039;, { }],
			]);
			const result = await db.getObjects([&#039;bulkKey3&#039;, &#039;bulkKey4&#039;]);
			assert.deepStrictEqual(result, [{ foo: &#039;1&#039; }, null]);
		});

		it(&#039;should update existing object on second call&#039;, async () =&gt; {
			await db.setObjectBulk([[&#039;bulkKey3.5&#039;, { foo: &#039;1&#039; }]]);
			await db.setObjectBulk([[&#039;bulkKey3.5&#039;, { baz: &#039;2&#039; }]]);
			const result = await db.getObject(&#039;bulkKey3.5&#039;);
			assert.deepStrictEqual(result, { foo: &#039;1&#039;, baz: &#039;2&#039; });
		});

		it(&#039;should not error if object is empty&#039;, async () =&gt; {
			await db.setObjectBulk([[&#039;bulkKey5&#039;, {}]]);
			const result = await db.getObjects([&#039;bulkKey5&#039;]);
			assert.deepStrictEqual(result, [null]);
		});

		it(&#039;should not error if object is empty&#039;, async () =&gt; {
			const keys = [&#039;bulkKey6&#039;, &#039;bulkKey7&#039;];
			const data = {};

			await db.setObject(keys, data);
			const result = await db.getObjects(keys);
			assert.deepStrictEqual(result, [null, null]);
		});

		it(&#039;should not error if object is empty&#039;, async () =&gt; {
			await db.setObject(&#039;emptykey&#039;, {});
			const result = await db.getObject(&#039;emptykey&#039;);
			assert.deepStrictEqual(result, null);
		});
	});

	describe(&#039;setObjectField()&#039;, () =&gt; {
		it(&#039;should create a new object with field&#039;, (done) =&gt; {
			db.setObjectField(&#039;testObject2&#039;, &#039;name&#039;, &#039;ginger&#039;, function (err) {
				assert.ifError(err);
				assert(arguments.length &lt; 2);
				done();
			});
		});

		it(&#039;should add a new field to an object&#039;, (done) =&gt; {
			db.setObjectField(&#039;testObject2&#039;, &#039;type&#039;, &#039;cat&#039;, function (err) {
				assert.ifError(err, null);
				assert(arguments.length &lt; 2);
				done();
			});
		});

		it(&#039;should set two objects fields to same data&#039;, async () =&gt; {
			const data = { foo: &#039;baz&#039;, test: &#039;1&#039; };
			await db.setObjectField([&#039;multiObject1&#039;, &#039;multiObject2&#039;], &#039;myField&#039;, &#039;2&#039;);
			const result = await db.getObjects([&#039;multiObject1&#039;, &#039;multiObject2&#039;]);
			assert.deepStrictEqual(result[0].myField, &#039;2&#039;);
			assert.deepStrictEqual(result[1].myField, &#039;2&#039;);
		});

		it(&#039;should work for field names with &quot;.&quot; in them&#039;, (done) =&gt; {
			db.setObjectField(&#039;dotObject2&#039;, &#039;my.dot.field&#039;, &#039;foo2&#039;, (err) =&gt; {
				assert.ifError(err);
				db.getObjectField(&#039;dotObject2&#039;, &#039;my.dot.field&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.equal(value, &#039;foo2&#039;);
					done();
				});
			});
		});

		it(&#039;should work for field names with &quot;.&quot; in them when they are cached&#039;, async () =&gt; {
			await db.setObjectField(&#039;dotObject3&#039;, &#039;my.dot.field&#039;, &#039;foo2&#039;);
			const data = await db.getObject(&#039;dotObject3&#039;);
			assert.strictEqual(data[&#039;my.dot.field&#039;], &#039;foo2&#039;);
			const value = await db.getObjectField(&#039;dotObject3&#039;, &#039;my.dot.field&#039;);
			assert.equal(value, &#039;foo2&#039;);
		});

		it(&#039;should work for fields that start with $&#039;, async () =&gt; {
			await db.setObjectField(&#039;dollarsign&#039;, &#039;$someField&#039;, &#039;foo&#039;);
			assert.strictEqual(await db.getObjectField(&#039;dollarsign&#039;, &#039;$someField&#039;), &#039;foo&#039;);
			assert.strictEqual(await db.isObjectField(&#039;dollarsign&#039;, &#039;$someField&#039;), true);
			assert.strictEqual(await db.isObjectField(&#039;dollarsign&#039;, &#039;$doesntexist&#039;), false);
			await db.deleteObjectField(&#039;dollarsign&#039;, &#039;$someField&#039;);
			assert.strictEqual(await db.isObjectField(&#039;dollarsign&#039;, &#039;$someField&#039;), false);
		});
	});

	describe(&#039;getObject()&#039;, () =&gt; {
		it(&#039;should return falsy if object does not exist&#039;, (done) =&gt; {
			db.getObject(&#039;doesnotexist&#039;, function (err, data) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!data, false);
				done();
			});
		});

		it(&#039;should retrieve an object&#039;, (done) =&gt; {
			db.getObject(&#039;hashTestObject&#039;, (err, data) =&gt; {
				assert.equal(err, null);
				assert.equal(data.name, testData.name);
				assert.equal(data.age, testData.age);
				assert.equal(data.lastname, &#039;usakli&#039;);
				done();
			});
		});

		it(&#039;should return null if key is falsy&#039;, (done) =&gt; {
			db.getObject(null, function (err, data) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(data, null);
				done();
			});
		});

		it(&#039;should return fields if given&#039;, async () =&gt; {
			const data = await db.getObject(&#039;hashTestObject&#039;, [&#039;name&#039;, &#039;age&#039;]);
			assert.strictEqual(data.name, &#039;baris&#039;);
			assert.strictEqual(parseInt(data.age, 10), 99);
		});
	});

	describe(&#039;getObjects()&#039;, () =&gt; {
		before((done) =&gt; {
			async.parallel([
				async.apply(db.setObject, &#039;testObject4&#039;, { name: &#039;baris&#039; }),
				async.apply(db.setObjectField, &#039;testObject5&#039;, &#039;name&#039;, &#039;ginger&#039;),
			], done);
		});

		it(&#039;should return 3 objects with correct data&#039;, (done) =&gt; {
			db.getObjects([&#039;testObject4&#039;, &#039;testObject5&#039;, &#039;doesnotexist&#039;], function (err, objects) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(objects) &amp;&amp; objects.length === 3, true);
				assert.equal(objects[0].name, &#039;baris&#039;);
				assert.equal(objects[1].name, &#039;ginger&#039;);
				assert.equal(!!objects[2], false);
				done();
			});
		});

		it(&#039;should return fields if given&#039;, async () =&gt; {
			await db.setObject(&#039;fieldsObj1&#039;, { foo: &#039;foo&#039;, baz: &#039;baz&#039;, herp: &#039;herp&#039; });
			await db.setObject(&#039;fieldsObj2&#039;, { foo: &#039;foo2&#039;, baz: &#039;baz2&#039;, herp: &#039;herp2&#039;, onlyin2: &#039;onlyin2&#039; });
			const data = await db.getObjects([&#039;fieldsObj1&#039;, &#039;fieldsObj2&#039;], [&#039;baz&#039;, &#039;doesnotexist&#039;, &#039;onlyin2&#039;]);
			assert.strictEqual(data[0].baz, &#039;baz&#039;);
			assert.strictEqual(data[0].doesnotexist, null);
			assert.strictEqual(data[0].onlyin2, null);
			assert.strictEqual(data[1].baz, &#039;baz2&#039;);
			assert.strictEqual(data[1].doesnotexist, null);
			assert.strictEqual(data[1].onlyin2, &#039;onlyin2&#039;);
		});
	});

	describe(&#039;getObjectField()&#039;, () =&gt; {
		it(&#039;should return falsy if object does not exist&#039;, (done) =&gt; {
			db.getObjectField(&#039;doesnotexist&#039;, &#039;fieldName&#039;, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!value, false);
				done();
			});
		});

		it(&#039;should return falsy if field does not exist&#039;, (done) =&gt; {
			db.getObjectField(&#039;hashTestObject&#039;, &#039;fieldName&#039;, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!value, false);
				done();
			});
		});

		it(&#039;should get an objects field&#039;, (done) =&gt; {
			db.getObjectField(&#039;hashTestObject&#039;, &#039;lastname&#039;, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, &#039;usakli&#039;);
				done();
			});
		});

		it(&#039;should return null if key is falsy&#039;, (done) =&gt; {
			db.getObjectField(null, &#039;test&#039;, function (err, data) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(data, null);
				done();
			});
		});

		it(&#039;should return null and not error&#039;, async () =&gt; {
			const data = await db.getObjectField(&#039;hashTestObject&#039;, [&#039;field1&#039;, &#039;field2&#039;]);
			assert.strictEqual(data, null);
		});
	});

	describe(&#039;getObjectFields()&#039;, () =&gt; {
		it(&#039;should return an object with falsy values&#039;, (done) =&gt; {
			db.getObjectFields(&#039;doesnotexist&#039;, [&#039;field1&#039;, &#039;field2&#039;], function (err, object) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(typeof object, &#039;object&#039;);
				assert.equal(!!object.field1, false);
				assert.equal(!!object.field2, false);
				done();
			});
		});

		it(&#039;should return an object with correct fields&#039;, (done) =&gt; {
			db.getObjectFields(&#039;hashTestObject&#039;, [&#039;lastname&#039;, &#039;age&#039;, &#039;field1&#039;], function (err, object) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(typeof object, &#039;object&#039;);
				assert.equal(object.lastname, &#039;usakli&#039;);
				assert.equal(object.age, 99);
				assert.equal(!!object.field1, false);
				done();
			});
		});

		it(&#039;should return null if key is falsy&#039;, (done) =&gt; {
			db.getObjectFields(null, [&#039;test&#039;, &#039;foo&#039;], function (err, data) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(data, null);
				done();
			});
		});
	});

	describe(&#039;getObjectsFields()&#039;, () =&gt; {
		before((done) =&gt; {
			async.parallel([
				async.apply(db.setObject, &#039;testObject8&#039;, { name: &#039;baris&#039;, age: 99 }),
				async.apply(db.setObject, &#039;testObject9&#039;, { name: &#039;ginger&#039;, age: 3 }),
			], done);
		});

		it(&#039;should return an array of objects with correct values&#039;, (done) =&gt; {
			db.getObjectsFields([&#039;testObject8&#039;, &#039;testObject9&#039;, &#039;doesnotexist&#039;], [&#039;name&#039;, &#039;age&#039;], function (err, objects) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(objects), true);
				assert.equal(objects.length, 3);
				assert.equal(objects[0].name, &#039;baris&#039;);
				assert.equal(objects[0].age, 99);
				assert.equal(objects[1].name, &#039;ginger&#039;);
				assert.equal(objects[1].age, 3);
				assert.equal(!!objects[2].name, false);
				done();
			});
		});

		it(&#039;should return undefined for all fields if object does not exist&#039;, (done) =&gt; {
			db.getObjectsFields([&#039;doesnotexist1&#039;, &#039;doesnotexist2&#039;], [&#039;name&#039;, &#039;age&#039;], (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				assert.equal(data[0].name, null);
				assert.equal(data[0].age, null);
				assert.equal(data[1].name, null);
				assert.equal(data[1].age, null);
				done();
			});
		});

		it(&#039;should return all fields if fields is empty array&#039;, async () =&gt; {
			const objects = await db.getObjectsFields([&#039;testObject8&#039;, &#039;testObject9&#039;, &#039;doesnotexist&#039;], []);
			assert(Array.isArray(objects));
			assert.strict(objects.length, 3);
			assert.strictEqual(objects[0].name, &#039;baris&#039;);
			assert.strictEqual(Number(objects[0].age), 99);
			assert.strictEqual(objects[1].name, &#039;ginger&#039;);
			assert.strictEqual(Number(objects[1].age), 3);
			assert.strictEqual(!!objects[2], false);
		});

		it(&#039;should return objects if fields is not an array&#039;, async () =&gt; {
			const objects = await db.getObjectsFields([&#039;testObject8&#039;, &#039;testObject9&#039;, &#039;doesnotexist&#039;], undefined);
			assert.strictEqual(objects[0].name, &#039;baris&#039;);
			assert.strictEqual(Number(objects[0].age), 99);
			assert.strictEqual(objects[1].name, &#039;ginger&#039;);
			assert.strictEqual(Number(objects[1].age), 3);
			assert.strictEqual(!!objects[2], false);
		});
	});

	describe(&#039;getObjectKeys()&#039;, () =&gt; {
		it(&#039;should return an empty array for a object that does not exist&#039;, (done) =&gt; {
			db.getObjectKeys(&#039;doesnotexist&#039;, function (err, keys) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(keys) &amp;&amp; keys.length === 0, true);
				done();
			});
		});

		it(&#039;should return an array of keys for the object\&#039;s fields&#039;, (done) =&gt; {
			db.getObjectKeys(&#039;hashTestObject&#039;, function (err, keys) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(keys) &amp;&amp; keys.length === 3, true);
				keys.forEach((key) =&gt; {
					assert.notEqual([&#039;name&#039;, &#039;lastname&#039;, &#039;age&#039;].indexOf(key), -1);
				});
				done();
			});
		});
	});

	describe(&#039;getObjectValues()&#039;, () =&gt; {
		it(&#039;should return an empty array for a object that does not exist&#039;, (done) =&gt; {
			db.getObjectValues(&#039;doesnotexist&#039;, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(values) &amp;&amp; values.length === 0, true);
				done();
			});
		});

		it(&#039;should return an array of values for the object\&#039;s fields&#039;, (done) =&gt; {
			db.getObjectValues(&#039;hashTestObject&#039;, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(Array.isArray(values) &amp;&amp; values.length === 3, true);
				assert.deepEqual([&#039;baris&#039;, &#039;usakli&#039;, 99].sort(), values.sort());
				done();
			});
		});
	});

	describe(&#039;isObjectField()&#039;, () =&gt; {
		it(&#039;should return false if object does not exist&#039;, (done) =&gt; {
			db.isObjectField(&#039;doesnotexist&#039;, &#039;field1&#039;, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, false);
				done();
			});
		});

		it(&#039;should return false if field does not exist&#039;, (done) =&gt; {
			db.isObjectField(&#039;hashTestObject&#039;, &#039;field1&#039;, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, false);
				done();
			});
		});

		it(&#039;should return true if field exists&#039;, (done) =&gt; {
			db.isObjectField(&#039;hashTestObject&#039;, &#039;name&#039;, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(value, true);
				done();
			});
		});

		it(&#039;should not error if field is falsy&#039;, async () =&gt; {
			const value = await db.isObjectField(&#039;hashTestObjectEmpty&#039;, &#039;&#039;);
			assert.strictEqual(value, false);
		});
	});


	describe(&#039;isObjectFields()&#039;, () =&gt; {
		it(&#039;should return an array of false if object does not exist&#039;, (done) =&gt; {
			db.isObjectFields(&#039;doesnotexist&#039;, [&#039;field1&#039;, &#039;field2&#039;], function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [false, false]);
				done();
			});
		});

		it(&#039;should return false if field does not exist&#039;, (done) =&gt; {
			db.isObjectFields(&#039;hashTestObject&#039;, [&#039;name&#039;, &#039;age&#039;, &#039;field1&#039;], function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [true, true, false]);
				done();
			});
		});

		it(&#039;should not error if one field is falsy&#039;, async () =&gt; {
			const values = await db.isObjectFields(&#039;hashTestObject&#039;, [&#039;name&#039;, &#039;&#039;]);
			assert.deepStrictEqual(values, [true, false]);
		});
	});

	describe(&#039;deleteObjectField()&#039;, () =&gt; {
		before((done) =&gt; {
			db.setObject(&#039;testObject10&#039;, { foo: &#039;bar&#039;, delete: &#039;this&#039;, delete1: &#039;this&#039;, delete2: &#039;this&#039; }, done);
		});

		it(&#039;should delete an objects field&#039;, (done) =&gt; {
			db.deleteObjectField(&#039;testObject10&#039;, &#039;delete&#039;, function (err) {
				assert.ifError(err);
				assert(arguments.length &lt; 2);
				db.isObjectField(&#039;testObject10&#039;, &#039;delete&#039;, (err, isField) =&gt; {
					assert.ifError(err);
					assert.equal(isField, false);
					done();
				});
			});
		});

		it(&#039;should delete multiple fields of the object&#039;, (done) =&gt; {
			db.deleteObjectFields(&#039;testObject10&#039;, [&#039;delete1&#039;, &#039;delete2&#039;], function (err) {
				assert.ifError(err);
				assert(arguments.length &lt; 2);
				async.parallel({
					delete1: async.apply(db.isObjectField, &#039;testObject10&#039;, &#039;delete1&#039;),
					delete2: async.apply(db.isObjectField, &#039;testObject10&#039;, &#039;delete2&#039;),
				}, (err, results) =&gt; {
					assert.ifError(err);
					assert.equal(results.delete1, false);
					assert.equal(results.delete2, false);
					done();
				});
			});
		});

		it(&#039;should delete multiple fields of multiple objects&#039;, async () =&gt; {
			await db.setObject(&#039;deleteFields1&#039;, { foo: &#039;foo1&#039;, baz: &#039;2&#039; });
			await db.setObject(&#039;deleteFields2&#039;, { foo: &#039;foo2&#039;, baz: &#039;3&#039; });
			await db.deleteObjectFields([&#039;deleteFields1&#039;, &#039;deleteFields2&#039;], [&#039;baz&#039;]);
			const obj1 = await db.getObject(&#039;deleteFields1&#039;);
			const obj2 = await db.getObject(&#039;deleteFields2&#039;);
			assert.deepStrictEqual(obj1, { foo: &#039;foo1&#039; });
			assert.deepStrictEqual(obj2, { foo: &#039;foo2&#039; });
		});

		it(&#039;should not error if fields is empty array&#039;, async () =&gt; {
			await db.deleteObjectFields(&#039;someKey&#039;, []);
			await db.deleteObjectField(&#039;someKey&#039;, []);
		});

		it(&#039;should not error if key is undefined&#039;, (done) =&gt; {
			db.deleteObjectField(undefined, &#039;someField&#039;, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should not error if key is null&#039;, (done) =&gt; {
			db.deleteObjectField(null, &#039;someField&#039;, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should not error if field is undefined&#039;, (done) =&gt; {
			db.deleteObjectField(&#039;someKey&#039;, undefined, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should not error if one of the fields is undefined&#039;, async () =&gt; {
			await db.deleteObjectFields(&#039;someKey&#039;, [&#039;best&#039;, undefined]);
		});

		it(&#039;should not error if field is null&#039;, (done) =&gt; {
			db.deleteObjectField(&#039;someKey&#039;, null, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});
	});

	describe(&#039;incrObjectField()&#039;, () =&gt; {
		before((done) =&gt; {
			db.setObject(&#039;testObject11&#039;, { age: 99 }, done);
		});

		it(&#039;should set an objects field to 1 if object does not exist&#039;, (done) =&gt; {
			db.incrObjectField(&#039;testObject12&#039;, &#039;field1&#039;, function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 1);
				done();
			});
		});

		it(&#039;should increment an object fields by 1 and return it&#039;, (done) =&gt; {
			db.incrObjectField(&#039;testObject11&#039;, &#039;age&#039;, function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 100);
				done();
			});
		});
	});

	describe(&#039;decrObjectField()&#039;, () =&gt; {
		before((done) =&gt; {
			db.setObject(&#039;testObject13&#039;, { age: 99 }, done);
		});

		it(&#039;should set an objects field to -1 if object does not exist&#039;, (done) =&gt; {
			db.decrObjectField(&#039;testObject14&#039;, &#039;field1&#039;, function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, -1);
				done();
			});
		});

		it(&#039;should decrement an object fields by 1 and return it&#039;, (done) =&gt; {
			db.decrObjectField(&#039;testObject13&#039;, &#039;age&#039;, function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, 98);
				done();
			});
		});

		it(&#039;should decrement multiple objects field by 1 and return an array of new values&#039;, (done) =&gt; {
			db.decrObjectField([&#039;testObject13&#039;, &#039;testObject14&#039;, &#039;decrTestObject&#039;], &#039;age&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.equal(data[0], 97);
				assert.equal(data[1], -1);
				assert.equal(data[2], -1);
				done();
			});
		});
	});

	describe(&#039;incrObjectFieldBy()&#039;, () =&gt; {
		before((done) =&gt; {
			db.setObject(&#039;testObject15&#039;, { age: 100 }, done);
		});

		it(&#039;should set an objects field to 5 if object does not exist&#039;, (done) =&gt; {
			db.incrObjectFieldBy(&#039;testObject16&#039;, &#039;field1&#039;, 5, function (err, newValue) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, 5);
				done();
			});
		});

		it(&#039;should increment an object fields by passed in value and return it&#039;, (done) =&gt; {
			db.incrObjectFieldBy(&#039;testObject15&#039;, &#039;age&#039;, 11, function (err, newValue) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(newValue, 111);
				done();
			});
		});

		it(&#039;should increment an object fields by passed in value and return it&#039;, (done) =&gt; {
			db.incrObjectFieldBy(&#039;testObject15&#039;, &#039;age&#039;, &#039;11&#039;, (err, newValue) =&gt; {
				assert.ifError(err);
				assert.equal(newValue, 122);
				done();
			});
		});

		it(&#039;should return null if value is NaN&#039;, (done) =&gt; {
			db.incrObjectFieldBy(&#039;testObject15&#039;, &#039;lastonline&#039;, &#039;notanumber&#039;, (err, newValue) =&gt; {
				assert.ifError(err);
				assert.strictEqual(newValue, null);
				db.isObjectField(&#039;testObject15&#039;, &#039;lastonline&#039;, (err, isField) =&gt; {
					assert.ifError(err);
					assert(!isField);
					done();
				});
			});
		});
	});

	describe(&#039;incrObjectFieldByBulk&#039;, () =&gt; {
		before(async () =&gt; {
			await db.setObject(&#039;testObject16&#039;, { age: 100 });
		});

		it(&#039;should increment multiple object fields&#039;, async () =&gt; {
			await db.incrObjectFieldByBulk([
				[&#039;testObject16&#039;, { age: 5, newField: 10 }],
				[&#039;testObject17&#039;, { newField: -5 }],
			]);
			const d = await db.getObjects([&#039;testObject16&#039;, &#039;testObject17&#039;]);
			assert.equal(d[0].age, 105);
			assert.equal(d[0].newField, 10);
			assert.equal(d[1].newField, -5);
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
