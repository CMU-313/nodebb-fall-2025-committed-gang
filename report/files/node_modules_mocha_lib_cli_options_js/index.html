<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/mocha/lib/cli/options.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/mocha/lib/cli/options.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">338</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">43.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.10</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

/**
 * Main entry point for handling filesystem-based configuration,
 * whether that&#039;s a config file or `package.json` or whatever.
 * @module lib/cli/options
 * @private
 */

const fs = require(&#039;node:fs&#039;);
const pc = require(&#039;picocolors&#039;);
const yargsParser = require(&#039;yargs-parser&#039;);
const {
  types,
  aliases,
  isMochaFlag,
  expectedTypeForFlag
} = require(&#039;./run-option-metadata&#039;);
const {ONE_AND_DONE_ARGS} = require(&#039;./one-and-dones&#039;);
const mocharc = require(&#039;../mocharc.json&#039;);
const {list} = require(&#039;./run-helpers&#039;);
const {loadConfig, findConfig} = require(&#039;./config&#039;);
const findUp = require(&#039;find-up&#039;);
const debug = require(&#039;debug&#039;)(&#039;mocha:cli:options&#039;);
const {isNodeFlag} = require(&#039;./node-flags&#039;);
const {
  createUnparsableFileError,
  createInvalidArgumentTypeError,
  createUnsupportedError
} = require(&#039;../errors&#039;);
const {isNumeric} = require(&#039;../utils&#039;);

/**
 * The `yargs-parser` namespace
 * @external yargsParser
 * @see {@link https://npm.im/yargs-parser}
 */

/**
 * An object returned by a configured `yargs-parser` representing arguments
 * @memberof external:yargsParser
 * @interface Arguments
 */

/**
 * Base yargs parser configuration
 * @private
 */
const YARGS_PARSER_CONFIG = {
  &#039;combine-arrays&#039;: true,
  &#039;short-option-groups&#039;: false,
  &#039;dot-notation&#039;: false,
  &#039;strip-aliased&#039;: true
};

/**
 * This is the config pulled from the `yargs` property of Mocha&#039;s
 * `package.json`, but it also disables camel case expansion as to
 * avoid outputting non-canonical keynames, as we need to do some
 * lookups.
 * @private
 * @ignore
 */
const configuration = Object.assign({}, YARGS_PARSER_CONFIG, {
  &#039;camel-case-expansion&#039;: false
});

/**
 * This is a really fancy way to:
 * - `array`-type options: ensure unique values and evtl. split comma-delimited lists
 * - `boolean`/`number`/`string`- options: use last element when given multiple times
 * This is passed as the `coerce` option to `yargs-parser`
 * @private
 * @ignore
 */
const globOptions = [&#039;spec&#039;, &#039;ignore&#039;];
const coerceOpts = Object.assign(
  types.array.reduce(
    (acc, arg) =&gt;
      Object.assign(acc, {
        [arg]: v =&gt; Array.from(new Set(globOptions.includes(arg) ? v : list(v)))
      }),
    {}
  ),
  types.boolean
    .concat(types.string, types.number)
    .reduce(
      (acc, arg) =&gt;
        Object.assign(acc, {[arg]: v =&gt; (Array.isArray(v) ? v.pop() : v)}),
      {}
    )
);

/**
 * We do not have a case when multiple arguments are ever allowed after a flag
 * (e.g., `--foo bar baz quux`), so we fix the number of arguments to 1 across
 * the board of non-boolean options.
 * This is passed as the `narg` option to `yargs-parser`
 * @private
 * @ignore
 */
const nargOpts = types.array
  .concat(types.string, types.number)
  .reduce((acc, arg) =&gt; Object.assign(acc, {[arg]: 1}), {});

/**
 * Throws either &quot;UNSUPPORTED&quot; error or &quot;INVALID_ARG_TYPE&quot; error for numeric positional arguments.
 * @param {string[]} allArgs - Stringified args passed to mocha cli
 * @param {number} numericArg - Numeric positional arg for which error must be thrown
 * @param {Object} parsedResult - Result from `yargs-parser`
 * @private
 * @ignore
 */
const createErrorForNumericPositionalArg = (
  numericArg,
  allArgs,
  parsedResult
) =&gt; {
  // A flag for `numericArg` exists if:
  // 1. A mocha flag immediately preceeded the numericArg in `allArgs` array and
  // 2. `numericArg` value could not be assigned to this flag by `yargs-parser` because of incompatible datatype.
  const flag = allArgs.find((arg, index) =&gt; {
    const normalizedArg = arg.replace(/^--?/, &#039;&#039;);
    return (
      isMochaFlag(arg) &amp;&amp;
      allArgs[index + 1] === String(numericArg) &amp;&amp;
      parsedResult[normalizedArg] !== String(numericArg)
    );
  });

  if (flag) {
    throw createInvalidArgumentTypeError(
      `Mocha flag &#039;${flag}&#039; given invalid option: &#039;${numericArg}&#039;`,
      numericArg,
      expectedTypeForFlag(flag)
    );
  } else {
    throw createUnsupportedError(
      `Option ${numericArg} is unsupported by the mocha cli`
    );
  }
};

/**
 * Wrapper around `yargs-parser` which applies our settings
 * @param {string|string[]} args - Arguments to parse
 * @param {Object} defaultValues - Default values of mocharc.json
 * @param  {...Object} configObjects - `configObjects` for yargs-parser
 * @private
 * @ignore
 */
const parse = (args = [], defaultValues = {}, ...configObjects) =&gt; {
  // save node-specific args for special handling.
  // 1. when these args have a &quot;=&quot; they should be considered to have values
  // 2. if they don&#039;t, they are just boolean flags
  // 3. to avoid explicitly defining the set of them, we tell yargs-parser they
  //    are ALL boolean flags.
  // 4. we can then reapply the values after yargs-parser is done.
  const allArgs = Array.isArray(args) ? args : args.split(&#039; &#039;);
  const nodeArgs = allArgs.reduce((acc, arg) =&gt; {
    const pair = arg.split(&#039;=&#039;);
    let flag = pair[0];
    if (isNodeFlag(flag, false)) {
      flag = flag.replace(/^--?/, &#039;&#039;);
      return acc.concat([[flag, arg.includes(&#039;=&#039;) ? pair[1] : true]]);
    }
    return acc;
  }, []);

  const result = yargsParser.detailed(args, {
    configuration,
    configObjects,
    default: defaultValues,
    coerce: coerceOpts,
    narg: nargOpts,
    alias: aliases,
    string: types.string,
    array: types.array,
    number: types.number,
    boolean: types.boolean.concat(nodeArgs.map(pair =&gt; pair[0]))
  });
  if (result.error) {
    console.error(pc.red(`Error: ${result.error.message}`));
    process.exit(1);
  }

  const numericPositionalArg = result.argv._.find(arg =&gt; isNumeric(arg));
  if (numericPositionalArg) {
    createErrorForNumericPositionalArg(
      numericPositionalArg,
      allArgs,
      result.argv
    );
  }

  // reapply &quot;=&quot; arg values from above
  nodeArgs.forEach(([key, value]) =&gt; {
    result.argv[key] = value;
  });

  return result.argv;
};

/**
 * Given path to config file in `args.config`, attempt to load &amp; parse config file.
 * @param {Object} [args] - Arguments object
 * @param {string|boolean} [args.config] - Path to config file or `false` to skip
 * @public
 * @alias module:lib/cli.loadRc
 * @returns {external:yargsParser.Arguments|void} Parsed config, or nothing if `args.config` is `false`
 */
const loadRc = (args = {}) =&gt; {
  if (args.config !== false) {
    const config = args.config || findConfig();
    return config ? loadConfig(config) : {};
  }
};

module.exports.loadRc = loadRc;

/**
 * Given path to `package.json` in `args.package`, attempt to load config from `mocha` prop.
 * @param {Object} [args] - Arguments object
 * @param {string|boolean} [args.config] - Path to `package.json` or `false` to skip
 * @public
 * @alias module:lib/cli.loadPkgRc
 * @returns {external:yargsParser.Arguments|void} Parsed config, or nothing if `args.package` is `false`
 */
const loadPkgRc = (args = {}) =&gt; {
  let result;
  if (args.package === false) {
    return result;
  }
  result = {};
  const filepath = args.package || findUp.sync(mocharc.package);
  if (filepath) {
    let configData;
    try {
      configData = fs.readFileSync(filepath, &#039;utf8&#039;);
    } catch (err) {
      // If `args.package` was explicitly specified, throw an error
      if (filepath == args.package) {
        throw createUnparsableFileError(
          `Unable to read ${filepath}: ${err}`,
          filepath
        );
      } else {
        debug(&#039;failed to read default package.json at %s; ignoring&#039;,
              filepath);
        return result;
      }
    }
    try {
      const pkg = JSON.parse(configData);
      if (pkg.mocha) {
        debug(&#039;`mocha` prop of package.json parsed: %O&#039;, pkg.mocha);
        result = pkg.mocha;
      } else {
        debug(&#039;no config found in %s&#039;, filepath);
      }
    } catch (err) {
      // If JSON failed to parse, throw an error.
      throw createUnparsableFileError(
        `Unable to parse ${filepath}: ${err}`,
        filepath
      );
    }
  }
  return result;
};

module.exports.loadPkgRc = loadPkgRc;

/**
 * Priority list:
 *
 * 1. Command-line args
 * 2. `MOCHA_OPTIONS` environment variable.
 * 3. RC file (`.mocharc.c?js`, `.mocharc.ya?ml`, `mocharc.json`)
 * 4. `mocha` prop of `package.json`
 * 5. default configuration (`lib/mocharc.json`)
 *
 * If a {@link module:lib/cli/one-and-dones.ONE_AND_DONE_ARGS &quot;one-and-done&quot; option} is present in the `argv` array, no external config files will be read.
 * @summary Parses options read from `.mocharc.*` and `package.json`.
 * @param {string|string[]} [argv] - Arguments to parse
 * @public
 * @alias module:lib/cli.loadOptions
 * @returns {external:yargsParser.Arguments} Parsed args from everything
 */
const loadOptions = (argv = []) =&gt; {
  let args = parse(argv);
  // short-circuit: look for a flag that would abort loading of options
  if (
    Array.from(ONE_AND_DONE_ARGS).reduce(
      (acc, arg) =&gt; acc || arg in args,
      false
    )
  ) {
    return args;
  }

  const envConfig = parse(process.env.MOCHA_OPTIONS || &#039;&#039;);
  const rcConfig = loadRc(args);
  const pkgConfig = loadPkgRc(args);

  if (rcConfig) {
    args.config = false;
    args._ = args._.concat(rcConfig._ || []);
  }
  if (pkgConfig) {
    args.package = false;
    args._ = args._.concat(pkgConfig._ || []);
  }

  args = parse(
    args._,
    mocharc,
    args,
    envConfig,
    rcConfig || {},
    pkgConfig || {}
  );

  // recombine positional arguments and &quot;spec&quot;
  if (args.spec) {
    args._ = args._.concat(args.spec);
    delete args.spec;
  }

  // make unique
  args._ = Array.from(new Set(args._));

  return args;
};

module.exports.loadOptions = loadOptions;
module.exports.YARGS_PARSER_CONFIG = YARGS_PARSER_CONFIG;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
