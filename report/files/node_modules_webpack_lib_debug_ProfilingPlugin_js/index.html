<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/debug/ProfilingPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/debug/ProfilingPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">562</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

&quot;use strict&quot;;

const { Tracer } = require(&quot;chrome-trace-event&quot;);
const {
	JAVASCRIPT_MODULES,
	CSS_MODULES,
	WEBASSEMBLY_MODULES,
	JSON_MODULE_TYPE
} = require(&quot;../ModuleTypeConstants&quot;);
const createSchemaValidation = require(&quot;../util/create-schema-validation&quot;);
const { dirname, mkdirpSync } = require(&quot;../util/fs&quot;);

/** @typedef {import(&quot;inspector&quot;).Session} Session */
/** @typedef {import(&quot;tapable&quot;).FullTap} FullTap */
/** @typedef {import(&quot;../../declarations/plugins/debug/ProfilingPlugin&quot;).ProfilingPluginOptions} ProfilingPluginOptions */
/** @typedef {import(&quot;../Compilation&quot;)} Compilation */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../ContextModuleFactory&quot;)} ContextModuleFactory */
/** @typedef {import(&quot;../ModuleFactory&quot;)} ModuleFactory */
/** @typedef {import(&quot;../NormalModuleFactory&quot;)} NormalModuleFactory */
/** @typedef {import(&quot;../Parser&quot;)} Parser */
/** @typedef {import(&quot;../ResolverFactory&quot;)} ResolverFactory */
/** @typedef {import(&quot;../util/fs&quot;).IntermediateFileSystem} IntermediateFileSystem */

const validate = createSchemaValidation(
	require(&quot;../../schemas/plugins/debug/ProfilingPlugin.check.js&quot;),
	() =&gt; require(&quot;../../schemas/plugins/debug/ProfilingPlugin.json&quot;),
	{
		name: &quot;Profiling Plugin&quot;,
		baseDataPath: &quot;options&quot;
	}
);

/** @typedef {{ Session: typeof import(&quot;inspector&quot;).Session }} Inspector */

/** @type {Inspector | undefined} */
let inspector;

try {
	// eslint-disable-next-line n/no-unsupported-features/node-builtins
	inspector = require(&quot;inspector&quot;);
} catch (_err) {
	// eslint-disable-next-line no-console
	console.log(&quot;Unable to CPU profile in &lt; node 8.0&quot;);
}

class Profiler {
	/**
	 * @param {Inspector} inspector inspector
	 */
	constructor(inspector) {
		/** @type {undefined | Session} */
		this.session = undefined;
		this.inspector = inspector;
		this._startTime = 0;
	}

	hasSession() {
		return this.session !== undefined;
	}

	startProfiling() {
		if (this.inspector === undefined) {
			return Promise.resolve();
		}

		try {
			this.session = new /** @type {Inspector} */ (inspector).Session();
			/** @type {Session} */
			(this.session).connect();
		} catch (_) {
			this.session = undefined;
			return Promise.resolve();
		}

		const hrtime = process.hrtime();
		this._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);

		return Promise.all([
			this.sendCommand(&quot;Profiler.setSamplingInterval&quot;, {
				interval: 100
			}),
			this.sendCommand(&quot;Profiler.enable&quot;),
			this.sendCommand(&quot;Profiler.start&quot;)
		]);
	}

	/**
	 * @param {string} method method name
	 * @param {EXPECTED_OBJECT=} params params
	 * @returns {Promise&lt;EXPECTED_ANY | void&gt;} Promise for the result
	 */
	sendCommand(method, params) {
		if (this.hasSession()) {
			return new Promise((res, rej) =&gt; {
				/** @type {Session} */
				(this.session).post(method, params, (err, params) =&gt; {
					if (err !== null) {
						rej(err);
					} else {
						res(params);
					}
				});
			});
		}
		return Promise.resolve();
	}

	destroy() {
		if (this.hasSession()) {
			/** @type {Session} */
			(this.session).disconnect();
		}

		return Promise.resolve();
	}

	stopProfiling() {
		return this.sendCommand(&quot;Profiler.stop&quot;).then(({ profile }) =&gt; {
			const hrtime = process.hrtime();
			const endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);
			// Avoid coverage problems due indirect changes
			/* istanbul ignore next */
			if (profile.startTime &lt; this._startTime || profile.endTime &gt; endTime) {
				// In some cases timestamps mismatch and we need to adjust them
				// Both process.hrtime and the inspector timestamps claim to be relative
				// to a unknown point in time. But they do not guarantee that this is the
				// same point in time.
				const duration = profile.endTime - profile.startTime;
				const ownDuration = endTime - this._startTime;
				const untracked = Math.max(0, ownDuration - duration);
				profile.startTime = this._startTime + untracked / 2;
				profile.endTime = endTime - untracked / 2;
			}
			return { profile };
		});
	}
}

/**
 * an object that wraps Tracer and Profiler with a counter
 * @typedef {object} Trace
 * @property {Tracer} trace instance of Tracer
 * @property {number} counter Counter
 * @property {Profiler} profiler instance of Profiler
 * @property {(callback: (err?: null | Error) =&gt; void) =&gt; void} end the end function
 */

/**
 * @param {IntermediateFileSystem} fs filesystem used for output
 * @param {string} outputPath The location where to write the log.
 * @returns {Trace} The trace object
 */
const createTrace = (fs, outputPath) =&gt; {
	const trace = new Tracer();
	const profiler = new Profiler(/** @type {Inspector} */ (inspector));
	if (/\/|\\/.test(outputPath)) {
		const dirPath = dirname(fs, outputPath);
		mkdirpSync(fs, dirPath);
	}
	const fsStream = fs.createWriteStream(outputPath);

	let counter = 0;

	trace.pipe(fsStream);
	// These are critical events that need to be inserted so that tools like
	// chrome dev tools can load the profile.
	trace.instantEvent({
		name: &quot;TracingStartedInPage&quot;,
		id: ++counter,
		cat: [&quot;disabled-by-default-devtools.timeline&quot;],
		args: {
			data: {
				sessionId: &quot;-1&quot;,
				page: &quot;0xfff&quot;,
				frames: [
					{
						frame: &quot;0xfff&quot;,
						url: &quot;webpack&quot;,
						name: &quot;&quot;
					}
				]
			}
		}
	});

	trace.instantEvent({
		name: &quot;TracingStartedInBrowser&quot;,
		id: ++counter,
		cat: [&quot;disabled-by-default-devtools.timeline&quot;],
		args: {
			data: {
				sessionId: &quot;-1&quot;
			}
		}
	});

	return {
		trace,
		counter,
		profiler,
		end: callback =&gt; {
			trace.push(&quot;]&quot;);
			// Wait until the write stream finishes.
			fsStream.on(&quot;close&quot;, () =&gt; {
				callback();
			});
			// Tear down the readable trace stream.
			trace.push(null);
		}
	};
};

const PLUGIN_NAME = &quot;ProfilingPlugin&quot;;

class ProfilingPlugin {
	/**
	 * @param {ProfilingPluginOptions=} options options object
	 */
	constructor(options = {}) {
		validate(options);
		this.outputPath = options.outputPath || &quot;events.json&quot;;
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const tracer = createTrace(
			/** @type {IntermediateFileSystem} */
			(compiler.intermediateFileSystem),
			this.outputPath
		);
		tracer.profiler.startProfiling();

		// Compiler Hooks
		for (const hookName of Object.keys(compiler.hooks)) {
			const hook =
				compiler.hooks[/** @type {keyof Compiler[&quot;hooks&quot;]} */ (hookName)];
			if (hook) {
				hook.intercept(makeInterceptorFor(&quot;Compiler&quot;, tracer)(hookName));
			}
		}

		for (const hookName of Object.keys(compiler.resolverFactory.hooks)) {
			const hook =
				compiler.resolverFactory.hooks[
					/** @type {keyof ResolverFactory[&quot;hooks&quot;]} */
					(hookName)
				];
			if (hook) {
				hook.intercept(makeInterceptorFor(&quot;Resolver&quot;, tracer)(hookName));
			}
		}

		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory, contextModuleFactory }) =&gt; {
				interceptAllHooksFor(compilation, tracer, &quot;Compilation&quot;);
				interceptAllHooksFor(
					normalModuleFactory,
					tracer,
					&quot;Normal Module Factory&quot;
				);
				interceptAllHooksFor(
					contextModuleFactory,
					tracer,
					&quot;Context Module Factory&quot;
				);
				interceptAllParserHooks(normalModuleFactory, tracer);
				interceptAllGeneratorHooks(normalModuleFactory, tracer);
				interceptAllJavascriptModulesPluginHooks(compilation, tracer);
				interceptAllCssModulesPluginHooks(compilation, tracer);
			}
		);

		// We need to write out the CPU profile when we are all done.
		compiler.hooks.done.tapAsync(
			{
				name: PLUGIN_NAME,
				stage: Infinity
			},
			(stats, callback) =&gt; {
				if (compiler.watchMode) return callback();
				tracer.profiler.stopProfiling().then(parsedResults =&gt; {
					if (parsedResults === undefined) {
						tracer.profiler.destroy();
						tracer.end(callback);
						return;
					}

					const cpuStartTime = parsedResults.profile.startTime;
					const cpuEndTime = parsedResults.profile.endTime;

					tracer.trace.completeEvent({
						name: &quot;TaskQueueManager::ProcessTaskFromWorkQueue&quot;,
						id: ++tracer.counter,
						cat: [&quot;toplevel&quot;],
						ts: cpuStartTime,
						args: {
							// eslint-disable-next-line camelcase
							src_file: &quot;../../ipc/ipc_moji_bootstrap.cc&quot;,
							// eslint-disable-next-line camelcase
							src_func: &quot;Accept&quot;
						}
					});

					tracer.trace.completeEvent({
						name: &quot;EvaluateScript&quot;,
						id: ++tracer.counter,
						cat: [&quot;devtools.timeline&quot;],
						ts: cpuStartTime,
						dur: cpuEndTime - cpuStartTime,
						args: {
							data: {
								url: &quot;webpack&quot;,
								lineNumber: 1,
								columnNumber: 1,
								frame: &quot;0xFFF&quot;
							}
						}
					});

					tracer.trace.instantEvent({
						name: &quot;CpuProfile&quot;,
						id: ++tracer.counter,
						cat: [&quot;disabled-by-default-devtools.timeline&quot;],
						ts: cpuEndTime,
						args: {
							data: {
								cpuProfile: parsedResults.profile
							}
						}
					});

					tracer.profiler.destroy();
					tracer.end(callback);
				});
			}
		);
	}
}

/**
 * @param {EXPECTED_ANY &amp; { hooks: TODO }} instance instance
 * @param {Trace} tracer tracer
 * @param {string} logLabel log label
 */
const interceptAllHooksFor = (instance, tracer, logLabel) =&gt; {
	if (Reflect.has(instance, &quot;hooks&quot;)) {
		for (const hookName of Object.keys(instance.hooks)) {
			const hook = instance.hooks[hookName];
			if (hook &amp;&amp; !hook._fakeHook) {
				hook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));
			}
		}
	}
};

/**
 * @param {NormalModuleFactory} moduleFactory normal module factory
 * @param {Trace} tracer tracer
 */
const interceptAllParserHooks = (moduleFactory, tracer) =&gt; {
	const moduleTypes = [
		...JAVASCRIPT_MODULES,
		JSON_MODULE_TYPE,
		...WEBASSEMBLY_MODULES,
		...CSS_MODULES
	];

	for (const moduleType of moduleTypes) {
		moduleFactory.hooks.parser
			.for(moduleType)
			.tap(PLUGIN_NAME, (parser, parserOpts) =&gt; {
				interceptAllHooksFor(parser, tracer, &quot;Parser&quot;);
			});
	}
};

/**
 * @param {NormalModuleFactory} moduleFactory normal module factory
 * @param {Trace} tracer tracer
 */
const interceptAllGeneratorHooks = (moduleFactory, tracer) =&gt; {
	const moduleTypes = [
		...JAVASCRIPT_MODULES,
		JSON_MODULE_TYPE,
		...WEBASSEMBLY_MODULES,
		...CSS_MODULES
	];

	for (const moduleType of moduleTypes) {
		moduleFactory.hooks.generator
			.for(moduleType)
			.tap(PLUGIN_NAME, (parser, parserOpts) =&gt; {
				interceptAllHooksFor(parser, tracer, &quot;Generator&quot;);
			});
	}
};

/**
 * @param {Compilation} compilation compilation
 * @param {Trace} tracer tracer
 */
const interceptAllJavascriptModulesPluginHooks = (compilation, tracer) =&gt; {
	interceptAllHooksFor(
		{
			hooks:
				require(&quot;../javascript/JavascriptModulesPlugin&quot;).getCompilationHooks(
					compilation
				)
		},
		tracer,
		&quot;JavascriptModulesPlugin&quot;
	);
};

/**
 * @param {Compilation} compilation compilation
 * @param {Trace} tracer tracer
 */
const interceptAllCssModulesPluginHooks = (compilation, tracer) =&gt; {
	interceptAllHooksFor(
		{
			hooks: require(&quot;../css/CssModulesPlugin&quot;).getCompilationHooks(compilation)
		},
		tracer,
		&quot;CssModulesPlugin&quot;
	);
};

/** @typedef {(...args: EXPECTED_ANY[]) =&gt; EXPECTED_ANY | Promise&lt;(...args: EXPECTED_ANY[]) =&gt; EXPECTED_ANY&gt;} PluginFunction */

/**
 * @param {string} instance instance
 * @param {Trace} tracer tracer
 * @returns {(hookName: string) =&gt; TODO} interceptor
 */
const makeInterceptorFor = (instance, tracer) =&gt; hookName =&gt; ({
	/**
	 * @param {FullTap} tapInfo tap info
	 * @returns {FullTap} modified full tap
	 */
	register: tapInfo =&gt; {
		const { name, type, fn: internalFn } = tapInfo;
		const newFn =
			// Don&#039;t tap our own hooks to ensure stream can close cleanly
			name === PLUGIN_NAME
				? internalFn
				: makeNewProfiledTapFn(hookName, tracer, {
						name,
						type,
						fn: /** @type {PluginFunction} */ (internalFn)
					});
		return { ...tapInfo, fn: newFn };
	}
});

/**
 * @param {string} hookName Name of the hook to profile.
 * @param {Trace} tracer The trace object.
 * @param {object} options Options for the profiled fn.
 * @param {string} options.name Plugin name
 * @param {&quot;sync&quot; | &quot;async&quot; | &quot;promise&quot;} options.type Plugin type (sync | async | promise)
 * @param {PluginFunction} options.fn Plugin function
 * @returns {PluginFunction} Chainable hooked function.
 */
const makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) =&gt; {
	const defaultCategory = [&quot;blink.user_timing&quot;];

	switch (type) {
		case &quot;promise&quot;:
			return (...args) =&gt; {
				const id = ++tracer.counter;
				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				});
				const promise =
					/** @type {Promise&lt;(...args: EXPECTED_ANY[]) =&gt; EXPECTED_ANY&gt;} */
					(fn(...args));
				return promise.then(r =&gt; {
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					});
					return r;
				});
			};
		case &quot;async&quot;:
			return (...args) =&gt; {
				const id = ++tracer.counter;
				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				});
				const callback = args.pop();
				fn(
					...args,
					/**
					 * @param {...EXPECTED_ANY[]} r result
					 */
					(...r) =&gt; {
						tracer.trace.end({
							name,
							id,
							cat: defaultCategory
						});
						callback(...r);
					}
				);
			};
		case &quot;sync&quot;:
			return (...args) =&gt; {
				const id = ++tracer.counter;
				// Do not instrument ourself due to the CPU
				// profile needing to be the last event in the trace.
				if (name === PLUGIN_NAME) {
					return fn(...args);
				}

				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				});
				let r;
				try {
					r = fn(...args);
				} catch (err) {
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					});
					throw err;
				}
				tracer.trace.end({
					name,
					id,
					cat: defaultCategory
				});
				return r;
			};
		default:
			return fn;
	}
};

module.exports = ProfilingPlugin;
module.exports.Profiler = Profiler;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
