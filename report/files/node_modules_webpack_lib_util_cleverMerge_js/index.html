<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/util/cleverMerge.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/util/cleverMerge.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">638</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">104.84</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

/** @type {WeakMap&lt;EXPECTED_OBJECT, WeakMap&lt;EXPECTED_OBJECT, EXPECTED_OBJECT&gt;&gt;} */
const mergeCache = new WeakMap();
/** @type {WeakMap&lt;EXPECTED_OBJECT, Map&lt;string, Map&lt;string | number | boolean, EXPECTED_OBJECT&gt;&gt;&gt;} */
const setPropertyCache = new WeakMap();
const DELETE = Symbol(&quot;DELETE&quot;);
const DYNAMIC_INFO = Symbol(&quot;cleverMerge dynamic info&quot;);

/**
 * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.
 * @template T
 * @template O
 * @example
 * // performs cleverMerge(first, second), stores the result in WeakMap and returns result
 * cachedCleverMerge({a: 1}, {a: 2})
 * {a: 2}
 *  // when same arguments passed, gets the result from WeakMap and returns it.
 * cachedCleverMerge({a: 1}, {a: 2})
 * {a: 2}
 * @param {T | null | undefined} first first object
 * @param {O | null | undefined} second second object
 * @returns {T &amp; O | T | O} merged object of first and second object
 */
const cachedCleverMerge = (first, second) =&gt; {
	if (second === undefined) return /** @type {T} */ (first);
	if (first === undefined) return /** @type {O} */ (second);
	if (typeof second !== &quot;object&quot; || second === null)
		return /** @type {O} */ (second);
	if (typeof first !== &quot;object&quot; || first === null)
		return /** @type {T} */ (first);

	let innerCache = mergeCache.get(first);
	if (innerCache === undefined) {
		innerCache = new WeakMap();
		mergeCache.set(first, innerCache);
	}
	const prevMerge = /** @type {T &amp; O} */ (innerCache.get(second));
	if (prevMerge !== undefined) return prevMerge;
	const newMerge = _cleverMerge(first, second, true);
	innerCache.set(second, newMerge);
	return newMerge;
};

/**
 * @template T
 * @param {Partial&lt;T&gt;} obj object
 * @param {string} property property
 * @param {string | number | boolean} value assignment value
 * @returns {T} new object
 */
const cachedSetProperty = (obj, property, value) =&gt; {
	let mapByProperty = setPropertyCache.get(obj);

	if (mapByProperty === undefined) {
		mapByProperty = new Map();
		setPropertyCache.set(obj, mapByProperty);
	}

	let mapByValue = mapByProperty.get(property);

	if (mapByValue === undefined) {
		mapByValue = new Map();
		mapByProperty.set(property, mapByValue);
	}

	let result = mapByValue.get(value);

	if (result) return /** @type {T} */ (result);

	result = {
		...obj,
		[property]: value
	};
	mapByValue.set(value, result);

	return /** @type {T} */ (result);
};

/**
 * @template V
 * @typedef {Map&lt;string, V | undefined&gt;} ByValues
 */

/**
 * @typedef {object} ObjectParsedPropertyEntry
 * @property {TODO | undefined} base base value
 * @property {string | undefined} byProperty the name of the selector property
 * @property {ByValues&lt;TODO&gt;} byValues value depending on selector property, merged with base
 */

/** @typedef {(function(...EXPECTED_ANY): object) &amp; { [DYNAMIC_INFO]: [DynamicFunction, object] }} DynamicFunction */

/**
 * @typedef {object} ParsedObject
 * @property {Map&lt;string, ObjectParsedPropertyEntry&gt;} static static properties (key is property name)
 * @property {{ byProperty: string, fn: DynamicFunction } | undefined} dynamic dynamic part
 */

/** @type {WeakMap&lt;EXPECTED_OBJECT, ParsedObject&gt;} */
const parseCache = new WeakMap();

/**
 * @template {object} T
 * @param {T} obj the object
 * @returns {ParsedObject} parsed object
 */
const cachedParseObject = obj =&gt; {
	const entry = parseCache.get(/** @type {EXPECTED_OBJECT} */ (obj));
	if (entry !== undefined) return entry;
	const result = parseObject(obj);
	parseCache.set(/** @type {EXPECTED_OBJECT} */ (obj), result);
	return result;
};

/**
 * @template {object} T
 * @template V
 * @param {T} obj the object
 * @returns {ParsedObject} parsed object
 */
const parseObject = obj =&gt; {
	const info = new Map();
	let dynamicInfo;
	/**
	 * @param {string} p path
	 * @returns {Partial&lt;ObjectParsedPropertyEntry&gt;} object parsed property entry
	 */
	const getInfo = p =&gt; {
		const entry = info.get(p);
		if (entry !== undefined) return entry;
		const newEntry = {
			base: undefined,
			byProperty: undefined,
			byValues: undefined
		};
		info.set(p, newEntry);
		return newEntry;
	};
	for (const key of Object.keys(obj)) {
		if (key.startsWith(&quot;by&quot;)) {
			const byProperty = /** @type {keyof T} */ (key);
			const byObj = /** @type {TODO} */ (obj[byProperty]);
			if (typeof byObj === &quot;object&quot;) {
				for (const byValue of Object.keys(byObj)) {
					const obj = byObj[/** @type {keyof (keyof T)} */ (byValue)];
					for (const key of Object.keys(obj)) {
						const entry = getInfo(key);
						if (entry.byProperty === undefined) {
							entry.byProperty = /** @type {string} */ (byProperty);
							entry.byValues = new Map();
						} else if (entry.byProperty !== byProperty) {
							throw new Error(
								`${/** @type {string} */ (byProperty)} and ${entry.byProperty} for a single property is not supported`
							);
						}
						/** @type {ByValues&lt;V&gt;} */
						(entry.byValues).set(
							byValue,
							obj[/** @type {keyof (keyof T)} */ (key)]
						);
						if (byValue === &quot;default&quot;) {
							for (const otherByValue of Object.keys(byObj)) {
								if (
									!(
										/** @type {ByValues&lt;V&gt;} */
										(entry.byValues).has(otherByValue)
									)
								)
									/** @type {ByValues&lt;V&gt;} */
									(entry.byValues).set(otherByValue, undefined);
							}
						}
					}
				}
			} else if (typeof byObj === &quot;function&quot;) {
				if (dynamicInfo === undefined) {
					dynamicInfo = {
						byProperty: key,
						fn: byObj
					};
				} else {
					throw new Error(
						`${key} and ${dynamicInfo.byProperty} when both are functions is not supported`
					);
				}
			} else {
				const entry = getInfo(key);
				entry.base = obj[/** @type {keyof T} */ (key)];
			}
		} else {
			const entry = getInfo(key);
			entry.base = obj[/** @type {keyof T} */ (key)];
		}
	}
	return {
		static: info,
		dynamic: dynamicInfo
	};
};

/**
 * @template {object} T
 * @param {Map&lt;string, ObjectParsedPropertyEntry&gt;} info static properties (key is property name)
 * @param {{ byProperty: string, fn: (...args: EXPECTED_ANY[]) =&gt; T } | undefined} dynamicInfo dynamic part
 * @returns {T} the object
 */
const serializeObject = (info, dynamicInfo) =&gt; {
	const obj = /** @type {T} */ ({});
	// Setup byProperty structure
	for (const entry of info.values()) {
		if (entry.byProperty !== undefined) {
			const byProperty = /** @type {keyof T} */ (entry.byProperty);
			const byObj = (obj[byProperty] =
				obj[byProperty] || /** @type {TODO} */ ({}));
			for (const byValue of entry.byValues.keys()) {
				byObj[byValue] = byObj[byValue] || {};
			}
		}
	}
	for (const [key, entry] of info) {
		if (entry.base !== undefined) {
			obj[/** @type {keyof T} */ (key)] = entry.base;
		}
		// Fill byProperty structure
		if (entry.byProperty !== undefined) {
			const byProperty = /** @type {keyof T} */ (entry.byProperty);
			const byObj = (obj[byProperty] =
				obj[byProperty] || /** @type {TODO} */ ({}));
			for (const byValue of Object.keys(byObj)) {
				const value = getFromByValues(entry.byValues, byValue);
				if (value !== undefined) byObj[byValue][key] = value;
			}
		}
	}
	if (dynamicInfo !== undefined) {
		/** @type {TODO} */
		(obj)[dynamicInfo.byProperty] = dynamicInfo.fn;
	}
	return obj;
};

const VALUE_TYPE_UNDEFINED = 0;
const VALUE_TYPE_ATOM = 1;
const VALUE_TYPE_ARRAY_EXTEND = 2;
const VALUE_TYPE_OBJECT = 3;
const VALUE_TYPE_DELETE = 4;

/**
 * @template T
 * @param {T} value a single value
 * @returns {VALUE_TYPE_UNDEFINED | VALUE_TYPE_ATOM | VALUE_TYPE_ARRAY_EXTEND | VALUE_TYPE_OBJECT | VALUE_TYPE_DELETE} value type
 */
const getValueType = value =&gt; {
	if (value === undefined) {
		return VALUE_TYPE_UNDEFINED;
	} else if (value === DELETE) {
		return VALUE_TYPE_DELETE;
	} else if (Array.isArray(value)) {
		if (value.includes(&quot;...&quot;)) return VALUE_TYPE_ARRAY_EXTEND;
		return VALUE_TYPE_ATOM;
	} else if (
		typeof value === &quot;object&quot; &amp;&amp;
		value !== null &amp;&amp;
		(!value.constructor || value.constructor === Object)
	) {
		return VALUE_TYPE_OBJECT;
	}
	return VALUE_TYPE_ATOM;
};

/**
 * Merges two objects. Objects are deeply clever merged.
 * Arrays might reference the old value with &quot;...&quot;.
 * Non-object values take preference over object values.
 * @template T
 * @template O
 * @param {T} first first object
 * @param {O} second second object
 * @returns {T &amp; O | T | O} merged object of first and second object
 */
const cleverMerge = (first, second) =&gt; {
	if (second === undefined) return first;
	if (first === undefined) return second;
	if (typeof second !== &quot;object&quot; || second === null) return second;
	if (typeof first !== &quot;object&quot; || first === null) return first;

	return /** @type {T &amp; O} */ (_cleverMerge(first, second, false));
};

/**
 * @template {object} T
 * @template {object} O
 * Merges two objects. Objects are deeply clever merged.
 * @param {T} first first
 * @param {O} second second
 * @param {boolean} internalCaching should parsing of objects and nested merges be cached
 * @returns {T &amp; O} merged object of first and second object
 */
const _cleverMerge = (first, second, internalCaching = false) =&gt; {
	const firstObject = internalCaching
		? cachedParseObject(first)
		: parseObject(first);
	const { static: firstInfo, dynamic: firstDynamicInfo } = firstObject;

	// If the first argument has a dynamic part we modify the dynamic part to merge the second argument
	if (firstDynamicInfo !== undefined) {
		let { byProperty, fn } = firstDynamicInfo;
		const fnInfo = fn[DYNAMIC_INFO];
		if (fnInfo) {
			second =
				/** @type {TODO} */
				(
					internalCaching
						? cachedCleverMerge(fnInfo[1], second)
						: cleverMerge(fnInfo[1], second)
				);
			fn = fnInfo[0];
		}
		/** @type {DynamicFunction} */
		const newFn = (...args) =&gt; {
			const fnResult = fn(...args);
			return internalCaching
				? cachedCleverMerge(fnResult, second)
				: cleverMerge(fnResult, second);
		};
		newFn[DYNAMIC_INFO] = [fn, second];
		return /** @type {T &amp; O} */ (
			serializeObject(firstObject.static, { byProperty, fn: newFn })
		);
	}

	// If the first part is static only, we merge the static parts and keep the dynamic part of the second argument
	const secondObject = internalCaching
		? cachedParseObject(second)
		: parseObject(second);
	const { static: secondInfo, dynamic: secondDynamicInfo } = secondObject;
	/** @type {Map&lt;string, ObjectParsedPropertyEntry&gt;} */
	const resultInfo = new Map();
	for (const [key, firstEntry] of firstInfo) {
		const secondEntry = secondInfo.get(key);
		const entry =
			secondEntry !== undefined
				? mergeEntries(firstEntry, secondEntry, internalCaching)
				: firstEntry;
		resultInfo.set(key, entry);
	}
	for (const [key, secondEntry] of secondInfo) {
		if (!firstInfo.has(key)) {
			resultInfo.set(key, secondEntry);
		}
	}
	return /** @type {T &amp; O} */ (serializeObject(resultInfo, secondDynamicInfo));
};

/**
 * @param {ObjectParsedPropertyEntry} firstEntry a
 * @param {ObjectParsedPropertyEntry} secondEntry b
 * @param {boolean} internalCaching should parsing of objects and nested merges be cached
 * @returns {ObjectParsedPropertyEntry} new entry
 */
const mergeEntries = (firstEntry, secondEntry, internalCaching) =&gt; {
	switch (getValueType(secondEntry.base)) {
		case VALUE_TYPE_ATOM:
		case VALUE_TYPE_DELETE:
			// No need to consider firstEntry at all
			// second value override everything
			// = second.base + second.byProperty
			return secondEntry;
		case VALUE_TYPE_UNDEFINED:
			if (!firstEntry.byProperty) {
				// = first.base + second.byProperty
				return {
					base: firstEntry.base,
					byProperty: secondEntry.byProperty,
					byValues: secondEntry.byValues
				};
			} else if (firstEntry.byProperty !== secondEntry.byProperty) {
				throw new Error(
					`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`
				);
			} else {
				// = first.base + (first.byProperty + second.byProperty)
				// need to merge first and second byValues
				const newByValues = new Map(firstEntry.byValues);
				for (const [key, value] of secondEntry.byValues) {
					const firstValue = getFromByValues(firstEntry.byValues, key);
					newByValues.set(
						key,
						mergeSingleValue(firstValue, value, internalCaching)
					);
				}
				return {
					base: firstEntry.base,
					byProperty: firstEntry.byProperty,
					byValues: newByValues
				};
			}
		default: {
			if (!firstEntry.byProperty) {
				// The simple case
				// = (first.base + second.base) + second.byProperty
				return {
					base: mergeSingleValue(
						firstEntry.base,
						secondEntry.base,
						internalCaching
					),
					byProperty: secondEntry.byProperty,
					byValues: secondEntry.byValues
				};
			}
			let newBase;
			const intermediateByValues = new Map(firstEntry.byValues);
			for (const [key, value] of intermediateByValues) {
				intermediateByValues.set(
					key,
					mergeSingleValue(value, secondEntry.base, internalCaching)
				);
			}
			if (
				Array.from(firstEntry.byValues.values()).every(value =&gt; {
					const type = getValueType(value);
					return type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;
				})
			) {
				// = (first.base + second.base) + ((first.byProperty + second.base) + second.byProperty)
				newBase = mergeSingleValue(
					firstEntry.base,
					secondEntry.base,
					internalCaching
				);
			} else {
				// = first.base + ((first.byProperty (+default) + second.base) + second.byProperty)
				newBase = firstEntry.base;
				if (!intermediateByValues.has(&quot;default&quot;))
					intermediateByValues.set(&quot;default&quot;, secondEntry.base);
			}
			if (!secondEntry.byProperty) {
				// = first.base + (first.byProperty + second.base)
				return {
					base: newBase,
					byProperty: firstEntry.byProperty,
					byValues: intermediateByValues
				};
			} else if (firstEntry.byProperty !== secondEntry.byProperty) {
				throw new Error(
					`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`
				);
			}
			const newByValues = new Map(intermediateByValues);
			for (const [key, value] of secondEntry.byValues) {
				const firstValue = getFromByValues(intermediateByValues, key);
				newByValues.set(
					key,
					mergeSingleValue(firstValue, value, internalCaching)
				);
			}
			return {
				base: newBase,
				byProperty: firstEntry.byProperty,
				byValues: newByValues
			};
		}
	}
};

/**
 * @template V
 * @param {ByValues&lt;V&gt;} byValues all values
 * @param {string} key value of the selector
 * @returns {V | undefined} value
 */
const getFromByValues = (byValues, key) =&gt; {
	if (key !== &quot;default&quot; &amp;&amp; byValues.has(key)) {
		return byValues.get(key);
	}
	return byValues.get(&quot;default&quot;);
};

/**
 * @template A
 * @template B
 * @param {A | A[]} a value
 * @param {B | B[]} b value
 * @param {boolean} internalCaching should parsing of objects and nested merges be cached
 * @returns {A &amp; B | (A | B)[] | A | A[] | B | B[]} value
 */
const mergeSingleValue = (a, b, internalCaching) =&gt; {
	const bType = getValueType(b);
	const aType = getValueType(a);
	switch (bType) {
		case VALUE_TYPE_DELETE:
		case VALUE_TYPE_ATOM:
			return b;
		case VALUE_TYPE_OBJECT: {
			return aType !== VALUE_TYPE_OBJECT
				? b
				: internalCaching
					? cachedCleverMerge(a, b)
					: cleverMerge(a, b);
		}
		case VALUE_TYPE_UNDEFINED:
			return a;
		case VALUE_TYPE_ARRAY_EXTEND:
			switch (
				aType !== VALUE_TYPE_ATOM
					? aType
					: Array.isArray(a)
						? VALUE_TYPE_ARRAY_EXTEND
						: VALUE_TYPE_OBJECT
			) {
				case VALUE_TYPE_UNDEFINED:
					return b;
				case VALUE_TYPE_DELETE:
					return /** @type {B[]} */ (b).filter(item =&gt; item !== &quot;...&quot;);
				case VALUE_TYPE_ARRAY_EXTEND: {
					/** @type {(A | B)[]} */
					const newArray = [];
					for (const item of /** @type {B[]} */ (b)) {
						if (item === &quot;...&quot;) {
							for (const item of /** @type {A[]} */ (a)) {
								newArray.push(item);
							}
						} else {
							newArray.push(item);
						}
					}
					return newArray;
				}
				case VALUE_TYPE_OBJECT:
					return /** @type {(A | B)[]} */ (b).map(item =&gt;
						item === &quot;...&quot; ? /** @type {A} */ (a) : item
					);
				default:
					throw new Error(&quot;Not implemented&quot;);
			}
		default:
			throw new Error(&quot;Not implemented&quot;);
	}
};

/**
 * @template {object} T
 * @param {T} obj the object
 * @param {(keyof T)[]=} keysToKeepOriginalValue keys to keep original value
 * @returns {T} the object without operations like &quot;...&quot; or DELETE
 */
const removeOperations = (obj, keysToKeepOriginalValue = []) =&gt; {
	const newObj = /** @type {T} */ ({});
	for (const _key of Object.keys(obj)) {
		const key = /** @type {keyof T} */ (_key);
		const value = obj[key];
		const type = getValueType(value);
		if (type === VALUE_TYPE_OBJECT &amp;&amp; keysToKeepOriginalValue.includes(key)) {
			newObj[key] = value;
			continue;
		}
		switch (type) {
			case VALUE_TYPE_UNDEFINED:
			case VALUE_TYPE_DELETE:
				break;
			case VALUE_TYPE_OBJECT:
				newObj[key] =
					/** @type {T[keyof T]} */
					(
						removeOperations(
							/** @type {T} */
							(value),
							keysToKeepOriginalValue
						)
					);
				break;
			case VALUE_TYPE_ARRAY_EXTEND:
				newObj[key] =
					/** @type {T[keyof T]} */
					(
						/** @type {EXPECTED_ANY[]} */
						(value).filter(i =&gt; i !== &quot;...&quot;)
					);
				break;
			default:
				newObj[key] = value;
				break;
		}
	}
	return newObj;
};

/**
 * @template T
 * @template {keyof T} P
 * @template V
 * @param {T} obj the object
 * @param {P} byProperty the by description
 * @param {...V} values values
 * @returns {Omit&lt;T, P&gt;} object with merged byProperty
 */
const resolveByProperty = (obj, byProperty, ...values) =&gt; {
	if (typeof obj !== &quot;object&quot; || obj === null || !(byProperty in obj)) {
		return obj;
	}
	const { [byProperty]: _byValue, ..._remaining } = obj;
	const remaining = /** @type {T} */ (_remaining);
	const byValue =
		/** @type {Record&lt;string, T&gt; | ((...args: V[]) =&gt; T)} */
		(_byValue);
	if (typeof byValue === &quot;object&quot;) {
		const key = /** @type {string} */ (values[0]);
		if (key in byValue) {
			return cachedCleverMerge(remaining, byValue[key]);
		} else if (&quot;default&quot; in byValue) {
			return cachedCleverMerge(remaining, byValue.default);
		}
		return remaining;
	} else if (typeof byValue === &quot;function&quot;) {
		// eslint-disable-next-line prefer-spread
		const result = byValue.apply(null, values);
		return cachedCleverMerge(
			remaining,
			resolveByProperty(result, byProperty, ...values)
		);
	}
	return obj;
};

module.exports.cachedSetProperty = cachedSetProperty;
module.exports.cachedCleverMerge = cachedCleverMerge;
module.exports.cleverMerge = cleverMerge;
module.exports.resolveByProperty = resolveByProperty;
module.exports.removeOperations = removeOperations;
module.exports.DELETE = DELETE;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
