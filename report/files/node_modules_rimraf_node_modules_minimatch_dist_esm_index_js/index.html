<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/rimraf/node_modules/minimatch/dist/esm/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/rimraf/node_modules/minimatch/dist/esm/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1001</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">174.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { expand } from &#039;@isaacs/brace-expansion&#039;;
import { assertValidPattern } from &#039;./assert-valid-pattern.js&#039;;
import { AST } from &#039;./ast.js&#039;;
import { escape } from &#039;./escape.js&#039;;
import { unescape } from &#039;./unescape.js&#039;;
export const minimatch = (p, pattern, options = {}) =&gt; {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) =&gt; (f) =&gt; !f.startsWith(&#039;.&#039;) &amp;&amp; f.endsWith(ext);
const starDotExtTestDot = (ext) =&gt; (f) =&gt; f.endsWith(ext);
const starDotExtTestNocase = (ext) =&gt; {
    ext = ext.toLowerCase();
    return (f) =&gt; !f.startsWith(&#039;.&#039;) &amp;&amp; f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) =&gt; {
    ext = ext.toLowerCase();
    return (f) =&gt; f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) =&gt; !f.startsWith(&#039;.&#039;) &amp;&amp; f.includes(&#039;.&#039;);
const starDotStarTestDot = (f) =&gt; f !== &#039;.&#039; &amp;&amp; f !== &#039;..&#039; &amp;&amp; f.includes(&#039;.&#039;);
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) =&gt; f !== &#039;.&#039; &amp;&amp; f !== &#039;..&#039; &amp;&amp; f.startsWith(&#039;.&#039;);
const starRE = /^\*+$/;
const starTest = (f) =&gt; f.length !== 0 &amp;&amp; !f.startsWith(&#039;.&#039;);
const starTestDot = (f) =&gt; f.length !== 0 &amp;&amp; f !== &#039;.&#039; &amp;&amp; f !== &#039;..&#039;;
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = &#039;&#039;]) =&gt; {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) =&gt; noext(f) &amp;&amp; f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = &#039;&#039;]) =&gt; {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) =&gt; noext(f) &amp;&amp; f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = &#039;&#039;]) =&gt; {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) =&gt; noext(f) &amp;&amp; f.endsWith(ext);
};
const qmarksTest = ([$0, ext = &#039;&#039;]) =&gt; {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) =&gt; noext(f) &amp;&amp; f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) =&gt; {
    const len = $0.length;
    return (f) =&gt; f.length === len &amp;&amp; !f.startsWith(&#039;.&#039;);
};
const qmarksTestNoExtDot = ([$0]) =&gt; {
    const len = $0.length;
    return (f) =&gt; f.length === len &amp;&amp; f !== &#039;.&#039; &amp;&amp; f !== &#039;..&#039;;
};
/* c8 ignore start */
const defaultPlatform = (typeof process === &#039;object&#039; &amp;&amp; process
    ? (typeof process.env === &#039;object&#039; &amp;&amp;
        process.env &amp;&amp;
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : &#039;posix&#039;);
const path = {
    win32: { sep: &#039;\\&#039; },
    posix: { sep: &#039;/&#039; },
};
/* c8 ignore stop */
export const sep = defaultPlatform === &#039;win32&#039; ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
export const GLOBSTAR = Symbol(&#039;globstar **&#039;);
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don&#039;t need to escape / when using new RegExp()
const qmark = &#039;[^/]&#039;;
// * =&gt; any number of characters
const star = qmark + &#039;*?&#039;;
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = &#039;(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?&#039;;
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = &#039;(?:(?!(?:\\/|^)\\.).)*?&#039;;
export const filter = (pattern, options = {}) =&gt; (p) =&gt; minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) =&gt; Object.assign({}, a, b);
export const defaults = (def) =&gt; {
    if (!def || typeof def !== &#039;object&#039; || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) =&gt; orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) =&gt; orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) =&gt; orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) =&gt; orig.filter(pattern, ext(def, options)),
        defaults: (options) =&gt; orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) =&gt; orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) =&gt; orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) =&gt; orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -&gt; abd acd
// a{b,}c -&gt; abc ac
// a{0..3}d -&gt; a0d a1d a2d a3d
// a{b,c{d,e}f}g -&gt; abg acdfg acefg
// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -&gt; a{2..}b
// a{b}c -&gt; a{b}c
export const braceExpand = (pattern, options = {}) =&gt; {
    assertValidPattern(pattern);
    // Thanks to Yeting Li &lt;https://github.com/yetingli&gt; for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain &quot;/&quot; in it
// so we&#039;re going to return a 2d array, where each entry is the full
// pattern, split on &#039;/&#039;, and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
export const makeRe = (pattern, options = {}) =&gt; new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
export const match = (list, pattern, options = {}) =&gt; {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f =&gt; mm.match(f));
    if (mm.options.nonull &amp;&amp; !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) =&gt; s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &#039;\\$&amp;&#039;);
export class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === &#039;win32&#039;;
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, &#039;/&#039;);
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows &amp;&amp; this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces &amp;&amp; this.set.length &gt; 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== &#039;string&#039;)
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) =&gt; console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of &quot;**&quot;, which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s =&gt; this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --&gt; regexps
        let set = this.globParts.map((s, _, __) =&gt; {
            if (this.isWindows &amp;&amp; this.windowsNoMagicRoot) {
                // check if it&#039;s a drive or unc path.
                const isUNC = s[0] === &#039;&#039; &amp;&amp;
                    s[1] === &#039;&#039; &amp;&amp;
                    (s[2] === &#039;?&#039; || !globMagic.test(s[2])) &amp;&amp;
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss =&gt; this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss =&gt; this.parse(ss))];
                }
            }
            return s.map(ss =&gt; this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn&#039;t compile properly.
        this.set = set.filter(s =&gt; s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i &lt; this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === &#039;&#039; &amp;&amp;
                    p[1] === &#039;&#039; &amp;&amp;
                    this.globParts[i][2] === &#039;?&#039; &amp;&amp;
                    typeof p[3] === &#039;string&#039; &amp;&amp;
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = &#039;?&#039;;
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we&#039;re not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i &lt; globParts.length; i++) {
                for (let j = 0; j &lt; globParts[i].length; j++) {
                    if (globParts[i][j] === &#039;**&#039;) {
                        globParts[i][j] = &#039;*&#039;;
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel &gt;= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel &gt;= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts =&gt; {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf(&#039;**&#039;, gs + 1))) {
                let i = gs;
                while (parts[i + 1] === &#039;**&#039;) {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts =&gt; {
            parts = parts.reduce((set, part) =&gt; {
                const prev = set[set.length - 1];
                if (part === &#039;**&#039; &amp;&amp; prev === &#039;**&#039;) {
                    return set;
                }
                if (part === &#039;..&#039;) {
                    if (prev &amp;&amp; prev !== &#039;..&#039; &amp;&amp; prev !== &#039;.&#039; &amp;&amp; prev !== &#039;**&#039;) {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [&#039;&#039;] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // &lt;pre&gt;/&lt;e&gt;/&lt;rest&gt; -&gt; &lt;pre&gt;/&lt;rest&gt;
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i &lt; parts.length - 1; i++) {
                    const p = parts[i];
                    // don&#039;t squeeze out UNC patterns
                    if (i === 1 &amp;&amp; p === &#039;&#039; &amp;&amp; parts[0] === &#039;&#039;)
                        continue;
                    if (p === &#039;.&#039; || p === &#039;&#039;) {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === &#039;.&#039; &amp;&amp;
                    parts.length === 2 &amp;&amp;
                    (parts[1] === &#039;.&#039; || parts[1] === &#039;&#039;)) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // &lt;pre&gt;/&lt;p&gt;/../&lt;rest&gt; -&gt; &lt;pre&gt;/&lt;rest&gt;
            let dd = 0;
            while (-1 !== (dd = parts.indexOf(&#039;..&#039;, dd + 1))) {
                const p = parts[dd - 1];
                if (p &amp;&amp; p !== &#039;.&#039; &amp;&amp; p !== &#039;..&#039; &amp;&amp; p !== &#039;**&#039;) {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [&#039;&#039;] : parts;
    }
    // First phase: single-pattern processing
    // &lt;pre&gt; is 1 or more portions
    // &lt;rest&gt; is 1 or more portions
    // &lt;p&gt; is any portion other than ., .., &#039;&#039;, or **
    // &lt;e&gt; is . or &#039;&#039;
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and &#039;&#039;) can be.
    //
    // &lt;pre&gt;/**/../&lt;p&gt;/&lt;p&gt;/&lt;rest&gt; -&gt; {&lt;pre&gt;/../&lt;p&gt;/&lt;p&gt;/&lt;rest&gt;,&lt;pre&gt;/**/&lt;p&gt;/&lt;p&gt;/&lt;rest&gt;}
    // &lt;pre&gt;/&lt;e&gt;/&lt;rest&gt; -&gt; &lt;pre&gt;/&lt;rest&gt;
    // &lt;pre&gt;/&lt;p&gt;/../&lt;rest&gt; -&gt; &lt;pre&gt;/&lt;rest&gt;
    // **/**/&lt;rest&gt; -&gt; **/&lt;rest&gt;
    //
    // **/*/&lt;rest&gt; -&gt; */**/&lt;rest&gt; &lt;== not valid because ** doesn&#039;t follow
    // this WOULD be allowed if ** did follow symlinks, or * didn&#039;t
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // &lt;pre&gt;/**/../&lt;p&gt;/&lt;p&gt;/&lt;rest&gt; -&gt; {&lt;pre&gt;/../&lt;p&gt;/&lt;p&gt;/&lt;rest&gt;,&lt;pre&gt;/**/&lt;p&gt;/&lt;p&gt;/&lt;rest&gt;}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf(&#039;**&#039;, gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === &#039;**&#039;) {
                        // &lt;pre&gt;/**/**/&lt;rest&gt; -&gt; &lt;pre&gt;/**/&lt;rest&gt;
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss &gt; gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== &#039;..&#039;)
                        continue;
                    if (!p ||
                        p === &#039;.&#039; ||
                        p === &#039;..&#039; ||
                        !p2 ||
                        p2 === &#039;.&#039; ||
                        p2 === &#039;..&#039;) {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = &#039;**&#039;;
                    globParts.push(other);
                    gs--;
                }
                // &lt;pre&gt;/&lt;e&gt;/&lt;rest&gt; -&gt; &lt;pre&gt;/&lt;rest&gt;
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i &lt; parts.length - 1; i++) {
                        const p = parts[i];
                        // don&#039;t squeeze out UNC patterns
                        if (i === 1 &amp;&amp; p === &#039;&#039; &amp;&amp; parts[0] === &#039;&#039;)
                            continue;
                        if (p === &#039;.&#039; || p === &#039;&#039;) {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === &#039;.&#039; &amp;&amp;
                        parts.length === 2 &amp;&amp;
                        (parts[1] === &#039;.&#039; || parts[1] === &#039;&#039;)) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // &lt;pre&gt;/&lt;p&gt;/../&lt;rest&gt; -&gt; &lt;pre&gt;/&lt;rest&gt;
                let dd = 0;
                while (-1 !== (dd = parts.indexOf(&#039;..&#039;, dd + 1))) {
                    const p = parts[dd - 1];
                    if (p &amp;&amp; p !== &#039;.&#039; &amp;&amp; p !== &#039;..&#039; &amp;&amp; p !== &#039;**&#039;) {
                        didSomething = true;
                        const needDot = dd === 1 &amp;&amp; parts[dd + 1] === &#039;**&#039;;
                        const splin = needDot ? [&#039;.&#039;] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push(&#039;&#039;);
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {&lt;pre&gt;/*/&lt;rest&gt;,&lt;pre&gt;/&lt;p&gt;/&lt;rest&gt;} -&gt; &lt;pre&gt;/*/&lt;rest&gt;
    // {&lt;pre&gt;/&lt;rest&gt;,&lt;pre&gt;/&lt;rest&gt;} -&gt; &lt;pre&gt;/&lt;rest&gt;
    // {&lt;pre&gt;/**/&lt;rest&gt;,&lt;pre&gt;/&lt;rest&gt;} -&gt; &lt;pre&gt;/**/&lt;rest&gt;
    //
    // {&lt;pre&gt;/**/&lt;rest&gt;,&lt;pre&gt;/**/&lt;p&gt;/&lt;rest&gt;} -&gt; &lt;pre&gt;/**/&lt;rest&gt;
    // ^-- not valid because ** doens&#039;t follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i &lt; globParts.length - 1; i++) {
            for (let j = i + 1; j &lt; globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs =&gt; gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = &#039;&#039;;
        while (ai &lt; a.length &amp;&amp; bi &lt; b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === &#039;b&#039; ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch &amp;&amp; a[ai] === &#039;**&#039; &amp;&amp; b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch &amp;&amp; b[bi] === &#039;**&#039; &amp;&amp; a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === &#039;*&#039; &amp;&amp;
                b[bi] &amp;&amp;
                (this.options.dot || !b[bi].startsWith(&#039;.&#039;)) &amp;&amp;
                b[bi] !== &#039;**&#039;) {
                if (which === &#039;b&#039;)
                    return false;
                which = &#039;a&#039;;
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === &#039;*&#039; &amp;&amp;
                a[ai] &amp;&amp;
                (this.options.dot || !a[ai].startsWith(&#039;.&#039;)) &amp;&amp;
                a[ai] !== &#039;**&#039;) {
                if (which === &#039;a&#039;)
                    return false;
                which = &#039;b&#039;;
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length &amp;&amp; result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i &lt; pattern.length &amp;&amp; pattern.charAt(i) === &#039;!&#039;; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;
    // Partial means, if you run out of file before you run
    // out of pattern, then that&#039;s fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === &#039;string&#039; &amp;&amp; /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &amp;&amp;
                file[0] === &#039;&#039; &amp;&amp;
                file[1] === &#039;&#039; &amp;&amp;
                file[2] === &#039;?&#039; &amp;&amp;
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === &#039;string&#039; &amp;&amp; /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &amp;&amp;
                pattern[0] === &#039;&#039; &amp;&amp;
                pattern[1] === &#039;&#039; &amp;&amp;
                pattern[2] === &#039;?&#039; &amp;&amp;
                typeof pattern[3] === &#039;string&#039; &amp;&amp;
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === &#039;number&#039; &amp;&amp; typeof pdi === &#039;number&#039;) {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi &gt; fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi &gt; pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont&#039; need to do the second phase, because it&#039;s only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel &gt;= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug(&#039;matchOne&#039;, this, { file, pattern });
        this.debug(&#039;matchOne&#039;, file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi &lt; fl &amp;&amp; pi &lt; pl; fi++, pi++) {
            this.debug(&#039;matchOne loop&#039;);
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug(&#039;GLOBSTAR&#039;, [pattern, p, f]);
                // &quot;**&quot;
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** &quot;swallows&quot; a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -&gt; no
                //       - matchOne(y/z/c, c) -&gt; no
                //       - matchOne(z/c, c) -&gt; no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug(&#039;** at the end&#039;);
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi &lt; fl; fi++) {
                        if (file[fi] === &#039;.&#039; ||
                            file[fi] === &#039;..&#039; ||
                            (!options.dot &amp;&amp; file[fi].charAt(0) === &#039;.&#039;))
                            return false;
                    }
                    return true;
                }
                // ok, let&#039;s see if we can swallow whatever we can.
                while (fr &lt; fl) {
                    var swallowee = file[fr];
                    this.debug(&#039;\nglobstar while&#039;, file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug(&#039;globstar found match!&#039;, fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can&#039;t swallow &quot;.&quot; or &quot;..&quot; ever.
                        // can only swallow &quot;.foo&quot; when explicitly asked.
                        if (swallowee === &#039;.&#039; ||
                            swallowee === &#039;..&#039; ||
                            (!options.dot &amp;&amp; swallowee.charAt(0) === &#039;.&#039;)) {
                            this.debug(&#039;dot detected!&#039;, file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug(&#039;globstar swallow a segment, and continue&#039;);
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can&#039;t say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug(&#039;\n&gt;&gt;&gt; no match, partial?&#039;, file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === &#039;string&#039;) {
                hit = f === p;
                this.debug(&#039;string match&#039;, p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug(&#039;pattern match&#039;, p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we&#039;ll get a final &quot;&quot;
        // at the end of the pattern.  This can only match a
        // corresponding &quot;&quot; at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn&#039;t have any more for it. But, a/b/ should *not*
        // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we&#039;re done.
        if (fi === fl &amp;&amp; pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we&#039;re doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we&#039;re on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 &amp;&amp; file[fi] === &#039;&#039;;
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error(&#039;wtf?&#039;);
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === &#039;**&#039;)
            return GLOBSTAR;
        if (pattern === &#039;&#039;)
            return &#039;&#039;;
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.&lt;ext&gt;  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest &amp;&amp; typeof re === &#039;object&#039;) {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, &#039;test&#039;, { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or &quot;**&quot;.
        //
        // It&#039;s better to use .match().  This function shouldn&#039;t
        // be used, really, but it&#039;s pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? [&#039;i&#039;] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern =&gt; {
            const pp = pattern.map(p =&gt; {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(&#039;&#039;))
                        flags.add(f);
                }
                return typeof p === &#039;string&#039;
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) =&gt; {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined &amp;&amp; next !== GLOBSTAR) {
                        pp[i + 1] = &#039;(?:\\/|&#039; + twoStar + &#039;\\/)?&#039; + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + &#039;(?:\\/|&#039; + twoStar + &#039;)?&#039;;
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + &#039;(?:\\/|\\/&#039; + twoStar + &#039;\\/)&#039; + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            return pp.filter(p =&gt; p !== GLOBSTAR).join(&#039;/&#039;);
        })
            .join(&#039;|&#039;);
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length &gt; 1 ? [&#039;(?:&#039;, &#039;)&#039;] : [&#039;&#039;, &#039;&#039;];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = &#039;^&#039; + open + re + close + &#039;$&#039;;
        // can match anything, as long as it&#039;s not this.
        if (this.negate)
            re = &#039;^(?!&#039; + re + &#039;).+$&#039;;
        try {
            this.regexp = new RegExp(re, [...flags].join(&#039;&#039;));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren&#039;t broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split(&#039;/&#039;);
        }
        else if (this.isWindows &amp;&amp; /^\/\/[^\/]+/.test(p)) {
            // add an extra &#039;&#039; for the one we lose
            return [&#039;&#039;, ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug(&#039;match&#039;, f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === &#039;&#039;;
        }
        if (f === &#039;/&#039; &amp;&amp; partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split(&#039;\\&#039;).join(&#039;/&#039;);
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, &#039;split&#039;, ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, &#039;set&#039;, set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename &amp;&amp; i &gt;= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i &lt; set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase &amp;&amp; pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn&#039;t get any hits.  this is success if it&#039;s a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore start */
export { AST } from &#039;./ast.js&#039;;
export { escape } from &#039;./escape.js&#039;;
export { unescape } from &#039;./unescape.js&#039;;
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;
//# sourceMappingURL=index.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
