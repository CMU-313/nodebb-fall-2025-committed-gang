<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsonwebtoken/verify.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsonwebtoken/verify.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">48.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">264</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">51.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.64</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">const JsonWebTokenError = require(&#039;./lib/JsonWebTokenError&#039;);
const NotBeforeError = require(&#039;./lib/NotBeforeError&#039;);
const TokenExpiredError = require(&#039;./lib/TokenExpiredError&#039;);
const decode = require(&#039;./decode&#039;);
const timespan = require(&#039;./lib/timespan&#039;);
const validateAsymmetricKey = require(&#039;./lib/validateAsymmetricKey&#039;);
const PS_SUPPORTED = require(&#039;./lib/psSupported&#039;);
const jws = require(&#039;jws&#039;);
const {KeyObject, createSecretKey, createPublicKey} = require(&quot;crypto&quot;);

const PUB_KEY_ALGS = [&#039;RS256&#039;, &#039;RS384&#039;, &#039;RS512&#039;];
const EC_KEY_ALGS = [&#039;ES256&#039;, &#039;ES384&#039;, &#039;ES512&#039;];
const RSA_KEY_ALGS = [&#039;RS256&#039;, &#039;RS384&#039;, &#039;RS512&#039;];
const HS_ALGS = [&#039;HS256&#039;, &#039;HS384&#039;, &#039;HS512&#039;];

if (PS_SUPPORTED) {
  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, &#039;PS256&#039;, &#039;PS384&#039;, &#039;PS512&#039;);
  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, &#039;PS256&#039;, &#039;PS384&#039;, &#039;PS512&#039;);
}

module.exports = function (jwtString, secretOrPublicKey, options, callback) {
  if ((typeof options === &#039;function&#039;) &amp;&amp; !callback) {
    callback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  //clone this object since we are going to mutate it.
  options = Object.assign({}, options);

  let done;

  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }

  if (options.clockTimestamp &amp;&amp; typeof options.clockTimestamp !== &#039;number&#039;) {
    return done(new JsonWebTokenError(&#039;clockTimestamp must be a number&#039;));
  }

  if (options.nonce !== undefined &amp;&amp; (typeof options.nonce !== &#039;string&#039; || options.nonce.trim() === &#039;&#039;)) {
    return done(new JsonWebTokenError(&#039;nonce must be a non-empty string&#039;));
  }

  if (options.allowInvalidAsymmetricKeyTypes !== undefined &amp;&amp; typeof options.allowInvalidAsymmetricKeyTypes !== &#039;boolean&#039;) {
    return done(new JsonWebTokenError(&#039;allowInvalidAsymmetricKeyTypes must be a boolean&#039;));
  }

  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString){
    return done(new JsonWebTokenError(&#039;jwt must be provided&#039;));
  }

  if (typeof jwtString !== &#039;string&#039;) {
    return done(new JsonWebTokenError(&#039;jwt must be a string&#039;));
  }

  const parts = jwtString.split(&#039;.&#039;);

  if (parts.length !== 3){
    return done(new JsonWebTokenError(&#039;jwt malformed&#039;));
  }

  let decodedToken;

  try {
    decodedToken = decode(jwtString, { complete: true });
  } catch(err) {
    return done(err);
  }

  if (!decodedToken) {
    return done(new JsonWebTokenError(&#039;invalid token&#039;));
  }

  const header = decodedToken.header;
  let getSecret;

  if(typeof secretOrPublicKey === &#039;function&#039;) {
    if(!callback) {
      return done(new JsonWebTokenError(&#039;verify must be called asynchronous if secret or public key is provided as a callback&#039;));
    }

    getSecret = secretOrPublicKey;
  }
  else {
    getSecret = function(header, secretCallback) {
      return secretCallback(null, secretOrPublicKey);
    };
  }

  return getSecret(header, function(err, secretOrPublicKey) {
    if(err) {
      return done(new JsonWebTokenError(&#039;error in secret or public key callback: &#039; + err.message));
    }

    const hasSignature = parts[2].trim() !== &#039;&#039;;

    if (!hasSignature &amp;&amp; secretOrPublicKey){
      return done(new JsonWebTokenError(&#039;jwt signature is required&#039;));
    }

    if (hasSignature &amp;&amp; !secretOrPublicKey) {
      return done(new JsonWebTokenError(&#039;secret or public key must be provided&#039;));
    }

    if (!hasSignature &amp;&amp; !options.algorithms) {
      return done(new JsonWebTokenError(&#039;please specify &quot;none&quot; in &quot;algorithms&quot; to verify unsigned tokens&#039;));
    }

    if (secretOrPublicKey != null &amp;&amp; !(secretOrPublicKey instanceof KeyObject)) {
      try {
        secretOrPublicKey = createPublicKey(secretOrPublicKey);
      } catch (_) {
        try {
          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === &#039;string&#039; ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);
        } catch (_) {
          return done(new JsonWebTokenError(&#039;secretOrPublicKey is not valid key material&#039;))
        }
      }
    }

    if (!options.algorithms) {
      if (secretOrPublicKey.type === &#039;secret&#039;) {
        options.algorithms = HS_ALGS;
      } else if ([&#039;rsa&#039;, &#039;rsa-pss&#039;].includes(secretOrPublicKey.asymmetricKeyType)) {
        options.algorithms = RSA_KEY_ALGS
      } else if (secretOrPublicKey.asymmetricKeyType === &#039;ec&#039;) {
        options.algorithms = EC_KEY_ALGS
      } else {
        options.algorithms = PUB_KEY_ALGS
      }
    }

    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
      return done(new JsonWebTokenError(&#039;invalid algorithm&#039;));
    }

    if (header.alg.startsWith(&#039;HS&#039;) &amp;&amp; secretOrPublicKey.type !== &#039;secret&#039;) {
      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))
    } else if (/^(?:RS|PS|ES)/.test(header.alg) &amp;&amp; secretOrPublicKey.type !== &#039;public&#039;) {
      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))
    }

    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPublicKey);
      } catch (e) {
        return done(e);
      }
    }

    let valid;

    try {
      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
    } catch (e) {
      return done(e);
    }

    if (!valid) {
      return done(new JsonWebTokenError(&#039;invalid signature&#039;));
    }

    const payload = decodedToken.payload;

    if (typeof payload.nbf !== &#039;undefined&#039; &amp;&amp; !options.ignoreNotBefore) {
      if (typeof payload.nbf !== &#039;number&#039;) {
        return done(new JsonWebTokenError(&#039;invalid nbf value&#039;));
      }
      if (payload.nbf &gt; clockTimestamp + (options.clockTolerance || 0)) {
        return done(new NotBeforeError(&#039;jwt not active&#039;, new Date(payload.nbf * 1000)));
      }
    }

    if (typeof payload.exp !== &#039;undefined&#039; &amp;&amp; !options.ignoreExpiration) {
      if (typeof payload.exp !== &#039;number&#039;) {
        return done(new JsonWebTokenError(&#039;invalid exp value&#039;));
      }
      if (clockTimestamp &gt;= payload.exp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError(&#039;jwt expired&#039;, new Date(payload.exp * 1000)));
      }
    }

    if (options.audience) {
      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

      const match = target.some(function (targetAudience) {
        return audiences.some(function (audience) {
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
        });
      });

      if (!match) {
        return done(new JsonWebTokenError(&#039;jwt audience invalid. expected: &#039; + audiences.join(&#039; or &#039;)));
      }
    }

    if (options.issuer) {
      const invalid_issuer =
              (typeof options.issuer === &#039;string&#039; &amp;&amp; payload.iss !== options.issuer) ||
              (Array.isArray(options.issuer) &amp;&amp; options.issuer.indexOf(payload.iss) === -1);

      if (invalid_issuer) {
        return done(new JsonWebTokenError(&#039;jwt issuer invalid. expected: &#039; + options.issuer));
      }
    }

    if (options.subject) {
      if (payload.sub !== options.subject) {
        return done(new JsonWebTokenError(&#039;jwt subject invalid. expected: &#039; + options.subject));
      }
    }

    if (options.jwtid) {
      if (payload.jti !== options.jwtid) {
        return done(new JsonWebTokenError(&#039;jwt jwtid invalid. expected: &#039; + options.jwtid));
      }
    }

    if (options.nonce) {
      if (payload.nonce !== options.nonce) {
        return done(new JsonWebTokenError(&#039;jwt nonce invalid. expected: &#039; + options.nonce));
      }
    }

    if (options.maxAge) {
      if (typeof payload.iat !== &#039;number&#039;) {
        return done(new JsonWebTokenError(&#039;iat required when maxAge is specified&#039;));
      }

      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === &#039;undefined&#039;) {
        return done(new JsonWebTokenError(&#039;&quot;maxAge&quot; should be a number of seconds or string representing a timespan eg: &quot;1d&quot;, &quot;20h&quot;, 60&#039;));
      }
      if (clockTimestamp &gt;= maxAgeTimestamp + (options.clockTolerance || 0)) {
        return done(new TokenExpiredError(&#039;maxAge exceeded&#039;, new Date(maxAgeTimestamp * 1000)));
      }
    }

    if (options.complete === true) {
      const signature = decodedToken.signature;

      return done(null, {
        header: header,
        payload: payload,
        signature: signature
      });
    }

    return done(null, payload);
  });
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
