<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cron/dist/time.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cron/dist/time.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">311</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">114.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.CronTime = void 0;
const luxon_1 = require(&quot;luxon&quot;);
const constants_1 = require(&quot;./constants&quot;);
const errors_1 = require(&quot;./errors&quot;);
class CronTime {
    constructor(source, timeZone, utcOffset) {
        this.realDate = false;
        this.second = {};
        this.minute = {};
        this.hour = {};
        this.dayOfMonth = {};
        this.month = {};
        this.dayOfWeek = {};
        if (timeZone != null &amp;&amp; utcOffset != null) {
            throw new errors_1.ExclusiveParametersError(&#039;timeZone&#039;, &#039;utcOffset&#039;);
        }
        if (timeZone) {
            const dt = luxon_1.DateTime.fromObject({}, { zone: timeZone });
            if (!dt.isValid) {
                throw new errors_1.CronError(&#039;Invalid timezone.&#039;);
            }
            this.timeZone = timeZone;
        }
        if (utcOffset != null) {
            this.utcOffset = utcOffset;
        }
        if (timeZone == null &amp;&amp; utcOffset == null) {
            const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            this.timeZone = systemTimezone;
        }
        if (source instanceof Date || source instanceof luxon_1.DateTime) {
            this.source =
                source instanceof Date ? luxon_1.DateTime.fromJSDate(source) : source;
            this.realDate = true;
        }
        else {
            this.source = source;
            this._parse(this.source);
        }
    }
    static validateCronExpression(cronExpression) {
        try {
            new CronTime(cronExpression);
            return {
                valid: true
            };
        }
        catch (error) {
            return {
                valid: false,
                error
            };
        }
    }
    _getWeekDay(date) {
        return date.weekday === 7 ? 0 : date.weekday;
    }
    sendAt(i) {
        let date = this.realDate &amp;&amp; this.source instanceof luxon_1.DateTime
            ? this.source
            : luxon_1.DateTime.utc();
        if (this.timeZone) {
            date = date.setZone(this.timeZone);
        }
        if (this.utcOffset !== undefined) {
            const sign = this.utcOffset &lt; 0 ? &#039;-&#039; : &#039;+&#039;;
            const offsetHours = Math.trunc(this.utcOffset / 60);
            const offsetHoursStr = String(Math.abs(offsetHours)).padStart(2, &#039;0&#039;);
            const offsetMins = Math.abs(this.utcOffset - offsetHours * 60);
            const offsetMinsStr = String(offsetMins).padStart(2, &#039;0&#039;);
            const utcZone = `UTC${sign}${offsetHoursStr}:${offsetMinsStr}`;
            date = date.setZone(utcZone);
            if (!date.isValid) {
                throw new errors_1.CronError(&#039;ERROR: You specified an invalid UTC offset.&#039;);
            }
        }
        if (this.realDate) {
            if (luxon_1.DateTime.local() &gt; date) {
                throw new errors_1.CronError(&#039;WARNING: Date in past. Will never be fired.&#039;);
            }
            return date;
        }
        if (i === undefined || isNaN(i) || i &lt; 0) {
            const nextDate = this.getNextDateFrom(date);
            return nextDate;
        }
        else {
            const dates = [];
            for (; i &gt; 0; i--) {
                date = this.getNextDateFrom(date);
                dates.push(date);
            }
            return dates;
        }
    }
    getTimeout() {
        return this.sendAt().toMillis() - luxon_1.DateTime.local().toMillis();
    }
    toString() {
        return this.toJSON().join(&#039; &#039;);
    }
    toJSON() {
        return constants_1.TIME_UNITS.map(unit =&gt; {
            return this._wcOrAll(unit);
        });
    }
    getNextDateFrom(start, timeZone) {
        var _a, _b;
        if (start instanceof Date) {
            start = luxon_1.DateTime.fromJSDate(start);
        }
        if (timeZone) {
            start = start.setZone(timeZone);
        }
        else {
            timeZone = (_a = start.zone.zoneName) !== null &amp;&amp; _a !== void 0 ? _a : start.zone.fixed;
        }
        let date = luxon_1.DateTime.fromFormat(`${start.year}-${start.month}-${start.day} ${start.hour}:${start.minute}:${start.second}`, &#039;yyyy-M-d H:m:s&#039;, {
            zone: &#039;UTC&#039;
        });
        const firstDate = date.toMillis();
        if (!this.realDate) {
            if (date.millisecond &gt; 0) {
                date = date.set({ millisecond: 0, second: date.second + 1 });
            }
        }
        if (!date.isValid) {
            throw new errors_1.CronError(&#039;ERROR: You specified an invalid date.&#039;);
        }
        const maxMatch = luxon_1.DateTime.now().plus({ years: 8 });
        while (true) {
            if (date &gt; maxMatch) {
                throw new errors_1.CronError(`Something went wrong. No execution date was found in the next 8 years.
							Please provide the following string if you would like to help debug:
							Time Zone: ${(_b = timeZone === null || timeZone === void 0 ? void 0 : timeZone.toString()) !== null &amp;&amp; _b !== void 0 ? _b : &#039;&quot;&quot;&#039;} - Cron String: ${this.source.toString()} - UTC offset: ${date.offset} - current Date: ${luxon_1.DateTime.local().toString()}`);
            }
            if (!(date.month in this.month) &amp;&amp;
                Object.keys(this.month).length !== 12) {
                date = date.plus({ month: 1 });
                date = date.set({ day: 1, hour: 0, minute: 0, second: 0 });
                continue;
            }
            if ((!(date.day in this.dayOfMonth) &amp;&amp;
                Object.keys(this.dayOfMonth).length !== 31 &amp;&amp;
                !(this._getWeekDay(date) in this.dayOfWeek &amp;&amp;
                    Object.keys(this.dayOfWeek).length !== 7)) ||
                (!(this._getWeekDay(date) in this.dayOfWeek) &amp;&amp;
                    Object.keys(this.dayOfWeek).length !== 7 &amp;&amp;
                    !(date.day in this.dayOfMonth &amp;&amp;
                        Object.keys(this.dayOfMonth).length !== 31))) {
                date = date.plus({ days: 1 });
                date = date.set({ hour: 0, minute: 0, second: 0 });
                continue;
            }
            if (!(date.hour in this.hour) &amp;&amp; Object.keys(this.hour).length !== 24) {
                date = date.plus({ hour: 1 });
                date = date.set({ minute: 0, second: 0 });
                continue;
            }
            if (!(date.minute in this.minute) &amp;&amp;
                Object.keys(this.minute).length !== 60) {
                date = date.plus({ minute: 1 });
                date = date.set({ second: 0 });
                continue;
            }
            if (date.toMillis() === firstDate ||
                (!(date.second in this.second) &amp;&amp;
                    Object.keys(this.second).length !== 60)) {
                date = date.plus({ second: 1 });
                continue;
            }
            break;
        }
        const expectedHour = date.hour;
        const expectedMinute = date.minute;
        date = luxon_1.DateTime.fromFormat(`${date.year}-${date.month}-${date.day} ${date.hour}:${date.minute}:${date.second}`, &#039;yyyy-M-d H:m:s&#039;, {
            zone: timeZone
        });
        const nonDSTReferenceDate = luxon_1.DateTime.fromFormat(`${date.year}-1-1 0:0:0`, &#039;yyyy-M-d H:m:s&#039;, { zone: timeZone });
        if ((expectedHour !== date.hour || expectedMinute !== date.minute) &amp;&amp;
            nonDSTReferenceDate.offset !== date.offset) {
            while (date.minus({ minute: 1 }).offset !== nonDSTReferenceDate.offset) {
                date = date.minus({ minute: 1 });
            }
            return date;
        }
        const hourTestDate = date.minus({ hour: 1 });
        const twoHourTestDate = date.minus({ hour: 2 });
        if ((hourTestDate.hour === date.hour ||
            twoHourTestDate.hour === hourTestDate.hour) &amp;&amp;
            hourTestDate &gt; start) {
            date = hourTestDate;
        }
        const halfHourTestDate = date.minus({ minute: 30 });
        if ((halfHourTestDate.minute === date.minute ||
            hourTestDate.minute === halfHourTestDate.minute) &amp;&amp;
            halfHourTestDate &gt; start) {
            date = halfHourTestDate;
        }
        return date;
    }
    _wcOrAll(unit) {
        if (this._hasAll(unit)) {
            return &#039;*&#039;;
        }
        const all = [];
        for (const time in this[unit]) {
            all.push(time);
        }
        return all.join(&#039;,&#039;);
    }
    _hasAll(unit) {
        const constraints = constants_1.CONSTRAINTS[unit];
        const low = constraints[0];
        const high = unit === constants_1.TIME_UNITS_MAP.DAY_OF_WEEK ? constraints[1] - 1 : constraints[1];
        for (let i = low, n = high; i &lt; n; i++) {
            if (!(i in this[unit])) {
                return false;
            }
        }
        return true;
    }
    _parse(source) {
        var _a;
        source = source.toLowerCase();
        if (Object.keys(constants_1.PRESETS).includes(source)) {
            source = constants_1.PRESETS[source];
        }
        source = source.replace(/[a-z]{1,3}/gi, (alias) =&gt; {
            if (Object.keys(constants_1.ALIASES).includes(alias)) {
                return constants_1.ALIASES[alias].toString();
            }
            throw new errors_1.CronError(`Unknown alias: ${alias}`);
        });
        const units = source.trim().split(/\s+/);
        if (units.length &lt; constants_1.TIME_UNITS_LEN - 1) {
            throw new errors_1.CronError(&#039;Too few fields&#039;);
        }
        if (units.length &gt; constants_1.TIME_UNITS_LEN) {
            throw new errors_1.CronError(&#039;Too many fields&#039;);
        }
        const unitsLen = units.length;
        for (const unit of constants_1.TIME_UNITS) {
            const i = constants_1.TIME_UNITS.indexOf(unit);
            const cur = (_a = units[i - (constants_1.TIME_UNITS_LEN - unitsLen)]) !== null &amp;&amp; _a !== void 0 ? _a : constants_1.PARSE_DEFAULTS[unit];
            this._parseField(cur, unit);
        }
    }
    _parseField(value, unit) {
        const typeObj = this[unit];
        let pointer;
        const constraints = constants_1.CONSTRAINTS[unit];
        const low = constraints[0];
        const high = constraints[1];
        const fields = value.split(&#039;,&#039;);
        fields.forEach(field =&gt; {
            const wildcardIndex = field.indexOf(&#039;*&#039;);
            if (wildcardIndex !== -1 &amp;&amp; wildcardIndex !== 0) {
                throw new errors_1.CronError(`Field (${field}) has an invalid wildcard expression`);
            }
        });
        value = value.replace(constants_1.RE_WILDCARDS, `${low}-${high}`);
        const allRanges = value.split(&#039;,&#039;);
        for (const range of allRanges) {
            const match = [...range.matchAll(constants_1.RE_RANGE)][0];
            if ((match === null || match === void 0 ? void 0 : match[1]) !== undefined) {
                const [, mLower, mUpper, mStep] = match;
                let lower = parseInt(mLower, 10);
                let upper = mUpper !== undefined ? parseInt(mUpper, 10) : undefined;
                const wasStepDefined = mStep !== undefined;
                const step = parseInt(mStep !== null &amp;&amp; mStep !== void 0 ? mStep : &#039;1&#039;, 10);
                if (step === 0) {
                    throw new errors_1.CronError(`Field (${unit}) has a step of zero`);
                }
                if (upper !== undefined &amp;&amp; lower &gt; upper) {
                    throw new errors_1.CronError(`Field (${unit}) has an invalid range`);
                }
                const isOutOfRange = lower &lt; low ||
                    (upper !== undefined &amp;&amp; upper &gt; high) ||
                    (upper === undefined &amp;&amp; lower &gt; high);
                if (isOutOfRange) {
                    throw new errors_1.CronError(`Field value (${value}) is out of range`);
                }
                lower = Math.min(Math.max(low, ~~Math.abs(lower)), high);
                if (upper !== undefined) {
                    upper = Math.min(high, ~~Math.abs(upper));
                }
                else {
                    upper = wasStepDefined ? high : lower;
                }
                pointer = lower;
                do {
                    typeObj[pointer] = true;
                    pointer += step;
                } while (pointer &lt;= upper);
                if (unit === &#039;dayOfWeek&#039;) {
                    if (!typeObj[0] &amp;&amp; !!typeObj[7])
                        typeObj[0] = typeObj[7];
                    delete typeObj[7];
                }
            }
            else {
                throw new errors_1.CronError(`Field (${unit}) cannot be parsed`);
            }
        }
    }
}
exports.CronTime = CronTime;
//# sourceMappingURL=time.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
