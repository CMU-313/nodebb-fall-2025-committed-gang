<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/Compiler.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/Compiler.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.17</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1382</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">79.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const parseJson = require(&quot;json-parse-even-better-errors&quot;);
const asyncLib = require(&quot;neo-async&quot;);
const {
	SyncHook,
	SyncBailHook,
	AsyncParallelHook,
	AsyncSeriesHook
} = require(&quot;tapable&quot;);
const { SizeOnlySource } = require(&quot;webpack-sources&quot;);
const webpack = require(&quot;.&quot;);
const Cache = require(&quot;./Cache&quot;);
const CacheFacade = require(&quot;./CacheFacade&quot;);
const ChunkGraph = require(&quot;./ChunkGraph&quot;);
const Compilation = require(&quot;./Compilation&quot;);
const ConcurrentCompilationError = require(&quot;./ConcurrentCompilationError&quot;);
const ContextModuleFactory = require(&quot;./ContextModuleFactory&quot;);
const ModuleGraph = require(&quot;./ModuleGraph&quot;);
const NormalModuleFactory = require(&quot;./NormalModuleFactory&quot;);
const RequestShortener = require(&quot;./RequestShortener&quot;);
const ResolverFactory = require(&quot;./ResolverFactory&quot;);
const Stats = require(&quot;./Stats&quot;);
const Watching = require(&quot;./Watching&quot;);
const WebpackError = require(&quot;./WebpackError&quot;);
const { Logger } = require(&quot;./logging/Logger&quot;);
const { join, dirname, mkdirp } = require(&quot;./util/fs&quot;);
const { makePathsRelative } = require(&quot;./util/identifier&quot;);
const { isSourceEqual } = require(&quot;./util/source&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).EntryNormalized} Entry */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).OutputNormalized} OutputOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WatchOptions} WatchOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackPluginInstance} WebpackPluginInstance */
/** @typedef {import(&quot;./Chunk&quot;)} Chunk */
/** @typedef {import(&quot;./ChunkGraph&quot;).ModuleId} ModuleId */
/** @typedef {import(&quot;./Dependency&quot;)} Dependency */
/** @typedef {import(&quot;./Module&quot;)} Module */
/** @typedef {import(&quot;./Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;./config/target&quot;).PlatformTargetProperties} PlatformTargetProperties */
/** @typedef {import(&quot;./logging/createConsoleLogger&quot;).LoggingFunction} LoggingFunction */
/** @typedef {import(&quot;./util/fs&quot;).IStats} IStats */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/** @typedef {import(&quot;./util/fs&quot;).IntermediateFileSystem} IntermediateFileSystem */
/** @typedef {import(&quot;./util/fs&quot;).OutputFileSystem} OutputFileSystem */
/** @typedef {import(&quot;./util/fs&quot;).TimeInfoEntries} TimeInfoEntries */
/** @typedef {import(&quot;./util/fs&quot;).WatchFileSystem} WatchFileSystem */

/**
 * @typedef {object} CompilationParams
 * @property {NormalModuleFactory} normalModuleFactory
 * @property {ContextModuleFactory} contextModuleFactory
 */

/**
 * @template T
 * @callback RunCallback
 * @param {Error | null} err
 * @param {T=} result
 */

/**
 * @template T
 * @callback Callback
 * @param {(Error | null)=} err
 * @param {T=} result
 */

/**
 * @callback RunAsChildCallback
 * @param {Error | null} err
 * @param {Chunk[]=} entries
 * @param {Compilation=} compilation
 */

/**
 * @typedef {object} AssetEmittedInfo
 * @property {Buffer} content
 * @property {Source} source
 * @property {Compilation} compilation
 * @property {string} outputPath
 * @property {string} targetPath
 */

/** @typedef {{ sizeOnlySource: SizeOnlySource | undefined, writtenTo: Map&lt;string, number&gt; }} CacheEntry */
/** @typedef {{ path: string, source: Source, size: number | undefined, waiting: ({ cacheEntry: CacheEntry, file: string }[] | undefined) }} SimilarEntry */

/** @typedef {WeakMap&lt;Dependency, Module&gt;} WeakReferences */
/** @typedef {import(&quot;./util/WeakTupleMap&quot;)&lt;EXPECTED_ANY[], EXPECTED_ANY&gt;} MemCache */
/** @typedef {{ buildInfo: BuildInfo, references: WeakReferences | undefined, memCache: MemCache }} ModuleMemCachesItem */

/**
 * @param {string[]} array an array
 * @returns {boolean} true, if the array is sorted
 */
const isSorted = array =&gt; {
	for (let i = 1; i &lt; array.length; i++) {
		if (array[i - 1] &gt; array[i]) return false;
	}
	return true;
};

/**
 * @template {object} T
 * @param {T} obj an object
 * @param {(keyof T)[]} keys the keys of the object
 * @returns {T} the object with properties sorted by property name
 */
const sortObject = (obj, keys) =&gt; {
	const o = /** @type {T} */ ({});
	for (const k of keys.sort()) {
		o[k] = obj[k];
	}
	return o;
};

/**
 * @param {string} filename filename
 * @param {string | string[] | undefined} hashes list of hashes
 * @returns {boolean} true, if the filename contains any hash
 */
const includesHash = (filename, hashes) =&gt; {
	if (!hashes) return false;
	if (Array.isArray(hashes)) {
		return hashes.some(hash =&gt; filename.includes(hash));
	}
	return filename.includes(hashes);
};

class Compiler {
	/**
	 * @param {string} context the compilation path
	 * @param {WebpackOptions} options options
	 */
	constructor(context, options = /** @type {WebpackOptions} */ ({})) {
		this.hooks = Object.freeze({
			/** @type {SyncHook&lt;[]&gt;} */
			initialize: new SyncHook([]),

			/** @type {SyncBailHook&lt;[Compilation], boolean | void&gt;} */
			shouldEmit: new SyncBailHook([&quot;compilation&quot;]),
			/** @type {AsyncSeriesHook&lt;[Stats]&gt;} */
			done: new AsyncSeriesHook([&quot;stats&quot;]),
			/** @type {SyncHook&lt;[Stats]&gt;} */
			afterDone: new SyncHook([&quot;stats&quot;]),
			/** @type {AsyncSeriesHook&lt;[]&gt;} */
			additionalPass: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook&lt;[Compiler]&gt;} */
			beforeRun: new AsyncSeriesHook([&quot;compiler&quot;]),
			/** @type {AsyncSeriesHook&lt;[Compiler]&gt;} */
			run: new AsyncSeriesHook([&quot;compiler&quot;]),
			/** @type {AsyncSeriesHook&lt;[Compilation]&gt;} */
			emit: new AsyncSeriesHook([&quot;compilation&quot;]),
			/** @type {AsyncSeriesHook&lt;[string, AssetEmittedInfo]&gt;} */
			assetEmitted: new AsyncSeriesHook([&quot;file&quot;, &quot;info&quot;]),
			/** @type {AsyncSeriesHook&lt;[Compilation]&gt;} */
			afterEmit: new AsyncSeriesHook([&quot;compilation&quot;]),

			/** @type {SyncHook&lt;[Compilation, CompilationParams]&gt;} */
			thisCompilation: new SyncHook([&quot;compilation&quot;, &quot;params&quot;]),
			/** @type {SyncHook&lt;[Compilation, CompilationParams]&gt;} */
			compilation: new SyncHook([&quot;compilation&quot;, &quot;params&quot;]),
			/** @type {SyncHook&lt;[NormalModuleFactory]&gt;} */
			normalModuleFactory: new SyncHook([&quot;normalModuleFactory&quot;]),
			/** @type {SyncHook&lt;[ContextModuleFactory]&gt;}  */
			contextModuleFactory: new SyncHook([&quot;contextModuleFactory&quot;]),

			/** @type {AsyncSeriesHook&lt;[CompilationParams]&gt;} */
			beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),
			/** @type {SyncHook&lt;[CompilationParams]&gt;} */
			compile: new SyncHook([&quot;params&quot;]),
			/** @type {AsyncParallelHook&lt;[Compilation]&gt;} */
			make: new AsyncParallelHook([&quot;compilation&quot;]),
			/** @type {AsyncParallelHook&lt;[Compilation]&gt;} */
			finishMake: new AsyncSeriesHook([&quot;compilation&quot;]),
			/** @type {AsyncSeriesHook&lt;[Compilation]&gt;} */
			afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),

			/** @type {AsyncSeriesHook&lt;[]&gt;} */
			readRecords: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook&lt;[]&gt;} */
			emitRecords: new AsyncSeriesHook([]),

			/** @type {AsyncSeriesHook&lt;[Compiler]&gt;} */
			watchRun: new AsyncSeriesHook([&quot;compiler&quot;]),
			/** @type {SyncHook&lt;[Error]&gt;} */
			failed: new SyncHook([&quot;error&quot;]),
			/** @type {SyncHook&lt;[string | null, number]&gt;} */
			invalid: new SyncHook([&quot;filename&quot;, &quot;changeTime&quot;]),
			/** @type {SyncHook&lt;[]&gt;} */
			watchClose: new SyncHook([]),
			/** @type {AsyncSeriesHook&lt;[]&gt;} */
			shutdown: new AsyncSeriesHook([]),

			/** @type {SyncBailHook&lt;[string, string, EXPECTED_ANY[] | undefined], true | void&gt;} */
			infrastructureLog: new SyncBailHook([&quot;origin&quot;, &quot;type&quot;, &quot;args&quot;]),

			// TODO the following hooks are weirdly located here
			// TODO move them for webpack 5
			/** @type {SyncHook&lt;[]&gt;} */
			environment: new SyncHook([]),
			/** @type {SyncHook&lt;[]&gt;} */
			afterEnvironment: new SyncHook([]),
			/** @type {SyncHook&lt;[Compiler]&gt;} */
			afterPlugins: new SyncHook([&quot;compiler&quot;]),
			/** @type {SyncHook&lt;[Compiler]&gt;} */
			afterResolvers: new SyncHook([&quot;compiler&quot;]),
			/** @type {SyncBailHook&lt;[string, Entry], boolean | void&gt;} */
			entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])
		});

		this.webpack = webpack;

		/** @type {string | undefined} */
		this.name = undefined;
		/** @type {Compilation | undefined} */
		this.parentCompilation = undefined;
		/** @type {Compiler} */
		this.root = this;
		/** @type {string} */
		this.outputPath = &quot;&quot;;
		/** @type {Watching | undefined} */
		this.watching = undefined;

		/** @type {OutputFileSystem | null} */
		this.outputFileSystem = null;
		/** @type {IntermediateFileSystem | null} */
		this.intermediateFileSystem = null;
		/** @type {InputFileSystem | null} */
		this.inputFileSystem = null;
		/** @type {WatchFileSystem | null} */
		this.watchFileSystem = null;

		/** @type {string|null} */
		this.recordsInputPath = null;
		/** @type {string|null} */
		this.recordsOutputPath = null;
		/** @type {Record&lt;string, TODO&gt;} */
		this.records = {};
		/** @type {Set&lt;string | RegExp&gt;} */
		this.managedPaths = new Set();
		/** @type {Set&lt;string | RegExp&gt;} */
		this.unmanagedPaths = new Set();
		/** @type {Set&lt;string | RegExp&gt;} */
		this.immutablePaths = new Set();

		/** @type {ReadonlySet&lt;string&gt; | undefined} */
		this.modifiedFiles = undefined;
		/** @type {ReadonlySet&lt;string&gt; | undefined} */
		this.removedFiles = undefined;
		/** @type {TimeInfoEntries | undefined} */
		this.fileTimestamps = undefined;
		/** @type {TimeInfoEntries | undefined} */
		this.contextTimestamps = undefined;
		/** @type {number | undefined} */
		this.fsStartTime = undefined;

		/** @type {ResolverFactory} */
		this.resolverFactory = new ResolverFactory();

		/** @type {LoggingFunction | undefined} */
		this.infrastructureLogger = undefined;

		/** @type {Readonly&lt;PlatformTargetProperties&gt;} */
		this.platform = {
			web: null,
			browser: null,
			webworker: null,
			node: null,
			nwjs: null,
			electron: null
		};

		this.options = options;

		this.context = context;

		this.requestShortener = new RequestShortener(context, this.root);

		this.cache = new Cache();

		/** @type {Map&lt;Module, ModuleMemCachesItem&gt; | undefined} */
		this.moduleMemCaches = undefined;

		this.compilerPath = &quot;&quot;;

		/** @type {boolean} */
		this.running = false;

		/** @type {boolean} */
		this.idle = false;

		/** @type {boolean} */
		this.watchMode = false;

		this._backCompat = this.options.experiments.backCompat !== false;

		/** @type {Compilation | undefined} */
		this._lastCompilation = undefined;
		/** @type {NormalModuleFactory | undefined} */
		this._lastNormalModuleFactory = undefined;

		/**
		 * @private
		 * @type {WeakMap&lt;Source, CacheEntry&gt;}
		 */
		this._assetEmittingSourceCache = new WeakMap();
		/**
		 * @private
		 * @type {Map&lt;string, number&gt;}
		 */
		this._assetEmittingWrittenFiles = new Map();
		/**
		 * @private
		 * @type {Set&lt;string&gt;}
		 */
		this._assetEmittingPreviousFiles = new Set();
	}

	/**
	 * @param {string} name cache name
	 * @returns {CacheFacade} the cache facade instance
	 */
	getCache(name) {
		return new CacheFacade(
			this.cache,
			`${this.compilerPath}${name}`,
			this.options.output.hashFunction
		);
	}

	/**
	 * @param {string | (() =&gt; string)} name name of the logger, or function called once to get the logger name
	 * @returns {Logger} a logger with that name
	 */
	getInfrastructureLogger(name) {
		if (!name) {
			throw new TypeError(
				&quot;Compiler.getInfrastructureLogger(name) called without a name&quot;
			);
		}
		return new Logger(
			(type, args) =&gt; {
				if (typeof name === &quot;function&quot;) {
					name = name();
					if (!name) {
						throw new TypeError(
							&quot;Compiler.getInfrastructureLogger(name) called with a function not returning a name&quot;
						);
					}
				}
				if (
					this.hooks.infrastructureLog.call(name, type, args) === undefined &amp;&amp;
					this.infrastructureLogger !== undefined
				) {
					this.infrastructureLogger(name, type, args);
				}
			},
			childName =&gt; {
				if (typeof name === &quot;function&quot;) {
					if (typeof childName === &quot;function&quot;) {
						return this.getInfrastructureLogger(() =&gt; {
							if (typeof name === &quot;function&quot;) {
								name = name();
								if (!name) {
									throw new TypeError(
										&quot;Compiler.getInfrastructureLogger(name) called with a function not returning a name&quot;
									);
								}
							}
							if (typeof childName === &quot;function&quot;) {
								childName = childName();
								if (!childName) {
									throw new TypeError(
										&quot;Logger.getChildLogger(name) called with a function not returning a name&quot;
									);
								}
							}
							return `${name}/${childName}`;
						});
					}
					return this.getInfrastructureLogger(() =&gt; {
						if (typeof name === &quot;function&quot;) {
							name = name();
							if (!name) {
								throw new TypeError(
									&quot;Compiler.getInfrastructureLogger(name) called with a function not returning a name&quot;
								);
							}
						}
						return `${name}/${childName}`;
					});
				}
				if (typeof childName === &quot;function&quot;) {
					return this.getInfrastructureLogger(() =&gt; {
						if (typeof childName === &quot;function&quot;) {
							childName = childName();
							if (!childName) {
								throw new TypeError(
									&quot;Logger.getChildLogger(name) called with a function not returning a name&quot;
								);
							}
						}
						return `${name}/${childName}`;
					});
				}
				return this.getInfrastructureLogger(`${name}/${childName}`);
			}
		);
	}

	// TODO webpack 6: solve this in a better way
	// e.g. move compilation specific info from Modules into ModuleGraph
	_cleanupLastCompilation() {
		if (this._lastCompilation !== undefined) {
			for (const childCompilation of this._lastCompilation.children) {
				for (const module of childCompilation.modules) {
					ChunkGraph.clearChunkGraphForModule(module);
					ModuleGraph.clearModuleGraphForModule(module);
					module.cleanupForCache();
				}
				for (const chunk of childCompilation.chunks) {
					ChunkGraph.clearChunkGraphForChunk(chunk);
				}
			}

			for (const module of this._lastCompilation.modules) {
				ChunkGraph.clearChunkGraphForModule(module);
				ModuleGraph.clearModuleGraphForModule(module);
				module.cleanupForCache();
			}
			for (const chunk of this._lastCompilation.chunks) {
				ChunkGraph.clearChunkGraphForChunk(chunk);
			}
			this._lastCompilation = undefined;
		}
	}

	// TODO webpack 6: solve this in a better way
	_cleanupLastNormalModuleFactory() {
		if (this._lastNormalModuleFactory !== undefined) {
			this._lastNormalModuleFactory.cleanupForCache();
			this._lastNormalModuleFactory = undefined;
		}
	}

	/**
	 * @param {WatchOptions} watchOptions the watcher&#039;s options
	 * @param {RunCallback&lt;Stats&gt;} handler signals when the call finishes
	 * @returns {Watching} a compiler watcher
	 */
	watch(watchOptions, handler) {
		if (this.running) {
			return handler(new ConcurrentCompilationError());
		}

		this.running = true;
		this.watchMode = true;
		this.watching = new Watching(this, watchOptions, handler);
		return this.watching;
	}

	/**
	 * @param {RunCallback&lt;Stats&gt;} callback signals when the call finishes
	 * @returns {void}
	 */
	run(callback) {
		if (this.running) {
			return callback(new ConcurrentCompilationError());
		}

		/** @type {Logger | undefined} */
		let logger;

		/**
		 * @param {Error | null} err error
		 * @param {Stats=} stats stats
		 */
		const finalCallback = (err, stats) =&gt; {
			if (logger) logger.time(&quot;beginIdle&quot;);
			this.idle = true;
			this.cache.beginIdle();
			this.idle = true;
			if (logger) logger.timeEnd(&quot;beginIdle&quot;);
			this.running = false;
			if (err) {
				this.hooks.failed.call(err);
			}
			if (callback !== undefined) callback(err, stats);
			this.hooks.afterDone.call(/** @type {Stats} */ (stats));
		};

		const startTime = Date.now();

		this.running = true;

		/**
		 * @param {Error | null} err error
		 * @param {Compilation=} _compilation compilation
		 * @returns {void}
		 */
		const onCompiled = (err, _compilation) =&gt; {
			if (err) return finalCallback(err);

			const compilation = /** @type {Compilation} */ (_compilation);

			if (this.hooks.shouldEmit.call(compilation) === false) {
				compilation.startTime = startTime;
				compilation.endTime = Date.now();
				const stats = new Stats(compilation);
				this.hooks.done.callAsync(stats, err =&gt; {
					if (err) return finalCallback(err);
					return finalCallback(null, stats);
				});
				return;
			}

			process.nextTick(() =&gt; {
				logger = compilation.getLogger(&quot;webpack.Compiler&quot;);
				logger.time(&quot;emitAssets&quot;);
				this.emitAssets(compilation, err =&gt; {
					/** @type {Logger} */
					(logger).timeEnd(&quot;emitAssets&quot;);
					if (err) return finalCallback(err);

					if (compilation.hooks.needAdditionalPass.call()) {
						compilation.needAdditionalPass = true;

						compilation.startTime = startTime;
						compilation.endTime = Date.now();
						/** @type {Logger} */
						(logger).time(&quot;done hook&quot;);
						const stats = new Stats(compilation);
						this.hooks.done.callAsync(stats, err =&gt; {
							/** @type {Logger} */
							(logger).timeEnd(&quot;done hook&quot;);
							if (err) return finalCallback(err);

							this.hooks.additionalPass.callAsync(err =&gt; {
								if (err) return finalCallback(err);
								this.compile(onCompiled);
							});
						});
						return;
					}

					/** @type {Logger} */
					(logger).time(&quot;emitRecords&quot;);
					this.emitRecords(err =&gt; {
						/** @type {Logger} */
						(logger).timeEnd(&quot;emitRecords&quot;);
						if (err) return finalCallback(err);

						compilation.startTime = startTime;
						compilation.endTime = Date.now();
						/** @type {Logger} */
						(logger).time(&quot;done hook&quot;);
						const stats = new Stats(compilation);
						this.hooks.done.callAsync(stats, err =&gt; {
							/** @type {Logger} */
							(logger).timeEnd(&quot;done hook&quot;);
							if (err) return finalCallback(err);
							this.cache.storeBuildDependencies(
								compilation.buildDependencies,
								err =&gt; {
									if (err) return finalCallback(err);
									return finalCallback(null, stats);
								}
							);
						});
					});
				});
			});
		};

		const run = () =&gt; {
			this.hooks.beforeRun.callAsync(this, err =&gt; {
				if (err) return finalCallback(err);

				this.hooks.run.callAsync(this, err =&gt; {
					if (err) return finalCallback(err);

					this.readRecords(err =&gt; {
						if (err) return finalCallback(err);

						this.compile(onCompiled);
					});
				});
			});
		};

		if (this.idle) {
			this.cache.endIdle(err =&gt; {
				if (err) return finalCallback(err);

				this.idle = false;
				run();
			});
		} else {
			run();
		}
	}

	/**
	 * @param {RunAsChildCallback} callback signals when the call finishes
	 * @returns {void}
	 */
	runAsChild(callback) {
		const startTime = Date.now();

		/**
		 * @param {Error | null} err error
		 * @param {Chunk[]=} entries entries
		 * @param {Compilation=} compilation compilation
		 */
		const finalCallback = (err, entries, compilation) =&gt; {
			try {
				callback(err, entries, compilation);
			} catch (runAsChildErr) {
				const err = new WebpackError(
					`compiler.runAsChild callback error: ${runAsChildErr}`,
					{ cause: runAsChildErr }
				);
				err.details = /** @type {Error} */ (runAsChildErr).stack;
				/** @type {Compilation} */
				(this.parentCompilation).errors.push(err);
			}
		};

		this.compile((err, _compilation) =&gt; {
			if (err) return finalCallback(err);

			const compilation = /** @type {Compilation} */ (_compilation);
			const parentCompilation = /** @type {Compilation} */ (
				this.parentCompilation
			);

			parentCompilation.children.push(compilation);

			for (const { name, source, info } of compilation.getAssets()) {
				parentCompilation.emitAsset(name, source, info);
			}

			/** @type {Chunk[]} */
			const entries = [];

			for (const ep of compilation.entrypoints.values()) {
				entries.push(...ep.chunks);
			}

			compilation.startTime = startTime;
			compilation.endTime = Date.now();

			return finalCallback(null, entries, compilation);
		});
	}

	purgeInputFileSystem() {
		if (this.inputFileSystem &amp;&amp; this.inputFileSystem.purge) {
			this.inputFileSystem.purge();
		}
	}

	/**
	 * @param {Compilation} compilation the compilation
	 * @param {Callback&lt;void&gt;} callback signals when the assets are emitted
	 * @returns {void}
	 */
	emitAssets(compilation, callback) {
		/** @type {string} */
		let outputPath;

		/**
		 * @param {Error=} err error
		 * @returns {void}
		 */
		const emitFiles = err =&gt; {
			if (err) return callback(err);

			const assets = compilation.getAssets();
			compilation.assets = { ...compilation.assets };
			/** @type {Map&lt;string, SimilarEntry&gt;} */
			const caseInsensitiveMap = new Map();
			/** @type {Set&lt;string&gt;} */
			const allTargetPaths = new Set();
			asyncLib.forEachLimit(
				assets,
				15,
				({ name: file, source, info }, callback) =&gt; {
					let targetFile = file;
					let immutable = info.immutable;
					const queryStringIdx = targetFile.indexOf(&quot;?&quot;);
					if (queryStringIdx &gt;= 0) {
						targetFile = targetFile.slice(0, queryStringIdx);
						// We may remove the hash, which is in the query string
						// So we recheck if the file is immutable
						// This doesn&#039;t cover all cases, but immutable is only a performance optimization anyway
						immutable =
							immutable &amp;&amp;
							(includesHash(targetFile, info.contenthash) ||
								includesHash(targetFile, info.chunkhash) ||
								includesHash(targetFile, info.modulehash) ||
								includesHash(targetFile, info.fullhash));
					}

					/**
					 * @param {Error=} err error
					 * @returns {void}
					 */
					const writeOut = err =&gt; {
						if (err) return callback(err);
						const targetPath = join(
							/** @type {OutputFileSystem} */
							(this.outputFileSystem),
							outputPath,
							targetFile
						);
						allTargetPaths.add(targetPath);

						// check if the target file has already been written by this Compiler
						const targetFileGeneration =
							this._assetEmittingWrittenFiles.get(targetPath);

						// create an cache entry for this Source if not already existing
						let cacheEntry = this._assetEmittingSourceCache.get(source);
						if (cacheEntry === undefined) {
							cacheEntry = {
								sizeOnlySource: undefined,
								writtenTo: new Map()
							};
							this._assetEmittingSourceCache.set(source, cacheEntry);
						}

						/** @type {SimilarEntry | undefined} */
						let similarEntry;

						const checkSimilarFile = () =&gt; {
							const caseInsensitiveTargetPath = targetPath.toLowerCase();
							similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);
							if (similarEntry !== undefined) {
								const { path: other, source: otherSource } = similarEntry;
								if (isSourceEqual(otherSource, source)) {
									// Size may or may not be available at this point.
									// If it&#039;s not available add to &quot;waiting&quot; list and it will be updated once available
									if (similarEntry.size !== undefined) {
										updateWithReplacementSource(similarEntry.size);
									} else {
										if (!similarEntry.waiting) similarEntry.waiting = [];
										similarEntry.waiting.push({ file, cacheEntry });
									}
									alreadyWritten();
								} else {
									const err =
										new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.
This will lead to a race-condition and corrupted files on case-insensitive file systems.
${targetPath}
${other}`);
									err.file = file;
									callback(err);
								}
								return true;
							}
							caseInsensitiveMap.set(
								caseInsensitiveTargetPath,
								(similarEntry = /** @type {SimilarEntry} */ ({
									path: targetPath,
									source,
									size: undefined,
									waiting: undefined
								}))
							);
							return false;
						};

						/**
						 * get the binary (Buffer) content from the Source
						 * @returns {Buffer} content for the source
						 */
						const getContent = () =&gt; {
							if (typeof source.buffer === &quot;function&quot;) {
								return source.buffer();
							}
							const bufferOrString = source.source();
							if (Buffer.isBuffer(bufferOrString)) {
								return bufferOrString;
							}
							return Buffer.from(bufferOrString, &quot;utf8&quot;);
						};

						const alreadyWritten = () =&gt; {
							// cache the information that the Source has been already been written to that location
							if (targetFileGeneration === undefined) {
								const newGeneration = 1;
								this._assetEmittingWrittenFiles.set(targetPath, newGeneration);
								/** @type {CacheEntry} */
								(cacheEntry).writtenTo.set(targetPath, newGeneration);
							} else {
								/** @type {CacheEntry} */
								(cacheEntry).writtenTo.set(targetPath, targetFileGeneration);
							}
							callback();
						};

						/**
						 * Write the file to output file system
						 * @param {Buffer} content content to be written
						 * @returns {void}
						 */
						const doWrite = content =&gt; {
							/** @type {OutputFileSystem} */
							(this.outputFileSystem).writeFile(targetPath, content, err =&gt; {
								if (err) return callback(err);

								// information marker that the asset has been emitted
								compilation.emittedAssets.add(file);

								// cache the information that the Source has been written to that location
								const newGeneration =
									targetFileGeneration === undefined
										? 1
										: targetFileGeneration + 1;
								/** @type {CacheEntry} */
								(cacheEntry).writtenTo.set(targetPath, newGeneration);
								this._assetEmittingWrittenFiles.set(targetPath, newGeneration);
								this.hooks.assetEmitted.callAsync(
									file,
									{
										content,
										source,
										outputPath,
										compilation,
										targetPath
									},
									callback
								);
							});
						};

						/**
						 * @param {number} size size
						 */
						const updateWithReplacementSource = size =&gt; {
							updateFileWithReplacementSource(
								file,
								/** @type {CacheEntry} */ (cacheEntry),
								size
							);
							/** @type {SimilarEntry} */
							(similarEntry).size = size;
							if (
								/** @type {SimilarEntry} */ (similarEntry).waiting !== undefined
							) {
								for (const { file, cacheEntry } of /** @type {SimilarEntry} */ (
									similarEntry
								).waiting) {
									updateFileWithReplacementSource(file, cacheEntry, size);
								}
							}
						};

						/**
						 * @param {string} file file
						 * @param {CacheEntry} cacheEntry cache entry
						 * @param {number} size size
						 */
						const updateFileWithReplacementSource = (
							file,
							cacheEntry,
							size
						) =&gt; {
							// Create a replacement resource which only allows to ask for size
							// This allows to GC all memory allocated by the Source
							// (expect when the Source is stored in any other cache)
							if (!cacheEntry.sizeOnlySource) {
								cacheEntry.sizeOnlySource = new SizeOnlySource(size);
							}
							compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
								size
							});
						};

						/**
						 * @param {IStats} stats stats
						 * @returns {void}
						 */
						const processExistingFile = stats =&gt; {
							// skip emitting if it&#039;s already there and an immutable file
							if (immutable) {
								updateWithReplacementSource(/** @type {number} */ (stats.size));
								return alreadyWritten();
							}

							const content = getContent();

							updateWithReplacementSource(content.length);

							// if it exists and content on disk matches content
							// skip writing the same content again
							// (to keep mtime and don&#039;t trigger watchers)
							// for a fast negative match file size is compared first
							if (content.length === stats.size) {
								compilation.comparedForEmitAssets.add(file);
								return /** @type {OutputFileSystem} */ (
									this.outputFileSystem
								).readFile(targetPath, (err, existingContent) =&gt; {
									if (
										err ||
										!content.equals(/** @type {Buffer} */ (existingContent))
									) {
										return doWrite(content);
									}
									return alreadyWritten();
								});
							}

							return doWrite(content);
						};

						const processMissingFile = () =&gt; {
							const content = getContent();

							updateWithReplacementSource(content.length);

							return doWrite(content);
						};

						// if the target file has already been written
						if (targetFileGeneration !== undefined) {
							// check if the Source has been written to this target file
							const writtenGeneration = /** @type {CacheEntry} */ (
								cacheEntry
							).writtenTo.get(targetPath);
							if (writtenGeneration === targetFileGeneration) {
								// if yes, we may skip writing the file
								// if it&#039;s already there
								// (we assume one doesn&#039;t modify files while the Compiler is running, other then removing them)

								if (this._assetEmittingPreviousFiles.has(targetPath)) {
									const sizeOnlySource = /** @type {SizeOnlySource} */ (
										/** @type {CacheEntry} */ (cacheEntry).sizeOnlySource
									);

									// We assume that assets from the last compilation say intact on disk (they are not removed)
									compilation.updateAsset(file, sizeOnlySource, {
										size: sizeOnlySource.size()
									});

									return callback();
								}
								// Settings immutable will make it accept file content without comparing when file exist
								immutable = true;
							} else if (!immutable) {
								if (checkSimilarFile()) return;
								// We wrote to this file before which has very likely a different content
								// skip comparing and assume content is different for performance
								// This case happens often during watch mode.
								return processMissingFile();
							}
						}

						if (checkSimilarFile()) return;
						if (this.options.output.compareBeforeEmit) {
							/** @type {OutputFileSystem} */
							(this.outputFileSystem).stat(targetPath, (err, stats) =&gt; {
								const exists = !err &amp;&amp; /** @type {IStats} */ (stats).isFile();

								if (exists) {
									processExistingFile(/** @type {IStats} */ (stats));
								} else {
									processMissingFile();
								}
							});
						} else {
							processMissingFile();
						}
					};

					if (/\/|\\/.test(targetFile)) {
						const fs = /** @type {OutputFileSystem} */ (this.outputFileSystem);
						const dir = dirname(fs, join(fs, outputPath, targetFile));
						mkdirp(fs, dir, writeOut);
					} else {
						writeOut();
					}
				},
				err =&gt; {
					// Clear map to free up memory
					caseInsensitiveMap.clear();
					if (err) {
						this._assetEmittingPreviousFiles.clear();
						return callback(err);
					}

					this._assetEmittingPreviousFiles = allTargetPaths;

					this.hooks.afterEmit.callAsync(compilation, err =&gt; {
						if (err) return callback(err);

						return callback();
					});
				}
			);
		};

		this.hooks.emit.callAsync(compilation, err =&gt; {
			if (err) return callback(err);
			outputPath = compilation.getPath(this.outputPath, {});
			mkdirp(
				/** @type {OutputFileSystem} */ (this.outputFileSystem),
				outputPath,
				emitFiles
			);
		});
	}

	/**
	 * @param {Callback&lt;void&gt;} callback signals when the call finishes
	 * @returns {void}
	 */
	emitRecords(callback) {
		if (this.hooks.emitRecords.isUsed()) {
			if (this.recordsOutputPath) {
				asyncLib.parallel(
					[
						cb =&gt; this.hooks.emitRecords.callAsync(cb),
						this._emitRecords.bind(this)
					],
					err =&gt; callback(err)
				);
			} else {
				this.hooks.emitRecords.callAsync(callback);
			}
		} else if (this.recordsOutputPath) {
			this._emitRecords(callback);
		} else {
			callback();
		}
	}

	/**
	 * @param {Callback&lt;void&gt;} callback signals when the call finishes
	 * @returns {void}
	 */
	_emitRecords(callback) {
		const writeFile = () =&gt; {
			/** @type {OutputFileSystem} */
			(this.outputFileSystem).writeFile(
				/** @type {string} */ (this.recordsOutputPath),
				JSON.stringify(
					this.records,
					(n, value) =&gt; {
						if (
							typeof value === &quot;object&quot; &amp;&amp;
							value !== null &amp;&amp;
							!Array.isArray(value)
						) {
							const keys = Object.keys(value);
							if (!isSorted(keys)) {
								return sortObject(value, keys);
							}
						}
						return value;
					},
					2
				),
				callback
			);
		};

		const recordsOutputPathDirectory = dirname(
			/** @type {OutputFileSystem} */ (this.outputFileSystem),
			/** @type {string} */ (this.recordsOutputPath)
		);
		if (!recordsOutputPathDirectory) {
			return writeFile();
		}
		mkdirp(
			/** @type {OutputFileSystem} */ (this.outputFileSystem),
			recordsOutputPathDirectory,
			err =&gt; {
				if (err) return callback(err);
				writeFile();
			}
		);
	}

	/**
	 * @param {Callback&lt;void&gt;} callback signals when the call finishes
	 * @returns {void}
	 */
	readRecords(callback) {
		if (this.hooks.readRecords.isUsed()) {
			if (this.recordsInputPath) {
				asyncLib.parallel(
					[
						cb =&gt; this.hooks.readRecords.callAsync(cb),
						this._readRecords.bind(this)
					],
					err =&gt; callback(err)
				);
			} else {
				this.records = {};
				this.hooks.readRecords.callAsync(callback);
			}
		} else if (this.recordsInputPath) {
			this._readRecords(callback);
		} else {
			this.records = {};
			callback();
		}
	}

	/**
	 * @param {Callback&lt;void&gt;} callback signals when the call finishes
	 * @returns {void}
	 */
	_readRecords(callback) {
		if (!this.recordsInputPath) {
			this.records = {};
			return callback();
		}
		/** @type {InputFileSystem} */
		(this.inputFileSystem).stat(this.recordsInputPath, err =&gt; {
			// It doesn&#039;t exist
			// We can ignore this.
			if (err) return callback();

			/** @type {InputFileSystem} */
			(this.inputFileSystem).readFile(
				/** @type {string} */ (this.recordsInputPath),
				(err, content) =&gt; {
					if (err) return callback(err);

					try {
						this.records = parseJson(
							/** @type {Buffer} */ (content).toString(&quot;utf-8&quot;)
						);
					} catch (parseErr) {
						return callback(
							new Error(
								`Cannot parse records: ${/** @type {Error} */ (parseErr).message}`
							)
						);
					}

					return callback();
				}
			);
		});
	}

	/**
	 * @param {Compilation} compilation the compilation
	 * @param {string} compilerName the compiler&#039;s name
	 * @param {number} compilerIndex the compiler&#039;s index
	 * @param {Partial&lt;OutputOptions&gt;=} outputOptions the output options
	 * @param {WebpackPluginInstance[]=} plugins the plugins to apply
	 * @returns {Compiler} a child compiler
	 */
	createChildCompiler(
		compilation,
		compilerName,
		compilerIndex,
		outputOptions,
		plugins
	) {
		const childCompiler = new Compiler(this.context, {
			...this.options,
			output: {
				...this.options.output,
				...outputOptions
			}
		});
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolverFactory = this.resolverFactory;
		childCompiler.modifiedFiles = this.modifiedFiles;
		childCompiler.removedFiles = this.removedFiles;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;
		childCompiler.fsStartTime = this.fsStartTime;
		childCompiler.cache = this.cache;
		childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;
		childCompiler._backCompat = this._backCompat;

		const relativeCompilerName = makePathsRelative(
			this.context,
			compilerName,
			this.root
		);
		if (!this.records[relativeCompilerName]) {
			this.records[relativeCompilerName] = [];
		}
		if (this.records[relativeCompilerName][compilerIndex]) {
			childCompiler.records = this.records[relativeCompilerName][compilerIndex];
		} else {
			this.records[relativeCompilerName].push((childCompiler.records = {}));
		}

		childCompiler.parentCompilation = compilation;
		childCompiler.root = this.root;
		if (Array.isArray(plugins)) {
			for (const plugin of plugins) {
				if (plugin) {
					plugin.apply(childCompiler);
				}
			}
		}
		for (const name in this.hooks) {
			if (
				![
					&quot;make&quot;,
					&quot;compile&quot;,
					&quot;emit&quot;,
					&quot;afterEmit&quot;,
					&quot;invalid&quot;,
					&quot;done&quot;,
					&quot;thisCompilation&quot;
				].includes(name) &amp;&amp;
				childCompiler.hooks[/** @type {keyof Compiler[&quot;hooks&quot;]} */ (name)]
			) {
				childCompiler.hooks[
					/** @type {keyof Compiler[&quot;hooks&quot;]} */
					(name)
				].taps =
					this.hooks[
						/** @type {keyof Compiler[&quot;hooks&quot;]} */
						(name)
					].taps.slice();
			}
		}

		compilation.hooks.childCompiler.call(
			childCompiler,
			compilerName,
			compilerIndex
		);

		return childCompiler;
	}

	isChild() {
		return Boolean(this.parentCompilation);
	}

	/**
	 * @param {CompilationParams} params the compilation parameters
	 * @returns {Compilation} compilation
	 */
	createCompilation(params) {
		this._cleanupLastCompilation();
		return (this._lastCompilation = new Compilation(this, params));
	}

	/**
	 * @param {CompilationParams} params the compilation parameters
	 * @returns {Compilation} the created compilation
	 */
	newCompilation(params) {
		const compilation = this.createCompilation(params);
		compilation.name = this.name;
		compilation.records = this.records;
		this.hooks.thisCompilation.call(compilation, params);
		this.hooks.compilation.call(compilation, params);
		return compilation;
	}

	createNormalModuleFactory() {
		this._cleanupLastNormalModuleFactory();
		const normalModuleFactory = new NormalModuleFactory({
			context: this.options.context,
			fs: /** @type {InputFileSystem} */ (this.inputFileSystem),
			resolverFactory: this.resolverFactory,
			options: this.options.module,
			associatedObjectForCache: this.root,
			layers: this.options.experiments.layers
		});
		this._lastNormalModuleFactory = normalModuleFactory;
		this.hooks.normalModuleFactory.call(normalModuleFactory);
		return normalModuleFactory;
	}

	createContextModuleFactory() {
		const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
		this.hooks.contextModuleFactory.call(contextModuleFactory);
		return contextModuleFactory;
	}

	newCompilationParams() {
		const params = {
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory()
		};
		return params;
	}

	/**
	 * @param {RunCallback&lt;Compilation&gt;} callback signals when the compilation finishes
	 * @returns {void}
	 */
	compile(callback) {
		const params = this.newCompilationParams();
		this.hooks.beforeCompile.callAsync(params, err =&gt; {
			if (err) return callback(err);

			this.hooks.compile.call(params);

			const compilation = this.newCompilation(params);

			const logger = compilation.getLogger(&quot;webpack.Compiler&quot;);

			logger.time(&quot;make hook&quot;);
			this.hooks.make.callAsync(compilation, err =&gt; {
				logger.timeEnd(&quot;make hook&quot;);
				if (err) return callback(err);

				logger.time(&quot;finish make hook&quot;);
				this.hooks.finishMake.callAsync(compilation, err =&gt; {
					logger.timeEnd(&quot;finish make hook&quot;);
					if (err) return callback(err);

					process.nextTick(() =&gt; {
						logger.time(&quot;finish compilation&quot;);
						compilation.finish(err =&gt; {
							logger.timeEnd(&quot;finish compilation&quot;);
							if (err) return callback(err);

							logger.time(&quot;seal compilation&quot;);
							compilation.seal(err =&gt; {
								logger.timeEnd(&quot;seal compilation&quot;);
								if (err) return callback(err);

								logger.time(&quot;afterCompile hook&quot;);
								this.hooks.afterCompile.callAsync(compilation, err =&gt; {
									logger.timeEnd(&quot;afterCompile hook&quot;);
									if (err) return callback(err);

									return callback(null, compilation);
								});
							});
						});
					});
				});
			});
		});
	}

	/**
	 * @param {RunCallback&lt;void&gt;} callback signals when the compiler closes
	 * @returns {void}
	 */
	close(callback) {
		if (this.watching) {
			// When there is still an active watching, close this first
			this.watching.close(err =&gt; {
				this.close(callback);
			});
			return;
		}
		this.hooks.shutdown.callAsync(err =&gt; {
			if (err) return callback(err);
			// Get rid of reference to last compilation to avoid leaking memory
			// We can&#039;t run this._cleanupLastCompilation() as the Stats to this compilation
			// might be still in use. We try to get rid of the reference to the cache instead.
			this._lastCompilation = undefined;
			this._lastNormalModuleFactory = undefined;
			this.cache.shutdown(callback);
		});
	}
}

module.exports = Compiler;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
