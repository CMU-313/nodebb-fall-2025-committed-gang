<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/cli-engine/file-enumerator.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/cli-engine/file-enumerator.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">542</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">52.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.63</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview `FileEnumerator` class.
 *
 * `FileEnumerator` class has two responsibilities:
 *
 * 1. Find target files by processing glob patterns.
 * 2. Tie each target file and appropriate configuration.
 *
 * It provides a method:
 *
 * - `iterateFiles(patterns)`
 *     Iterate files which are matched by given patterns together with the
 *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.
 *     While iterating files, it loads the configuration file of each directory
 *     before iterate files on the directory, so we can use the configuration
 *     files to determine target files.
 *
 * @example
 * const enumerator = new FileEnumerator();
 * const linter = new Linter();
 *
 * for (const { config, filePath } of enumerator.iterateFiles([&quot;*.js&quot;])) {
 *     const code = fs.readFileSync(filePath, &quot;utf8&quot;);
 *     const messages = linter.verify(code, config, filePath);
 *
 *     console.log(messages);
 * }
 *
 * @author Toru Nagashima &lt;https://github.com/mysticatea&gt;
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const fs = require(&quot;node:fs&quot;);
const path = require(&quot;node:path&quot;);
const getGlobParent = require(&quot;glob-parent&quot;);
const isGlob = require(&quot;is-glob&quot;);
const escapeRegExp = require(&quot;escape-string-regexp&quot;);
const { Minimatch } = require(&quot;minimatch&quot;);

const {
	Legacy: { IgnorePattern, CascadingConfigArrayFactory },
} = require(&quot;@eslint/eslintrc&quot;);
const debug = require(&quot;debug&quot;)(&quot;eslint:file-enumerator&quot;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const minimatchOpts = { dot: true, matchBase: true };
const dotfilesPattern = /(?:^\.|[/\\]\.)[^/\\.].*/u;
const NONE = 0;
const IGNORED_SILENTLY = 1;
const IGNORED = 2;

// For VSCode intellisense
/** @typedef {ReturnType&lt;CascadingConfigArrayFactory.getConfigArrayForFile&gt;} ConfigArray */

/**
 * @typedef {Object} FileEnumeratorOptions
 * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.
 * @property {string} [cwd] The base directory to start lookup.
 * @property {string[]} [extensions] The extensions to match files for directory patterns.
 * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean} [ignore] The flag to check ignored files.
 * @property {string[]} [rulePaths] The value of `--rulesdir` option.
 */

/**
 * @typedef {Object} FileAndConfig
 * @property {string} filePath The path to a target file.
 * @property {ConfigArray} config The config entries of that file.
 * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.
 */

/**
 * @typedef {Object} FileEntry
 * @property {string} filePath The path to a target file.
 * @property {ConfigArray} config The config entries of that file.
 * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.
 * - `NONE` means the file is a target file.
 * - `IGNORED_SILENTLY` means the file should be ignored silently.
 * - `IGNORED` means the file should be ignored and warned because it was directly specified.
 */

/**
 * @typedef {Object} FileEnumeratorInternalSlots
 * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.
 * @property {string} cwd The base directory to start lookup.
 * @property {RegExp|null} extensionRegExp The RegExp to test if a string ends with specific file extensions.
 * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean} ignoreFlag The flag to check ignored files.
 * @property {(filePath:string, dot:boolean) =&gt; boolean} defaultIgnores The default predicate function to ignore files.
 */

/** @type {WeakMap&lt;FileEnumerator, FileEnumeratorInternalSlots&gt;} */
const internalSlotsMap = new WeakMap();

/**
 * Check if a string is a glob pattern or not.
 * @param {string} pattern A glob pattern.
 * @returns {boolean} `true` if the string is a glob pattern.
 */
function isGlobPattern(pattern) {
	return isGlob(path.sep === &quot;\\&quot; ? pattern.replace(/\\/gu, &quot;/&quot;) : pattern);
}

/**
 * Get stats of a given path.
 * @param {string} filePath The path to target file.
 * @throws {Error} As may be thrown by `fs.statSync`.
 * @returns {fs.Stats|null} The stats.
 * @private
 */
function statSafeSync(filePath) {
	try {
		return fs.statSync(filePath);
	} catch (error) {
		/* c8 ignore next */
		if (error.code !== &quot;ENOENT&quot;) {
			throw error;
		}
		return null;
	}
}

/**
 * Get filenames in a given path to a directory.
 * @param {string} directoryPath The path to target directory.
 * @throws {Error} As may be thrown by `fs.readdirSync`.
 * @returns {import(&quot;fs&quot;).Dirent[]} The filenames.
 * @private
 */
function readdirSafeSync(directoryPath) {
	try {
		return fs.readdirSync(directoryPath, { withFileTypes: true });
	} catch (error) {
		/* c8 ignore next */
		if (error.code !== &quot;ENOENT&quot;) {
			throw error;
		}
		return [];
	}
}

/**
 * Create a `RegExp` object to detect extensions.
 * @param {string[] | null} extensions The extensions to create.
 * @returns {RegExp | null} The created `RegExp` object or null.
 */
function createExtensionRegExp(extensions) {
	if (extensions) {
		const normalizedExts = extensions.map(ext =&gt;
			escapeRegExp(ext.startsWith(&quot;.&quot;) ? ext.slice(1) : ext),
		);

		return new RegExp(`.\\.(?:${normalizedExts.join(&quot;|&quot;)})$`, &quot;u&quot;);
	}
	return null;
}

/**
 * The error type when no files match a glob.
 */
class NoFilesFoundError extends Error {
	/**
	 * @param {string} pattern The glob pattern which was not found.
	 * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.
	 */
	constructor(pattern, globDisabled) {
		super(
			`No files matching &#039;${pattern}&#039; were found${globDisabled ? &quot; (glob was disabled)&quot; : &quot;&quot;}.`,
		);
		this.messageTemplate = &quot;file-not-found&quot;;
		this.messageData = { pattern, globDisabled };
	}
}

/**
 * The error type when there are files matched by a glob, but all of them have been ignored.
 */
class AllFilesIgnoredError extends Error {
	/**
	 * @param {string} pattern The glob pattern which was not found.
	 */
	constructor(pattern) {
		super(`All files matched by &#039;${pattern}&#039; are ignored.`);
		this.messageTemplate = &quot;all-files-ignored&quot;;
		this.messageData = { pattern };
	}
}

/**
 * This class provides the functionality that enumerates every file which is
 * matched by given glob patterns and that configuration.
 */
class FileEnumerator {
	/**
	 * Initialize this enumerator.
	 * @param {FileEnumeratorOptions} options The options.
	 */
	constructor({
		cwd = process.cwd(),
		configArrayFactory = new CascadingConfigArrayFactory({
			cwd,
			getEslintRecommendedConfig: () =&gt;
				require(&quot;@eslint/js&quot;).configs.recommended,
			getEslintAllConfig: () =&gt; require(&quot;@eslint/js&quot;).configs.all,
		}),
		extensions = null,
		globInputPaths = true,
		errorOnUnmatchedPattern = true,
		ignore = true,
	} = {}) {
		internalSlotsMap.set(this, {
			configArrayFactory,
			cwd,
			defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),
			extensionRegExp: createExtensionRegExp(extensions),
			globInputPaths,
			errorOnUnmatchedPattern,
			ignoreFlag: ignore,
		});
	}

	/**
	 * Check if a given file is target or not.
	 * @param {string} filePath The path to a candidate file.
	 * @param {ConfigArray} [providedConfig] Optional. The configuration for the file.
	 * @returns {boolean} `true` if the file is a target.
	 */
	isTargetPath(filePath, providedConfig) {
		const { configArrayFactory, extensionRegExp } =
			internalSlotsMap.get(this);

		// If `--ext` option is present, use it.
		if (extensionRegExp) {
			return extensionRegExp.test(filePath);
		}

		// `.js` file is target by default.
		if (filePath.endsWith(&quot;.js&quot;)) {
			return true;
		}

		// use `overrides[].files` to check additional targets.
		const config =
			providedConfig ||
			configArrayFactory.getConfigArrayForFile(filePath, {
				ignoreNotFoundError: true,
			});

		return config.isAdditionalTargetPath(filePath);
	}

	/**
	 * Iterate files which are matched by given glob patterns.
	 * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.
	 * @throws {NoFilesFoundError|AllFilesIgnoredError} On an unmatched pattern.
	 * @returns {IterableIterator&lt;FileAndConfig&gt;} The found files.
	 */
	*iterateFiles(patternOrPatterns) {
		const { globInputPaths, errorOnUnmatchedPattern } =
			internalSlotsMap.get(this);
		const patterns = Array.isArray(patternOrPatterns)
			? patternOrPatterns
			: [patternOrPatterns];

		debug(&quot;Start to iterate files: %o&quot;, patterns);

		// The set of paths to remove duplicate.
		const set = new Set();

		for (const pattern of patterns) {
			let foundRegardlessOfIgnored = false;
			let found = false;

			// Skip empty string.
			if (!pattern) {
				continue;
			}

			// Iterate files of this pattern.
			for (const { config, filePath, flag } of this._iterateFiles(
				pattern,
			)) {
				foundRegardlessOfIgnored = true;
				if (flag === IGNORED_SILENTLY) {
					continue;
				}
				found = true;

				// Remove duplicate paths while yielding paths.
				if (!set.has(filePath)) {
					set.add(filePath);
					yield {
						config,
						filePath,
						ignored: flag === IGNORED,
					};
				}
			}

			// Raise an error if any files were not found.
			if (errorOnUnmatchedPattern) {
				if (!foundRegardlessOfIgnored) {
					throw new NoFilesFoundError(
						pattern,
						!globInputPaths &amp;&amp; isGlob(pattern),
					);
				}
				if (!found) {
					throw new AllFilesIgnoredError(pattern);
				}
			}
		}

		debug(`Complete iterating files: ${JSON.stringify(patterns)}`);
	}

	/**
	 * Iterate files which are matched by a given glob pattern.
	 * @param {string} pattern The glob pattern to iterate files.
	 * @returns {IterableIterator&lt;FileEntry&gt;} The found files.
	 */
	_iterateFiles(pattern) {
		const { cwd, globInputPaths } = internalSlotsMap.get(this);
		const absolutePath = path.resolve(cwd, pattern);
		const isDot = dotfilesPattern.test(pattern);
		const stat = statSafeSync(absolutePath);

		if (stat &amp;&amp; stat.isDirectory()) {
			return this._iterateFilesWithDirectory(absolutePath, isDot);
		}
		if (stat &amp;&amp; stat.isFile()) {
			return this._iterateFilesWithFile(absolutePath);
		}
		if (globInputPaths &amp;&amp; isGlobPattern(pattern)) {
			return this._iterateFilesWithGlob(pattern, isDot);
		}

		return [];
	}

	/**
	 * Iterate a file which is matched by a given path.
	 * @param {string} filePath The path to the target file.
	 * @returns {IterableIterator&lt;FileEntry&gt;} The found files.
	 * @private
	 */
	_iterateFilesWithFile(filePath) {
		debug(`File: ${filePath}`);

		const { configArrayFactory } = internalSlotsMap.get(this);
		const config = configArrayFactory.getConfigArrayForFile(filePath);
		const ignored = this._isIgnoredFile(filePath, { config, direct: true });
		const flag = ignored ? IGNORED : NONE;

		return [{ config, filePath, flag }];
	}

	/**
	 * Iterate files in a given path.
	 * @param {string} directoryPath The path to the target directory.
	 * @param {boolean} dotfiles If `true` then it doesn&#039;t skip dot files by default.
	 * @returns {IterableIterator&lt;FileEntry&gt;} The found files.
	 * @private
	 */
	_iterateFilesWithDirectory(directoryPath, dotfiles) {
		debug(`Directory: ${directoryPath}`);

		return this._iterateFilesRecursive(directoryPath, {
			dotfiles,
			recursive: true,
			selector: null,
		});
	}

	/**
	 * Iterate files which are matched by a given glob pattern.
	 * @param {string} pattern The glob pattern to iterate files.
	 * @param {boolean} dotfiles If `true` then it doesn&#039;t skip dot files by default.
	 * @returns {IterableIterator&lt;FileEntry&gt;} The found files.
	 * @private
	 */
	_iterateFilesWithGlob(pattern, dotfiles) {
		debug(`Glob: ${pattern}`);

		const { cwd } = internalSlotsMap.get(this);
		const directoryPath = path.resolve(cwd, getGlobParent(pattern));
		const absolutePath = path.resolve(cwd, pattern);
		const globPart = absolutePath.slice(directoryPath.length + 1);

		/*
		 * recursive if there are `**` or path separators in the glob part.
		 * Otherwise, patterns such as `src/*.js`, it doesn&#039;t need recursive.
		 */
		const recursive = /\*\*|\/|\\/u.test(globPart);
		const selector = new Minimatch(absolutePath, minimatchOpts);

		debug(`recursive? ${recursive}`);

		return this._iterateFilesRecursive(directoryPath, {
			dotfiles,
			recursive,
			selector,
		});
	}

	/**
	 * Iterate files in a given path.
	 * @param {string} directoryPath The path to the target directory.
	 * @param {Object} options The options to iterate files.
	 * @param {boolean} [options.dotfiles] If `true` then it doesn&#039;t skip dot files by default.
	 * @param {boolean} [options.recursive] If `true` then it dives into sub directories.
	 * @param {InstanceType&lt;Minimatch&gt;} [options.selector] The matcher to choose files.
	 * @returns {IterableIterator&lt;FileEntry&gt;} The found files.
	 * @private
	 */
	*_iterateFilesRecursive(directoryPath, options) {
		debug(`Enter the directory: ${directoryPath}`);
		const { configArrayFactory } = internalSlotsMap.get(this);

		/** @type {ConfigArray|null} */
		let config = null;

		// Enumerate the files of this directory.
		for (const entry of readdirSafeSync(directoryPath)) {
			const filePath = path.join(directoryPath, entry.name);
			const fileInfo = entry.isSymbolicLink()
				? statSafeSync(filePath)
				: entry;

			if (!fileInfo) {
				continue;
			}

			// Check if the file is matched.
			if (fileInfo.isFile()) {
				if (!config) {
					config = configArrayFactory.getConfigArrayForFile(
						filePath,

						/*
						 * We must ignore `ConfigurationNotFoundError` at this
						 * point because we don&#039;t know if target files exist in
						 * this directory.
						 */
						{ ignoreNotFoundError: true },
					);
				}
				const matched = options.selector
					? // Started with a glob pattern; choose by the pattern.
						options.selector.match(filePath)
					: // Started with a directory path; choose by file extensions.
						this.isTargetPath(filePath, config);

				if (matched) {
					const ignored = this._isIgnoredFile(filePath, {
						...options,
						config,
					});
					const flag = ignored ? IGNORED_SILENTLY : NONE;

					debug(
						`Yield: ${entry.name}${ignored ? &quot; but ignored&quot; : &quot;&quot;}`,
					);
					yield {
						config: configArrayFactory.getConfigArrayForFile(
							filePath,
						),
						filePath,
						flag,
					};
				} else {
					debug(`Didn&#039;t match: ${entry.name}`);
				}

				// Dive into the sub directory.
			} else if (options.recursive &amp;&amp; fileInfo.isDirectory()) {
				if (!config) {
					config = configArrayFactory.getConfigArrayForFile(
						filePath,
						{ ignoreNotFoundError: true },
					);
				}
				const ignored = this._isIgnoredFile(filePath + path.sep, {
					...options,
					config,
				});

				if (!ignored) {
					yield* this._iterateFilesRecursive(filePath, options);
				}
			}
		}

		debug(`Leave the directory: ${directoryPath}`);
	}

	/**
	 * Check if a given file should be ignored.
	 * @param {string} filePath The path to a file to check.
	 * @param {Object} options Options
	 * @param {ConfigArray} [options.config] The config for this file.
	 * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.
	 * @param {boolean} [options.direct] If `true` then this is a direct specified file.
	 * @returns {boolean} `true` if the file should be ignored.
	 * @private
	 */
	_isIgnoredFile(
		filePath,
		{ config: providedConfig, dotfiles = false, direct = false },
	) {
		const { configArrayFactory, defaultIgnores, ignoreFlag } =
			internalSlotsMap.get(this);

		if (ignoreFlag) {
			const config =
				providedConfig ||
				configArrayFactory.getConfigArrayForFile(filePath, {
					ignoreNotFoundError: true,
				});
			const ignores =
				config.extractConfig(filePath).ignores || defaultIgnores;

			return ignores(filePath, dotfiles);
		}

		return !direct &amp;&amp; defaultIgnores(filePath, dotfiles);
	}
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = { FileEnumerator };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
