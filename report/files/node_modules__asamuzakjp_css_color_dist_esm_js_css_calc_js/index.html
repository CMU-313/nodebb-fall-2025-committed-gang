<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@asamuzakjp/css-color/dist/esm/js/css-calc.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@asamuzakjp/css-color/dist/esm/js/css-calc.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">861</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">169.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.94</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var __typeError = (msg) =&gt; {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) =&gt; member.has(obj) || __typeError(&quot;Cannot &quot; + msg);
var __privateGet = (obj, member, getter) =&gt; (__accessCheck(obj, member, &quot;read from private field&quot;), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) =&gt; member.has(obj) ? __typeError(&quot;Cannot add the same private member more than once&quot;) : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) =&gt; (__accessCheck(obj, member, &quot;write to private field&quot;), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _hasNum, _numSum, _numMul, _hasPct, _pctSum, _pctMul, _hasDim, _dimSum, _dimSub, _dimMul, _dimDiv, _hasEtc, _etcSum, _etcSub, _etcMul, _etcDiv;
import { calc } from &quot;@csstools/css-calc&quot;;
import { TokenType, tokenize } from &quot;@csstools/css-tokenizer&quot;;
import { createCacheKey, getCache, CacheItem, setCache, NullObject } from &quot;./cache.js&quot;;
import { isString, isStringOrNumber } from &quot;./common.js&quot;;
import { resolveVar } from &quot;./css-var.js&quot;;
import { roundToPrecision } from &quot;./util.js&quot;;
import { VAL_SPEC, SYN_FN_VAR, SYN_FN_CALC, SYN_FN_VAR_START, NUM, ANGLE, LENGTH, SYN_FN_MATH_START } from &quot;./constant.js&quot;;
const {
  CloseParen: PAREN_CLOSE,
  Comment: COMMENT,
  Dimension: DIM,
  EOF,
  Function: FUNC,
  OpenParen: PAREN_OPEN,
  Whitespace: W_SPACE
} = TokenType;
const NAMESPACE = &quot;css-calc&quot;;
const TRIA = 3;
const HEX = 16;
const MAX_PCT = 100;
const REG_FN_CALC = new RegExp(SYN_FN_CALC);
const REG_FN_CALC_NUM = new RegExp(`^calc\\((${NUM})\\)$`);
const REG_FN_MATH_START = new RegExp(SYN_FN_MATH_START);
const REG_FN_VAR = new RegExp(SYN_FN_VAR);
const REG_FN_VAR_START = new RegExp(SYN_FN_VAR_START);
const REG_OPERATOR = /\s[*+/-]\s/;
const REG_TYPE_DIM = new RegExp(`^(${NUM})(${ANGLE}|${LENGTH})$`);
const REG_TYPE_DIM_PCT = new RegExp(`^(${NUM})(${ANGLE}|${LENGTH}|%)$`);
const REG_TYPE_PCT = new RegExp(`^(${NUM})%$`);
class Calculator {
  /**
   * constructor
   */
  constructor() {
    /* private */
    // number
    __privateAdd(this, _hasNum);
    __privateAdd(this, _numSum);
    __privateAdd(this, _numMul);
    // percentage
    __privateAdd(this, _hasPct);
    __privateAdd(this, _pctSum);
    __privateAdd(this, _pctMul);
    // dimension
    __privateAdd(this, _hasDim);
    __privateAdd(this, _dimSum);
    __privateAdd(this, _dimSub);
    __privateAdd(this, _dimMul);
    __privateAdd(this, _dimDiv);
    // et cetra
    __privateAdd(this, _hasEtc);
    __privateAdd(this, _etcSum);
    __privateAdd(this, _etcSub);
    __privateAdd(this, _etcMul);
    __privateAdd(this, _etcDiv);
    __privateSet(this, _hasNum, false);
    __privateSet(this, _numSum, []);
    __privateSet(this, _numMul, []);
    __privateSet(this, _hasPct, false);
    __privateSet(this, _pctSum, []);
    __privateSet(this, _pctMul, []);
    __privateSet(this, _hasDim, false);
    __privateSet(this, _dimSum, []);
    __privateSet(this, _dimSub, []);
    __privateSet(this, _dimMul, []);
    __privateSet(this, _dimDiv, []);
    __privateSet(this, _hasEtc, false);
    __privateSet(this, _etcSum, []);
    __privateSet(this, _etcSub, []);
    __privateSet(this, _etcMul, []);
    __privateSet(this, _etcDiv, []);
  }
  get hasNum() {
    return __privateGet(this, _hasNum);
  }
  set hasNum(value) {
    __privateSet(this, _hasNum, !!value);
  }
  get numSum() {
    return __privateGet(this, _numSum);
  }
  get numMul() {
    return __privateGet(this, _numMul);
  }
  get hasPct() {
    return __privateGet(this, _hasPct);
  }
  set hasPct(value) {
    __privateSet(this, _hasPct, !!value);
  }
  get pctSum() {
    return __privateGet(this, _pctSum);
  }
  get pctMul() {
    return __privateGet(this, _pctMul);
  }
  get hasDim() {
    return __privateGet(this, _hasDim);
  }
  set hasDim(value) {
    __privateSet(this, _hasDim, !!value);
  }
  get dimSum() {
    return __privateGet(this, _dimSum);
  }
  get dimSub() {
    return __privateGet(this, _dimSub);
  }
  get dimMul() {
    return __privateGet(this, _dimMul);
  }
  get dimDiv() {
    return __privateGet(this, _dimDiv);
  }
  get hasEtc() {
    return __privateGet(this, _hasEtc);
  }
  set hasEtc(value) {
    __privateSet(this, _hasEtc, !!value);
  }
  get etcSum() {
    return __privateGet(this, _etcSum);
  }
  get etcSub() {
    return __privateGet(this, _etcSub);
  }
  get etcMul() {
    return __privateGet(this, _etcMul);
  }
  get etcDiv() {
    return __privateGet(this, _etcDiv);
  }
  /**
   * clear values
   * @returns void
   */
  clear() {
    __privateSet(this, _hasNum, false);
    __privateSet(this, _numSum, []);
    __privateSet(this, _numMul, []);
    __privateSet(this, _hasPct, false);
    __privateSet(this, _pctSum, []);
    __privateSet(this, _pctMul, []);
    __privateSet(this, _hasDim, false);
    __privateSet(this, _dimSum, []);
    __privateSet(this, _dimSub, []);
    __privateSet(this, _dimMul, []);
    __privateSet(this, _dimDiv, []);
    __privateSet(this, _hasEtc, false);
    __privateSet(this, _etcSum, []);
    __privateSet(this, _etcSub, []);
    __privateSet(this, _etcMul, []);
    __privateSet(this, _etcDiv, []);
  }
  /**
   * sort values
   * @param values - values
   * @returns sorted values
   */
  sort(values = []) {
    const arr = [...values];
    if (arr.length &gt; 1) {
      arr.sort((a, b) =&gt; {
        let res;
        if (REG_TYPE_DIM_PCT.test(a) &amp;&amp; REG_TYPE_DIM_PCT.test(b)) {
          const [, valA, unitA] = a.match(REG_TYPE_DIM_PCT);
          const [, valB, unitB] = b.match(REG_TYPE_DIM_PCT);
          if (unitA === unitB) {
            if (Number(valA) === Number(valB)) {
              res = 0;
            } else if (Number(valA) &gt; Number(valB)) {
              res = 1;
            } else {
              res = -1;
            }
          } else if (unitA &gt; unitB) {
            res = 1;
          } else {
            res = -1;
          }
        } else {
          if (a === b) {
            res = 0;
          } else if (a &gt; b) {
            res = 1;
          } else {
            res = -1;
          }
        }
        return res;
      });
    }
    return arr;
  }
  /**
   * multiply values
   * @returns resolved value
   */
  multiply() {
    const value = [];
    let num;
    if (__privateGet(this, _hasNum)) {
      num = 1;
      for (const i of __privateGet(this, _numMul)) {
        num *= i;
        if (num === 0 || !Number.isFinite(num) || Number.isNaN(num)) {
          break;
        }
      }
      if (!__privateGet(this, _hasPct) &amp;&amp; !__privateGet(this, _hasDim) &amp;&amp; !this.hasEtc) {
        if (Number.isFinite(num)) {
          num = roundToPrecision(num, HEX);
        }
        value.push(num);
      }
    }
    if (__privateGet(this, _hasPct)) {
      if (typeof num !== &quot;number&quot;) {
        num = 1;
      }
      for (const i of __privateGet(this, _pctMul)) {
        num *= i;
        if (num === 0 || !Number.isFinite(num) || Number.isNaN(num)) {
          break;
        }
      }
      if (Number.isFinite(num)) {
        num = `${roundToPrecision(num, HEX)}%`;
      }
      if (!__privateGet(this, _hasDim) &amp;&amp; !this.hasEtc) {
        value.push(num);
      }
    }
    if (__privateGet(this, _hasDim)) {
      let dim = &quot;&quot;;
      let mul = &quot;&quot;;
      let div = &quot;&quot;;
      if (__privateGet(this, _dimMul).length) {
        if (__privateGet(this, _dimMul).length === 1) {
          [mul] = __privateGet(this, _dimMul);
        } else {
          mul = `${this.sort(__privateGet(this, _dimMul)).join(&quot; * &quot;)}`;
        }
      }
      if (__privateGet(this, _dimDiv).length) {
        if (__privateGet(this, _dimDiv).length === 1) {
          [div] = __privateGet(this, _dimDiv);
        } else {
          div = `${this.sort(__privateGet(this, _dimDiv)).join(&quot; * &quot;)}`;
        }
      }
      if (Number.isFinite(num)) {
        if (mul) {
          if (div) {
            if (div.includes(&quot;*&quot;)) {
              dim = calc(`calc(${num} * ${mul} / (${div}))`, {
                toCanonicalUnits: true
              });
            } else {
              dim = calc(`calc(${num} * ${mul} / ${div})`, {
                toCanonicalUnits: true
              });
            }
          } else {
            dim = calc(`calc(${num} * ${mul})`, {
              toCanonicalUnits: true
            });
          }
        } else if (div.includes(&quot;*&quot;)) {
          dim = calc(`calc(${num} / (${div}))`, {
            toCanonicalUnits: true
          });
        } else {
          dim = calc(`calc(${num} / ${div})`, {
            toCanonicalUnits: true
          });
        }
        value.push(dim.replace(/^calc/, &quot;&quot;));
      } else {
        if (!value.length &amp;&amp; num !== void 0) {
          value.push(num);
        }
        if (mul) {
          if (div) {
            if (div.includes(&quot;*&quot;)) {
              dim = calc(`calc(${mul} / (${div}))`, {
                toCanonicalUnits: true
              });
            } else {
              dim = calc(`calc(${mul} / ${div})`, {
                toCanonicalUnits: true
              });
            }
          } else {
            dim = calc(`calc(${mul})`, {
              toCanonicalUnits: true
            });
          }
          if (value.length) {
            value.push(&quot;*&quot;, dim.replace(/^calc/, &quot;&quot;));
          } else {
            value.push(dim.replace(/^calc/, &quot;&quot;));
          }
        } else {
          dim = calc(`calc(${div})`, {
            toCanonicalUnits: true
          });
          if (value.length) {
            value.push(&quot;/&quot;, dim.replace(/^calc/, &quot;&quot;));
          } else {
            value.push(&quot;1&quot;, &quot;/&quot;, dim.replace(/^calc/, &quot;&quot;));
          }
        }
      }
    }
    if (__privateGet(this, _hasEtc)) {
      if (__privateGet(this, _etcMul).length) {
        if (!value.length &amp;&amp; num !== void 0) {
          value.push(num);
        }
        const mul = this.sort(__privateGet(this, _etcMul)).join(&quot; * &quot;);
        if (value.length) {
          value.push(`* ${mul}`);
        } else {
          value.push(`${mul}`);
        }
      }
      if (__privateGet(this, _etcDiv).length) {
        const div = this.sort(__privateGet(this, _etcDiv)).join(&quot; * &quot;);
        if (div.includes(&quot;*&quot;)) {
          if (value.length) {
            value.push(`/ (${div})`);
          } else {
            value.push(`1 / (${div})`);
          }
        } else if (value.length) {
          value.push(`/ ${div}`);
        } else {
          value.push(`1 / ${div}`);
        }
      }
    }
    if (value.length) {
      return value.join(&quot; &quot;);
    }
    return &quot;&quot;;
  }
  /**
   * sum values
   * @returns resolved value
   */
  sum() {
    const value = [];
    if (__privateGet(this, _hasNum)) {
      let num = 0;
      for (const i of __privateGet(this, _numSum)) {
        num += i;
        if (!Number.isFinite(num) || Number.isNaN(num)) {
          break;
        }
      }
      value.push(num);
    }
    if (__privateGet(this, _hasPct)) {
      let num = 0;
      for (const i of __privateGet(this, _pctSum)) {
        num += i;
        if (!Number.isFinite(num)) {
          break;
        }
      }
      if (Number.isFinite(num)) {
        num = `${num}%`;
      }
      if (value.length) {
        value.push(`+ ${num}`);
      } else {
        value.push(num);
      }
    }
    if (__privateGet(this, _hasDim)) {
      let dim, sum, sub;
      if (__privateGet(this, _dimSum).length) {
        sum = this.sort(__privateGet(this, _dimSum)).join(&quot; + &quot;);
      }
      if (__privateGet(this, _dimSub).length) {
        sub = this.sort(__privateGet(this, _dimSub)).join(&quot; + &quot;);
      }
      if (sum) {
        if (sub) {
          if (sub.includes(&quot;-&quot;)) {
            dim = calc(`calc(${sum} - (${sub}))`, {
              toCanonicalUnits: true
            });
          } else {
            dim = calc(`calc(${sum} - ${sub})`, {
              toCanonicalUnits: true
            });
          }
        } else {
          dim = calc(`calc(${sum})`, {
            toCanonicalUnits: true
          });
        }
      } else {
        dim = calc(`calc(-1 * (${sub}))`, {
          toCanonicalUnits: true
        });
      }
      if (value.length) {
        value.push(&quot;+&quot;, dim.replace(/^calc/, &quot;&quot;));
      } else {
        value.push(dim.replace(/^calc/, &quot;&quot;));
      }
    }
    if (__privateGet(this, _hasEtc)) {
      if (__privateGet(this, _etcSum).length) {
        const sum = this.sort(__privateGet(this, _etcSum)).map((item) =&gt; {
          let res;
          if (REG_OPERATOR.test(item) &amp;&amp; !item.startsWith(&quot;(&quot;) &amp;&amp; !item.endsWith(&quot;)&quot;)) {
            res = `(${item})`;
          } else {
            res = item;
          }
          return res;
        }).join(&quot; + &quot;);
        if (value.length) {
          if (__privateGet(this, _etcSum).length &gt; 1) {
            value.push(`+ (${sum})`);
          } else {
            value.push(`+ ${sum}`);
          }
        } else {
          value.push(`${sum}`);
        }
      }
      if (__privateGet(this, _etcSub).length) {
        const sub = this.sort(__privateGet(this, _etcSub)).map((item) =&gt; {
          let res;
          if (REG_OPERATOR.test(item) &amp;&amp; !item.startsWith(&quot;(&quot;) &amp;&amp; !item.endsWith(&quot;)&quot;)) {
            res = `(${item})`;
          } else {
            res = item;
          }
          return res;
        }).join(&quot; + &quot;);
        if (value.length) {
          if (__privateGet(this, _etcSub).length &gt; 1) {
            value.push(`- (${sub})`);
          } else {
            value.push(`- ${sub}`);
          }
        } else if (__privateGet(this, _etcSub).length &gt; 1) {
          value.push(`-1 * (${sub})`);
        } else {
          value.push(`-1 * ${sub}`);
        }
      }
    }
    if (value.length) {
      return value.join(&quot; &quot;);
    }
    return &quot;&quot;;
  }
}
_hasNum = new WeakMap();
_numSum = new WeakMap();
_numMul = new WeakMap();
_hasPct = new WeakMap();
_pctSum = new WeakMap();
_pctMul = new WeakMap();
_hasDim = new WeakMap();
_dimSum = new WeakMap();
_dimSub = new WeakMap();
_dimMul = new WeakMap();
_dimDiv = new WeakMap();
_hasEtc = new WeakMap();
_etcSum = new WeakMap();
_etcSub = new WeakMap();
_etcMul = new WeakMap();
_etcDiv = new WeakMap();
const sortCalcValues = (values = [], finalize = false) =&gt; {
  if (values.length &lt; TRIA) {
    throw new Error(`Unexpected array length ${values.length}.`);
  }
  const start = values.shift();
  if (!isString(start) || !start.endsWith(&quot;(&quot;)) {
    throw new Error(`Unexpected token ${start}.`);
  }
  const end = values.pop();
  if (end !== &quot;)&quot;) {
    throw new Error(`Unexpected token ${end}.`);
  }
  if (values.length === 1) {
    const [value] = values;
    if (!isStringOrNumber(value)) {
      throw new Error(`Unexpected token ${value}.`);
    }
    return `${start}${value}${end}`;
  }
  const sortedValues = [];
  const cal = new Calculator();
  let operator = &quot;&quot;;
  const l = values.length;
  for (let i = 0; i &lt; l; i++) {
    const value = values[i];
    if (!isStringOrNumber(value)) {
      throw new Error(`Unexpected token ${value}.`);
    }
    if (value === &quot;*&quot; || value === &quot;/&quot;) {
      operator = value;
    } else if (value === &quot;+&quot; || value === &quot;-&quot;) {
      const sortedValue = cal.multiply();
      if (sortedValue) {
        sortedValues.push(sortedValue, value);
      }
      cal.clear();
      operator = &quot;&quot;;
    } else {
      const numValue = Number(value);
      const strValue = `${value}`;
      switch (operator) {
        case &quot;/&quot;: {
          if (Number.isFinite(numValue)) {
            cal.hasNum = true;
            cal.numMul.push(1 / numValue);
          } else if (REG_TYPE_PCT.test(strValue)) {
            const [, val] = strValue.match(REG_TYPE_PCT);
            cal.hasPct = true;
            cal.pctMul.push(MAX_PCT * MAX_PCT / Number(val));
          } else if (REG_TYPE_DIM.test(strValue)) {
            cal.hasDim = true;
            cal.dimDiv.push(strValue);
          } else {
            cal.hasEtc = true;
            cal.etcDiv.push(strValue);
          }
          break;
        }
        case &quot;*&quot;:
        default: {
          if (Number.isFinite(numValue)) {
            cal.hasNum = true;
            cal.numMul.push(numValue);
          } else if (REG_TYPE_PCT.test(strValue)) {
            const [, val] = strValue.match(REG_TYPE_PCT);
            cal.hasPct = true;
            cal.pctMul.push(Number(val));
          } else if (REG_TYPE_DIM.test(strValue)) {
            cal.hasDim = true;
            cal.dimMul.push(strValue);
          } else {
            cal.hasEtc = true;
            cal.etcMul.push(strValue);
          }
        }
      }
    }
    if (i === l - 1) {
      const sortedValue = cal.multiply();
      if (sortedValue) {
        sortedValues.push(sortedValue);
      }
      cal.clear();
      operator = &quot;&quot;;
    }
  }
  let resolvedValue = &quot;&quot;;
  if (finalize &amp;&amp; (sortedValues.includes(&quot;+&quot;) || sortedValues.includes(&quot;-&quot;))) {
    const finalizedValues = [];
    cal.clear();
    operator = &quot;&quot;;
    const l2 = sortedValues.length;
    for (let i = 0; i &lt; l2; i++) {
      const value = sortedValues[i];
      if (isStringOrNumber(value)) {
        if (value === &quot;+&quot; || value === &quot;-&quot;) {
          operator = value;
        } else {
          const numValue = Number(value);
          const strValue = `${value}`;
          switch (operator) {
            case &quot;-&quot;: {
              if (Number.isFinite(numValue)) {
                cal.hasNum = true;
                cal.numSum.push(-1 * numValue);
              } else if (REG_TYPE_PCT.test(strValue)) {
                const [, val] = strValue.match(REG_TYPE_PCT);
                cal.hasPct = true;
                cal.pctSum.push(-1 * Number(val));
              } else if (REG_TYPE_DIM.test(strValue)) {
                cal.hasDim = true;
                cal.dimSub.push(strValue);
              } else {
                cal.hasEtc = true;
                cal.etcSub.push(strValue);
              }
              break;
            }
            case &quot;+&quot;:
            default: {
              if (Number.isFinite(numValue)) {
                cal.hasNum = true;
                cal.numSum.push(numValue);
              } else if (REG_TYPE_PCT.test(strValue)) {
                const [, val] = strValue.match(REG_TYPE_PCT);
                cal.hasPct = true;
                cal.pctSum.push(Number(val));
              } else if (REG_TYPE_DIM.test(strValue)) {
                cal.hasDim = true;
                cal.dimSum.push(strValue);
              } else {
                cal.hasEtc = true;
                cal.etcSum.push(strValue);
              }
            }
          }
        }
      }
      if (i === l2 - 1) {
        const sortedValue = cal.sum();
        if (sortedValue) {
          finalizedValues.push(sortedValue);
        }
        cal.clear();
        operator = &quot;&quot;;
      }
    }
    resolvedValue = finalizedValues.join(&quot; &quot;).replace(/\+\s-/g, &quot;- &quot;);
  } else {
    resolvedValue = sortedValues.join(&quot; &quot;).replace(/\+\s-/g, &quot;- &quot;);
  }
  if (resolvedValue.startsWith(&quot;(&quot;) &amp;&amp; resolvedValue.endsWith(&quot;)&quot;) &amp;&amp; resolvedValue.lastIndexOf(&quot;(&quot;) === 0 &amp;&amp; resolvedValue.indexOf(&quot;)&quot;) === resolvedValue.length - 1) {
    resolvedValue = resolvedValue.replace(/^\(/, &quot;&quot;).replace(/\)$/, &quot;&quot;);
  }
  return `${start}${resolvedValue}${end}`;
};
const serializeCalc = (value, opt = {}) =&gt; {
  const { format = &quot;&quot; } = opt;
  if (isString(value)) {
    if (!REG_FN_VAR_START.test(value) || format !== VAL_SPEC) {
      return value;
    }
    value = value.toLowerCase().trim();
  } else {
    throw new TypeError(`${value} is not a string.`);
  }
  const cacheKey = createCacheKey(
    {
      namespace: NAMESPACE,
      name: &quot;serializeCalc&quot;,
      value
    },
    opt
  );
  const cachedResult = getCache(cacheKey);
  if (cachedResult instanceof CacheItem) {
    return cachedResult.item;
  }
  const items = tokenize({ css: value }).map((token) =&gt; {
    const [type, value2] = token;
    let res = &quot;&quot;;
    if (type !== W_SPACE &amp;&amp; type !== COMMENT) {
      res = value2;
    }
    return res;
  }).filter((v) =&gt; v);
  let startIndex = items.findLastIndex((item) =&gt; /\($/.test(item));
  while (startIndex) {
    const endIndex = items.findIndex((item, index) =&gt; {
      return item === &quot;)&quot; &amp;&amp; index &gt; startIndex;
    });
    const slicedValues = items.slice(startIndex, endIndex + 1);
    let serializedValue = sortCalcValues(slicedValues);
    if (REG_FN_VAR_START.test(serializedValue)) {
      serializedValue = calc(serializedValue, {
        toCanonicalUnits: true
      });
    }
    items.splice(startIndex, endIndex - startIndex + 1, serializedValue);
    startIndex = items.findLastIndex((item) =&gt; /\($/.test(item));
  }
  const serializedCalc = sortCalcValues(items, true);
  setCache(cacheKey, serializedCalc);
  return serializedCalc;
};
const resolveDimension = (token, opt = {}) =&gt; {
  if (!Array.isArray(token)) {
    throw new TypeError(`${token} is not an array.`);
  }
  const [, , , , detail = {}] = token;
  const { unit, value } = detail;
  const { dimension = {} } = opt;
  if (unit === &quot;px&quot;) {
    return `${value}${unit}`;
  }
  const relativeValue = Number(value);
  if (unit &amp;&amp; Number.isFinite(relativeValue)) {
    let pixelValue;
    if (Object.hasOwnProperty.call(dimension, unit)) {
      pixelValue = dimension[unit];
    } else if (typeof dimension.callback === &quot;function&quot;) {
      pixelValue = dimension.callback(unit);
    }
    pixelValue = Number(pixelValue);
    if (Number.isFinite(pixelValue)) {
      return `${relativeValue * pixelValue}px`;
    }
  }
  return new NullObject();
};
const parseTokens = (tokens, opt = {}) =&gt; {
  if (!Array.isArray(tokens)) {
    throw new TypeError(`${tokens} is not an array.`);
  }
  const { format = &quot;&quot; } = opt;
  const mathFunc = /* @__PURE__ */ new Set();
  let nest = 0;
  const res = [];
  while (tokens.length) {
    const token = tokens.shift();
    if (!Array.isArray(token)) {
      throw new TypeError(`${token} is not an array.`);
    }
    const [type = &quot;&quot;, value = &quot;&quot;] = token;
    switch (type) {
      case DIM: {
        if (format === VAL_SPEC &amp;&amp; !mathFunc.has(nest)) {
          res.push(value);
        } else {
          const resolvedValue = resolveDimension(token, opt);
          if (isString(resolvedValue)) {
            res.push(resolvedValue);
          } else {
            res.push(value);
          }
        }
        break;
      }
      case FUNC:
      case PAREN_OPEN: {
        res.push(value);
        nest++;
        if (REG_FN_MATH_START.test(value)) {
          mathFunc.add(nest);
        }
        break;
      }
      case PAREN_CLOSE: {
        if (res.length) {
          const lastValue = res[res.length - 1];
          if (lastValue === &quot; &quot;) {
            res.splice(-1, 1, value);
          } else {
            res.push(value);
          }
        } else {
          res.push(value);
        }
        if (mathFunc.has(nest)) {
          mathFunc.delete(nest);
        }
        nest--;
        break;
      }
      case W_SPACE: {
        if (res.length) {
          const lastValue = res[res.length - 1];
          if (isString(lastValue) &amp;&amp; !lastValue.endsWith(&quot;(&quot;) &amp;&amp; lastValue !== &quot; &quot;) {
            res.push(value);
          }
        }
        break;
      }
      default: {
        if (type !== COMMENT &amp;&amp; type !== EOF) {
          res.push(value);
        }
      }
    }
  }
  return res;
};
const cssCalc = (value, opt = {}) =&gt; {
  const { format = &quot;&quot; } = opt;
  if (isString(value)) {
    if (REG_FN_VAR.test(value)) {
      if (format === VAL_SPEC) {
        return value;
      } else {
        const resolvedValue2 = resolveVar(value, opt);
        if (isString(resolvedValue2)) {
          return resolvedValue2;
        } else {
          return &quot;&quot;;
        }
      }
    } else if (!REG_FN_CALC.test(value)) {
      return value;
    }
    value = value.toLowerCase().trim();
  } else {
    throw new TypeError(`${value} is not a string.`);
  }
  const cacheKey = createCacheKey(
    {
      namespace: NAMESPACE,
      name: &quot;cssCalc&quot;,
      value
    },
    opt
  );
  const cachedResult = getCache(cacheKey);
  if (cachedResult instanceof CacheItem) {
    return cachedResult.item;
  }
  const tokens = tokenize({ css: value });
  const values = parseTokens(tokens, opt);
  let resolvedValue = calc(values.join(&quot;&quot;), {
    toCanonicalUnits: true
  });
  if (REG_FN_VAR_START.test(value)) {
    if (REG_TYPE_DIM_PCT.test(resolvedValue)) {
      const [, val, unit] = resolvedValue.match(
        REG_TYPE_DIM_PCT
      );
      resolvedValue = `${roundToPrecision(Number(val), HEX)}${unit}`;
    }
    if (resolvedValue &amp;&amp; !REG_FN_VAR_START.test(resolvedValue) &amp;&amp; format === VAL_SPEC) {
      resolvedValue = `calc(${resolvedValue})`;
    }
  }
  if (format === VAL_SPEC) {
    if (/\s[-+*/]\s/.test(resolvedValue) &amp;&amp; !resolvedValue.includes(&quot;NaN&quot;)) {
      resolvedValue = serializeCalc(resolvedValue, opt);
    } else if (REG_FN_CALC_NUM.test(resolvedValue)) {
      const [, val] = resolvedValue.match(REG_FN_CALC_NUM);
      resolvedValue = `calc(${roundToPrecision(Number(val), HEX)})`;
    }
  }
  setCache(cacheKey, resolvedValue);
  return resolvedValue;
};
export {
  Calculator,
  cssCalc,
  parseTokens,
  resolveDimension,
  serializeCalc,
  sortCalcValues
};
//# sourceMappingURL=css-calc.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
