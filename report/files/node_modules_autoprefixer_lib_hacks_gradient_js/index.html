<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/autoprefixer/lib/hacks/gradient.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/autoprefixer/lib/hacks/gradient.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">449</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">78.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">let range = require(&#039;normalize-range&#039;)
let parser = require(&#039;postcss-value-parser&#039;)

let OldValue = require(&#039;../old-value&#039;)
let utils = require(&#039;../utils&#039;)
let Value = require(&#039;../value&#039;)

let IS_DIRECTION = /top|left|right|bottom/gi

class Gradient extends Value {
  /**
   * Do not add non-webkit prefixes for list-style and object
   */
  add(decl, prefix) {
    let p = decl.prop
    if (p.includes(&#039;mask&#039;)) {
      if (prefix === &#039;-webkit-&#039; || prefix === &#039;-webkit- old&#039;) {
        return super.add(decl, prefix)
      }
    } else if (
      p === &#039;list-style&#039; ||
      p === &#039;list-style-image&#039; ||
      p === &#039;content&#039;
    ) {
      if (prefix === &#039;-webkit-&#039; || prefix === &#039;-webkit- old&#039;) {
        return super.add(decl, prefix)
      }
    } else {
      return super.add(decl, prefix)
    }
    return undefined
  }

  /**
   * Get div token from exists parameters
   */
  cloneDiv(params) {
    for (let i of params) {
      if (i.type === &#039;div&#039; &amp;&amp; i.value === &#039;,&#039;) {
        return i
      }
    }
    return { after: &#039; &#039;, type: &#039;div&#039;, value: &#039;,&#039; }
  }

  /**
   * Change colors syntax to old webkit
   */
  colorStops(params) {
    let result = []
    for (let i = 0; i &lt; params.length; i++) {
      let pos
      let param = params[i]
      let item
      if (i === 0) {
        continue
      }

      let color = parser.stringify(param[0])
      if (param[1] &amp;&amp; param[1].type === &#039;word&#039;) {
        pos = param[1].value
      } else if (param[2] &amp;&amp; param[2].type === &#039;word&#039;) {
        pos = param[2].value
      }

      let stop
      if (i === 1 &amp;&amp; (!pos || pos === &#039;0%&#039;)) {
        stop = `from(${color})`
      } else if (i === params.length - 1 &amp;&amp; (!pos || pos === &#039;100%&#039;)) {
        stop = `to(${color})`
      } else if (pos) {
        stop = `color-stop(${pos}, ${color})`
      } else {
        stop = `color-stop(${color})`
      }

      let div = param[param.length - 1]
      params[i] = [{ type: &#039;word&#039;, value: stop }]
      if (div.type === &#039;div&#039; &amp;&amp; div.value === &#039;,&#039;) {
        item = params[i].push(div)
      }
      result.push(item)
    }
    return result
  }

  /**
   * Change new direction to old
   */
  convertDirection(params) {
    if (params.length &gt; 0) {
      if (params[0].value === &#039;to&#039;) {
        this.fixDirection(params)
      } else if (params[0].value.includes(&#039;deg&#039;)) {
        this.fixAngle(params)
      } else if (this.isRadial(params)) {
        this.fixRadial(params)
      }
    }
    return params
  }

  /**
   * Add 90 degrees
   */
  fixAngle(params) {
    let first = params[0].value
    first = parseFloat(first)
    first = Math.abs(450 - first) % 360
    first = this.roundFloat(first, 3)
    params[0].value = `${first}deg`
  }

  /**
   * Replace `to top left` to `bottom right`
   */
  fixDirection(params) {
    params.splice(0, 2)

    for (let param of params) {
      if (param.type === &#039;div&#039;) {
        break
      }
      if (param.type === &#039;word&#039;) {
        param.value = this.revertDirection(param.value)
      }
    }
  }

  /**
   * Fix radial direction syntax
   */
  fixRadial(params) {
    let first = []
    let second = []
    let a, b, c, i, next

    for (i = 0; i &lt; params.length - 2; i++) {
      a = params[i]
      b = params[i + 1]
      c = params[i + 2]
      if (a.type === &#039;space&#039; &amp;&amp; b.value === &#039;at&#039; &amp;&amp; c.type === &#039;space&#039;) {
        next = i + 3
        break
      } else {
        first.push(a)
      }
    }

    let div
    for (i = next; i &lt; params.length; i++) {
      if (params[i].type === &#039;div&#039;) {
        div = params[i]
        break
      } else {
        second.push(params[i])
      }
    }

    params.splice(0, i, ...second, div, ...first)
  }

  /**
   * Look for at word
   */
  isRadial(params) {
    let state = &#039;before&#039;
    for (let param of params) {
      if (state === &#039;before&#039; &amp;&amp; param.type === &#039;space&#039;) {
        state = &#039;at&#039;
      } else if (state === &#039;at&#039; &amp;&amp; param.value === &#039;at&#039;) {
        state = &#039;after&#039;
      } else if (state === &#039;after&#039; &amp;&amp; param.type === &#039;space&#039;) {
        return true
      } else if (param.type === &#039;div&#039;) {
        break
      } else {
        state = &#039;before&#039;
      }
    }
    return false
  }

  /**
   * Replace old direction to new
   */
  newDirection(params) {
    if (params[0].value === &#039;to&#039;) {
      return params
    }
    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp
    if (!IS_DIRECTION.test(params[0].value)) {
      return params
    }

    params.unshift(
      {
        type: &#039;word&#039;,
        value: &#039;to&#039;
      },
      {
        type: &#039;space&#039;,
        value: &#039; &#039;
      }
    )

    for (let i = 2; i &lt; params.length; i++) {
      if (params[i].type === &#039;div&#039;) {
        break
      }
      if (params[i].type === &#039;word&#039;) {
        params[i].value = this.revertDirection(params[i].value)
      }
    }

    return params
  }

  /**
   * Normalize angle
   */
  normalize(nodes, gradientName) {
    if (!nodes[0]) return nodes

    if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)
    } else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)
    } else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)
    } else if (nodes[0].value.includes(&#039;deg&#039;)) {
      let num = parseFloat(nodes[0].value)
      num = range.wrap(0, 360, num)
      nodes[0].value = `${num}deg`
    }

    if (
      gradientName === &#039;linear-gradient&#039; ||
      gradientName === &#039;repeating-linear-gradient&#039;
    ) {
      let direction = nodes[0].value

      // Unitless zero for `&lt;angle&gt;` values are allowed in CSS gradients and transforms.
      // Spec: https://github.com/w3c/csswg-drafts/commit/602789171429b2231223ab1e5acf8f7f11652eb3
      if (direction === &#039;0deg&#039; || direction === &#039;0&#039;) {
        nodes = this.replaceFirst(nodes, &#039;to&#039;, &#039; &#039;, &#039;top&#039;)
      } else if (direction === &#039;90deg&#039;) {
        nodes = this.replaceFirst(nodes, &#039;to&#039;, &#039; &#039;, &#039;right&#039;)
      } else if (direction === &#039;180deg&#039;) {
        nodes = this.replaceFirst(nodes, &#039;to&#039;, &#039; &#039;, &#039;bottom&#039;) // default value
      } else if (direction === &#039;270deg&#039;) {
        nodes = this.replaceFirst(nodes, &#039;to&#039;, &#039; &#039;, &#039;left&#039;)
      }
    }

    return nodes
  }

  /**
   * Convert angle unit to deg
   */
  normalizeUnit(str, full) {
    let num = parseFloat(str)
    let deg = (num / full) * 360
    return `${deg}deg`
  }

  /**
   * Remove old WebKit gradient too
   */
  old(prefix) {
    if (prefix === &#039;-webkit-&#039;) {
      let type
      if (this.name === &#039;linear-gradient&#039;) {
        type = &#039;linear&#039;
      } else if (this.name === &#039;repeating-linear-gradient&#039;) {
        type = &#039;repeating-linear&#039;
      } else if (this.name === &#039;repeating-radial-gradient&#039;) {
        type = &#039;repeating-radial&#039;
      } else {
        type = &#039;radial&#039;
      }
      let string = &#039;-gradient&#039;
      let regexp = utils.regexp(
        `-webkit-(${type}-gradient|gradient\\(\\s*${type})`,
        false
      )

      return new OldValue(this.name, prefix + this.name, string, regexp)
    } else {
      return super.old(prefix)
    }
  }

  /**
   * Change direction syntax to old webkit
   */
  oldDirection(params) {
    let div = this.cloneDiv(params[0])

    if (params[0][0].value !== &#039;to&#039;) {
      return params.unshift([
        { type: &#039;word&#039;, value: Gradient.oldDirections.bottom },
        div
      ])
    } else {
      let words = []
      for (let node of params[0].slice(2)) {
        if (node.type === &#039;word&#039;) {
          words.push(node.value.toLowerCase())
        }
      }

      words = words.join(&#039; &#039;)
      let old = Gradient.oldDirections[words] || words

      params[0] = [{ type: &#039;word&#039;, value: old }, div]
      return params[0]
    }
  }

  /**
   * Convert to old webkit syntax
   */
  oldWebkit(node) {
    let { nodes } = node
    let string = parser.stringify(node.nodes)

    if (this.name !== &#039;linear-gradient&#039;) {
      return false
    }
    if (nodes[0] &amp;&amp; nodes[0].value.includes(&#039;deg&#039;)) {
      return false
    }
    if (
      string.includes(&#039;px&#039;) ||
      string.includes(&#039;-corner&#039;) ||
      string.includes(&#039;-side&#039;)
    ) {
      return false
    }

    let params = [[]]
    for (let i of nodes) {
      params[params.length - 1].push(i)
      if (i.type === &#039;div&#039; &amp;&amp; i.value === &#039;,&#039;) {
        params.push([])
      }
    }

    this.oldDirection(params)
    this.colorStops(params)

    node.nodes = []
    for (let param of params) {
      node.nodes = node.nodes.concat(param)
    }

    node.nodes.unshift(
      { type: &#039;word&#039;, value: &#039;linear&#039; },
      this.cloneDiv(node.nodes)
    )
    node.value = &#039;-webkit-gradient&#039;

    return true
  }

  /**
   * Change degrees for webkit prefix
   */
  replace(string, prefix) {
    let ast = parser(string)
    for (let node of ast.nodes) {
      let gradientName = this.name // gradient name
      if (node.type === &#039;function&#039; &amp;&amp; node.value === gradientName) {
        node.nodes = this.newDirection(node.nodes)
        node.nodes = this.normalize(node.nodes, gradientName)
        if (prefix === &#039;-webkit- old&#039;) {
          let changes = this.oldWebkit(node)
          if (!changes) {
            return false
          }
        } else {
          node.nodes = this.convertDirection(node.nodes)
          node.value = prefix + node.value
        }
      }
    }
    return ast.toString()
  }

  /**
   * Replace first token
   */
  replaceFirst(params, ...words) {
    let prefix = words.map(i =&gt; {
      if (i === &#039; &#039;) {
        return { type: &#039;space&#039;, value: i }
      }
      return { type: &#039;word&#039;, value: i }
    })
    return prefix.concat(params.slice(1))
  }

  revertDirection(word) {
    return Gradient.directions[word.toLowerCase()] || word
  }

  /**
   * Round float and save digits under dot
   */
  roundFloat(float, digits) {
    return parseFloat(float.toFixed(digits))
  }
}

Gradient.names = [
  &#039;linear-gradient&#039;,
  &#039;repeating-linear-gradient&#039;,
  &#039;radial-gradient&#039;,
  &#039;repeating-radial-gradient&#039;
]

Gradient.directions = {
  bottom: &#039;top&#039;,
  left: &#039;right&#039;,
  right: &#039;left&#039;,
  top: &#039;bottom&#039; // default value
}

// Direction to replace
Gradient.oldDirections = {
  &#039;bottom&#039;: &#039;left top, left bottom&#039;,
  &#039;bottom left&#039;: &#039;right top, left bottom&#039;,
  &#039;bottom right&#039;: &#039;left top, right bottom&#039;,
  &#039;left&#039;: &#039;right top, left top&#039;,

  &#039;left bottom&#039;: &#039;right top, left bottom&#039;,
  &#039;left top&#039;: &#039;right bottom, left top&#039;,
  &#039;right&#039;: &#039;left top, right top&#039;,
  &#039;right bottom&#039;: &#039;left top, right bottom&#039;,
  &#039;right top&#039;: &#039;left bottom, right top&#039;,
  &#039;top&#039;: &#039;left bottom, left top&#039;,
  &#039;top left&#039;: &#039;right bottom, left top&#039;,
  &#039;top right&#039;: &#039;left bottom, right top&#039;
}

module.exports = Gradient
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
