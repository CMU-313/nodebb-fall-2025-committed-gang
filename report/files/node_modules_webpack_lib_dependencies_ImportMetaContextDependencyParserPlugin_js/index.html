<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/dependencies/ImportMetaContextDependencyParserPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/dependencies/ImportMetaContextDependencyParserPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">308</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">43.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.92</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/

&quot;use strict&quot;;

const WebpackError = require(&quot;../WebpackError&quot;);
const {
	evaluateToIdentifier
} = require(&quot;../javascript/JavascriptParserHelpers&quot;);
const ImportMetaContextDependency = require(&quot;./ImportMetaContextDependency&quot;);

/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;estree&quot;).ObjectExpression} ObjectExpression */
/** @typedef {import(&quot;estree&quot;).Property} Property */
/** @typedef {import(&quot;estree&quot;).Identifier} Identifier */
/** @typedef {import(&quot;estree&quot;).SourceLocation} SourceLocation */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;)} JavascriptParser */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).Range} Range */
/** @typedef {import(&quot;../ContextModule&quot;).ContextModuleOptions} ContextModuleOptions */
/** @typedef {import(&quot;../ChunkGroup&quot;).RawChunkGroupOptions} RawChunkGroupOptions */
/** @typedef {import(&quot;../Dependency&quot;).DependencyLocation} DependencyLocation */
/** @typedef {import(&quot;../javascript/BasicEvaluatedExpression&quot;)} BasicEvaluatedExpression */
/** @typedef {Pick&lt;ContextModuleOptions, &#039;mode&#039;|&#039;recursive&#039;|&#039;regExp&#039;|&#039;include&#039;|&#039;exclude&#039;|&#039;chunkName&#039;&gt;&amp;{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[&quot;referencedExports&quot;]}} ImportMetaContextOptions */

/**
 * @param {Property} prop property
 * @param {string} expect except message
 * @returns {WebpackError} error
 */
function createPropertyParseError(prop, expect) {
	return createError(
		`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(
			/** @type {Identifier} */
			(prop.key).name
		)}, expected type ${expect}.`,
		/** @type {DependencyLocation} */
		(prop.value.loc)
	);
}

/**
 * @param {string} msg message
 * @param {DependencyLocation} loc location
 * @returns {WebpackError} error
 */
function createError(msg, loc) {
	const error = new WebpackError(msg);
	error.name = &quot;ImportMetaContextError&quot;;
	error.loc = loc;
	return error;
}

const PLUGIN_NAME = &quot;ImportMetaContextDependencyParserPlugin&quot;;

module.exports = class ImportMetaContextDependencyParserPlugin {
	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		parser.hooks.evaluateIdentifier
			.for(&quot;import.meta.webpackContext&quot;)
			.tap(PLUGIN_NAME, expr =&gt;
				evaluateToIdentifier(
					&quot;import.meta.webpackContext&quot;,
					&quot;import.meta&quot;,
					() =&gt; [&quot;webpackContext&quot;],
					true
				)(expr)
			);
		parser.hooks.call
			.for(&quot;import.meta.webpackContext&quot;)
			.tap(PLUGIN_NAME, expr =&gt; {
				if (expr.arguments.length &lt; 1 || expr.arguments.length &gt; 2) return;
				const [directoryNode, optionsNode] = expr.arguments;
				if (optionsNode &amp;&amp; optionsNode.type !== &quot;ObjectExpression&quot;) return;
				const requestExpr = parser.evaluateExpression(
					/** @type {Expression} */ (directoryNode)
				);
				if (!requestExpr.isString()) return;
				const request = /** @type {string} */ (requestExpr.string);
				const errors = [];
				let regExp = /^\.\/.*$/;
				let recursive = true;
				/** @type {ContextModuleOptions[&quot;mode&quot;]} */
				let mode = &quot;sync&quot;;
				/** @type {ContextModuleOptions[&quot;include&quot;]} */
				let include;
				/** @type {ContextModuleOptions[&quot;exclude&quot;]} */
				let exclude;
				/** @type {RawChunkGroupOptions} */
				const groupOptions = {};
				/** @type {ContextModuleOptions[&quot;chunkName&quot;]} */
				let chunkName;
				/** @type {ContextModuleOptions[&quot;referencedExports&quot;]} */
				let exports;
				if (optionsNode) {
					for (const prop of /** @type {ObjectExpression} */ (optionsNode)
						.properties) {
						if (prop.type !== &quot;Property&quot; || prop.key.type !== &quot;Identifier&quot;) {
							errors.push(
								createError(
									&quot;Parsing import.meta.webpackContext options failed.&quot;,
									/** @type {DependencyLocation} */
									(optionsNode.loc)
								)
							);
							break;
						}
						switch (prop.key.name) {
							case &quot;regExp&quot;: {
								const regExpExpr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (!regExpExpr.isRegExp()) {
									errors.push(createPropertyParseError(prop, &quot;RegExp&quot;));
								} else {
									regExp = /** @type {RegExp} */ (regExpExpr.regExp);
								}
								break;
							}
							case &quot;include&quot;: {
								const regExpExpr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (!regExpExpr.isRegExp()) {
									errors.push(createPropertyParseError(prop, &quot;RegExp&quot;));
								} else {
									include = regExpExpr.regExp;
								}
								break;
							}
							case &quot;exclude&quot;: {
								const regExpExpr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (!regExpExpr.isRegExp()) {
									errors.push(createPropertyParseError(prop, &quot;RegExp&quot;));
								} else {
									exclude = regExpExpr.regExp;
								}
								break;
							}
							case &quot;mode&quot;: {
								const modeExpr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (!modeExpr.isString()) {
									errors.push(createPropertyParseError(prop, &quot;string&quot;));
								} else {
									mode = /** @type {ContextModuleOptions[&quot;mode&quot;]} */ (
										modeExpr.string
									);
								}
								break;
							}
							case &quot;chunkName&quot;: {
								const expr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (!expr.isString()) {
									errors.push(createPropertyParseError(prop, &quot;string&quot;));
								} else {
									chunkName = expr.string;
								}
								break;
							}
							case &quot;exports&quot;: {
								const expr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (expr.isString()) {
									exports = [[/** @type {string} */ (expr.string)]];
								} else if (expr.isArray()) {
									const items =
										/** @type {BasicEvaluatedExpression[]} */
										(expr.items);
									if (
										items.every(i =&gt; {
											if (!i.isArray()) return false;
											const innerItems =
												/** @type {BasicEvaluatedExpression[]} */ (i.items);
											return innerItems.every(i =&gt; i.isString());
										})
									) {
										exports = [];
										for (const i1 of items) {
											/** @type {string[]} */
											const export_ = [];
											for (const i2 of /** @type {BasicEvaluatedExpression[]} */ (
												i1.items
											)) {
												export_.push(/** @type {string} */ (i2.string));
											}
											exports.push(export_);
										}
									} else {
										errors.push(
											createPropertyParseError(prop, &quot;string|string[][]&quot;)
										);
									}
								} else {
									errors.push(
										createPropertyParseError(prop, &quot;string|string[][]&quot;)
									);
								}
								break;
							}
							case &quot;prefetch&quot;: {
								const expr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (expr.isBoolean()) {
									groupOptions.prefetchOrder = 0;
								} else if (expr.isNumber()) {
									groupOptions.prefetchOrder = expr.number;
								} else {
									errors.push(createPropertyParseError(prop, &quot;boolean|number&quot;));
								}
								break;
							}
							case &quot;preload&quot;: {
								const expr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (expr.isBoolean()) {
									groupOptions.preloadOrder = 0;
								} else if (expr.isNumber()) {
									groupOptions.preloadOrder = expr.number;
								} else {
									errors.push(createPropertyParseError(prop, &quot;boolean|number&quot;));
								}
								break;
							}
							case &quot;fetchPriority&quot;: {
								const expr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (
									expr.isString() &amp;&amp;
									[&quot;high&quot;, &quot;low&quot;, &quot;auto&quot;].includes(
										/** @type {string} */ (expr.string)
									)
								) {
									groupOptions.fetchPriority =
										/** @type {RawChunkGroupOptions[&quot;fetchPriority&quot;]} */ (
											expr.string
										);
								} else {
									errors.push(
										createPropertyParseError(prop, &#039;&quot;high&quot;|&quot;low&quot;|&quot;auto&quot;&#039;)
									);
								}
								break;
							}
							case &quot;recursive&quot;: {
								const recursiveExpr = parser.evaluateExpression(
									/** @type {Expression} */ (prop.value)
								);
								if (!recursiveExpr.isBoolean()) {
									errors.push(createPropertyParseError(prop, &quot;boolean&quot;));
								} else {
									recursive = /** @type {boolean} */ (recursiveExpr.bool);
								}
								break;
							}
							default:
								errors.push(
									createError(
										`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(
											prop.key.name
										)}.`,
										/** @type {DependencyLocation} */ (optionsNode.loc)
									)
								);
						}
					}
				}
				if (errors.length) {
					for (const error of errors) parser.state.current.addError(error);
					return;
				}

				const dep = new ImportMetaContextDependency(
					{
						request,
						include,
						exclude,
						recursive,
						regExp,
						groupOptions,
						chunkName,
						referencedExports: exports,
						mode,
						category: &quot;esm&quot;
					},
					/** @type {Range} */ (expr.range)
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				dep.optional = Boolean(parser.scope.inTry);
				parser.state.current.addDependency(dep);
				return true;
			});
	}
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
