<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/require-atomic-updates.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/require-atomic-updates.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">366</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">45.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.82</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`
 * @author Teddy Katz
 * @author Toru Nagashima
 */
&quot;use strict&quot;;

/**
 * Make the map from identifiers to each reference.
 * @param {escope.Scope} scope The scope to get references.
 * @param {Map&lt;Identifier, escope.Reference&gt;} [outReferenceMap] The map from identifier nodes to each reference object.
 * @returns {Map&lt;Identifier, escope.Reference&gt;} `referenceMap`.
 */
function createReferenceMap(scope, outReferenceMap = new Map()) {
	for (const reference of scope.references) {
		if (reference.resolved === null) {
			continue;
		}

		outReferenceMap.set(reference.identifier, reference);
	}
	for (const childScope of scope.childScopes) {
		if (childScope.type !== &quot;function&quot;) {
			createReferenceMap(childScope, outReferenceMap);
		}
	}

	return outReferenceMap;
}

/**
 * Get `reference.writeExpr` of a given reference.
 * If it&#039;s the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`
 * @param {escope.Reference} reference The reference to get.
 * @returns {Expression|null} The `reference.writeExpr`.
 */
function getWriteExpr(reference) {
	if (reference.writeExpr) {
		return reference.writeExpr;
	}
	let node = reference.identifier;

	while (node) {
		const t = node.parent.type;

		if (t === &quot;AssignmentExpression&quot; &amp;&amp; node.parent.left === node) {
			return node.parent.right;
		}
		if (t === &quot;MemberExpression&quot; &amp;&amp; node.parent.object === node) {
			node = node.parent;
			continue;
		}

		break;
	}

	return null;
}

/**
 * Checks if an expression is a variable that can only be observed within the given function.
 * @param {Variable|null} variable The variable to check
 * @param {boolean} isMemberAccess If `true` then this is a member access.
 * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.
 */
function isLocalVariableWithoutEscape(variable, isMemberAccess) {
	if (!variable) {
		return false; // A global variable which was not defined.
	}

	// If the reference is a property access and the variable is a parameter, it handles the variable is not local.
	if (isMemberAccess &amp;&amp; variable.defs.some(d =&gt; d.type === &quot;Parameter&quot;)) {
		return false;
	}

	const functionScope = variable.scope.variableScope;

	return variable.references.every(
		reference =&gt; reference.from.variableScope === functionScope,
	);
}

/**
 * Represents segment information.
 */
class SegmentInfo {
	constructor() {
		this.info = new WeakMap();
	}

	/**
	 * Initialize the segment information.
	 * @param {PathSegment} segment The segment to initialize.
	 * @returns {void}
	 */
	initialize(segment) {
		const outdatedReadVariables = new Set();
		const freshReadVariables = new Set();

		for (const prevSegment of segment.prevSegments) {
			const info = this.info.get(prevSegment);

			if (info) {
				info.outdatedReadVariables.forEach(
					Set.prototype.add,
					outdatedReadVariables,
				);
				info.freshReadVariables.forEach(
					Set.prototype.add,
					freshReadVariables,
				);
			}
		}

		this.info.set(segment, { outdatedReadVariables, freshReadVariables });
	}

	/**
	 * Mark a given variable as read on given segments.
	 * @param {PathSegment[]} segments The segments that it read the variable on.
	 * @param {Variable} variable The variable to be read.
	 * @returns {void}
	 */
	markAsRead(segments, variable) {
		for (const segment of segments) {
			const info = this.info.get(segment);

			if (info) {
				info.freshReadVariables.add(variable);

				// If a variable is freshly read again, then it&#039;s no more out-dated.
				info.outdatedReadVariables.delete(variable);
			}
		}
	}

	/**
	 * Move `freshReadVariables` to `outdatedReadVariables`.
	 * @param {PathSegment[]} segments The segments to process.
	 * @returns {void}
	 */
	makeOutdated(segments) {
		for (const segment of segments) {
			const info = this.info.get(segment);

			if (info) {
				info.freshReadVariables.forEach(
					Set.prototype.add,
					info.outdatedReadVariables,
				);
				info.freshReadVariables.clear();
			}
		}
	}

	/**
	 * Check if a given variable is outdated on the current segments.
	 * @param {PathSegment[]} segments The current segments.
	 * @param {Variable} variable The variable to check.
	 * @returns {boolean} `true` if the variable is outdated on the segments.
	 */
	isOutdated(segments, variable) {
		for (const segment of segments) {
			const info = this.info.get(segment);

			if (info &amp;&amp; info.outdatedReadVariables.has(variable)) {
				return true;
			}
		}
		return false;
	}
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;problem&quot;,

		defaultOptions: [
			{
				allowProperties: false,
			},
		],

		docs: {
			description:
				&quot;Disallow assignments that can lead to race conditions due to usage of `await` or `yield`&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/require-atomic-updates&quot;,
		},

		fixable: null,

		schema: [
			{
				type: &quot;object&quot;,
				properties: {
					allowProperties: {
						type: &quot;boolean&quot;,
					},
				},
				additionalProperties: false,
			},
		],

		messages: {
			nonAtomicUpdate:
				&quot;Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.&quot;,
			nonAtomicObjectUpdate:
				&quot;Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`.&quot;,
		},
	},

	create(context) {
		const [{ allowProperties }] = context.options;

		const sourceCode = context.sourceCode;
		const assignmentReferences = new Map();
		const segmentInfo = new SegmentInfo();
		let stack = null;

		return {
			onCodePathStart(codePath, node) {
				const scope = sourceCode.getScope(node);
				const shouldVerify =
					scope.type === &quot;function&quot; &amp;&amp;
					(scope.block.async || scope.block.generator);

				stack = {
					upper: stack,
					codePath,
					referenceMap: shouldVerify
						? createReferenceMap(scope)
						: null,
					currentSegments: new Set(),
				};
			},
			onCodePathEnd() {
				stack = stack.upper;
			},

			// Initialize the segment information.
			onCodePathSegmentStart(segment) {
				segmentInfo.initialize(segment);
				stack.currentSegments.add(segment);
			},

			onUnreachableCodePathSegmentStart(segment) {
				stack.currentSegments.add(segment);
			},

			onUnreachableCodePathSegmentEnd(segment) {
				stack.currentSegments.delete(segment);
			},

			onCodePathSegmentEnd(segment) {
				stack.currentSegments.delete(segment);
			},

			// Handle references to prepare verification.
			Identifier(node) {
				const { referenceMap } = stack;
				const reference = referenceMap &amp;&amp; referenceMap.get(node);

				// Ignore if this is not a valid variable reference.
				if (!reference) {
					return;
				}
				const variable = reference.resolved;
				const writeExpr = getWriteExpr(reference);
				const isMemberAccess =
					reference.identifier.parent.type === &quot;MemberExpression&quot;;

				// Add a fresh read variable.
				if (
					reference.isRead() &amp;&amp;
					!(writeExpr &amp;&amp; writeExpr.parent.operator === &quot;=&quot;)
				) {
					segmentInfo.markAsRead(stack.currentSegments, variable);
				}

				/*
				 * Register the variable to verify after ESLint traversed the `writeExpr` node
				 * if this reference is an assignment to a variable which is referred from other closure.
				 */
				if (
					writeExpr &amp;&amp;
					writeExpr.parent.right === writeExpr &amp;&amp; // ← exclude variable declarations.
					!isLocalVariableWithoutEscape(variable, isMemberAccess)
				) {
					let refs = assignmentReferences.get(writeExpr);

					if (!refs) {
						refs = [];
						assignmentReferences.set(writeExpr, refs);
					}

					refs.push(reference);
				}
			},

			/*
			 * Verify assignments.
			 * If the reference exists in `outdatedReadVariables` list, report it.
			 */
			&quot;:expression:exit&quot;(node) {
				// referenceMap exists if this is in a resumable function scope.
				if (!stack.referenceMap) {
					return;
				}

				// Mark the read variables on this code path as outdated.
				if (
					node.type === &quot;AwaitExpression&quot; ||
					node.type === &quot;YieldExpression&quot;
				) {
					segmentInfo.makeOutdated(stack.currentSegments);
				}

				// Verify.
				const references = assignmentReferences.get(node);

				if (references) {
					assignmentReferences.delete(node);

					for (const reference of references) {
						const variable = reference.resolved;

						if (
							segmentInfo.isOutdated(
								stack.currentSegments,
								variable,
							)
						) {
							if (node.parent.left === reference.identifier) {
								context.report({
									node: node.parent,
									messageId: &quot;nonAtomicUpdate&quot;,
									data: {
										value: variable.name,
									},
								});
							} else if (!allowProperties) {
								context.report({
									node: node.parent,
									messageId: &quot;nonAtomicObjectUpdate&quot;,
									data: {
										value: sourceCode.getText(
											node.parent.left,
										),
										object: variable.name,
									},
								});
							}
						}
					}
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
