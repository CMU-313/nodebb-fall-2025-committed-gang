<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/src/PFX.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/src/PFX.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">647</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">77.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.52</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import * as asn1js from &quot;asn1js&quot;;
import { getParametersValue, utilConcatBuf, clearProps } from &quot;pvutils&quot;;
import { getCrypto, getEngine, getRandomValues, getOIDByAlgorithm, getAlgorithmByOID } from &quot;./common.js&quot;;
import ContentInfo from &quot;./ContentInfo.js&quot;;
import MacData from &quot;./MacData.js&quot;;
import DigestInfo from &quot;./DigestInfo.js&quot;;
import AlgorithmIdentifier from &quot;./AlgorithmIdentifier.js&quot;;
import SignedData from &quot;./SignedData.js&quot;;
import EncapsulatedContentInfo from &quot;./EncapsulatedContentInfo.js&quot;;
import Attribute from &quot;./Attribute.js&quot;;
import SignerInfo from &quot;./SignerInfo.js&quot;;
import IssuerAndSerialNumber from &quot;./IssuerAndSerialNumber.js&quot;;
import SignedAndUnsignedAttributes from &quot;./SignedAndUnsignedAttributes.js&quot;;
import AuthenticatedSafe from &quot;./AuthenticatedSafe.js&quot;;
//**************************************************************************************
/**
 * Class from RFC7292
 */
export default class PFX 
{
	//**********************************************************************************
	/**
	 * Constructor for PFX class
	 * @param {Object} [parameters={}]
	 * @property {Object} [schema] asn1js parsed value
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @description version
		 */
		this.version = getParametersValue(parameters, &quot;version&quot;, PFX.defaultValues(&quot;version&quot;));
		/**
		 * @type {ContentInfo}
		 * @description authSafe
		 */
		this.authSafe = getParametersValue(parameters, &quot;authSafe&quot;, PFX.defaultValues(&quot;authSafe&quot;));
		
		if(&quot;macData&quot; in parameters)
			/**
			 * @type {MacData}
			 * @description macData
			 */
			this.macData = getParametersValue(parameters, &quot;macData&quot;, PFX.defaultValues(&quot;macData&quot;));
		
		if(&quot;parsedValue&quot; in parameters)
			/**
			 * @type {*}
			 * @description parsedValue
			 */
			this.parsedValue = getParametersValue(parameters, &quot;parsedValue&quot;, PFX.defaultValues(&quot;parsedValue&quot;));
		//endregion
		
		//region If input argument array contains &quot;schema&quot; for this object
		if(&quot;schema&quot; in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case &quot;version&quot;:
				return 3;
			case &quot;authSafe&quot;:
				return (new ContentInfo());
			case &quot;macData&quot;:
				return (new MacData());
			case &quot;parsedValue&quot;:
				return {};
			default:
				throw new Error(`Invalid member name for PFX class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case &quot;version&quot;:
				return (memberValue === PFX.defaultValues(memberName));
			case &quot;authSafe&quot;:
				return ((ContentInfo.compareWithDefault(&quot;contentType&quot;, memberValue.contentType)) &amp;&amp;
				(ContentInfo.compareWithDefault(&quot;content&quot;, memberValue.content)));
			case &quot;macData&quot;:
				return ((MacData.compareWithDefault(&quot;mac&quot;, memberValue.mac)) &amp;&amp;
				(MacData.compareWithDefault(&quot;macSalt&quot;, memberValue.macSalt)) &amp;&amp;
				(MacData.compareWithDefault(&quot;iterations&quot;, memberValue.iterations)));
			case &quot;parsedValue&quot;:
				return ((memberValue instanceof Object) &amp;&amp; (Object.keys(memberValue).length === 0));
			default:
				throw new Error(`Invalid member name for PFX class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of asn1js schema for current class
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		//PFX ::= SEQUENCE {
		//    version		INTEGER {v3(3)}(v3,...),
		//    authSafe	ContentInfo,
		//    macData    	MacData OPTIONAL
		//}
		
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [authSafe]
		 * @property {string} [macData]
		 */
		const names = getParametersValue(parameters, &quot;names&quot;, {});
		
		return (new asn1js.Sequence({
			name: (names.blockName || &quot;&quot;),
			value: [
				new asn1js.Integer({ name: (names.version || &quot;version&quot;) }),
				ContentInfo.schema(names.authSafe || {
					names: {
						blockName: &quot;authSafe&quot;
					}
				}),
				MacData.schema(names.macData || {
					names: {
						blockName: &quot;macData&quot;,
						optional: true
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		clearProps(schema, [
			&quot;version&quot;,
			&quot;authSafe&quot;,
			&quot;macData&quot;
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema,
			schema,
			PFX.schema({
				names: {
					version: &quot;version&quot;,
					authSafe: {
						names: {
							blockName: &quot;authSafe&quot;
						}
					},
					macData: {
						names: {
							blockName: &quot;macData&quot;
						}
					}
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error(&quot;Object&#039;s schema was not verified against input data for PFX&quot;);
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.authSafe = new ContentInfo({ schema: asn1.result.authSafe });
		
		if(&quot;macData&quot; in asn1.result)
			this.macData = new MacData({ schema: asn1.result.macData });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		const outputArray = [
			new asn1js.Integer({ value: this.version }),
			this.authSafe.toSchema()
		];
		
		if(&quot;macData&quot; in this)
			outputArray.push(this.macData.toSchema());
		
		return (new asn1js.Sequence({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const output = {
			version: this.version,
			authSafe: this.authSafe.toJSON()
		};
		
		if(&quot;macData&quot; in this)
			output.macData = this.macData.toJSON();
		
		return output;
	}
	//**********************************************************************************
	/**
	 * Making ContentInfo from &quot;parsedValue&quot; object
	 * @param {Object} parameters Parameters, specific to each &quot;integrity mode&quot;
	 */
	makeInternalValues(parameters = {})
	{
		//region Check mandatory parameter
		if((parameters instanceof Object) === false)
			return Promise.reject(&quot;The \&quot;parameters\&quot; must has \&quot;Object\&quot; type&quot;);
		
		if((&quot;parsedValue&quot; in this) === false)
			return Promise.reject(&quot;Please call \&quot;parseValues\&quot; function first in order to make \&quot;parsedValue\&quot; data&quot;);
		
		if((&quot;integrityMode&quot; in this.parsedValue) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;integrityMode\&quot; inside \&quot;parsedValue\&quot;&quot;);
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		//endregion
		
		//region Get a &quot;crypto&quot; extension
		const crypto = getCrypto();
		if(typeof crypto === &quot;undefined&quot;)
			return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion
		
		//region Makes values for each particular integrity mode
		//region Check that we do have neccessary fields in &quot;parsedValue&quot; object
		if((&quot;authenticatedSafe&quot; in this.parsedValue) === false)
			return Promise.reject(&quot;Absent mandatory parameter \&quot;authenticatedSafe\&quot; in \&quot;parsedValue\&quot;&quot;);
		//endregion
		
		switch(this.parsedValue.integrityMode)
		{
			//region HMAC-based integrity
			case 0:
				{
					//region Check additional mandatory parameters
					if((&quot;iterations&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;iterations\&quot;&quot;);
				
					if((&quot;pbkdf2HashAlgorithm&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;pbkdf2HashAlgorithm\&quot;&quot;);
				
					if((&quot;hmacHashAlgorithm&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;hmacHashAlgorithm\&quot;&quot;);
				
					if((&quot;password&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);
					//endregion
				
					//region Initial variables
					const saltBuffer = new ArrayBuffer(64);
					const saltView = new Uint8Array(saltBuffer);
				
					getRandomValues(saltView);
					
					const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);

					this.authSafe = new ContentInfo({
						contentType: &quot;1.2.840.113549.1.7.1&quot;,
						content: new asn1js.OctetString({ valueHex: data })
					});
					//endregion
					
					//region Call current crypto engine for making HMAC-based data stamp
					const engine = getEngine();
					
					if((&quot;stampDataWithPassword&quot; in engine.subtle) === false)
						return Promise.reject(`No support for &quot;stampDataWithPassword&quot; in current engine &quot;${engine.name}&quot;`);
					
					sequence = sequence.then(() =&gt;
						engine.subtle.stampDataWithPassword({
							password: parameters.password,
							hashAlgorithm: parameters.hmacHashAlgorithm,
							salt: saltBuffer,
							iterationCount: parameters.iterations,
							contentToStamp: data
						})
					);
					//endregion
					
					//region Make &quot;MacData&quot; values
					sequence = sequence.then(
						result =&gt;
						{
							this.macData = new MacData({
								mac: new DigestInfo({
									digestAlgorithm: new AlgorithmIdentifier({
										algorithmId: getOIDByAlgorithm({ name: parameters.hmacHashAlgorithm })
									}),
									digest: new asn1js.OctetString({ valueHex: result })
								}),
								macSalt: new asn1js.OctetString({ valueHex: saltBuffer }),
								iterations: parameters.iterations
							});
						},
						error =&gt; Promise.reject(error)
					);
					//endregion
					//endregion
				}
				break;
			//endregion
			//region publicKey-based integrity
			case 1:
				{
					//region Check additional mandatory parameters
					if((&quot;signingCertificate&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;signingCertificate\&quot;&quot;);
				
					if((&quot;privateKey&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;privateKey\&quot;&quot;);
				
					if((&quot;hashAlgorithm&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;hashAlgorithm\&quot;&quot;);
					//endregion
				
					//region Making data to be signed
					// NOTE: all internal data for &quot;authenticatedSafe&quot; must be already prepared.
					// Thus user must call &quot;makeValues&quot; for all internal &quot;SafeContent&quot; value with appropriate parameters.
					// Or user can choose to use values from initial parsing of existing PKCS#12 data.
				
					const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
					//endregion
					
					//region Initial variables
					const cmsSigned = new SignedData({
						version: 1,
						encapContentInfo: new EncapsulatedContentInfo({
							eContentType: &quot;1.2.840.113549.1.7.1&quot;, // &quot;data&quot; content type
							eContent: new asn1js.OctetString({ valueHex: toBeSigned })
						}),
						certificates: [parameters.signingCertificate]
					});
					//endregion
					
					//region Making additional attributes for CMS Signed Data
					//region Create a message digest
					sequence = sequence.then(
						() =&gt; crypto.digest({ name: parameters.hashAlgorithm }, new Uint8Array(toBeSigned))
					);
					//endregion
				
					//region Combine all signed extensions
					sequence = sequence.then(
						result =&gt;
						{
							//region Initial variables
							const signedAttr = [];
							//endregion
							
							//region contentType
							signedAttr.push(new Attribute({
								type: &quot;1.2.840.113549.1.9.3&quot;,
								values: [
									new asn1js.ObjectIdentifier({ value: &quot;1.2.840.113549.1.7.1&quot; })
								]
							}));
							//endregion
							//region signingTime
							signedAttr.push(new Attribute({
								type: &quot;1.2.840.113549.1.9.5&quot;,
								values: [
									new asn1js.UTCTime({ valueDate: new Date() })
								]
							}));
							//endregion
							//region messageDigest
							signedAttr.push(new Attribute({
								type: &quot;1.2.840.113549.1.9.4&quot;,
								values: [
									new asn1js.OctetString({ valueHex: result })
								]
							}));
							//endregion
							
							//region Making final value for &quot;SignerInfo&quot; type
							cmsSigned.signerInfos.push(new SignerInfo({
								version: 1,
								sid: new IssuerAndSerialNumber({
									issuer: parameters.signingCertificate.issuer,
									serialNumber: parameters.signingCertificate.serialNumber
								}),
								signedAttrs: new SignedAndUnsignedAttributes({
									type: 0,
									attributes: signedAttr
								})
							}));
							//endregion
						},
						error =&gt; Promise.reject(`Error during making digest for message: ${error}`)
					);
					//endregion
					//endregion
				
					//region Signing CMS Signed Data
					sequence = sequence.then(
						() =&gt; cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm)
					);
					//endregion
				
					//region Making final CMS_CONTENT_INFO type
					sequence = sequence.then(
						() =&gt;
						{
							this.authSafe = new ContentInfo({
								contentType: &quot;1.2.840.113549.1.7.2&quot;,
								content: cmsSigned.toSchema(true)
							});
						},
						error =&gt; Promise.reject(`Error during making signature: ${error}`)
					);
					//endregion
				}
				break;
			//endregion
			//region default
			default:
				return Promise.reject(`Parameter &quot;integrityMode&quot; has unknown value: ${parameters.integrityMode}`);
			//endregion
		}
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	parseInternalValues(parameters)
	{
		//region Check input data from &quot;parameters&quot; 
		if((parameters instanceof Object) === false)
			return Promise.reject(&quot;The \&quot;parameters\&quot; must has \&quot;Object\&quot; type&quot;);
		
		if((&quot;checkIntegrity&quot; in parameters) === false)
			parameters.checkIntegrity = true;
		//endregion 
		
		//region Initial variables 
		let sequence = Promise.resolve();
		//endregion 
		
		//region Get a &quot;crypto&quot; extension 
		const crypto = getCrypto();
		if(typeof crypto === &quot;undefined&quot;)
			return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion 
		
		//region Create value for &quot;this.parsedValue.authenticatedSafe&quot; and check integrity 
		this.parsedValue = {};
		
		switch(this.authSafe.contentType)
		{
			//region data 
			case &quot;1.2.840.113549.1.7.1&quot;:
				{
					//region Check additional mandatory parameters
					if((&quot;password&quot; in parameters) === false)
						return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);
					//endregion
				
					//region Integrity based on HMAC
					this.parsedValue.integrityMode = 0;
					//endregion
				
					//region Check that we do have OCTETSTRING as &quot;content&quot;
					if((this.authSafe.content instanceof asn1js.OctetString) === false)
						return Promise.reject(&quot;Wrong type of \&quot;this.authSafe.content\&quot;&quot;);
					//endregion
					
					//region Check we have &quot;constructive encoding&quot; for AuthSafe content
					let authSafeContent = new ArrayBuffer(0);
					
					if(this.authSafe.content.valueBlock.isConstructed)
					{
						for(const contentValue of this.authSafe.content.valueBlock.value)
							authSafeContent = utilConcatBuf(authSafeContent, contentValue.valueBlock.valueHex);
					}
					else
						authSafeContent = this.authSafe.content.valueBlock.valueHex;
					//endregion
					
					//region Parse internal ASN.1 data
					const asn1 = asn1js.fromBER(authSafeContent);
					if(asn1.offset === (-1))
						return Promise.reject(&quot;Error during parsing of ASN.1 data inside \&quot;this.authSafe.content\&quot;&quot;);
					//endregion
				
					//region Set &quot;authenticatedSafe&quot; value
					this.parsedValue.authenticatedSafe = new AuthenticatedSafe({ schema: asn1.result });
					//endregion
				
					//region Check integrity
					if(parameters.checkIntegrity)
					{
						//region Check that &quot;MacData&quot; exists
						if((&quot;macData&quot; in this) === false)
							return Promise.reject(&quot;Absent \&quot;macData\&quot; value, can not check PKCS#12 data integrity&quot;);
						//endregion
						
						//region Initial variables
						const hashAlgorithm = getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId);
						if((&quot;name&quot; in hashAlgorithm) === false)
							return Promise.reject(`Unsupported digest algorithm: ${this.macData.mac.digestAlgorithm.algorithmId}`);
						//endregion
						
						//region Call current crypto engine for verifying HMAC-based data stamp
						const engine = getEngine();
						
						sequence = sequence.then(() =&gt;
							engine.subtle.verifyDataStampedWithPassword({
								password: parameters.password,
								hashAlgorithm: hashAlgorithm.name,
								salt: this.macData.macSalt.valueBlock.valueHex,
								iterationCount: this.macData.iterations,
								contentToVerify: authSafeContent,
								signatureToVerify: this.macData.mac.digest.valueBlock.valueHex
							})
						);
						//endregion

						//region Verify HMAC signature
						sequence = sequence.then(
							result =&gt;
							{
								if(result === false)
									return Promise.reject(&quot;Integrity for the PKCS#12 data is broken!&quot;);
								
								return Promise.resolve();
							},
							error =&gt; Promise.reject(error)
						);
						//endregion
					}
					//endregion
				}
				break;
			//endregion 
			//region signedData 
			case &quot;1.2.840.113549.1.7.2&quot;:
				{
					//region Integrity based on signature using public key
					this.parsedValue.integrityMode = 1;
					//endregion
				
					//region Parse CMS Signed Data
					const cmsSigned = new SignedData({ schema: this.authSafe.content });
					//endregion
				
					//region Check that we do have OCTETSTRING as &quot;content&quot;
					if((&quot;eContent&quot; in cmsSigned.encapContentInfo) === false)
						return Promise.reject(&quot;Absent of attached data in \&quot;cmsSigned.encapContentInfo\&quot;&quot;);
				
					if((cmsSigned.encapContentInfo.eContent instanceof asn1js.OctetString) === false)
						return Promise.reject(&quot;Wrong type of \&quot;cmsSigned.encapContentInfo.eContent\&quot;&quot;);
					//endregion
				
					//region Create correct data block for verification
					let data = new ArrayBuffer(0);
				
					if(cmsSigned.encapContentInfo.eContent.idBlock.isConstructed === false)
						data = cmsSigned.encapContentInfo.eContent.valueBlock.valueHex;
					else
					{
						for(let i = 0; i &lt; cmsSigned.encapContentInfo.eContent.valueBlock.value.length; i++)
							data = utilConcatBuf(data, cmsSigned.encapContentInfo.eContent.valueBlock.value[i].valueBlock.valueHex);
					}
					//endregion
				
					//region Parse internal ASN.1 data
					const asn1 = asn1js.fromBER(data);
					if(asn1.offset === (-1))
						return Promise.reject(&quot;Error during parsing of ASN.1 data inside \&quot;this.authSafe.content\&quot;&quot;);
					//endregion
				
					//region Set &quot;authenticatedSafe&quot; value
					this.parsedValue.authenticatedSafe = new AuthenticatedSafe({ schema: asn1.result });
					//endregion
				
					//region Check integrity
					sequence = sequence.then(
						() =&gt; cmsSigned.verify({ signer: 0, checkChain: false })
					).then(
						result =&gt;
						{
							if(result === false)
								return Promise.reject(&quot;Integrity for the PKCS#12 data is broken!&quot;);
							
							return Promise.resolve();
						},
						error =&gt; Promise.reject(`Error during integrity verification: ${error}`)
					);
					//endregion
				}
				break;
			//endregion   
			//region default 
			default:
				return Promise.reject(`Incorrect value for &quot;this.authSafe.contentType&quot;: ${this.authSafe.contentType}`);
			//endregion 
		}
		//endregion 
		
		//region Return result of the function 
		return sequence.then(
			() =&gt; this,
			error =&gt; Promise.reject(`Error during parsing: ${error}`)
		);
		//endregion   
	}
	//**********************************************************************************
}
//**************************************************************************************
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
