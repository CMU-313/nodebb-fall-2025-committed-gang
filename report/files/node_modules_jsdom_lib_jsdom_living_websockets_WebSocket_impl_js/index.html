<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/living/websockets/WebSocket-impl.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/living/websockets/WebSocket-impl.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">329</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">51.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.23</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const nodeURL = require(&quot;url&quot;);

const DOMException = require(&quot;../generated/DOMException&quot;);
const { parseURL, serializeURL, serializeURLOrigin } = require(&quot;whatwg-url&quot;);
const WebSocket = require(&quot;ws&quot;);

const { setupForSimpleEventAccessors } = require(&quot;../helpers/create-event-accessor&quot;);
const { fireAnEvent } = require(&quot;../helpers/events&quot;);
const { isArrayBuffer } = require(&quot;../generated/utils&quot;);
const { copyToArrayBufferInNewRealm } = require(&quot;../helpers/binary-data&quot;);

const EventTargetImpl = require(&quot;../events/EventTarget-impl&quot;).implementation;

const idlUtils = require(&quot;../generated/utils&quot;);
const Blob = require(&quot;../generated/Blob&quot;);
const CloseEvent = require(&quot;../generated/CloseEvent&quot;);
const MessageEvent = require(&quot;../generated/MessageEvent&quot;);

const CONNECTING = 0;
const OPEN = 1;
const CLOSING = 2;
const CLOSED = 3;

const productions = {
  // https://tools.ietf.org/html/rfc7230#section-3.2.6
  token: /^[!#$%&amp;&#039;*+\-.^_`|~\dA-Za-z]+$/
};

const readyStateWSToDOM = [];
readyStateWSToDOM[WebSocket.CONNECTING] = CONNECTING;
readyStateWSToDOM[WebSocket.OPEN] = OPEN;
readyStateWSToDOM[WebSocket.CLOSING] = CLOSING;
readyStateWSToDOM[WebSocket.CLOSED] = CLOSED;

// https://tools.ietf.org/html/rfc6455#section-4.3
// See Sec-WebSocket-Protocol-Client, which is for the syntax of an entire header value. This function checks if a
// single header conforms to the rules.
function verifySecWebSocketProtocol(str) {
  return productions.token.test(str);
}

class PromiseQueues extends WeakMap {
  get(window) {
    const cur = super.get(window);
    return cur !== undefined ? cur : Promise.resolve();
  }
}

const openSockets = new WeakMap();
const openingQueues = new PromiseQueues();

class WebSocketImpl extends EventTargetImpl {
  constructor(globalObject, args, privateData) {
    super(globalObject, args, privateData);

    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);

    const url = args[0];
    let protocols = args[1] !== undefined ? args[1] : [];

    const urlRecord = parseURL(url);
    if (urlRecord === null) {
      throw DOMException.create(this._globalObject, [`The URL &#039;${url}&#039; is invalid.`, &quot;SyntaxError&quot;]);
    }
    if (urlRecord.scheme !== &quot;ws&quot; &amp;&amp; urlRecord.scheme !== &quot;wss&quot;) {
      throw DOMException.create(this._globalObject, [
        `The URL&#039;s scheme must be either &#039;ws&#039; or &#039;wss&#039;. &#039;${urlRecord.scheme}&#039; is not allowed.`,
        &quot;SyntaxError&quot;
      ]);
    }
    if (urlRecord.fragment !== null) {
      throw DOMException.create(this._globalObject, [
        `The URL contains a fragment identifier (&#039;${urlRecord.fragment}&#039;). Fragment identifiers ` +
        &quot;are not allowed in WebSocket URLs.&quot;,
        &quot;SyntaxError&quot;
      ]);
    }

    if (typeof protocols === &quot;string&quot;) {
      protocols = [protocols];
    }
    const protocolSet = new Set();
    for (const protocol of protocols) {
      if (!verifySecWebSocketProtocol(protocol)) {
        throw DOMException.create(this._globalObject, [`The subprotocol &#039;${protocol}&#039; is invalid.`, &quot;SyntaxError&quot;]);
      }
      const lowered = protocol.toLowerCase();
      if (protocolSet.has(lowered)) {
        throw DOMException.create(this._globalObject, [
          `The subprotocol &#039;${protocol}&#039; is duplicated.`,
          &quot;SyntaxError&quot;
        ]);
      }
      protocolSet.add(lowered);
    }

    this._urlRecord = urlRecord;
    this.url = serializeURL(urlRecord);
    const nodeParsedURL = nodeURL.parse(this.url);
    this.extensions = &quot;&quot;;

    this.binaryType = &quot;blob&quot;;

    this._ws = null;
    // Used when this._ws has not been initialized yet.
    this._readyState = CONNECTING;
    this._requiredToFail = false;
    this.bufferedAmount = 0;
    this._sendQueue = [];

    let openSocketsForWindow = openSockets.get(globalObject._globalProxy);
    if (openSocketsForWindow === undefined) {
      openSocketsForWindow = new Set();
      openSockets.set(globalObject._globalProxy, openSocketsForWindow);
    }
    openSocketsForWindow.add(this);

    openingQueues.set(this._ownerDocument, openingQueues.get(this._ownerDocument).then(() =&gt; new Promise(resolve =&gt; {
      // close() called before _ws has been initialized.
      if (this._requiredToFail) {
        resolve();
        this._readyState = CLOSED;
        this._onConnectionClosed(1006, &quot;&quot;);
        return;
      }

      this._ws = new WebSocket(this.url, protocols, {
        headers: {
          &quot;user-agent&quot;: globalObject.navigator.userAgent,
          &quot;cookie&quot;: this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),
          &quot;origin&quot;: globalObject._origin
        },
        rejectUnauthorized: globalObject._resourceLoader._strictSSL
      });
      this._ws.once(&quot;open&quot;, () =&gt; {
        resolve();
        this._onConnectionEstablished();
      });
      this._ws.on(&quot;message&quot;, this._onMessageReceived.bind(this));
      this._ws.once(&quot;close&quot;, (...closeArgs) =&gt; {
        resolve();
        this._onConnectionClosed(...closeArgs);
      });
      this._ws.once(&quot;upgrade&quot;, ({ headers }) =&gt; {
        if (Array.isArray(headers[&quot;set-cookie&quot;])) {
          for (const cookie of headers[&quot;set-cookie&quot;]) {
            this._ownerDocument._cookieJar.setCookieSync(
              cookie,
              nodeParsedURL,
              { http: true, ignoreError: true }
            );
          }
        } else if (headers[&quot;set-cookie&quot;] !== undefined) {
          this._ownerDocument._cookieJar.setCookieSync(
            headers[&quot;set-cookie&quot;],
            nodeParsedURL,
            { http: true, ignoreError: true }
          );
        }
      });
      this._ws.once(&quot;error&quot;, () =&gt; {
        // The exact error is passed into this callback, but it is ignored as we don&#039;t really care about it.
        resolve();
        this._requiredToFail = true;
        // Do not emit an error here, as that will be handled in _onConnectionClosed. ws always emits a close event
        // after errors.
      });
    })));
  }

  // https://html.spec.whatwg.org/multipage/web-sockets.html#make-disappear
  _makeDisappear() {
    this._eventListeners = Object.create(null);
    this._close(1001);
  }

  static cleanUpWindow(window) {
    const openSocketsForWindow = openSockets.get(window._globalProxy);
    if (openSocketsForWindow !== undefined) {
      for (const ws of openSocketsForWindow) {
        ws._makeDisappear();
      }
    }
  }

  // https://html.spec.whatwg.org/multipage/web-sockets.html#feedback-from-the-protocol
  _onConnectionEstablished() {
    // readyState is a getter.
    if (this._ws.extensions !== null) {
      // Right now, ws only supports one extension, permessage-deflate, without any parameters. This algorithm may need
      // to be more sophiscated as more extenions are supported.
      this.extensions = Object.keys(this._ws.extensions).join(&quot;, &quot;);
    }
    // protocol is a getter.
    fireAnEvent(&quot;open&quot;, this);
  }

  _onMessageReceived(data, isBinary) {
    if (this.readyState !== OPEN) {
      return;
    }
    let dataForEvent;
    if (!isBinary) {
      dataForEvent = data.toString();
    } else if (this.binaryType === &quot;arraybuffer&quot;) {
      if (isArrayBuffer(data)) {
        dataForEvent = data;
      } else if (Array.isArray(data)) {
        dataForEvent = copyToArrayBufferInNewRealm(Buffer.concat(data), this._globalObject);
      } else {
        dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);
      }
    } else { // this.binaryType === &quot;blob&quot;
      if (!Array.isArray(data)) {
        data = [data];
      }
      dataForEvent = Blob.create(this._globalObject, [data, { type: &quot;&quot; }]);
    }
    fireAnEvent(&quot;message&quot;, this, MessageEvent, {
      data: dataForEvent,
      origin: serializeURLOrigin(this._urlRecord)
    });
  }

  _onConnectionClosed(code, reason) {
    const openSocketsForWindow = openSockets.get(this._ownerDocument._defaultView);
    openSocketsForWindow.delete(this);

    const wasClean = !this._requiredToFail;
    if (this._requiredToFail) {
      fireAnEvent(&quot;error&quot;, this);
    }
    fireAnEvent(&quot;close&quot;, this, CloseEvent, {
      wasClean,
      code,
      reason: reason.toString()
    });
  }

  get readyState() {
    if (this._ws !== null) {
      return readyStateWSToDOM[this._ws.readyState];
    }
    return this._readyState;
  }

  get protocol() {
    if (this._ws === null) {
      return &quot;&quot;;
    }
    return this._ws.protocol;
  }

  close(code = undefined, reason = undefined) {
    if (code !== undefined &amp;&amp; code !== 1000 &amp;&amp; !(code &gt;= 3000 &amp;&amp; code &lt;= 4999)) {
      throw DOMException.create(this._globalObject, [
        `The code must be either 1000, or between 3000 and 4999. ${code} is neither.`,
        &quot;InvalidAccessError&quot;
      ]);
    }
    if (reason !== undefined &amp;&amp; Buffer.byteLength(reason, &quot;utf8&quot;) &gt; 123) {
      throw DOMException.create(this._globalObject, [
        &quot;The message must not be greater than 123 bytes.&quot;,
        &quot;SyntaxError&quot;
      ]);
    }
    this._close(code, reason);
  }

  _close(code = undefined, reason = undefined) {
    if (this.readyState === CONNECTING) {
      this._requiredToFail = true;
      if (this._ws !== null) {
        this._ws.terminate();
      } else {
        this._readyState = CLOSING;
      }
    } else if (this.readyState === OPEN) {
      this._ws.close(code, reason);
    }
  }

  send(data) {
    if (this.readyState === CONNECTING) {
      throw DOMException.create(this._globalObject, [&quot;Still in CONNECTING state.&quot;, &quot;InvalidStateError&quot;]);
    }
    if (this.readyState !== OPEN) {
      return;
    }
    if (Blob.isImpl(data)) {
      data = data._buffer;
    }
    let length;
    if (typeof data === &quot;string&quot;) {
      length = Buffer.byteLength(data, &quot;utf8&quot;);
    } else {
      length = data.byteLength;
    }
    this.bufferedAmount += length;
    this._sendQueue.push([data, length]);
    this._scheduleSend();
  }

  _actuallySend() {
    for (const [data, length] of this._sendQueue.splice(0)) {
      this._ws.send(data, { binary: typeof data !== &quot;string&quot; }, () =&gt; {
        this.bufferedAmount -= length;
      });
    }
  }

  _scheduleSend() {
    if (this._dequeueScheduled) {
      return;
    }
    this._dequeueScheduled = true;
    process.nextTick(() =&gt; {
      this._dequeueScheduled = false;
      this._actuallySend();
    });
  }
}

setupForSimpleEventAccessors(WebSocketImpl.prototype, [&quot;open&quot;, &quot;message&quot;, &quot;error&quot;, &quot;close&quot;]);

exports.implementation = WebSocketImpl;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
