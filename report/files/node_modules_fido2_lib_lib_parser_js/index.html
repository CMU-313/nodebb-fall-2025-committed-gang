<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/lib/parser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/lib/parser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">47.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">364</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">58.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const cbor = require(&quot;cbor&quot;);
const jwkToPem = require(&quot;jwk-to-pem&quot;);
const coseToJwk = require(&quot;cose-to-jwk&quot;);
var Fido2Lib;
const {
	coerceToBase64Url,
	coerceToArrayBuffer,
	checkOrigin,
	checkRpId,
	ab2str,
} = require(&quot;./utils&quot;);

// NOTE: throws if origin is https and has port 443
// use `new URL(originstr).origin` to create a properly formatted origin
function parseExpectations(exp) {
	if (typeof exp !== &quot;object&quot;) {
		throw new TypeError(&quot;expected &#039;expectations&#039; to be of type object, got &quot; + typeof exp);
	}

	var ret = new Map();

	// origin
	if (exp.origin) {
		if (typeof exp.origin !== &quot;string&quot;) {
			throw new TypeError(&quot;expected &#039;origin&#039; should be string, got &quot; + typeof exp.origin);
		}

		let origin = checkOrigin(exp.origin);
		ret.set(&quot;origin&quot;, origin);
	}

	// rpId
	if (exp.rpId) {
		if (typeof exp.rpId !== &quot;string&quot;) {
			throw new TypeError(&quot;expected &#039;rpId&#039; should be string, got &quot; + typeof exp.rpId);
		}

		let rpId = checkRpId(exp.rpId);
		ret.set(&quot;rpId&quot;, rpId);
	}

	// challenge
	if (exp.challenge) {
		var challenge = exp.challenge;
		challenge = coerceToBase64Url(challenge, &quot;expected challenge&quot;);
		ret.set(&quot;challenge&quot;, challenge);
	}

	// flags
	if (exp.flags) {
		var flags = exp.flags;

		if (Array.isArray(flags)) {
			flags = new Set(flags);
		}

		if (!(flags instanceof Set)) {
			throw new TypeError(&quot;expected flags to be an Array or a Set, got: &quot; + typeof flags);
		}

		ret.set(&quot;flags&quot;, flags);
	}

	// counter
	if (exp.prevCounter !== undefined) {
		if (typeof exp.prevCounter !== &quot;number&quot;) {
			throw new TypeError(&quot;expected &#039;prevCounter&#039; should be Number, got &quot; + typeof exp.prevCounter);
		}

		ret.set(&quot;prevCounter&quot;, exp.prevCounter);
	}

	// publicKey
	if (exp.publicKey) {
		if (typeof exp.publicKey !== &quot;string&quot;) {
			throw new TypeError(&quot;expected &#039;publicKey&#039; should be String, got &quot; + typeof exp.publicKey);
		}

		ret.set(&quot;publicKey&quot;, exp.publicKey);
	}

	// userHandle
	if (exp.userHandle !== undefined) {
		var userHandle = exp.userHandle;
		if (userHandle !== null &amp;&amp; userHandle !== &quot;&quot;) userHandle = coerceToBase64Url(userHandle, &quot;userHandle&quot;);
		ret.set(&quot;userHandle&quot;, userHandle);
	}


	// allowCredentials
	if (exp.allowCredentials !== undefined) {

		var allowCredentials = exp.allowCredentials;

		if (allowCredentials !== null &amp;&amp; !Array.isArray(allowCredentials)) {
			throw new TypeError(&quot;expected &#039;allowCredentials&#039; to be null or array, got &quot; + typeof allowCredentials);
		}

		for (const index in allowCredentials) {
			if (allowCredentials[index].id != null) {
				allowCredentials[index].id = coerceToArrayBuffer(allowCredentials[index].id, &quot;allowCredentials[&quot; + index + &quot;].id&quot;);
			}
		}
		ret.set(&quot;allowCredentials&quot;, allowCredentials);
	}

	return ret;
}

/**
 * Parses the clientData JSON byte stream into an Object
 * @param  {ArrayBuffer} clientDataJSON The ArrayBuffer containing the properly formatted JSON of the clientData object
 * @return {Object}                The parsed clientData object
 */
function parseClientResponse(msg) {
	if (typeof msg !== &quot;object&quot;) {
		throw new TypeError(&quot;expected msg to be Object&quot;);
	}

	if (msg.id &amp;&amp; !msg.rawId) {
		msg.rawId = msg.id;
	}
	var rawId = coerceToArrayBuffer(msg.rawId, &quot;rawId&quot;);

	if (typeof msg.response !== &quot;object&quot;) {
		throw new TypeError(&quot;expected response to be Object&quot;);
	}

	var clientDataJSON = coerceToArrayBuffer(msg.response.clientDataJSON, &quot;clientDataJSON&quot;);
	if (!(clientDataJSON instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;clientDataJSON&#039; to be ArrayBuffer&quot;);
	}

	// printHex(&quot;clientDataJSON&quot;, clientDataJSON);

	// convert to string
	var clientDataJson = ab2str(clientDataJSON);

	// parse JSON string
	var parsed;
	try {
		parsed = JSON.parse(clientDataJson);
	} catch (err) {
		throw new Error(&quot;couldn&#039;t parse clientDataJson: &quot; + err);
	}

	var ret = new Map([
		[&quot;challenge&quot;, parsed.challenge],
		[&quot;origin&quot;, parsed.origin],
		[&quot;type&quot;, parsed.type],
		[&quot;tokenBinding&quot;, parsed.tokenBinding],
		[&quot;rawClientDataJson&quot;, clientDataJSON],
		[&quot;rawId&quot;, rawId],
	]);

	return ret;
}

/**
 * @deprecated
 * Parses the CBOR attestation statement
 * @param  {ArrayBuffer} attestationObject The CBOR byte array representing the attestation statement
 * @return {Object}                   The Object containing all the attestation information
 * @see https://w3c.github.io/webauthn/#generating-an-attestation-object
 * @see  https://w3c.github.io/webauthn/#defined-attestation-formats
 */
function parseAttestationObject(attestationObject) {
	// update docs to say ArrayBuffer-ish object
	attestationObject = coerceToArrayBuffer(attestationObject, &quot;attestationObject&quot;);

	// parse attestation
	var parsed;
	try {
		parsed = cbor.decodeAllSync(Buffer.from(attestationObject));
	} catch (err) {
		throw new TypeError(&quot;couldn&#039;t parse attestationObject CBOR&quot;);
	}

	if (!Array.isArray(parsed) || typeof parsed[0] !== &quot;object&quot;) {
		throw new TypeError(&quot;invalid parsing of attestationObject CBOR&quot;);
	}
	parsed = parsed[0];

	if (typeof parsed.fmt !== &quot;string&quot;) {
		throw new Error(&quot;expected attestation CBOR to contain a &#039;fmt&#039; string&quot;);
	}

	if (typeof parsed.attStmt !== &quot;object&quot;) {
		throw new Error(&quot;expected attestation CBOR to contain a &#039;attStmt&#039; object&quot;);
	}

	if (!(parsed.authData instanceof Buffer)) {
		throw new Error(&quot;expected attestation CBOR to contain a &#039;authData&#039; byte sequence&quot;);
	}

	// have to require here to prevent circular dependency
	if (!Fido2Lib) Fido2Lib = require(&quot;../index&quot;).Fido2Lib; // eslint-disable-line global-require
	var ret = new Map([
		...Fido2Lib.parseAttestation(parsed.fmt, parsed.attStmt),
		// return raw buffer for future signature verification
		[&quot;rawAuthnrData&quot;, coerceToArrayBuffer(parsed.authData, &quot;authData&quot;)],
		// Added for compatibility with parseAuthnrAttestationResponse
		[&quot;transports&quot;, undefined],
		// parse authData
		...parseAuthenticatorData(parsed.authData),
	]);

	return ret;
}

function parseAuthnrAttestationResponse(msg) {

	if (typeof msg !== &quot;object&quot;) {
		throw new TypeError(&quot;expected msg to be Object&quot;);
	}

	if (typeof msg.response !== &quot;object&quot;) {
		throw new TypeError(&quot;expected response to be Object&quot;);
	}

	var attestationObject = msg.response.attestationObject;

	// update docs to say ArrayBuffer-ish object
	attestationObject = coerceToArrayBuffer(attestationObject, &quot;attestationObject&quot;);

	// parse attestation
	var parsed;
	try {
		parsed = cbor.decodeAllSync(Buffer.from(attestationObject));
	} catch (err) {
		throw new TypeError(&quot;couldn&#039;t parse attestationObject CBOR&quot;);
	}

	if (!Array.isArray(parsed) || typeof parsed[0] !== &quot;object&quot;) {
		throw new TypeError(&quot;invalid parsing of attestationObject CBOR&quot;);
	}
	parsed = parsed[0];

	if (typeof parsed.fmt !== &quot;string&quot;) {
		throw new Error(&quot;expected attestation CBOR to contain a &#039;fmt&#039; string&quot;);
	}

	if (typeof parsed.attStmt !== &quot;object&quot;) {
		throw new Error(&quot;expected attestation CBOR to contain a &#039;attStmt&#039; object&quot;);
	}

	if (!(parsed.authData instanceof Buffer)) {
		throw new Error(&quot;expected attestation CBOR to contain a &#039;authData&#039; byte sequence&quot;);
	}

	if (msg.transports != undefined &amp;&amp; !Array.isArray(msg.transports)) {
		throw new Error(&quot;expected transports to be &#039;null&#039; or &#039;array&lt;string&gt;&#039;&quot;);
	}

	// have to require here to prevent circular dependency
	if (!Fido2Lib) Fido2Lib = require(&quot;../index&quot;).Fido2Lib; // eslint-disable-line global-require
	var ret = new Map([
		...Fido2Lib.parseAttestation(parsed.fmt, parsed.attStmt),
		// return raw buffer for future signature verification
		[&quot;rawAuthnrData&quot;, coerceToArrayBuffer(parsed.authData, &quot;authData&quot;)],
		[&quot;transports&quot;, msg.transports],
		// parse authData
		...parseAuthenticatorData(parsed.authData),
	]);

	return ret;
}

function parseAuthenticatorData(authnrDataArrayBuffer) {
	// convert to ArrayBuffer
	authnrDataArrayBuffer = coerceToArrayBuffer(authnrDataArrayBuffer, &quot;authnrDataArrayBuffer&quot;);

	var ret = new Map();

	// console.log(&quot;authnrDataArrayBuffer&quot;, authnrDataArrayBuffer);
	// console.log(&quot;typeof authnrDataArrayBuffer&quot;, typeof authnrDataArrayBuffer);
	// printHex(&quot;authnrDataArrayBuffer&quot;, authnrDataArrayBuffer);

	var authnrDataBuf = new DataView(authnrDataArrayBuffer);
	var offset = 0;
	ret.set(&quot;rpIdHash&quot;, authnrDataBuf.buffer.slice(offset, offset + 32));
	offset += 32;
	var flags = authnrDataBuf.getUint8(offset);
	var flagsSet = new Set();
	ret.set(&quot;flags&quot;, flagsSet);
	if (flags &amp; 0x01) flagsSet.add(&quot;UP&quot;);
	if (flags &amp; 0x02) flagsSet.add(&quot;RFU1&quot;);
	if (flags &amp; 0x04) flagsSet.add(&quot;UV&quot;);
	if (flags &amp; 0x08) flagsSet.add(&quot;RFU3&quot;);
	if (flags &amp; 0x10) flagsSet.add(&quot;RFU4&quot;);
	if (flags &amp; 0x20) flagsSet.add(&quot;RFU5&quot;);
	if (flags &amp; 0x40) flagsSet.add(&quot;AT&quot;);
	if (flags &amp; 0x80) flagsSet.add(&quot;ED&quot;);
	offset++;
	ret.set(&quot;counter&quot;, authnrDataBuf.getUint32(offset, false));
	offset += 4;

	// see if there&#039;s more data to process
	var attestation = flagsSet.has(&quot;AT&quot;);
	var extensions = flagsSet.has(&quot;ED&quot;);

	if (attestation) {
		ret.set(&quot;aaguid&quot;, authnrDataBuf.buffer.slice(offset, offset + 16));
		offset += 16;
		var credIdLen = authnrDataBuf.getUint16(offset, false);
		ret.set(&quot;credIdLen&quot;, credIdLen);
		offset += 2;
		ret.set(&quot;credId&quot;, authnrDataBuf.buffer.slice(offset, offset + credIdLen));
		offset += credIdLen;
		var credentialPublicKeyCose = authnrDataBuf.buffer.slice(offset, authnrDataBuf.buffer.byteLength);
		ret.set(&quot;credentialPublicKeyCose&quot;, credentialPublicKeyCose);
		var jwk = coseToJwk(credentialPublicKeyCose);
		ret.set(&quot;credentialPublicKeyJwk&quot;, jwk);
		ret.set(&quot;credentialPublicKeyPem&quot;, jwkToPem(jwk));
	}

	// TODO: parse extensions
	if (extensions) {
		// extensionStart = offset
		throw new Error(&quot;authenticator extensions not supported&quot;);
	}

	return ret;
}

function parseAuthnrAssertionResponse(msg) {
	if (typeof msg !== &quot;object&quot;) {
		throw new TypeError(&quot;expected msg to be Object&quot;);
	}

	if (typeof msg.response !== &quot;object&quot;) {
		throw new TypeError(&quot;expected response to be Object&quot;);
	}

	let userHandle;
	if (msg.response.userHandle !== undefined) {
		userHandle = coerceToArrayBuffer(msg.response.userHandle, &quot;response.userHandle&quot;);
		if (userHandle.byteLength === 0) {
			userHandle = undefined;
		}
	}

	let sigAb = coerceToArrayBuffer(msg.response.signature, &quot;response.signature&quot;);
	let ret = new Map([
		[&quot;sig&quot;, sigAb],
		[&quot;userHandle&quot;, userHandle],
		[&quot;rawAuthnrData&quot;, coerceToArrayBuffer(msg.response.authenticatorData, &quot;response.authenticatorData&quot;)],
		...parseAuthenticatorData(msg.response.authenticatorData),
	]);

	return ret;
}

module.exports = {
	parseExpectations,
	parseClientResponse,
	parseAttestationObject,
	parseAuthenticatorData,
	parseAuthnrAssertionResponse,
	parseAuthnrAttestationResponse,
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
