<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/javascript/JavascriptModulesPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/javascript/JavascriptModulesPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.70</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1672</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const eslintScope = require(&quot;eslint-scope&quot;);
const { SyncWaterfallHook, SyncHook, SyncBailHook } = require(&quot;tapable&quot;);
const vm = require(&quot;vm&quot;);
const {
	ConcatSource,
	OriginalSource,
	PrefixSource,
	RawSource,
	CachedSource,
	ReplaceSource
} = require(&quot;webpack-sources&quot;);
const Compilation = require(&quot;../Compilation&quot;);
const { tryRunOrWebpackError } = require(&quot;../HookWebpackError&quot;);
const HotUpdateChunk = require(&quot;../HotUpdateChunk&quot;);
const InitFragment = require(&quot;../InitFragment&quot;);
const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC,
	JAVASCRIPT_MODULE_TYPE_ESM,
	WEBPACK_MODULE_TYPE_RUNTIME
} = require(&quot;../ModuleTypeConstants&quot;);
const NormalModule = require(&quot;../NormalModule&quot;);
const RuntimeGlobals = require(&quot;../RuntimeGlobals&quot;);
const Template = require(&quot;../Template&quot;);
const { last, someInIterable } = require(&quot;../util/IterableHelpers&quot;);
const StringXor = require(&quot;../util/StringXor&quot;);
const { compareModulesByIdOrIdentifier } = require(&quot;../util/comparators&quot;);
const {
	getPathInAst,
	getAllReferences,
	RESERVED_NAMES,
	findNewName,
	addScopeSymbols,
	getUsedNamesInScopeInfo
} = require(&quot;../util/concatenate&quot;);
const createHash = require(&quot;../util/createHash&quot;);
const nonNumericOnlyHash = require(&quot;../util/nonNumericOnlyHash&quot;);
const removeBOM = require(&quot;../util/removeBOM&quot;);
const { intersectRuntime } = require(&quot;../util/runtime&quot;);
const JavascriptGenerator = require(&quot;./JavascriptGenerator&quot;);
const JavascriptParser = require(&quot;./JavascriptParser&quot;);

/** @typedef {import(&quot;eslint-scope&quot;).Reference} Reference */
/** @typedef {import(&quot;eslint-scope&quot;).Scope} Scope */
/** @typedef {import(&quot;eslint-scope&quot;).Variable} Variable */
/** @typedef {import(&quot;estree&quot;).Program} Program */
/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).HashFunction} HashFunction */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).Output} OutputOptions */
/** @typedef {import(&quot;../Chunk&quot;)} Chunk */
/** @typedef {import(&quot;../ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;../CodeGenerationResults&quot;)} CodeGenerationResults */
/** @typedef {import(&quot;../Compilation&quot;).ChunkHashContext} ChunkHashContext */
/** @typedef {import(&quot;../Compilation&quot;).ExecuteModuleObject} ExecuteModuleObject */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../DependencyTemplates&quot;)} DependencyTemplates */
/** @typedef {import(&quot;../Entrypoint&quot;)} Entrypoint */
/** @typedef {import(&quot;../Module&quot;)} Module */
/** @typedef {import(&quot;../Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;../ModuleGraph&quot;)} ModuleGraph */
/** @typedef {import(&quot;../RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {import(&quot;../TemplatedPathPlugin&quot;).TemplatePath} TemplatePath */
/** @typedef {import(&quot;../WebpackError&quot;)} WebpackError */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).Range} Range */
/** @typedef {import(&quot;../util/Hash&quot;)} Hash */

/**
 * @param {Chunk} chunk a chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @returns {boolean} true, when a JS file is needed for this chunk
 */
const chunkHasJs = (chunk, chunkGraph) =&gt; {
	if (chunkGraph.getNumberOfEntryModules(chunk) &gt; 0) return true;

	return Boolean(
		chunkGraph.getChunkModulesIterableBySourceType(chunk, &quot;javascript&quot;)
	);
};

/**
 * @param {Chunk} chunk a chunk
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @returns {boolean} true, when a JS file is needed for this chunk
 */
const chunkHasRuntimeOrJs = (chunk, chunkGraph) =&gt; {
	if (
		chunkGraph.getChunkModulesIterableBySourceType(
			chunk,
			WEBPACK_MODULE_TYPE_RUNTIME
		)
	)
		return true;

	return Boolean(
		chunkGraph.getChunkModulesIterableBySourceType(chunk, &quot;javascript&quot;)
	);
};

/**
 * @param {Module} module a module
 * @param {string} code the code
 * @returns {string} generated code for the stack
 */
const printGeneratedCodeForStack = (module, code) =&gt; {
	const lines = code.split(&quot;\n&quot;);
	const n = `${lines.length}`.length;
	return `\n\nGenerated code for ${module.identifier()}\n${lines
		.map(
			/**
			 * @param {string} line the line
			 * @param {number} i the index
			 * @param {string[]} lines the lines
			 * @returns {string} the line with line number
			 */
			(line, i, lines) =&gt; {
				const iStr = `${i + 1}`;
				return `${&quot; &quot;.repeat(n - iStr.length)}${iStr} | ${line}`;
			}
		)
		.join(&quot;\n&quot;)}`;
};

/**
 * @typedef {object} RenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {boolean | undefined} strictMode rendering in strict context
 */

/**
 * @typedef {object} MainRenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {string} hash hash to be used for render call
 * @property {boolean | undefined} strictMode rendering in strict context
 */

/**
 * @typedef {object} ChunkRenderContext
 * @property {Chunk} chunk the chunk
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {InitFragment&lt;ChunkRenderContext&gt;[]} chunkInitFragments init fragments for the chunk
 * @property {boolean | undefined} strictMode rendering in strict context
 */

/**
 * @typedef {object} RenderBootstrapContext
 * @property {Chunk} chunk the chunk
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {string} hash hash to be used for render call
 */

/** @typedef {RenderContext &amp; { inlined: boolean }} StartupRenderContext */

/**
 * @typedef {object} CompilationHooks
 * @property {SyncWaterfallHook&lt;[Source, Module, ChunkRenderContext]&gt;} renderModuleContent
 * @property {SyncWaterfallHook&lt;[Source, Module, ChunkRenderContext]&gt;} renderModuleContainer
 * @property {SyncWaterfallHook&lt;[Source, Module, ChunkRenderContext]&gt;} renderModulePackage
 * @property {SyncWaterfallHook&lt;[Source, RenderContext]&gt;} renderChunk
 * @property {SyncWaterfallHook&lt;[Source, RenderContext]&gt;} renderMain
 * @property {SyncWaterfallHook&lt;[Source, RenderContext]&gt;} renderContent
 * @property {SyncWaterfallHook&lt;[Source, RenderContext]&gt;} render
 * @property {SyncWaterfallHook&lt;[Source, Module, StartupRenderContext]&gt;} renderStartup
 * @property {SyncWaterfallHook&lt;[string, RenderBootstrapContext]&gt;} renderRequire
 * @property {SyncBailHook&lt;[Module, RenderBootstrapContext], string | void&gt;} inlineInRuntimeBailout
 * @property {SyncBailHook&lt;[Module, RenderContext], string | void&gt;} embedInRuntimeBailout
 * @property {SyncBailHook&lt;[RenderContext], string | void&gt;} strictRuntimeBailout
 * @property {SyncHook&lt;[Chunk, Hash, ChunkHashContext]&gt;} chunkHash
 * @property {SyncBailHook&lt;[Chunk, RenderContext], boolean | void&gt;} useSourceMap
 */

/** @type {WeakMap&lt;Compilation, CompilationHooks&gt;} */
const compilationHooksMap = new WeakMap();

const PLUGIN_NAME = &quot;JavascriptModulesPlugin&quot;;

/** @typedef {{ header: string[], beforeStartup: string[], startup: string[], afterStartup: string[], allowInlineStartup: boolean }} Bootstrap */

class JavascriptModulesPlugin {
	/**
	 * @param {Compilation} compilation the compilation
	 * @returns {CompilationHooks} the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				&quot;The &#039;compilation&#039; argument must be an instance of Compilation&quot;
			);
		}
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				renderModuleContent: new SyncWaterfallHook([
					&quot;source&quot;,
					&quot;module&quot;,
					&quot;renderContext&quot;
				]),
				renderModuleContainer: new SyncWaterfallHook([
					&quot;source&quot;,
					&quot;module&quot;,
					&quot;renderContext&quot;
				]),
				renderModulePackage: new SyncWaterfallHook([
					&quot;source&quot;,
					&quot;module&quot;,
					&quot;renderContext&quot;
				]),
				render: new SyncWaterfallHook([&quot;source&quot;, &quot;renderContext&quot;]),
				renderContent: new SyncWaterfallHook([&quot;source&quot;, &quot;renderContext&quot;]),
				renderStartup: new SyncWaterfallHook([
					&quot;source&quot;,
					&quot;module&quot;,
					&quot;startupRenderContext&quot;
				]),
				renderChunk: new SyncWaterfallHook([&quot;source&quot;, &quot;renderContext&quot;]),
				renderMain: new SyncWaterfallHook([&quot;source&quot;, &quot;renderContext&quot;]),
				renderRequire: new SyncWaterfallHook([&quot;code&quot;, &quot;renderContext&quot;]),
				inlineInRuntimeBailout: new SyncBailHook([&quot;module&quot;, &quot;renderContext&quot;]),
				embedInRuntimeBailout: new SyncBailHook([&quot;module&quot;, &quot;renderContext&quot;]),
				strictRuntimeBailout: new SyncBailHook([&quot;renderContext&quot;]),
				chunkHash: new SyncHook([&quot;chunk&quot;, &quot;hash&quot;, &quot;context&quot;]),
				useSourceMap: new SyncBailHook([&quot;chunk&quot;, &quot;renderContext&quot;])
			};
			compilationHooksMap.set(compilation, hooks);
		}
		return hooks;
	}

	constructor(options = {}) {
		this.options = options;
		/** @type {WeakMap&lt;Source, { source: Source, needModule:boolean, needExports: boolean, needRequire: boolean, needThisAsExports: boolean, needStrict: boolean | undefined }&gt;} */
		this._moduleFactoryCache = new WeakMap();
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory }) =&gt; {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);

				for (const type of [
					JAVASCRIPT_MODULE_TYPE_AUTO,
					JAVASCRIPT_MODULE_TYPE_DYNAMIC,
					JAVASCRIPT_MODULE_TYPE_ESM
				]) {
					normalModuleFactory.hooks.createParser
						.for(type)
						.tap(PLUGIN_NAME, _options =&gt; {
							switch (type) {
								case JAVASCRIPT_MODULE_TYPE_AUTO: {
									return new JavascriptParser(&quot;auto&quot;);
								}
								case JAVASCRIPT_MODULE_TYPE_DYNAMIC: {
									return new JavascriptParser(&quot;script&quot;);
								}
								case JAVASCRIPT_MODULE_TYPE_ESM: {
									return new JavascriptParser(&quot;module&quot;);
								}
							}
						});
					normalModuleFactory.hooks.createGenerator
						.for(type)
						.tap(PLUGIN_NAME, () =&gt; new JavascriptGenerator());

					NormalModule.getCompilationHooks(compilation).processResult.tap(
						PLUGIN_NAME,
						(result, module) =&gt; {
							if (module.type === type) {
								const [source, ...rest] = result;

								return [removeBOM(source), ...rest];
							}

							return result;
						}
					);
				}

				compilation.hooks.renderManifest.tap(PLUGIN_NAME, (result, options) =&gt; {
					const {
						hash,
						chunk,
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						dependencyTemplates,
						outputOptions,
						codeGenerationResults
					} = options;

					const hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null;
					const filenameTemplate =
						JavascriptModulesPlugin.getChunkFilenameTemplate(
							chunk,
							outputOptions
						);

					let render;

					if (hotUpdateChunk) {
						render = () =&gt;
							this.renderChunk(
								{
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								},
								hooks
							);
					} else if (chunk.hasRuntime()) {
						if (!chunkHasRuntimeOrJs(chunk, chunkGraph)) {
							return result;
						}

						render = () =&gt;
							this.renderMain(
								{
									hash,
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								},
								hooks,
								compilation
							);
					} else {
						if (!chunkHasJs(chunk, chunkGraph)) {
							return result;
						}

						render = () =&gt;
							this.renderChunk(
								{
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								},
								hooks
							);
					}

					result.push({
						render,
						filenameTemplate,
						pathOptions: {
							hash,
							runtime: chunk.runtime,
							chunk,
							contentHashType: &quot;javascript&quot;
						},
						info: {
							javascriptModule: compilation.runtimeTemplate.isModule()
						},
						identifier: hotUpdateChunk
							? `hotupdatechunk${chunk.id}`
							: `chunk${chunk.id}`,
						hash: chunk.contentHash.javascript
					});

					return result;
				});
				compilation.hooks.chunkHash.tap(PLUGIN_NAME, (chunk, hash, context) =&gt; {
					hooks.chunkHash.call(chunk, hash, context);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: &quot;0000&quot;,
								chunk,
								codeGenerationResults: context.codeGenerationResults,
								chunkGraph: context.chunkGraph,
								moduleGraph: context.moduleGraph,
								runtimeTemplate: context.runtimeTemplate
							},
							hooks
						);
					}
				});
				compilation.hooks.contentHash.tap(PLUGIN_NAME, chunk =&gt; {
					const {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						}
					} = compilation;
					const hash = createHash(/** @type {HashFunction} */ (hashFunction));
					if (hashSalt) hash.update(hashSalt);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: &quot;0000&quot;,
								chunk,
								codeGenerationResults,
								chunkGraph: compilation.chunkGraph,
								moduleGraph: compilation.moduleGraph,
								runtimeTemplate: compilation.runtimeTemplate
							},
							hooks
						);
					} else {
						hash.update(`${chunk.id} `);
						hash.update(chunk.ids ? chunk.ids.join(&quot;,&quot;) : &quot;&quot;);
					}
					hooks.chunkHash.call(chunk, hash, {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate
					});
					const modules = chunkGraph.getChunkModulesIterableBySourceType(
						chunk,
						&quot;javascript&quot;
					);
					if (modules) {
						const xor = new StringXor();
						for (const m of modules) {
							xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
						}
						xor.updateHash(hash);
					}
					const runtimeModules = chunkGraph.getChunkModulesIterableBySourceType(
						chunk,
						WEBPACK_MODULE_TYPE_RUNTIME
					);
					if (runtimeModules) {
						const xor = new StringXor();
						for (const m of runtimeModules) {
							xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
						}
						xor.updateHash(hash);
					}
					const digest = /** @type {string} */ (hash.digest(hashDigest));
					chunk.contentHash.javascript = nonNumericOnlyHash(
						digest,
						/** @type {number} */
						(hashDigestLength)
					);
				});
				compilation.hooks.additionalTreeRuntimeRequirements.tap(
					PLUGIN_NAME,
					(chunk, set, { chunkGraph }) =&gt; {
						if (
							!set.has(RuntimeGlobals.startupNoDefault) &amp;&amp;
							chunkGraph.hasChunkEntryDependentChunks(chunk)
						) {
							set.add(RuntimeGlobals.onChunksLoaded);
							set.add(RuntimeGlobals.exports);
							set.add(RuntimeGlobals.require);
						}
					}
				);
				compilation.hooks.executeModule.tap(PLUGIN_NAME, (options, context) =&gt; {
					const source = options.codeGenerationResult.sources.get(&quot;javascript&quot;);
					if (source === undefined) return;
					const { module } = options;
					const code = source.source();

					const fn = vm.runInThisContext(
						`(function(${module.moduleArgument}, ${module.exportsArgument}, ${RuntimeGlobals.require}) {\n${code}\n/**/})`,
						{
							filename: module.identifier(),
							lineOffset: -1
						}
					);

					const moduleObject =
						/** @type {ExecuteModuleObject} */
						(options.moduleObject);

					try {
						fn.call(
							moduleObject.exports,
							moduleObject,
							moduleObject.exports,
							context.__webpack_require__
						);
					} catch (err) {
						/** @type {Error} */
						(err).stack += printGeneratedCodeForStack(
							options.module,
							/** @type {string} */ (code)
						);
						throw err;
					}
				});
				compilation.hooks.executeModule.tap(PLUGIN_NAME, (options, context) =&gt; {
					const source = options.codeGenerationResult.sources.get(&quot;runtime&quot;);
					if (source === undefined) return;
					let code = source.source();
					if (typeof code !== &quot;string&quot;) code = code.toString();

					const fn = vm.runInThisContext(
						`(function(${RuntimeGlobals.require}) {\n${code}\n/**/})`,
						{
							filename: options.module.identifier(),
							lineOffset: -1
						}
					);
					try {
						// eslint-disable-next-line no-useless-call
						fn.call(null, context.__webpack_require__);
					} catch (err) {
						/** @type {Error} */
						(err).stack += printGeneratedCodeForStack(options.module, code);
						throw err;
					}
				});
			}
		);
	}

	/**
	 * @param {Chunk} chunk chunk
	 * @param {OutputOptions} outputOptions output options
	 * @returns {TemplatePath} used filename template
	 */
	static getChunkFilenameTemplate(chunk, outputOptions) {
		if (chunk.filenameTemplate) {
			return chunk.filenameTemplate;
		} else if (chunk instanceof HotUpdateChunk) {
			return /** @type {TemplatePath} */ (outputOptions.hotUpdateChunkFilename);
		} else if (chunk.canBeInitial()) {
			return /** @type {TemplatePath} */ (outputOptions.filename);
		}
		return /** @type {TemplatePath} */ (outputOptions.chunkFilename);
	}

	/**
	 * @param {Module} module the rendered module
	 * @param {ChunkRenderContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @param {boolean} factory true: renders as factory method, false: pure module content
	 * @returns {Source | null} the newly generated source from rendering
	 */
	renderModule(module, renderContext, hooks, factory) {
		const {
			chunk,
			chunkGraph,
			runtimeTemplate,
			codeGenerationResults,
			strictMode
		} = renderContext;
		try {
			const codeGenResult = codeGenerationResults.get(module, chunk.runtime);
			const moduleSource = codeGenResult.sources.get(&quot;javascript&quot;);
			if (!moduleSource) return null;
			if (codeGenResult.data !== undefined) {
				const chunkInitFragments = codeGenResult.data.get(&quot;chunkInitFragments&quot;);
				if (chunkInitFragments) {
					for (const i of chunkInitFragments)
						renderContext.chunkInitFragments.push(i);
				}
			}
			const moduleSourcePostContent = tryRunOrWebpackError(
				() =&gt;
					hooks.renderModuleContent.call(moduleSource, module, renderContext),
				&quot;JavascriptModulesPlugin.getCompilationHooks().renderModuleContent&quot;
			);
			let moduleSourcePostContainer;
			if (factory) {
				const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
					module,
					chunk.runtime
				);
				const needModule = runtimeRequirements.has(RuntimeGlobals.module);
				const needExports = runtimeRequirements.has(RuntimeGlobals.exports);
				const needRequire =
					runtimeRequirements.has(RuntimeGlobals.require) ||
					runtimeRequirements.has(RuntimeGlobals.requireScope);
				const needThisAsExports = runtimeRequirements.has(
					RuntimeGlobals.thisAsExports
				);
				const needStrict =
					/** @type {BuildInfo} */
					(module.buildInfo).strict &amp;&amp; !strictMode;
				const cacheEntry = this._moduleFactoryCache.get(
					moduleSourcePostContent
				);
				let source;
				if (
					cacheEntry &amp;&amp;
					cacheEntry.needModule === needModule &amp;&amp;
					cacheEntry.needExports === needExports &amp;&amp;
					cacheEntry.needRequire === needRequire &amp;&amp;
					cacheEntry.needThisAsExports === needThisAsExports &amp;&amp;
					cacheEntry.needStrict === needStrict
				) {
					source = cacheEntry.source;
				} else {
					const factorySource = new ConcatSource();
					const args = [];
					if (needExports || needRequire || needModule)
						args.push(
							needModule
								? module.moduleArgument
								: `__unused_webpack_${module.moduleArgument}`
						);
					if (needExports || needRequire)
						args.push(
							needExports
								? module.exportsArgument
								: `__unused_webpack_${module.exportsArgument}`
						);
					if (needRequire) args.push(RuntimeGlobals.require);
					if (!needThisAsExports &amp;&amp; runtimeTemplate.supportsArrowFunction()) {
						factorySource.add(`/***/ ((${args.join(&quot;, &quot;)}) =&gt; {\n\n`);
					} else {
						factorySource.add(`/***/ (function(${args.join(&quot;, &quot;)}) {\n\n`);
					}
					if (needStrict) {
						factorySource.add(&#039;&quot;use strict&quot;;\n&#039;);
					}
					factorySource.add(moduleSourcePostContent);
					factorySource.add(&quot;\n\n/***/ })&quot;);
					source = new CachedSource(factorySource);
					this._moduleFactoryCache.set(moduleSourcePostContent, {
						source,
						needModule,
						needExports,
						needRequire,
						needThisAsExports,
						needStrict
					});
				}
				moduleSourcePostContainer = tryRunOrWebpackError(
					() =&gt; hooks.renderModuleContainer.call(source, module, renderContext),
					&quot;JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer&quot;
				);
			} else {
				moduleSourcePostContainer = moduleSourcePostContent;
			}
			return tryRunOrWebpackError(
				() =&gt;
					hooks.renderModulePackage.call(
						moduleSourcePostContainer,
						module,
						renderContext
					),
				&quot;JavascriptModulesPlugin.getCompilationHooks().renderModulePackage&quot;
			);
		} catch (err) {
			/** @type {WebpackError} */
			(err).module = module;
			throw err;
		}
	}

	/**
	 * @param {RenderContext} renderContext the render context
	 * @param {CompilationHooks} hooks hooks
	 * @returns {Source} the rendered source
	 */
	renderChunk(renderContext, hooks) {
		const { chunk, chunkGraph } = renderContext;
		const modules = chunkGraph.getOrderedChunkModulesIterableBySourceType(
			chunk,
			&quot;javascript&quot;,
			compareModulesByIdOrIdentifier(chunkGraph)
		);
		const allModules = modules ? Array.from(modules) : [];
		let strictHeader;
		let allStrict = renderContext.strictMode;
		if (
			!allStrict &amp;&amp;
			allModules.every(m =&gt; /** @type {BuildInfo} */ (m.buildInfo).strict)
		) {
			const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
			strictHeader = strictBailout
				? `// runtime can&#039;t be in strict mode because ${strictBailout}.\n`
				: &#039;&quot;use strict&quot;;\n&#039;;
			if (!strictBailout) allStrict = true;
		}
		/** @type {ChunkRenderContext} */
		const chunkRenderContext = {
			...renderContext,
			chunkInitFragments: [],
			strictMode: allStrict
		};
		const moduleSources =
			Template.renderChunkModules(chunkRenderContext, allModules, module =&gt;
				this.renderModule(module, chunkRenderContext, hooks, true)
			) || new RawSource(&quot;{}&quot;);
		let source = tryRunOrWebpackError(
			() =&gt; hooks.renderChunk.call(moduleSources, chunkRenderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().renderChunk&quot;
		);
		source = tryRunOrWebpackError(
			() =&gt; hooks.renderContent.call(source, chunkRenderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().renderContent&quot;
		);
		if (!source) {
			throw new Error(
				&quot;JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something&quot;
			);
		}
		source = InitFragment.addToSource(
			source,
			chunkRenderContext.chunkInitFragments,
			chunkRenderContext
		);
		source = tryRunOrWebpackError(
			() =&gt; hooks.render.call(source, chunkRenderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().render&quot;
		);
		if (!source) {
			throw new Error(
				&quot;JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something&quot;
			);
		}
		chunk.rendered = true;
		return strictHeader
			? new ConcatSource(strictHeader, source, &quot;;&quot;)
			: renderContext.runtimeTemplate.isModule()
				? source
				: new ConcatSource(source, &quot;;&quot;);
	}

	/**
	 * @param {MainRenderContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @param {Compilation} compilation the compilation
	 * @returns {Source} the newly generated source from rendering
	 */
	renderMain(renderContext, hooks, compilation) {
		const { chunk, chunkGraph, runtimeTemplate } = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);
		const iife = runtimeTemplate.isIIFE();

		const bootstrap = this.renderBootstrap(renderContext, hooks);
		const useSourceMap = hooks.useSourceMap.call(chunk, renderContext);

		const allModules = Array.from(
			chunkGraph.getOrderedChunkModulesIterableBySourceType(
				chunk,
				&quot;javascript&quot;,
				compareModulesByIdOrIdentifier(chunkGraph)
			) || []
		);

		const hasEntryModules = chunkGraph.getNumberOfEntryModules(chunk) &gt; 0;
		/** @type {Set&lt;Module&gt; | undefined} */
		let inlinedModules;
		if (bootstrap.allowInlineStartup &amp;&amp; hasEntryModules) {
			inlinedModules = new Set(chunkGraph.getChunkEntryModulesIterable(chunk));
		}

		const source = new ConcatSource();
		let prefix;
		if (iife) {
			if (runtimeTemplate.supportsArrowFunction()) {
				source.add(&quot;/******/ (() =&gt; { // webpackBootstrap\n&quot;);
			} else {
				source.add(&quot;/******/ (function() { // webpackBootstrap\n&quot;);
			}
			prefix = &quot;/******/ \t&quot;;
		} else {
			prefix = &quot;/******/ &quot;;
		}
		let allStrict = renderContext.strictMode;
		if (
			!allStrict &amp;&amp;
			allModules.every(m =&gt; /** @type {BuildInfo} */ (m.buildInfo).strict)
		) {
			const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
			if (strictBailout) {
				source.add(
					`${
						prefix
					}// runtime can&#039;t be in strict mode because ${strictBailout}.\n`
				);
			} else {
				allStrict = true;
				source.add(`${prefix}&quot;use strict&quot;;\n`);
			}
		}

		/** @type {ChunkRenderContext} */
		const chunkRenderContext = {
			...renderContext,
			chunkInitFragments: [],
			strictMode: allStrict
		};

		const chunkModules = Template.renderChunkModules(
			chunkRenderContext,
			inlinedModules
				? allModules.filter(
						m =&gt; !(/** @type {Set&lt;Module&gt;} */ (inlinedModules).has(m))
					)
				: allModules,
			module =&gt; this.renderModule(module, chunkRenderContext, hooks, true),
			prefix
		);
		if (
			chunkModules ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactories) ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly) ||
			runtimeRequirements.has(RuntimeGlobals.require)
		) {
			source.add(`${prefix}var __webpack_modules__ = (`);
			source.add(chunkModules || &quot;{}&quot;);
			source.add(&quot;);\n&quot;);
			source.add(
				&quot;/************************************************************************/\n&quot;
			);
		}

		if (bootstrap.header.length &gt; 0) {
			const header = `${Template.asString(bootstrap.header)}\n`;
			source.add(
				new PrefixSource(
					prefix,
					useSourceMap
						? new OriginalSource(header, &quot;webpack/bootstrap&quot;)
						: new RawSource(header)
				)
			);
			source.add(
				&quot;/************************************************************************/\n&quot;
			);
		}

		const runtimeModules =
			renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);

		if (runtimeModules.length &gt; 0) {
			source.add(
				new PrefixSource(
					prefix,
					Template.renderRuntimeModules(runtimeModules, chunkRenderContext)
				)
			);
			source.add(
				&quot;/************************************************************************/\n&quot;
			);
			// runtimeRuntimeModules calls codeGeneration
			for (const module of runtimeModules) {
				compilation.codeGeneratedModules.add(module);
			}
		}
		if (inlinedModules) {
			if (bootstrap.beforeStartup.length &gt; 0) {
				const beforeStartup = `${Template.asString(bootstrap.beforeStartup)}\n`;
				source.add(
					new PrefixSource(
						prefix,
						useSourceMap
							? new OriginalSource(beforeStartup, &quot;webpack/before-startup&quot;)
							: new RawSource(beforeStartup)
					)
				);
			}
			const lastInlinedModule = /** @type {Module} */ (last(inlinedModules));
			const startupSource = new ConcatSource();

			if (runtimeRequirements.has(RuntimeGlobals.exports)) {
				startupSource.add(`var ${RuntimeGlobals.exports} = {};\n`);
			}

			const avoidEntryIife = compilation.options.optimization.avoidEntryIife;
			/** @type {Map&lt;Module, Source&gt; | false} */
			let renamedInlinedModule = false;
			if (avoidEntryIife) {
				renamedInlinedModule = this.getRenamedInlineModule(
					allModules,
					renderContext,
					inlinedModules,
					chunkRenderContext,
					hooks,
					allStrict,
					Boolean(chunkModules)
				);
			}

			for (const m of inlinedModules) {
				const renderedModule = renamedInlinedModule
					? renamedInlinedModule.get(m)
					: this.renderModule(m, chunkRenderContext, hooks, false);

				if (renderedModule) {
					const innerStrict =
						!allStrict &amp;&amp; /** @type {BuildInfo} */ (m.buildInfo).strict;
					const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
						m,
						chunk.runtime
					);
					const exports = runtimeRequirements.has(RuntimeGlobals.exports);
					const webpackExports =
						exports &amp;&amp; m.exportsArgument === RuntimeGlobals.exports;
					const iife = innerStrict
						? &quot;it needs to be in strict mode.&quot;
						: inlinedModules.size &gt; 1
							? // TODO check globals and top-level declarations of other entries and chunk modules
								// to make a better decision
								&quot;it needs to be isolated against other entry modules.&quot;
							: chunkModules &amp;&amp; !renamedInlinedModule
								? &quot;it needs to be isolated against other modules in the chunk.&quot;
								: exports &amp;&amp; !webpackExports
									? `it uses a non-standard name for the exports (${m.exportsArgument}).`
									: hooks.embedInRuntimeBailout.call(m, renderContext);
					let footer;
					if (iife !== undefined) {
						startupSource.add(
							`// This entry needs to be wrapped in an IIFE because ${iife}\n`
						);
						const arrow = runtimeTemplate.supportsArrowFunction();
						if (arrow) {
							startupSource.add(&quot;(() =&gt; {\n&quot;);
							footer = &quot;\n})();\n\n&quot;;
						} else {
							startupSource.add(&quot;!function() {\n&quot;);
							footer = &quot;\n}();\n&quot;;
						}
						if (innerStrict) startupSource.add(&#039;&quot;use strict&quot;;\n&#039;);
					} else {
						footer = &quot;\n&quot;;
					}
					if (exports) {
						if (m !== lastInlinedModule)
							startupSource.add(`var ${m.exportsArgument} = {};\n`);
						else if (m.exportsArgument !== RuntimeGlobals.exports)
							startupSource.add(
								`var ${m.exportsArgument} = ${RuntimeGlobals.exports};\n`
							);
					}
					startupSource.add(renderedModule);
					startupSource.add(footer);
				}
			}
			if (runtimeRequirements.has(RuntimeGlobals.onChunksLoaded)) {
				startupSource.add(
					`${RuntimeGlobals.exports} = ${RuntimeGlobals.onChunksLoaded}(${RuntimeGlobals.exports});\n`
				);
			}
			source.add(
				hooks.renderStartup.call(startupSource, lastInlinedModule, {
					...renderContext,
					inlined: true
				})
			);
			if (bootstrap.afterStartup.length &gt; 0) {
				const afterStartup = `${Template.asString(bootstrap.afterStartup)}\n`;
				source.add(
					new PrefixSource(
						prefix,
						useSourceMap
							? new OriginalSource(afterStartup, &quot;webpack/after-startup&quot;)
							: new RawSource(afterStartup)
					)
				);
			}
		} else {
			const lastEntryModule =
				/** @type {Module} */
				(last(chunkGraph.getChunkEntryModulesIterable(chunk)));
			/** @type {(content: string[], name: string) =&gt; Source} */
			const toSource = useSourceMap
				? (content, name) =&gt;
						new OriginalSource(Template.asString(content), name)
				: content =&gt; new RawSource(Template.asString(content));
			source.add(
				new PrefixSource(
					prefix,
					new ConcatSource(
						toSource(bootstrap.beforeStartup, &quot;webpack/before-startup&quot;),
						&quot;\n&quot;,
						hooks.renderStartup.call(
							toSource(bootstrap.startup.concat(&quot;&quot;), &quot;webpack/startup&quot;),
							lastEntryModule,
							{
								...renderContext,
								inlined: false
							}
						),
						toSource(bootstrap.afterStartup, &quot;webpack/after-startup&quot;),
						&quot;\n&quot;
					)
				)
			);
		}
		if (
			hasEntryModules &amp;&amp;
			runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)
		) {
			source.add(`${prefix}return ${RuntimeGlobals.exports};\n`);
		}
		if (iife) {
			source.add(&quot;/******/ })()\n&quot;);
		}

		/** @type {Source} */
		let finalSource = tryRunOrWebpackError(
			() =&gt; hooks.renderMain.call(source, renderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().renderMain&quot;
		);
		if (!finalSource) {
			throw new Error(
				&quot;JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderMain plugins should return something&quot;
			);
		}
		finalSource = tryRunOrWebpackError(
			() =&gt; hooks.renderContent.call(finalSource, renderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().renderContent&quot;
		);
		if (!finalSource) {
			throw new Error(
				&quot;JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something&quot;
			);
		}

		finalSource = InitFragment.addToSource(
			finalSource,
			chunkRenderContext.chunkInitFragments,
			chunkRenderContext
		);
		finalSource = tryRunOrWebpackError(
			() =&gt; hooks.render.call(finalSource, renderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().render&quot;
		);
		if (!finalSource) {
			throw new Error(
				&quot;JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something&quot;
			);
		}
		chunk.rendered = true;
		return iife ? new ConcatSource(finalSource, &quot;;&quot;) : finalSource;
	}

	/**
	 * @param {Hash} hash the hash to be updated
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 */
	updateHashWithBootstrap(hash, renderContext, hooks) {
		const bootstrap = this.renderBootstrap(renderContext, hooks);
		for (const _k of Object.keys(bootstrap)) {
			const key = /** @type {keyof Bootstrap} */ (_k);
			hash.update(key);
			if (Array.isArray(bootstrap[key])) {
				for (const line of bootstrap[key]) {
					hash.update(line);
				}
			} else {
				hash.update(JSON.stringify(bootstrap[key]));
			}
		}
	}

	/**
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @returns {Bootstrap} the generated source of the bootstrap code
	 */
	renderBootstrap(renderContext, hooks) {
		const {
			chunkGraph,
			codeGenerationResults,
			moduleGraph,
			chunk,
			runtimeTemplate
		} = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);

		const requireFunction = runtimeRequirements.has(RuntimeGlobals.require);
		const moduleCache = runtimeRequirements.has(RuntimeGlobals.moduleCache);
		const moduleFactories = runtimeRequirements.has(
			RuntimeGlobals.moduleFactories
		);
		const moduleUsed = runtimeRequirements.has(RuntimeGlobals.module);
		const requireScopeUsed = runtimeRequirements.has(
			RuntimeGlobals.requireScope
		);
		const interceptModuleExecution = runtimeRequirements.has(
			RuntimeGlobals.interceptModuleExecution
		);

		const useRequire =
			requireFunction || interceptModuleExecution || moduleUsed;

		/**
		 * @type {{startup: string[], beforeStartup: string[], header: string[], afterStartup: string[], allowInlineStartup: boolean}}
		 */
		const result = {
			header: [],
			beforeStartup: [],
			startup: [],
			afterStartup: [],
			allowInlineStartup: true
		};

		const { header: buf, startup, beforeStartup, afterStartup } = result;

		if (result.allowInlineStartup &amp;&amp; moduleFactories) {
			startup.push(
				&quot;// module factories are used so entry inlining is disabled&quot;
			);
			result.allowInlineStartup = false;
		}
		if (result.allowInlineStartup &amp;&amp; moduleCache) {
			startup.push(&quot;// module cache are used so entry inlining is disabled&quot;);
			result.allowInlineStartup = false;
		}
		if (result.allowInlineStartup &amp;&amp; interceptModuleExecution) {
			startup.push(
				&quot;// module execution is intercepted so entry inlining is disabled&quot;
			);
			result.allowInlineStartup = false;
		}

		if (useRequire || moduleCache) {
			buf.push(&quot;// The module cache&quot;);
			buf.push(&quot;var __webpack_module_cache__ = {};&quot;);
			buf.push(&quot;&quot;);
		}

		if (useRequire) {
			buf.push(&quot;// The require function&quot;);
			buf.push(`function ${RuntimeGlobals.require}(moduleId) {`);
			buf.push(Template.indent(this.renderRequire(renderContext, hooks)));
			buf.push(&quot;}&quot;);
			buf.push(&quot;&quot;);
		} else if (runtimeRequirements.has(RuntimeGlobals.requireScope)) {
			buf.push(&quot;// The require scope&quot;);
			buf.push(`var ${RuntimeGlobals.require} = {};`);
			buf.push(&quot;&quot;);
		}

		if (
			moduleFactories ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly)
		) {
			buf.push(&quot;// expose the modules object (__webpack_modules__)&quot;);
			buf.push(`${RuntimeGlobals.moduleFactories} = __webpack_modules__;`);
			buf.push(&quot;&quot;);
		}

		if (moduleCache) {
			buf.push(&quot;// expose the module cache&quot;);
			buf.push(`${RuntimeGlobals.moduleCache} = __webpack_module_cache__;`);
			buf.push(&quot;&quot;);
		}

		if (interceptModuleExecution) {
			buf.push(&quot;// expose the module execution interceptor&quot;);
			buf.push(`${RuntimeGlobals.interceptModuleExecution} = [];`);
			buf.push(&quot;&quot;);
		}

		if (!runtimeRequirements.has(RuntimeGlobals.startupNoDefault)) {
			if (chunkGraph.getNumberOfEntryModules(chunk) &gt; 0) {
				/** @type {string[]} */
				const buf2 = [];
				const runtimeRequirements =
					chunkGraph.getTreeRuntimeRequirements(chunk);
				buf2.push(&quot;// Load entry module and return exports&quot;);
				let i = chunkGraph.getNumberOfEntryModules(chunk);
				for (const [
					entryModule,
					entrypoint
				] of chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)) {
					if (!chunkGraph.getModuleSourceTypes(entryModule).has(&quot;javascript&quot;)) {
						i--;
						continue;
					}
					const chunks =
						/** @type {Entrypoint} */
						(entrypoint).chunks.filter(c =&gt; c !== chunk);
					if (result.allowInlineStartup &amp;&amp; chunks.length &gt; 0) {
						buf2.push(
							&quot;// This entry module depends on other loaded chunks and execution need to be delayed&quot;
						);
						result.allowInlineStartup = false;
					}
					if (
						result.allowInlineStartup &amp;&amp;
						someInIterable(
							moduleGraph.getIncomingConnectionsByOriginModule(entryModule),
							([originModule, connections]) =&gt;
								originModule &amp;&amp;
								connections.some(c =&gt; c.isTargetActive(chunk.runtime)) &amp;&amp;
								someInIterable(
									chunkGraph.getModuleRuntimes(originModule),
									runtime =&gt;
										intersectRuntime(runtime, chunk.runtime) !== undefined
								)
						)
					) {
						buf2.push(
							&quot;// This entry module is referenced by other modules so it can&#039;t be inlined&quot;
						);
						result.allowInlineStartup = false;
					}

					let data;
					if (codeGenerationResults.has(entryModule, chunk.runtime)) {
						const result = codeGenerationResults.get(
							entryModule,
							chunk.runtime
						);
						data = result.data;
					}
					if (
						result.allowInlineStartup &amp;&amp;
						(!data || !data.get(&quot;topLevelDeclarations&quot;)) &amp;&amp;
						(!entryModule.buildInfo ||
							!entryModule.buildInfo.topLevelDeclarations)
					) {
						buf2.push(
							&quot;// This entry module doesn&#039;t tell about it&#039;s top-level declarations so it can&#039;t be inlined&quot;
						);
						result.allowInlineStartup = false;
					}
					if (result.allowInlineStartup) {
						const bailout = hooks.inlineInRuntimeBailout.call(
							entryModule,
							renderContext
						);
						if (bailout !== undefined) {
							buf2.push(
								`// This entry module can&#039;t be inlined because ${bailout}`
							);
							result.allowInlineStartup = false;
						}
					}
					i--;
					const moduleId = chunkGraph.getModuleId(entryModule);
					const entryRuntimeRequirements =
						chunkGraph.getModuleRuntimeRequirements(entryModule, chunk.runtime);
					let moduleIdExpr = JSON.stringify(moduleId);
					if (runtimeRequirements.has(RuntimeGlobals.entryModuleId)) {
						moduleIdExpr = `${RuntimeGlobals.entryModuleId} = ${moduleIdExpr}`;
					}
					if (
						result.allowInlineStartup &amp;&amp;
						entryRuntimeRequirements.has(RuntimeGlobals.module)
					) {
						result.allowInlineStartup = false;
						buf2.push(
							&quot;// This entry module used &#039;module&#039; so it can&#039;t be inlined&quot;
						);
					}
					if (chunks.length &gt; 0) {
						buf2.push(
							`${i === 0 ? `var ${RuntimeGlobals.exports} = ` : &quot;&quot;}${
								RuntimeGlobals.onChunksLoaded
							}(undefined, ${JSON.stringify(
								chunks.map(c =&gt; c.id)
							)}, ${runtimeTemplate.returningFunction(
								`${RuntimeGlobals.require}(${moduleIdExpr})`
							)})`
						);
					} else if (useRequire) {
						buf2.push(
							`${i === 0 ? `var ${RuntimeGlobals.exports} = ` : &quot;&quot;}${
								RuntimeGlobals.require
							}(${moduleIdExpr});`
						);
					} else {
						if (i === 0) buf2.push(`var ${RuntimeGlobals.exports} = {};`);
						if (requireScopeUsed) {
							buf2.push(
								`__webpack_modules__[${moduleIdExpr}](0, ${
									i === 0 ? RuntimeGlobals.exports : &quot;{}&quot;
								}, ${RuntimeGlobals.require});`
							);
						} else if (entryRuntimeRequirements.has(RuntimeGlobals.exports)) {
							buf2.push(
								`__webpack_modules__[${moduleIdExpr}](0, ${
									i === 0 ? RuntimeGlobals.exports : &quot;{}&quot;
								});`
							);
						} else {
							buf2.push(`__webpack_modules__[${moduleIdExpr}]();`);
						}
					}
				}
				if (runtimeRequirements.has(RuntimeGlobals.onChunksLoaded)) {
					buf2.push(
						`${RuntimeGlobals.exports} = ${RuntimeGlobals.onChunksLoaded}(${RuntimeGlobals.exports});`
					);
				}
				if (
					runtimeRequirements.has(RuntimeGlobals.startup) ||
					(runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) &amp;&amp;
						runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter))
				) {
					result.allowInlineStartup = false;
					buf.push(&quot;// the startup function&quot;);
					buf.push(
						`${RuntimeGlobals.startup} = ${runtimeTemplate.basicFunction(&quot;&quot;, [
							...buf2,
							`return ${RuntimeGlobals.exports};`
						])};`
					);
					buf.push(&quot;&quot;);
					startup.push(&quot;// run startup&quot;);
					startup.push(
						`var ${RuntimeGlobals.exports} = ${RuntimeGlobals.startup}();`
					);
				} else if (runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore)) {
					buf.push(&quot;// the startup function&quot;);
					buf.push(
						`${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`
					);
					beforeStartup.push(&quot;// run runtime startup&quot;);
					beforeStartup.push(`${RuntimeGlobals.startup}();`);
					startup.push(&quot;// startup&quot;);
					startup.push(Template.asString(buf2));
				} else if (runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)) {
					buf.push(&quot;// the startup function&quot;);
					buf.push(
						`${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`
					);
					startup.push(&quot;// startup&quot;);
					startup.push(Template.asString(buf2));
					afterStartup.push(&quot;// run runtime startup&quot;);
					afterStartup.push(`${RuntimeGlobals.startup}();`);
				} else {
					startup.push(&quot;// startup&quot;);
					startup.push(Template.asString(buf2));
				}
			} else if (
				runtimeRequirements.has(RuntimeGlobals.startup) ||
				runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) ||
				runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)
			) {
				buf.push(
					&quot;// the startup function&quot;,
					&quot;// It&#039;s empty as no entry modules are in this chunk&quot;,
					`${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`,
					&quot;&quot;
				);
			}
		} else if (
			runtimeRequirements.has(RuntimeGlobals.startup) ||
			runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) ||
			runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)
		) {
			result.allowInlineStartup = false;
			buf.push(
				&quot;// the startup function&quot;,
				&quot;// It&#039;s empty as some runtime module handles the default behavior&quot;,
				`${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`
			);
			startup.push(&quot;// run startup&quot;);
			startup.push(
				`var ${RuntimeGlobals.exports} = ${RuntimeGlobals.startup}();`
			);
		}
		return result;
	}

	/**
	 * @param {RenderBootstrapContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @returns {string} the generated source of the require function
	 */
	renderRequire(renderContext, hooks) {
		const {
			chunk,
			chunkGraph,
			runtimeTemplate: { outputOptions }
		} = renderContext;
		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);
		const moduleExecution = runtimeRequirements.has(
			RuntimeGlobals.interceptModuleExecution
		)
			? Template.asString([
					`var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: ${RuntimeGlobals.require} };`,
					`${RuntimeGlobals.interceptModuleExecution}.forEach(function(handler) { handler(execOptions); });`,
					&quot;module = execOptions.module;&quot;,
					&quot;execOptions.factory.call(module.exports, module, module.exports, execOptions.require);&quot;
				])
			: runtimeRequirements.has(RuntimeGlobals.thisAsExports)
				? Template.asString([
						`__webpack_modules__[moduleId].call(module.exports, module, module.exports, ${RuntimeGlobals.require});`
					])
				: Template.asString([
						`__webpack_modules__[moduleId](module, module.exports, ${RuntimeGlobals.require});`
					]);
		const needModuleId = runtimeRequirements.has(RuntimeGlobals.moduleId);
		const needModuleLoaded = runtimeRequirements.has(
			RuntimeGlobals.moduleLoaded
		);
		const content = Template.asString([
			&quot;// Check if module is in cache&quot;,
			&quot;var cachedModule = __webpack_module_cache__[moduleId];&quot;,
			&quot;if (cachedModule !== undefined) {&quot;,
			outputOptions.strictModuleErrorHandling
				? Template.indent([
						&quot;if (cachedModule.error !== undefined) throw cachedModule.error;&quot;,
						&quot;return cachedModule.exports;&quot;
					])
				: Template.indent(&quot;return cachedModule.exports;&quot;),
			&quot;}&quot;,
			&quot;// Create a new module (and put it into the cache)&quot;,
			&quot;var module = __webpack_module_cache__[moduleId] = {&quot;,
			Template.indent([
				needModuleId ? &quot;id: moduleId,&quot; : &quot;// no module.id needed&quot;,
				needModuleLoaded ? &quot;loaded: false,&quot; : &quot;// no module.loaded needed&quot;,
				&quot;exports: {}&quot;
			]),
			&quot;};&quot;,
			&quot;&quot;,
			outputOptions.strictModuleExceptionHandling
				? Template.asString([
						&quot;// Execute the module function&quot;,
						&quot;var threw = true;&quot;,
						&quot;try {&quot;,
						Template.indent([moduleExecution, &quot;threw = false;&quot;]),
						&quot;} finally {&quot;,
						Template.indent([
							&quot;if(threw) delete __webpack_module_cache__[moduleId];&quot;
						]),
						&quot;}&quot;
					])
				: outputOptions.strictModuleErrorHandling
					? Template.asString([
							&quot;// Execute the module function&quot;,
							&quot;try {&quot;,
							Template.indent(moduleExecution),
							&quot;} catch(e) {&quot;,
							Template.indent([&quot;module.error = e;&quot;, &quot;throw e;&quot;]),
							&quot;}&quot;
						])
					: Template.asString([
							&quot;// Execute the module function&quot;,
							moduleExecution
						]),
			needModuleLoaded
				? Template.asString([
						&quot;&quot;,
						&quot;// Flag the module as loaded&quot;,
						`${RuntimeGlobals.moduleLoaded} = true;`,
						&quot;&quot;
					])
				: &quot;&quot;,
			&quot;// Return the exports of the module&quot;,
			&quot;return module.exports;&quot;
		]);
		return tryRunOrWebpackError(
			() =&gt; hooks.renderRequire.call(content, renderContext),
			&quot;JavascriptModulesPlugin.getCompilationHooks().renderRequire&quot;
		);
	}

	/**
	 * @param {Module[]} allModules allModules
	 * @param {MainRenderContext} renderContext renderContext
	 * @param {Set&lt;Module&gt;} inlinedModules inlinedModules
	 * @param {ChunkRenderContext} chunkRenderContext chunkRenderContext
	 * @param {CompilationHooks} hooks hooks
	 * @param {boolean | undefined} allStrict allStrict
	 * @param {boolean} hasChunkModules hasChunkModules
	 * @returns {Map&lt;Module, Source&gt; | false} renamed inlined modules
	 */
	getRenamedInlineModule(
		allModules,
		renderContext,
		inlinedModules,
		chunkRenderContext,
		hooks,
		allStrict,
		hasChunkModules
	) {
		const innerStrict =
			!allStrict &amp;&amp;
			allModules.every(m =&gt; /** @type {BuildInfo} */ (m.buildInfo).strict);
		const isMultipleEntries = inlinedModules.size &gt; 1;
		const singleEntryWithModules = inlinedModules.size === 1 &amp;&amp; hasChunkModules;

		// TODO:
		// This step is before the IIFE reason calculation. Ideally, it should only be executed when this function can optimize the
		// IIFE reason. Otherwise, it should directly return false. There are four reasons now, we have skipped two already, the left
		// one is &#039;it uses a non-standard name for the exports&#039;.
		if (isMultipleEntries || innerStrict || !singleEntryWithModules) {
			return false;
		}

		/** @type {Map&lt;Module, Source&gt;} */
		const renamedInlinedModules = new Map();
		const { runtimeTemplate } = renderContext;

		/** @typedef {{ source: Source, module: Module, ast: Program, variables: Set&lt;Variable&gt;, through: Set&lt;Reference&gt;, usedInNonInlined: Set&lt;Variable&gt;, moduleScope: Scope }} Info */
		/** @type {Map&lt;Module, Info&gt;} */
		const inlinedModulesToInfo = new Map();
		/** @type {Set&lt;string&gt;} */
		const nonInlinedModuleThroughIdentifiers = new Set();
		/** @type {Map&lt;Module, Source&gt;} */

		for (const m of allModules) {
			const isInlinedModule = inlinedModules &amp;&amp; inlinedModules.has(m);
			const moduleSource = this.renderModule(
				m,
				chunkRenderContext,
				hooks,
				!isInlinedModule
			);

			if (!moduleSource) continue;
			const code = /** @type {string} */ (moduleSource.source());
			const ast = JavascriptParser._parse(code, {
				sourceType: &quot;auto&quot;
			});

			const scopeManager = eslintScope.analyze(ast, {
				ecmaVersion: 6,
				sourceType: &quot;module&quot;,
				optimistic: true,
				ignoreEval: true
			});

			const globalScope = /** @type {Scope} */ (scopeManager.acquire(ast));
			if (inlinedModules &amp;&amp; inlinedModules.has(m)) {
				const moduleScope = globalScope.childScopes[0];
				inlinedModulesToInfo.set(m, {
					source: moduleSource,
					ast,
					module: m,
					variables: new Set(moduleScope.variables),
					through: new Set(moduleScope.through),
					usedInNonInlined: new Set(),
					moduleScope
				});
			} else {
				for (const ref of globalScope.through) {
					nonInlinedModuleThroughIdentifiers.add(ref.identifier.name);
				}
			}
		}

		for (const [, { variables, usedInNonInlined }] of inlinedModulesToInfo) {
			for (const variable of variables) {
				if (
					nonInlinedModuleThroughIdentifiers.has(variable.name) ||
					RESERVED_NAMES.has(variable.name)
				) {
					usedInNonInlined.add(variable);
				}
			}
		}

		for (const [m, moduleInfo] of inlinedModulesToInfo) {
			const { ast, source: _source, usedInNonInlined } = moduleInfo;
			const source = new ReplaceSource(_source);
			if (usedInNonInlined.size === 0) {
				renamedInlinedModules.set(m, source);
				continue;
			}

			const info = /** @type {Info} */ (inlinedModulesToInfo.get(m));
			const allUsedNames = new Set(
				Array.from(info.through, v =&gt; v.identifier.name)
			);

			for (const variable of usedInNonInlined) {
				allUsedNames.add(variable.name);
			}

			for (const variable of info.variables) {
				const usedNamesInScopeInfo = new Map();
				const ignoredScopes = new Set();

				const name = variable.name;
				const { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(
					usedNamesInScopeInfo,
					info.module.identifier(),
					name
				);

				if (allUsedNames.has(name) || usedNames.has(name)) {
					const references = getAllReferences(variable);
					const allIdentifiers = new Set(
						references.map(r =&gt; r.identifier).concat(variable.identifiers)
					);
					for (const ref of references) {
						addScopeSymbols(
							ref.from,
							usedNames,
							alreadyCheckedScopes,
							ignoredScopes
						);
					}

					const newName = findNewName(
						variable.name,
						allUsedNames,
						usedNames,
						m.readableIdentifier(runtimeTemplate.requestShortener)
					);
					allUsedNames.add(newName);
					for (const identifier of allIdentifiers) {
						const r = /** @type {Range} */ (identifier.range);
						const path = getPathInAst(ast, identifier);
						if (path &amp;&amp; path.length &gt; 1) {
							const maybeProperty =
								path[1].type === &quot;AssignmentPattern&quot; &amp;&amp; path[1].left === path[0]
									? path[2]
									: path[1];
							if (
								maybeProperty.type === &quot;Property&quot; &amp;&amp;
								maybeProperty.shorthand
							) {
								source.insert(r[1], `: ${newName}`);
								continue;
							}
						}
						source.replace(r[0], r[1] - 1, newName);
					}
				}
				allUsedNames.add(name);
			}

			renamedInlinedModules.set(m, source);
		}

		return renamedInlinedModules;
	}
}

module.exports = JavascriptModulesPlugin;
module.exports.chunkHasJs = chunkHasJs;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
