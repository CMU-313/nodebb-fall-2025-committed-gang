<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jquery-ui/ui/widgets/sortable.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jquery-ui/ui/widgets/sortable.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1609</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">147.58</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.02</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * jQuery UI Sortable 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//&gt;&gt;label: Sortable
//&gt;&gt;group: Interactions
//&gt;&gt;description: Enables items in a list to be sorted using the mouse.
//&gt;&gt;docs: https://api.jqueryui.com/sortable/
//&gt;&gt;demos: https://jqueryui.com/sortable/
//&gt;&gt;css.structure: ../../themes/base/sortable.css

( function( factory ) {
	&quot;use strict&quot;;

	if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {

		// AMD. Register as an anonymous module.
		define( [
			&quot;jquery&quot;,
			&quot;./mouse&quot;,
			&quot;../data&quot;,
			&quot;../scroll-parent&quot;,
			&quot;../version&quot;,
			&quot;../widget&quot;
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
} )( function( $ ) {
&quot;use strict&quot;;

return $.widget( &quot;ui.sortable&quot;, $.ui.mouse, {
	version: &quot;1.14.1&quot;,
	widgetEventPrefix: &quot;sort&quot;,
	ready: false,
	options: {
		appendTo: &quot;parent&quot;,
		axis: false,
		connectWith: false,
		containment: false,
		cursor: &quot;auto&quot;,
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		items: &quot;&gt; *&quot;,
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: &quot;default&quot;,
		tolerance: &quot;intersect&quot;,
		zIndex: 1000,

		// Callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x &gt;= reference ) &amp;&amp; ( x &lt; ( reference + size ) );
	},

	_isFloating: function( item ) {
		return ( /left|right/ ).test( item.css( &quot;float&quot; ) ) ||
			( /inline|table-cell/ ).test( item.css( &quot;display&quot; ) );
	},

	_create: function() {
		this.containerCache = {};
		this._addClass( &quot;ui-sortable&quot; );

		//Get the items
		this.refresh();

		//Let&#039;s determine the parent&#039;s offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We&#039;re ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === &quot;handle&quot; ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		var that = this;
		this._removeClass( this.element.find( &quot;.ui-sortable-handle&quot; ), &quot;ui-sortable-handle&quot; );
		$.each( this.items, function() {
			that._addClass(
				this.instance.options.handle ?
					this.item.find( this.instance.options.handle ) :
					this.item,
				&quot;ui-sortable-handle&quot;
			);
		} );
	},

	_destroy: function() {
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i &gt;= 0; i-- ) {
			this.items[ i ].item.removeData( this.widgetName + &quot;-item&quot; );
		}

		return this;
	},

	_mouseCapture: function( event, overrideHandle ) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if ( this.reverting ) {
			return false;
		}

		if ( this.options.disabled || this.options.type === &quot;static&quot; ) {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems( event );

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$( event.target ).parents().each( function() {
			if ( $.data( this, that.widgetName + &quot;-item&quot; ) === that ) {
				currentItem = $( this );
				return false;
			}
		} );
		if ( $.data( event.target, that.widgetName + &quot;-item&quot; ) === that ) {
			currentItem = $( event.target );
		}

		if ( !currentItem ) {
			return false;
		}
		if ( this.options.handle &amp;&amp; !overrideHandle ) {
			$( this.options.handle, currentItem ).find( &quot;*&quot; ).addBack().each( function() {
				if ( this === event.target ) {
					validHandle = true;
				}
			} );
			if ( !validHandle ) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function( event, overrideHandle, noActivation ) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to
		// mouseCapture
		this.refreshPositions();

		//Prepare the dragged items parent
		this.appendTo = $( o.appendTo !== &quot;parent&quot; ?
				o.appendTo :
				this.currentItem.parent() );

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#039;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//The element&#039;s absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend( this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},

			// This is a relative to absolute position minus the actual position calculation -
			// only used for relative positioned helper
			relative: this._getRelativeOffset()
		} );

		// After we get the helper offset, but before we get the parent offset we can
		// change the helper&#039;s position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css( &quot;position&quot;, &quot;absolute&quot; );
		this.cssPosition = this.helper.css( &quot;position&quot; );

		//Adjust the mouse offset relative to the helper if &quot;cursorAt&quot; is supplied
		if ( o.cursorAt ) {
			this._adjustOffsetFromHelper( o.cursorAt );
		}

		//Cache the former DOM position
		this.domPosition = {
			prev: this.currentItem.prev()[ 0 ],
			parent: this.currentItem.parent()[ 0 ]
		};

		// If the helper is not the original, hide the original so it&#039;s not playing any role during
		// the drag, won&#039;t cause anything bad this way
		if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Get the next scrolling parent
		this.scrollParent = this.placeholder.scrollParent();

		$.extend( this.offset, {
			parent: this._getParentOffset()
		} );

		//Set a containment if given in the options
		if ( o.containment ) {
			this._setContainment();
		}

		if ( o.cursor &amp;&amp; o.cursor !== &quot;auto&quot; ) { // cursor option
			body = this.document.find( &quot;body&quot; );

			this._storedStylesheet =
				$( &quot;&lt;style&gt;*{ cursor: &quot; + o.cursor + &quot; !important; }&lt;/style&gt;&quot; ).appendTo( body );
		}

		// We need to make sure to grab the zIndex before setting the
		// opacity, because setting the opacity to anything lower than 1
		// causes the zIndex to change from &quot;auto&quot; to 0.
		if ( o.zIndex ) { // zIndex option
			if ( this.helper.css( &quot;zIndex&quot; ) ) {
				this._storedZIndex = this.helper.css( &quot;zIndex&quot; );
			}
			this.helper.css( &quot;zIndex&quot;, o.zIndex );
		}

		if ( o.opacity ) { // opacity option
			if ( this.helper.css( &quot;opacity&quot; ) ) {
				this._storedOpacity = this.helper.css( &quot;opacity&quot; );
			}
			this.helper.css( &quot;opacity&quot;, o.opacity );
		}

		//Prepare scrolling
		if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
				this.scrollParent[ 0 ].tagName !== &quot;HTML&quot; ) {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger( &quot;start&quot;, event, this._uiHash() );

		//Recache the helper size
		if ( !this._preserveHelperProportions ) {
			this._cacheHelperProportions();
		}

		//Post &quot;activate&quot; events to possible containers
		if ( !noActivation ) {
			for ( i = this.containers.length - 1; i &gt;= 0; i-- ) {
				this.containers[ i ]._trigger( &quot;activate&quot;, event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		if ( $.ui.ddmanager &amp;&amp; !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		this.dragging = true;

		this._addClass( this.helper, &quot;ui-sortable-helper&quot; );

		//Move the helper, if needed
		if ( !this.helper.parent().is( this.appendTo ) ) {
			this.helper.detach().appendTo( this.appendTo );

			//Update position
			this.offset.parent = this._getParentOffset();
		}

		//Generate the original position
		this.position = this.originalPosition = this._generatePosition( event );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;
		this.lastPositionAbs = this.positionAbs = this._convertPositionTo( &quot;absolute&quot; );

		this._mouseDrag( event );

		return true;

	},

	_scroll: function( event ) {
		var o = this.options,
			scrolled = false;

		if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
				this.scrollParent[ 0 ].tagName !== &quot;HTML&quot; ) {

			if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
					event.pageY &lt; o.scrollSensitivity ) {
				this.scrollParent[ 0 ].scrollTop =
					scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
			} else if ( event.pageY - this.overflowOffset.top &lt; o.scrollSensitivity ) {
				this.scrollParent[ 0 ].scrollTop =
					scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
			}

			if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
					event.pageX &lt; o.scrollSensitivity ) {
				this.scrollParent[ 0 ].scrollLeft = scrolled =
					this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
			} else if ( event.pageX - this.overflowOffset.left &lt; o.scrollSensitivity ) {
				this.scrollParent[ 0 ].scrollLeft = scrolled =
					this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
			}

		} else {

			if ( event.pageY - this.document.scrollTop() &lt; o.scrollSensitivity ) {
				scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
			} else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) &lt;
					o.scrollSensitivity ) {
				scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
			}

			if ( event.pageX - this.document.scrollLeft() &lt; o.scrollSensitivity ) {
				scrolled = this.document.scrollLeft(
					this.document.scrollLeft() - o.scrollSpeed
				);
			} else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) &lt;
					o.scrollSensitivity ) {
				scrolled = this.document.scrollLeft(
					this.document.scrollLeft() + o.scrollSpeed
				);
			}

		}

		return scrolled;
	},

	_mouseDrag: function( event ) {
		var i, item, itemElement, intersection,
			o = this.options;

		//Compute the helpers position
		this.position = this._generatePosition( event );
		this.positionAbs = this._convertPositionTo( &quot;absolute&quot; );

		//Set the helper position
		if ( !this.options.axis || this.options.axis !== &quot;y&quot; ) {
			this.helper[ 0 ].style.left = this.position.left + &quot;px&quot;;
		}
		if ( !this.options.axis || this.options.axis !== &quot;x&quot; ) {
			this.helper[ 0 ].style.top = this.position.top + &quot;px&quot;;
		}

		//Do scrolling
		if ( o.scroll ) {
			if ( this._scroll( event ) !== false ) {

				//Update item positions used in position checks
				this._refreshItemPositions( true );

				if ( $.ui.ddmanager &amp;&amp; !o.dropBehaviour ) {
					$.ui.ddmanager.prepareOffsets( this, event );
				}
			}
		}

		this.dragDirection = {
			vertical: this._getDragVerticalDirection(),
			horizontal: this._getDragHorizontalDirection()
		};

		//Rearrange
		for ( i = this.items.length - 1; i &gt;= 0; i-- ) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[ i ];
			itemElement = item.item[ 0 ];
			intersection = this._intersectsWithPointer( item );
			if ( !intersection ) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in &quot;sub-sortables&quot; can cause
			// the placeholder to jitter between the outer and inner container.
			if ( item.instance !== this.currentContainer ) {
				continue;
			}

			// Cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if ( itemElement !== this.currentItem[ 0 ] &amp;&amp;
				this.placeholder[ intersection === 1 ?
				&quot;next&quot; : &quot;prev&quot; ]()[ 0 ] !== itemElement &amp;&amp;
				!$.contains( this.placeholder[ 0 ], itemElement ) &amp;&amp;
				( this.options.type === &quot;semi-dynamic&quot; ?
					!$.contains( this.element[ 0 ], itemElement ) :
					true
				)
			) {

				this.direction = intersection === 1 ? &quot;down&quot; : &quot;up&quot;;

				if ( this.options.tolerance === &quot;pointer&quot; ||
						this._intersectsWithSides( item ) ) {
					this._rearrange( event, item );
				} else {
					break;
				}

				this._trigger( &quot;change&quot;, event, this._uiHash() );
				break;
			}
		}

		//Post events to containers
		this._contactContainers( event );

		//Interconnect with droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		//Call callbacks
		this._trigger( &quot;sort&quot;, event, this._uiHash() );

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function( event, noPropagation ) {

		if ( !event ) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ( $.ui.ddmanager &amp;&amp; !this.options.dropBehaviour ) {
			$.ui.ddmanager.drop( this, event );
		}

		if ( this.options.revert ) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === &quot;x&quot; ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollLeft
					);
			}
			if ( !axis || axis === &quot;y&quot; ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollTop
					);
			}
			this.reverting = true;
			$( this.helper ).animate(
				animation,
				parseInt( this.options.revert, 10 ) || 500,
				function() {
					that._clear( event );
				}
			);
		} else {
			this._clear( event, noPropagation );
		}

		return false;

	},

	cancel: function() {

		if ( this.dragging ) {

			this._mouseUp( new $.Event( &quot;mouseup&quot;, { target: null } ) );

			if ( this.options.helper === &quot;original&quot; ) {
				this.currentItem.css( this._storedCSS );
				this._removeClass( this.currentItem, &quot;ui-sortable-helper&quot; );
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for ( var i = this.containers.length - 1; i &gt;= 0; i-- ) {
				this.containers[ i ]._trigger( &quot;deactivate&quot;, null, this._uiHash( this ) );
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( &quot;out&quot;, null, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		if ( this.placeholder ) {

			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
			// it unbinds ALL events from the original node!
			if ( this.placeholder[ 0 ].parentNode ) {
				this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
			}
			if ( this.options.helper !== &quot;original&quot; &amp;&amp; this.helper &amp;&amp;
					this.helper[ 0 ].parentNode ) {
				this.helper.remove();
			}

			$.extend( this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			} );

			if ( this.domPosition.prev ) {
				$( this.domPosition.prev ).after( this.currentItem );
			} else {
				$( this.domPosition.parent ).prepend( this.currentItem );
			}
		}

		return this;

	},

	serialize: function( o ) {

		var items = this._getItemsAsjQuery( o &amp;&amp; o.connected ),
			str = [];
		o = o || {};

		$( items ).each( function() {
			var res = ( $( o.item || this ).attr( o.attribute || &quot;id&quot; ) || &quot;&quot; )
				.match( o.expression || ( /(.+)[\-=_](.+)/ ) );
			if ( res ) {
				str.push(
					( o.key || res[ 1 ] + &quot;[]&quot; ) +
					&quot;=&quot; + ( o.key &amp;&amp; o.expression ? res[ 1 ] : res[ 2 ] ) );
			}
		} );

		if ( !str.length &amp;&amp; o.key ) {
			str.push( o.key + &quot;=&quot; );
		}

		return str.join( &quot;&amp;&quot; );

	},

	toArray: function( o ) {

		var items = this._getItemsAsjQuery( o &amp;&amp; o.connected ),
			ret = [];

		o = o || {};

		items.each( function() {
			ret.push( $( o.item || this ).attr( o.attribute || &quot;id&quot; ) || &quot;&quot; );
		} );
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function( item ) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === &quot;x&quot; ) || ( ( y1 + dyClick ) &gt; t &amp;&amp;
				( y1 + dyClick ) &lt; b ),
			isOverElementWidth = ( this.options.axis === &quot;y&quot; ) || ( ( x1 + dxClick ) &gt; l &amp;&amp;
				( x1 + dxClick ) &lt; r ),
			isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth;

		if ( this.options.tolerance === &quot;pointer&quot; ||
			this.options.forcePointerForContainers ||
			( this.options.tolerance !== &quot;pointer&quot; &amp;&amp;
				this.helperProportions[ this.floating ? &quot;width&quot; : &quot;height&quot; ] &gt;
				item[ this.floating ? &quot;width&quot; : &quot;height&quot; ] )
		) {
			return isOverElement;
		} else {

			return ( l &lt; x1 + ( this.helperProportions.width / 2 ) &amp;&amp; // Right Half
				x2 - ( this.helperProportions.width / 2 ) &lt; r &amp;&amp; // Left Half
				t &lt; y1 + ( this.helperProportions.height / 2 ) &amp;&amp; // Bottom Half
				y2 - ( this.helperProportions.height / 2 ) &lt; b ); // Top Half

		}
	},

	_intersectsWithPointer: function( item ) {
		var verticalDirection, horizontalDirection,
			isOverElementHeight = ( this.options.axis === &quot;x&quot; ) ||
				this._isOverAxis(
					this.positionAbs.top + this.offset.click.top, item.top, item.height ),
			isOverElementWidth = ( this.options.axis === &quot;y&quot; ) ||
				this._isOverAxis(
					this.positionAbs.left + this.offset.click.left, item.left, item.width ),
			isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth;

		if ( !isOverElement ) {
			return false;
		}

		verticalDirection = this.dragDirection.vertical;
		horizontalDirection = this.dragDirection.horizontal;

		return this.floating ?
			( ( horizontalDirection === &quot;right&quot; || verticalDirection === &quot;down&quot; ) ? 2 : 1 ) :
			( verticalDirection &amp;&amp; ( verticalDirection === &quot;down&quot; ? 2 : 1 ) );

	},

	_intersectsWithSides: function( item ) {

		var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
				this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
			isOverRightHalf = this._isOverAxis( this.positionAbs.left +
				this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
			verticalDirection = this.dragDirection.vertical,
			horizontalDirection = this.dragDirection.horizontal;

		if ( this.floating &amp;&amp; horizontalDirection ) {
			return ( ( horizontalDirection === &quot;right&quot; &amp;&amp; isOverRightHalf ) ||
				( horizontalDirection === &quot;left&quot; &amp;&amp; !isOverRightHalf ) );
		} else {
			return verticalDirection &amp;&amp; ( ( verticalDirection === &quot;down&quot; &amp;&amp; isOverBottomHalf ) ||
				( verticalDirection === &quot;up&quot; &amp;&amp; !isOverBottomHalf ) );
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 &amp;&amp; ( delta &gt; 0 ? &quot;down&quot; : &quot;up&quot; );
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 &amp;&amp; ( delta &gt; 0 ? &quot;right&quot; : &quot;left&quot; );
	},

	refresh: function( event ) {
		this._refreshItems( event );
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ?
			[ options.connectWith ] :
			options.connectWith;
	},

	_getItemsAsjQuery: function( connected ) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if ( connectWith &amp;&amp; connected ) {
			for ( i = connectWith.length - 1; i &gt;= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j &gt;= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst &amp;&amp; inst !== this &amp;&amp; !inst.options.disabled ) {
						queries.push( [ typeof inst.options.items === &quot;function&quot; ?
							inst.options.items.call( inst.element ) :
							$( inst.options.items, inst.element )
								.not( &quot;.ui-sortable-helper&quot; )
								.not( &quot;.ui-sortable-placeholder&quot; ), inst ] );
					}
				}
			}
		}

		queries.push( [ typeof this.options.items === &quot;function&quot; ?
			this.options.items
				.call( this.element, null, { options: this.options, item: this.currentItem } ) :
			$( this.options.items, this.element )
				.not( &quot;.ui-sortable-helper&quot; )
				.not( &quot;.ui-sortable-placeholder&quot; ), this ] );

		function addItems() {
			items.push( this );
		}
		for ( i = queries.length - 1; i &gt;= 0; i-- ) {
			queries[ i ][ 0 ].each( addItems );
		}

		return $( items );

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find( &quot;:data(&quot; + this.widgetName + &quot;-item)&quot; );

		this.items = $.grep( this.items, function( item ) {
			for ( var j = 0; j &lt; list.length; j++ ) {
				if ( list[ j ] === item.item[ 0 ] ) {
					return false;
				}
			}
			return true;
		} );

	},

	_refreshItems: function( event ) {

		this.items = [];
		this.containers = [ this ];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [ [ typeof this.options.items === &quot;function&quot; ?
				this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
				$( this.options.items, this.element ), this ] ],
			connectWith = this._connectWith();

		//Shouldn&#039;t be run the first time through due to massive slow-down
		if ( connectWith &amp;&amp; this.ready ) {
			for ( i = connectWith.length - 1; i &gt;= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j &gt;= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst &amp;&amp; inst !== this &amp;&amp; !inst.options.disabled ) {
						queries.push( [ typeof inst.options.items === &quot;function&quot; ?
							inst.options.items
								.call( inst.element[ 0 ], event, { item: this.currentItem } ) :
							$( inst.options.items, inst.element ), inst ] );
						this.containers.push( inst );
					}
				}
			}
		}

		for ( i = queries.length - 1; i &gt;= 0; i-- ) {
			targetData = queries[ i ][ 1 ];
			_queries = queries[ i ][ 0 ];

			for ( j = 0, queriesLength = _queries.length; j &lt; queriesLength; j++ ) {
				item = $( _queries[ j ] );

				// Data for target checking (mouse manager)
				item.data( this.widgetName + &quot;-item&quot;, targetData );

				items.push( {
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				} );
			}
		}

	},

	_refreshItemPositions: function( fast ) {
		var i, item, t, p;

		for ( i = this.items.length - 1; i &gt;= 0; i-- ) {
			item = this.items[ i ];

			//We ignore calculating positions of all connected containers when we&#039;re not over them
			if ( this.currentContainer &amp;&amp; item.instance !== this.currentContainer &amp;&amp;
					item.item[ 0 ] !== this.currentItem[ 0 ] ) {
				continue;
			}

			t = this.options.toleranceElement ?
				$( this.options.toleranceElement, item.item ) :
				item.item;

			if ( !fast ) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}
	},

	refreshPositions: function( fast ) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === &quot;x&quot; || this._isFloating( this.items[ 0 ].item ) :
			false;

		// This has to be redone because due to the item being moved out/into the offsetParent,
		// the offsetParent&#039;s position will change
		if ( this.offsetParent &amp;&amp; this.helper ) {
			this.offset.parent = this._getParentOffset();
		}

		this._refreshItemPositions( fast );

		var i, p;

		if ( this.options.custom &amp;&amp; this.options.custom.refreshContainers ) {
			this.options.custom.refreshContainers.call( this );
		} else {
			for ( i = this.containers.length - 1; i &gt;= 0; i-- ) {
				p = this.containers[ i ].element.offset();
				this.containers[ i ].containerCache.left = p.left;
				this.containers[ i ].containerCache.top = p.top;
				this.containers[ i ].containerCache.width =
					this.containers[ i ].element.outerWidth();
				this.containers[ i ].containerCache.height =
					this.containers[ i ].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function( that ) {
		that = that || this;
		var className, nodeName,
			o = that.options;

		if ( !o.placeholder || o.placeholder.constructor === String ) {
			className = o.placeholder;
			nodeName = that.currentItem[ 0 ].nodeName.toLowerCase();
			o.placeholder = {
				element: function() {

					var element = $( &quot;&lt;&quot; + nodeName + &quot;&gt;&quot;, that.document[ 0 ] );

					that._addClass( element, &quot;ui-sortable-placeholder&quot;,
							className || that.currentItem[ 0 ].className )
						._removeClass( element, &quot;ui-sortable-helper&quot; );

					if ( nodeName === &quot;tbody&quot; ) {
						that._createTrPlaceholder(
							that.currentItem.find( &quot;tr&quot; ).eq( 0 ),
							$( &quot;&lt;tr&gt;&quot;, that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === &quot;tr&quot; ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === &quot;img&quot; ) {
						element.attr( &quot;src&quot;, that.currentItem.attr( &quot;src&quot; ) );
					}

					if ( !className ) {
						element.css( &quot;visibility&quot;, &quot;hidden&quot; );
					}

					return element;
				},
				update: function( container, p ) {

					// 1. If a className is set as &#039;placeholder option, we don&#039;t force sizes -
					// the class is responsible for that
					// 2. The option &#039;forcePlaceholderSize can be enabled to force it even if a
					// class name is specified
					if ( className &amp;&amp; !o.forcePlaceholderSize ) {
						return;
					}

					// If the element doesn&#039;t have a actual height or width by itself (without
					// styles coming from a stylesheet), it receives the inline height and width
					// from the dragged item. Or, if it&#039;s a tbody or tr, it&#039;s going to have a height
					// anyway since we&#039;re populating them with &lt;td&gt;s above, but they&#039;re unlikely to
					// be the correct height on their own if the row heights are dynamic, so we&#039;ll
					// always assign the height of the dragged item given forcePlaceholderSize
					// is true.
					if ( !p.height() || ( o.forcePlaceholderSize &amp;&amp;
							( nodeName === &quot;tbody&quot; || nodeName === &quot;tr&quot; ) ) ) {
						p.height(
							that.currentItem.innerHeight() -
							parseInt( that.currentItem.css( &quot;paddingTop&quot; ) || 0, 10 ) -
							parseInt( that.currentItem.css( &quot;paddingBottom&quot; ) || 0, 10 ) );
					}
					if ( !p.width() ) {
						p.width(
							that.currentItem.innerWidth() -
							parseInt( that.currentItem.css( &quot;paddingLeft&quot; ) || 0, 10 ) -
							parseInt( that.currentItem.css( &quot;paddingRight&quot; ) || 0, 10 ) );
					}
				}
			};
		}

		//Create the placeholder
		that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );

		//Append it after the actual current item
		that.currentItem.after( that.placeholder );

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update( that, that.placeholder );

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each( function() {
			$( &quot;&lt;td&gt;&amp;#160;&lt;/td&gt;&quot;, that.document[ 0 ] )
				.attr( &quot;colspan&quot;, $( this ).attr( &quot;colspan&quot; ) || 1 )
				.appendTo( targetTr );
		} );
	},

	_contactContainers: function( event ) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
			floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// Get innermost container that intersects with item
		for ( i = this.containers.length - 1; i &gt;= 0; i-- ) {

			// Never consider a container that&#039;s located within the item itself
			if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
				continue;
			}

			if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {

				// If we&#039;ve already found a container and it&#039;s more &quot;inner&quot; than this, then continue
				if ( innermostContainer &amp;&amp;
						$.contains(
							this.containers[ i ].element[ 0 ],
							innermostContainer.element[ 0 ] ) ) {
					continue;
				}

				innermostContainer = this.containers[ i ];
				innermostIndex = i;

			} else {

				// container doesn&#039;t intersect. trigger &quot;out&quot; event if necessary
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( &quot;out&quot;, event, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		// If no intersecting containers found, return
		if ( !innermostContainer ) {
			return;
		}

		// Move the item into the container if it&#039;s not there already
		if ( this.containers.length === 1 ) {
			if ( !this.containers[ innermostIndex ].containerCache.over ) {
				this.containers[ innermostIndex ]._trigger( &quot;over&quot;, event, this._uiHash( this ) );
				this.containers[ innermostIndex ].containerCache.over = 1;
			}
		} else {

			// When entering a new container, we will find the item with the least distance and
			// append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating( this.currentItem );
			posProperty = floating ? &quot;left&quot; : &quot;top&quot;;
			sizeProperty = floating ? &quot;width&quot; : &quot;height&quot;;
			axis = floating ? &quot;pageX&quot; : &quot;pageY&quot;;

			for ( j = this.items.length - 1; j &gt;= 0; j-- ) {
				if ( !$.contains(
						this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
				) {
					continue;
				}
				if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
					continue;
				}

				cur = this.items[ j ].item.offset()[ posProperty ];
				nearBottom = false;
				if ( event[ axis ] - cur &gt; this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) &lt; dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? &quot;up&quot; : &quot;down&quot;;
				}
			}

			//Check if dropOnEmpty is enabled
			if ( !itemWithLeastDistance &amp;&amp; !this.options.dropOnEmpty ) {
				return;
			}

			if ( this.currentContainer === this.containers[ innermostIndex ] ) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( &quot;over&quot;, event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			if ( itemWithLeastDistance ) {
				this._rearrange( event, itemWithLeastDistance, null, true );
			} else {
				this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
			}
			this._trigger( &quot;change&quot;, event, this._uiHash() );
			this.containers[ innermostIndex ]._trigger( &quot;change&quot;, event, this._uiHash( this ) );
			this.currentContainer = this.containers[ innermostIndex ];

			//Update the placeholder
			this.options.placeholder.update( this.currentContainer, this.placeholder );

			//Update scrollParent
			this.scrollParent = this.placeholder.scrollParent();

			//Update overflowOffset
			if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
					this.scrollParent[ 0 ].tagName !== &quot;HTML&quot; ) {
				this.overflowOffset = this.scrollParent.offset();
			}

			this.containers[ innermostIndex ]._trigger( &quot;over&quot;, event, this._uiHash( this ) );
			this.containers[ innermostIndex ].containerCache.over = 1;
		}

	},

	_createHelper: function( event ) {

		var o = this.options,
			helper = typeof o.helper === &quot;function&quot; ?
				$( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
				( o.helper === &quot;clone&quot; ? this.currentItem.clone() : this.currentItem );

		//Add the helper to the DOM if that didn&#039;t happen already
		if ( !helper.parents( &quot;body&quot; ).length ) {
			this.appendTo[ 0 ].appendChild( helper[ 0 ] );
		}

		if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
			this._storedCSS = {
				width: this.currentItem[ 0 ].style.width,
				height: this.currentItem[ 0 ].style.height,
				position: this.currentItem.css( &quot;position&quot; ),
				top: this.currentItem.css( &quot;top&quot; ),
				left: this.currentItem.css( &quot;left&quot; )
			};
		}

		if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
			helper.width( this.currentItem.width() );
		}
		if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
			helper.height( this.currentItem.height() );
		}

		return helper;

	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === &quot;string&quot; ) {
			obj = obj.split( &quot; &quot; );
		}
		if ( Array.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( &quot;left&quot; in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( &quot;right&quot; in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( &quot;top&quot; in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( &quot;bottom&quot; in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it&#039;s position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#039;t
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === &quot;absolute&quot; &amp;&amp; this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes
		// this information.
		if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( &quot;borderTopWidth&quot; ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( &quot;borderLeftWidth&quot; ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {

		if ( this.cssPosition === &quot;relative&quot; ) {
			var p = this.currentItem.position();
			return {
				top: p.top - ( parseInt( this.helper.css( &quot;top&quot; ), 10 ) || 0 ) +
					this.scrollParent.scrollTop(),
				left: p.left - ( parseInt( this.helper.css( &quot;left&quot; ), 10 ) || 0 ) +
					this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.currentItem.css( &quot;marginLeft&quot; ), 10 ) || 0 ),
			top: ( parseInt( this.currentItem.css( &quot;marginTop&quot; ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if ( o.containment === &quot;parent&quot; ) {
			o.containment = this.helper[ 0 ].parentNode;
		}
		if ( o.containment === &quot;document&quot; || o.containment === &quot;window&quot; ) {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === &quot;document&quot; ?
					this.document.width() :
					this.window.width() - this.helperProportions.width - this.margins.left,
				( o.containment === &quot;document&quot; ?
					( this.document.height() || document.body.parentNode.scrollHeight ) :
					this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
				) - this.helperProportions.height - this.margins.top
			];
		}

		if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
			ce = $( o.containment )[ 0 ];
			co = $( o.containment ).offset();
			over = ( $( ce ).css( &quot;overflow&quot; ) !== &quot;hidden&quot; );

			this.containment = [
				co.left + ( parseInt( $( ce ).css( &quot;borderLeftWidth&quot; ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( &quot;paddingLeft&quot; ), 10 ) || 0 ) - this.margins.left,
				co.top + ( parseInt( $( ce ).css( &quot;borderTopWidth&quot; ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( &quot;paddingTop&quot; ), 10 ) || 0 ) - this.margins.top,
				co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
					( parseInt( $( ce ).css( &quot;borderLeftWidth&quot; ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( &quot;paddingRight&quot; ), 10 ) || 0 ) -
					this.helperProportions.width - this.margins.left,
				co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
					( parseInt( $( ce ).css( &quot;borderTopWidth&quot; ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( &quot;paddingBottom&quot; ), 10 ) || 0 ) -
					this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}
		var mod = d === &quot;absolute&quot; ? 1 : -1,
			scroll = this.cssPosition === &quot;absolute&quot; &amp;&amp;
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
			scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent&#039;s offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === &quot;fixed&quot; ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent&#039;s offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === &quot;fixed&quot; ?
					-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
					scroll.scrollLeft() ) * mod )
			)
		};

	},

	_generatePosition: function( event ) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === &quot;absolute&quot; &amp;&amp;
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
				scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if ( this.cssPosition === &quot;relative&quot; &amp;&amp; !( this.scrollParent[ 0 ] !== this.document[ 0 ] &amp;&amp;
				this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if ( this.originalPosition ) { //If we are not dragging yet, we won&#039;t check for options

			if ( this.containment ) {
				if ( event.pageX - this.offset.click.left &lt; this.containment[ 0 ] ) {
					pageX = this.containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top &lt; this.containment[ 1 ] ) {
					pageY = this.containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left &gt; this.containment[ 2 ] ) {
					pageX = this.containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top &gt; this.containment[ 3 ] ) {
					pageY = this.containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {
				top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
					o.grid[ 1 ] ) * o.grid[ 1 ];
				pageY = this.containment ?
					( ( top - this.offset.click.top &gt;= this.containment[ 1 ] &amp;&amp;
						top - this.offset.click.top &lt;= this.containment[ 3 ] ) ?
							top :
							( ( top - this.offset.click.top &gt;= this.containment[ 1 ] ) ?
								top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
								top;

				left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
					o.grid[ 0 ] ) * o.grid[ 0 ];
				pageX = this.containment ?
					( ( left - this.offset.click.left &gt;= this.containment[ 0 ] &amp;&amp;
						left - this.offset.click.left &lt;= this.containment[ 2 ] ) ?
							left :
							( ( left - this.offset.click.left &gt;= this.containment[ 0 ] ) ?
								left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
								left;
			}

		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent&#039;s offset without borders (offset + border)
				this.offset.parent.top +
				( ( this.cssPosition === &quot;fixed&quot; ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent&#039;s offset without borders (offset + border)
				this.offset.parent.left +
				( ( this.cssPosition === &quot;fixed&quot; ?
					-this.scrollParent.scrollLeft() :
					scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
			)
		};

	},

	_rearrange: function( event, i, a, hardRefresh ) {

		if ( a ) {
			a[ 0 ].appendChild( this.placeholder[ 0 ] );
		} else {
			i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
				( this.direction === &quot;down&quot; ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );
		}

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get&#039;s higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout,
		// if it&#039;s still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay( function() {
			if ( counter === this.counter ) {

				//Precompute after each DOM insertion, NOT on mousemove
				this.refreshPositions( !hardRefresh );
			}
		} );

	},

	_clear: function( event, noPropagation ) {

		this.reverting = false;

		// We delay all events that have to be triggered to after the point where the placeholder
		// has been removed and everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don&#039;t do it if the current item is already removed (by a user), or it gets
		// reappended (see #4088)
		if ( !this._noFinalSort &amp;&amp; this.currentItem.parent().length ) {
			this.placeholder.before( this.currentItem );
		}
		this._noFinalSort = null;

		if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
			for ( i in this._storedCSS ) {
				if ( this._storedCSS[ i ] === &quot;auto&quot; || this._storedCSS[ i ] === &quot;static&quot; ) {
					this._storedCSS[ i ] = &quot;&quot;;
				}
			}
			this.currentItem.css( this._storedCSS );
			this._removeClass( this.currentItem, &quot;ui-sortable-helper&quot; );
		} else {
			this.currentItem.show();
		}

		if ( this.fromOutside &amp;&amp; !noPropagation ) {
			delayedTriggers.push( function( event ) {
				this._trigger( &quot;receive&quot;, event, this._uiHash( this.fromOutside ) );
			} );
		}
		if ( ( this.fromOutside ||
				this.domPosition.prev !==
				this.currentItem.prev().not( &quot;.ui-sortable-helper&quot; )[ 0 ] ||
				this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) &amp;&amp; !noPropagation ) {

			// Trigger update callback if the DOM position has changed
			delayedTriggers.push( function( event ) {
				this._trigger( &quot;update&quot;, event, this._uiHash() );
			} );
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if ( this !== this.currentContainer ) {
			if ( !noPropagation ) {
				delayedTriggers.push( function( event ) {
					this._trigger( &quot;remove&quot;, event, this._uiHash() );
				} );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( &quot;receive&quot;, event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( &quot;update&quot;, event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
			}
		}

		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for ( i = this.containers.length - 1; i &gt;= 0; i-- ) {
			if ( !noPropagation ) {
				delayedTriggers.push( delayEvent( &quot;deactivate&quot;, this, this.containers[ i ] ) );
			}
			if ( this.containers[ i ].containerCache.over ) {
				delayedTriggers.push( delayEvent( &quot;out&quot;, this, this.containers[ i ] ) );
				this.containers[ i ].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this._storedStylesheet ) {
			this._storedStylesheet.remove();
			this._storedStylesheet = null;
		}
		if ( this._storedOpacity ) {
			this.helper.css( &quot;opacity&quot;, this._storedOpacity );
		}
		if ( this._storedZIndex ) {
			this.helper.css( &quot;zIndex&quot;, this._storedZIndex === &quot;auto&quot; ? &quot;&quot; : this._storedZIndex );
		}

		this.dragging = false;

		if ( !noPropagation ) {
			this._trigger( &quot;beforeStop&quot;, event, this._uiHash() );
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
		// it unbinds ALL events from the original node!
		this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if ( !noPropagation ) {
			for ( i = 0; i &lt; delayedTriggers.length; i++ ) {

				// Trigger all delayed events
				delayedTriggers[ i ].call( this, event );
			}
			this._trigger( &quot;stop&quot;, event, this._uiHash() );
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
			this.cancel();
		}
	},

	_uiHash: function( _inst ) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $( [] ),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

} );

} );
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
