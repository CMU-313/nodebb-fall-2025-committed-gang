<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/connect-multiparty/node_modules/qs/test/stringify.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/connect-multiparty/node_modules/qs/test/stringify.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">643</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">83.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.91</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var test = require(&#039;tape&#039;);
var qs = require(&#039;../&#039;);
var utils = require(&#039;../lib/utils&#039;);
var iconv = require(&#039;iconv-lite&#039;);
var SaferBuffer = require(&#039;safer-buffer&#039;).Buffer;

test(&#039;stringify()&#039;, function (t) {
    t.test(&#039;stringifies a querystring object&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: 1 }), &#039;a=1&#039;);
        st.equal(qs.stringify({ a: 1, b: 2 }), &#039;a=1&amp;b=2&#039;);
        st.equal(qs.stringify({ a: &#039;A_Z&#039; }), &#039;a=A_Z&#039;);
        st.equal(qs.stringify({ a: &#039;‚Ç¨&#039; }), &#039;a=%E2%82%AC&#039;);
        st.equal(qs.stringify({ a: &#039;ÓÄÄ&#039; }), &#039;a=%EE%80%80&#039;);
        st.equal(qs.stringify({ a: &#039;◊ê&#039; }), &#039;a=%D7%90&#039;);
        st.equal(qs.stringify({ a: &#039;êê∑&#039; }), &#039;a=%F0%90%90%B7&#039;);
        st.end();
    });

    t.test(&#039;stringifies falsy values&#039;, function (st) {
        st.equal(qs.stringify(undefined), &#039;&#039;);
        st.equal(qs.stringify(null), &#039;&#039;);
        st.equal(qs.stringify(null, { strictNullHandling: true }), &#039;&#039;);
        st.equal(qs.stringify(false), &#039;&#039;);
        st.equal(qs.stringify(0), &#039;&#039;);
        st.end();
    });

    t.test(&#039;adds query prefix&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }, { addQueryPrefix: true }), &#039;?a=b&#039;);
        st.end();
    });

    t.test(&#039;with query prefix, outputs blank string given an empty object&#039;, function (st) {
        st.equal(qs.stringify({}, { addQueryPrefix: true }), &#039;&#039;);
        st.end();
    });

    t.test(&#039;stringifies nested falsy values&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: { c: null } } }), &#039;a%5Bb%5D%5Bc%5D=&#039;);
        st.equal(qs.stringify({ a: { b: { c: null } } }, { strictNullHandling: true }), &#039;a%5Bb%5D%5Bc%5D&#039;);
        st.equal(qs.stringify({ a: { b: { c: false } } }), &#039;a%5Bb%5D%5Bc%5D=false&#039;);
        st.end();
    });

    t.test(&#039;stringifies a nested object&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }), &#039;a%5Bb%5D=c&#039;);
        st.equal(qs.stringify({ a: { b: { c: { d: &#039;e&#039; } } } }), &#039;a%5Bb%5D%5Bc%5D%5Bd%5D=e&#039;);
        st.end();
    });

    t.test(&#039;stringifies a nested object with dots notation&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }, { allowDots: true }), &#039;a.b=c&#039;);
        st.equal(qs.stringify({ a: { b: { c: { d: &#039;e&#039; } } } }, { allowDots: true }), &#039;a.b.c.d=e&#039;);
        st.end();
    });

    t.test(&#039;stringifies an array value&#039;, function (st) {
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { arrayFormat: &#039;indices&#039; }),
            &#039;a%5B0%5D=b&amp;a%5B1%5D=c&amp;a%5B2%5D=d&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { arrayFormat: &#039;brackets&#039; }),
            &#039;a%5B%5D=b&amp;a%5B%5D=c&amp;a%5B%5D=d&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }),
            &#039;a%5B0%5D=b&amp;a%5B1%5D=c&amp;a%5B2%5D=d&#039;,
            &#039;default =&gt; indices&#039;
        );
        st.end();
    });

    t.test(&#039;omits nulls when asked&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039;, c: null }, { skipNulls: true }), &#039;a=b&#039;);
        st.end();
    });

    t.test(&#039;omits nested nulls when asked&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039;, d: null } }, { skipNulls: true }), &#039;a%5Bb%5D=c&#039;);
        st.end();
    });

    t.test(&#039;omits array indices when asked&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { indices: false }), &#039;a=b&amp;a=c&amp;a=d&#039;);
        st.end();
    });

    t.test(&#039;stringifies a nested array value&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }, { arrayFormat: &#039;indices&#039; }), &#039;a%5Bb%5D%5B0%5D=c&amp;a%5Bb%5D%5B1%5D=d&#039;);
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }, { arrayFormat: &#039;brackets&#039; }), &#039;a%5Bb%5D%5B%5D=c&amp;a%5Bb%5D%5B%5D=d&#039;);
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }), &#039;a%5Bb%5D%5B0%5D=c&amp;a%5Bb%5D%5B1%5D=d&#039;);
        st.end();
    });

    t.test(&#039;stringifies a nested array value with dots notation&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encode: false, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a.b[0]=c&amp;a.b[1]=d&#039;,
            &#039;indices: stringifies with dots + indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encode: false, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a.b[]=c&amp;a.b[]=d&#039;,
            &#039;brackets: stringifies with dots + brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encode: false }
            ),
            &#039;a.b[0]=c&amp;a.b[1]=d&#039;,
            &#039;default: stringifies with dots + indices&#039;
        );
        st.end();
    });

    t.test(&#039;stringifies an object inside an array&#039;, function (st) {
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }, { arrayFormat: &#039;indices&#039; }),
            &#039;a%5B0%5D%5Bb%5D=c&#039;,
            &#039;indices =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }, { arrayFormat: &#039;brackets&#039; }),
            &#039;a%5B%5D%5Bb%5D=c&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }),
            &#039;a%5B0%5D%5Bb%5D=c&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: &#039;indices&#039; }),
            &#039;a%5B0%5D%5Bb%5D%5Bc%5D%5B0%5D=1&#039;,
            &#039;indices =&gt; indices&#039;
        );

        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: &#039;brackets&#039; }),
            &#039;a%5B%5D%5Bb%5D%5Bc%5D%5B%5D=1&#039;,
            &#039;brackets =&gt; brackets&#039;
        );

        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }),
            &#039;a%5B0%5D%5Bb%5D%5Bc%5D%5B0%5D=1&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;stringifies an array with mixed objects and primitives&#039;, function (st) {
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encode: false, arrayFormat: &#039;indices&#039; }),
            &#039;a[0][b]=1&amp;a[1]=2&amp;a[2]=3&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encode: false, arrayFormat: &#039;brackets&#039; }),
            &#039;a[][b]=1&amp;a[]=2&amp;a[]=3&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encode: false }),
            &#039;a[0][b]=1&amp;a[1]=2&amp;a[2]=3&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;stringifies an object inside an array with dots notation&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: [{ b: &#039;c&#039; }] },
                { allowDots: true, encode: false, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a[0].b=c&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: &#039;c&#039; }] },
                { allowDots: true, encode: false, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a[].b=c&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: &#039;c&#039; }] },
                { allowDots: true, encode: false }
            ),
            &#039;a[0].b=c&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a[0].b.c[0]=1&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a[].b.c[]=1&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false }
            ),
            &#039;a[0].b.c[0]=1&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;does not omit object keys when indices = false&#039;, function (st) {
        st.equal(qs.stringify({ a: [{ b: &#039;c&#039; }] }, { indices: false }), &#039;a%5Bb%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses indices notation for arrays when indices=true&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { indices: true }), &#039;a%5B0%5D=b&amp;a%5B1%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses indices notation for arrays when no arrayFormat is specified&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }), &#039;a%5B0%5D=b&amp;a%5B1%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses indices notation for arrays when no arrayFormat=indices&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { arrayFormat: &#039;indices&#039; }), &#039;a%5B0%5D=b&amp;a%5B1%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses repeat notation for arrays when no arrayFormat=repeat&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { arrayFormat: &#039;repeat&#039; }), &#039;a=b&amp;a=c&#039;);
        st.end();
    });

    t.test(&#039;uses brackets notation for arrays when no arrayFormat=brackets&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { arrayFormat: &#039;brackets&#039; }), &#039;a%5B%5D=b&amp;a%5B%5D=c&#039;);
        st.end();
    });

    t.test(&#039;stringifies a complicated object&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039;, d: &#039;e&#039; } }), &#039;a%5Bb%5D=c&amp;a%5Bd%5D=e&#039;);
        st.end();
    });

    t.test(&#039;stringifies an empty value&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;&#039; }), &#039;a=&#039;);
        st.equal(qs.stringify({ a: null }, { strictNullHandling: true }), &#039;a&#039;);

        st.equal(qs.stringify({ a: &#039;&#039;, b: &#039;&#039; }), &#039;a=&amp;b=&#039;);
        st.equal(qs.stringify({ a: null, b: &#039;&#039; }, { strictNullHandling: true }), &#039;a&amp;b=&#039;);

        st.equal(qs.stringify({ a: { b: &#039;&#039; } }), &#039;a%5Bb%5D=&#039;);
        st.equal(qs.stringify({ a: { b: null } }, { strictNullHandling: true }), &#039;a%5Bb%5D&#039;);
        st.equal(qs.stringify({ a: { b: null } }, { strictNullHandling: false }), &#039;a%5Bb%5D=&#039;);

        st.end();
    });

    t.test(&#039;stringifies a null object&#039;, { skip: !Object.create }, function (st) {
        var obj = Object.create(null);
        obj.a = &#039;b&#039;;
        st.equal(qs.stringify(obj), &#039;a=b&#039;);
        st.end();
    });

    t.test(&#039;returns an empty string for invalid input&#039;, function (st) {
        st.equal(qs.stringify(undefined), &#039;&#039;);
        st.equal(qs.stringify(false), &#039;&#039;);
        st.equal(qs.stringify(null), &#039;&#039;);
        st.equal(qs.stringify(&#039;&#039;), &#039;&#039;);
        st.end();
    });

    t.test(&#039;stringifies an object with a null object as a child&#039;, { skip: !Object.create }, function (st) {
        var obj = { a: Object.create(null) };

        obj.a.b = &#039;c&#039;;
        st.equal(qs.stringify(obj), &#039;a%5Bb%5D=c&#039;);
        st.end();
    });

    t.test(&#039;drops keys with a value of undefined&#039;, function (st) {
        st.equal(qs.stringify({ a: undefined }), &#039;&#039;);

        st.equal(qs.stringify({ a: { b: undefined, c: null } }, { strictNullHandling: true }), &#039;a%5Bc%5D&#039;);
        st.equal(qs.stringify({ a: { b: undefined, c: null } }, { strictNullHandling: false }), &#039;a%5Bc%5D=&#039;);
        st.equal(qs.stringify({ a: { b: undefined, c: &#039;&#039; } }), &#039;a%5Bc%5D=&#039;);
        st.end();
    });

    t.test(&#039;url encodes values&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }), &#039;a=b%20c&#039;);
        st.end();
    });

    t.test(&#039;stringifies a date&#039;, function (st) {
        var now = new Date();
        var str = &#039;a=&#039; + encodeURIComponent(now.toISOString());
        st.equal(qs.stringify({ a: now }), str);
        st.end();
    });

    t.test(&#039;stringifies the weird object from qs&#039;, function (st) {
        st.equal(qs.stringify({ &#039;my weird field&#039;: &#039;~q1!2&quot;\&#039;w$5&amp;7/z8)?&#039; }), &#039;my%20weird%20field=~q1%212%22%27w%245%267%2Fz8%29%3F&#039;);
        st.end();
    });

    t.test(&#039;skips properties that are part of the object prototype&#039;, function (st) {
        Object.prototype.crash = &#039;test&#039;;
        st.equal(qs.stringify({ a: &#039;b&#039; }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }), &#039;a%5Bb%5D=c&#039;);
        delete Object.prototype.crash;
        st.end();
    });

    t.test(&#039;stringifies boolean values&#039;, function (st) {
        st.equal(qs.stringify({ a: true }), &#039;a=true&#039;);
        st.equal(qs.stringify({ a: { b: true } }), &#039;a%5Bb%5D=true&#039;);
        st.equal(qs.stringify({ b: false }), &#039;b=false&#039;);
        st.equal(qs.stringify({ b: { c: false } }), &#039;b%5Bc%5D=false&#039;);
        st.end();
    });

    t.test(&#039;stringifies buffer values&#039;, function (st) {
        st.equal(qs.stringify({ a: SaferBuffer.from(&#039;test&#039;) }), &#039;a=test&#039;);
        st.equal(qs.stringify({ a: { b: SaferBuffer.from(&#039;test&#039;) } }), &#039;a%5Bb%5D=test&#039;);
        st.end();
    });

    t.test(&#039;stringifies an object using an alternative delimiter&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039;, c: &#039;d&#039; }, { delimiter: &#039;;&#039; }), &#039;a=b;c=d&#039;);
        st.end();
    });

    t.test(&#039;doesn\&#039;t blow up when Buffer global is missing&#039;, function (st) {
        var tempBuffer = global.Buffer;
        delete global.Buffer;
        var result = qs.stringify({ a: &#039;b&#039;, c: &#039;d&#039; });
        global.Buffer = tempBuffer;
        st.equal(result, &#039;a=b&amp;c=d&#039;);
        st.end();
    });

    t.test(&#039;selects properties when filter=array&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }, { filter: [&#039;a&#039;] }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: 1 }, { filter: [] }), &#039;&#039;);

        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: &#039;d&#039; }, c: &#039;f&#039; },
                { filter: [&#039;a&#039;, &#039;b&#039;, 0, 2], arrayFormat: &#039;indices&#039; }
            ),
            &#039;a%5Bb%5D%5B0%5D=1&amp;a%5Bb%5D%5B2%5D=3&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: &#039;d&#039; }, c: &#039;f&#039; },
                { filter: [&#039;a&#039;, &#039;b&#039;, 0, 2], arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a%5Bb%5D%5B%5D=1&amp;a%5Bb%5D%5B%5D=3&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: &#039;d&#039; }, c: &#039;f&#039; },
                { filter: [&#039;a&#039;, &#039;b&#039;, 0, 2] }
            ),
            &#039;a%5Bb%5D%5B0%5D=1&amp;a%5Bb%5D%5B2%5D=3&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;supports custom representations when filter=function&#039;, function (st) {
        var calls = 0;
        var obj = { a: &#039;b&#039;, c: &#039;d&#039;, e: { f: new Date(1257894000000) } };
        var filterFunc = function (prefix, value) {
            calls += 1;
            if (calls === 1) {
                st.equal(prefix, &#039;&#039;, &#039;prefix is empty&#039;);
                st.equal(value, obj);
            } else if (prefix === &#039;c&#039;) {
                return void 0;
            } else if (value instanceof Date) {
                st.equal(prefix, &#039;e[f]&#039;);
                return value.getTime();
            }
            return value;
        };

        st.equal(qs.stringify(obj, { filter: filterFunc }), &#039;a=b&amp;e%5Bf%5D=1257894000000&#039;);
        st.equal(calls, 5);
        st.end();
    });

    t.test(&#039;can disable uri encoding&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }, { encode: false }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }, { encode: false }), &#039;a[b]=c&#039;);
        st.equal(qs.stringify({ a: &#039;b&#039;, c: null }, { strictNullHandling: true, encode: false }), &#039;a=b&amp;c&#039;);
        st.end();
    });

    t.test(&#039;can sort the keys&#039;, function (st) {
        var sort = function (a, b) {
            return a.localeCompare(b);
        };
        st.equal(qs.stringify({ a: &#039;c&#039;, z: &#039;y&#039;, b: &#039;f&#039; }, { sort: sort }), &#039;a=c&amp;b=f&amp;z=y&#039;);
        st.equal(qs.stringify({ a: &#039;c&#039;, z: { j: &#039;a&#039;, i: &#039;b&#039; }, b: &#039;f&#039; }, { sort: sort }), &#039;a=c&amp;b=f&amp;z%5Bi%5D=b&amp;z%5Bj%5D=a&#039;);
        st.end();
    });

    t.test(&#039;can sort the keys at depth 3 or more too&#039;, function (st) {
        var sort = function (a, b) {
            return a.localeCompare(b);
        };
        st.equal(
            qs.stringify(
                { a: &#039;a&#039;, z: { zj: { zjb: &#039;zjb&#039;, zja: &#039;zja&#039; }, zi: { zib: &#039;zib&#039;, zia: &#039;zia&#039; } }, b: &#039;b&#039; },
                { sort: sort, encode: false }
            ),
            &#039;a=a&amp;b=b&amp;z[zi][zia]=zia&amp;z[zi][zib]=zib&amp;z[zj][zja]=zja&amp;z[zj][zjb]=zjb&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;a&#039;, z: { zj: { zjb: &#039;zjb&#039;, zja: &#039;zja&#039; }, zi: { zib: &#039;zib&#039;, zia: &#039;zia&#039; } }, b: &#039;b&#039; },
                { sort: null, encode: false }
            ),
            &#039;a=a&amp;z[zj][zjb]=zjb&amp;z[zj][zja]=zja&amp;z[zi][zib]=zib&amp;z[zi][zia]=zia&amp;b=b&#039;
        );
        st.end();
    });

    t.test(&#039;can stringify with custom encoding&#039;, function (st) {
        st.equal(qs.stringify({ Áúå: &#039;Â§ßÈò™Â∫ú&#039;, &#039;&#039;: &#039;&#039; }, {
            encoder: function (str) {
                if (str.length === 0) {
                    return &#039;&#039;;
                }
                var buf = iconv.encode(str, &#039;shiftjis&#039;);
                var result = [];
                for (var i = 0; i &lt; buf.length; ++i) {
                    result.push(buf.readUInt8(i).toString(16));
                }
                return &#039;%&#039; + result.join(&#039;%&#039;);
            }
        }), &#039;%8c%a7=%91%e5%8d%e3%95%7b&amp;=&#039;);
        st.end();
    });

    t.test(&#039;receives the default encoder as a second argument&#039;, function (st) {
        st.plan(2);
        qs.stringify({ a: 1 }, {
            encoder: function (str, defaultEncoder) {
                st.equal(defaultEncoder, utils.encode);
            }
        });
        st.end();
    });

    t.test(&#039;throws error with wrong encoder&#039;, function (st) {
        st[&#039;throws&#039;](function () {
            qs.stringify({}, { encoder: &#039;string&#039; });
        }, new TypeError(&#039;Encoder has to be a function.&#039;));
        st.end();
    });

    t.test(&#039;can use custom encoder for a buffer object&#039;, { skip: typeof Buffer === &#039;undefined&#039; }, function (st) {
        st.equal(qs.stringify({ a: SaferBuffer.from([1]) }, {
            encoder: function (buffer) {
                if (typeof buffer === &#039;string&#039;) {
                    return buffer;
                }
                return String.fromCharCode(buffer.readUInt8(0) + 97);
            }
        }), &#039;a=b&#039;);

        st.equal(qs.stringify({ a: SaferBuffer.from(&#039;a b&#039;) }, {
            encoder: function (buffer) {
                return buffer;
            }
        }), &#039;a=a b&#039;);
        st.end();
    });

    t.test(&#039;serializeDate option&#039;, function (st) {
        var date = new Date();
        st.equal(
            qs.stringify({ a: date }),
            &#039;a=&#039; + date.toISOString().replace(/:/g, &#039;%3A&#039;),
            &#039;default is toISOString&#039;
        );

        var mutatedDate = new Date();
        mutatedDate.toISOString = function () {
            throw new SyntaxError();
        };
        st[&#039;throws&#039;](function () {
            mutatedDate.toISOString();
        }, SyntaxError);
        st.equal(
            qs.stringify({ a: mutatedDate }),
            &#039;a=&#039; + Date.prototype.toISOString.call(mutatedDate).replace(/:/g, &#039;%3A&#039;),
            &#039;toISOString works even when method is not locally present&#039;
        );

        var specificDate = new Date(6);
        st.equal(
            qs.stringify(
                { a: specificDate },
                { serializeDate: function (d) { return d.getTime() * 7; } }
            ),
            &#039;a=42&#039;,
            &#039;custom serializeDate function called&#039;
        );

        st.end();
    });

    t.test(&#039;RFC 1738 spaces serialization&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }, { format: qs.formats.RFC1738 }), &#039;a=b+c&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: &#039;c d&#039; }, { format: qs.formats.RFC1738 }), &#039;a+b=c+d&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: SaferBuffer.from(&#039;a b&#039;) }, { format: qs.formats.RFC1738 }), &#039;a+b=a+b&#039;);
        st.end();
    });

    t.test(&#039;RFC 3986 spaces serialization&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }, { format: qs.formats.RFC3986 }), &#039;a=b%20c&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: &#039;c d&#039; }, { format: qs.formats.RFC3986 }), &#039;a%20b=c%20d&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: SaferBuffer.from(&#039;a b&#039;) }, { format: qs.formats.RFC3986 }), &#039;a%20b=a%20b&#039;);
        st.end();
    });

    t.test(&#039;Backward compatibility to RFC 3986&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }), &#039;a=b%20c&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: SaferBuffer.from(&#039;a b&#039;) }), &#039;a%20b=a%20b&#039;);
        st.end();
    });

    t.test(&#039;Edge cases and unknown formats&#039;, function (st) {
        [&#039;UFO1234&#039;, false, 1234, null, {}, []].forEach(
            function (format) {
                st[&#039;throws&#039;](
                    function () {
                        qs.stringify({ a: &#039;b c&#039; }, { format: format });
                    },
                    new TypeError(&#039;Unknown format option provided.&#039;)
                );
            }
        );
        st.end();
    });

    t.test(&#039;encodeValuesOnly&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e=f&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { encodeValuesOnly: true }
            ),
            &#039;a=b&amp;c[0]=d&amp;c[1]=e%3Df&amp;f[0][0]=g&amp;f[1][0]=h&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] }
            ),
            &#039;a=b&amp;c%5B0%5D=d&amp;c%5B1%5D=e&amp;f%5B0%5D%5B0%5D=g&amp;f%5B1%5D%5B0%5D=h&#039;
        );
        st.end();
    });

    t.test(&#039;encodeValuesOnly - strictNullHandling&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: { b: null } },
                { encodeValuesOnly: true, strictNullHandling: true }
            ),
            &#039;a[b]&#039;
        );
        st.end();
    });

    t.test(&#039;does not mutate the options argument&#039;, function (st) {
        var options = {};
        qs.stringify({}, options);
        st.deepEqual(options, {});
        st.end();
    });

    t.test(&#039;strictNullHandling works with custom filter&#039;, function (st) {
        var filter = function (prefix, value) {
            return value;
        };

        var options = { strictNullHandling: true, filter: filter };
        st.equal(qs.stringify({ key: null }, options), &#039;key&#039;);
        st.end();
    });

    t.test(&#039;strictNullHandling works with null serializeDate&#039;, function (st) {
        var serializeDate = function () {
            return null;
        };
        var options = { strictNullHandling: true, serializeDate: serializeDate };
        var date = new Date();
        st.equal(qs.stringify({ key: date }, options), &#039;key&#039;);
        st.end();
    });

    t.end();
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
