<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/wasm-sync/WasmChunkLoadingRuntimeModule.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/wasm-sync/WasmChunkLoadingRuntimeModule.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">414</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">35.17</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.08</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

&quot;use strict&quot;;

const RuntimeGlobals = require(&quot;../RuntimeGlobals&quot;);
const RuntimeModule = require(&quot;../RuntimeModule&quot;);
const Template = require(&quot;../Template&quot;);
const { compareModulesByIdentifier } = require(&quot;../util/comparators&quot;);
const WebAssemblyUtils = require(&quot;./WebAssemblyUtils&quot;);

/** @typedef {import(&quot;@webassemblyjs/ast&quot;).Signature} Signature */
/** @typedef {import(&quot;../Chunk&quot;)} Chunk */
/** @typedef {import(&quot;../ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;../ChunkGraph&quot;).ModuleId} ModuleId */
/** @typedef {import(&quot;../Compilation&quot;)} Compilation */
/** @typedef {import(&quot;../Module&quot;)} Module */
/** @typedef {import(&quot;../Module&quot;).ReadOnlyRuntimeRequirements} ReadOnlyRuntimeRequirements */
/** @typedef {import(&quot;../ModuleGraph&quot;)} ModuleGraph */
/** @typedef {import(&quot;../util/runtime&quot;).RuntimeSpec} RuntimeSpec */

// TODO webpack 6 remove the whole folder

// Get all wasm modules
/**
 * @param {ModuleGraph} moduleGraph the module graph
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {Chunk} chunk the chunk
 * @returns {Module[]} all wasm modules
 */
const getAllWasmModules = (moduleGraph, chunkGraph, chunk) =&gt; {
	const wasmModules = chunk.getAllAsyncChunks();
	const array = [];
	for (const chunk of wasmModules) {
		for (const m of chunkGraph.getOrderedChunkModulesIterable(
			chunk,
			compareModulesByIdentifier
		)) {
			if (m.type.startsWith(&quot;webassembly&quot;)) {
				array.push(m);
			}
		}
	}

	return array;
};

/**
 * generates the import object function for a module
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {Module} module the module
 * @param {boolean | undefined} mangle mangle imports
 * @param {string[]} declarations array where declarations are pushed to
 * @param {RuntimeSpec} runtime the runtime
 * @returns {string} source code
 */
const generateImportObject = (
	chunkGraph,
	module,
	mangle,
	declarations,
	runtime
) =&gt; {
	const moduleGraph = chunkGraph.moduleGraph;
	/** @type {Map&lt;string, string | number&gt;} */
	const waitForInstances = new Map();
	const properties = [];
	const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(
		moduleGraph,
		module,
		mangle
	);
	for (const usedDep of usedWasmDependencies) {
		const dep = usedDep.dependency;
		const importedModule = moduleGraph.getModule(dep);
		const exportName = dep.name;
		const usedName =
			importedModule &amp;&amp;
			moduleGraph
				.getExportsInfo(importedModule)
				.getUsedName(exportName, runtime);
		const description = dep.description;
		const direct = dep.onlyDirectImport;

		const module = usedDep.module;
		const name = usedDep.name;

		if (direct) {
			const instanceVar = `m${waitForInstances.size}`;
			waitForInstances.set(
				instanceVar,
				/** @type {ModuleId} */
				(chunkGraph.getModuleId(/** @type {Module} */ (importedModule)))
			);
			properties.push({
				module,
				name,
				value: `${instanceVar}[${JSON.stringify(usedName)}]`
			});
		} else {
			const params =
				/** @type {Signature} */
				(description.signature).params.map(
					(param, k) =&gt; `p${k}${param.valtype}`
				);

			const mod = `${RuntimeGlobals.moduleCache}[${JSON.stringify(
				chunkGraph.getModuleId(/** @type {Module} */ (importedModule))
			)}]`;
			const modExports = `${mod}.exports`;

			const cache = `wasmImportedFuncCache${declarations.length}`;
			declarations.push(`var ${cache};`);

			const modCode =
				/** @type {Module} */
				(importedModule).type.startsWith(&quot;webassembly&quot;)
					? `${mod} ? ${modExports}[${JSON.stringify(usedName)}] : `
					: &quot;&quot;;

			properties.push({
				module,
				name,
				value: Template.asString([
					`${modCode}function(${params}) {`,
					Template.indent([
						`if(${cache} === undefined) ${cache} = ${modExports};`,
						`return ${cache}[${JSON.stringify(usedName)}](${params});`
					]),
					&quot;}&quot;
				])
			});
		}
	}

	let importObject;
	if (mangle) {
		importObject = [
			&quot;return {&quot;,
			Template.indent([
				properties.map(p =&gt; `${JSON.stringify(p.name)}: ${p.value}`).join(&quot;,\n&quot;)
			]),
			&quot;};&quot;
		];
	} else {
		/** @type {Map&lt;string, Array&lt;{ name: string, value: string }&gt;&gt;} */
		const propertiesByModule = new Map();
		for (const p of properties) {
			let list = propertiesByModule.get(p.module);
			if (list === undefined) {
				propertiesByModule.set(p.module, (list = []));
			}
			list.push(p);
		}
		importObject = [
			&quot;return {&quot;,
			Template.indent([
				Array.from(propertiesByModule, ([module, list]) =&gt;
					Template.asString([
						`${JSON.stringify(module)}: {`,
						Template.indent([
							list.map(p =&gt; `${JSON.stringify(p.name)}: ${p.value}`).join(&quot;,\n&quot;)
						]),
						&quot;}&quot;
					])
				).join(&quot;,\n&quot;)
			]),
			&quot;};&quot;
		];
	}

	const moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));
	if (waitForInstances.size === 1) {
		const moduleId = Array.from(waitForInstances.values())[0];
		const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;
		const variable = Array.from(waitForInstances.keys())[0];
		return Template.asString([
			`${moduleIdStringified}: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`,
				Template.indent(importObject),
				&quot;});&quot;
			]),
			&quot;},&quot;
		]);
	} else if (waitForInstances.size &gt; 0) {
		const promises = Array.from(
			waitForInstances.values(),
			id =&gt; `installedWasmModules[${JSON.stringify(id)}]`
		).join(&quot;, &quot;);
		const variables = Array.from(
			waitForInstances.keys(),
			(name, i) =&gt; `${name} = array[${i}]`
		).join(&quot;, &quot;);
		return Template.asString([
			`${moduleIdStringified}: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`,
				Template.indent([`var ${variables};`, ...importObject]),
				&quot;});&quot;
			]),
			&quot;},&quot;
		]);
	}
	return Template.asString([
		`${moduleIdStringified}: function() {`,
		Template.indent(importObject),
		&quot;},&quot;
	]);
};

/**
 * @typedef {object} WasmChunkLoadingRuntimeModuleOptions
 * @property {(path: string) =&gt; string} generateLoadBinaryCode
 * @property {boolean=} supportsStreaming
 * @property {boolean=} mangleImports
 * @property {ReadOnlyRuntimeRequirements} runtimeRequirements
 */

class WasmChunkLoadingRuntimeModule extends RuntimeModule {
	/**
	 * @param {WasmChunkLoadingRuntimeModuleOptions} options options
	 */
	constructor({
		generateLoadBinaryCode,
		supportsStreaming,
		mangleImports,
		runtimeRequirements
	}) {
		super(&quot;wasm chunk loading&quot;, RuntimeModule.STAGE_ATTACH);
		this.generateLoadBinaryCode = generateLoadBinaryCode;
		this.supportsStreaming = supportsStreaming;
		this.mangleImports = mangleImports;
		this._runtimeRequirements = runtimeRequirements;
	}

	/**
	 * @returns {string | null} runtime code
	 */
	generate() {
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withHmr = this._runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const compilation = /** @type {Compilation} */ (this.compilation);
		const { moduleGraph, outputOptions } = compilation;
		const chunkGraph = /** @type {ChunkGraph} */ (this.chunkGraph);
		const chunk = /** @type {Chunk} */ (this.chunk);
		const wasmModules = getAllWasmModules(moduleGraph, chunkGraph, chunk);
		const { mangleImports } = this;
		/** @type {string[]} */
		const declarations = [];
		const importObjects = wasmModules.map(module =&gt;
			generateImportObject(
				chunkGraph,
				module,
				mangleImports,
				declarations,
				chunk.runtime
			)
		);
		const chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, m =&gt;
			m.type.startsWith(&quot;webassembly&quot;)
		);
		/**
		 * @param {string} content content
		 * @returns {string} created import object
		 */
		const createImportObject = content =&gt;
			mangleImports
				? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }`
				: content;
		const wasmModuleSrcPath = compilation.getPath(
			JSON.stringify(outputOptions.webassemblyModuleFilename),
			{
				hash: `&quot; + ${RuntimeGlobals.getFullHash}() + &quot;`,
				hashWithLength: length =&gt;
					`&quot; + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + &quot;`,
				module: {
					id: &#039;&quot; + wasmModuleId + &quot;&#039;,
					hash: `&quot; + ${JSON.stringify(
						chunkGraph.getChunkModuleRenderedHashMap(chunk, m =&gt;
							m.type.startsWith(&quot;webassembly&quot;)
						)
					)}[chunkId][wasmModuleId] + &quot;`,
					hashWithLength(length) {
						return `&quot; + ${JSON.stringify(
							chunkGraph.getChunkModuleRenderedHashMap(
								chunk,
								m =&gt; m.type.startsWith(&quot;webassembly&quot;),
								length
							)
						)}[chunkId][wasmModuleId] + &quot;`;
					}
				},
				runtime: chunk.runtime
			}
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix}_wasm`
			: undefined;

		return Template.asString([
			&quot;// object to store loaded and loading wasm modules&quot;,
			`var installedWasmModules = ${
				stateExpression ? `${stateExpression} = ${stateExpression} || ` : &quot;&quot;
			}{};`,
			&quot;&quot;,
			// This function is used to delay reading the installed wasm module promises
			// by a microtask. Sorting them doesn&#039;t help because there are edge cases where
			// sorting is not possible (modules splitted into different chunks).
			// So we not even trying and solve this by a microtask delay.
			&quot;function promiseResolve() { return Promise.resolve(); }&quot;,
			&quot;&quot;,
			Template.asString(declarations),
			&quot;var wasmImportObjects = {&quot;,
			Template.indent(importObjects),
			&quot;};&quot;,
			&quot;&quot;,
			`var wasmModuleMap = ${JSON.stringify(
				chunkModuleIdMap,
				undefined,
				&quot;\t&quot;
			)};`,
			&quot;&quot;,
			&quot;// object with all WebAssembly.instance exports&quot;,
			`${RuntimeGlobals.wasmInstances} = {};`,
			&quot;&quot;,
			&quot;// Fetch + compile chunk loading for webassembly&quot;,
			`${fn}.wasm = function(chunkId, promises) {`,
			Template.indent([
				&quot;&quot;,
				&quot;var wasmModules = wasmModuleMap[chunkId] || [];&quot;,
				&quot;&quot;,
				&quot;wasmModules.forEach(function(wasmModuleId, idx) {&quot;,
				Template.indent([
					&quot;var installedWasmModuleData = installedWasmModules[wasmModuleId];&quot;,
					&quot;&quot;,
					&#039;// a Promise means &quot;currently loading&quot; or &quot;already loaded&quot;.&#039;,
					&quot;if(installedWasmModuleData)&quot;,
					Template.indent([&quot;promises.push(installedWasmModuleData);&quot;]),
					&quot;else {&quot;,
					Template.indent([
						&quot;var importObject = wasmImportObjects[wasmModuleId]();&quot;,
						`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`,
						&quot;var promise;&quot;,
						this.supportsStreaming
							? Template.asString([
									&quot;if(importObject &amp;&amp; typeof importObject.then === &#039;function&#039; &amp;&amp; typeof WebAssembly.compileStreaming === &#039;function&#039;) {&quot;,
									Template.indent([
										&quot;promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {&quot;,
										Template.indent([
											`return WebAssembly.instantiate(items[0], ${createImportObject(
												&quot;items[1]&quot;
											)});`
										]),
										&quot;});&quot;
									]),
									&quot;} else if(typeof WebAssembly.instantiateStreaming === &#039;function&#039;) {&quot;,
									Template.indent([
										`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(
											&quot;importObject&quot;
										)});`
									])
								])
							: Template.asString([
									&quot;if(importObject &amp;&amp; typeof importObject.then === &#039;function&#039;) {&quot;,
									Template.indent([
										&quot;var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });&quot;,
										&quot;promise = Promise.all([&quot;,
										Template.indent([
											&quot;bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),&quot;,
											&quot;importObject&quot;
										]),
										&quot;]).then(function(items) {&quot;,
										Template.indent([
											`return WebAssembly.instantiate(items[0], ${createImportObject(
												&quot;items[1]&quot;
											)});`
										]),
										&quot;});&quot;
									])
								]),
						&quot;} else {&quot;,
						Template.indent([
							&quot;var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });&quot;,
							&quot;promise = bytesPromise.then(function(bytes) {&quot;,
							Template.indent([
								`return WebAssembly.instantiate(bytes, ${createImportObject(
									&quot;importObject&quot;
								)});`
							]),
							&quot;});&quot;
						]),
						&quot;}&quot;,
						&quot;promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {&quot;,
						Template.indent([
							`return ${RuntimeGlobals.wasmInstances}[wasmModuleId] = (res.instance || res).exports;`
						]),
						&quot;}));&quot;
					]),
					&quot;}&quot;
				]),
				&quot;});&quot;
			]),
			&quot;};&quot;
		]);
	}
}

module.exports = WasmChunkLoadingRuntimeModule;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
