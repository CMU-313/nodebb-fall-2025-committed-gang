<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/node-jose/lib/jwe/encrypt.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/node-jose/lib/jwe/encrypt.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">678</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.18</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * jwe/encrypt.js - Encrypt to a JWE
 *
 * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
 */
&quot;use strict&quot;;

var util = require(&quot;../util&quot;),
    generateCEK = require(&quot;./helpers&quot;).generateCEK,
    JWK = require(&quot;../jwk&quot;),
    slice = require(&quot;./helpers&quot;).slice,
    pako = require(&quot;pako&quot;),
    CONSTANTS = require(&quot;../algorithms/constants&quot;);

var assign = require(&quot;lodash/assign&quot;);
var clone = require(&quot;lodash/clone&quot;);
var DEFAULTS = require(&quot;./defaults&quot;);

/**
 * @class JWE.Encrypter
 * @classdesc
 * Generator of encrypted data.
 *
 * @description
 * **NOTE:** This class cannot be instantiated directly. Instead call {@link
 * JWE.createEncrypt}.
 */
function JWEEncrypter(cfg, fields, recipients) {
  var finalized = false,
    format = cfg.format || &quot;general&quot;,
    protectAll = !!cfg.protectAll,
    content = Buffer.alloc(0);

  /**
   * @member {String} JWE.Encrypter#zip
   * @readonly
   * @description
   * Indicates the compression algorithm applied to the plaintext
   * before it is encrypted.  The possible values are:
   *
   * + **`&quot;DEF&quot;`**: Compress the plaintext using the DEFLATE algorithm.
   * + **`&quot;&quot;`**: Do not compress the plaintext.
   */
  Object.defineProperty(this, &quot;zip&quot;, {
    get: function() {
      return fields.zip || &quot;&quot;;
    },
    enumerable: true
  });
  /**
   * @member {Boolean} JWE.Encrypter#compact
   * @readonly
   * @description
   * Indicates whether the output of this encryption generator is
   * using the Compact serialization (`true`) or the JSON
   * serialization (`false`).
   */
  Object.defineProperty(this, &quot;compact&quot;, {
    get: function() { return &quot;compact&quot; === format; },
    enumerable: true
  });
  /**
   * @member {String} JWE.Encrypter#format
   * @readonly
   * @description
   * Indicates the format the output of this encryption generator takes.
   */
  Object.defineProperty(this, &quot;format&quot;, {
    get: function() { return format; },
    enumerable: true
  });
  /**
   * @member {String[]} JWE.Encrypter#protected
   * @readonly
   * @description
   * The header parameter names that are protected. Protected header fields
   * are first serialized to UTF-8 then encoded as util.base64url, then used as
   * the additional authenticated data in the encryption operation.
   */
  Object.defineProperty(this, &quot;protected&quot;, {
    get: function() {
      return clone(cfg.protect);
    },
    enumerable: true
  });
  /**
   * @member {Object} JWE.Encrypter#header
   * @readonly
   * @description
   * The global header parameters, both protected and unprotected. Call
   * {@link JWE.Encrypter#protected} to determine which parameters will
   * be protected.
   */
  Object.defineProperty(this, &quot;header&quot;, {
    get: function() {
      return clone(fields);
    },
    enumerable: true
  });

  /**
   * @method JWE.Encrypter#update
   * @description
   * Updates the plaintext data for the encryption generator. The plaintext
   * is appended to the end of any other plaintext already applied.
   *
   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is
   * converted to a Buffer internally to {encoding}.
   *
   * @param {Buffer|String} [data] The plaintext to apply.
   * @param {String} [encoding] The encoding of the plaintext.
   * @returns {JWE.Encrypter} This encryption generator.
   * @throws {Error} If ciphertext has already been generated.
   */
  Object.defineProperty(this, &quot;update&quot;, {
    value: function(data, encoding) {
      if (finalized) {
        throw new Error(&quot;already final&quot;);
      }
      if (data != null) {
        data = util.asBuffer(data, encoding);
        if (content.length) {
          content = Buffer.concat([content, data],
                      content.length + data.length);
        } else {
          content = data;
        }
      }

      return this;
    }
  });
  /**
   * @method JWE.Encrypter#final
   * @description
   * Finishes the encryption operation.
   *
   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)
   * object, either in the Compact (if {@link JWE.Encrypter#compact} is
   * `true`) or the JSON serialization.
   *
   * @param {Buffer|String} [data] The final plaintext data to apply.
   * @param {String} [encoding] The encoding of the final plaintext data
   *        (if any).
   * @returns {Promise} A promise for the encryption operation.
   * @throws {Error} If ciphertext has already been generated.
   */
  Object.defineProperty(this, &quot;final&quot;, {
    value: function(data, encoding) {
      if (finalized) {
        return Promise.reject(new Error(&quot;already final&quot;));
      }

      // last-minute data
      this.update(data, encoding);

      // mark as done...ish
      finalized = true;
      var promise = Promise.resolve({});

      // determine CEK and IV
      var encAlg = fields.enc;
      var encKey;
      promise = promise.then(function(jwe) {
        if (cfg.cek) {
          encKey = JWK.asKey(cfg.cek);
        }
        return jwe;
      });

      // process recipients
      promise = promise.then(function(jwe) {
        var procR = function(r, one) {
          var props = {};
          props = assign(props, fields);
          props = assign(props, r.header);

          var algKey = r.key,
              algAlg = props.alg;

          // generate Ephemeral EC Key
          var tks,
              rpromise;
          if ((props.alg || &quot;&quot;).indexOf(&quot;ECDH-ES&quot;) === 0) {
            tks = algKey.keystore.temp();
            if (r.epk) {
              rpromise = Promise.resolve(r.epk).
                then(function(epk) {
                  r.header.epk = epk.toJSON(false, [&quot;kid&quot;]);
                  props.epk = epk.toObject(true, [&quot;kid&quot;]);
                });
            } else {
              rpromise = tks.generate(&quot;EC&quot;, algKey.get(&quot;crv&quot;)).
                then(function(epk) {
                  r.header.epk = epk.toJSON(false, [&quot;kid&quot;]);
                  props.epk = epk.toObject(true, [&quot;kid&quot;]);
                });
            }
          } else {
            rpromise = Promise.resolve();
          }

          // encrypt the CEK
          rpromise = rpromise.then(function() {
            var cek,
                p;
            // special case &#039;alg=dir&#039;
            if (&quot;dir&quot; === algAlg &amp;&amp; one) {
              encKey = Promise.resolve(algKey);
              p = encKey.then(function(jwk) {
                // fixup encAlg
                if (!encAlg) {
                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];
                }
                return {
                  once: true,
                  direct: true
                };
              });
            } else {
              if (!encKey) {
                if (!encAlg) {
                  props.enc = fields.enc = encAlg = cfg.contentAlg;
                }
                encKey = generateCEK(encAlg);
              }
              p = encKey.then(function(jwk) {
                cek = jwk.get(&quot;k&quot;, true);
                // algKey may or may not be a promise
                return algKey;
              });
              p = p.then(function(algKey) {
                return algKey.wrap(algAlg, cek, props);
              });
            }
            return p;
          });
          rpromise = rpromise.then(function(wrapped) {
            if (wrapped.once &amp;&amp; !one) {
              return Promise.reject(new Error(&quot;cannot use &#039;alg&#039;:&#039;&quot; + algAlg + &quot;&#039; with multiple recipients&quot;));
            }

            var rjwe = {},
                cek;
            if (wrapped.data) {
              cek = wrapped.data;
              cek = util.base64url.encode(cek);
            }

            if (wrapped.direct &amp;&amp; cek) {
              // replace content key
              encKey = JWK.asKey({
                kty: &quot;oct&quot;,
                k: cek
              });
            } else if (cek) {
              /* eslint camelcase: [0] */
              rjwe.encrypted_key = cek;
            }

            if (r.header &amp;&amp; Object.keys(r.header).length) {
              rjwe.header = clone(r.header || {});
            }
            if (wrapped.header) {
              rjwe.header = assign(rjwe.header || {},
                                     wrapped.header);
            }

            return rjwe;
           });
           return rpromise;
        };

        var p = Promise.all(recipients);
        p = p.then(function(rcpts) {
          var single = (1 === rcpts.length);
          rcpts = rcpts.map(function(r) {
            return procR(r, single);
          });
          return Promise.all(rcpts);
        });
        p = p.then(function(rcpts) {
          jwe.recipients = rcpts.filter(function(r) { return !!r; });
          return jwe;
        });
        return p;
      });

      // normalize headers
      var props = {};
      promise = promise.then(function(jwe) {
        var protect,
          lenProtect,
          unprotect,
          lenUnprotect;

        unprotect = clone(fields);
        if ((protectAll &amp;&amp; jwe.recipients.length === 1) || &quot;compact&quot; === format) {
          // merge single recipient into fields
          protect = {};
          protect = assign({},
                     unprotect,
                    jwe.recipients[0].header);
          lenProtect = Object.keys(protect).length;

          unprotect = undefined;
          lenUnprotect = 0;

          delete jwe.recipients[0].header;
          if (Object.keys(jwe.recipients[0]).length === 0) {
            jwe.recipients.splice(0, 1);
          }
        } else {
          protect = {};
          lenProtect = 0;
          lenUnprotect = Object.keys(unprotect).length;
          cfg.protect.forEach(function(f) {
            // remove protected header values from body unprotected header
            if (!(f in unprotect)) {
              return;
            }
            protect[f] = unprotect[f];
            lenProtect++;

            delete unprotect[f];
            lenUnprotect--;
          });

          jwe.recipients = (jwe.recipients || []).map(function(rcpt) {
            rcpt = rcpt || {};
            var header = rcpt.header;
            if (header) {
              Object.keys(header).forEach(function (f) {
                if (f in protect) { delete header[f]; }
              });
              if (!Object.keys(header).length) {
                delete rcpt.header;
              }
            }
            return rcpt;
          });
        }

        if (!jwe.recipients || jwe.recipients.length === 0) {
          delete jwe.recipients;
        }

        // &quot;serialize&quot; (and setup merged props)
        if (unprotect &amp;&amp; lenUnprotect &gt; 0) {
          props = assign(props, unprotect);
          jwe.unprotected = unprotect;
        }
        if (protect &amp;&amp; lenProtect &gt; 0) {
          props = assign(props, protect);
          protect = JSON.stringify(protect);
          jwe.protected = util.base64url.encode(protect, &quot;utf8&quot;);
        }

        return jwe;
      });

      // (OPTIONAL) compress plaintext
      promise = promise.then(function(jwe) {
        var pdata = content;
        if (!props.zip) {
          jwe.plaintext = pdata;
          return jwe;
        } else if (props.zip === &quot;DEF&quot;) {
          return new Promise(function(resolve, reject) {
            try {
              var data = pako.deflateRaw(Buffer.from(pdata, &quot;binary&quot;));

              jwe.plaintext = Buffer.from(data);
              resolve(jwe);
            } catch (error) {
              reject(error);
            }
          });
        }
        return Promise.reject(new Error(&quot;unsupported &#039;zip&#039; mode&quot;));
      });

      // encrypt plaintext
      promise = promise.then(function(jwe) {
        props.adata = jwe.protected;
        if (&quot;aad&quot; in cfg &amp;&amp; cfg.aad != null) {
          props.adata += &quot;.&quot; + cfg.aad;
          props.adata = Buffer.from(props.adata, &quot;utf8&quot;);
        }
        // calculate IV
        var iv = cfg.iv ||
                 util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);
        if (&quot;string&quot; === typeof iv) {
          iv = util.base64url.decode(iv);
        }
        props.iv = iv;

        if (&quot;recipients&quot; in jwe &amp;&amp; jwe.recipients.length === 1) {
          props.kdata = jwe.recipients[0].encrypted_key;
        }

        if (&quot;epu&quot; in cfg &amp;&amp; cfg.epu != null) {
          props.epu = cfg.epu;
        }

        if (&quot;epv&quot; in cfg &amp;&amp; cfg.epv != null) {
          props.epv = cfg.epv;
        }

        var pdata = jwe.plaintext;
        delete jwe.plaintext;
        return encKey.then(function(encKey) {
          var p = encKey.encrypt(encAlg, pdata, props);
          p = p.then(function(result) {
            jwe.iv = util.base64url.encode(iv, &quot;binary&quot;);
            if (&quot;aad&quot; in cfg &amp;&amp; cfg.aad != null) {
             jwe.aad = cfg.aad;
            }
            jwe.ciphertext = util.base64url.encode(result.data, &quot;binary&quot;);
            jwe.tag = util.base64url.encode(result.tag, &quot;binary&quot;);
            return jwe;
          });
          return p;
        });
      });

      // (OPTIONAL) compact/flattened results
      switch (format) {
        case &quot;compact&quot;:
          promise = promise.then(function(jwe) {
            var compact = new Array(5);

            compact[0] = jwe.protected;
            if (jwe.recipients &amp;&amp; jwe.recipients[0]) {
              compact[1] = jwe.recipients[0].encrypted_key;
            }

            compact[2] = jwe.iv;
            compact[3] = jwe.ciphertext;
            compact[4] = jwe.tag;
            compact = compact.join(&quot;.&quot;);

            return compact;
          });
          break;
        case &quot;flattened&quot;:
          promise = promise.then(function(jwe) {
            var flattened = {},
                rcpt = jwe.recipients &amp;&amp; jwe.recipients[0];

            if (jwe.protected) {
              flattened.protected = jwe.protected;
            }
            if (jwe.unprotected) {
              flattened.unprotected = jwe.unprotected;
            }
            [&quot;header&quot;, &quot;encrypted_key&quot;].forEach(function(f) {
              if (!rcpt) { return; }
              if (!(f in rcpt)) { return; }
              if (!rcpt[f]) { return; }
              if (&quot;object&quot; === typeof rcpt[f] &amp;&amp; !Object.keys(rcpt[f]).length) { return; }
              flattened[f] = rcpt[f];
            });
            if (jwe.aad) {
              flattened.aad = jwe.aad;
            }
            flattened.iv = jwe.iv;
            flattened.ciphertext = jwe.ciphertext;
            flattened.tag = jwe.tag;

            return flattened;
          });
          break;
        case &quot;general&quot;:
          promise = promise.then(function(jwe) {
            var recipients = jwe.recipients || [];
            recipients = recipients.map(function (rcpt) {
              if (!Object.keys(rcpt).length) { return undefined; }
              return rcpt;
            });
            recipients = recipients.filter(function (rcpt) { return !!rcpt; });
            if (recipients.length) {
              jwe.recipients = recipients;
            } else {
              delete jwe.recipients;
            }

            return jwe;
          });
      }

      return promise;
    }
  });
}

function createEncrypt(opts, rcpts) {
  // fixup recipients
  var options = opts,
    rcptStart = 1,
    rcptList = rcpts;

  if (arguments.length === 0) {
    throw new Error(&quot;at least one recipient must be provided&quot;);
  }
  if (arguments.length === 1) {
    // assume opts is the recipient list
    rcptList = opts;
    rcptStart = 0;
    options = {};
  } else if (JWK.isKey(opts) ||
        (opts &amp;&amp; &quot;kty&quot; in opts) ||
        (opts &amp;&amp; &quot;key&quot; in opts &amp;&amp;
        (JWK.isKey(opts.key) || &quot;kty&quot; in opts.key))) {
    rcptList = opts;
    rcptStart = 0;
    options = {};
  } else {
    options = clone(opts);
  }
  if (!Array.isArray(rcptList)) {
    rcptList = slice(arguments, rcptStart);
  }

  // fixup options
  options = assign(clone(DEFAULTS), options);

  // setup header fields
  var fields = clone(options.fields || {});
  if (options.zip) {
    fields.zip = (typeof options.zip === &quot;boolean&quot;) ?
           (options.zip ? &quot;DEF&quot; : false) :
           options.zip;
  }
  options.format = (options.compact ? &quot;compact&quot; : options.format) || &quot;general&quot;;
  switch (options.format) {
    case &quot;compact&quot;:
      if (&quot;aad&quot; in opts) {
        throw new Error(&quot;additional authenticated data cannot be used for compact serialization&quot;);
      }
      /* eslint no-fallthrough: [0] */
    case &quot;flattened&quot;:
      if (rcptList.length &gt; 1) {
        throw new Error(&quot;too many recipients for compact serialization&quot;);
      }
      break;
  }

  // note protected fields (globally)
  // protected fields are global only
  var protectAll = false;
  if (&quot;compact&quot; === options.format || &quot;*&quot; === options.protect) {
    protectAll = true;
    options.protect = Object.keys(fields).concat(&quot;enc&quot;);
  } else if (typeof options.protect === &quot;string&quot;) {
    options.protect = [options.protect];
  } else if (Array.isArray(options.protect)) {
    options.protect = options.protect.concat();
  } else if (!options.protect) {
    options.protect = [];
  } else {
    throw new Error(&quot;protect must be a list of fields&quot;);
  }

  if (protectAll &amp;&amp; 1 &lt; rcptList.length) {
    throw new Error(&quot;too many recipients to protect all header parameters&quot;);
  }

  rcptList = rcptList.map(function(r, idx) {
    var p;

    // resolve a key
    if (r &amp;&amp; &quot;kty&quot; in r) {
      p = JWK.asKey(r);
      p = p.then(function(k) {
        return {
          key: k
        };
      });
    } else if (r) {
      p = JWK.asKey(r.key);
      p = p.then(function(k) {
        return {
          header: r.header,
          reference: r.reference,
          key: k
        };
      });
    } else {
      p = Promise.reject(new Error(&quot;missing key for recipient &quot; + idx));
    }

    // convert ephemeral key (if present)
    if (r.epk) {
      p = p.then(function(recipient) {
        return JWK.asKey(r.epk).
          then(function(epk) {
            recipient.epk = epk;
            return recipient;
          });
      });
    }

    // resolve the complete recipient
    p = p.then(function(recipient) {
      var key = recipient.key;

      // prepare the recipient header
      var header = recipient.header || {};
      recipient.header = header;
      var props = {};
      props = assign(props, fields);
      props = assign(props, recipient.header);

      // ensure key protection algorithm is set
      if (!props.alg) {
        props.alg = key.algorithms(JWK.MODE_WRAP)[0];
        header.alg = props.alg;
      }
      if (!props.alg) {
        return Promise.reject(new Error(&quot;key not valid for encrypting to recipient &quot; + idx));
      }
      header.alg = props.alg;

      // determine the key reference
      var ref = recipient.reference;
      delete recipient.reference;
      if (undefined === ref) {
        // header already contains the key reference
        ref = [&quot;kid&quot;, &quot;jku&quot;, &quot;x5c&quot;, &quot;x5t&quot;, &quot;x5u&quot;].some(function(k) {
          return (k in header);
        });
        ref = !ref ? &quot;kid&quot; : null;
      } else if (&quot;boolean&quot; === typeof ref) {
        // explicit (positive | negative) request for key reference
        ref = ref ? &quot;kid&quot; : null;
      }
      var jwk;
      if (ref) {
        jwk = key.toJSON();
        if (&quot;jwk&quot; === ref) {
          if (&quot;oct&quot; === key.kty) {
            return Promise.reject(new Error(&quot;cannot embed key&quot;));
          }
          header.jwk = jwk;
        } else if (ref in jwk) {
          header[ref] = jwk[ref];
        }
      }

      // freeze recipient
      recipient = Object.freeze(recipient);
      return recipient;
    });

    return p;
  });

  // create and configure encryption
  var cfg = {
    aad: (&quot;aad&quot; in options) ? util.base64url.encode(options.aad || &quot;&quot;) : null,
    contentAlg: options.contentAlg,
    format: options.format,
    protect: options.protect,
    cek: options.cek,
    iv: options.iv,
    protectAll: protectAll
  };
  var enc = new JWEEncrypter(cfg, fields, rcptList);

  return enc;
}

module.exports = {
  encrypter: JWEEncrypter,
  createEncrypt: createEncrypt
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
