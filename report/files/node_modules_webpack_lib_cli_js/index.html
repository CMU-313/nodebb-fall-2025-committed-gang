<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/cli.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/cli.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">712</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">114.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const path = require(&quot;path&quot;);
const webpackSchema = require(&quot;../schemas/WebpackOptions.json&quot;);

/** @typedef {import(&quot;json-schema&quot;).JSONSchema4} JSONSchema4 */
/** @typedef {import(&quot;json-schema&quot;).JSONSchema6} JSONSchema6 */
/** @typedef {import(&quot;json-schema&quot;).JSONSchema7} JSONSchema7 */
/** @typedef {JSONSchema4 | JSONSchema6 | JSONSchema7} JSONSchema */
/** @typedef {JSONSchema &amp; { absolutePath: boolean, instanceof: string, cli: { helper?: boolean, exclude?: boolean, description?: string, negatedDescription?: string, resetDescription?: string } }} Schema */

// TODO add originPath to PathItem for better errors
/**
 * @typedef {object} PathItem
 * @property {Schema} schema the part of the schema
 * @property {string} path the path in the config
 */

/** @typedef {&quot;unknown-argument&quot; | &quot;unexpected-non-array-in-path&quot; | &quot;unexpected-non-object-in-path&quot; | &quot;multiple-values-unexpected&quot; | &quot;invalid-value&quot;} ProblemType */

/** @typedef {string | number | boolean | RegExp} Value */

/**
 * @typedef {object} Problem
 * @property {ProblemType} type
 * @property {string} path
 * @property {string} argument
 * @property {Value=} value
 * @property {number=} index
 * @property {string=} expected
 */

/**
 * @typedef {object} LocalProblem
 * @property {ProblemType} type
 * @property {string} path
 * @property {string=} expected
 */

/** @typedef {{ [key: string]: EnumValue }} EnumValueObject */
/** @typedef {EnumValue[]} EnumValueArray */
/** @typedef {string | number | boolean | EnumValueObject | EnumValueArray | null} EnumValue */

/**
 * @typedef {object} ArgumentConfig
 * @property {string=} description
 * @property {string=} negatedDescription
 * @property {string} path
 * @property {boolean} multiple
 * @property {&quot;enum&quot; | &quot;string&quot; | &quot;path&quot; | &quot;number&quot; | &quot;boolean&quot; | &quot;RegExp&quot; | &quot;reset&quot;} type
 * @property {EnumValue[]=} values
 */

/** @typedef {&quot;string&quot; | &quot;number&quot; | &quot;boolean&quot;} SimpleType */

/**
 * @typedef {object} Argument
 * @property {string | undefined} description
 * @property {SimpleType} simpleType
 * @property {boolean} multiple
 * @property {ArgumentConfig[]} configs
 */

/** @typedef {Record&lt;string, Argument&gt;} Flags */

/**
 * @param {Schema=} schema a json schema to create arguments for (by default webpack schema is used)
 * @returns {Flags} object of arguments
 */
const getArguments = (schema = webpackSchema) =&gt; {
	/** @type {Flags} */
	const flags = {};

	/**
	 * @param {string} input input
	 * @returns {string} result
	 */
	const pathToArgumentName = input =&gt;
		input
			.replace(/\./g, &quot;-&quot;)
			.replace(/\[\]/g, &quot;&quot;)
			.replace(
				/(\p{Uppercase_Letter}+|\p{Lowercase_Letter}|\d)(\p{Uppercase_Letter}+)/gu,
				&quot;$1-$2&quot;
			)
			.replace(/-?[^\p{Uppercase_Letter}\p{Lowercase_Letter}\d]+/gu, &quot;-&quot;)
			.toLowerCase();

	/**
	 * @param {string} path path
	 * @returns {Schema} schema part
	 */
	const getSchemaPart = path =&gt; {
		const newPath = path.split(&quot;/&quot;);

		let schemaPart = schema;

		for (let i = 1; i &lt; newPath.length; i++) {
			const inner = schemaPart[/** @type {keyof Schema} */ (newPath[i])];

			if (!inner) {
				break;
			}

			schemaPart = inner;
		}

		return schemaPart;
	};

	/**
	 * @param {PathItem[]} path path in the schema
	 * @returns {string | undefined} description
	 */
	const getDescription = path =&gt; {
		for (const { schema } of path) {
			if (schema.cli) {
				if (schema.cli.helper) continue;
				if (schema.cli.description) return schema.cli.description;
			}
			if (schema.description) return schema.description;
		}
	};

	/**
	 * @param {PathItem[]} path path in the schema
	 * @returns {string | undefined} negative description
	 */
	const getNegatedDescription = path =&gt; {
		for (const { schema } of path) {
			if (schema.cli) {
				if (schema.cli.helper) continue;
				if (schema.cli.negatedDescription) return schema.cli.negatedDescription;
			}
		}
	};

	/**
	 * @param {PathItem[]} path path in the schema
	 * @returns {string | undefined} reset description
	 */
	const getResetDescription = path =&gt; {
		for (const { schema } of path) {
			if (schema.cli) {
				if (schema.cli.helper) continue;
				if (schema.cli.resetDescription) return schema.cli.resetDescription;
			}
		}
	};

	/**
	 * @param {Schema} schemaPart schema
	 * @returns {Pick&lt;ArgumentConfig, &quot;type&quot; | &quot;values&quot;&gt; | undefined} partial argument config
	 */
	const schemaToArgumentConfig = schemaPart =&gt; {
		if (schemaPart.enum) {
			return {
				type: &quot;enum&quot;,
				values: schemaPart.enum
			};
		}
		switch (schemaPart.type) {
			case &quot;number&quot;:
				return {
					type: &quot;number&quot;
				};
			case &quot;string&quot;:
				return {
					type: schemaPart.absolutePath ? &quot;path&quot; : &quot;string&quot;
				};
			case &quot;boolean&quot;:
				return {
					type: &quot;boolean&quot;
				};
		}
		if (schemaPart.instanceof === &quot;RegExp&quot;) {
			return {
				type: &quot;RegExp&quot;
			};
		}
		return undefined;
	};

	/**
	 * @param {PathItem[]} path path in the schema
	 * @returns {void}
	 */
	const addResetFlag = path =&gt; {
		const schemaPath = path[0].path;
		const name = pathToArgumentName(`${schemaPath}.reset`);
		const description =
			getResetDescription(path) ||
			`Clear all items provided in &#039;${schemaPath}&#039; configuration. ${getDescription(
				path
			)}`;
		flags[name] = {
			configs: [
				{
					type: &quot;reset&quot;,
					multiple: false,
					description,
					path: schemaPath
				}
			],
			description: undefined,
			simpleType:
				/** @type {SimpleType} */
				(/** @type {unknown} */ (undefined)),
			multiple: /** @type {boolean} */ (/** @type {unknown} */ (undefined))
		};
	};

	/**
	 * @param {PathItem[]} path full path in schema
	 * @param {boolean} multiple inside of an array
	 * @returns {number} number of arguments added
	 */
	const addFlag = (path, multiple) =&gt; {
		const argConfigBase = schemaToArgumentConfig(path[0].schema);
		if (!argConfigBase) return 0;

		const negatedDescription = getNegatedDescription(path);
		const name = pathToArgumentName(path[0].path);
		/** @type {ArgumentConfig} */
		const argConfig = {
			...argConfigBase,
			multiple,
			description: getDescription(path),
			path: path[0].path
		};

		if (negatedDescription) {
			argConfig.negatedDescription = negatedDescription;
		}

		if (!flags[name]) {
			flags[name] = {
				configs: [],
				description: undefined,
				simpleType:
					/** @type {SimpleType} */
					(/** @type {unknown} */ (undefined)),
				multiple: /** @type {boolean} */ (/** @type {unknown} */ (undefined))
			};
		}

		if (
			flags[name].configs.some(
				item =&gt; JSON.stringify(item) === JSON.stringify(argConfig)
			)
		) {
			return 0;
		}

		if (
			flags[name].configs.some(
				item =&gt; item.type === argConfig.type &amp;&amp; item.multiple !== multiple
			)
		) {
			if (multiple) {
				throw new Error(
					`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`
				);
			}
			return 0;
		}

		flags[name].configs.push(argConfig);

		return 1;
	};

	// TODO support `not` and `if/then/else`
	// TODO support `const`, but we don&#039;t use it on our schema
	/**
	 * @param {Schema} schemaPart the current schema
	 * @param {string} schemaPath the current path in the schema
	 * @param {PathItem[]} path all previous visited schemaParts
	 * @param {string | null} inArray if inside of an array, the path to the array
	 * @returns {number} added arguments
	 */
	const traverse = (schemaPart, schemaPath = &quot;&quot;, path = [], inArray = null) =&gt; {
		while (schemaPart.$ref) {
			schemaPart = getSchemaPart(schemaPart.$ref);
		}

		const repetitions = path.filter(({ schema }) =&gt; schema === schemaPart);
		if (
			repetitions.length &gt;= 2 ||
			repetitions.some(({ path }) =&gt; path === schemaPath)
		) {
			return 0;
		}

		if (schemaPart.cli &amp;&amp; schemaPart.cli.exclude) return 0;

		/** @type {PathItem[]} */
		const fullPath = [{ schema: schemaPart, path: schemaPath }, ...path];

		let addedArguments = 0;

		addedArguments += addFlag(fullPath, Boolean(inArray));

		if (schemaPart.type === &quot;object&quot;) {
			if (schemaPart.properties) {
				for (const property of Object.keys(schemaPart.properties)) {
					addedArguments += traverse(
						/** @type {Schema} */
						(schemaPart.properties[property]),
						schemaPath ? `${schemaPath}.${property}` : property,
						fullPath,
						inArray
					);
				}
			}

			return addedArguments;
		}

		if (schemaPart.type === &quot;array&quot;) {
			if (inArray) {
				return 0;
			}
			if (Array.isArray(schemaPart.items)) {
				const i = 0;
				for (const item of schemaPart.items) {
					addedArguments += traverse(
						/** @type {Schema} */
						(item),
						`${schemaPath}.${i}`,
						fullPath,
						schemaPath
					);
				}

				return addedArguments;
			}

			addedArguments += traverse(
				/** @type {Schema} */
				(schemaPart.items),
				`${schemaPath}[]`,
				fullPath,
				schemaPath
			);

			if (addedArguments &gt; 0) {
				addResetFlag(fullPath);
				addedArguments++;
			}

			return addedArguments;
		}

		const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;

		if (maybeOf) {
			const items = maybeOf;

			for (let i = 0; i &lt; items.length; i++) {
				addedArguments += traverse(
					/** @type {Schema} */
					(items[i]),
					schemaPath,
					fullPath,
					inArray
				);
			}

			return addedArguments;
		}

		return addedArguments;
	};

	traverse(schema);

	// Summarize flags
	for (const name of Object.keys(flags)) {
		/** @type {Argument} */
		const argument = flags[name];
		argument.description = argument.configs.reduce((desc, { description }) =&gt; {
			if (!desc) return description;
			if (!description) return desc;
			if (desc.includes(description)) return desc;
			return `${desc} ${description}`;
		}, /** @type {string | undefined} */ (undefined));
		argument.simpleType =
			/** @type {SimpleType} */
			(
				argument.configs.reduce((t, argConfig) =&gt; {
					/** @type {SimpleType} */
					let type = &quot;string&quot;;
					switch (argConfig.type) {
						case &quot;number&quot;:
							type = &quot;number&quot;;
							break;
						case &quot;reset&quot;:
						case &quot;boolean&quot;:
							type = &quot;boolean&quot;;
							break;
						case &quot;enum&quot;: {
							const values =
								/** @type {NonNullable&lt;ArgumentConfig[&quot;values&quot;]&gt;} */
								(argConfig.values);

							if (values.every(v =&gt; typeof v === &quot;boolean&quot;)) type = &quot;boolean&quot;;
							if (values.every(v =&gt; typeof v === &quot;number&quot;)) type = &quot;number&quot;;
							break;
						}
					}
					if (t === undefined) return type;
					return t === type ? t : &quot;string&quot;;
				}, /** @type {SimpleType | undefined} */ (undefined))
			);
		argument.multiple = argument.configs.some(c =&gt; c.multiple);
	}

	return flags;
};

const cliAddedItems = new WeakMap();

/** @typedef {string | number} Property */

/**
 * @param {Configuration} config configuration
 * @param {string} schemaPath path in the config
 * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined
 * @returns {{ problem?: LocalProblem, object?: TODO, property?: Property, value?: EXPECTED_OBJECT | EXPECTED_ANY[] }} problem or object with property and value
 */
const getObjectAndProperty = (config, schemaPath, index = 0) =&gt; {
	if (!schemaPath) return { value: config };
	const parts = schemaPath.split(&quot;.&quot;);
	const property = /** @type {string} */ (parts.pop());
	let current = config;
	let i = 0;
	for (const part of parts) {
		const isArray = part.endsWith(&quot;[]&quot;);
		const name = isArray ? part.slice(0, -2) : part;
		let value = current[name];
		if (isArray) {
			if (value === undefined) {
				value = {};
				current[name] = [...Array.from({ length: index }), value];
				cliAddedItems.set(current[name], index + 1);
			} else if (!Array.isArray(value)) {
				return {
					problem: {
						type: &quot;unexpected-non-array-in-path&quot;,
						path: parts.slice(0, i).join(&quot;.&quot;)
					}
				};
			} else {
				let addedItems = cliAddedItems.get(value) || 0;
				while (addedItems &lt;= index) {
					value.push(undefined);
					addedItems++;
				}
				cliAddedItems.set(value, addedItems);
				const x = value.length - addedItems + index;
				if (value[x] === undefined) {
					value[x] = {};
				} else if (value[x] === null || typeof value[x] !== &quot;object&quot;) {
					return {
						problem: {
							type: &quot;unexpected-non-object-in-path&quot;,
							path: parts.slice(0, i).join(&quot;.&quot;)
						}
					};
				}
				value = value[x];
			}
		} else if (value === undefined) {
			value = current[name] = {};
		} else if (value === null || typeof value !== &quot;object&quot;) {
			return {
				problem: {
					type: &quot;unexpected-non-object-in-path&quot;,
					path: parts.slice(0, i).join(&quot;.&quot;)
				}
			};
		}
		current = value;
		i++;
	}
	const value = current[property];
	if (property.endsWith(&quot;[]&quot;)) {
		const name = property.slice(0, -2);
		const value = current[name];
		if (value === undefined) {
			current[name] = [...Array.from({ length: index }), undefined];
			cliAddedItems.set(current[name], index + 1);
			return { object: current[name], property: index, value: undefined };
		} else if (!Array.isArray(value)) {
			current[name] = [value, ...Array.from({ length: index }), undefined];
			cliAddedItems.set(current[name], index + 1);
			return { object: current[name], property: index + 1, value: undefined };
		}
		let addedItems = cliAddedItems.get(value) || 0;
		while (addedItems &lt;= index) {
			value.push(undefined);
			addedItems++;
		}
		cliAddedItems.set(value, addedItems);
		const x = value.length - addedItems + index;
		if (value[x] === undefined) {
			value[x] = {};
		} else if (value[x] === null || typeof value[x] !== &quot;object&quot;) {
			return {
				problem: {
					type: &quot;unexpected-non-object-in-path&quot;,
					path: schemaPath
				}
			};
		}
		return {
			object: value,
			property: x,
			value: value[x]
		};
	}
	return { object: current, property, value };
};

/**
 * @param {Configuration} config configuration
 * @param {string} schemaPath path in the config
 * @param {ParsedValue} value parsed value
 * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined
 * @returns {LocalProblem | null} problem or null for success
 */
const setValue = (config, schemaPath, value, index) =&gt; {
	const { problem, object, property } = getObjectAndProperty(
		config,
		schemaPath,
		index
	);
	if (problem) return problem;
	object[/** @type {Property} */ (property)] = value;
	return null;
};

/**
 * @param {ArgumentConfig} argConfig processing instructions
 * @param {Configuration} config configuration
 * @param {Value} value the value
 * @param {number | undefined} index the index if multiple values provided
 * @returns {LocalProblem | null} a problem if any
 */
const processArgumentConfig = (argConfig, config, value, index) =&gt; {
	if (index !== undefined &amp;&amp; !argConfig.multiple) {
		return {
			type: &quot;multiple-values-unexpected&quot;,
			path: argConfig.path
		};
	}
	const parsed = parseValueForArgumentConfig(argConfig, value);
	if (parsed === undefined) {
		return {
			type: &quot;invalid-value&quot;,
			path: argConfig.path,
			expected: getExpectedValue(argConfig)
		};
	}
	const problem = setValue(config, argConfig.path, parsed, index);
	if (problem) return problem;
	return null;
};

/**
 * @param {ArgumentConfig} argConfig processing instructions
 * @returns {string | undefined} expected message
 */
const getExpectedValue = argConfig =&gt; {
	switch (argConfig.type) {
		case &quot;boolean&quot;:
			return &quot;true | false&quot;;
		case &quot;RegExp&quot;:
			return &quot;regular expression (example: /ab?c*/)&quot;;
		case &quot;enum&quot;:
			return /** @type {NonNullable&lt;ArgumentConfig[&quot;values&quot;]&gt;} */ (
				argConfig.values
			)
				.map(v =&gt; `${v}`)
				.join(&quot; | &quot;);
		case &quot;reset&quot;:
			return &quot;true (will reset the previous value to an empty array)&quot;;
		default:
			return argConfig.type;
	}
};

/** @typedef {null | string | number | boolean | RegExp | EnumValue | []} ParsedValue */

/**
 * @param {ArgumentConfig} argConfig processing instructions
 * @param {Value} value the value
 * @returns {ParsedValue | undefined} parsed value
 */
const parseValueForArgumentConfig = (argConfig, value) =&gt; {
	switch (argConfig.type) {
		case &quot;string&quot;:
			if (typeof value === &quot;string&quot;) {
				return value;
			}
			break;
		case &quot;path&quot;:
			if (typeof value === &quot;string&quot;) {
				return path.resolve(value);
			}
			break;
		case &quot;number&quot;:
			if (typeof value === &quot;number&quot;) return value;
			if (typeof value === &quot;string&quot; &amp;&amp; /^[+-]?\d*(\.\d*)[eE]\d+$/) {
				const n = Number(value);
				if (!Number.isNaN(n)) return n;
			}
			break;
		case &quot;boolean&quot;:
			if (typeof value === &quot;boolean&quot;) return value;
			if (value === &quot;true&quot;) return true;
			if (value === &quot;false&quot;) return false;
			break;
		case &quot;RegExp&quot;:
			if (value instanceof RegExp) return value;
			if (typeof value === &quot;string&quot;) {
				// cspell:word yugi
				const match = /^\/(.*)\/([yugi]*)$/.exec(value);
				if (match &amp;&amp; !/[^\\]\//.test(match[1]))
					return new RegExp(match[1], match[2]);
			}
			break;
		case &quot;enum&quot;: {
			const values =
				/** @type {EnumValue[]} */
				(argConfig.values);
			if (values.includes(/** @type {Exclude&lt;Value, RegExp&gt;} */ (value)))
				return value;
			for (const item of values) {
				if (`${item}` === value) return item;
			}
			break;
		}
		case &quot;reset&quot;:
			if (value === true) return [];
			break;
	}
};

/** @typedef {TODO} Configuration */

/**
 * @param {Flags} args object of arguments
 * @param {Configuration} config configuration
 * @param {Record&lt;string, Value[]&gt;} values object with values
 * @returns {Problem[] | null} problems or null for success
 */
const processArguments = (args, config, values) =&gt; {
	/** @type {Problem[]} */
	const problems = [];
	for (const key of Object.keys(values)) {
		const arg = args[key];
		if (!arg) {
			problems.push({
				type: &quot;unknown-argument&quot;,
				path: &quot;&quot;,
				argument: key
			});
			continue;
		}
		/**
		 * @param {Value} value value
		 * @param {number | undefined} i index
		 */
		const processValue = (value, i) =&gt; {
			const currentProblems = [];
			for (const argConfig of arg.configs) {
				const problem = processArgumentConfig(argConfig, config, value, i);
				if (!problem) {
					return;
				}
				currentProblems.push({
					...problem,
					argument: key,
					value,
					index: i
				});
			}
			problems.push(...currentProblems);
		};
		const value = values[key];
		if (Array.isArray(value)) {
			for (let i = 0; i &lt; value.length; i++) {
				processValue(value[i], i);
			}
		} else {
			processValue(value, undefined);
		}
	}
	if (problems.length === 0) return null;
	return problems;
};

module.exports.getArguments = getArguments;
module.exports.processArguments = processArguments;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
