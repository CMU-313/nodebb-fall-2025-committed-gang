<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/enhanced-resolve/lib/CachedInputFileSystem.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/enhanced-resolve/lib/CachedInputFileSystem.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.73</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">678</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">126.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

// eslint-disable-next-line n/prefer-global/process
const { nextTick } = require(&quot;process&quot;);

/** @typedef {import(&quot;./Resolver&quot;).FileSystem} FileSystem */
/** @typedef {import(&quot;./Resolver&quot;).PathLike} PathLike */
/** @typedef {import(&quot;./Resolver&quot;).PathOrFileDescriptor} PathOrFileDescriptor */
/** @typedef {import(&quot;./Resolver&quot;).SyncFileSystem} SyncFileSystem */
/** @typedef {FileSystem &amp; SyncFileSystem} BaseFileSystem */

/**
 * @template T
 * @typedef {import(&quot;./Resolver&quot;).FileSystemCallback&lt;T&gt;} FileSystemCallback&lt;T&gt;
 */

/**
 * @param {string} path path
 * @returns {string} dirname
 */
const dirname = (path) =&gt; {
	let idx = path.length - 1;
	while (idx &gt;= 0) {
		const char = path.charCodeAt(idx);
		// slash or backslash
		if (char === 47 || char === 92) break;
		idx--;
	}
	if (idx &lt; 0) return &quot;&quot;;
	return path.slice(0, idx);
};

/**
 * @template T
 * @param {FileSystemCallback&lt;T&gt;[]} callbacks callbacks
 * @param {Error | null} err error
 * @param {T} result result
 */
const runCallbacks = (callbacks, err, result) =&gt; {
	if (callbacks.length === 1) {
		callbacks[0](err, result);
		callbacks.length = 0;
		return;
	}
	let error;
	for (const callback of callbacks) {
		try {
			callback(err, result);
		} catch (err) {
			if (!error) error = err;
		}
	}
	callbacks.length = 0;
	if (error) throw error;
};

// eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {Function} EXPECTED_FUNCTION */
// eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {any} EXPECTED_ANY */

class OperationMergerBackend {
	/**
	 * @param {EXPECTED_FUNCTION | undefined} provider async method in filesystem
	 * @param {EXPECTED_FUNCTION | undefined} syncProvider sync method in filesystem
	 * @param {BaseFileSystem} providerContext call context for the provider methods
	 */
	constructor(provider, syncProvider, providerContext) {
		this._provider = provider;
		this._syncProvider = syncProvider;
		this._providerContext = providerContext;
		this._activeAsyncOperations = new Map();

		this.provide = this._provider
			? // Comment to align jsdoc
				/**
				 * @param {PathLike | PathOrFileDescriptor} path path
				 * @param {object | FileSystemCallback&lt;EXPECTED_ANY&gt; | undefined} options options
				 * @param {FileSystemCallback&lt;EXPECTED_ANY&gt;=} callback callback
				 * @returns {EXPECTED_ANY} result
				 */
				(path, options, callback) =&gt; {
					if (typeof options === &quot;function&quot;) {
						callback =
							/** @type {FileSystemCallback&lt;EXPECTED_ANY&gt;} */
							(options);
						options = undefined;
					}
					if (
						typeof path !== &quot;string&quot; &amp;&amp;
						!Buffer.isBuffer(path) &amp;&amp;
						!(path instanceof URL) &amp;&amp;
						typeof path !== &quot;number&quot;
					) {
						/** @type {EXPECTED_FUNCTION} */
						(callback)(
							new TypeError(&quot;path must be a string, Buffer, URL or number&quot;),
						);
						return;
					}
					if (options) {
						return /** @type {EXPECTED_FUNCTION} */ (this._provider).call(
							this._providerContext,
							path,
							options,
							callback,
						);
					}
					let callbacks = this._activeAsyncOperations.get(path);
					if (callbacks) {
						callbacks.push(callback);
						return;
					}
					this._activeAsyncOperations.set(path, (callbacks = [callback]));
					/** @type {EXPECTED_FUNCTION} */
					(provider)(
						path,
						/**
						 * @param {Error} err error
						 * @param {EXPECTED_ANY} result result
						 */
						(err, result) =&gt; {
							this._activeAsyncOperations.delete(path);
							runCallbacks(callbacks, err, result);
						},
					);
				}
			: null;
		this.provideSync = this._syncProvider
			? // Comment to align jsdoc
				/**
				 * @param {PathLike | PathOrFileDescriptor} path path
				 * @param {object=} options options
				 * @returns {EXPECTED_ANY} result
				 */
				(path, options) =&gt;
					/** @type {EXPECTED_FUNCTION} */ (this._syncProvider).call(
						this._providerContext,
						path,
						options,
					)
			: null;
	}

	purge() {}

	purgeParent() {}
}

/*

IDLE:
	insert data: goto SYNC

SYNC:
	before provide: run ticks
	event loop tick: goto ASYNC_ACTIVE

ASYNC:
	timeout: run tick, goto ASYNC_PASSIVE

ASYNC_PASSIVE:
	before provide: run ticks

IDLE --[insert data]--&gt; SYNC --[event loop tick]--&gt; ASYNC_ACTIVE --[interval tick]-&gt; ASYNC_PASSIVE
                                                          ^                             |
                                                          +---------[insert data]-------+
*/

const STORAGE_MODE_IDLE = 0;
const STORAGE_MODE_SYNC = 1;
const STORAGE_MODE_ASYNC = 2;

/**
 * @callback Provide
 * @param {PathLike | PathOrFileDescriptor} path path
 * @param {EXPECTED_ANY} options options
 * @param {FileSystemCallback&lt;EXPECTED_ANY&gt;} callback callback
 * @returns {void}
 */

class CacheBackend {
	/**
	 * @param {number} duration max cache duration of items
	 * @param {EXPECTED_FUNCTION | undefined} provider async method
	 * @param {EXPECTED_FUNCTION | undefined} syncProvider sync method
	 * @param {BaseFileSystem} providerContext call context for the provider methods
	 */
	constructor(duration, provider, syncProvider, providerContext) {
		this._duration = duration;
		this._provider = provider;
		this._syncProvider = syncProvider;
		this._providerContext = providerContext;
		/** @type {Map&lt;string, FileSystemCallback&lt;EXPECTED_ANY&gt;[]&gt;} */
		this._activeAsyncOperations = new Map();
		/** @type {Map&lt;string, { err: Error | null, result?: EXPECTED_ANY, level: Set&lt;string&gt; }&gt;} */
		this._data = new Map();
		/** @type {Set&lt;string&gt;[]} */
		this._levels = [];
		for (let i = 0; i &lt; 10; i++) this._levels.push(new Set());
		for (let i = 5000; i &lt; duration; i += 500) this._levels.push(new Set());
		this._currentLevel = 0;
		this._tickInterval = Math.floor(duration / this._levels.length);
		/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */
		this._mode = STORAGE_MODE_IDLE;

		/** @type {NodeJS.Timeout | undefined} */
		this._timeout = undefined;
		/** @type {number | undefined} */
		this._nextDecay = undefined;

		// eslint-disable-next-line no-warning-comments
		// @ts-ignore
		this.provide = provider ? this.provide.bind(this) : null;
		// eslint-disable-next-line no-warning-comments
		// @ts-ignore
		this.provideSync = syncProvider ? this.provideSync.bind(this) : null;
	}

	/**
	 * @param {PathLike | PathOrFileDescriptor} path path
	 * @param {EXPECTED_ANY} options options
	 * @param {FileSystemCallback&lt;EXPECTED_ANY&gt;} callback callback
	 * @returns {void}
	 */
	provide(path, options, callback) {
		if (typeof options === &quot;function&quot;) {
			callback = options;
			options = undefined;
		}
		if (
			typeof path !== &quot;string&quot; &amp;&amp;
			!Buffer.isBuffer(path) &amp;&amp;
			!(path instanceof URL) &amp;&amp;
			typeof path !== &quot;number&quot;
		) {
			callback(new TypeError(&quot;path must be a string, Buffer, URL or number&quot;));
			return;
		}
		const strPath = typeof path !== &quot;string&quot; ? path.toString() : path;
		if (options) {
			return /** @type {EXPECTED_FUNCTION} */ (this._provider).call(
				this._providerContext,
				path,
				options,
				callback,
			);
		}

		// When in sync mode we can move to async mode
		if (this._mode === STORAGE_MODE_SYNC) {
			this._enterAsyncMode();
		}

		// Check in cache
		const cacheEntry = this._data.get(strPath);
		if (cacheEntry !== undefined) {
			if (cacheEntry.err) return nextTick(callback, cacheEntry.err);
			return nextTick(callback, null, cacheEntry.result);
		}

		// Check if there is already the same operation running
		let callbacks = this._activeAsyncOperations.get(strPath);
		if (callbacks !== undefined) {
			callbacks.push(callback);
			return;
		}
		this._activeAsyncOperations.set(strPath, (callbacks = [callback]));

		// Run the operation
		/** @type {EXPECTED_FUNCTION} */
		(this._provider).call(
			this._providerContext,
			path,
			/**
			 * @param {Error | null} err error
			 * @param {EXPECTED_ANY=} result result
			 */
			(err, result) =&gt; {
				this._activeAsyncOperations.delete(strPath);
				this._storeResult(strPath, err, result);

				// Enter async mode if not yet done
				this._enterAsyncMode();

				runCallbacks(
					/** @type {FileSystemCallback&lt;EXPECTED_ANY&gt;[]} */ (callbacks),
					err,
					result,
				);
			},
		);
	}

	/**
	 * @param {PathLike | PathOrFileDescriptor} path path
	 * @param {EXPECTED_ANY} options options
	 * @returns {EXPECTED_ANY} result
	 */
	provideSync(path, options) {
		if (
			typeof path !== &quot;string&quot; &amp;&amp;
			!Buffer.isBuffer(path) &amp;&amp;
			!(path instanceof URL) &amp;&amp;
			typeof path !== &quot;number&quot;
		) {
			throw new TypeError(&quot;path must be a string&quot;);
		}
		const strPath = typeof path !== &quot;string&quot; ? path.toString() : path;
		if (options) {
			return /** @type {EXPECTED_FUNCTION} */ (this._syncProvider).call(
				this._providerContext,
				path,
				options,
			);
		}

		// In sync mode we may have to decay some cache items
		if (this._mode === STORAGE_MODE_SYNC) {
			this._runDecays();
		}

		// Check in cache
		const cacheEntry = this._data.get(strPath);
		if (cacheEntry !== undefined) {
			if (cacheEntry.err) throw cacheEntry.err;
			return cacheEntry.result;
		}

		// Get all active async operations
		// This sync operation will also complete them
		const callbacks = this._activeAsyncOperations.get(strPath);
		this._activeAsyncOperations.delete(strPath);

		// Run the operation
		// When in idle mode, we will enter sync mode
		let result;
		try {
			result = /** @type {EXPECTED_FUNCTION} */ (this._syncProvider).call(
				this._providerContext,
				path,
			);
		} catch (err) {
			this._storeResult(strPath, /** @type {Error} */ (err), undefined);
			this._enterSyncModeWhenIdle();
			if (callbacks) {
				runCallbacks(callbacks, /** @type {Error} */ (err), undefined);
			}
			throw err;
		}
		this._storeResult(strPath, null, result);
		this._enterSyncModeWhenIdle();
		if (callbacks) {
			runCallbacks(callbacks, null, result);
		}
		return result;
	}

	/**
	 * @param {(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set&lt;string | URL | Buffer | number&gt;)=} what what to purge
	 */
	purge(what) {
		if (!what) {
			if (this._mode !== STORAGE_MODE_IDLE) {
				this._data.clear();
				for (const level of this._levels) {
					level.clear();
				}
				this._enterIdleMode();
			}
		} else if (
			typeof what === &quot;string&quot; ||
			Buffer.isBuffer(what) ||
			what instanceof URL ||
			typeof what === &quot;number&quot;
		) {
			const strWhat = typeof what !== &quot;string&quot; ? what.toString() : what;
			for (const [key, data] of this._data) {
				if (key.startsWith(strWhat)) {
					this._data.delete(key);
					data.level.delete(key);
				}
			}
			if (this._data.size === 0) {
				this._enterIdleMode();
			}
		} else {
			for (const [key, data] of this._data) {
				for (const item of what) {
					const strItem = typeof item !== &quot;string&quot; ? item.toString() : item;
					if (key.startsWith(strItem)) {
						this._data.delete(key);
						data.level.delete(key);
						break;
					}
				}
			}
			if (this._data.size === 0) {
				this._enterIdleMode();
			}
		}
	}

	/**
	 * @param {(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set&lt;string | URL | Buffer | number&gt;)=} what what to purge
	 */
	purgeParent(what) {
		if (!what) {
			this.purge();
		} else if (
			typeof what === &quot;string&quot; ||
			Buffer.isBuffer(what) ||
			what instanceof URL ||
			typeof what === &quot;number&quot;
		) {
			const strWhat = typeof what !== &quot;string&quot; ? what.toString() : what;
			this.purge(dirname(strWhat));
		} else {
			const set = new Set();
			for (const item of what) {
				const strItem = typeof item !== &quot;string&quot; ? item.toString() : item;
				set.add(dirname(strItem));
			}
			this.purge(set);
		}
	}

	/**
	 * @param {string} path path
	 * @param {Error | null} err error
	 * @param {EXPECTED_ANY} result result
	 */
	_storeResult(path, err, result) {
		if (this._data.has(path)) return;
		const level = this._levels[this._currentLevel];
		this._data.set(path, { err, result, level });
		level.add(path);
	}

	_decayLevel() {
		const nextLevel = (this._currentLevel + 1) % this._levels.length;
		const decay = this._levels[nextLevel];
		this._currentLevel = nextLevel;
		for (const item of decay) {
			this._data.delete(item);
		}
		decay.clear();
		if (this._data.size === 0) {
			this._enterIdleMode();
		} else {
			/** @type {number} */
			(this._nextDecay) += this._tickInterval;
		}
	}

	_runDecays() {
		while (
			/** @type {number} */ (this._nextDecay) &lt;= Date.now() &amp;&amp;
			this._mode !== STORAGE_MODE_IDLE
		) {
			this._decayLevel();
		}
	}

	_enterAsyncMode() {
		let timeout = 0;
		switch (this._mode) {
			case STORAGE_MODE_ASYNC:
				return;
			case STORAGE_MODE_IDLE:
				this._nextDecay = Date.now() + this._tickInterval;
				timeout = this._tickInterval;
				break;
			case STORAGE_MODE_SYNC:
				this._runDecays();
				// _runDecays may change the mode
				if (
					/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */
					(this._mode) === STORAGE_MODE_IDLE
				) {
					return;
				}
				timeout = Math.max(
					0,
					/** @type {number} */ (this._nextDecay) - Date.now(),
				);
				break;
		}
		this._mode = STORAGE_MODE_ASYNC;
		const ref = setTimeout(() =&gt; {
			this._mode = STORAGE_MODE_SYNC;
			this._runDecays();
		}, timeout);
		if (ref.unref) ref.unref();
		this._timeout = ref;
	}

	_enterSyncModeWhenIdle() {
		if (this._mode === STORAGE_MODE_IDLE) {
			this._mode = STORAGE_MODE_SYNC;
			this._nextDecay = Date.now() + this._tickInterval;
		}
	}

	_enterIdleMode() {
		this._mode = STORAGE_MODE_IDLE;
		this._nextDecay = undefined;
		if (this._timeout) clearTimeout(this._timeout);
	}
}

/**
 * @template {EXPECTED_FUNCTION} Provider
 * @template {EXPECTED_FUNCTION} AsyncProvider
 * @template FileSystem
 * @param {number} duration duration in ms files are cached
 * @param {Provider | undefined} provider provider
 * @param {AsyncProvider | undefined} syncProvider sync provider
 * @param {BaseFileSystem} providerContext provider context
 * @returns {OperationMergerBackend | CacheBackend} backend
 */
const createBackend = (duration, provider, syncProvider, providerContext) =&gt; {
	if (duration &gt; 0) {
		return new CacheBackend(duration, provider, syncProvider, providerContext);
	}
	return new OperationMergerBackend(provider, syncProvider, providerContext);
};

module.exports = class CachedInputFileSystem {
	/**
	 * @param {BaseFileSystem} fileSystem file system
	 * @param {number} duration duration in ms files are cached
	 */
	constructor(fileSystem, duration) {
		this.fileSystem = fileSystem;

		this._lstatBackend = createBackend(
			duration,
			this.fileSystem.lstat,
			this.fileSystem.lstatSync,
			this.fileSystem,
		);
		const lstat = this._lstatBackend.provide;
		this.lstat = /** @type {FileSystem[&quot;lstat&quot;]} */ (lstat);
		const lstatSync = this._lstatBackend.provideSync;
		this.lstatSync = /** @type {SyncFileSystem[&quot;lstatSync&quot;]} */ (lstatSync);

		this._statBackend = createBackend(
			duration,
			this.fileSystem.stat,
			this.fileSystem.statSync,
			this.fileSystem,
		);
		const stat = this._statBackend.provide;
		this.stat = /** @type {FileSystem[&quot;stat&quot;]} */ (stat);
		const statSync = this._statBackend.provideSync;
		this.statSync = /** @type {SyncFileSystem[&quot;statSync&quot;]} */ (statSync);

		this._readdirBackend = createBackend(
			duration,
			this.fileSystem.readdir,
			this.fileSystem.readdirSync,
			this.fileSystem,
		);
		const readdir = this._readdirBackend.provide;
		this.readdir = /** @type {FileSystem[&quot;readdir&quot;]} */ (readdir);
		const readdirSync = this._readdirBackend.provideSync;
		this.readdirSync = /** @type {SyncFileSystem[&quot;readdirSync&quot;]} */ (
			readdirSync
		);

		this._readFileBackend = createBackend(
			duration,
			this.fileSystem.readFile,
			this.fileSystem.readFileSync,
			this.fileSystem,
		);
		const readFile = this._readFileBackend.provide;
		this.readFile = /** @type {FileSystem[&quot;readFile&quot;]} */ (readFile);
		const readFileSync = this._readFileBackend.provideSync;
		this.readFileSync = /** @type {SyncFileSystem[&quot;readFileSync&quot;]} */ (
			readFileSync
		);

		this._readJsonBackend = createBackend(
			duration,
			// prettier-ignore
			this.fileSystem.readJson ||
				(this.readFile &amp;&amp;
					(
						/**
						 * @param {string} path path
						 * @param {FileSystemCallback&lt;EXPECTED_ANY&gt;} callback callback
						 */
						(path, callback) =&gt; {
							this.readFile(path, (err, buffer) =&gt; {
								if (err) return callback(err);
								if (!buffer || buffer.length === 0)
									{return callback(new Error(&quot;No file content&quot;));}
								let data;
								try {
									data = JSON.parse(buffer.toString(&quot;utf8&quot;));
								} catch (err_) {
									return callback(/** @type {Error} */ (err_));
								}
								callback(null, data);
							});
						})
				),
			// prettier-ignore
			this.fileSystem.readJsonSync ||
				(this.readFileSync &amp;&amp;
					(
						/**
						 * @param {string} path path
						 * @returns {EXPECTED_ANY} result
						 */
						(path) =&gt; {
							const buffer = this.readFileSync(path);
							const data = JSON.parse(buffer.toString(&quot;utf8&quot;));
							return data;
						}
				 )),
			this.fileSystem,
		);
		const readJson = this._readJsonBackend.provide;
		this.readJson = /** @type {FileSystem[&quot;readJson&quot;]} */ (readJson);
		const readJsonSync = this._readJsonBackend.provideSync;
		this.readJsonSync = /** @type {SyncFileSystem[&quot;readJsonSync&quot;]} */ (
			readJsonSync
		);

		this._readlinkBackend = createBackend(
			duration,
			this.fileSystem.readlink,
			this.fileSystem.readlinkSync,
			this.fileSystem,
		);
		const readlink = this._readlinkBackend.provide;
		this.readlink = /** @type {FileSystem[&quot;readlink&quot;]} */ (readlink);
		const readlinkSync = this._readlinkBackend.provideSync;
		this.readlinkSync = /** @type {SyncFileSystem[&quot;readlinkSync&quot;]} */ (
			readlinkSync
		);

		this._realpathBackend = createBackend(
			duration,
			this.fileSystem.realpath,
			this.fileSystem.realpathSync,
			this.fileSystem,
		);
		const realpath = this._realpathBackend.provide;
		this.realpath = /** @type {FileSystem[&quot;realpath&quot;]} */ (realpath);
		const realpathSync = this._realpathBackend.provideSync;
		this.realpathSync = /** @type {SyncFileSystem[&quot;realpathSync&quot;]} */ (
			realpathSync
		);
	}

	/**
	 * @param {(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set&lt;string | URL | Buffer | number&gt;)=} what what to purge
	 */
	purge(what) {
		this._statBackend.purge(what);
		this._lstatBackend.purge(what);
		this._readdirBackend.purgeParent(what);
		this._readFileBackend.purge(what);
		this._readlinkBackend.purge(what);
		this._readJsonBackend.purge(what);
		this._realpathBackend.purge(what);
	}
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
