<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - build/public/38416.aa135a15371f10ab5037.min.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>build/public/38416.aa135a15371f10ab5037.min.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1223</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">138.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.62</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(self.webpackChunknodebb = self.webpackChunknodebb || []).push([
	[38416],
	{
		38416: (Ie) =&gt; {
			var Z = { exports: {} };
			function J(e) {
				return (
					e instanceof Map
						? (e.clear =
								e.delete =
								e.set =
									function () {
										throw new Error(&quot;map is read-only&quot;);
									})
						: e instanceof Set &amp;&amp;
							(e.add =
								e.clear =
								e.delete =
									function () {
										throw new Error(&quot;set is read-only&quot;);
									}),
					Object.freeze(e),
					Object.getOwnPropertyNames(e).forEach(function (t) {
						var n = e[t];
						typeof n == &quot;object&quot; &amp;&amp; !Object.isFrozen(n) &amp;&amp; J(n);
					}),
					e
				);
			}
			((Z.exports = J), (Z.exports.default = J));
			var ve = Z.exports;
			class oe {
				constructor(t) {
					(t.data === void 0 &amp;&amp; (t.data = {}),
						(this.data = t.data),
						(this.isMatchIgnored = !1));
				}
				ignoreMatch() {
					this.isMatchIgnored = !0;
				}
			}
			function ae(e) {
				return e
					.replace(/&amp;/g, &quot;&amp;amp;&quot;)
					.replace(/&lt;/g, &quot;&amp;lt;&quot;)
					.replace(/&gt;/g, &quot;&amp;gt;&quot;)
					.replace(/&quot;/g, &quot;&amp;quot;&quot;)
					.replace(/&#039;/g, &quot;&amp;#x27;&quot;);
			}
			function N(e, ...t) {
				const n = Object.create(null);
				for (const f in e) n[f] = e[f];
				return (
					t.forEach(function (f) {
						for (const b in f) n[b] = f[b];
					}),
					n
				);
			}
			const Be = &quot;&lt;/span&gt;&quot;,
				le = (e) =&gt; !!e.kind,
				De = (e, { prefix: t }) =&gt; {
					if (e.includes(&quot;.&quot;)) {
						const n = e.split(&quot;.&quot;);
						return [
							`${t}${n.shift()}`,
							...n.map((f, b) =&gt; `${f}${&quot;_&quot;.repeat(b + 1)}`),
						].join(&quot; &quot;);
					}
					return `${t}${e}`;
				};
			class Le {
				constructor(t, n) {
					((this.buffer = &quot;&quot;),
						(this.classPrefix = n.classPrefix),
						t.walk(this));
				}
				addText(t) {
					this.buffer += ae(t);
				}
				openNode(t) {
					if (!le(t)) return;
					let n = t.kind;
					(t.sublanguage
						? (n = `language-${n}`)
						: (n = De(n, { prefix: this.classPrefix })),
						this.span(n));
				}
				closeNode(t) {
					le(t) &amp;&amp; (this.buffer += Be);
				}
				value() {
					return this.buffer;
				}
				span(t) {
					this.buffer += `&lt;span class=&quot;${t}&quot;&gt;`;
				}
			}
			class V {
				constructor() {
					((this.rootNode = { children: [] }), (this.stack = [this.rootNode]));
				}
				get top() {
					return this.stack[this.stack.length - 1];
				}
				get root() {
					return this.rootNode;
				}
				add(t) {
					this.top.children.push(t);
				}
				openNode(t) {
					const n = { kind: t, children: [] };
					(this.add(n), this.stack.push(n));
				}
				closeNode() {
					if (this.stack.length &gt; 1) return this.stack.pop();
				}
				closeAllNodes() {
					for (; this.closeNode(); );
				}
				toJSON() {
					return JSON.stringify(this.rootNode, null, 4);
				}
				walk(t) {
					return this.constructor._walk(t, this.rootNode);
				}
				static _walk(t, n) {
					return (
						typeof n == &quot;string&quot;
							? t.addText(n)
							: n.children &amp;&amp;
								(t.openNode(n),
								n.children.forEach((f) =&gt; this._walk(t, f)),
								t.closeNode(n)),
						t
					);
				}
				static _collapse(t) {
					typeof t != &quot;string&quot; &amp;&amp;
						t.children &amp;&amp;
						(t.children.every((n) =&gt; typeof n == &quot;string&quot;)
							? (t.children = [t.children.join(&quot;&quot;)])
							: t.children.forEach((n) =&gt; {
									V._collapse(n);
								}));
				}
			}
			class Ce extends V {
				constructor(t) {
					(super(), (this.options = t));
				}
				addKeyword(t, n) {
					t !== &quot;&quot; &amp;&amp; (this.openNode(n), this.addText(t), this.closeNode());
				}
				addText(t) {
					t !== &quot;&quot; &amp;&amp; this.add(t);
				}
				addSublanguage(t, n) {
					const f = t.root;
					((f.kind = n), (f.sublanguage = !0), this.add(f));
				}
				toHTML() {
					return new Le(this, this.options).value();
				}
				finalize() {
					return !0;
				}
			}
			function H(e) {
				return e ? (typeof e == &quot;string&quot; ? e : e.source) : null;
			}
			function ue(e) {
				return v(&quot;(?=&quot;, e, &quot;)&quot;);
			}
			function He(e) {
				return v(&quot;(?:&quot;, e, &quot;)*&quot;);
			}
			function Pe(e) {
				return v(&quot;(?:&quot;, e, &quot;)?&quot;);
			}
			function v(...e) {
				return e.map((n) =&gt; H(n)).join(&quot;&quot;);
			}
			function je(e) {
				const t = e[e.length - 1];
				return typeof t == &quot;object&quot; &amp;&amp; t.constructor === Object
					? (e.splice(e.length - 1, 1), t)
					: {};
			}
			function q(...e) {
				return (
					&quot;(&quot; + (je(e).capture ? &quot;&quot; : &quot;?:&quot;) + e.map((f) =&gt; H(f)).join(&quot;|&quot;) + &quot;)&quot;
				);
			}
			function fe(e) {
				return new RegExp(e.toString() + &quot;|&quot;).exec(&quot;&quot;).length - 1;
			}
			function Ue(e, t) {
				const n = e &amp;&amp; e.exec(t);
				return n &amp;&amp; n.index === 0;
			}
			const $e = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
			function Q(e, { joinWith: t }) {
				let n = 0;
				return e
					.map((f) =&gt; {
						n += 1;
						const b = n;
						let _ = H(f),
							c = &quot;&quot;;
						for (; _.length &gt; 0; ) {
							const s = $e.exec(_);
							if (!s) {
								c += _;
								break;
							}
							((c += _.substring(0, s.index)),
								(_ = _.substring(s.index + s[0].length)),
								s[0][0] === &quot;\\&quot; &amp;&amp; s[1]
									? (c += &quot;\\&quot; + String(Number(s[1]) + b))
									: ((c += s[0]), s[0] === &quot;(&quot; &amp;&amp; n++));
						}
						return c;
					})
					.map((f) =&gt; `(${f})`)
					.join(t);
			}
			const Ge = /\b\B/,
				ge = &quot;[a-zA-Z]\\w*&quot;,
				m = &quot;[a-zA-Z_]\\w*&quot;,
				he = &quot;\\b\\d+(\\.\\d+)?&quot;,
				de =
					&quot;(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)&quot;,
				pe = &quot;\\b(0b[01]+)&quot;,
				Ke =
					&quot;!|!=|!==|%|%=|&amp;|&amp;&amp;|&amp;=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|&lt;&lt;|&lt;&lt;=|&lt;=|&lt;|===|==|=|&gt;&gt;&gt;=|&gt;&gt;=|&gt;=|&gt;&gt;&gt;|&gt;&gt;|&gt;|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~&quot;,
				We = (e = {}) =&gt; {
					const t = /^#![ ]*\//;
					return (
						e.binary &amp;&amp; (e.begin = v(t, /.*\b/, e.binary, /\b.*/)),
						N(
							{
								scope: &quot;meta&quot;,
								begin: t,
								end: /$/,
								relevance: 0,
								&quot;on:begin&quot;: (n, f) =&gt; {
									n.index !== 0 &amp;&amp; f.ignoreMatch();
								},
							},
							e,
						)
					);
				},
				P = { begin: &quot;\\\\[\\s\\S]&quot;, relevance: 0 },
				ze = {
					scope: &quot;string&quot;,
					begin: &quot;&#039;&quot;,
					end: &quot;&#039;&quot;,
					illegal: &quot;\\n&quot;,
					contains: [P],
				},
				Fe = {
					scope: &quot;string&quot;,
					begin: &#039;&quot;&#039;,
					end: &#039;&quot;&#039;,
					illegal: &quot;\\n&quot;,
					contains: [P],
				},
				Xe = {
					begin:
						/\b(a|an|the|are|I&#039;m|isn&#039;t|don&#039;t|doesn&#039;t|won&#039;t|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
				},
				$ = function (e, t, n = {}) {
					const f = N({ scope: &quot;comment&quot;, begin: e, end: t, contains: [] }, n);
					f.contains.push({
						scope: &quot;doctag&quot;,
						begin: &quot;[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)&quot;,
						end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
						excludeBegin: !0,
						relevance: 0,
					});
					const b = q(
						&quot;I&quot;,
						&quot;a&quot;,
						&quot;is&quot;,
						&quot;so&quot;,
						&quot;us&quot;,
						&quot;to&quot;,
						&quot;at&quot;,
						&quot;if&quot;,
						&quot;in&quot;,
						&quot;it&quot;,
						&quot;on&quot;,
						/[A-Za-z]+[&#039;](d|ve|re|ll|t|s|n)/,
						/[A-Za-z]+[-][a-z]+/,
						/[A-Za-z][a-z]{2,}/,
					);
					return (
						f.contains.push({
							begin: v(/[ ]+/, &quot;(&quot;, b, /[.]?[:]?([.][ ]|[ ])/, &quot;){3}&quot;),
						}),
						f
					);
				},
				Ye = $(&quot;//&quot;, &quot;$&quot;),
				Ze = $(&quot;/\\*&quot;, &quot;\\*/&quot;),
				Je = $(&quot;#&quot;, &quot;$&quot;),
				Ve = { scope: &quot;number&quot;, begin: he, relevance: 0 },
				qe = { scope: &quot;number&quot;, begin: de, relevance: 0 },
				Qe = { scope: &quot;number&quot;, begin: pe, relevance: 0 },
				me = {
					begin: /(?=\/[^/\n]*\/)/,
					contains: [
						{
							scope: &quot;regexp&quot;,
							begin: /\//,
							end: /\/[gimuy]*/,
							illegal: /\n/,
							contains: [
								P,
								{ begin: /\[/, end: /\]/, relevance: 0, contains: [P] },
							],
						},
					],
				},
				et = { scope: &quot;title&quot;, begin: ge, relevance: 0 },
				tt = { scope: &quot;title&quot;, begin: m, relevance: 0 },
				nt = { begin: &quot;\\.\\s*&quot; + m, relevance: 0 };
			var G = Object.freeze({
				__proto__: null,
				MATCH_NOTHING_RE: Ge,
				IDENT_RE: ge,
				UNDERSCORE_IDENT_RE: m,
				NUMBER_RE: he,
				C_NUMBER_RE: de,
				BINARY_NUMBER_RE: pe,
				RE_STARTERS_RE: Ke,
				SHEBANG: We,
				BACKSLASH_ESCAPE: P,
				APOS_STRING_MODE: ze,
				QUOTE_STRING_MODE: Fe,
				PHRASAL_WORDS_MODE: Xe,
				COMMENT: $,
				C_LINE_COMMENT_MODE: Ye,
				C_BLOCK_COMMENT_MODE: Ze,
				HASH_COMMENT_MODE: Je,
				NUMBER_MODE: Ve,
				C_NUMBER_MODE: qe,
				BINARY_NUMBER_MODE: Qe,
				REGEXP_MODE: me,
				TITLE_MODE: et,
				UNDERSCORE_TITLE_MODE: tt,
				METHOD_GUARD: nt,
				END_SAME_AS_BEGIN: function (e) {
					return Object.assign(e, {
						&quot;on:begin&quot;: (t, n) =&gt; {
							n.data._beginMatch = t[1];
						},
						&quot;on:end&quot;: (t, n) =&gt; {
							n.data._beginMatch !== t[1] &amp;&amp; n.ignoreMatch();
						},
					});
				},
			});
			function it(e, t) {
				e.input[e.index - 1] === &quot;.&quot; &amp;&amp; t.ignoreMatch();
			}
			function rt(e, t) {
				e.className !== void 0 &amp;&amp; ((e.scope = e.className), delete e.className);
			}
			function st(e, t) {
				t &amp;&amp;
					e.beginKeywords &amp;&amp;
					((e.begin =
						&quot;\\b(&quot; +
						e.beginKeywords.split(&quot; &quot;).join(&quot;|&quot;) +
						&quot;)(?!\\.)(?=\\b|\\s)&quot;),
					(e.__beforeBegin = it),
					(e.keywords = e.keywords || e.beginKeywords),
					delete e.beginKeywords,
					e.relevance === void 0 &amp;&amp; (e.relevance = 0));
			}
			function ct(e, t) {
				Array.isArray(e.illegal) &amp;&amp; (e.illegal = q(...e.illegal));
			}
			function ot(e, t) {
				if (e.match) {
					if (e.begin || e.end)
						throw new Error(&quot;begin &amp; end are not supported with match&quot;);
					((e.begin = e.match), delete e.match);
				}
			}
			function at(e, t) {
				e.relevance === void 0 &amp;&amp; (e.relevance = 1);
			}
			const lt = (e, t) =&gt; {
					if (!e.beforeMatch) return;
					if (e.starts)
						throw new Error(&quot;beforeMatch cannot be used with starts&quot;);
					const n = Object.assign({}, e);
					(Object.keys(e).forEach((f) =&gt; {
						delete e[f];
					}),
						(e.keywords = n.keywords),
						(e.begin = v(n.beforeMatch, ue(n.begin))),
						(e.starts = {
							relevance: 0,
							contains: [Object.assign(n, { endsParent: !0 })],
						}),
						(e.relevance = 0),
						delete n.beforeMatch);
				},
				ut = [
					&quot;of&quot;,
					&quot;and&quot;,
					&quot;for&quot;,
					&quot;in&quot;,
					&quot;not&quot;,
					&quot;or&quot;,
					&quot;if&quot;,
					&quot;then&quot;,
					&quot;parent&quot;,
					&quot;list&quot;,
					&quot;value&quot;,
				],
				ft = &quot;keyword&quot;;
			function Ee(e, t, n = ft) {
				const f = Object.create(null);
				return (
					typeof e == &quot;string&quot;
						? b(n, e.split(&quot; &quot;))
						: Array.isArray(e)
							? b(n, e)
							: Object.keys(e).forEach(function (_) {
									Object.assign(f, Ee(e[_], t, _));
								}),
					f
				);
				function b(_, c) {
					(t &amp;&amp; (c = c.map((s) =&gt; s.toLowerCase())),
						c.forEach(function (s) {
							const l = s.split(&quot;|&quot;);
							f[l[0]] = [_, gt(l[0], l[1])];
						}));
				}
			}
			function gt(e, t) {
				return t ? Number(t) : ht(e) ? 0 : 1;
			}
			function ht(e) {
				return ut.includes(e.toLowerCase());
			}
			const be = {},
				B = (e) =&gt; {
					console.error(e);
				},
				_e = (e, ...t) =&gt; {
					console.log(`WARN: ${e}`, ...t);
				},
				L = (e, t) =&gt; {
					be[`${e}/${t}`] ||
						(console.log(`Deprecated as of ${e}. ${t}`),
						(be[`${e}/${t}`] = !0));
				},
				K = new Error();
			function we(e, t, { key: n }) {
				let f = 0;
				const b = e[n],
					_ = {},
					c = {};
				for (let s = 1; s &lt;= t.length; s++)
					((c[s + f] = b[s]), (_[s + f] = !0), (f += fe(t[s - 1])));
				((e[n] = c), (e[n]._emit = _), (e[n]._multi = !0));
			}
			function dt(e) {
				if (Array.isArray(e.begin)) {
					if (e.skip || e.excludeBegin || e.returnBegin)
						throw (
							B(
								&quot;skip, excludeBegin, returnBegin not compatible with beginScope: {}&quot;,
							),
							K
						);
					if (typeof e.beginScope != &quot;object&quot; || e.beginScope === null)
						throw (B(&quot;beginScope must be object&quot;), K);
					(we(e, e.begin, { key: &quot;beginScope&quot; }),
						(e.begin = Q(e.begin, { joinWith: &quot;&quot; })));
				}
			}
			function pt(e) {
				if (Array.isArray(e.end)) {
					if (e.skip || e.excludeEnd || e.returnEnd)
						throw (
							B(&quot;skip, excludeEnd, returnEnd not compatible with endScope: {}&quot;),
							K
						);
					if (typeof e.endScope != &quot;object&quot; || e.endScope === null)
						throw (B(&quot;endScope must be object&quot;), K);
					(we(e, e.end, { key: &quot;endScope&quot; }),
						(e.end = Q(e.end, { joinWith: &quot;&quot; })));
				}
			}
			function Et(e) {
				e.scope &amp;&amp;
					typeof e.scope == &quot;object&quot; &amp;&amp;
					e.scope !== null &amp;&amp;
					((e.beginScope = e.scope), delete e.scope);
			}
			function bt(e) {
				(Et(e),
					typeof e.beginScope == &quot;string&quot; &amp;&amp;
						(e.beginScope = { _wrap: e.beginScope }),
					typeof e.endScope == &quot;string&quot; &amp;&amp; (e.endScope = { _wrap: e.endScope }),
					dt(e),
					pt(e));
			}
			function _t(e) {
				function t(c, s) {
					return new RegExp(
						H(c),
						&quot;m&quot; +
							(e.case_insensitive ? &quot;i&quot; : &quot;&quot;) +
							(e.unicodeRegex ? &quot;u&quot; : &quot;&quot;) +
							(s ? &quot;g&quot; : &quot;&quot;),
					);
				}
				class n {
					constructor() {
						((this.matchIndexes = {}),
							(this.regexes = []),
							(this.matchAt = 1),
							(this.position = 0));
					}
					addRule(s, l) {
						((l.position = this.position++),
							(this.matchIndexes[this.matchAt] = l),
							this.regexes.push([l, s]),
							(this.matchAt += fe(s) + 1));
					}
					compile() {
						this.regexes.length === 0 &amp;&amp; (this.exec = () =&gt; null);
						const s = this.regexes.map((l) =&gt; l[1]);
						((this.matcherRe = t(Q(s, { joinWith: &quot;|&quot; }), !0)),
							(this.lastIndex = 0));
					}
					exec(s) {
						this.matcherRe.lastIndex = this.lastIndex;
						const l = this.matcherRe.exec(s);
						if (!l) return null;
						const x = l.findIndex((U, te) =&gt; te &gt; 0 &amp;&amp; U !== void 0),
							w = this.matchIndexes[x];
						return (l.splice(0, x), Object.assign(l, w));
					}
				}
				class f {
					constructor() {
						((this.rules = []),
							(this.multiRegexes = []),
							(this.count = 0),
							(this.lastIndex = 0),
							(this.regexIndex = 0));
					}
					getMatcher(s) {
						if (this.multiRegexes[s]) return this.multiRegexes[s];
						const l = new n();
						return (
							this.rules.slice(s).forEach(([x, w]) =&gt; l.addRule(x, w)),
							l.compile(),
							(this.multiRegexes[s] = l),
							l
						);
					}
					resumingScanAtSamePosition() {
						return this.regexIndex !== 0;
					}
					considerAll() {
						this.regexIndex = 0;
					}
					addRule(s, l) {
						(this.rules.push([s, l]), l.type === &quot;begin&quot; &amp;&amp; this.count++);
					}
					exec(s) {
						const l = this.getMatcher(this.regexIndex);
						l.lastIndex = this.lastIndex;
						let x = l.exec(s);
						if (
							this.resumingScanAtSamePosition() &amp;&amp;
							!(x &amp;&amp; x.index === this.lastIndex)
						) {
							const w = this.getMatcher(0);
							((w.lastIndex = this.lastIndex + 1), (x = w.exec(s)));
						}
						return (
							x &amp;&amp;
								((this.regexIndex += x.position + 1),
								this.regexIndex === this.count &amp;&amp; this.considerAll()),
							x
						);
					}
				}
				function b(c) {
					const s = new f();
					return (
						c.contains.forEach((l) =&gt;
							s.addRule(l.begin, { rule: l, type: &quot;begin&quot; }),
						),
						c.terminatorEnd &amp;&amp; s.addRule(c.terminatorEnd, { type: &quot;end&quot; }),
						c.illegal &amp;&amp; s.addRule(c.illegal, { type: &quot;illegal&quot; }),
						s
					);
				}
				function _(c, s) {
					const l = c;
					if (c.isCompiled) return l;
					([rt, ot, bt, lt].forEach((w) =&gt; w(c, s)),
						e.compilerExtensions.forEach((w) =&gt; w(c, s)),
						(c.__beforeBegin = null),
						[st, ct, at].forEach((w) =&gt; w(c, s)),
						(c.isCompiled = !0));
					let x = null;
					return (
						typeof c.keywords == &quot;object&quot; &amp;&amp;
							c.keywords.$pattern &amp;&amp;
							((c.keywords = Object.assign({}, c.keywords)),
							(x = c.keywords.$pattern),
							delete c.keywords.$pattern),
						(x = x || /\w+/),
						c.keywords &amp;&amp; (c.keywords = Ee(c.keywords, e.case_insensitive)),
						(l.keywordPatternRe = t(x, !0)),
						s &amp;&amp;
							(c.begin || (c.begin = /\B|\b/),
							(l.beginRe = t(l.begin)),
							!c.end &amp;&amp; !c.endsWithParent &amp;&amp; (c.end = /\B|\b/),
							c.end &amp;&amp; (l.endRe = t(l.end)),
							(l.terminatorEnd = H(l.end) || &quot;&quot;),
							c.endsWithParent &amp;&amp;
								s.terminatorEnd &amp;&amp;
								(l.terminatorEnd += (c.end ? &quot;|&quot; : &quot;&quot;) + s.terminatorEnd)),
						c.illegal &amp;&amp; (l.illegalRe = t(c.illegal)),
						c.contains || (c.contains = []),
						(c.contains = [].concat(
							...c.contains.map(function (w) {
								return wt(w === &quot;self&quot; ? c : w);
							}),
						)),
						c.contains.forEach(function (w) {
							_(w, l);
						}),
						c.starts &amp;&amp; _(c.starts, s),
						(l.matcher = b(l)),
						l
					);
				}
				if (
					(e.compilerExtensions || (e.compilerExtensions = []),
					e.contains &amp;&amp; e.contains.includes(&quot;self&quot;))
				)
					throw new Error(
						&quot;ERR: contains `self` is not supported at the top-level of a language.  See documentation.&quot;,
					);
				return ((e.classNameAliases = N(e.classNameAliases || {})), _(e));
			}
			function Me(e) {
				return e ? e.endsWithParent || Me(e.starts) : !1;
			}
			function wt(e) {
				return (
					e.variants &amp;&amp;
						!e.cachedVariants &amp;&amp;
						(e.cachedVariants = e.variants.map(function (t) {
							return N(e, { variants: null }, t);
						})),
					e.cachedVariants
						? e.cachedVariants
						: Me(e)
							? N(e, { starts: e.starts ? N(e.starts) : null })
							: Object.isFrozen(e)
								? N(e)
								: e
				);
			}
			var Mt = &quot;11.4.0&quot;;
			class xt extends Error {
				constructor(t, n) {
					(super(t), (this.name = &quot;HTMLInjectionError&quot;), (this.html = n));
				}
			}
			const ee = ae,
				xe = N,
				Oe = Symbol(&quot;nomatch&quot;),
				Ot = 7;
			var j = (function (e) {
				const t = Object.create(null),
					n = Object.create(null),
					f = [];
				let b = !0;
				const _ =
						&quot;Could not find the language &#039;{}&#039;, did you forget to load/include a language module?&quot;,
					c = { disableAutodetect: !0, name: &quot;Plain text&quot;, contains: [] };
				let s = {
					ignoreUnescapedHTML: !1,
					throwUnescapedHTML: !1,
					noHighlightRe: /^(no-?highlight)$/i,
					languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
					classPrefix: &quot;hljs-&quot;,
					cssSelector: &quot;pre code&quot;,
					languages: null,
					__emitter: Ce,
				};
				function l(i) {
					return s.noHighlightRe.test(i);
				}
				function x(i) {
					let a = i.className + &quot; &quot;;
					a += i.parentNode ? i.parentNode.className : &quot;&quot;;
					const h = s.languageDetectRe.exec(a);
					if (h) {
						const p = A(h[1]);
						return (
							p ||
								(_e(_.replace(&quot;{}&quot;, h[1])),
								_e(&quot;Falling back to no-highlight mode for this block.&quot;, i)),
							p ? h[1] : &quot;no-highlight&quot;
						);
					}
					return a.split(/\s+/).find((p) =&gt; l(p) || A(p));
				}
				function w(i, a, h) {
					let p = &quot;&quot;,
						M = &quot;&quot;;
					(typeof a == &quot;object&quot;
						? ((p = i), (h = a.ignoreIllegals), (M = a.language))
						: (L(
								&quot;10.7.0&quot;,
								&quot;highlight(lang, code, ...args) has been deprecated.&quot;,
							),
							L(
								&quot;10.7.0&quot;,
								`Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`,
							),
							(M = i),
							(p = a)),
						h === void 0 &amp;&amp; (h = !0));
					const S = { code: p, language: M };
					z(&quot;before:highlight&quot;, S);
					const k = S.result ? S.result : U(S.language, S.code, h);
					return ((k.code = S.code), z(&quot;after:highlight&quot;, k), k);
				}
				function U(i, a, h, p) {
					const M = Object.create(null);
					function S(r, o) {
						return r.keywords[o];
					}
					function k() {
						if (!u.keywords) {
							O.addText(E);
							return;
						}
						let r = 0;
						u.keywordPatternRe.lastIndex = 0;
						let o = u.keywordPatternRe.exec(E),
							g = &quot;&quot;;
						for (; o; ) {
							g += E.substring(r, o.index);
							const d = I.case_insensitive ? o[0].toLowerCase() : o[0],
								y = S(u, d);
							if (y) {
								const [C, Ut] = y;
								if (
									(O.addText(g),
									(g = &quot;&quot;),
									(M[d] = (M[d] || 0) + 1),
									M[d] &lt;= Ot &amp;&amp; (Y += Ut),
									C.startsWith(&quot;_&quot;))
								)
									g += o[0];
								else {
									const $t = I.classNameAliases[C] || C;
									O.addKeyword(o[0], $t);
								}
							} else g += o[0];
							((r = u.keywordPatternRe.lastIndex),
								(o = u.keywordPatternRe.exec(E)));
						}
						((g += E.substr(r)), O.addText(g));
					}
					function F() {
						if (E === &quot;&quot;) return;
						let r = null;
						if (typeof u.subLanguage == &quot;string&quot;) {
							if (!t[u.subLanguage]) {
								O.addText(E);
								return;
							}
							((r = U(u.subLanguage, E, !0, Te[u.subLanguage])),
								(Te[u.subLanguage] = r._top));
						} else r = ne(E, u.subLanguage.length ? u.subLanguage : null);
						(u.relevance &gt; 0 &amp;&amp; (Y += r.relevance),
							O.addSublanguage(r._emitter, r.language));
					}
					function R() {
						(u.subLanguage != null ? F() : k(), (E = &quot;&quot;));
					}
					function T(r, o) {
						let g = 1;
						for (; o[g] !== void 0; ) {
							if (!r._emit[g]) {
								g++;
								continue;
							}
							const d = I.classNameAliases[r[g]] || r[g],
								y = o[g];
							(d ? O.addKeyword(y, d) : ((E = y), k(), (E = &quot;&quot;)), g++);
						}
					}
					function Ne(r, o) {
						return (
							r.scope &amp;&amp;
								typeof r.scope == &quot;string&quot; &amp;&amp;
								O.openNode(I.classNameAliases[r.scope] || r.scope),
							r.beginScope &amp;&amp;
								(r.beginScope._wrap
									? (O.addKeyword(
											E,
											I.classNameAliases[r.beginScope._wrap] ||
												r.beginScope._wrap,
										),
										(E = &quot;&quot;))
									: r.beginScope._multi &amp;&amp; (T(r.beginScope, o), (E = &quot;&quot;))),
							(u = Object.create(r, { parent: { value: u } })),
							u
						);
					}
					function Ae(r, o, g) {
						let d = Ue(r.endRe, g);
						if (d) {
							if (r[&quot;on:end&quot;]) {
								const y = new oe(r);
								(r[&quot;on:end&quot;](o, y), y.isMatchIgnored &amp;&amp; (d = !1));
							}
							if (d) {
								for (; r.endsParent &amp;&amp; r.parent; ) r = r.parent;
								return r;
							}
						}
						if (r.endsWithParent) return Ae(r.parent, o, g);
					}
					function Lt(r) {
						return u.matcher.regexIndex === 0
							? ((E += r[0]), 1)
							: ((ce = !0), 0);
					}
					function Ct(r) {
						const o = r[0],
							g = r.rule,
							d = new oe(g),
							y = [g.__beforeBegin, g[&quot;on:begin&quot;]];
						for (const C of y)
							if (C &amp;&amp; (C(r, d), d.isMatchIgnored)) return Lt(o);
						return (
							g.skip
								? (E += o)
								: (g.excludeBegin &amp;&amp; (E += o),
									R(),
									!g.returnBegin &amp;&amp; !g.excludeBegin &amp;&amp; (E = o)),
							Ne(g, r),
							g.returnBegin ? 0 : o.length
						);
					}
					function Ht(r) {
						const o = r[0],
							g = a.substr(r.index),
							d = Ae(u, r, g);
						if (!d) return Oe;
						const y = u;
						u.endScope &amp;&amp; u.endScope._wrap
							? (R(), O.addKeyword(o, u.endScope._wrap))
							: u.endScope &amp;&amp; u.endScope._multi
								? (R(), T(u.endScope, r))
								: y.skip
									? (E += o)
									: (y.returnEnd || y.excludeEnd || (E += o),
										R(),
										y.excludeEnd &amp;&amp; (E = o));
						do
							(u.scope &amp;&amp; O.closeNode(),
								!u.skip &amp;&amp; !u.subLanguage &amp;&amp; (Y += u.relevance),
								(u = u.parent));
						while (u !== d.parent);
						return (d.starts &amp;&amp; Ne(d.starts, r), y.returnEnd ? 0 : o.length);
					}
					function Pt() {
						const r = [];
						for (let o = u; o !== I; o = o.parent)
							o.scope &amp;&amp; r.unshift(o.scope);
						r.forEach((o) =&gt; O.openNode(o));
					}
					let X = {};
					function ke(r, o) {
						const g = o &amp;&amp; o[0];
						if (((E += r), g == null)) return (R(), 0);
						if (
							X.type === &quot;begin&quot; &amp;&amp;
							o.type === &quot;end&quot; &amp;&amp;
							X.index === o.index &amp;&amp;
							g === &quot;&quot;
						) {
							if (((E += a.slice(o.index, o.index + 1)), !b)) {
								const d = new Error(`0 width match regex (${i})`);
								throw ((d.languageName = i), (d.badRule = X.rule), d);
							}
							return 1;
						}
						if (((X = o), o.type === &quot;begin&quot;)) return Ct(o);
						if (o.type === &quot;illegal&quot; &amp;&amp; !h) {
							const d = new Error(
								&#039;Illegal lexeme &quot;&#039; +
									g +
									&#039;&quot; for mode &quot;&#039; +
									(u.scope || &quot;&lt;unnamed&gt;&quot;) +
									&#039;&quot;&#039;,
							);
							throw ((d.mode = u), d);
						} else if (o.type === &quot;end&quot;) {
							const d = Ht(o);
							if (d !== Oe) return d;
						}
						if (o.type === &quot;illegal&quot; &amp;&amp; g === &quot;&quot;) return 1;
						if (se &gt; 1e5 &amp;&amp; se &gt; o.index * 3)
							throw new Error(
								&quot;potential infinite loop, way more iterations than matches&quot;,
							);
						return ((E += g), g.length);
					}
					const I = A(i);
					if (!I)
						throw (
							B(_.replace(&quot;{}&quot;, i)),
							new Error(&#039;Unknown language: &quot;&#039; + i + &#039;&quot;&#039;)
						);
					const jt = _t(I);
					let re = &quot;&quot;,
						u = p || jt;
					const Te = {},
						O = new s.__emitter(s);
					Pt();
					let E = &quot;&quot;,
						Y = 0,
						D = 0,
						se = 0,
						ce = !1;
					try {
						for (u.matcher.considerAll(); ; ) {
							(se++,
								ce ? (ce = !1) : u.matcher.considerAll(),
								(u.matcher.lastIndex = D));
							const r = u.matcher.exec(a);
							if (!r) break;
							const o = a.substring(D, r.index),
								g = ke(o, r);
							D = r.index + g;
						}
						return (
							ke(a.substr(D)),
							O.closeAllNodes(),
							O.finalize(),
							(re = O.toHTML()),
							{
								language: i,
								value: re,
								relevance: Y,
								illegal: !1,
								_emitter: O,
								_top: u,
							}
						);
					} catch (r) {
						if (r.message &amp;&amp; r.message.includes(&quot;Illegal&quot;))
							return {
								language: i,
								value: ee(a),
								illegal: !0,
								relevance: 0,
								_illegalBy: {
									message: r.message,
									index: D,
									context: a.slice(D - 100, D + 100),
									mode: r.mode,
									resultSoFar: re,
								},
								_emitter: O,
							};
						if (b)
							return {
								language: i,
								value: ee(a),
								illegal: !1,
								relevance: 0,
								errorRaised: r,
								_emitter: O,
								_top: u,
							};
						throw r;
					}
				}
				function te(i) {
					const a = {
						value: ee(i),
						illegal: !1,
						relevance: 0,
						_top: c,
						_emitter: new s.__emitter(s),
					};
					return (a._emitter.addText(i), a);
				}
				function ne(i, a) {
					a = a || s.languages || Object.keys(t);
					const h = te(i),
						p = a
							.filter(A)
							.filter(Se)
							.map((R) =&gt; U(R, i, !1));
					p.unshift(h);
					const M = p.sort((R, T) =&gt; {
							if (R.relevance !== T.relevance) return T.relevance - R.relevance;
							if (R.language &amp;&amp; T.language) {
								if (A(R.language).supersetOf === T.language) return 1;
								if (A(T.language).supersetOf === R.language) return -1;
							}
							return 0;
						}),
						[S, k] = M,
						F = S;
					return ((F.secondBest = k), F);
				}
				function yt(i, a, h) {
					const p = (a &amp;&amp; n[a]) || h;
					(i.classList.add(&quot;hljs&quot;), i.classList.add(`language-${p}`));
				}
				function ie(i) {
					let a = null;
					const h = x(i);
					if (l(h)) return;
					if (
						(z(&quot;before:highlightElement&quot;, { el: i, language: h }),
						i.children.length &gt; 0 &amp;&amp;
							(s.ignoreUnescapedHTML ||
								(console.warn(
									&quot;One of your code blocks includes unescaped HTML. This is a potentially serious security risk.&quot;,
								),
								console.warn(
									&quot;https://github.com/highlightjs/highlight.js/wiki/security&quot;,
								),
								console.warn(&quot;The element with unescaped HTML:&quot;),
								console.warn(i)),
							s.throwUnescapedHTML))
					)
						throw new xt(
							&quot;One of your code blocks includes unescaped HTML.&quot;,
							i.innerHTML,
						);
					a = i;
					const p = a.textContent,
						M = h ? w(p, { language: h, ignoreIllegals: !0 }) : ne(p);
					((i.innerHTML = M.value),
						yt(i, h, M.language),
						(i.result = {
							language: M.language,
							re: M.relevance,
							relevance: M.relevance,
						}),
						M.secondBest &amp;&amp;
							(i.secondBest = {
								language: M.secondBest.language,
								relevance: M.secondBest.relevance,
							}),
						z(&quot;after:highlightElement&quot;, { el: i, result: M, text: p }));
				}
				function Rt(i) {
					s = xe(s, i);
				}
				const St = () =&gt; {
					(W(),
						L(
							&quot;10.6.0&quot;,
							&quot;initHighlighting() deprecated.  Use highlightAll() now.&quot;,
						));
				};
				function Nt() {
					(W(),
						L(
							&quot;10.6.0&quot;,
							&quot;initHighlightingOnLoad() deprecated.  Use highlightAll() now.&quot;,
						));
				}
				let ye = !1;
				function W() {
					if (document.readyState === &quot;loading&quot;) {
						ye = !0;
						return;
					}
					document.querySelectorAll(s.cssSelector).forEach(ie);
				}
				function At() {
					ye &amp;&amp; W();
				}
				typeof window &lt; &quot;u&quot; &amp;&amp;
					window.addEventListener &amp;&amp;
					window.addEventListener(&quot;DOMContentLoaded&quot;, At, !1);
				function kt(i, a) {
					let h = null;
					try {
						h = a(e);
					} catch (p) {
						if (
							(B(
								&quot;Language definition for &#039;{}&#039; could not be registered.&quot;.replace(
									&quot;{}&quot;,
									i,
								),
							),
							b)
						)
							B(p);
						else throw p;
						h = c;
					}
					(h.name || (h.name = i),
						(t[i] = h),
						(h.rawDefinition = a.bind(null, e)),
						h.aliases &amp;&amp; Re(h.aliases, { languageName: i }));
				}
				function Tt(i) {
					delete t[i];
					for (const a of Object.keys(n)) n[a] === i &amp;&amp; delete n[a];
				}
				function It() {
					return Object.keys(t);
				}
				function A(i) {
					return ((i = (i || &quot;&quot;).toLowerCase()), t[i] || t[n[i]]);
				}
				function Re(i, { languageName: a }) {
					(typeof i == &quot;string&quot; &amp;&amp; (i = [i]),
						i.forEach((h) =&gt; {
							n[h.toLowerCase()] = a;
						}));
				}
				function Se(i) {
					const a = A(i);
					return a &amp;&amp; !a.disableAutodetect;
				}
				function vt(i) {
					(i[&quot;before:highlightBlock&quot;] &amp;&amp;
						!i[&quot;before:highlightElement&quot;] &amp;&amp;
						(i[&quot;before:highlightElement&quot;] = (a) =&gt; {
							i[&quot;before:highlightBlock&quot;](Object.assign({ block: a.el }, a));
						}),
						i[&quot;after:highlightBlock&quot;] &amp;&amp;
							!i[&quot;after:highlightElement&quot;] &amp;&amp;
							(i[&quot;after:highlightElement&quot;] = (a) =&gt; {
								i[&quot;after:highlightBlock&quot;](Object.assign({ block: a.el }, a));
							}));
				}
				function Bt(i) {
					(vt(i), f.push(i));
				}
				function z(i, a) {
					const h = i;
					f.forEach(function (p) {
						p[h] &amp;&amp; p[h](a);
					});
				}
				function Dt(i) {
					return (
						L(&quot;10.7.0&quot;, &quot;highlightBlock will be removed entirely in v12.0&quot;),
						L(&quot;10.7.0&quot;, &quot;Please use highlightElement now.&quot;),
						ie(i)
					);
				}
				(Object.assign(e, {
					highlight: w,
					highlightAuto: ne,
					highlightAll: W,
					highlightElement: ie,
					highlightBlock: Dt,
					configure: Rt,
					initHighlighting: St,
					initHighlightingOnLoad: Nt,
					registerLanguage: kt,
					unregisterLanguage: Tt,
					listLanguages: It,
					getLanguage: A,
					registerAliases: Re,
					autoDetection: Se,
					inherit: xe,
					addPlugin: Bt,
				}),
					(e.debugMode = function () {
						b = !1;
					}),
					(e.safeMode = function () {
						b = !0;
					}),
					(e.versionString = Mt),
					(e.regex = {
						concat: v,
						lookahead: ue,
						either: q,
						optional: Pe,
						anyNumberOfTimes: He,
					}));
				for (const i in G) typeof G[i] == &quot;object&quot; &amp;&amp; ve(G[i]);
				return (Object.assign(e, G), e);
			})({});
			((Ie.exports = j), (j.HighlightJS = j), (j.default = j));
		},
	},
]);
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
