<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/underscore.string/dist/underscore.string.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/underscore.string/dist/underscore.string.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1393</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">161.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
* Underscore.string
* (c) 2010 Esa-Matti Suuronen &lt;esa-matti aet suuronen dot org&gt;
* Underscore.string is freely distributable under the terms of the MIT license.
* Documentation: https://github.com/epeli/underscore.string
* Some code is borrowed from MooTools and Alexandru Marasteanu.
* Version &#039;3.3.6&#039;
* @preserve
*/

(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.s = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var trim = require(&#039;./trim&#039;);
var decap = require(&#039;./decapitalize&#039;);

module.exports = function camelize(str, decapitalize) {
  str = trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
    return c ? c.toUpperCase() : &#039;&#039;;
  });

  if (decapitalize === true) {
    return decap(str);
  } else {
    return str;
  }
};

},{&quot;./decapitalize&quot;:10,&quot;./trim&quot;:65}],2:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function capitalize(str, lowercaseRest) {
  str = makeString(str);
  var remainingChars = !lowercaseRest ? str.slice(1) : str.slice(1).toLowerCase();

  return str.charAt(0).toUpperCase() + remainingChars;
};

},{&quot;./helper/makeString&quot;:20}],3:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function chars(str) {
  return makeString(str).split(&#039;&#039;);
};

},{&quot;./helper/makeString&quot;:20}],4:[function(require,module,exports){
module.exports = function chop(str, step) {
  if (str == null) return [];
  str = String(str);
  step = ~~step;
  return step &gt; 0 ? str.match(new RegExp(&#039;.{1,&#039; + step + &#039;}&#039;, &#039;g&#039;)) : [str];
};

},{}],5:[function(require,module,exports){
var capitalize = require(&#039;./capitalize&#039;);
var camelize = require(&#039;./camelize&#039;);
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function classify(str) {
  str = makeString(str);
  return capitalize(camelize(str.replace(/[\W_]/g, &#039; &#039;)).replace(/\s/g, &#039;&#039;));
};

},{&quot;./camelize&quot;:1,&quot;./capitalize&quot;:2,&quot;./helper/makeString&quot;:20}],6:[function(require,module,exports){
var trim = require(&#039;./trim&#039;);

module.exports = function clean(str) {
  return trim(str).replace(/\s\s+/g, &#039; &#039;);
};

},{&quot;./trim&quot;:65}],7:[function(require,module,exports){

var makeString = require(&#039;./helper/makeString&#039;);

var from  = &#039;ąàáäâãåæăćčĉęèéëêĝĥìíïîĵłľńňòóöőôõðøśșşšŝťțţŭùúüűûñÿýçżźž&#039;,
  to    = &#039;aaaaaaaaaccceeeeeghiiiijllnnoooooooossssstttuuuuuunyyczzz&#039;;

from += from.toUpperCase();
to += to.toUpperCase();

to = to.split(&#039;&#039;);

// for tokens requireing multitoken output
from += &#039;ß&#039;;
to.push(&#039;ss&#039;);


module.exports = function cleanDiacritics(str) {
  return makeString(str).replace(/.{1}/g, function(c){
    var index = from.indexOf(c);
    return index === -1 ? c : to[index];
  });
};

},{&quot;./helper/makeString&quot;:20}],8:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function(str, substr) {
  str = makeString(str);
  substr = makeString(substr);

  if (str.length === 0 || substr.length === 0) return 0;
  
  return str.split(substr).length - 1;
};

},{&quot;./helper/makeString&quot;:20}],9:[function(require,module,exports){
var trim = require(&#039;./trim&#039;);

module.exports = function dasherize(str) {
  return trim(str).replace(/([A-Z])/g, &#039;-$1&#039;).replace(/[-_\s]+/g, &#039;-&#039;).toLowerCase();
};

},{&quot;./trim&quot;:65}],10:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function decapitalize(str) {
  str = makeString(str);
  return str.charAt(0).toLowerCase() + str.slice(1);
};

},{&quot;./helper/makeString&quot;:20}],11:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

function getIndent(str) {
  var matches = str.match(/^[\s\\t]*/gm);
  var indent = matches[0].length;
  
  for (var i = 1; i &lt; matches.length; i++) {
    indent = Math.min(matches[i].length, indent);
  }

  return indent;
}

module.exports = function dedent(str, pattern) {
  str = makeString(str);
  var indent = getIndent(str);
  var reg;

  if (indent === 0) return str;

  if (typeof pattern === &#039;string&#039;) {
    reg = new RegExp(&#039;^&#039; + pattern, &#039;gm&#039;);
  } else {
    reg = new RegExp(&#039;^[ \\t]{&#039; + indent + &#039;}&#039;, &#039;gm&#039;);
  }

  return str.replace(reg, &#039;&#039;);
};

},{&quot;./helper/makeString&quot;:20}],12:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var toPositive = require(&#039;./helper/toPositive&#039;);

module.exports = function endsWith(str, ends, position) {
  str = makeString(str);
  ends = &#039;&#039; + ends;
  if (typeof position == &#039;undefined&#039;) {
    position = str.length - ends.length;
  } else {
    position = Math.min(toPositive(position), str.length) - ends.length;
  }
  return position &gt;= 0 &amp;&amp; str.indexOf(ends, position) === position;
};

},{&quot;./helper/makeString&quot;:20,&quot;./helper/toPositive&quot;:22}],13:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var escapeChars = require(&#039;./helper/escapeChars&#039;);

var regexString = &#039;[&#039;;
for(var key in escapeChars) {
  regexString += key;
}
regexString += &#039;]&#039;;

var regex = new RegExp( regexString, &#039;g&#039;);

module.exports = function escapeHTML(str) {

  return makeString(str).replace(regex, function(m) {
    return &#039;&amp;&#039; + escapeChars[m] + &#039;;&#039;;
  });
};

},{&quot;./helper/escapeChars&quot;:17,&quot;./helper/makeString&quot;:20}],14:[function(require,module,exports){
module.exports = function() {
  var result = {};

  for (var prop in this) {
    if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse|join|map|wrap)$/)) continue;
    result[prop] = this[prop];
  }

  return result;
};

},{}],15:[function(require,module,exports){
var makeString = require(&#039;./makeString&#039;);

module.exports = function adjacent(str, direction) {
  str = makeString(str);
  if (str.length === 0) {
    return &#039;&#039;;
  }
  return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length - 1) + direction);
};

},{&quot;./makeString&quot;:20}],16:[function(require,module,exports){
var escapeRegExp = require(&#039;./escapeRegExp&#039;);

module.exports = function defaultToWhiteSpace(characters) {
  if (characters == null)
    return &#039;\\s&#039;;
  else if (characters.source)
    return characters.source;
  else
    return &#039;[&#039; + escapeRegExp(characters) + &#039;]&#039;;
};

},{&quot;./escapeRegExp&quot;:18}],17:[function(require,module,exports){
/* We&#039;re explicitly defining the list of entities we want to escape.
nbsp is an HTML entity, but we don&#039;t want to escape all space characters in a string, hence its omission in this map.

*/
var escapeChars = {
  &#039;¢&#039; : &#039;cent&#039;,
  &#039;£&#039; : &#039;pound&#039;,
  &#039;¥&#039; : &#039;yen&#039;,
  &#039;€&#039;: &#039;euro&#039;,
  &#039;©&#039; :&#039;copy&#039;,
  &#039;®&#039; : &#039;reg&#039;,
  &#039;&lt;&#039; : &#039;lt&#039;,
  &#039;&gt;&#039; : &#039;gt&#039;,
  &#039;&quot;&#039; : &#039;quot&#039;,
  &#039;&amp;&#039; : &#039;amp&#039;,
  &#039;\&#039;&#039; : &#039;#39&#039;
};

module.exports = escapeChars;

},{}],18:[function(require,module,exports){
var makeString = require(&#039;./makeString&#039;);

module.exports = function escapeRegExp(str) {
  return makeString(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, &#039;\\$1&#039;);
};

},{&quot;./makeString&quot;:20}],19:[function(require,module,exports){
/*
We&#039;re explicitly defining the list of entities that might see in escape HTML strings
*/
var htmlEntities = {
  nbsp: &#039; &#039;,
  cent: &#039;¢&#039;,
  pound: &#039;£&#039;,
  yen: &#039;¥&#039;,
  euro: &#039;€&#039;,
  copy: &#039;©&#039;,
  reg: &#039;®&#039;,
  lt: &#039;&lt;&#039;,
  gt: &#039;&gt;&#039;,
  quot: &#039;&quot;&#039;,
  amp: &#039;&amp;&#039;,
  apos: &#039;\&#039;&#039;
};

module.exports = htmlEntities;

},{}],20:[function(require,module,exports){
/**
 * Ensure some object is a coerced to a string
 **/
module.exports = function makeString(object) {
  if (object == null) return &#039;&#039;;
  return &#039;&#039; + object;
};

},{}],21:[function(require,module,exports){
module.exports = function strRepeat(str, qty){
  if (qty &lt; 1) return &#039;&#039;;
  var result = &#039;&#039;;
  while (qty &gt; 0) {
    if (qty &amp; 1) result += str;
    qty &gt;&gt;= 1, str += str;
  }
  return result;
};

},{}],22:[function(require,module,exports){
module.exports = function toPositive(number) {
  return number &lt; 0 ? 0 : (+number || 0);
};

},{}],23:[function(require,module,exports){
var capitalize = require(&#039;./capitalize&#039;);
var underscored = require(&#039;./underscored&#039;);
var trim = require(&#039;./trim&#039;);

module.exports = function humanize(str) {
  return capitalize(trim(underscored(str).replace(/_id$/, &#039;&#039;).replace(/_/g, &#039; &#039;)));
};

},{&quot;./capitalize&quot;:2,&quot;./trim&quot;:65,&quot;./underscored&quot;:67}],24:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function include(str, needle) {
  if (needle === &#039;&#039;) return true;
  return makeString(str).indexOf(needle) !== -1;
};

},{&quot;./helper/makeString&quot;:20}],25:[function(require,module,exports){
/*
* Underscore.string
* (c) 2010 Esa-Matti Suuronen &lt;esa-matti aet suuronen dot org&gt;
* Underscore.string is freely distributable under the terms of the MIT license.
* Documentation: https://github.com/epeli/underscore.string
* Some code is borrowed from MooTools and Alexandru Marasteanu.
* Version &#039;3.3.6&#039;
* @preserve
*/

&#039;use strict&#039;;

function s(value) {
  /* jshint validthis: true */
  if (!(this instanceof s)) return new s(value);
  this._wrapped = value;
}

s.VERSION = &#039;3.3.6&#039;;

s.isBlank          = require(&#039;./isBlank&#039;);
s.stripTags        = require(&#039;./stripTags&#039;);
s.capitalize       = require(&#039;./capitalize&#039;);
s.decapitalize     = require(&#039;./decapitalize&#039;);
s.chop             = require(&#039;./chop&#039;);
s.trim             = require(&#039;./trim&#039;);
s.clean            = require(&#039;./clean&#039;);
s.cleanDiacritics  = require(&#039;./cleanDiacritics&#039;);
s.count            = require(&#039;./count&#039;);
s.chars            = require(&#039;./chars&#039;);
s.swapCase         = require(&#039;./swapCase&#039;);
s.escapeHTML       = require(&#039;./escapeHTML&#039;);
s.unescapeHTML     = require(&#039;./unescapeHTML&#039;);
s.splice           = require(&#039;./splice&#039;);
s.insert           = require(&#039;./insert&#039;);
s.replaceAll       = require(&#039;./replaceAll&#039;);
s.include          = require(&#039;./include&#039;);
s.join             = require(&#039;./join&#039;);
s.lines            = require(&#039;./lines&#039;);
s.dedent           = require(&#039;./dedent&#039;);
s.reverse          = require(&#039;./reverse&#039;);
s.startsWith       = require(&#039;./startsWith&#039;);
s.endsWith         = require(&#039;./endsWith&#039;);
s.pred             = require(&#039;./pred&#039;);
s.succ             = require(&#039;./succ&#039;);
s.titleize         = require(&#039;./titleize&#039;);
s.camelize         = require(&#039;./camelize&#039;);
s.underscored      = require(&#039;./underscored&#039;);
s.dasherize        = require(&#039;./dasherize&#039;);
s.classify         = require(&#039;./classify&#039;);
s.humanize         = require(&#039;./humanize&#039;);
s.ltrim            = require(&#039;./ltrim&#039;);
s.rtrim            = require(&#039;./rtrim&#039;);
s.truncate         = require(&#039;./truncate&#039;);
s.prune            = require(&#039;./prune&#039;);
s.words            = require(&#039;./words&#039;);
s.pad              = require(&#039;./pad&#039;);
s.lpad             = require(&#039;./lpad&#039;);
s.rpad             = require(&#039;./rpad&#039;);
s.lrpad            = require(&#039;./lrpad&#039;);
s.sprintf          = require(&#039;./sprintf&#039;);
s.vsprintf         = require(&#039;./vsprintf&#039;);
s.toNumber         = require(&#039;./toNumber&#039;);
s.numberFormat     = require(&#039;./numberFormat&#039;);
s.strRight         = require(&#039;./strRight&#039;);
s.strRightBack     = require(&#039;./strRightBack&#039;);
s.strLeft          = require(&#039;./strLeft&#039;);
s.strLeftBack      = require(&#039;./strLeftBack&#039;);
s.toSentence       = require(&#039;./toSentence&#039;);
s.toSentenceSerial = require(&#039;./toSentenceSerial&#039;);
s.slugify          = require(&#039;./slugify&#039;);
s.surround         = require(&#039;./surround&#039;);
s.quote            = require(&#039;./quote&#039;);
s.unquote          = require(&#039;./unquote&#039;);
s.repeat           = require(&#039;./repeat&#039;);
s.naturalCmp       = require(&#039;./naturalCmp&#039;);
s.levenshtein      = require(&#039;./levenshtein&#039;);
s.toBoolean        = require(&#039;./toBoolean&#039;);
s.exports          = require(&#039;./exports&#039;);
s.escapeRegExp     = require(&#039;./helper/escapeRegExp&#039;);
s.wrap             = require(&#039;./wrap&#039;);
s.map              = require(&#039;./map&#039;);

// Aliases
s.strip     = s.trim;
s.lstrip    = s.ltrim;
s.rstrip    = s.rtrim;
s.center    = s.lrpad;
s.rjust     = s.lpad;
s.ljust     = s.rpad;
s.contains  = s.include;
s.q         = s.quote;
s.toBool    = s.toBoolean;
s.camelcase = s.camelize;
s.mapChars  = s.map;


// Implement chaining
s.prototype = {
  value: function value() {
    return this._wrapped;
  }
};

function fn2method(key, fn) {
  if (typeof fn !== &#039;function&#039;) return;
  s.prototype[key] = function() {
    var args = [this._wrapped].concat(Array.prototype.slice.call(arguments));
    var res = fn.apply(null, args);
    // if the result is non-string stop the chain and return the value
    return typeof res === &#039;string&#039; ? new s(res) : res;
  };
}

// Copy functions to instance methods for chaining
for (var key in s) fn2method(key, s[key]);

fn2method(&#039;tap&#039;, function tap(string, fn) {
  return fn(string);
});

function prototype2method(methodName) {
  fn2method(methodName, function(context) {
    var args = Array.prototype.slice.call(arguments, 1);
    return String.prototype[methodName].apply(context, args);
  });
}

var prototypeMethods = [
  &#039;toUpperCase&#039;,
  &#039;toLowerCase&#039;,
  &#039;split&#039;,
  &#039;replace&#039;,
  &#039;slice&#039;,
  &#039;substring&#039;,
  &#039;substr&#039;,
  &#039;concat&#039;
];

for (var method in prototypeMethods) prototype2method(prototypeMethods[method]);


module.exports = s;

},{&quot;./camelize&quot;:1,&quot;./capitalize&quot;:2,&quot;./chars&quot;:3,&quot;./chop&quot;:4,&quot;./classify&quot;:5,&quot;./clean&quot;:6,&quot;./cleanDiacritics&quot;:7,&quot;./count&quot;:8,&quot;./dasherize&quot;:9,&quot;./decapitalize&quot;:10,&quot;./dedent&quot;:11,&quot;./endsWith&quot;:12,&quot;./escapeHTML&quot;:13,&quot;./exports&quot;:14,&quot;./helper/escapeRegExp&quot;:18,&quot;./humanize&quot;:23,&quot;./include&quot;:24,&quot;./insert&quot;:26,&quot;./isBlank&quot;:27,&quot;./join&quot;:28,&quot;./levenshtein&quot;:29,&quot;./lines&quot;:30,&quot;./lpad&quot;:31,&quot;./lrpad&quot;:32,&quot;./ltrim&quot;:33,&quot;./map&quot;:34,&quot;./naturalCmp&quot;:35,&quot;./numberFormat&quot;:38,&quot;./pad&quot;:39,&quot;./pred&quot;:40,&quot;./prune&quot;:41,&quot;./quote&quot;:42,&quot;./repeat&quot;:43,&quot;./replaceAll&quot;:44,&quot;./reverse&quot;:45,&quot;./rpad&quot;:46,&quot;./rtrim&quot;:47,&quot;./slugify&quot;:48,&quot;./splice&quot;:49,&quot;./sprintf&quot;:50,&quot;./startsWith&quot;:51,&quot;./strLeft&quot;:52,&quot;./strLeftBack&quot;:53,&quot;./strRight&quot;:54,&quot;./strRightBack&quot;:55,&quot;./stripTags&quot;:56,&quot;./succ&quot;:57,&quot;./surround&quot;:58,&quot;./swapCase&quot;:59,&quot;./titleize&quot;:60,&quot;./toBoolean&quot;:61,&quot;./toNumber&quot;:62,&quot;./toSentence&quot;:63,&quot;./toSentenceSerial&quot;:64,&quot;./trim&quot;:65,&quot;./truncate&quot;:66,&quot;./underscored&quot;:67,&quot;./unescapeHTML&quot;:68,&quot;./unquote&quot;:69,&quot;./vsprintf&quot;:70,&quot;./words&quot;:71,&quot;./wrap&quot;:72}],26:[function(require,module,exports){
var splice = require(&#039;./splice&#039;);

module.exports = function insert(str, i, substr) {
  return splice(str, i, 0, substr);
};

},{&quot;./splice&quot;:49}],27:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function isBlank(str) {
  return (/^\s*$/).test(makeString(str));
};

},{&quot;./helper/makeString&quot;:20}],28:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var slice = [].slice;

module.exports = function join() {
  var args = slice.call(arguments),
    separator = args.shift();

  return args.join(makeString(separator));
};

},{&quot;./helper/makeString&quot;:20}],29:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

/**
 * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein
 */
module.exports = function levenshtein(str1, str2) {
  &#039;use strict&#039;;
  str1 = makeString(str1);
  str2 = makeString(str2);

  // Short cut cases  
  if (str1 === str2) return 0;
  if (!str1 || !str2) return Math.max(str1.length, str2.length);

  // two rows
  var prevRow = new Array(str2.length + 1);

  // initialise previous row
  for (var i = 0; i &lt; prevRow.length; ++i) {
    prevRow[i] = i;
  }

  // calculate current row distance from previous row
  for (i = 0; i &lt; str1.length; ++i) {
    var nextCol = i + 1;

    for (var j = 0; j &lt; str2.length; ++j) {
      var curCol = nextCol;

      // substution
      nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );
      // insertion
      var tmp = curCol + 1;
      if (nextCol &gt; tmp) {
        nextCol = tmp;
      }
      // deletion
      tmp = prevRow[j + 1] + 1;
      if (nextCol &gt; tmp) {
        nextCol = tmp;
      }

      // copy current col value into previous (in preparation for next iteration)
      prevRow[j] = curCol;
    }

    // copy last col value into previous (in preparation for next iteration)
    prevRow[j] = nextCol;
  }

  return nextCol;
};

},{&quot;./helper/makeString&quot;:20}],30:[function(require,module,exports){
module.exports = function lines(str) {
  if (str == null) return [];
  return String(str).split(/\r\n?|\n/);
};

},{}],31:[function(require,module,exports){
var pad = require(&#039;./pad&#039;);

module.exports = function lpad(str, length, padStr) {
  return pad(str, length, padStr);
};

},{&quot;./pad&quot;:39}],32:[function(require,module,exports){
var pad = require(&#039;./pad&#039;);

module.exports = function lrpad(str, length, padStr) {
  return pad(str, length, padStr, &#039;both&#039;);
};

},{&quot;./pad&quot;:39}],33:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var defaultToWhiteSpace = require(&#039;./helper/defaultToWhiteSpace&#039;);
var nativeTrimLeft = String.prototype.trimLeft;

module.exports = function ltrim(str, characters) {
  str = makeString(str);
  if (!characters &amp;&amp; nativeTrimLeft) return nativeTrimLeft.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp(&#039;^&#039; + characters + &#039;+&#039;), &#039;&#039;);
};

},{&quot;./helper/defaultToWhiteSpace&quot;:16,&quot;./helper/makeString&quot;:20}],34:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function(str, callback) {
  str = makeString(str);

  if (str.length === 0 || typeof callback !== &#039;function&#039;) return str;

  return str.replace(/./g, callback);
};

},{&quot;./helper/makeString&quot;:20}],35:[function(require,module,exports){
module.exports = function naturalCmp(str1, str2) {
  if (str1 == str2) return 0;
  if (!str1) return -1;
  if (!str2) return 1;

  var cmpRegex = /(\.\d+|\d+|\D+)/g,
    tokens1 = String(str1).match(cmpRegex),
    tokens2 = String(str2).match(cmpRegex),
    count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i &lt; count; i++) {
    var a = tokens1[i],
      b = tokens2[i];

    if (a !== b) {
      var num1 = +a;
      var num2 = +b;
      if (num1 === num1 &amp;&amp; num2 === num2) {
        return num1 &gt; num2 ? 1 : -1;
      }
      return a &lt; b ? -1 : 1;
    }
  }

  if (tokens1.length != tokens2.length)
    return tokens1.length - tokens2.length;

  return str1 &lt; str2 ? -1 : 1;
};

},{}],36:[function(require,module,exports){
/* global window, exports, define */

!function() {
    &#039;use strict&#039;

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|&#039;[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = &#039;&#039;, i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i &lt; tree_length; i++) {
            if (typeof parse_tree[i] === &#039;string&#039;) {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === &#039;object&#039;) {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k &lt; ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf(&#039;[sprintf] Cannot access property &quot;%s&quot; of undefined value &quot;%s&quot;&#039;, ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) &amp;&amp; re.not_primitive.test(ph.type) &amp;&amp; arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) &amp;&amp; (typeof arg !== &#039;number&#039; &amp;&amp; isNaN(arg))) {
                    throw new TypeError(sprintf(&#039;[sprintf] expecting number but found %T&#039;, arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg &gt;= 0
                }

                switch (ph.type) {
                    case &#039;b&#039;:
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case &#039;c&#039;:
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case &#039;d&#039;:
                    case &#039;i&#039;:
                        arg = parseInt(arg, 10)
                        break
                    case &#039;j&#039;:
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case &#039;e&#039;:
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case &#039;f&#039;:
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case &#039;g&#039;:
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case &#039;o&#039;:
                        arg = (parseInt(arg, 10) &gt;&gt;&gt; 0).toString(8)
                        break
                    case &#039;s&#039;:
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case &#039;t&#039;:
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case &#039;T&#039;:
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case &#039;u&#039;:
                        arg = parseInt(arg, 10) &gt;&gt;&gt; 0
                        break
                    case &#039;v&#039;:
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case &#039;x&#039;:
                        arg = (parseInt(arg, 10) &gt;&gt;&gt; 0).toString(16)
                        break
                    case &#039;X&#039;:
                        arg = (parseInt(arg, 10) &gt;&gt;&gt; 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) &amp;&amp; (!is_positive || ph.sign)) {
                        sign = is_positive ? &#039;+&#039; : &#039;-&#039;
                        arg = arg.toString().replace(re.sign, &#039;&#039;)
                    }
                    else {
                        sign = &#039;&#039;
                    }
                    pad_character = ph.pad_char ? ph.pad_char === &#039;0&#039; ? &#039;0&#039; : ph.pad_char.charAt(1) : &#039; &#039;
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length &gt; 0 ? pad_character.repeat(pad_length) : &#039;&#039;) : &#039;&#039;
                    output += ph.align ? sign + arg + pad : (pad_character === &#039;0&#039; ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push(&#039;%&#039;)
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== &#039;&#039;) {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError(&#039;[sprintf] failed to parse named argument key&#039;)
                            }
                        }
                    }
                    else {
                        throw new SyntaxError(&#039;[sprintf] failed to parse named argument key&#039;)
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error(&#039;[sprintf] mixing positional and named placeholders is not (yet) supported&#039;)
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError(&#039;[sprintf] unexpected placeholder&#039;)
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (typeof exports !== &#039;undefined&#039;) {
        exports[&#039;sprintf&#039;] = sprintf
        exports[&#039;vsprintf&#039;] = vsprintf
    }
    if (typeof window !== &#039;undefined&#039;) {
        window[&#039;sprintf&#039;] = sprintf
        window[&#039;vsprintf&#039;] = vsprintf

        if (typeof define === &#039;function&#039; &amp;&amp; define[&#039;amd&#039;]) {
            define(function() {
                return {
                    &#039;sprintf&#039;: sprintf,
                    &#039;vsprintf&#039;: vsprintf
                }
            })
        }
    }
    /* eslint-enable quote-props */
}(); // eslint-disable-line

},{}],37:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new &quot;deprecated&quot; version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config(&#039;noDeprecation&#039;)) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config(&#039;throwDeprecation&#039;)) {
        throw new Error(msg);
      } else if (config(&#039;traceDeprecation&#039;)) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === &#039;true&#039;;
}

}).call(this)}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
},{}],38:[function(require,module,exports){
module.exports = function numberFormat(number, dec, dsep, tsep) {
  if (isNaN(number) || number == null) return &#039;&#039;;

  number = number.toFixed(~~dec);
  tsep = typeof tsep == &#039;string&#039; ? tsep : &#039;,&#039;;

  var parts = number.split(&#039;.&#039;),
    fnums = parts[0],
    decimals = parts[1] ? (dsep || &#039;.&#039;) + parts[1] : &#039;&#039;;

  return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, &#039;$1&#039; + tsep) + decimals;
};

},{}],39:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var strRepeat = require(&#039;./helper/strRepeat&#039;);

module.exports = function pad(str, length, padStr, type) {
  str = makeString(str);
  length = ~~length;

  var padlen = 0;

  if (!padStr)
    padStr = &#039; &#039;;
  else if (padStr.length &gt; 1)
    padStr = padStr.charAt(0);

  switch (type) {
  case &#039;right&#039;:
    padlen = length - str.length;
    return str + strRepeat(padStr, padlen);
  case &#039;both&#039;:
    padlen = length - str.length;
    return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
  default: // &#039;left&#039;
    padlen = length - str.length;
    return strRepeat(padStr, padlen) + str;
  }
};

},{&quot;./helper/makeString&quot;:20,&quot;./helper/strRepeat&quot;:21}],40:[function(require,module,exports){
var adjacent = require(&#039;./helper/adjacent&#039;);

module.exports = function succ(str) {
  return adjacent(str, -1);
};

},{&quot;./helper/adjacent&quot;:15}],41:[function(require,module,exports){
/**
 * _s.prune: a more elegant version of truncate
 * prune extra chars, never leaving a half-chopped word.
 * @author github.com/rwz
 */
var makeString = require(&#039;./helper/makeString&#039;);
var rtrim = require(&#039;./rtrim&#039;);

module.exports = function prune(str, length, pruneStr) {
  str = makeString(str);
  length = ~~length;
  pruneStr = pruneStr != null ? String(pruneStr) : &#039;...&#039;;

  if (str.length &lt;= length) return str;

  var tmpl = function(c) {
      return c.toUpperCase() !== c.toLowerCase() ? &#039;A&#039; : &#039; &#039;;
    },
    template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // &#039;Hello, world&#039; -&gt; &#039;HellAA AAAAA&#039;

  if (template.slice(template.length - 2).match(/\w\w/))
    template = template.replace(/\s*\S+$/, &#039;&#039;);
  else
    template = rtrim(template.slice(0, template.length - 1));

  return (template + pruneStr).length &gt; str.length ? str : str.slice(0, template.length) + pruneStr;
};

},{&quot;./helper/makeString&quot;:20,&quot;./rtrim&quot;:47}],42:[function(require,module,exports){
var surround = require(&#039;./surround&#039;);

module.exports = function quote(str, quoteChar) {
  return surround(str, quoteChar || &#039;&quot;&#039;);
};

},{&quot;./surround&quot;:58}],43:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var strRepeat = require(&#039;./helper/strRepeat&#039;);

module.exports = function repeat(str, qty, separator) {
  str = makeString(str);

  qty = ~~qty;

  // using faster implementation if separator is not needed;
  if (separator == null) return strRepeat(str, qty);

  // this one is about 300x slower in Google Chrome
  /*eslint no-empty: 0*/
  for (var repeat = []; qty &gt; 0; repeat[--qty] = str) {}
  return repeat.join(separator);
};

},{&quot;./helper/makeString&quot;:20,&quot;./helper/strRepeat&quot;:21}],44:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function replaceAll(str, find, replace, ignorecase) {
  var flags = (ignorecase === true)?&#039;gi&#039;:&#039;g&#039;;
  var reg = new RegExp(find, flags);

  return makeString(str).replace(reg, replace);
};

},{&quot;./helper/makeString&quot;:20}],45:[function(require,module,exports){
var chars = require(&#039;./chars&#039;);

module.exports = function reverse(str) {
  return chars(str).reverse().join(&#039;&#039;);
};

},{&quot;./chars&quot;:3}],46:[function(require,module,exports){
var pad = require(&#039;./pad&#039;);

module.exports = function rpad(str, length, padStr) {
  return pad(str, length, padStr, &#039;right&#039;);
};

},{&quot;./pad&quot;:39}],47:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var defaultToWhiteSpace = require(&#039;./helper/defaultToWhiteSpace&#039;);
var nativeTrimRight = String.prototype.trimRight;

module.exports = function rtrim(str, characters) {
  str = makeString(str);
  if (!characters &amp;&amp; nativeTrimRight) return nativeTrimRight.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp(characters + &#039;+$&#039;), &#039;&#039;);
};

},{&quot;./helper/defaultToWhiteSpace&quot;:16,&quot;./helper/makeString&quot;:20}],48:[function(require,module,exports){
var trim = require(&#039;./trim&#039;);
var dasherize = require(&#039;./dasherize&#039;);
var cleanDiacritics = require(&#039;./cleanDiacritics&#039;);

module.exports = function slugify(str) {
  return trim(dasherize(cleanDiacritics(str).replace(/[^\w\s-]/g, &#039;-&#039;).toLowerCase()), &#039;-&#039;);
};

},{&quot;./cleanDiacritics&quot;:7,&quot;./dasherize&quot;:9,&quot;./trim&quot;:65}],49:[function(require,module,exports){
var chars = require(&#039;./chars&#039;);

module.exports = function splice(str, i, howmany, substr) {
  var arr = chars(str);
  arr.splice(~~i, ~~howmany, substr);
  return arr.join(&#039;&#039;);
};

},{&quot;./chars&quot;:3}],50:[function(require,module,exports){
var deprecate = require(&#039;util-deprecate&#039;);

module.exports = deprecate(require(&#039;sprintf-js&#039;).sprintf,
  &#039;sprintf() will be removed in the next major release, use the sprintf-js package instead.&#039;);

},{&quot;sprintf-js&quot;:36,&quot;util-deprecate&quot;:37}],51:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var toPositive = require(&#039;./helper/toPositive&#039;);

module.exports = function startsWith(str, starts, position) {
  str = makeString(str);
  starts = &#039;&#039; + starts;
  position = position == null ? 0 : Math.min(toPositive(position), str.length);
  return str.lastIndexOf(starts, position) === position;
};

},{&quot;./helper/makeString&quot;:20,&quot;./helper/toPositive&quot;:22}],52:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function strLeft(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = !sep ? -1 : str.indexOf(sep);
  return~ pos ? str.slice(0, pos) : str;
};

},{&quot;./helper/makeString&quot;:20}],53:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function strLeftBack(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = str.lastIndexOf(sep);
  return~ pos ? str.slice(0, pos) : str;
};

},{&quot;./helper/makeString&quot;:20}],54:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function strRight(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = !sep ? -1 : str.indexOf(sep);
  return~ pos ? str.slice(pos + sep.length, str.length) : str;
};

},{&quot;./helper/makeString&quot;:20}],55:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function strRightBack(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = !sep ? -1 : str.lastIndexOf(sep);
  return~ pos ? str.slice(pos + sep.length, str.length) : str;
};

},{&quot;./helper/makeString&quot;:20}],56:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function stripTags(str) {
  return makeString(str).replace(/&lt;\/?[^&gt;]+&gt;/g, &#039;&#039;);
};

},{&quot;./helper/makeString&quot;:20}],57:[function(require,module,exports){
var adjacent = require(&#039;./helper/adjacent&#039;);

module.exports = function succ(str) {
  return adjacent(str, 1);
};

},{&quot;./helper/adjacent&quot;:15}],58:[function(require,module,exports){
module.exports = function surround(str, wrapper) {
  return [wrapper, str, wrapper].join(&#039;&#039;);
};

},{}],59:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function swapCase(str) {
  return makeString(str).replace(/\S/g, function(c) {
    return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
  });
};

},{&quot;./helper/makeString&quot;:20}],60:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function titleize(str) {
  return makeString(str).toLowerCase().replace(/(?:^|\s|-)\S/g, function(c) {
    return c.toUpperCase();
  });
};

},{&quot;./helper/makeString&quot;:20}],61:[function(require,module,exports){
var trim = require(&#039;./trim&#039;);

function boolMatch(s, matchers) {
  var i, matcher, down = s.toLowerCase();
  matchers = [].concat(matchers);
  for (i = 0; i &lt; matchers.length; i += 1) {
    matcher = matchers[i];
    if (!matcher) continue;
    if (matcher.test &amp;&amp; matcher.test(s)) return true;
    if (matcher.toLowerCase() === down) return true;
  }
}

module.exports = function toBoolean(str, trueValues, falseValues) {
  if (typeof str === &#039;number&#039;) str = &#039;&#039; + str;
  if (typeof str !== &#039;string&#039;) return !!str;
  str = trim(str);
  if (boolMatch(str, trueValues || [&#039;true&#039;, &#039;1&#039;])) return true;
  if (boolMatch(str, falseValues || [&#039;false&#039;, &#039;0&#039;])) return false;
};

},{&quot;./trim&quot;:65}],62:[function(require,module,exports){
module.exports = function toNumber(num, precision) {
  if (num == null) return 0;
  var factor = Math.pow(10, isFinite(precision) ? precision : 0);
  return Math.round(num * factor) / factor;
};

},{}],63:[function(require,module,exports){
var rtrim = require(&#039;./rtrim&#039;);

module.exports = function toSentence(array, separator, lastSeparator, serial) {
  separator = separator || &#039;, &#039;;
  lastSeparator = lastSeparator || &#039; and &#039;;
  var a = array.slice(),
    lastMember = a.pop();

  if (array.length &gt; 2 &amp;&amp; serial) lastSeparator = rtrim(separator) + lastSeparator;

  return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
};

},{&quot;./rtrim&quot;:47}],64:[function(require,module,exports){
var toSentence = require(&#039;./toSentence&#039;);

module.exports = function toSentenceSerial(array, sep, lastSep) {
  return toSentence(array, sep, lastSep, true);
};

},{&quot;./toSentence&quot;:63}],65:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var defaultToWhiteSpace = require(&#039;./helper/defaultToWhiteSpace&#039;);
var nativeTrim = String.prototype.trim;

module.exports = function trim(str, characters) {
  str = makeString(str);
  if (!characters &amp;&amp; nativeTrim) return nativeTrim.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp(&#039;^&#039; + characters + &#039;+|&#039; + characters + &#039;+$&#039;, &#039;g&#039;), &#039;&#039;);
};

},{&quot;./helper/defaultToWhiteSpace&quot;:16,&quot;./helper/makeString&quot;:20}],66:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function truncate(str, length, truncateStr) {
  str = makeString(str);
  truncateStr = truncateStr || &#039;...&#039;;
  length = ~~length;
  return str.length &gt; length ? str.slice(0, length) + truncateStr : str;
};

},{&quot;./helper/makeString&quot;:20}],67:[function(require,module,exports){
var trim = require(&#039;./trim&#039;);

module.exports = function underscored(str) {
  return trim(str).replace(/([a-z\d])([A-Z]+)/g, &#039;$1_$2&#039;).replace(/[-\s]+/g, &#039;_&#039;).toLowerCase();
};

},{&quot;./trim&quot;:65}],68:[function(require,module,exports){
var makeString = require(&#039;./helper/makeString&#039;);
var htmlEntities = require(&#039;./helper/htmlEntities&#039;);

module.exports = function unescapeHTML(str) {
  return makeString(str).replace(/\&amp;([^;]{1,10});/g, function(entity, entityCode) {
    var match;

    if (entityCode in htmlEntities) {
      return htmlEntities[entityCode];
    /*eslint no-cond-assign: 0*/
    } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
      return String.fromCharCode(parseInt(match[1], 16));
    /*eslint no-cond-assign: 0*/
    } else if (match = entityCode.match(/^#(\d+)$/)) {
      return String.fromCharCode(~~match[1]);
    } else {
      return entity;
    }
  });
};

},{&quot;./helper/htmlEntities&quot;:19,&quot;./helper/makeString&quot;:20}],69:[function(require,module,exports){
module.exports = function unquote(str, quoteChar) {
  quoteChar = quoteChar || &#039;&quot;&#039;;
  if (str[0] === quoteChar &amp;&amp; str[str.length - 1] === quoteChar)
    return str.slice(1, str.length - 1);
  else return str;
};

},{}],70:[function(require,module,exports){
var deprecate = require(&#039;util-deprecate&#039;);

module.exports = deprecate(require(&#039;sprintf-js&#039;).vsprintf,
  &#039;vsprintf() will be removed in the next major release, use the sprintf-js package instead.&#039;);

},{&quot;sprintf-js&quot;:36,&quot;util-deprecate&quot;:37}],71:[function(require,module,exports){
var isBlank = require(&#039;./isBlank&#039;);
var trim = require(&#039;./trim&#039;);

module.exports = function words(str, delimiter) {
  if (isBlank(str)) return [];
  return trim(str, delimiter).split(delimiter || /\s+/);
};

},{&quot;./isBlank&quot;:27,&quot;./trim&quot;:65}],72:[function(require,module,exports){
// Wrap
// wraps a string by a certain width

var makeString = require(&#039;./helper/makeString&#039;);

module.exports = function wrap(str, options){
  str = makeString(str);
  
  options = options || {};
  
  var width = options.width || 75;
  var seperator = options.seperator || &#039;\n&#039;;
  var cut = options.cut || false;
  var preserveSpaces = options.preserveSpaces || false;
  var trailingSpaces = options.trailingSpaces || false;
  
  var result;
  
  if(width &lt;= 0){
    return str;
  }
  
  else if(!cut){
  
    var words = str.split(&#039; &#039;);
    var current_column = 0;
    result = &#039;&#039;;
  
    while(words.length &gt; 0){
      
      // if adding a space and the next word would cause this line to be longer than width...
      if(1 + words[0].length + current_column &gt; width){
        //start a new line if this line is not already empty
        if(current_column &gt; 0){
          // add a space at the end of the line is preserveSpaces is true
          if (preserveSpaces){
            result += &#039; &#039;;
            current_column++;
          }
          // fill the rest of the line with spaces if trailingSpaces option is true
          else if(trailingSpaces){
            while(current_column &lt; width){
              result += &#039; &#039;;
              current_column++;
            }            
          }
          //start new line
          result += seperator;
          current_column = 0;
        }
      }
  
      // if not at the begining of the line, add a space in front of the word
      if(current_column &gt; 0){
        result += &#039; &#039;;
        current_column++;
      }
  
      // tack on the next word, update current column, a pop words array
      result += words[0];
      current_column += words[0].length;
      words.shift();
  
    }
  
    // fill the rest of the line with spaces if trailingSpaces option is true
    if(trailingSpaces){
      while(current_column &lt; width){
        result += &#039; &#039;;
        current_column++;
      }            
    }
  
    return result;
  
  }
  
  else {
  
    var index = 0;
    result = &#039;&#039;;
  
    // walk through each character and add seperators where appropriate
    while(index &lt; str.length){
      if(index % width == 0 &amp;&amp; index &gt; 0){
        result += seperator;
      }
      result += str.charAt(index);
      index++;
    }
  
    // fill the rest of the line with spaces if trailingSpaces option is true
    if(trailingSpaces){
      while(index % width &gt; 0){
        result += &#039; &#039;;
        index++;
      }            
    }
    
    return result;
  }
};

},{&quot;./helper/makeString&quot;:20}]},{},[25])(25)
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
