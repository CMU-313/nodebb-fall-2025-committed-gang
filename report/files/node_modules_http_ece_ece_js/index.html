<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/http_ece/ece.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/http_ece/ece.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">529</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.64</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;
/*
 * Encrypted content coding
 *
 * === Note about versions ===
 *
 * This code supports multiple versions of the draft.  This is selected using
 * the |version| parameter.
 *
 * aes128gcm: The most recent version, the salt, record size and key identifier
 *    are included in a header that is part of the encrypted content coding.
 *
 * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).
 *    This version is selected by default, unless you specify a |padSize| of 1.
 */

var crypto = require(&#039;crypto&#039;);

var AES_GCM = &#039;aes-128-gcm&#039;;
var PAD_SIZE = { &#039;aes128gcm&#039;: 1, &#039;aesgcm&#039;: 2 };
var TAG_LENGTH = 16;
var KEY_LENGTH = 16;
var NONCE_LENGTH = 12;
var SHA_256_LENGTH = 32;
var MODE_ENCRYPT = &#039;encrypt&#039;;
var MODE_DECRYPT = &#039;decrypt&#039;;

var keylog;
if (process.env.ECE_KEYLOG === &#039;1&#039;) {
  keylog = function(m, k) {
    console.warn(m + &#039; [&#039; + k.length + &#039;]: &#039; + k.toString(&#039;base64url&#039;));
    return k;
  };
} else {
  keylog = function(m, k) { return k; };
}

/* Optionally base64 decode something. */
function decode(b) {
  if (typeof b === &#039;string&#039;) {
    return Buffer.from(b, &#039;base64url&#039;);
  }
  return b;
}

function HMAC_hash(key, input) {
  var hmac = crypto.createHmac(&#039;sha256&#039;, key);
  hmac.update(input);
  return hmac.digest();
}

/* HKDF as defined in RFC5869, using SHA-256 */
function HKDF_extract(salt, ikm) {
  keylog(&#039;salt&#039;, salt);
  keylog(&#039;ikm&#039;, ikm);
  return keylog(&#039;extract&#039;, HMAC_hash(salt, ikm));
}

function HKDF_expand(prk, info, l) {
  keylog(&#039;prk&#039;, prk);
  keylog(&#039;info&#039;, info);
  var output = Buffer.alloc(0);
  var T = Buffer.alloc(0);
  info = Buffer.from(info, &#039;ascii&#039;);
  var counter = 0;
  var cbuf = Buffer.alloc(1);
  while (output.length &lt; l) {
    cbuf.writeUIntBE(++counter, 0, 1);
    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));
    output = Buffer.concat([output, T]);
  }

  return keylog(&#039;expand&#039;, output.slice(0, l));
}

function HKDF(salt, ikm, info, len) {
  return HKDF_expand(HKDF_extract(salt, ikm), info, len);
}

function info(base, context) {
  var result = Buffer.concat([
    Buffer.from(&#039;Content-Encoding: &#039; + base + &#039;\0&#039;, &#039;ascii&#039;),
    context
  ]);
  keylog(&#039;info &#039; + base, result);
  return result;
}

function lengthPrefix(buffer) {
  var b = Buffer.concat([Buffer.alloc(2), buffer]);
  b.writeUIntBE(buffer.length, 0, 2);
  return b;
}

function extractDH(header, mode) {
  var key = header.privateKey;
  var senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = key.getPublicKey();
    receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    senderPubKey = header.dh;
    receiverPubKey = key.getPublicKey();
  } else {
    throw new Error(&#039;Unknown mode only &#039; + MODE_ENCRYPT +
                    &#039; and &#039; + MODE_DECRYPT + &#039; supported&#039;);
  }
  return {
    secret: key.computeSecret(header.dh),
    context: Buffer.concat([
      Buffer.from(header.keylabel, &#039;ascii&#039;),
      Buffer.from([0]),
      lengthPrefix(receiverPubKey), // user agent
      lengthPrefix(senderPubKey)    // application server
    ])
  };
}

function extractSecretAndContext(header, mode) {
  var result = { secret: null, context: Buffer.alloc(0) };
  if (header.key) {
    result.secret = header.key;
    if (result.secret.length !== KEY_LENGTH) {
      throw new Error(&#039;An explicit key must be &#039; + KEY_LENGTH + &#039; bytes&#039;);
    }
  } else if (header.dh) { // receiver/decrypt
    result = extractDH(header, mode);
  } else if (typeof header.keyid !== undefined) {
    result.secret = header.keymap[header.keyid];
  }
  if (!result.secret) {
    throw new Error(&#039;Unable to determine key&#039;);
  }
  keylog(&#039;secret&#039;, result.secret);
  keylog(&#039;context&#039;, result.context);
  if (header.authSecret) {
    result.secret = HKDF(header.authSecret, result.secret,
                         info(&#039;auth&#039;, Buffer.alloc(0)), SHA_256_LENGTH);
    keylog(&#039;authsecret&#039;, result.secret);
  }
  return result;
}

function webpushSecret(header, mode) {
  if (!header.authSecret) {
    throw new Error(&#039;No authentication secret for webpush&#039;);
  }
  keylog(&#039;authsecret&#039;, header.authSecret);

  var remotePubKey, senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = header.privateKey.getPublicKey();
    remotePubKey = receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    remotePubKey = senderPubKey = header.keyid;
    receiverPubKey = header.privateKey.getPublicKey();
  } else {
    throw new Error(&#039;Unknown mode only &#039; + MODE_ENCRYPT +
                    &#039; and &#039; + MODE_DECRYPT + &#039; supported&#039;);
  }
  keylog(&#039;remote pubkey&#039;, remotePubKey);
  keylog(&#039;sender pubkey&#039;, senderPubKey);
  keylog(&#039;receiver pubkey&#039;, receiverPubKey);
  return keylog(&#039;secret dh&#039;,
                HKDF(header.authSecret,
                     header.privateKey.computeSecret(remotePubKey),
                     Buffer.concat([
                       Buffer.from(&#039;WebPush: info\0&#039;),
                       receiverPubKey,
                       senderPubKey
                     ]),
                     SHA_256_LENGTH));
}

function extractSecret(header, mode, keyLookupCallback) {
  if (keyLookupCallback) {
    if (!isFunction(keyLookupCallback)) {
      throw new Error(&#039;Callback is not a function&#039;)
    }
  }

  if (header.key) {
    if (header.key.length !== KEY_LENGTH) {
      throw new Error(&#039;An explicit key must be &#039; + KEY_LENGTH + &#039; bytes&#039;);
    }
    return keylog(&#039;secret key&#039;, header.key);
  }

  if (!header.privateKey) {
    // Lookup based on keyid
    if (!keyLookupCallback) {
      var key = header.keymap &amp;&amp; header.keymap[header.keyid];
    } else {
      var key = keyLookupCallback(header.keyid)
    }
    if (!key) {
      throw new Error(&#039;No saved key (keyid: &quot;&#039; + header.keyid + &#039;&quot;)&#039;);
    }
    return key;
  }

  return webpushSecret(header, mode);
}

function deriveKeyAndNonce(header, mode, lookupKeyCallback) {
  if (!header.salt) {
    throw new Error(&#039;must include a salt parameter for &#039; + header.version);
  }
  var keyInfo;
  var nonceInfo;
  var secret;
  if (header.version === &#039;aesgcm&#039;) {
    // old
    var s = extractSecretAndContext(header, mode, lookupKeyCallback);
    keyInfo = info(&#039;aesgcm&#039;, s.context);
    nonceInfo = info(&#039;nonce&#039;, s.context);
    secret = s.secret;
  } else if (header.version === &#039;aes128gcm&#039;) {
    // latest
    keyInfo = Buffer.from(&#039;Content-Encoding: aes128gcm\0&#039;);
    nonceInfo = Buffer.from(&#039;Content-Encoding: nonce\0&#039;);
    secret = extractSecret(header, mode, lookupKeyCallback);
  } else {
    throw new Error(&#039;Unable to set context for mode &#039; + header.version);
  }
  var prk = HKDF_extract(header.salt, secret);
  var result = {
    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),
    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)
  };
  keylog(&#039;key&#039;, result.key);
  keylog(&#039;nonce base&#039;, result.nonce);
  return result;
}

/* Parse command-line arguments. */
function parseParams(params) {
  var header = {};

  header.version = params.version || &#039;aes128gcm&#039;;
  header.rs = parseInt(params.rs, 10);
  if (isNaN(header.rs)) {
    header.rs = 4096;
  }
  var overhead = PAD_SIZE[header.version];
  if (header.version === &#039;aes128gcm&#039;) {
    overhead += TAG_LENGTH;
  }
  if (header.rs &lt;= overhead) {
    throw new Error(&#039;The rs parameter has to be greater than &#039; + overhead);
  }

  if (params.salt) {
    header.salt = decode(params.salt);
    if (header.salt.length !== KEY_LENGTH) {
      throw new Error(&#039;The salt parameter must be &#039; + KEY_LENGTH + &#039; bytes&#039;);
    }
  }
  header.keyid = params.keyid;
  if (params.key) {
    header.key = decode(params.key);
  } else {
    header.privateKey = params.privateKey;
    if (!header.privateKey) {
      header.keymap = params.keymap;
    }
    if (header.version !== &#039;aes128gcm&#039;) {
      header.keylabel = params.keylabel || &#039;P-256&#039;;
    }
    if (params.dh) {
      header.dh = decode(params.dh);
    }
  }
  if (params.authSecret) {
    header.authSecret = decode(params.authSecret);
  }
  return header;
}

function generateNonce(base, counter) {
  var nonce = Buffer.from(base);
  var m = nonce.readUIntBE(nonce.length - 6, 6);
  var x = ((m ^ counter) &amp; 0xffffff) +
      ((((m / 0x1000000) ^ (counter / 0x1000000)) &amp; 0xffffff) * 0x1000000);
  nonce.writeUIntBE(x, nonce.length - 6, 6);
  keylog(&#039;nonce&#039; + counter, nonce);
  return nonce;
}

/* Used when decrypting aes128gcm to populate the header values. Modifies the
 * header values in place and returns the size of the header. */
function readHeader(buffer, header) {
  var idsz = buffer.readUIntBE(20, 1);
  header.salt = buffer.slice(0, KEY_LENGTH);
  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);
  header.keyid = buffer.slice(21, 21 + idsz);
  return 21 + idsz;
}

function unpadLegacy(data, version) {
  var padSize = PAD_SIZE[version];
  var pad = data.readUIntBE(0, padSize);
  if (pad + padSize &gt; data.length) {
    throw new Error(&#039;padding exceeds block size&#039;);
  }
  keylog(&#039;padding&#039;, data.slice(0, padSize + pad));
  var padCheck = Buffer.alloc(pad);
  padCheck.fill(0);
  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {
    throw new Error(&#039;invalid padding&#039;);
  }
  return data.slice(padSize + pad);
}

function unpad(data, last) {
  var i = data.length - 1;
  while(i &gt;= 0) {
    if (data[i]) {
      if (last) {
        if (data[i] !== 2) {
          throw new Error(&#039;last record needs to start padding with a 2&#039;);
        }
      } else {
        if (data[i] !== 1) {
          throw new Error(&#039;last record needs to start padding with a 2&#039;);
        }
      }
      return data.slice(0, i);
    }
    --i;
  }
  throw new Error(&#039;all zero plaintext&#039;);
}

function decryptRecord(key, counter, buffer, header, last) {
  keylog(&#039;decrypt&#039;, buffer);
  var nonce = generateNonce(key.nonce, counter);
  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);
  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));
  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));
  data = Buffer.concat([data, gcm.final()]);
  keylog(&#039;decrypted&#039;, data);
  if (header.version !== &#039;aes128gcm&#039;) {
    return unpadLegacy(data, header.version);
  }
  return unpad(data, last);
}

/**
 * Decrypt some bytes.  This uses the parameters to determine the key and block
 * size, which are described in the draft.  Binary values are base64url encoded.
 *
 * |params.version| contains the version of encoding to use: aes128gcm is the latest,
 * but aesgcm is also accepted (though the latter might
 * disappear in a future release).  If omitted, assume aes128gcm.
 *
 * If |params.key| is specified, that value is used as the key.
 *
 * If the version is aes128gcm, the keyid is extracted from the header and used
 * as the ECDH public key of the sender.  For version aesgcm ,
 * |params.dh| needs to be provided with the public key of the sender.
 *
 * The |params.privateKey| includes the private key of the receiver.
 */
function decrypt(buffer, params, keyLookupCallback) {
  var header = parseParams(params);
  if (header.version === &#039;aes128gcm&#039;) {
    var headerLength = readHeader(buffer, header);
    buffer = buffer.slice(headerLength);
  }
  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);
  var start = 0;
  var result = Buffer.alloc(0);

  var chunkSize = header.rs;
  if (header.version !== &#039;aes128gcm&#039;) {
    chunkSize += TAG_LENGTH;
  }

  for (var i = 0; start &lt; buffer.length; ++i) {
    var end = start + chunkSize;
    if (header.version !== &#039;aes128gcm&#039; &amp;&amp; end === buffer.length) {
      throw new Error(&#039;Truncated payload&#039;);
    }
    end = Math.min(end, buffer.length);
    if (end - start &lt;= TAG_LENGTH) {
      throw new Error(&#039;Invalid block: too small at &#039; + i);
    }
    var block = decryptRecord(key, i, buffer.slice(start, end),
                              header, end &gt;= buffer.length);
    result = Buffer.concat([result, block]);
    start = end;
  }
  return result;
}

function encryptRecord(key, counter, buffer, pad, header, last) {
  keylog(&#039;encrypt&#039;, buffer);
  pad = pad || 0;
  var nonce = generateNonce(key.nonce, counter);
  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);

  var ciphertext = [];
  var padSize = PAD_SIZE[header.version];
  var padding = Buffer.alloc(pad + padSize);
  padding.fill(0);

  if (header.version !== &#039;aes128gcm&#039;) {
    padding.writeUIntBE(pad, 0, padSize);
    keylog(&#039;padding&#039;, padding);
    ciphertext.push(gcm.update(padding));
    ciphertext.push(gcm.update(buffer));

    if (!last &amp;&amp; padding.length + buffer.length &lt; header.rs) {
      throw new Error(&#039;Unable to pad to record size&#039;);
    }
  } else {
    ciphertext.push(gcm.update(buffer));
    padding.writeUIntBE(last ? 2 : 1, 0, 1);
    keylog(&#039;padding&#039;, padding);
    ciphertext.push(gcm.update(padding));
  }

  gcm.final();
  var tag = gcm.getAuthTag();
  if (tag.length !== TAG_LENGTH) {
    throw new Error(&#039;invalid tag generated&#039;);
  }
  ciphertext.push(tag);
  return keylog(&#039;encrypted&#039;, Buffer.concat(ciphertext));
}

function writeHeader(header) {
  var ints = Buffer.alloc(5);
  var keyid = Buffer.from(header.keyid || []);
  if (keyid.length &gt; 255) {
    throw new Error(&#039;keyid is too large&#039;);
  }
  ints.writeUIntBE(header.rs, 0, 4);
  ints.writeUIntBE(keyid.length, 4, 1);
  return Buffer.concat([header.salt, ints, keyid]);
}

/**
 * Encrypt some bytes.  This uses the parameters to determine the key and block
 * size, which are described in the draft.
 *
 * |params.version| contains the version of encoding to use: aes128gcm is the latest,
 * but aesgcm is also accepted (though the latter two might
 * disappear in a future release).  If omitted, assume aes128gcm.
 *
 * If |params.key| is specified, that value is used as the key.
 *
 * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the
 * receiver.  |params.privateKey| is used to establish a shared secret.  Key
 * pairs can be created using |crypto.createECDH()|.
 */
function encrypt(buffer, params, keyLookupCallback) {  
  if (!Buffer.isBuffer(buffer)) {
    throw new Error(&#039;buffer argument must be a Buffer&#039;);
  }
  var header = parseParams(params);
  if (!header.salt) {
    header.salt = crypto.randomBytes(KEY_LENGTH);
  }

  var result;
  if (header.version === &#039;aes128gcm&#039;) {
    // Save the DH public key in the header unless keyid is set.
    if (header.privateKey &amp;&amp; !header.keyid) {
      header.keyid = header.privateKey.getPublicKey();
    }
    result = writeHeader(header);
  } else {
    // No header on other versions
    result = Buffer.alloc(0);
  }

  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);
  var start = 0;
  var padSize = PAD_SIZE[header.version];
  var overhead = padSize;
  if (header.version === &#039;aes128gcm&#039;) {
    overhead += TAG_LENGTH;
  }
  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);

  var counter = 0;
  var last = false;
  while (!last) {
    // Pad so that at least one data byte is in a block.
    var recordPad = Math.min(header.rs - overhead - 1, pad);
    if (header.version !== &#039;aes128gcm&#039;) {
      recordPad = Math.min((1 &lt;&lt; (padSize * 8)) - 1, recordPad);
    }
    if (pad &gt; 0 &amp;&amp; recordPad === 0) {
      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.
    }
    pad -= recordPad;

    var end = start + header.rs - overhead - recordPad;
    if (header.version !== &#039;aes128gcm&#039;) {
      // The &gt; here ensures that we write out a padding-only block at the end
      // of a buffer.
      last = end &gt; buffer.length;
    } else {
      last = end &gt;= buffer.length;
    }
    last = last &amp;&amp; pad &lt;= 0;
    var block = encryptRecord(key, counter, buffer.slice(start, end),
                              recordPad, header, last);
    result = Buffer.concat([result, block]);

    start = end;
    ++counter;
  }
  return result;
}


function isFunction(object) {
  return typeof(object) === &#039;function&#039;;
 }

module.exports = {
  decrypt: decrypt,
  encrypt: encrypt
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
