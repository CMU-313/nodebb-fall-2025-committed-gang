<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/prefer-const.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/prefer-const.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">547</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.
 * @author Toru Nagashima
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const FixTracker = require(&quot;./utils/fix-tracker&quot;);
const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const PATTERN_TYPE =
	/^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
const DECLARATION_HOST_TYPE =
	/^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u;
const DESTRUCTURING_HOST_TYPE =
	/^(?:VariableDeclarator|AssignmentExpression)$/u;

/**
 * Checks whether a given node is located at `ForStatement.init` or not.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node is located at `ForStatement.init`.
 */
function isInitOfForStatement(node) {
	return node.parent.type === &quot;ForStatement&quot; &amp;&amp; node.parent.init === node;
}

/**
 * Checks whether a given Identifier node becomes a VariableDeclaration or not.
 * @param {ASTNode} identifier An Identifier node to check.
 * @returns {boolean} `true` if the node can become a VariableDeclaration.
 */
function canBecomeVariableDeclaration(identifier) {
	let node = identifier.parent;

	while (PATTERN_TYPE.test(node.type)) {
		node = node.parent;
	}

	return (
		node.type === &quot;VariableDeclarator&quot; ||
		(node.type === &quot;AssignmentExpression&quot; &amp;&amp;
			node.parent.type === &quot;ExpressionStatement&quot; &amp;&amp;
			DECLARATION_HOST_TYPE.test(node.parent.parent.type))
	);
}

/**
 * Checks if an property or element is from outer scope or function parameters
 * in destructing pattern.
 * @param {string} name A variable name to be checked.
 * @param {eslint-scope.Scope} initScope A scope to start find.
 * @returns {boolean} Indicates if the variable is from outer scope or function parameters.
 */
function isOuterVariableInDestructing(name, initScope) {
	if (
		initScope.through.some(
			ref =&gt; ref.resolved &amp;&amp; ref.resolved.name === name,
		)
	) {
		return true;
	}

	const variable = astUtils.getVariableByName(initScope, name);

	if (variable !== null) {
		return variable.defs.some(def =&gt; def.type === &quot;Parameter&quot;);
	}

	return false;
}

/**
 * Gets the VariableDeclarator/AssignmentExpression node that a given reference
 * belongs to.
 * This is used to detect a mix of reassigned and never reassigned in a
 * destructuring.
 * @param {eslint-scope.Reference} reference A reference to get.
 * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or
 *      null.
 */
function getDestructuringHost(reference) {
	if (!reference.isWrite()) {
		return null;
	}
	let node = reference.identifier.parent;

	while (PATTERN_TYPE.test(node.type)) {
		node = node.parent;
	}

	if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
		return null;
	}
	return node;
}

/**
 * Determines if a destructuring assignment node contains
 * any MemberExpression nodes. This is used to determine if a
 * variable that is only written once using destructuring can be
 * safely converted into a const declaration.
 * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.
 * @returns {boolean} True if the destructuring pattern contains
 *      a MemberExpression, false if not.
 */
function hasMemberExpressionAssignment(node) {
	switch (node.type) {
		case &quot;ObjectPattern&quot;:
			return node.properties.some(prop =&gt; {
				if (prop) {
					/*
					 * Spread elements have an argument property while
					 * others have a value property. Because different
					 * parsers use different node types for spread elements,
					 * we just check if there is an argument property.
					 */
					return hasMemberExpressionAssignment(
						prop.argument || prop.value,
					);
				}

				return false;
			});

		case &quot;ArrayPattern&quot;:
			return node.elements.some(element =&gt; {
				if (element) {
					return hasMemberExpressionAssignment(element);
				}

				return false;
			});

		case &quot;AssignmentPattern&quot;:
			return hasMemberExpressionAssignment(node.left);

		case &quot;MemberExpression&quot;:
			return true;

		// no default
	}

	return false;
}

/**
 * Gets an identifier node of a given variable.
 *
 * If the initialization exists or one or more reading references exist before
 * the first assignment, the identifier node is the node of the declaration.
 * Otherwise, the identifier node is the node of the first assignment.
 *
 * If the variable should not change to const, this function returns null.
 * - If the variable is reassigned.
 * - If the variable is never initialized nor assigned.
 * - If the variable is initialized in a different scope from the declaration.
 * - If the unique assignment of the variable cannot change to a declaration.
 *   e.g. `if (a) b = 1` / `return (b = 1)`
 * - If the variable is declared in the global scope and `eslintUsed` is `true`.
 *   `/*exported foo` directive comment makes such variables. This rule does not
 *   warn such variables because this rule cannot distinguish whether the
 *   exported variables are reassigned or not.
 * @param {eslint-scope.Variable} variable A variable to get.
 * @param {boolean} ignoreReadBeforeAssign
 *      The value of `ignoreReadBeforeAssign` option.
 * @returns {ASTNode|null}
 *      An Identifier node if the variable should change to const.
 *      Otherwise, null.
 */
function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
	if (variable.eslintUsed &amp;&amp; variable.scope.type === &quot;global&quot;) {
		return null;
	}

	// Finds the unique WriteReference.
	let writer = null;
	let isReadBeforeInit = false;
	const references = variable.references;

	for (let i = 0; i &lt; references.length; ++i) {
		const reference = references[i];

		if (reference.isWrite()) {
			const isReassigned =
				writer !== null &amp;&amp; writer.identifier !== reference.identifier;

			if (isReassigned) {
				return null;
			}

			const destructuringHost = getDestructuringHost(reference);

			if (
				destructuringHost !== null &amp;&amp;
				destructuringHost.left !== void 0
			) {
				const leftNode = destructuringHost.left;
				let hasOuterVariables = false,
					hasNonIdentifiers = false;

				if (leftNode.type === &quot;ObjectPattern&quot;) {
					const properties = leftNode.properties;

					hasOuterVariables = properties
						.filter(prop =&gt; prop.value)
						.map(prop =&gt; prop.value.name)
						.some(name =&gt;
							isOuterVariableInDestructing(name, variable.scope),
						);

					hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
				} else if (leftNode.type === &quot;ArrayPattern&quot;) {
					const elements = leftNode.elements;

					hasOuterVariables = elements
						.map(element =&gt; element &amp;&amp; element.name)
						.some(name =&gt;
							isOuterVariableInDestructing(name, variable.scope),
						);

					hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
				}

				if (hasOuterVariables || hasNonIdentifiers) {
					return null;
				}
			}

			writer = reference;
		} else if (reference.isRead() &amp;&amp; writer === null) {
			if (ignoreReadBeforeAssign) {
				return null;
			}
			isReadBeforeInit = true;
		}
	}

	/*
	 * If the assignment is from a different scope, ignore it.
	 * If the assignment cannot change to a declaration, ignore it.
	 */
	const shouldBeConst =
		writer !== null &amp;&amp;
		writer.from === variable.scope &amp;&amp;
		canBecomeVariableDeclaration(writer.identifier);

	if (!shouldBeConst) {
		return null;
	}

	if (isReadBeforeInit) {
		return variable.defs[0].name;
	}

	return writer.identifier;
}

/**
 * Groups by the VariableDeclarator/AssignmentExpression node that each
 * reference of given variables belongs to.
 * This is used to detect a mix of reassigned and never reassigned in a
 * destructuring.
 * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.
 * @param {boolean} ignoreReadBeforeAssign
 *      The value of `ignoreReadBeforeAssign` option.
 * @returns {Map&lt;ASTNode, ASTNode[]&gt;} Grouped identifier nodes.
 */
function groupByDestructuring(variables, ignoreReadBeforeAssign) {
	const identifierMap = new Map();

	for (let i = 0; i &lt; variables.length; ++i) {
		const variable = variables[i];
		const references = variable.references;
		const identifier = getIdentifierIfShouldBeConst(
			variable,
			ignoreReadBeforeAssign,
		);
		let prevId = null;

		for (let j = 0; j &lt; references.length; ++j) {
			const reference = references[j];
			const id = reference.identifier;

			/*
			 * Avoid counting a reference twice or more for default values of
			 * destructuring.
			 */
			if (id === prevId) {
				continue;
			}
			prevId = id;

			// Add the identifier node into the destructuring group.
			const group = getDestructuringHost(reference);

			if (group) {
				if (identifierMap.has(group)) {
					identifierMap.get(group).push(identifier);
				} else {
					identifierMap.set(group, [identifier]);
				}
			}
		}
	}

	return identifierMap;
}

/**
 * Finds the nearest parent of node with a given type.
 * @param {ASTNode} node The node to search from.
 * @param {string} type The type field of the parent node.
 * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.
 * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.
 */
function findUp(node, type, shouldStop) {
	if (!node || shouldStop(node)) {
		return null;
	}
	if (node.type === type) {
		return node;
	}
	return findUp(node.parent, type, shouldStop);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		defaultOptions: [
			{
				destructuring: &quot;any&quot;,
				ignoreReadBeforeAssign: false,
			},
		],

		docs: {
			description:
				&quot;Require `const` declarations for variables that are never reassigned after declared&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/prefer-const&quot;,
		},

		fixable: &quot;code&quot;,

		schema: [
			{
				type: &quot;object&quot;,
				properties: {
					destructuring: { enum: [&quot;any&quot;, &quot;all&quot;] },
					ignoreReadBeforeAssign: { type: &quot;boolean&quot; },
				},
				additionalProperties: false,
			},
		],
		messages: {
			useConst: &quot;&#039;{{name}}&#039; is never reassigned. Use &#039;const&#039; instead.&quot;,
		},
	},

	create(context) {
		const [{ destructuring, ignoreReadBeforeAssign }] = context.options;
		const shouldMatchAnyDestructuredVariable = destructuring !== &quot;all&quot;;
		const sourceCode = context.sourceCode;
		const variables = [];
		let reportCount = 0;
		let checkedId = null;
		let checkedName = &quot;&quot;;

		/**
		 * Reports given identifier nodes if all of the nodes should be declared
		 * as const.
		 *
		 * The argument &#039;nodes&#039; is an array of Identifier nodes.
		 * This node is the result of &#039;getIdentifierIfShouldBeConst()&#039;, so it&#039;s
		 * nullable. In simple declaration or assignment cases, the length of
		 * the array is 1. In destructuring cases, the length of the array can
		 * be 2 or more.
		 * @param {(eslint-scope.Reference|null)[]} nodes
		 *      References which are grouped by destructuring to report.
		 * @returns {void}
		 */
		function checkGroup(nodes) {
			const nodesToReport = nodes.filter(Boolean);

			if (
				nodes.length &amp;&amp;
				(shouldMatchAnyDestructuredVariable ||
					nodesToReport.length === nodes.length)
			) {
				const varDeclParent = findUp(
					nodes[0],
					&quot;VariableDeclaration&quot;,
					parentNode =&gt; parentNode.type.endsWith(&quot;Statement&quot;),
				);
				const isVarDecParentNull = varDeclParent === null;

				if (
					!isVarDecParentNull &amp;&amp;
					varDeclParent.declarations.length &gt; 0
				) {
					const firstDeclaration = varDeclParent.declarations[0];

					if (firstDeclaration.init) {
						const firstDecParent = firstDeclaration.init.parent;

						/*
						 * First we check the declaration type and then depending on
						 * if the type is a &quot;VariableDeclarator&quot; or its an &quot;ObjectPattern&quot;
						 * we compare the name and id from the first identifier, if the names are different
						 * we assign the new name, id and reset the count of reportCount and nodeCount in
						 * order to check each block for the number of reported errors and base our fix
						 * based on comparing nodes.length and nodesToReport.length.
						 */

						if (firstDecParent.type === &quot;VariableDeclarator&quot;) {
							if (firstDecParent.id.name !== checkedName) {
								checkedName = firstDecParent.id.name;
								reportCount = 0;
							}

							if (firstDecParent.id.type === &quot;ObjectPattern&quot;) {
								if (firstDecParent.init.name !== checkedName) {
									checkedName = firstDecParent.init.name;
									reportCount = 0;
								}
							}

							if (firstDecParent.id !== checkedId) {
								checkedId = firstDecParent.id;
								reportCount = 0;
							}
						}
					}
				}

				let shouldFix =
					varDeclParent &amp;&amp;
					// Don&#039;t do a fix unless all variables in the declarations are initialized (or it&#039;s in a for-in or for-of loop)
					(varDeclParent.parent.type === &quot;ForInStatement&quot; ||
						varDeclParent.parent.type === &quot;ForOfStatement&quot; ||
						varDeclParent.declarations.every(
							declaration =&gt; declaration.init,
						)) &amp;&amp;
					/*
					 * If options.destructuring is &quot;all&quot;, then this warning will not occur unless
					 * every assignment in the destructuring should be const. In that case, it&#039;s safe
					 * to apply the fix.
					 */
					nodesToReport.length === nodes.length;

				if (
					!isVarDecParentNull &amp;&amp;
					varDeclParent.declarations &amp;&amp;
					varDeclParent.declarations.length !== 1
				) {
					if (
						varDeclParent &amp;&amp;
						varDeclParent.declarations &amp;&amp;
						varDeclParent.declarations.length &gt;= 1
					) {
						/*
						 * Add nodesToReport.length to a count, then comparing the count to the length
						 * of the declarations in the current block.
						 */

						reportCount += nodesToReport.length;

						let totalDeclarationsCount = 0;

						varDeclParent.declarations.forEach(declaration =&gt; {
							if (declaration.id.type === &quot;ObjectPattern&quot;) {
								totalDeclarationsCount +=
									declaration.id.properties.length;
							} else if (declaration.id.type === &quot;ArrayPattern&quot;) {
								totalDeclarationsCount +=
									declaration.id.elements.length;
							} else {
								totalDeclarationsCount += 1;
							}
						});

						shouldFix =
							shouldFix &amp;&amp; reportCount === totalDeclarationsCount;
					}
				}

				nodesToReport.forEach(node =&gt; {
					context.report({
						node,
						messageId: &quot;useConst&quot;,
						data: node,
						fix: shouldFix
							? fixer =&gt; {
									const letKeywordToken =
										sourceCode.getFirstToken(
											varDeclParent,
											t =&gt; t.value === varDeclParent.kind,
										);

									/**
									 * Extend the replacement range to the whole declaration,
									 * in order to prevent other fixes in the same pass
									 * https://github.com/eslint/eslint/issues/13899
									 */
									return new FixTracker(fixer, sourceCode)
										.retainRange(varDeclParent.range)
										.replaceTextRange(
											letKeywordToken.range,
											&quot;const&quot;,
										);
								}
							: null,
					});
				});
			}
		}

		return {
			&quot;Program:exit&quot;() {
				groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(
					checkGroup,
				);
			},

			VariableDeclaration(node) {
				if (node.kind === &quot;let&quot; &amp;&amp; !isInitOfForStatement(node)) {
					variables.push(...sourceCode.getDeclaredVariables(node));
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
