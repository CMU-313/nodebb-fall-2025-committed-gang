<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/function-paren-newline.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/function-paren-newline.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">369</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">55.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.17</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview enforce consistent line breaks inside function parentheses
 * @author Teddy Katz
 * @deprecated in ESLint v8.53.0
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin&quot;,
						url: &quot;https://eslint.style&quot;,
					},
					rule: {
						name: &quot;function-paren-newline&quot;,
						url: &quot;https://eslint.style/rules/function-paren-newline&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description:
				&quot;Enforce consistent line breaks inside function parentheses&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/function-paren-newline&quot;,
		},

		fixable: &quot;whitespace&quot;,

		schema: [
			{
				oneOf: [
					{
						enum: [
							&quot;always&quot;,
							&quot;never&quot;,
							&quot;consistent&quot;,
							&quot;multiline&quot;,
							&quot;multiline-arguments&quot;,
						],
					},
					{
						type: &quot;object&quot;,
						properties: {
							minItems: {
								type: &quot;integer&quot;,
								minimum: 0,
							},
						},
						additionalProperties: false,
					},
				],
			},
		],

		messages: {
			expectedBefore: &quot;Expected newline before &#039;)&#039;.&quot;,
			expectedAfter: &quot;Expected newline after &#039;(&#039;.&quot;,
			expectedBetween: &quot;Expected newline between arguments/params.&quot;,
			unexpectedBefore: &quot;Unexpected newline before &#039;)&#039;.&quot;,
			unexpectedAfter: &quot;Unexpected newline after &#039;(&#039;.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;
		const rawOption = context.options[0] || &quot;multiline&quot;;
		const multilineOption = rawOption === &quot;multiline&quot;;
		const multilineArgumentsOption = rawOption === &quot;multiline-arguments&quot;;
		const consistentOption = rawOption === &quot;consistent&quot;;
		let minItems;

		if (typeof rawOption === &quot;object&quot;) {
			minItems = rawOption.minItems;
		} else if (rawOption === &quot;always&quot;) {
			minItems = 0;
		} else if (rawOption === &quot;never&quot;) {
			minItems = Infinity;
		} else {
			minItems = null;
		}

		//----------------------------------------------------------------------
		// Helpers
		//----------------------------------------------------------------------

		/**
		 * Determines whether there should be newlines inside function parens
		 * @param {ASTNode[]} elements The arguments or parameters in the list
		 * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.
		 * @returns {boolean} `true` if there should be newlines inside the function parens
		 */
		function shouldHaveNewlines(elements, hasLeftNewline) {
			if (multilineArgumentsOption &amp;&amp; elements.length === 1) {
				return hasLeftNewline;
			}
			if (multilineOption || multilineArgumentsOption) {
				return elements.some(
					(element, index) =&gt;
						index !== elements.length - 1 &amp;&amp;
						element.loc.end.line !==
							elements[index + 1].loc.start.line,
				);
			}
			if (consistentOption) {
				return hasLeftNewline;
			}
			return elements.length &gt;= minItems;
		}

		/**
		 * Validates parens
		 * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
		 * @param {ASTNode[]} elements The arguments or parameters in the list
		 * @returns {void}
		 */
		function validateParens(parens, elements) {
			const leftParen = parens.leftParen;
			const rightParen = parens.rightParen;
			const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
			const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
			const hasLeftNewline = !astUtils.isTokenOnSameLine(
				leftParen,
				tokenAfterLeftParen,
			);
			const hasRightNewline = !astUtils.isTokenOnSameLine(
				tokenBeforeRightParen,
				rightParen,
			);
			const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

			if (hasLeftNewline &amp;&amp; !needsNewlines) {
				context.report({
					node: leftParen,
					messageId: &quot;unexpectedAfter&quot;,
					fix(fixer) {
						return sourceCode
							.getText()
							.slice(
								leftParen.range[1],
								tokenAfterLeftParen.range[0],
							)
							.trim()
							? // If there is a comment between the ( and the first element, don&#039;t do a fix.
								null
							: fixer.removeRange([
									leftParen.range[1],
									tokenAfterLeftParen.range[0],
								]);
					},
				});
			} else if (!hasLeftNewline &amp;&amp; needsNewlines) {
				context.report({
					node: leftParen,
					messageId: &quot;expectedAfter&quot;,
					fix: fixer =&gt; fixer.insertTextAfter(leftParen, &quot;\n&quot;),
				});
			}

			if (hasRightNewline &amp;&amp; !needsNewlines) {
				context.report({
					node: rightParen,
					messageId: &quot;unexpectedBefore&quot;,
					fix(fixer) {
						return sourceCode
							.getText()
							.slice(
								tokenBeforeRightParen.range[1],
								rightParen.range[0],
							)
							.trim()
							? // If there is a comment between the last element and the ), don&#039;t do a fix.
								null
							: fixer.removeRange([
									tokenBeforeRightParen.range[1],
									rightParen.range[0],
								]);
					},
				});
			} else if (!hasRightNewline &amp;&amp; needsNewlines) {
				context.report({
					node: rightParen,
					messageId: &quot;expectedBefore&quot;,
					fix: fixer =&gt; fixer.insertTextBefore(rightParen, &quot;\n&quot;),
				});
			}
		}

		/**
		 * Validates a list of arguments or parameters
		 * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
		 * @param {ASTNode[]} elements The arguments or parameters in the list
		 * @returns {void}
		 */
		function validateArguments(parens, elements) {
			const leftParen = parens.leftParen;
			const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
			const hasLeftNewline = !astUtils.isTokenOnSameLine(
				leftParen,
				tokenAfterLeftParen,
			);
			const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

			for (let i = 0; i &lt;= elements.length - 2; i++) {
				const currentElement = elements[i];
				const nextElement = elements[i + 1];
				const hasNewLine =
					currentElement.loc.end.line !== nextElement.loc.start.line;

				if (!hasNewLine &amp;&amp; needsNewlines) {
					context.report({
						node: currentElement,
						messageId: &quot;expectedBetween&quot;,
						fix: fixer =&gt; fixer.insertTextBefore(nextElement, &quot;\n&quot;),
					});
				}
			}
		}

		/**
		 * Gets the left paren and right paren tokens of a node.
		 * @param {ASTNode} node The node with parens
		 * @throws {TypeError} Unexpected node type.
		 * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.
		 * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression
		 * with a single parameter)
		 */
		function getParenTokens(node) {
			switch (node.type) {
				case &quot;NewExpression&quot;:
					if (
						!node.arguments.length &amp;&amp;
						!(
							astUtils.isOpeningParenToken(
								sourceCode.getLastToken(node, { skip: 1 }),
							) &amp;&amp;
							astUtils.isClosingParenToken(
								sourceCode.getLastToken(node),
							) &amp;&amp;
							node.callee.range[1] &lt; node.range[1]
						)
					) {
						// If the NewExpression does not have parens (e.g. `new Foo`), return null.
						return null;
					}

				// falls through

				case &quot;CallExpression&quot;:
					return {
						leftParen: sourceCode.getTokenAfter(
							node.callee,
							astUtils.isOpeningParenToken,
						),
						rightParen: sourceCode.getLastToken(node),
					};

				case &quot;FunctionDeclaration&quot;:
				case &quot;FunctionExpression&quot;: {
					const leftParen = sourceCode.getFirstToken(
						node,
						astUtils.isOpeningParenToken,
					);
					const rightParen = node.params.length
						? sourceCode.getTokenAfter(
								node.params.at(-1),
								astUtils.isClosingParenToken,
							)
						: sourceCode.getTokenAfter(leftParen);

					return { leftParen, rightParen };
				}

				case &quot;ArrowFunctionExpression&quot;: {
					const firstToken = sourceCode.getFirstToken(node, {
						skip: node.async ? 1 : 0,
					});

					if (!astUtils.isOpeningParenToken(firstToken)) {
						// If the ArrowFunctionExpression has a single param without parens, return null.
						return null;
					}

					const rightParen = node.params.length
						? sourceCode.getTokenAfter(
								node.params.at(-1),
								astUtils.isClosingParenToken,
							)
						: sourceCode.getTokenAfter(firstToken);

					return {
						leftParen: firstToken,
						rightParen,
					};
				}

				case &quot;ImportExpression&quot;: {
					const leftParen = sourceCode.getFirstToken(node, 1);
					const rightParen = sourceCode.getLastToken(node);

					return { leftParen, rightParen };
				}

				default:
					throw new TypeError(
						`unexpected node with type ${node.type}`,
					);
			}
		}

		//----------------------------------------------------------------------
		// Public
		//----------------------------------------------------------------------

		return {
			[[
				&quot;ArrowFunctionExpression&quot;,
				&quot;CallExpression&quot;,
				&quot;FunctionDeclaration&quot;,
				&quot;FunctionExpression&quot;,
				&quot;ImportExpression&quot;,
				&quot;NewExpression&quot;,
			]](node) {
				const parens = getParenTokens(node);
				let params;

				if (node.type === &quot;ImportExpression&quot;) {
					params = [node.source];
				} else if (astUtils.isFunction(node)) {
					params = node.params;
				} else {
					params = node.arguments;
				}

				if (parens) {
					validateParens(parens, params);

					if (multilineArgumentsOption) {
						validateArguments(parens, params);
					}
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
