<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ignore/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ignore/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">81.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">637</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">41.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = &#039;&#039;
const SPACE = &#039; &#039;
const ESCAPE = &#039;\\&#039;
const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = &#039;/&#039;

// Do not use ternary expression here, since &quot;istanbul ignore next&quot; is buggy
let TMP_KEY_IGNORE = &#039;node-ignore&#039;
/* istanbul ignore else */
if (typeof Symbol !== &#039;undefined&#039;) {
  TMP_KEY_IGNORE = Symbol.for(&#039;node-ignore&#039;)
}
const KEY_IGNORE = TMP_KEY_IGNORE

const define = (object, key, value) =&gt;
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

const RETURN_FALSE = () =&gt; false

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range =&gt; range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) =&gt; from.charCodeAt(0) &lt;= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
)

// See fixtures #59
const cleanRangeBackSlash = slashes =&gt; {
  const {length} = slashes
  return slashes.slice(0, length - length % 2)
}

// &gt; If the pattern ends with a slash,
// &gt; it is removed for the purpose of the following description,
// &gt; but it would only find a match with a directory.
// &gt; In other words, foo/ will match a directory foo and paths underneath it,
// &gt; but will not match a regular file or a symbolic link foo
// &gt;  (this is consistent with the way how pathspec works in general in Git).
// &#039;`foo/`&#039; will not match regular file &#039;`foo`&#039; or symbolic link &#039;`foo`&#039;
// -&gt; ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// &#039;`foo/`&#039; should not continue with the &#039;`..`&#039;
const REPLACERS = [

  [
    // remove BOM
    // TODO:
    // Other similar zero-width characters?
    /^\uFEFF/,
    () =&gt; EMPTY
  ],

  // &gt; Trailing spaces are ignored unless they are quoted with backslash (&quot;\&quot;)
  [
    // (a\ ) -&gt; (a )
    // (a  ) -&gt; (a)
    // (a ) -&gt; (a)
    // (a \ ) -&gt; (a  )
    /((?:\\\\)*?)(\\?\s+)$/,
    (_, m1, m2) =&gt; m1 + (
      m2.indexOf(&#039;\\&#039;) === 0
        ? SPACE
        : EMPTY
    )
  ],

  // replace (\ ) with &#039; &#039;
  // (\ ) -&gt; &#039; &#039;
  // (\\ ) -&gt; &#039;\\ &#039;
  // (\\\ ) -&gt; &#039;\\ &#039;
  [
    /(\\+?)\s/g,
    (_, m1) =&gt; {
      const {length} = m1
      return m1.slice(0, length - length % 2) + SPACE
    }
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // &gt; There are 12 characters with special meanings:
  // &gt; - the backslash \,
  // &gt; - the caret ^,
  // &gt; - the dollar sign $,
  // &gt; - the period or dot .,
  // &gt; - the vertical bar or pipe symbol |,
  // &gt; - the question mark ?,
  // &gt; - the asterisk or star *,
  // &gt; - the plus sign +,
  // &gt; - the opening parenthesis (,
  // &gt; - the closing parenthesis ),
  // &gt; - and the opening square bracket [,
  // &gt; - the opening curly brace {,
  // &gt; These special characters are often called &quot;metacharacters&quot;.
  [
    /[\\$.|*+(){^]/g,
    match =&gt; `\\${match}`
  ],

  [
    // &gt; a question mark (?) matches a single character
    /(?!\\)\?/g,
    () =&gt; &#039;[^/]&#039;
  ],

  // leading slash
  [

    // &gt; A leading slash matches the beginning of the pathname.
    // &gt; For example, &quot;/*.c&quot; matches &quot;cat-file.c&quot; but not &quot;mozilla-sha1/sha1.c&quot;.
    // A leading slash matches the beginning of the pathname
    /^\//,
    () =&gt; &#039;^&#039;
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () =&gt; &#039;\\/&#039;
  ],

  [
    // &gt; A leading &quot;**&quot; followed by a slash means match in all directories.
    // &gt; For example, &quot;**/foo&quot; matches file or directory &quot;foo&quot; anywhere,
    // &gt; the same as pattern &quot;foo&quot;.
    // &gt; &quot;**/foo/bar&quot; matches file or directory &quot;bar&quot; anywhere that is directly
    // &gt;   under directory &quot;foo&quot;.
    // Notice that the &#039;*&#039;s have been replaced as &#039;\\*&#039;
    /^\^*\\\*\\\*\\\//,

    // &#039;**/foo&#039; &lt;-&gt; &#039;foo&#039;
    () =&gt; &#039;^(?:.*\\/)?&#039;
  ],

  // starting
  [
    // there will be no leading &#039;/&#039;
    //   (which has been replaced by section &quot;leading slash&quot;)
    // If starts with &#039;**&#039;, adding a &#039;^&#039; to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // &gt; Prior to 2.22.1
        // &gt; If the pattern does not contain a slash /,
        // &gt;   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // &gt; If there is a separator at the beginning or middle (or both)
        // &gt; of the pattern, then the pattern is relative to the directory
        // &gt; level of the particular .gitignore file itself.
        // &gt; Otherwise the pattern may also match at any level below
        // &gt; the .gitignore level.
        ? &#039;(?:^|\\/)&#039;

        // &gt; Otherwise, Git treats the pattern as a shell glob suitable for
        // &gt;   consumption by fnmatch(3)
        : &#039;^&#039;
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `&#039;/**&#039;`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use &#039;*&#039;, or it will be replaced by the next replacer

    // Check if it is not the last `&#039;/**&#039;`
    (_, index, str) =&gt; index + 6 &lt; str.length

      // case: /**/
      // &gt; A slash followed by two consecutive asterisks then a slash matches
      // &gt;   zero or more directories.
      // &gt; For example, &quot;a/**/b&quot; matches &quot;a/b&quot;, &quot;a/x/b&quot;, &quot;a/x/y/b&quot; and so on.
      // &#039;/**/&#039;
      ? &#039;(?:\\/[^\\/]+)*&#039;

      // case: /**
      // &gt; A trailing `&quot;/**&quot;` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : &#039;\\/.+&#039;
  ],

  // normal intermediate wildcards
  [
    // Never replace escaped &#039;*&#039;
    // ignore rule &#039;\*&#039; will match the path &#039;*&#039;

    // &#039;abc.*/&#039; -&gt; go
    // &#039;abc.*&#039;  -&gt; skip this rule,
    //    coz trailing single wildcard will be handed by [trailing wildcard]
    /(^|[^\\]+)(\\\*)+(?=.+)/g,

    // &#039;*.js&#039; matches &#039;.js&#039;
    // &#039;*.js&#039; doesn&#039;t match &#039;abc&#039;
    (_, p1, p2) =&gt; {
      // 1.
      // &gt; An asterisk &quot;*&quot; matches anything except a slash.
      // 2.
      // &gt; Other consecutive asterisks are considered regular asterisks
      // &gt; and will match according to the previous rules.
      const unescaped = p2.replace(/\\\*/g, &#039;[^\\/]*&#039;)
      return p1 + unescaped
    }
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a &#039;\\*&#039;,
    // after step 3, the result will be &#039;\\\\\\*&#039;
    /\\\\\\(?=[$.|*+(){^])/g,
    () =&gt; ESCAPE
  ],

  [
    // &#039;\\\\&#039; -&gt; &#039;\\&#039;
    /\\\\/g,
    () =&gt; ESCAPE
  ],

  [
    // &gt; The range notation, e.g. [a-zA-Z],
    // &gt; can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) =&gt; leadEscape === ESCAPE
      // &#039;\\[bar]&#039; -&gt; &#039;\\\\[bar\\]&#039;
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === &#039;]&#039;
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // &#039;[bar]&#039;
          // &#039;[bar\\\\]&#039;
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // &#039;[bar\\]&#039; -&gt; &#039;[bar\\\\]&#039;
          : &#039;[]&#039;
        : &#039;[]&#039;
  ],

  // ending
  [
    // &#039;js&#039; will not match &#039;js.&#039;
    // &#039;ab&#039; will not match &#039;abc&#039;
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // &gt; If there is a separator at the end of the pattern then the pattern
    // &gt; will only match directories, otherwise the pattern can match both
    // &gt; files and directories.

    // &#039;js*&#039; will not match &#039;a.js&#039;
    // &#039;js/&#039; will not match &#039;a.js&#039;
    // &#039;js&#039; will match &#039;a.js&#039; and &#039;a.js/&#039;
    match =&gt; /\/$/.test(match)
      // foo/ will not match &#039;foo&#039;
      ? `${match}$`
      // foo matches &#039;foo&#039; and &#039;foo/&#039;
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) =&gt; {
      const prefix = p1
        // &#039;\^&#039;:
        // &#039;/*&#039; does not match EMPTY
        // &#039;/*&#039; does not match everything

        // &#039;\\\/&#039;:
        // &#039;abc/*&#039; does not match &#039;abc/&#039;
        ? `${p1}[^/]+`

        // &#039;a*&#039; matches &#039;a&#039;
        // &#039;a*&#039; matches &#039;aa&#039;
        : &#039;[^/]*&#039;

      return `${prefix}(?=$|\\/$)`
    }
  ],
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, ignoreCase) =&gt; {
  let source = regexCache[pattern]

  if (!source) {
    source = REPLACERS.reduce(
      (prev, [matcher, replacer]) =&gt;
        prev.replace(matcher, replacer.bind(pattern)),
      pattern
    )
    regexCache[pattern] = source
  }

  return ignoreCase
    ? new RegExp(source, &#039;i&#039;)
    : new RegExp(source)
}

const isString = subject =&gt; typeof subject === &#039;string&#039;

// &gt; A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern =&gt; pattern
  &amp;&amp; isString(pattern)
  &amp;&amp; !REGEX_TEST_BLANK_LINE.test(pattern)
  &amp;&amp; !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)

  // &gt; A line starting with # serves as a comment.
  &amp;&amp; pattern.indexOf(&#039;#&#039;) !== 0

const splitPattern = pattern =&gt; pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignoreCase) =&gt; {
  const origin = pattern
  let negative = false

  // &gt; An optional prefix &quot;!&quot; which negates the pattern;
  if (pattern.indexOf(&#039;!&#039;) === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // &gt; Put a backslash (&quot;\&quot;) in front of the first &quot;!&quot; for patterns that
  // &gt;   begin with a literal &quot;!&quot;, for example, `&quot;\!important!.txt&quot;`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, &#039;!&#039;)
  // &gt; Put a backslash (&quot;\&quot;) in front of the first hash for patterns that
  // &gt;   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, &#039;#&#039;)

  const regex = makeRegex(pattern, ignoreCase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) =&gt; {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) =&gt; {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don&#039;t know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = &#039;`path.relative()`d&#039;
    return doThrow(
      `path should be a ${r} string, but got &quot;${originalPath}&quot;`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path =&gt; REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p =&gt; p

class Ignore {
  constructor ({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define(this, KEY_IGNORE, true)

    this._rules = []
    this._ignoreCase = ignoreCase
    this._allowRelativePaths = allowRelativePaths
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern &amp;&amp; pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignoreCase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array&lt;string&gt; | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule =&gt; {
      const {negative} = rule
      if (
        unignored === negative &amp;&amp; ignored !== unignored
        || negative &amp;&amp; !ignored &amp;&amp; !unignored &amp;&amp; !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      &amp;&amp; checkPath.convert(originalPath)

    checkPath(
      path,
      originalPath,
      this._allowRelativePaths
        ? RETURN_FALSE
        : throwError
    )

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // [&#039;path&#039;, &#039;to&#039;, &#039;a.js&#039;]
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // &gt; It is not possible to re-include a file if a parent directory of
      // &gt;   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path =&gt; !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options =&gt; new Ignore(options)

const isPathValid = path =&gt;
  checkPath(path &amp;&amp; checkPath.convert(path), path, RETURN_FALSE)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== &#039;undefined&#039;
  &amp;&amp; (
    process.env &amp;&amp; process.env.IGNORE_TEST_WIN32
    || process.platform === &#039;win32&#039;
  )
) {
  /* eslint no-control-regex: &quot;off&quot; */
  const makePosix = str =&gt; /^\\\\\?\\/.test(str)
  || /[&quot;&lt;&gt;|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, &#039;/&#039;)

  checkPath.convert = makePosix

  // &#039;C:\\foo&#039;     &lt;- &#039;C:\\foo&#039; has been converted to &#039;C:/&#039;
  // &#039;d:\\foo&#039;
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =&gt;
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
