<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/dashdash/lib/dashdash.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/dashdash/lib/dashdash.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1056</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">112.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * dashdash - A light, featureful and explicit option parsing library for
 * node.js.
 */
// vim: set ts=4 sts=4 sw=4 et:

var assert = require(&#039;assert-plus&#039;);
var format = require(&#039;util&#039;).format;
var fs = require(&#039;fs&#039;);
var path = require(&#039;path&#039;);


var DEBUG = true;
if (DEBUG) {
    var debug = console.warn;
} else {
    var debug = function () {};
}



// ---- internal support stuff

// Replace {{variable}} in `s` with the template data in `d`.
function renderTemplate(s, d) {
    return s.replace(/{{([a-zA-Z]+)}}/g, function (match, key) {
        return d.hasOwnProperty(key) ? d[key] : match;
    });
}

/**
 * Return a shallow copy of the given object;
 */
function shallowCopy(obj) {
    if (!obj) {
        return (obj);
    }
    var copy = {};
    Object.keys(obj).forEach(function (k) {
        copy[k] = obj[k];
    });
    return (copy);
}


function space(n) {
    var s = &#039;&#039;;
    for (var i = 0; i &lt; n; i++) {
        s += &#039; &#039;;
    }
    return s;
}


function makeIndent(arg, deflen, name) {
    if (arg === null || arg === undefined)
        return space(deflen);
    else if (typeof (arg) === &#039;number&#039;)
        return space(arg);
    else if (typeof (arg) === &#039;string&#039;)
        return arg;
    else
        assert.fail(&#039;invalid &quot;&#039; + name + &#039;&quot;: not a string or number: &#039; + arg);
}


/**
 * Return an array of lines wrapping the given text to the given width.
 * This splits on whitespace. Single tokens longer than `width` are not
 * broken up.
 */
function textwrap(s, width) {
    var words = s.trim().split(/\s+/);
    var lines = [];
    var line = &#039;&#039;;
    words.forEach(function (w) {
        var newLength = line.length + w.length;
        if (line.length &gt; 0)
            newLength += 1;
        if (newLength &gt; width) {
            lines.push(line);
            line = &#039;&#039;;
        }
        if (line.length &gt; 0)
            line += &#039; &#039;;
        line += w;
    });
    lines.push(line);
    return lines;
}


/**
 * Transform an option name to a &quot;key&quot; that is used as the field
 * on the `opts` object returned from `&lt;parser&gt;.parse()`.
 *
 * Transformations:
 * - &#039;-&#039; -&gt; &#039;_&#039;: This allow one to use hyphen in option names (common)
 *   but not have to do silly things like `opt[&quot;dry-run&quot;]` to access the
 *   parsed results.
 */
function optionKeyFromName(name) {
    return name.replace(/-/g, &#039;_&#039;);
}



// ---- Option types

function parseBool(option, optstr, arg) {
    return Boolean(arg);
}

function parseString(option, optstr, arg) {
    assert.string(arg, &#039;arg&#039;);
    return arg;
}

function parseNumber(option, optstr, arg) {
    assert.string(arg, &#039;arg&#039;);
    var num = Number(arg);
    if (isNaN(num)) {
        throw new Error(format(&#039;arg for &quot;%s&quot; is not a number: &quot;%s&quot;&#039;,
            optstr, arg));
    }
    return num;
}

function parseInteger(option, optstr, arg) {
    assert.string(arg, &#039;arg&#039;);
    var num = Number(arg);
    if (!/^[0-9-]+$/.test(arg) || isNaN(num)) {
        throw new Error(format(&#039;arg for &quot;%s&quot; is not an integer: &quot;%s&quot;&#039;,
            optstr, arg));
    }
    return num;
}

function parsePositiveInteger(option, optstr, arg) {
    assert.string(arg, &#039;arg&#039;);
    var num = Number(arg);
    if (!/^[0-9]+$/.test(arg) || isNaN(num) || num === 0) {
        throw new Error(format(&#039;arg for &quot;%s&quot; is not a positive integer: &quot;%s&quot;&#039;,
            optstr, arg));
    }
    return num;
}

/**
 * Supported date args:
 * - epoch second times (e.g. 1396031701)
 * - ISO 8601 format: YYYY-MM-DD[THH:MM:SS[.sss][Z]]
 *      2014-03-28T18:35:01.489Z
 *      2014-03-28T18:35:01.489
 *      2014-03-28T18:35:01Z
 *      2014-03-28T18:35:01
 *      2014-03-28
 */
function parseDate(option, optstr, arg) {
    assert.string(arg, &#039;arg&#039;);
    var date;
    if (/^\d+$/.test(arg)) {
        // epoch seconds
        date = new Date(Number(arg) * 1000);
    /* JSSTYLED */
    } else if (/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?Z?)?$/i.test(arg)) {
        // ISO 8601 format
        date = new Date(arg);
    } else {
        throw new Error(format(&#039;arg for &quot;%s&quot; is not a valid date format: &quot;%s&quot;&#039;,
            optstr, arg));
    }
    if (date.toString() === &#039;Invalid Date&#039;) {
        throw new Error(format(&#039;arg for &quot;%s&quot; is an invalid date: &quot;%s&quot;&#039;,
            optstr, arg));
    }
    return date;
}

var optionTypes = {
    bool: {
        takesArg: false,
        parseArg: parseBool
    },
    string: {
        takesArg: true,
        helpArg: &#039;ARG&#039;,
        parseArg: parseString
    },
    number: {
        takesArg: true,
        helpArg: &#039;NUM&#039;,
        parseArg: parseNumber
    },
    integer: {
        takesArg: true,
        helpArg: &#039;INT&#039;,
        parseArg: parseInteger
    },
    positiveInteger: {
        takesArg: true,
        helpArg: &#039;INT&#039;,
        parseArg: parsePositiveInteger
    },
    date: {
        takesArg: true,
        helpArg: &#039;DATE&#039;,
        parseArg: parseDate
    },
    arrayOfBool: {
        takesArg: false,
        array: true,
        parseArg: parseBool
    },
    arrayOfString: {
        takesArg: true,
        helpArg: &#039;ARG&#039;,
        array: true,
        parseArg: parseString
    },
    arrayOfNumber: {
        takesArg: true,
        helpArg: &#039;NUM&#039;,
        array: true,
        parseArg: parseNumber
    },
    arrayOfInteger: {
        takesArg: true,
        helpArg: &#039;INT&#039;,
        array: true,
        parseArg: parseInteger
    },
    arrayOfPositiveInteger: {
        takesArg: true,
        helpArg: &#039;INT&#039;,
        array: true,
        parseArg: parsePositiveInteger
    },
    arrayOfDate: {
        takesArg: true,
        helpArg: &#039;INT&#039;,
        array: true,
        parseArg: parseDate
    },
};



// ---- Parser

/**
 * Parser constructor.
 *
 * @param config {Object} The parser configuration
 *      - options {Array} Array of option specs. See the README for how to
 *        specify each option spec.
 *      - allowUnknown {Boolean} Default false. Whether to throw on unknown
 *        options. If false, then unknown args are included in the _args array.
 *      - interspersed {Boolean} Default true. Whether to allow interspersed
 *        arguments (non-options) and options. E.g.:
 *              node tool.js arg1 arg2 -v
 *        &#039;-v&#039; is after some args here. If `interspersed: false` then &#039;-v&#039;
 *        would not be parsed out. Note that regardless of `interspersed`
 *        the presence of &#039;--&#039; will stop option parsing, as all good
 *        option parsers should.
 */
function Parser(config) {
    assert.object(config, &#039;config&#039;);
    assert.arrayOfObject(config.options, &#039;config.options&#039;);
    assert.optionalBool(config.interspersed, &#039;config.interspersed&#039;);
    var self = this;

    // Allow interspersed arguments (true by default).
    this.interspersed = (config.interspersed !== undefined
        ? config.interspersed : true);

    // Don&#039;t allow unknown flags (true by default).
    this.allowUnknown = (config.allowUnknown !== undefined
        ? config.allowUnknown : false);

    this.options = config.options.map(function (o) { return shallowCopy(o); });
    this.optionFromName = {};
    this.optionFromEnv = {};
    for (var i = 0; i &lt; this.options.length; i++) {
        var o = this.options[i];
        if (o.group !== undefined &amp;&amp; o.group !== null) {
            assert.optionalString(o.group,
                format(&#039;config.options.%d.group&#039;, i));
            continue;
        }
        assert.ok(optionTypes[o.type],
            format(&#039;invalid config.options.%d.type: &quot;%s&quot; in %j&#039;,
                   i, o.type, o));
        assert.optionalString(o.name, format(&#039;config.options.%d.name&#039;, i));
        assert.optionalArrayOfString(o.names,
            format(&#039;config.options.%d.names&#039;, i));
        assert.ok((o.name || o.names) &amp;&amp; !(o.name &amp;&amp; o.names),
            format(&#039;exactly one of &quot;name&quot; or &quot;names&quot; required: %j&#039;, o));
        assert.optionalString(o.help, format(&#039;config.options.%d.help&#039;, i));
        var env = o.env || [];
        if (typeof (env) === &#039;string&#039;) {
            env = [env];
        }
        assert.optionalArrayOfString(env, format(&#039;config.options.%d.env&#039;, i));
        assert.optionalString(o.helpGroup,
            format(&#039;config.options.%d.helpGroup&#039;, i));
        assert.optionalBool(o.helpWrap,
            format(&#039;config.options.%d.helpWrap&#039;, i));
        assert.optionalBool(o.hidden, format(&#039;config.options.%d.hidden&#039;, i));

        if (o.name) {
            o.names = [o.name];
        } else {
            assert.string(o.names[0],
                format(&#039;config.options.%d.names is empty&#039;, i));
        }
        o.key = optionKeyFromName(o.names[0]);
        o.names.forEach(function (n) {
            if (self.optionFromName[n]) {
                throw new Error(format(
                    &#039;option name collision: &quot;%s&quot; used in %j and %j&#039;,
                    n, self.optionFromName[n], o));
            }
            self.optionFromName[n] = o;
        });
        env.forEach(function (n) {
            if (self.optionFromEnv[n]) {
                throw new Error(format(
                    &#039;option env collision: &quot;%s&quot; used in %j and %j&#039;,
                    n, self.optionFromEnv[n], o));
            }
            self.optionFromEnv[n] = o;
        });
    }
}

Parser.prototype.optionTakesArg = function optionTakesArg(option) {
    return optionTypes[option.type].takesArg;
};

/**
 * Parse options from the given argv.
 *
 * @param inputs {Object} Optional.
 *      - argv {Array} Optional. The argv to parse. Defaults to
 *        `process.argv`.
 *      - slice {Number} The index into argv at which options/args begin.
 *        Default is 2, as appropriate for `process.argv`.
 *      - env {Object} Optional. The env to use for &#039;env&#039; entries in the
 *        option specs. Defaults to `process.env`.
 * @returns {Object} Parsed `opts`. It has special keys `_args` (the
 *      remaining args from `argv`) and `_order` (gives the order that
 *      options were specified).
 */
Parser.prototype.parse = function parse(inputs) {
    var self = this;

    // Old API was `parse([argv, [slice]])`
    if (Array.isArray(arguments[0])) {
        inputs = {argv: arguments[0], slice: arguments[1]};
    }

    assert.optionalObject(inputs, &#039;inputs&#039;);
    if (!inputs) {
        inputs = {};
    }
    assert.optionalArrayOfString(inputs.argv, &#039;inputs.argv&#039;);
    //assert.optionalNumber(slice, &#039;slice&#039;);
    var argv = inputs.argv || process.argv;
    var slice = inputs.slice !== undefined ? inputs.slice : 2;
    var args = argv.slice(slice);
    var env = inputs.env || process.env;
    var opts = {};
    var _order = [];

    function addOpt(option, optstr, key, val, from) {
        var type = optionTypes[option.type];
        var parsedVal = type.parseArg(option, optstr, val);
        if (type.array) {
            if (!opts[key]) {
                opts[key] = [];
            }
            if (type.arrayFlatten &amp;&amp; Array.isArray(parsedVal)) {
                for (var i = 0; i &lt; parsedVal.length; i++) {
                    opts[key].push(parsedVal[i]);
                }
            } else {
                opts[key].push(parsedVal);
            }
        } else {
            opts[key] = parsedVal;
        }
        var item = { key: key, value: parsedVal, from: from };
        _order.push(item);
    }

    // Parse args.
    var _args = [];
    var i = 0;
    outer: while (i &lt; args.length) {
        var arg = args[i];

        // End of options marker.
        if (arg === &#039;--&#039;) {
            i++;
            break;

        // Long option
        } else if (arg.slice(0, 2) === &#039;--&#039;) {
            var name = arg.slice(2);
            var val = null;
            var idx = name.indexOf(&#039;=&#039;);
            if (idx !== -1) {
                val = name.slice(idx + 1);
                name = name.slice(0, idx);
            }
            var option = this.optionFromName[name];
            if (!option) {
                if (!this.allowUnknown)
                    throw new Error(format(&#039;unknown option: &quot;--%s&quot;&#039;, name));
                else if (this.interspersed)
                    _args.push(arg);
                else
                    break outer;
            } else {
                var takesArg = this.optionTakesArg(option);
                if (val !== null &amp;&amp; !takesArg) {
                    throw new Error(format(&#039;argument given to &quot;--%s&quot; option &#039;
                        + &#039;that does not take one: &quot;%s&quot;&#039;, name, arg));
                }
                if (!takesArg) {
                    addOpt(option, &#039;--&#039;+name, option.key, true, &#039;argv&#039;);
                } else if (val !== null) {
                    addOpt(option, &#039;--&#039;+name, option.key, val, &#039;argv&#039;);
                } else if (i + 1 &gt;= args.length) {
                    throw new Error(format(&#039;do not have enough args for &quot;--%s&quot; &#039;
                        + &#039;option&#039;, name));
                } else {
                    addOpt(option, &#039;--&#039;+name, option.key, args[i + 1], &#039;argv&#039;);
                    i++;
                }
            }

        // Short option
        } else if (arg[0] === &#039;-&#039; &amp;&amp; arg.length &gt; 1) {
            var j = 1;
            var allFound = true;
            while (j &lt; arg.length) {
                var name = arg[j];
                var option = this.optionFromName[name];
                if (!option) {
                    allFound = false;
                    if (this.allowUnknown) {
                        if (this.interspersed) {
                            _args.push(arg);
                            break;
                        } else
                            break outer;
                    } else if (arg.length &gt; 2) {
                        throw new Error(format(
                            &#039;unknown option: &quot;-%s&quot; in &quot;%s&quot; group&#039;,
                            name, arg));
                    } else {
                        throw new Error(format(&#039;unknown option: &quot;-%s&quot;&#039;, name));
                    }
                } else if (this.optionTakesArg(option)) {
                    break;
                }
                j++;
            }

            j = 1;
            while (allFound &amp;&amp; j &lt; arg.length) {
                var name = arg[j];
                var val = arg.slice(j + 1);  // option val if it takes an arg
                var option = this.optionFromName[name];
                var takesArg = this.optionTakesArg(option);
                if (!takesArg) {
                    addOpt(option, &#039;-&#039;+name, option.key, true, &#039;argv&#039;);
                } else if (val) {
                    addOpt(option, &#039;-&#039;+name, option.key, val, &#039;argv&#039;);
                    break;
                } else {
                    if (i + 1 &gt;= args.length) {
                        throw new Error(format(&#039;do not have enough args &#039;
                            + &#039;for &quot;-%s&quot; option&#039;, name));
                    }
                    addOpt(option, &#039;-&#039;+name, option.key, args[i + 1], &#039;argv&#039;);
                    i++;
                    break;
                }
                j++;
            }

        // An interspersed arg
        } else if (this.interspersed) {
            _args.push(arg);

        // An arg and interspersed args are not allowed, so done options.
        } else {
            break outer;
        }
        i++;
    }
    _args = _args.concat(args.slice(i));

    // Parse environment.
    Object.keys(this.optionFromEnv).forEach(function (envname) {
        var val = env[envname];
        if (val === undefined)
            return;
        var option = self.optionFromEnv[envname];
        if (opts[option.key] !== undefined)
            return;
        var takesArg = self.optionTakesArg(option);
        if (takesArg) {
            addOpt(option, envname, option.key, val, &#039;env&#039;);
        } else if (val !== &#039;&#039;) {
            // Boolean envvar handling:
            // - VAR=&lt;empty-string&gt;     not set (as if the VAR was not set)
            // - VAR=0                  false
            // - anything else          true
            addOpt(option, envname, option.key, (val !== &#039;0&#039;), &#039;env&#039;);
        }
    });

    // Apply default values.
    this.options.forEach(function (o) {
        if (opts[o.key] === undefined) {
            if (o.default !== undefined) {
                opts[o.key] = o.default;
            } else if (o.type &amp;&amp; optionTypes[o.type].default !== undefined) {
                opts[o.key] = optionTypes[o.type].default;
            }
        }
    });

    opts._order = _order;
    opts._args = _args;
    return opts;
};


/**
 * Return help output for the current options.
 *
 * E.g.: if the current options are:
 *      [{names: [&#039;help&#039;, &#039;h&#039;], type: &#039;bool&#039;, help: &#039;Show help and exit.&#039;}]
 * then this would return:
 *      &#039;  -h, --help     Show help and exit.\n&#039;
 *
 * @param config {Object} Config for controlling the option help output.
 *      - indent {Number|String} Default 4. An indent/prefix to use for
 *        each option line.
 *      - nameSort {String} Default is &#039;length&#039;. By default the names are
 *        sorted to put the short opts first (i.e. &#039;-h, --help&#039; preferred
 *        to &#039;--help, -h&#039;). Set to &#039;none&#039; to not do this sorting.
 *      - maxCol {Number} Default 80. Note that long tokens in a help string
 *        can go past this.
 *      - helpCol {Number} Set to specify a specific column at which
 *        option help will be aligned. By default this is determined
 *        automatically.
 *      - minHelpCol {Number} Default 20.
 *      - maxHelpCol {Number} Default 40.
 *      - includeEnv {Boolean} Default false. If true, a note stating the `env`
 *        envvar (if specified for this option) will be appended to the help
 *        output.
 *      - includeDefault {Boolean} Default false. If true, a note stating
 *        the `default` for this option, if any, will be appended to the help
 *        output.
 *      - helpWrap {Boolean} Default true. Wrap help text in helpCol..maxCol
 *        bounds.
 * @returns {String}
 */
Parser.prototype.help = function help(config) {
    config = config || {};
    assert.object(config, &#039;config&#039;);

    var indent = makeIndent(config.indent, 4, &#039;config.indent&#039;);
    var headingIndent = makeIndent(config.headingIndent,
        Math.round(indent.length / 2), &#039;config.headingIndent&#039;);

    assert.optionalString(config.nameSort, &#039;config.nameSort&#039;);
    var nameSort = config.nameSort || &#039;length&#039;;
    assert.ok(~[&#039;length&#039;, &#039;none&#039;].indexOf(nameSort),
        &#039;invalid &quot;config.nameSort&quot;&#039;);
    assert.optionalNumber(config.maxCol, &#039;config.maxCol&#039;);
    assert.optionalNumber(config.maxHelpCol, &#039;config.maxHelpCol&#039;);
    assert.optionalNumber(config.minHelpCol, &#039;config.minHelpCol&#039;);
    assert.optionalNumber(config.helpCol, &#039;config.helpCol&#039;);
    assert.optionalBool(config.includeEnv, &#039;config.includeEnv&#039;);
    assert.optionalBool(config.includeDefault, &#039;config.includeDefault&#039;);
    assert.optionalBool(config.helpWrap, &#039;config.helpWrap&#039;);
    var maxCol = config.maxCol || 80;
    var minHelpCol = config.minHelpCol || 20;
    var maxHelpCol = config.maxHelpCol || 40;

    var lines = [];
    var maxWidth = 0;
    this.options.forEach(function (o) {
        if (o.hidden) {
            return;
        }
        if (o.group !== undefined &amp;&amp; o.group !== null) {
            // We deal with groups in the next pass
            lines.push(null);
            return;
        }
        var type = optionTypes[o.type];
        var arg = o.helpArg || type.helpArg || &#039;ARG&#039;;
        var line = &#039;&#039;;
        var names = o.names.slice();
        if (nameSort === &#039;length&#039;) {
            names.sort(function (a, b) {
                if (a.length &lt; b.length)
                    return -1;
                else if (b.length &lt; a.length)
                    return 1;
                else
                    return 0;
            })
        }
        names.forEach(function (name, i) {
            if (i &gt; 0)
                line += &#039;, &#039;;
            if (name.length === 1) {
                line += &#039;-&#039; + name
                if (type.takesArg)
                    line += &#039; &#039; + arg;
            } else {
                line += &#039;--&#039; + name
                if (type.takesArg)
                    line += &#039;=&#039; + arg;
            }
        });
        maxWidth = Math.max(maxWidth, line.length);
        lines.push(line);
    });

    // Add help strings.
    var helpCol = config.helpCol;
    if (!helpCol) {
        helpCol = maxWidth + indent.length + 2;
        helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);
    }
    var i = -1;
    this.options.forEach(function (o) {
        if (o.hidden) {
            return;
        }
        i++;

        if (o.group !== undefined &amp;&amp; o.group !== null) {
            if (o.group === &#039;&#039;) {
                // Support a empty string &quot;group&quot; to have a blank line between
                // sets of options.
                lines[i] = &#039;&#039;;
            } else {
                // Render the group heading with the heading-specific indent.
                lines[i] = (i === 0 ? &#039;&#039; : &#039;\n&#039;) + headingIndent +
                    o.group + &#039;:&#039;;
            }
            return;
        }

        var helpDefault;
        if (config.includeDefault) {
            if (o.default !== undefined) {
                helpDefault = format(&#039;Default: %j&#039;, o.default);
            } else if (o.type &amp;&amp; optionTypes[o.type].default !== undefined) {
                helpDefault = format(&#039;Default: %j&#039;,
                    optionTypes[o.type].default);
            }
        }

        var line = lines[i] = indent + lines[i];
        if (!o.help &amp;&amp; !(config.includeEnv &amp;&amp; o.env) &amp;&amp; !helpDefault) {
            return;
        }
        var n = helpCol - line.length;
        if (n &gt;= 0) {
            line += space(n);
        } else {
            line += &#039;\n&#039; + space(helpCol);
        }

        var helpEnv = &#039;&#039;;
        if (o.env &amp;&amp; o.env.length &amp;&amp; config.includeEnv) {
            helpEnv += &#039;Environment: &#039;;
            var type = optionTypes[o.type];
            var arg = o.helpArg || type.helpArg || &#039;ARG&#039;;
            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(
                function (e) {
                    if (type.takesArg) {
                        return e + &#039;=&#039; + arg;
                    } else {
                        return e + &#039;=1&#039;;
                    }
                }
            );
            helpEnv += envs.join(&#039;, &#039;);
        }
        var help = (o.help || &#039;&#039;).trim();
        if (o.helpWrap !== false &amp;&amp; config.helpWrap !== false) {
            // Wrap help description normally.
            if (help.length &amp;&amp; !~&#039;.!?&quot;\&#039;&#039;.indexOf(help.slice(-1))) {
                help += &#039;.&#039;;
            }
            if (help.length) {
                help += &#039; &#039;;
            }
            help += helpEnv;
            if (helpDefault) {
                if (helpEnv) {
                    help += &#039;. &#039;;
                }
                help += helpDefault;
            }
            line += textwrap(help, maxCol - helpCol).join(
                &#039;\n&#039; + space(helpCol));
        } else {
            // Do not wrap help description, but indent newlines appropriately.
            var helpLines = help.split(&#039;\n&#039;).filter(
                    function (ln) { return ln.length });
            if (helpEnv !== &#039;&#039;) {
                helpLines.push(helpEnv);
            }
            if (helpDefault) {
                helpLines.push(helpDefault);
            }
            line += helpLines.join(&#039;\n&#039; + space(helpCol));
        }

        lines[i] = line;
    });

    var rv = &#039;&#039;;
    if (lines.length &gt; 0) {
        rv = lines.join(&#039;\n&#039;) + &#039;\n&#039;;
    }
    return rv;
};


/**
 * Return a string suitable for a Bash completion file for this tool.
 *
 * @param args.name {String} The tool name.
 * @param args.specExtra {String} Optional. Extra Bash code content to add
 *      to the end of the &quot;spec&quot;. Typically this is used to append Bash
 *      &quot;complete_TYPE&quot; functions for custom option types. See
 *      &quot;examples/ddcompletion.js&quot; for an example.
 * @param args.argtypes {Array} Optional. Array of completion types for
 *      positional args (i.e. non-options). E.g.
 *          argtypes = [&#039;fruit&#039;, &#039;veggie&#039;, &#039;file&#039;]
 *      will result in completion of fruits for the first arg, veggies for the
 *      second, and filenames for the third and subsequent positional args.
 *      If not given, positional args will use Bash&#039;s &#039;default&#039; completion.
 *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
 *      `complete_fruit` and `complete_veggie` in this example.
 */
Parser.prototype.bashCompletion = function bashCompletion(args) {
    assert.object(args, &#039;args&#039;);
    assert.string(args.name, &#039;args.name&#039;);
    assert.optionalString(args.specExtra, &#039;args.specExtra&#039;);
    assert.optionalArrayOfString(args.argtypes, &#039;args.argtypes&#039;);

    return bashCompletionFromOptions({
        name: args.name,
        specExtra: args.specExtra,
        argtypes: args.argtypes,
        options: this.options
    });
};


// ---- Bash completion

const BASH_COMPLETION_TEMPLATE_PATH = path.join(
    __dirname, &#039;../etc/dashdash.bash_completion.in&#039;);

/**
 * Return the Bash completion &quot;spec&quot; (the string value for the &quot;{{spec}}&quot;
 * var in the &quot;dashdash.bash_completion.in&quot; template) for this tool.
 *
 * The &quot;spec&quot; is Bash code that defines the CLI options and subcmds for
 * the template&#039;s completion code. It looks something like this:
 *
 *      local cmd_shortopts=&quot;-J ...&quot;
 *      local cmd_longopts=&quot;--help ...&quot;
 *      local cmd_optargs=&quot;-p=tritonprofile ...&quot;
 *
 * @param args.options {Array} The array of dashdash option specs.
 * @param args.context {String} Optional. A context string for the &quot;local cmd*&quot;
 *      vars in the spec. By default it is the empty string. When used to
 *      scope for completion on a *sub-command* (e.g. for &quot;git log&quot; on a &quot;git&quot;
 *      tool), then it would have a value (e.g. &quot;__log&quot;). See
 *      &lt;http://github.com/trentm/node-cmdln&gt; Bash completion for details.
 * @param opts.includeHidden {Boolean} Optional. Default false. By default
 *      hidden options and subcmds are &quot;excluded&quot;. Here excluded means they
 *      won&#039;t be offered as a completion, but if used, their argument type
 *      will be completed. &quot;Hidden&quot; options and subcmds are ones with the
 *      `hidden: true` attribute to exclude them from default help output.
 * @param args.argtypes {Array} Optional. Array of completion types for
 *      positional args (i.e. non-options). E.g.
 *          argtypes = [&#039;fruit&#039;, &#039;veggie&#039;, &#039;file&#039;]
 *      will result in completion of fruits for the first arg, veggies for the
 *      second, and filenames for the third and subsequent positional args.
 *      If not given, positional args will use Bash&#039;s &#039;default&#039; completion.
 *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
 *      `complete_fruit` and `complete_veggie` in this example.
 */
function bashCompletionSpecFromOptions(args) {
    assert.object(args, &#039;args&#039;);
    assert.object(args.options, &#039;args.options&#039;);
    assert.optionalString(args.context, &#039;args.context&#039;);
    assert.optionalBool(args.includeHidden, &#039;args.includeHidden&#039;);
    assert.optionalArrayOfString(args.argtypes, &#039;args.argtypes&#039;);

    var context = args.context || &#039;&#039;;
    var includeHidden = (args.includeHidden === undefined
        ? false : args.includeHidden);

    var spec = [];
    var shortopts = [];
    var longopts = [];
    var optargs = [];
    (args.options || []).forEach(function (o) {
        if (o.group !== undefined &amp;&amp; o.group !== null) {
            // Skip group headers.
            return;
        }

        var optNames = o.names || [o.name];
        var optType = getOptionType(o.type);
        if (optType.takesArg) {
            var completionType = o.completionType ||
                optType.completionType || o.type;
            optNames.forEach(function (optName) {
                if (optName.length === 1) {
                    if (includeHidden || !o.hidden) {
                        shortopts.push(&#039;-&#039; + optName);
                    }
                    // Include even hidden options in `optargs` so that bash
                    // completion of its arg still works.
                    optargs.push(&#039;-&#039; + optName + &#039;=&#039; + completionType);
                } else {
                    if (includeHidden || !o.hidden) {
                        longopts.push(&#039;--&#039; + optName);
                    }
                    optargs.push(&#039;--&#039; + optName + &#039;=&#039; + completionType);
                }
            });
        } else {
            optNames.forEach(function (optName) {
                if (includeHidden || !o.hidden) {
                    if (optName.length === 1) {
                        shortopts.push(&#039;-&#039; + optName);
                    } else {
                        longopts.push(&#039;--&#039; + optName);
                    }
                }
            });
        }
    });

    spec.push(format(&#039;local cmd%s_shortopts=&quot;%s&quot;&#039;,
        context, shortopts.sort().join(&#039; &#039;)));
    spec.push(format(&#039;local cmd%s_longopts=&quot;%s&quot;&#039;,
        context, longopts.sort().join(&#039; &#039;)));
    spec.push(format(&#039;local cmd%s_optargs=&quot;%s&quot;&#039;,
        context, optargs.sort().join(&#039; &#039;)));
    if (args.argtypes) {
        spec.push(format(&#039;local cmd%s_argtypes=&quot;%s&quot;&#039;,
            context, args.argtypes.join(&#039; &#039;)));
    }
    return spec.join(&#039;\n&#039;);
}


/**
 * Return a string suitable for a Bash completion file for this tool.
 *
 * @param args.name {String} The tool name.
 * @param args.options {Array} The array of dashdash option specs.
 * @param args.specExtra {String} Optional. Extra Bash code content to add
 *      to the end of the &quot;spec&quot;. Typically this is used to append Bash
 *      &quot;complete_TYPE&quot; functions for custom option types. See
 *      &quot;examples/ddcompletion.js&quot; for an example.
 * @param args.argtypes {Array} Optional. Array of completion types for
 *      positional args (i.e. non-options). E.g.
 *          argtypes = [&#039;fruit&#039;, &#039;veggie&#039;, &#039;file&#039;]
 *      will result in completion of fruits for the first arg, veggies for the
 *      second, and filenames for the third and subsequent positional args.
 *      If not given, positional args will use Bash&#039;s &#039;default&#039; completion.
 *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
 *      `complete_fruit` and `complete_veggie` in this example.
 */
function bashCompletionFromOptions(args) {
    assert.object(args, &#039;args&#039;);
    assert.object(args.options, &#039;args.options&#039;);
    assert.string(args.name, &#039;args.name&#039;);
    assert.optionalString(args.specExtra, &#039;args.specExtra&#039;);
    assert.optionalArrayOfString(args.argtypes, &#039;args.argtypes&#039;);

    // Gather template data.
    var data = {
        name: args.name,
        date: new Date(),
        spec: bashCompletionSpecFromOptions({
            options: args.options,
            argtypes: args.argtypes
        }),
    };
    if (args.specExtra) {
        data.spec += &#039;\n\n&#039; + args.specExtra;
    }

    // Render template.
    var template = fs.readFileSync(BASH_COMPLETION_TEMPLATE_PATH, &#039;utf8&#039;);
    return renderTemplate(template, data);
}



// ---- exports

function createParser(config) {
    return new Parser(config);
}

/**
 * Parse argv with the given options.
 *
 * @param config {Object} A merge of all the available fields from
 *      `dashdash.Parser` and `dashdash.Parser.parse`: options, interspersed,
 *      argv, env, slice.
 */
function parse(config) {
    assert.object(config, &#039;config&#039;);
    assert.optionalArrayOfString(config.argv, &#039;config.argv&#039;);
    assert.optionalObject(config.env, &#039;config.env&#039;);
    var config = shallowCopy(config);
    var argv = config.argv;
    delete config.argv;
    var env = config.env;
    delete config.env;

    var parser = new Parser(config);
    return parser.parse({argv: argv, env: env});
}


/**
 * Add a new option type.
 *
 * @params optionType {Object}:
 *      - name {String} Required.
 *      - takesArg {Boolean} Required. Whether this type of option takes an
 *        argument on process.argv. Typically this is true for all but the
 *        &quot;bool&quot; type.
 *      - helpArg {String} Required iff `takesArg === true`. The string to
 *        show in generated help for options of this type.
 *      - parseArg {Function} Require. `function (option, optstr, arg)` parser
 *        that takes a string argument and returns an instance of the
 *        appropriate type, or throws an error if the arg is invalid.
 *      - array {Boolean} Optional. Set to true if this is an &#039;arrayOf&#039; type
 *        that collects multiple usages of the option in process.argv and
 *        puts results in an array.
 *      - arrayFlatten {Boolean} Optional. XXX
 *      - default Optional. Default value for options of this type, if no
 *        default is specified in the option type usage.
 */
function addOptionType(optionType) {
    assert.object(optionType, &#039;optionType&#039;);
    assert.string(optionType.name, &#039;optionType.name&#039;);
    assert.bool(optionType.takesArg, &#039;optionType.takesArg&#039;);
    if (optionType.takesArg) {
        assert.string(optionType.helpArg, &#039;optionType.helpArg&#039;);
    }
    assert.func(optionType.parseArg, &#039;optionType.parseArg&#039;);
    assert.optionalBool(optionType.array, &#039;optionType.array&#039;);
    assert.optionalBool(optionType.arrayFlatten, &#039;optionType.arrayFlatten&#039;);

    optionTypes[optionType.name] = {
        takesArg: optionType.takesArg,
        helpArg: optionType.helpArg,
        parseArg: optionType.parseArg,
        array: optionType.array,
        arrayFlatten: optionType.arrayFlatten,
        default: optionType.default
    }
}


function getOptionType(name) {
    assert.string(name, &#039;name&#039;);
    return optionTypes[name];
}


/**
 * Return a synopsis string for the given option spec.
 *
 * Examples:
 *      &gt; synopsisFromOpt({names: [&#039;help&#039;, &#039;h&#039;], type: &#039;bool&#039;});
 *      &#039;[ --help | -h ]&#039;
 *      &gt; synopsisFromOpt({name: &#039;file&#039;, type: &#039;string&#039;, helpArg: &#039;FILE&#039;});
 *      &#039;[ --file=FILE ]&#039;
 */
function synopsisFromOpt(o) {
    assert.object(o, &#039;o&#039;);

    if (o.hasOwnProperty(&#039;group&#039;)) {
        return null;
    }
    var names = o.names || [o.name];
    // `type` here could be undefined if, for example, the command has a
    // dashdash option spec with a bogus &#039;type&#039;.
    var type = getOptionType(o.type);
    var helpArg = o.helpArg || (type &amp;&amp; type.helpArg) || &#039;ARG&#039;;
    var parts = [];
    names.forEach(function (name) {
        var part = (name.length === 1 ? &#039;-&#039; : &#039;--&#039;) + name;
        if (type &amp;&amp; type.takesArg) {
            part += (name.length === 1 ? &#039; &#039; + helpArg : &#039;=&#039; + helpArg);
        }
        parts.push(part);
    });
    return (&#039;[ &#039; + parts.join(&#039; | &#039;) + &#039; ]&#039;);
};


module.exports = {
    createParser: createParser,
    Parser: Parser,
    parse: parse,
    addOptionType: addOptionType,
    getOptionType: getOptionType,
    synopsisFromOpt: synopsisFromOpt,

    // Bash completion-related exports
    BASH_COMPLETION_TEMPLATE_PATH: BASH_COMPLETION_TEMPLATE_PATH,
    bashCompletionFromOptions: bashCompletionFromOptions,
    bashCompletionSpecFromOptions: bashCompletionSpecFromOptions,

    // Export the parseFoo parsers because they might be useful as primitives
    // for custom option types.
    parseBool: parseBool,
    parseString: parseString,
    parseNumber: parseNumber,
    parseInteger: parseInteger,
    parsePositiveInteger: parsePositiveInteger,
    parseDate: parseDate
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
