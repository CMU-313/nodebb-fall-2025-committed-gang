<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/build/CryptoEngine.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/build/CryptoEngine.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2433</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">192.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.70</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
	value: true
});

var _asn1js = require(&quot;asn1js&quot;);

var asn1js = _interopRequireWildcard(_asn1js);

var _pvutils = require(&quot;pvutils&quot;);

var _common = require(&quot;./common.js&quot;);

var _PublicKeyInfo = require(&quot;./PublicKeyInfo.js&quot;);

var _PublicKeyInfo2 = _interopRequireDefault(_PublicKeyInfo);

var _PrivateKeyInfo = require(&quot;./PrivateKeyInfo.js&quot;);

var _PrivateKeyInfo2 = _interopRequireDefault(_PrivateKeyInfo);

var _AlgorithmIdentifier = require(&quot;./AlgorithmIdentifier.js&quot;);

var _AlgorithmIdentifier2 = _interopRequireDefault(_AlgorithmIdentifier);

var _EncryptedContentInfo = require(&quot;./EncryptedContentInfo.js&quot;);

var _EncryptedContentInfo2 = _interopRequireDefault(_EncryptedContentInfo);

var _RSASSAPSSParams = require(&quot;./RSASSAPSSParams.js&quot;);

var _RSASSAPSSParams2 = _interopRequireDefault(_RSASSAPSSParams);

var _PBKDF2Params = require(&quot;./PBKDF2Params.js&quot;);

var _PBKDF2Params2 = _interopRequireDefault(_PBKDF2Params);

var _PBES2Params = require(&quot;./PBES2Params.js&quot;);

var _PBES2Params2 = _interopRequireDefault(_PBES2Params);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//**************************************************************************************
/**
 * Making MAC key using algorithm described in B.2 of PKCS#12 standard.
 */
function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {
	//region Initial variables
	let u;
	let v;

	const result = [];
	//endregion

	//region Get &quot;u&quot; and &quot;v&quot; values
	switch (hashAlgorithm.toUpperCase()) {
		case &quot;SHA-1&quot;:
			u = 20; // 160
			v = 64; // 512
			break;
		case &quot;SHA-256&quot;:
			u = 32; // 256
			v = 64; // 512
			break;
		case &quot;SHA-384&quot;:
			u = 48; // 384
			v = 128; // 1024
			break;
		case &quot;SHA-512&quot;:
			u = 64; // 512
			v = 128; // 1024
			break;
		default:
			throw new Error(&quot;Unsupported hashing algorithm&quot;);
	}
	//endregion

	//region Main algorithm making key
	//region Transform password to UTF-8 like string
	const passwordViewInitial = new Uint8Array(password);

	const passwordTransformed = new ArrayBuffer(password.byteLength * 2 + 2);
	const passwordTransformedView = new Uint8Array(passwordTransformed);

	for (let i = 0; i &lt; passwordViewInitial.length; i++) {
		passwordTransformedView[i * 2] = 0x00;
		passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
	}

	passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
	passwordTransformedView[passwordTransformedView.length - 1] = 0x00;

	password = passwordTransformed.slice(0);
	//endregion

	//region Construct a string D (the &quot;diversifier&quot;) by concatenating v/8 copies of ID
	const D = new ArrayBuffer(v);
	const dView = new Uint8Array(D);

	for (let i = 0; i &lt; D.byteLength; i++) dView[i] = 3; // The ID value equal to &quot;3&quot; for MACing (see B.3 of standard)
	//endregion

	//region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)
	const saltLength = salt.byteLength;

	const sLen = v * Math.ceil(saltLength / v);
	const S = new ArrayBuffer(sLen);
	const sView = new Uint8Array(S);

	const saltView = new Uint8Array(salt);

	for (let i = 0; i &lt; sLen; i++) sView[i] = saltView[i % saltLength];
	//endregion

	//region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)
	const passwordLength = password.byteLength;

	const pLen = v * Math.ceil(passwordLength / v);
	const P = new ArrayBuffer(pLen);
	const pView = new Uint8Array(P);

	const passwordView = new Uint8Array(password);

	for (let i = 0; i &lt; pLen; i++) pView[i] = passwordView[i % passwordLength];
	//endregion

	//region Set I=S||P to be the concatenation of S and P
	const sPlusPLength = S.byteLength + P.byteLength;

	let I = new ArrayBuffer(sPlusPLength);
	let iView = new Uint8Array(I);

	iView.set(sView);
	iView.set(pView, sView.length);
	//endregion

	//region Set c=ceil(n / u)
	const c = Math.ceil((keyLength &gt;&gt; 3) / u);
	//endregion

	//region Initial variables
	let internalSequence = Promise.resolve(I);
	//endregion

	//region For i=1, 2, ..., c, do the following:
	for (let i = 0; i &lt;= c; i++) {
		internalSequence = internalSequence.then(_I =&gt; {
			//region Create contecanetion of D and I
			const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
			const dAndIView = new Uint8Array(dAndI);

			dAndIView.set(dView);
			dAndIView.set(iView, dView.length);
			//endregion

			return dAndI;
		});

		//region Make &quot;iterationCount&quot; rounds of hashing
		for (let j = 0; j &lt; iterationCount; j++) internalSequence = internalSequence.then(roundBuffer =&gt; cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));
		//endregion

		internalSequence = internalSequence.then(roundBuffer =&gt; {
			//region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)
			const B = new ArrayBuffer(v);
			const bView = new Uint8Array(B);

			for (let j = 0; j &lt; B.byteLength; j++) bView[j] = roundBuffer[j % roundBuffer.length];
			//endregion

			//region Make new I value
			const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
			const iRound = [];

			let sliceStart = 0;
			let sliceLength = v;

			for (let j = 0; j &lt; k; j++) {
				const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
				sliceStart += v;
				if (sliceStart + v &gt; I.byteLength) sliceLength = I.byteLength - sliceStart;

				let x = 0x1ff;

				for (let l = B.byteLength - 1; l &gt;= 0; l--) {
					x &gt;&gt;= 8;
					x += bView[l] + chunk[l];
					chunk[l] = x &amp; 0xff;
				}

				iRound.push(...chunk);
			}

			I = new ArrayBuffer(iRound.length);
			iView = new Uint8Array(I);

			iView.set(iRound);
			//endregion

			result.push(...new Uint8Array(roundBuffer));

			return I;
		});
	}
	//endregion

	//region Initialize final key
	internalSequence = internalSequence.then(() =&gt; {
		const resultBuffer = new ArrayBuffer(keyLength &gt;&gt; 3);
		const resultView = new Uint8Array(resultBuffer);

		resultView.set(new Uint8Array(result).slice(0, keyLength &gt;&gt; 3));

		return resultBuffer;
	});
	//endregion
	//endregion

	return internalSequence;
}
//**************************************************************************************
/**
 * Default cryptographic engine for Web Cryptography API
 */
class CryptoEngine {
	//**********************************************************************************
	/**
  * Constructor for CryptoEngine class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {Object}
   * @description Usually here we are expecting &quot;window.crypto&quot; or an equivalent from custom &quot;crypto engine&quot;
   */
		this.crypto = (0, _pvutils.getParametersValue)(parameters, &quot;crypto&quot;, {});
		/**
   * @type {Object}
   * @description Usually here we are expecting &quot;window.crypto.subtle&quot; or an equivalent from custom &quot;crypto engine&quot;
   */
		this.subtle = (0, _pvutils.getParametersValue)(parameters, &quot;subtle&quot;, {});
		/**
   * @type {string}
   * @description Name of the &quot;crypto engine&quot;
   */
		this.name = (0, _pvutils.getParametersValue)(parameters, &quot;name&quot;, &quot;&quot;);
		//endregion
	}
	//**********************************************************************************
	/**
  * Import WebCrypto keys from different formats
  * @param {string} format
  * @param {ArrayBuffer|Uint8Array} keyData
  * @param {Object} algorithm
  * @param {boolean} extractable
  * @param {Array} keyUsages
  * @returns {Promise}
  */
	importKey(format, keyData, algorithm, extractable, keyUsages) {
		//region Initial variables
		let jwk = {};
		//endregion

		//region Change &quot;keyData&quot; type if needed
		if (keyData instanceof Uint8Array) keyData = keyData.buffer;
		//endregion

		switch (format.toLowerCase()) {
			case &quot;raw&quot;:
				return this.subtle.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages);
			case &quot;spki&quot;:
				{
					const asn1 = asn1js.fromBER(keyData);
					if (asn1.offset === -1) return Promise.reject(&quot;Incorrect keyData&quot;);

					const publicKeyInfo = new _PublicKeyInfo2.default();
					try {
						publicKeyInfo.fromSchema(asn1.result);
					} catch (ex) {
						return Promise.reject(&quot;Incorrect keyData&quot;);
					}

					// noinspection FallThroughInSwitchStatementJS
					switch (algorithm.name.toUpperCase()) {
						case &quot;RSA-PSS&quot;:
							{
								//region Get information about used hash function
								switch (algorithm.hash.name.toUpperCase()) {
									case &quot;SHA-1&quot;:
										jwk.alg = &quot;PS1&quot;;
										break;
									case &quot;SHA-256&quot;:
										jwk.alg = &quot;PS256&quot;;
										break;
									case &quot;SHA-384&quot;:
										jwk.alg = &quot;PS384&quot;;
										break;
									case &quot;SHA-512&quot;:
										jwk.alg = &quot;PS512&quot;;
										break;
									default:
										return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
								}
								//endregion
							}
						// break omitted
						case &quot;RSASSA-PKCS1-V1_5&quot;:
							{
								keyUsages = [&quot;verify&quot;]; // Override existing keyUsages value since the key is a public key

								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								if (publicKeyInfo.algorithm.algorithmId !== &quot;1.2.840.113549.1.1.1&quot;) return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);

								//region Get information about used hash function
								if (&quot;alg&quot; in jwk === false) {
									switch (algorithm.hash.name.toUpperCase()) {
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RS1&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RS256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RS384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RS512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
									}
								}
								//endregion

								//region Create RSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								var _iteratorNormalCompletion = true;
								var _didIteratorError = false;
								var _iteratorError = undefined;

								try {
									for (var _iterator = Object.keys(publicKeyJSON)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										const key = _step.value;

										jwk[key] = publicKeyJSON[key];
									} //endregion
								} catch (err) {
									_didIteratorError = true;
									_iteratorError = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
											_iterator.return();
										}
									} finally {
										if (_didIteratorError) {
											throw _iteratorError;
										}
									}
								}
							}
							break;
						case &quot;ECDSA&quot;:
							keyUsages = [&quot;verify&quot;]; // Override existing keyUsages value since the key is a public key
						// break omitted
						case &quot;ECDH&quot;:
							{
								//region Initial variables
								jwk = {
									kty: &quot;EC&quot;,
									ext: extractable,
									key_ops: keyUsages
								};
								//endregion

								//region Get information about algorithm
								if (publicKeyInfo.algorithm.algorithmId !== &quot;1.2.840.10045.2.1&quot;) return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
								//endregion

								//region Create ECDSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								var _iteratorNormalCompletion2 = true;
								var _didIteratorError2 = false;
								var _iteratorError2 = undefined;

								try {
									for (var _iterator2 = Object.keys(publicKeyJSON)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
										const key = _step2.value;

										jwk[key] = publicKeyJSON[key];
									} //endregion
								} catch (err) {
									_didIteratorError2 = true;
									_iteratorError2 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {
											_iterator2.return();
										}
									} finally {
										if (_didIteratorError2) {
											throw _iteratorError2;
										}
									}
								}
							}
							break;
						case &quot;RSA-OAEP&quot;:
							{
								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								if (this.name.toLowerCase() === &quot;safari&quot;) jwk.alg = &quot;RSA-OAEP&quot;;else {
									switch (algorithm.hash.name.toUpperCase()) {
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RSA-OAEP&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RSA-OAEP-256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RSA-OAEP-384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RSA-OAEP-512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
									}
								}

								//region Create ECDSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								var _iteratorNormalCompletion3 = true;
								var _didIteratorError3 = false;
								var _iteratorError3 = undefined;

								try {
									for (var _iterator3 = Object.keys(publicKeyJSON)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
										const key = _step3.value;

										jwk[key] = publicKeyJSON[key];
									} //endregion
								} catch (err) {
									_didIteratorError3 = true;
									_iteratorError3 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {
											_iterator3.return();
										}
									} finally {
										if (_didIteratorError3) {
											throw _iteratorError3;
										}
									}
								}
							}
							break;
						default:
							return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
					}
				}
				break;
			case &quot;pkcs8&quot;:
				{
					const privateKeyInfo = new _PrivateKeyInfo2.default();

					//region Parse &quot;PrivateKeyInfo&quot; object
					const asn1 = asn1js.fromBER(keyData);
					if (asn1.offset === -1) return Promise.reject(&quot;Incorrect keyData&quot;);

					try {
						privateKeyInfo.fromSchema(asn1.result);
					} catch (ex) {
						return Promise.reject(&quot;Incorrect keyData&quot;);
					}

					if (&quot;parsedKey&quot; in privateKeyInfo === false) return Promise.reject(&quot;Incorrect keyData&quot;);
					//endregion

					// noinspection FallThroughInSwitchStatementJS
					// noinspection FallThroughInSwitchStatementJS
					switch (algorithm.name.toUpperCase()) {
						case &quot;RSA-PSS&quot;:
							{
								//region Get information about used hash function
								switch (algorithm.hash.name.toUpperCase()) {
									case &quot;SHA-1&quot;:
										jwk.alg = &quot;PS1&quot;;
										break;
									case &quot;SHA-256&quot;:
										jwk.alg = &quot;PS256&quot;;
										break;
									case &quot;SHA-384&quot;:
										jwk.alg = &quot;PS384&quot;;
										break;
									case &quot;SHA-512&quot;:
										jwk.alg = &quot;PS512&quot;;
										break;
									default:
										return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
								}
								//endregion
							}
						// break omitted
						case &quot;RSASSA-PKCS1-V1_5&quot;:
							{
								keyUsages = [&quot;sign&quot;]; // Override existing keyUsages value since the key is a private key

								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								//region Get information about used hash function
								if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== &quot;1.2.840.113549.1.1.1&quot;) return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
								//endregion

								//region Get information about used hash function
								if (&quot;alg&quot; in jwk === false) {
									switch (algorithm.hash.name.toUpperCase()) {
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RS1&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RS256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RS384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RS512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion

								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								var _iteratorNormalCompletion4 = true;
								var _didIteratorError4 = false;
								var _iteratorError4 = undefined;

								try {
									for (var _iterator4 = Object.keys(privateKeyJSON)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
										const key = _step4.value;

										jwk[key] = privateKeyJSON[key];
									} //endregion
								} catch (err) {
									_didIteratorError4 = true;
									_iteratorError4 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) {
											_iterator4.return();
										}
									} finally {
										if (_didIteratorError4) {
											throw _iteratorError4;
										}
									}
								}
							}
							break;
						case &quot;ECDSA&quot;:
							keyUsages = [&quot;sign&quot;]; // Override existing keyUsages value since the key is a private key
						// break omitted
						case &quot;ECDH&quot;:
							{
								//region Initial variables
								jwk = {
									kty: &quot;EC&quot;,
									ext: extractable,
									key_ops: keyUsages
								};
								//endregion

								//region Get information about used hash function
								if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== &quot;1.2.840.10045.2.1&quot;) return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
								//endregion

								//region Create ECDSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								var _iteratorNormalCompletion5 = true;
								var _didIteratorError5 = false;
								var _iteratorError5 = undefined;

								try {
									for (var _iterator5 = Object.keys(privateKeyJSON)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
										const key = _step5.value;

										jwk[key] = privateKeyJSON[key];
									} //endregion
								} catch (err) {
									_didIteratorError5 = true;
									_iteratorError5 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) {
											_iterator5.return();
										}
									} finally {
										if (_didIteratorError5) {
											throw _iteratorError5;
										}
									}
								}
							}
							break;
						case &quot;RSA-OAEP&quot;:
							{
								jwk.kty = &quot;RSA&quot;;
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								//region Get information about used hash function
								if (this.name.toLowerCase() === &quot;safari&quot;) jwk.alg = &quot;RSA-OAEP&quot;;else {
									switch (algorithm.hash.name.toUpperCase()) {
										case &quot;SHA-1&quot;:
											jwk.alg = &quot;RSA-OAEP&quot;;
											break;
										case &quot;SHA-256&quot;:
											jwk.alg = &quot;RSA-OAEP-256&quot;;
											break;
										case &quot;SHA-384&quot;:
											jwk.alg = &quot;RSA-OAEP-384&quot;;
											break;
										case &quot;SHA-512&quot;:
											jwk.alg = &quot;RSA-OAEP-512&quot;;
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion

								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								var _iteratorNormalCompletion6 = true;
								var _didIteratorError6 = false;
								var _iteratorError6 = undefined;

								try {
									for (var _iterator6 = Object.keys(privateKeyJSON)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
										const key = _step6.value;

										jwk[key] = privateKeyJSON[key];
									} //endregion
								} catch (err) {
									_didIteratorError6 = true;
									_iteratorError6 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion6 &amp;&amp; _iterator6.return) {
											_iterator6.return();
										}
									} finally {
										if (_didIteratorError6) {
											throw _iteratorError6;
										}
									}
								}
							}
							break;
						default:
							return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
					}
				}
				break;
			case &quot;jwk&quot;:
				jwk = keyData;
				break;
			default:
				return Promise.reject(`Incorrect format: ${format}`);
		}

		//region Special case for Safari browser (since its acting not as WebCrypto standard describes)
		if (this.name.toLowerCase() === &quot;safari&quot;) {
			// Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)
			return Promise.resolve().then(() =&gt; this.subtle.importKey(&quot;jwk&quot;, (0, _pvutils.stringToArrayBuffer)(JSON.stringify(jwk)), algorithm, extractable, keyUsages)).then(result =&gt; result, () =&gt; this.subtle.importKey(&quot;jwk&quot;, jwk, algorithm, extractable, keyUsages));
		}
		//endregion

		return this.subtle.importKey(&quot;jwk&quot;, jwk, algorithm, extractable, keyUsages);
	}
	//**********************************************************************************
	/**
  * Export WebCrypto keys to different formats
  * @param {string} format
  * @param {Object} key
  * @returns {Promise}
  */
	exportKey(format, key) {
		let sequence = this.subtle.exportKey(&quot;jwk&quot;, key);

		//region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation
		if (this.name.toLowerCase() === &quot;safari&quot;) {
			sequence = sequence.then(result =&gt; {
				// Some additional checks for Safari Technology Preview
				if (result instanceof ArrayBuffer) return JSON.parse((0, _pvutils.arrayBufferToString)(result));

				return result;
			});
		}
		//endregion

		switch (format.toLowerCase()) {
			case &quot;raw&quot;:
				return this.subtle.exportKey(&quot;raw&quot;, key);
			case &quot;spki&quot;:
				sequence = sequence.then(result =&gt; {
					const publicKeyInfo = new _PublicKeyInfo2.default();

					try {
						publicKeyInfo.fromJSON(result);
					} catch (ex) {
						return Promise.reject(&quot;Incorrect key data&quot;);
					}

					return publicKeyInfo.toSchema().toBER(false);
				});
				break;
			case &quot;pkcs8&quot;:
				sequence = sequence.then(result =&gt; {
					const privateKeyInfo = new _PrivateKeyInfo2.default();

					try {
						privateKeyInfo.fromJSON(result);
					} catch (ex) {
						return Promise.reject(&quot;Incorrect key data&quot;);
					}

					return privateKeyInfo.toSchema().toBER(false);
				});
				break;
			case &quot;jwk&quot;:
				break;
			default:
				return Promise.reject(`Incorrect format: ${format}`);
		}

		return sequence;
	}
	//**********************************************************************************
	/**
  * Convert WebCrypto keys between different export formats
  * @param {string} inputFormat
  * @param {string} outputFormat
  * @param {ArrayBuffer|Object} keyData
  * @param {Object} algorithm
  * @param {boolean} extractable
  * @param {Array} keyUsages
  * @returns {Promise}
  */
	convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
		switch (inputFormat.toLowerCase()) {
			case &quot;raw&quot;:
				switch (outputFormat.toLowerCase()) {
					case &quot;raw&quot;:
						return Promise.resolve(keyData);
					case &quot;spki&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;spki&quot;, result));
					case &quot;pkcs8&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;pkcs8&quot;, result));
					case &quot;jwk&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;raw&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;jwk&quot;, result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case &quot;spki&quot;:
				switch (outputFormat.toLowerCase()) {
					case &quot;raw&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;spki&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;raw&quot;, result));
					case &quot;spki&quot;:
						return Promise.resolve(keyData);
					case &quot;pkcs8&quot;:
						return Promise.reject(&quot;Impossible to convert between SPKI/PKCS8&quot;);
					case &quot;jwk&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;spki&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;jwk&quot;, result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case &quot;pkcs8&quot;:
				switch (outputFormat.toLowerCase()) {
					case &quot;raw&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;pkcs8&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;raw&quot;, result));
					case &quot;spki&quot;:
						return Promise.reject(&quot;Impossible to convert between SPKI/PKCS8&quot;);
					case &quot;pkcs8&quot;:
						return Promise.resolve(keyData);
					case &quot;jwk&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;pkcs8&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;jwk&quot;, result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case &quot;jwk&quot;:
				switch (outputFormat.toLowerCase()) {
					case &quot;raw&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;jwk&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;raw&quot;, result));
					case &quot;spki&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;jwk&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;spki&quot;, result));
					case &quot;pkcs8&quot;:
						return Promise.resolve().then(() =&gt; this.importKey(&quot;jwk&quot;, keyData, algorithm, extractable, keyUsages)).then(result =&gt; this.exportKey(&quot;pkcs8&quot;, result));
					case &quot;jwk&quot;:
						return Promise.resolve(keyData);
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			default:
				return Promise.reject(`Incorrect inputFormat: ${inputFormat}`);
		}
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;encrypt&quot;
  * @param args
  * @returns {Promise}
  */
	encrypt(...args) {
		return this.subtle.encrypt(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;decrypt&quot;
  * @param args
  * @returns {Promise}
  */
	decrypt(...args) {
		return this.subtle.decrypt(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;sign&quot;
  * @param args
  * @returns {Promise}
  */
	sign(...args) {
		return this.subtle.sign(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;verify&quot;
  * @param args
  * @returns {Promise}
  */
	verify(...args) {
		return this.subtle.verify(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;digest&quot;
  * @param args
  * @returns {Promise}
  */
	digest(...args) {
		return this.subtle.digest(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;generateKey&quot;
  * @param args
  * @returns {Promise}
  */
	generateKey(...args) {
		return this.subtle.generateKey(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;deriveKey&quot;
  * @param args
  * @returns {Promise}
  */
	deriveKey(...args) {
		return this.subtle.deriveKey(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;deriveBits&quot;
  * @param args
  * @returns {Promise}
  */
	deriveBits(...args) {
		return this.subtle.deriveBits(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;wrapKey&quot;
  * @param args
  * @returns {Promise}
  */
	wrapKey(...args) {
		return this.subtle.wrapKey(...args);
	}
	//**********************************************************************************
	/**
  * Wrapper for standard function &quot;unwrapKey&quot;
  * @param args
  * @returns {Promise}
  */
	unwrapKey(...args) {
		return this.subtle.unwrapKey(...args);
	}
	//**********************************************************************************
	/**
  * Initialize input Uint8Array by random values (with help from current &quot;crypto engine&quot;)
  * @param {!Uint8Array} view
  * @returns {*}
  */
	getRandomValues(view) {
		if (&quot;getRandomValues&quot; in this.crypto === false) throw new Error(&quot;No support for getRandomValues&quot;);

		return this.crypto.getRandomValues(view);
	}
	//**********************************************************************************
	/**
  * Get WebCrypto algorithm by wel-known OID
  * @param {string} oid well-known OID to search for
  * @returns {Object}
  */
	getAlgorithmByOID(oid) {
		switch (oid) {
			case &quot;1.2.840.113549.1.1.1&quot;:
			case &quot;1.2.840.113549.1.1.5&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-1&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.11&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-256&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.12&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-384&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.13&quot;:
				return {
					name: &quot;RSASSA-PKCS1-v1_5&quot;,
					hash: {
						name: &quot;SHA-512&quot;
					}
				};
			case &quot;1.2.840.113549.1.1.10&quot;:
				return {
					name: &quot;RSA-PSS&quot;
				};
			case &quot;1.2.840.113549.1.1.7&quot;:
				return {
					name: &quot;RSA-OAEP&quot;
				};
			case &quot;1.2.840.10045.2.1&quot;:
			case &quot;1.2.840.10045.4.1&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-1&quot;
					}
				};
			case &quot;1.2.840.10045.4.3.2&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-256&quot;
					}
				};
			case &quot;1.2.840.10045.4.3.3&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-384&quot;
					}
				};
			case &quot;1.2.840.10045.4.3.4&quot;:
				return {
					name: &quot;ECDSA&quot;,
					hash: {
						name: &quot;SHA-512&quot;
					}
				};
			case &quot;1.3.133.16.840.63.0.2&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-1&quot;
				};
			case &quot;1.3.132.1.11.1&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-256&quot;
				};
			case &quot;1.3.132.1.11.2&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-384&quot;
				};
			case &quot;1.3.132.1.11.3&quot;:
				return {
					name: &quot;ECDH&quot;,
					kdf: &quot;SHA-512&quot;
				};
			case &quot;2.16.840.1.101.3.4.1.2&quot;:
				return {
					name: &quot;AES-CBC&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.22&quot;:
				return {
					name: &quot;AES-CBC&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.42&quot;:
				return {
					name: &quot;AES-CBC&quot;,
					length: 256
				};
			case &quot;2.16.840.1.101.3.4.1.6&quot;:
				return {
					name: &quot;AES-GCM&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.26&quot;:
				return {
					name: &quot;AES-GCM&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.46&quot;:
				return {
					name: &quot;AES-GCM&quot;,
					length: 256
				};
			case &quot;2.16.840.1.101.3.4.1.4&quot;:
				return {
					name: &quot;AES-CFB&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.24&quot;:
				return {
					name: &quot;AES-CFB&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.44&quot;:
				return {
					name: &quot;AES-CFB&quot;,
					length: 256
				};
			case &quot;2.16.840.1.101.3.4.1.5&quot;:
				return {
					name: &quot;AES-KW&quot;,
					length: 128
				};
			case &quot;2.16.840.1.101.3.4.1.25&quot;:
				return {
					name: &quot;AES-KW&quot;,
					length: 192
				};
			case &quot;2.16.840.1.101.3.4.1.45&quot;:
				return {
					name: &quot;AES-KW&quot;,
					length: 256
				};
			case &quot;1.2.840.113549.2.7&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-1&quot;
					}
				};
			case &quot;1.2.840.113549.2.9&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-256&quot;
					}
				};
			case &quot;1.2.840.113549.2.10&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-384&quot;
					}
				};
			case &quot;1.2.840.113549.2.11&quot;:
				return {
					name: &quot;HMAC&quot;,
					hash: {
						name: &quot;SHA-512&quot;
					}
				};
			case &quot;1.2.840.113549.1.9.16.3.5&quot;:
				return {
					name: &quot;DH&quot;
				};
			case &quot;1.3.14.3.2.26&quot;:
				return {
					name: &quot;SHA-1&quot;
				};
			case &quot;2.16.840.1.101.3.4.2.1&quot;:
				return {
					name: &quot;SHA-256&quot;
				};
			case &quot;2.16.840.1.101.3.4.2.2&quot;:
				return {
					name: &quot;SHA-384&quot;
				};
			case &quot;2.16.840.1.101.3.4.2.3&quot;:
				return {
					name: &quot;SHA-512&quot;
				};
			case &quot;1.2.840.113549.1.5.12&quot;:
				return {
					name: &quot;PBKDF2&quot;
				};
			//region Special case - OIDs for ECC curves
			case &quot;1.2.840.10045.3.1.7&quot;:
				return {
					name: &quot;P-256&quot;
				};
			case &quot;1.3.132.0.34&quot;:
				return {
					name: &quot;P-384&quot;
				};
			case &quot;1.3.132.0.35&quot;:
				return {
					name: &quot;P-521&quot;
				};
			//endregion
			default:
		}

		return {};
	}
	//**********************************************************************************
	/**
  * Get OID for each specific algorithm
  * @param {Object} algorithm
  * @returns {string}
  */
	getOIDByAlgorithm(algorithm) {
		let result = &quot;&quot;;

		switch (algorithm.name.toUpperCase()) {
			case &quot;RSASSA-PKCS1-V1_5&quot;:
				switch (algorithm.hash.name.toUpperCase()) {
					case &quot;SHA-1&quot;:
						result = &quot;1.2.840.113549.1.1.5&quot;;
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.2.840.113549.1.1.11&quot;;
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.2.840.113549.1.1.12&quot;;
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.2.840.113549.1.1.13&quot;;
						break;
					default:
				}
				break;
			case &quot;RSA-PSS&quot;:
				result = &quot;1.2.840.113549.1.1.10&quot;;
				break;
			case &quot;RSA-OAEP&quot;:
				result = &quot;1.2.840.113549.1.1.7&quot;;
				break;
			case &quot;ECDSA&quot;:
				switch (algorithm.hash.name.toUpperCase()) {
					case &quot;SHA-1&quot;:
						result = &quot;1.2.840.10045.4.1&quot;;
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.2.840.10045.4.3.2&quot;;
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.2.840.10045.4.3.3&quot;;
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.2.840.10045.4.3.4&quot;;
						break;
					default:
				}
				break;
			case &quot;ECDH&quot;:
				switch (algorithm.kdf.toUpperCase()) {// Non-standard addition - hash algorithm of KDF function
					case &quot;SHA-1&quot;:
						result = &quot;1.3.133.16.840.63.0.2&quot;; // dhSinglePass-stdDH-sha1kdf-scheme
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.3.132.1.11.1&quot;; // dhSinglePass-stdDH-sha256kdf-scheme
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.3.132.1.11.2&quot;; // dhSinglePass-stdDH-sha384kdf-scheme
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.3.132.1.11.3&quot;; // dhSinglePass-stdDH-sha512kdf-scheme
						break;
					default:
				}
				break;
			case &quot;AES-CTR&quot;:
				break;
			case &quot;AES-CBC&quot;:
				switch (algorithm.length) {
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.2&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.22&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.42&quot;;
						break;
					default:
				}
				break;
			case &quot;AES-CMAC&quot;:
				break;
			case &quot;AES-GCM&quot;:
				switch (algorithm.length) {
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.6&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.26&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.46&quot;;
						break;
					default:
				}
				break;
			case &quot;AES-CFB&quot;:
				switch (algorithm.length) {
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.4&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.24&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.44&quot;;
						break;
					default:
				}
				break;
			case &quot;AES-KW&quot;:
				switch (algorithm.length) {
					case 128:
						result = &quot;2.16.840.1.101.3.4.1.5&quot;;
						break;
					case 192:
						result = &quot;2.16.840.1.101.3.4.1.25&quot;;
						break;
					case 256:
						result = &quot;2.16.840.1.101.3.4.1.45&quot;;
						break;
					default:
				}
				break;
			case &quot;HMAC&quot;:
				switch (algorithm.hash.name.toUpperCase()) {
					case &quot;SHA-1&quot;:
						result = &quot;1.2.840.113549.2.7&quot;;
						break;
					case &quot;SHA-256&quot;:
						result = &quot;1.2.840.113549.2.9&quot;;
						break;
					case &quot;SHA-384&quot;:
						result = &quot;1.2.840.113549.2.10&quot;;
						break;
					case &quot;SHA-512&quot;:
						result = &quot;1.2.840.113549.2.11&quot;;
						break;
					default:
				}
				break;
			case &quot;DH&quot;:
				result = &quot;1.2.840.113549.1.9.16.3.5&quot;;
				break;
			case &quot;SHA-1&quot;:
				result = &quot;1.3.14.3.2.26&quot;;
				break;
			case &quot;SHA-256&quot;:
				result = &quot;2.16.840.1.101.3.4.2.1&quot;;
				break;
			case &quot;SHA-384&quot;:
				result = &quot;2.16.840.1.101.3.4.2.2&quot;;
				break;
			case &quot;SHA-512&quot;:
				result = &quot;2.16.840.1.101.3.4.2.3&quot;;
				break;
			case &quot;CONCAT&quot;:
				break;
			case &quot;HKDF&quot;:
				break;
			case &quot;PBKDF2&quot;:
				result = &quot;1.2.840.113549.1.5.12&quot;;
				break;
			//region Special case - OIDs for ECC curves
			case &quot;P-256&quot;:
				result = &quot;1.2.840.10045.3.1.7&quot;;
				break;
			case &quot;P-384&quot;:
				result = &quot;1.3.132.0.34&quot;;
				break;
			case &quot;P-521&quot;:
				result = &quot;1.3.132.0.35&quot;;
				break;
			//endregion
			default:
		}

		return result;
	}
	//**********************************************************************************
	/**
  * Get default algorithm parameters for each kind of operation
  * @param {string} algorithmName Algorithm name to get common parameters for
  * @param {string} operation Kind of operation: &quot;sign&quot;, &quot;encrypt&quot;, &quot;generatekey&quot;, &quot;importkey&quot;, &quot;exportkey&quot;, &quot;verify&quot;
  * @returns {*}
  */
	getAlgorithmParameters(algorithmName, operation) {
		let result = {
			algorithm: {},
			usages: []
		};

		switch (algorithmName.toUpperCase()) {
			case &quot;RSASSA-PKCS1-V1_5&quot;:
				switch (operation.toLowerCase()) {
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;RSASSA-PKCS1-v1_5&quot;,
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;verify&quot;:
					case &quot;sign&quot;:
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;RSASSA-PKCS1-v1_5&quot;,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;verify&quot;] // For importKey(&quot;pkcs8&quot;) usage must be &quot;sign&quot; only
						};
						break;
					case &quot;exportkey&quot;:
					default:
						return {
							algorithm: {
								name: &quot;RSASSA-PKCS1-v1_5&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;RSA-PSS&quot;:
				switch (operation.toLowerCase()) {
					case &quot;sign&quot;:
					case &quot;verify&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-PSS&quot;,
								hash: {
									name: &quot;SHA-1&quot;
								},
								saltLength: 20
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-PSS&quot;,
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: &quot;SHA-1&quot;
								}
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-PSS&quot;,
								hash: {
									name: &quot;SHA-1&quot;
								}
							},
							usages: [&quot;verify&quot;] // For importKey(&quot;pkcs8&quot;) usage must be &quot;sign&quot; only
						};
						break;
					case &quot;exportkey&quot;:
					default:
						return {
							algorithm: {
								name: &quot;RSA-PSS&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;RSA-OAEP&quot;:
				switch (operation.toLowerCase()) {
					case &quot;encrypt&quot;:
					case &quot;decrypt&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-OAEP&quot;
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-OAEP&quot;,
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;RSA-OAEP&quot;,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;encrypt&quot;] // encrypt for &quot;spki&quot; and decrypt for &quot;pkcs8&quot;
						};
						break;
					case &quot;exportkey&quot;:
					default:
						return {
							algorithm: {
								name: &quot;RSA-OAEP&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;ECDSA&quot;:
				switch (operation.toLowerCase()) {
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;ECDSA&quot;,
								namedCurve: &quot;P-256&quot;
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;importkey&quot;:
						result = {
							algorithm: {
								name: &quot;ECDSA&quot;,
								namedCurve: &quot;P-256&quot;
							},
							usages: [&quot;verify&quot;] // &quot;sign&quot; for &quot;pkcs8&quot;
						};
						break;
					case &quot;verify&quot;:
					case &quot;sign&quot;:
						result = {
							algorithm: {
								name: &quot;ECDSA&quot;,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;sign&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;ECDSA&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;ECDH&quot;:
				switch (operation.toLowerCase()) {
					case &quot;exportkey&quot;:
					case &quot;importkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;ECDH&quot;,
								namedCurve: &quot;P-256&quot;
							},
							usages: [&quot;deriveKey&quot;, &quot;deriveBits&quot;]
						};
						break;
					case &quot;derivekey&quot;:
					case &quot;derivebits&quot;:
						result = {
							algorithm: {
								name: &quot;ECDH&quot;,
								namedCurve: &quot;P-256&quot;,
								public: [] // Must be a &quot;publicKey&quot;
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;ECDH&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-CTR&quot;:
				switch (operation.toLowerCase()) {
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CTR&quot;,
								length: 256
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;decrypt&quot;:
					case &quot;encrypt&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CTR&quot;,
								counter: new Uint8Array(16),
								length: 10
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-CTR&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-CBC&quot;:
				switch (operation.toLowerCase()) {
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CBC&quot;,
								length: 256
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;decrypt&quot;:
					case &quot;encrypt&quot;:
						result = {
							algorithm: {
								name: &quot;AES-CBC&quot;,
								iv: this.getRandomValues(new Uint8Array(16)) // For &quot;decrypt&quot; the value should be replaced with value got on &quot;encrypt&quot; step
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-CBC&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-GCM&quot;:
				switch (operation.toLowerCase()) {
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-GCM&quot;,
								length: 256
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					case &quot;decrypt&quot;:
					case &quot;encrypt&quot;:
						result = {
							algorithm: {
								name: &quot;AES-GCM&quot;,
								iv: this.getRandomValues(new Uint8Array(16)) // For &quot;decrypt&quot; the value should be replaced with value got on &quot;encrypt&quot; step
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-GCM&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;AES-KW&quot;:
				switch (operation.toLowerCase()) {
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
					case &quot;wrapkey&quot;:
					case &quot;unwrapkey&quot;:
						result = {
							algorithm: {
								name: &quot;AES-KW&quot;,
								length: 256
							},
							usages: [&quot;wrapKey&quot;, &quot;unwrapKey&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;AES-KW&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;HMAC&quot;:
				switch (operation.toLowerCase()) {
					case &quot;sign&quot;:
					case &quot;verify&quot;:
						result = {
							algorithm: {
								name: &quot;HMAC&quot;
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					case &quot;importkey&quot;:
					case &quot;exportkey&quot;:
					case &quot;generatekey&quot;:
						result = {
							algorithm: {
								name: &quot;HMAC&quot;,
								length: 32,
								hash: {
									name: &quot;SHA-256&quot;
								}
							},
							usages: [&quot;sign&quot;, &quot;verify&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;HMAC&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;HKDF&quot;:
				switch (operation.toLowerCase()) {
					case &quot;derivekey&quot;:
						result = {
							algorithm: {
								name: &quot;HKDF&quot;,
								hash: &quot;SHA-256&quot;,
								salt: new Uint8Array([]),
								info: new Uint8Array([])
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;HKDF&quot;
							},
							usages: []
						};
				}
				break;
			case &quot;PBKDF2&quot;:
				switch (operation.toLowerCase()) {
					case &quot;derivekey&quot;:
						result = {
							algorithm: {
								name: &quot;PBKDF2&quot;,
								hash: { name: &quot;SHA-256&quot; },
								salt: new Uint8Array([]),
								iterations: 10000
							},
							usages: [&quot;encrypt&quot;, &quot;decrypt&quot;]
						};
						break;
					default:
						return {
							algorithm: {
								name: &quot;PBKDF2&quot;
							},
							usages: []
						};
				}
				break;
			default:
		}

		return result;
	}
	//**********************************************************************************
	/**
  * Getting hash algorithm by signature algorithm
  * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm
  * @returns {string}
  */
	getHashAlgorithm(signatureAlgorithm) {
		let result = &quot;&quot;;

		switch (signatureAlgorithm.algorithmId) {
			case &quot;1.2.840.10045.4.1&quot;: // ecdsa-with-SHA1
			case &quot;1.2.840.113549.1.1.5&quot;:
				result = &quot;SHA-1&quot;;
				break;
			case &quot;1.2.840.10045.4.3.2&quot;: // ecdsa-with-SHA256
			case &quot;1.2.840.113549.1.1.11&quot;:
				result = &quot;SHA-256&quot;;
				break;
			case &quot;1.2.840.10045.4.3.3&quot;: // ecdsa-with-SHA384
			case &quot;1.2.840.113549.1.1.12&quot;:
				result = &quot;SHA-384&quot;;
				break;
			case &quot;1.2.840.10045.4.3.4&quot;: // ecdsa-with-SHA512
			case &quot;1.2.840.113549.1.1.13&quot;:
				result = &quot;SHA-512&quot;;
				break;
			case &quot;1.2.840.113549.1.1.10&quot;:
				// RSA-PSS
				{
					try {
						const params = new _RSASSAPSSParams2.default({ schema: signatureAlgorithm.algorithmParams });
						if (&quot;hashAlgorithm&quot; in params) {
							const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
							if (&quot;name&quot; in algorithm === false) return &quot;&quot;;

							result = algorithm.name;
						} else result = &quot;SHA-1&quot;;
					} catch (ex) {}
				}
				break;
			default:
		}

		return result;
	}
	//**********************************************************************************
	/**
  * Specialized function encrypting &quot;EncryptedContentInfo&quot; object using parameters
  * @param {Object} parameters
  * @returns {Promise}
  */
	encryptEncryptedContentInfo(parameters) {
		//region Check for input parameters
		if (parameters instanceof Object === false) return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);

		if (&quot;password&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);

		if (&quot;contentEncryptionAlgorithm&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;contentEncryptionAlgorithm\&quot;&quot;);

		if (&quot;hmacHashAlgorithm&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;hmacHashAlgorithm\&quot;&quot;);

		if (&quot;iterationCount&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;iterationCount\&quot;&quot;);

		if (&quot;contentToEncrypt&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;contentToEncrypt\&quot;&quot;);

		if (&quot;contentType&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;contentType\&quot;&quot;);

		const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);
		if (contentEncryptionOID === &quot;&quot;) return Promise.reject(&quot;Wrong \&quot;contentEncryptionAlgorithm\&quot; value&quot;);

		const pbkdf2OID = this.getOIDByAlgorithm({
			name: &quot;PBKDF2&quot;
		});
		if (pbkdf2OID === &quot;&quot;) return Promise.reject(&quot;Can not find OID for PBKDF2&quot;);

		const hmacOID = this.getOIDByAlgorithm({
			name: &quot;HMAC&quot;,
			hash: {
				name: parameters.hmacHashAlgorithm
			}
		});
		if (hmacOID === &quot;&quot;) return Promise.reject(`Incorrect value for &quot;hmacHashAlgorithm&quot;: ${parameters.hmacHashAlgorithm}`);
		//endregion

		//region Initial variables
		let sequence = Promise.resolve();

		const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
		const ivView = new Uint8Array(ivBuffer);
		this.getRandomValues(ivView);

		const saltBuffer = new ArrayBuffer(64);
		const saltView = new Uint8Array(saltBuffer);
		this.getRandomValues(saltView);

		const contentView = new Uint8Array(parameters.contentToEncrypt);

		const pbkdf2Params = new _PBKDF2Params2.default({
			salt: new asn1js.OctetString({ valueHex: saltBuffer }),
			iterationCount: parameters.iterationCount,
			prf: new _AlgorithmIdentifier2.default({
				algorithmId: hmacOID,
				algorithmParams: new asn1js.Null()
			})
		});
		//endregion

		//region Derive PBKDF2 key from &quot;password&quot; buffer
		sequence = sequence.then(() =&gt; {
			const passwordView = new Uint8Array(parameters.password);

			return this.importKey(&quot;raw&quot;, passwordView, &quot;PBKDF2&quot;, false, [&quot;deriveKey&quot;]);
		}, error =&gt; Promise.reject(error));
		//endregion

		//region Derive key for &quot;contentEncryptionAlgorithm&quot;
		sequence = sequence.then(result =&gt; this.deriveKey({
			name: &quot;PBKDF2&quot;,
			hash: {
				name: parameters.hmacHashAlgorithm
			},
			salt: saltView,
			iterations: parameters.iterationCount
		}, result, parameters.contentEncryptionAlgorithm, false, [&quot;encrypt&quot;]), error =&gt; Promise.reject(error));
		//endregion

		//region Encrypt content
		sequence = sequence.then(result =&gt; this.encrypt({
			name: parameters.contentEncryptionAlgorithm.name,
			iv: ivView
		}, result, contentView), error =&gt; Promise.reject(error));
		//endregion

		//region Store all parameters in EncryptedData object
		sequence = sequence.then(result =&gt; {
			const pbes2Parameters = new _PBES2Params2.default({
				keyDerivationFunc: new _AlgorithmIdentifier2.default({
					algorithmId: pbkdf2OID,
					algorithmParams: pbkdf2Params.toSchema()
				}),
				encryptionScheme: new _AlgorithmIdentifier2.default({
					algorithmId: contentEncryptionOID,
					algorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })
				})
			});

			return new _EncryptedContentInfo2.default({
				contentType: parameters.contentType,
				contentEncryptionAlgorithm: new _AlgorithmIdentifier2.default({
					algorithmId: &quot;1.2.840.113549.1.5.13&quot;, // pkcs5PBES2
					algorithmParams: pbes2Parameters.toSchema()
				}),
				encryptedContent: new asn1js.OctetString({ valueHex: result })
			});
		}, error =&gt; Promise.reject(error));
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
  * Decrypt data stored in &quot;EncryptedContentInfo&quot; object using parameters
  * @param parameters
  * @return {Promise}
  */
	decryptEncryptedContentInfo(parameters) {
		//region Check for input parameters
		if (parameters instanceof Object === false) return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);

		if (&quot;password&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);

		if (&quot;encryptedContentInfo&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;encryptedContentInfo\&quot;&quot;);

		if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== &quot;1.2.840.113549.1.5.13&quot;) // pkcs5PBES2
			return Promise.reject(`Unknown &quot;contentEncryptionAlgorithm&quot;: ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
		//endregion

		//region Initial variables
		let sequence = Promise.resolve();

		let pbes2Parameters;

		try {
			pbes2Parameters = new _PBES2Params2.default({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
		} catch (ex) {
			return Promise.reject(&quot;Incorrectly encoded \&quot;pbes2Parameters\&quot;&quot;);
		}

		let pbkdf2Params;

		try {
			pbkdf2Params = new _PBKDF2Params2.default({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
		} catch (ex) {
			return Promise.reject(&quot;Incorrectly encoded \&quot;pbkdf2Params\&quot;&quot;);
		}

		const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);
		if (&quot;name&quot; in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect OID for &quot;contentEncryptionAlgorithm&quot;: ${pbes2Parameters.encryptionScheme.algorithmId}`);

		const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
		const ivView = new Uint8Array(ivBuffer);

		const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
		const saltView = new Uint8Array(saltBuffer);

		const iterationCount = pbkdf2Params.iterationCount;

		let hmacHashAlgorithm = &quot;SHA-1&quot;;

		if (&quot;prf&quot; in pbkdf2Params) {
			const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
			if (&quot;name&quot; in algorithm === false) return Promise.reject(&quot;Incorrect OID for HMAC hash algorithm&quot;);

			hmacHashAlgorithm = algorithm.hash.name;
		}
		//endregion

		//region Derive PBKDF2 key from &quot;password&quot; buffer
		sequence = sequence.then(() =&gt; this.importKey(&quot;raw&quot;, parameters.password, &quot;PBKDF2&quot;, false, [&quot;deriveKey&quot;]), error =&gt; Promise.reject(error));
		//endregion

		//region Derive key for &quot;contentEncryptionAlgorithm&quot;
		sequence = sequence.then(result =&gt; this.deriveKey({
			name: &quot;PBKDF2&quot;,
			hash: {
				name: hmacHashAlgorithm
			},
			salt: saltView,
			iterations: iterationCount
		}, result, contentEncryptionAlgorithm, false, [&quot;decrypt&quot;]), error =&gt; Promise.reject(error));
		//endregion

		//region Decrypt internal content using derived key
		sequence = sequence.then(result =&gt; {
			//region Create correct data block for decryption
			let dataBuffer = new ArrayBuffer(0);

			if (parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {
				var _iteratorNormalCompletion7 = true;
				var _didIteratorError7 = false;
				var _iteratorError7 = undefined;

				try {
					for (var _iterator7 = parameters.encryptedContentInfo.encryptedContent.valueBlock.value[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
						const content = _step7.value;

						dataBuffer = (0, _pvutils.utilConcatBuf)(dataBuffer, content.valueBlock.valueHex);
					}
				} catch (err) {
					_didIteratorError7 = true;
					_iteratorError7 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion7 &amp;&amp; _iterator7.return) {
							_iterator7.return();
						}
					} finally {
						if (_didIteratorError7) {
							throw _iteratorError7;
						}
					}
				}
			}
			//endregion

			return this.decrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			}, result, dataBuffer);
		}, error =&gt; Promise.reject(error));
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
  * Stamping (signing) data using algorithm simular to HMAC
  * @param {Object} parameters
  * @return {Promise.&lt;T&gt;|Promise}
  */
	stampDataWithPassword(parameters) {
		//region Check for input parameters
		if (parameters instanceof Object === false) return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);

		if (&quot;password&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);

		if (&quot;hashAlgorithm&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;hashAlgorithm\&quot;&quot;);

		if (&quot;salt&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;iterationCount\&quot;&quot;);

		if (&quot;iterationCount&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;salt\&quot;&quot;);

		if (&quot;contentToStamp&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;contentToStamp\&quot;&quot;);
		//endregion

		//region Choose correct length for HMAC key
		let length;

		switch (parameters.hashAlgorithm.toLowerCase()) {
			case &quot;sha-1&quot;:
				length = 160;
				break;
			case &quot;sha-256&quot;:
				length = 256;
				break;
			case &quot;sha-384&quot;:
				length = 384;
				break;
			case &quot;sha-512&quot;:
				length = 512;
				break;
			default:
				return Promise.reject(`Incorrect &quot;parameters.hashAlgorithm&quot; parameter: ${parameters.hashAlgorithm}`);
		}
		//endregion

		//region Initial variables
		let sequence = Promise.resolve();

		const hmacAlgorithm = {
			name: &quot;HMAC&quot;,
			length,
			hash: {
				name: parameters.hashAlgorithm
			}
		};
		//endregion

		//region Create PKCS#12 key for integrity checking
		sequence = sequence.then(() =&gt; makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
		//endregion

		//region Import HMAC key
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(result =&gt; this.importKey(&quot;raw&quot;, new Uint8Array(result), hmacAlgorithm, false, [&quot;sign&quot;]));
		//endregion

		//region Make signed HMAC value
		sequence = sequence.then(result =&gt; this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)), error =&gt; Promise.reject(error));
		//endregion

		return sequence;
	}
	//**********************************************************************************
	verifyDataStampedWithPassword(parameters) {
		//region Check for input parameters
		if (parameters instanceof Object === false) return Promise.reject(&quot;Parameters must have type \&quot;Object\&quot;&quot;);

		if (&quot;password&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;password\&quot;&quot;);

		if (&quot;hashAlgorithm&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;hashAlgorithm\&quot;&quot;);

		if (&quot;salt&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;iterationCount\&quot;&quot;);

		if (&quot;iterationCount&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;salt\&quot;&quot;);

		if (&quot;contentToVerify&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;contentToVerify\&quot;&quot;);

		if (&quot;signatureToVerify&quot; in parameters === false) return Promise.reject(&quot;Absent mandatory parameter \&quot;signatureToVerify\&quot;&quot;);
		//endregion

		//region Choose correct length for HMAC key
		let length;

		switch (parameters.hashAlgorithm.toLowerCase()) {
			case &quot;sha-1&quot;:
				length = 160;
				break;
			case &quot;sha-256&quot;:
				length = 256;
				break;
			case &quot;sha-384&quot;:
				length = 384;
				break;
			case &quot;sha-512&quot;:
				length = 512;
				break;
			default:
				return Promise.reject(`Incorrect &quot;parameters.hashAlgorithm&quot; parameter: ${parameters.hashAlgorithm}`);
		}
		//endregion

		//region Initial variables
		let sequence = Promise.resolve();

		const hmacAlgorithm = {
			name: &quot;HMAC&quot;,
			length,
			hash: {
				name: parameters.hashAlgorithm
			}
		};
		//endregion

		//region Create PKCS#12 key for integrity checking
		sequence = sequence.then(() =&gt; makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
		//endregion

		//region Import HMAC key
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(result =&gt; this.importKey(&quot;raw&quot;, new Uint8Array(result), hmacAlgorithm, false, [&quot;verify&quot;]));
		//endregion

		//region Make signed HMAC value
		sequence = sequence.then(result =&gt; this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)), error =&gt; Promise.reject(error));
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
  * Get signature parameters by analyzing private key algorithm
  * @param {Object} privateKey The private key user would like to use
  * @param {string} [hashAlgorithm=&quot;SHA-1&quot;] Hash algorithm user would like to use
  * @return {Promise.&lt;T&gt;|Promise}
  */
	getSignatureParameters(privateKey, hashAlgorithm = &quot;SHA-1&quot;) {
		//region Check hashing algorithm
		const oid = this.getOIDByAlgorithm({ name: hashAlgorithm });
		if (oid === &quot;&quot;) return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
		//endregion

		//region Initial variables
		const signatureAlgorithm = new _AlgorithmIdentifier2.default();
		//endregion

		//region Get a &quot;default parameters&quot; for current algorithm
		const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, &quot;sign&quot;);
		parameters.algorithm.hash.name = hashAlgorithm;
		//endregion

		//region Fill internal structures base on &quot;privateKey&quot; and &quot;hashAlgorithm&quot;
		switch (privateKey.algorithm.name.toUpperCase()) {
			case &quot;RSASSA-PKCS1-V1_5&quot;:
			case &quot;ECDSA&quot;:
				signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);
				break;
			case &quot;RSA-PSS&quot;:
				{
					//region Set &quot;saltLength&quot; as a length (in octets) of hash function result
					switch (hashAlgorithm.toUpperCase()) {
						case &quot;SHA-256&quot;:
							parameters.algorithm.saltLength = 32;
							break;
						case &quot;SHA-384&quot;:
							parameters.algorithm.saltLength = 48;
							break;
						case &quot;SHA-512&quot;:
							parameters.algorithm.saltLength = 64;
							break;
						default:
					}
					//endregion

					//region Fill &quot;RSASSA_PSS_params&quot; object
					const paramsObject = {};

					if (hashAlgorithm.toUpperCase() !== &quot;SHA-1&quot;) {
						const hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm });
						if (hashAlgorithmOID === &quot;&quot;) return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);

						paramsObject.hashAlgorithm = new _AlgorithmIdentifier2.default({
							algorithmId: hashAlgorithmOID,
							algorithmParams: new asn1js.Null()
						});

						paramsObject.maskGenAlgorithm = new _AlgorithmIdentifier2.default({
							algorithmId: &quot;1.2.840.113549.1.1.8&quot;, // MGF1
							algorithmParams: paramsObject.hashAlgorithm.toSchema()
						});
					}

					if (parameters.algorithm.saltLength !== 20) paramsObject.saltLength = parameters.algorithm.saltLength;

					const pssParameters = new _RSASSAPSSParams2.default(paramsObject);
					//endregion

					//region Automatically set signature algorithm
					signatureAlgorithm.algorithmId = &quot;1.2.840.113549.1.1.10&quot;;
					signatureAlgorithm.algorithmParams = pssParameters.toSchema();
					//endregion
				}
				break;
			default:
				return Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
		}
		//endregion

		return Promise.resolve().then(() =&gt; ({
			signatureAlgorithm,
			parameters
		}));
	}
	//**********************************************************************************
	/**
  * Sign data with pre-defined private key
  * @param {ArrayBuffer} data Data to be signed
  * @param {Object} privateKey Private key to use
  * @param {Object} parameters Parameters for used algorithm
  * @return {Promise.&lt;T&gt;|Promise}
  */
	signWithPrivateKey(data, privateKey, parameters) {
		return this.sign(parameters.algorithm, privateKey, new Uint8Array(data)).then(result =&gt; {
			//region Special case for ECDSA algorithm
			if (parameters.algorithm.name === &quot;ECDSA&quot;) result = (0, _common.createCMSECDSASignature)(result);
			//endregion

			return result;
		}, error =&gt; Promise.reject(`Signing error: ${error}`));
	}
	//**********************************************************************************
	fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
		const parameters = {};

		//region Find signer&#039;s hashing algorithm
		const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
		if (shaAlgorithm === &quot;&quot;) return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
		//endregion

		//region Get information about public key algorithm and default parameters for import
		let algorithmId;
		if (signatureAlgorithm.algorithmId === &quot;1.2.840.113549.1.1.10&quot;) algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;

		const algorithmObject = this.getAlgorithmByOID(algorithmId);
		if (&quot;name&quot; in algorithmObject === &quot;&quot;) return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);

		parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, &quot;importkey&quot;);
		if (&quot;hash&quot; in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;

		//region Special case for ECDSA
		if (algorithmObject.name === &quot;ECDSA&quot;) {
			//region Get information about named curve
			let algorithmParamsChecked = false;

			if (&quot;algorithmParams&quot; in publicKeyInfo.algorithm === true) {
				if (&quot;idBlock&quot; in publicKeyInfo.algorithm.algorithmParams) {
					if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 &amp;&amp; publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
				}
			}

			if (algorithmParamsChecked === false) return Promise.reject(&quot;Incorrect type for ECDSA public key parameters&quot;);

			const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
			if (&quot;name&quot; in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
			//endregion

			parameters.algorithm.algorithm.namedCurve = curveObject.name;
		}
		//endregion
		//endregion

		return parameters;
	}
	//**********************************************************************************
	getPublicKey(publicKeyInfo, signatureAlgorithm, parameters = null) {
		if (parameters === null) parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);

		const publicKeyInfoSchema = publicKeyInfo.toSchema();
		const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
		const publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);

		return this.importKey(&quot;spki&quot;, publicKeyInfoView, parameters.algorithm.algorithm, true, parameters.algorithm.usages);
	}
	//**********************************************************************************
	verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm = null) {
		//region Initial variables
		let sequence = Promise.resolve();
		//endregion

		//region Find signer&#039;s hashing algorithm
		if (shaAlgorithm === null) {
			shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
			if (shaAlgorithm === &quot;&quot;) return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);

			//region Import public key
			sequence = sequence.then(() =&gt; this.getPublicKey(publicKeyInfo, signatureAlgorithm));
			//endregion
		} else {
			const parameters = {};

			//region Get information about public key algorithm and default parameters for import
			let algorithmId;
			if (signatureAlgorithm.algorithmId === &quot;1.2.840.113549.1.1.10&quot;) algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;

			const algorithmObject = this.getAlgorithmByOID(algorithmId);
			if (&quot;name&quot; in algorithmObject === &quot;&quot;) return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);

			parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, &quot;importkey&quot;);
			if (&quot;hash&quot; in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;

			//region Special case for ECDSA
			if (algorithmObject.name === &quot;ECDSA&quot;) {
				//region Get information about named curve
				let algorithmParamsChecked = false;

				if (&quot;algorithmParams&quot; in publicKeyInfo.algorithm === true) {
					if (&quot;idBlock&quot; in publicKeyInfo.algorithm.algorithmParams) {
						if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 &amp;&amp; publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;
					}
				}

				if (algorithmParamsChecked === false) return Promise.reject(&quot;Incorrect type for ECDSA public key parameters&quot;);

				const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
				if (&quot;name&quot; in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
				//endregion

				parameters.algorithm.algorithm.namedCurve = curveObject.name;
			}
			//endregion
			//endregion

			//region Import public key
			sequence = sequence.then(() =&gt; this.getPublicKey(publicKeyInfo, null, parameters));
			//endregion
		}
		//endregion

		//region Verify signature
		sequence = sequence.then(publicKey =&gt; {
			//region Get default algorithm parameters for verification
			const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, &quot;verify&quot;);
			if (&quot;hash&quot; in algorithm.algorithm) algorithm.algorithm.hash.name = shaAlgorithm;
			//endregion

			//region Special case for ECDSA signatures
			let signatureValue = signature.valueBlock.valueHex;

			if (publicKey.algorithm.name === &quot;ECDSA&quot;) {
				const asn1 = asn1js.fromBER(signatureValue);
				// noinspection JSCheckFunctionSignatures
				signatureValue = (0, _common.createECDSASignatureFromCMS)(asn1.result);
			}
			//endregion

			//region Special case for RSA-PSS
			if (publicKey.algorithm.name === &quot;RSA-PSS&quot;) {
				let pssParameters;

				try {
					pssParameters = new _RSASSAPSSParams2.default({ schema: signatureAlgorithm.algorithmParams });
				} catch (ex) {
					return Promise.reject(ex);
				}

				if (&quot;saltLength&quot; in pssParameters) algorithm.algorithm.saltLength = pssParameters.saltLength;else algorithm.algorithm.saltLength = 20;

				let hashAlgo = &quot;SHA-1&quot;;

				if (&quot;hashAlgorithm&quot; in pssParameters) {
					const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);
					if (&quot;name&quot; in hashAlgorithm === false) return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);

					hashAlgo = hashAlgorithm.name;
				}

				algorithm.algorithm.hash.name = hashAlgo;
			}
			//endregion

			return this.verify(algorithm.algorithm, publicKey, new Uint8Array(signatureValue), new Uint8Array(data));
		});
		//endregion

		return sequence;
	}
	//**********************************************************************************
}
exports.default = CryptoEngine; //**************************************************************************************
//# sourceMappingURL=CryptoEngine.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
