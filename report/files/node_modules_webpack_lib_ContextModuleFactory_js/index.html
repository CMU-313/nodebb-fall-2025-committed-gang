<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/ContextModuleFactory.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/ContextModuleFactory.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">481</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.20</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const asyncLib = require(&quot;neo-async&quot;);
const { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(&quot;tapable&quot;);
const ContextModule = require(&quot;./ContextModule&quot;);
const ModuleFactory = require(&quot;./ModuleFactory&quot;);
const ContextElementDependency = require(&quot;./dependencies/ContextElementDependency&quot;);
const LazySet = require(&quot;./util/LazySet&quot;);
const { cachedSetProperty } = require(&quot;./util/cleverMerge&quot;);
const { createFakeHook } = require(&quot;./util/deprecation&quot;);
const { join } = require(&quot;./util/fs&quot;);

/** @typedef {import(&quot;./ContextModule&quot;).ContextModuleOptions} ContextModuleOptions */
/** @typedef {import(&quot;./ContextModule&quot;).ResolveDependenciesCallback} ResolveDependenciesCallback */
/** @typedef {import(&quot;./Module&quot;)} Module */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryCallback} ModuleFactoryCallback */
/** @typedef {import(&quot;./ResolverFactory&quot;)} ResolverFactory */
/** @typedef {import(&quot;./dependencies/ContextDependency&quot;)} ContextDependency */
/** @typedef {import(&quot;enhanced-resolve&quot;).ResolveRequest} ResolveRequest */
/**
 * @template T
 * @typedef {import(&quot;./util/deprecation&quot;).FakeHook&lt;T&gt;} FakeHook&lt;T&gt;
 */
/** @typedef {import(&quot;./util/fs&quot;).IStats} IStats */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/** @typedef {{ context: string, request: string }} ContextAlternativeRequest */

const EMPTY_RESOLVE_OPTIONS = {};

module.exports = class ContextModuleFactory extends ModuleFactory {
	/**
	 * @param {ResolverFactory} resolverFactory resolverFactory
	 */
	constructor(resolverFactory) {
		super();
		/** @type {AsyncSeriesWaterfallHook&lt;[ContextAlternativeRequest[], ContextModuleOptions]&gt;} */
		const alternativeRequests = new AsyncSeriesWaterfallHook([
			&quot;modules&quot;,
			&quot;options&quot;
		]);
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesWaterfallHook&lt;[TODO]&gt;} */
			beforeResolve: new AsyncSeriesWaterfallHook([&quot;data&quot;]),
			/** @type {AsyncSeriesWaterfallHook&lt;[TODO]&gt;} */
			afterResolve: new AsyncSeriesWaterfallHook([&quot;data&quot;]),
			/** @type {SyncWaterfallHook&lt;[string[]]&gt;} */
			contextModuleFiles: new SyncWaterfallHook([&quot;files&quot;]),
			/** @type {FakeHook&lt;Pick&lt;AsyncSeriesWaterfallHook&lt;[ContextAlternativeRequest[]]&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt;} */
			alternatives: createFakeHook(
				{
					name: &quot;alternatives&quot;,
					/** @type {AsyncSeriesWaterfallHook&lt;[ContextAlternativeRequest[]]&gt;[&quot;intercept&quot;]} */
					intercept: interceptor =&gt; {
						throw new Error(
							&quot;Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead&quot;
						);
					},
					/** @type {AsyncSeriesWaterfallHook&lt;[ContextAlternativeRequest[]]&gt;[&quot;tap&quot;]} */
					tap: (options, fn) =&gt; {
						alternativeRequests.tap(options, fn);
					},
					/** @type {AsyncSeriesWaterfallHook&lt;[ContextAlternativeRequest[]]&gt;[&quot;tapAsync&quot;]} */
					tapAsync: (options, fn) =&gt; {
						alternativeRequests.tapAsync(options, (items, _options, callback) =&gt;
							fn(items, callback)
						);
					},
					/** @type {AsyncSeriesWaterfallHook&lt;[ContextAlternativeRequest[]]&gt;[&quot;tapPromise&quot;]} */
					tapPromise: (options, fn) =&gt; {
						alternativeRequests.tapPromise(options, fn);
					}
				},
				&quot;ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.&quot;,
				&quot;DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES&quot;
			),
			alternativeRequests
		});
		this.resolverFactory = resolverFactory;
	}

	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {ModuleFactoryCallback} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency} */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context,
				dependencies,
				layer: data.contextInfo.issuerLayer,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			},
			(err, beforeResolveResult) =&gt; {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					});
				}

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders;
				let resource;
				let loadersPrefix = &quot;&quot;;
				const idx = request.lastIndexOf(&quot;!&quot;);
				if (idx &gt;= 0) {
					let loadersRequest = request.slice(0, idx + 1);
					let i;
					for (
						i = 0;
						i &lt; loadersRequest.length &amp;&amp; loadersRequest[i] === &quot;!&quot;;
						i++
					) {
						loadersPrefix += &quot;!&quot;;
					}
					loadersRequest = loadersRequest
						.slice(i)
						.replace(/!+$/, &quot;&quot;)
						.replace(/!!+/g, &quot;!&quot;);
					loaders = loadersRequest === &quot;&quot; ? [] : loadersRequest.split(&quot;!&quot;);
					resource = request.slice(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					&quot;context&quot;,
					dependencies.length &gt; 0
						? cachedSetProperty(
								resolveOptions || EMPTY_RESOLVE_OPTIONS,
								&quot;dependencyType&quot;,
								dependencies[0].category
							)
						: resolveOptions
				);
				const loaderResolver = this.resolverFactory.get(&quot;loader&quot;);

				asyncLib.parallel(
					[
						callback =&gt; {
							const results = /** @type ResolveRequest[] */ ([]);
							/**
							 * @param {ResolveRequest} obj obj
							 * @returns {void}
							 */
							const yield_ = obj =&gt; {
								results.push(obj);
							};

							contextResolver.resolve(
								{},
								context,
								resource,
								{
									fileDependencies,
									missingDependencies,
									contextDependencies,
									yield: yield_
								},
								err =&gt; {
									if (err) return callback(err);
									callback(null, results);
								}
							);
						},
						callback =&gt; {
							asyncLib.map(
								loaders,
								(loader, callback) =&gt; {
									loaderResolver.resolve(
										{},
										context,
										loader,
										{
											fileDependencies,
											missingDependencies,
											contextDependencies
										},
										(err, result) =&gt; {
											if (err) return callback(err);
											callback(null, /** @type {string} */ (result));
										}
									);
								},
								callback
							);
						}
					],
					(err, result) =&gt; {
						if (err) {
							return callback(err, {
								fileDependencies,
								missingDependencies,
								contextDependencies
							});
						}
						let [contextResult, loaderResult] =
							/** @type {[ResolveRequest[], string[]]} */ (result);
						if (contextResult.length &gt; 1) {
							const first = contextResult[0];
							contextResult = contextResult.filter(r =&gt; r.path);
							if (contextResult.length === 0) contextResult.push(first);
						}
						this.hooks.afterResolve.callAsync(
							{
								addon:
									loadersPrefix +
									loaderResult.join(&quot;!&quot;) +
									(loaderResult.length &gt; 0 ? &quot;!&quot; : &quot;&quot;),
								resource:
									contextResult.length &gt; 1
										? contextResult.map(r =&gt; r.path)
										: contextResult[0].path,
								resolveDependencies: this.resolveDependencies.bind(this),
								resourceQuery: contextResult[0].query,
								resourceFragment: contextResult[0].fragment,
								...beforeResolveResult
							},
							(err, result) =&gt; {
								if (err) {
									return callback(err, {
										fileDependencies,
										missingDependencies,
										contextDependencies
									});
								}

								// Ignored
								if (!result) {
									return callback(null, {
										fileDependencies,
										missingDependencies,
										contextDependencies
									});
								}

								return callback(null, {
									module: new ContextModule(result.resolveDependencies, result),
									fileDependencies,
									missingDependencies,
									contextDependencies
								});
							}
						);
					}
				);
			}
		);
	}

	/**
	 * @param {InputFileSystem} fs file system
	 * @param {ContextModuleOptions} options options
	 * @param {ResolveDependenciesCallback} callback callback function
	 * @returns {void}
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix,
			attributes
		} = options;
		if (!regExp || !resource) return callback(null, []);

		/**
		 * @param {string} ctx context
		 * @param {string} directory directory
		 * @param {Set&lt;string&gt;} visited visited
		 * @param {ResolveDependenciesCallback} callback callback
		 */
		const addDirectoryChecked = (ctx, directory, visited, callback) =&gt; {
			/** @type {NonNullable&lt;InputFileSystem[&quot;realpath&quot;]&gt;} */
			(fs.realpath)(directory, (err, _realPath) =&gt; {
				if (err) return callback(err);
				const realPath = /** @type {string} */ (_realPath);
				if (visited.has(realPath)) return callback(null, []);
				/** @type {Set&lt;string&gt; | undefined} */
				let recursionStack;
				addDirectory(
					ctx,
					directory,
					(_, dir, callback) =&gt; {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						}
						addDirectoryChecked(ctx, dir, recursionStack, callback);
					},
					callback
				);
			});
		};

		/**
		 * @param {string} ctx context
		 * @param {string} directory directory
		 * @param {(context: string, subResource: string, callback: () =&gt; void) =&gt; void} addSubDirectory addSubDirectoryFn
		 * @param {ResolveDependenciesCallback} callback callback
		 */
		const addDirectory = (ctx, directory, addSubDirectory, callback) =&gt; {
			fs.readdir(directory, (err, files) =&gt; {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]} */ (files).map(file =&gt; file.normalize(&quot;NFC&quot;))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p =&gt; p.indexOf(&quot;.&quot;) !== 0),
					(segment, callback) =&gt; {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, _stat) =&gt; {
								if (err) {
									if (err.code === &quot;ENOENT&quot;) {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									}
									return callback(err);
								}

								const stat = /** @type {IStats} */ (_stat);

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(ctx, subResource, callback);
								} else if (
									stat.isFile() &amp;&amp;
									(!include || subResource.match(include))
								) {
									/** @type {{ context: string, request: string }} */
									const obj = {
										context: ctx,
										request: `.${subResource.slice(ctx.length).replace(/\\/g, &quot;/&quot;)}`
									};

									this.hooks.alternativeRequests.callAsync(
										[obj],
										options,
										(err, alternatives) =&gt; {
											if (err) return callback(err);
											callback(
												null,
												/** @type {ContextAlternativeRequest[]} */
												(alternatives)
													.filter(obj =&gt;
														regExp.test(/** @type {string} */ (obj.request))
													)
													.map(obj =&gt; {
														const dep = new ContextElementDependency(
															`${obj.request}${resourceQuery}${resourceFragment}`,
															obj.request,
															typePrefix,
															/** @type {string} */
															(category),
															referencedExports,
															obj.context,
															attributes
														);
														dep.optional = true;
														return dep;
													})
											);
										}
									);
								} else {
									callback();
								}
							});
						} else {
							callback();
						}
					},
					(err, result) =&gt; {
						if (err) return callback(err);

						if (!result) return callback(null, []);

						const flattenedResult = [];

						for (const item of result) {
							if (item) flattenedResult.push(...item);
						}

						callback(null, flattenedResult);
					}
				);
			});
		};

		/**
		 * @param {string} ctx context
		 * @param {string} dir dir
		 * @param {ResolveDependenciesCallback} callback callback
		 * @returns {void}
		 */
		const addSubDirectory = (ctx, dir, callback) =&gt;
			addDirectory(ctx, dir, addSubDirectory, callback);

		/**
		 * @param {string} resource resource
		 * @param {ResolveDependenciesCallback} callback callback
		 */
		const visitResource = (resource, callback) =&gt; {
			if (typeof fs.realpath === &quot;function&quot;) {
				addDirectoryChecked(resource, resource, new Set(), callback);
			} else {
				addDirectory(resource, resource, addSubDirectory, callback);
			}
		};

		if (typeof resource === &quot;string&quot;) {
			visitResource(resource, callback);
		} else {
			asyncLib.map(resource, visitResource, (err, _result) =&gt; {
				if (err) return callback(err);
				const result = /** @type {ContextElementDependency[][]} */ (_result);

				// result dependencies should have unique userRequest
				// ordered by resolve result
				/** @type {Set&lt;string&gt;} */
				const temp = new Set();
				/** @type {ContextElementDependency[]} */
				const res = [];
				for (let i = 0; i &lt; result.length; i++) {
					const inner = result[i];
					for (const el of inner) {
						if (temp.has(el.userRequest)) continue;
						res.push(el);
						temp.add(el.userRequest);
					}
				}
				callback(null, res);
			});
		}
	}
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
