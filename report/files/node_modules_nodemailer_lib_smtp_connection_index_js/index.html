<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodemailer/lib/smtp-connection/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodemailer/lib/smtp-connection/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1837</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">18.63</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const packageInfo = require(&#039;../../package.json&#039;);
const EventEmitter = require(&#039;events&#039;).EventEmitter;
const net = require(&#039;net&#039;);
const tls = require(&#039;tls&#039;);
const os = require(&#039;os&#039;);
const crypto = require(&#039;crypto&#039;);
const DataStream = require(&#039;./data-stream&#039;);
const PassThrough = require(&#039;stream&#039;).PassThrough;
const shared = require(&#039;../shared&#039;);

// default timeout values in ms
const CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established
const SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client
const GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved
const DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname

/**
 * Generates a SMTP connection object
 *
 * Optional options object takes the following possible properties:
 *
 *  * **port** - is the port to connect to (defaults to 587 or 465)
 *  * **host** - is the hostname or IP address to connect to (defaults to &#039;localhost&#039;)
 *  * **secure** - use SSL
 *  * **ignoreTLS** - ignore server support for STARTTLS
 *  * **requireTLS** - forces the client to use STARTTLS
 *  * **name** - the name of the client server
 *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)
 *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)
 *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish
 *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)
 *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)
 *  * **lmtp** - if true, uses LMTP instead of SMTP protocol
 *  * **logger** - bunyan compatible logger interface
 *  * **debug** - if true pass SMTP traffic to the logger
 *  * **tls** - options for createCredentials
 *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)
 *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls
 *
 * @constructor
 * @namespace SMTP Client module
 * @param {Object} [options] Option properties
 */
class SMTPConnection extends EventEmitter {
    constructor(options) {
        super(options);

        this.id = crypto.randomBytes(8).toString(&#039;base64&#039;).replace(/\W/g, &#039;&#039;);
        this.stage = &#039;init&#039;;

        this.options = options || {};

        this.secureConnection = !!this.options.secure;
        this.alreadySecured = !!this.options.secured;

        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
        this.host = this.options.host || &#039;localhost&#039;;

        this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;

        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;

        if (typeof this.options.secure === &#039;undefined&#039; &amp;&amp; this.port === 465) {
            // if secure option is not set but port is 465, then default to secure
            this.secureConnection = true;
        }

        this.name = this.options.name || this._getHostname();

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || &#039;smtp-connection&#039;,
            sid: this.id
        });

        this.customAuth = new Map();
        Object.keys(this.options.customAuth || {}).forEach(key =&gt; {
            let mapKey = (key || &#039;&#039;).toString().trim().toUpperCase();
            if (!mapKey) {
                return;
            }
            this.customAuth.set(mapKey, this.options.customAuth[key]);
        });

        /**
         * Expose version nr, just for the reference
         * @type {String}
         */
        this.version = packageInfo.version;

        /**
         * If true, then the user is authenticated
         * @type {Boolean}
         */
        this.authenticated = false;

        /**
         * If set to true, this instance is no longer active
         * @private
         */
        this.destroyed = false;

        /**
         * Defines if the current connection is secure or not. If not,
         * STARTTLS can be used if available
         * @private
         */
        this.secure = !!this.secureConnection;

        /**
         * Store incomplete messages coming from the server
         * @private
         */
        this._remainder = &#039;&#039;;

        /**
         * Unprocessed responses from the server
         * @type {Array}
         */
        this._responseQueue = [];

        this.lastServerResponse = false;

        /**
         * The socket connecting to the server
         * @publick
         */
        this._socket = false;

        /**
         * Lists supported auth mechanisms
         * @private
         */
        this._supportedAuth = [];

        /**
         * Set to true, if EHLO response includes &quot;AUTH&quot;.
         * If false then authentication is not tried
         */
        this.allowsAuth = false;

        /**
         * Includes current envelope (from, to)
         * @private
         */
        this._envelope = false;

        /**
         * Lists supported extensions
         * @private
         */
        this._supportedExtensions = [];

        /**
         * Defines the maximum allowed size for a single message
         * @private
         */
        this._maxAllowedSize = 0;

        /**
         * Function queue to run if a data chunk comes from the server
         * @private
         */
        this._responseActions = [];
        this._recipientQueue = [];

        /**
         * Timeout variable for waiting the greeting
         * @private
         */
        this._greetingTimeout = false;

        /**
         * Timeout variable for waiting the connection to start
         * @private
         */
        this._connectionTimeout = false;

        /**
         * If the socket is deemed already closed
         * @private
         */
        this._destroyed = false;

        /**
         * If the socket is already being closed
         * @private
         */
        this._closing = false;

        /**
         * Callbacks for socket&#039;s listeners
         */
        this._onSocketData = chunk =&gt; this._onData(chunk);
        this._onSocketError = error =&gt; this._onError(error, &#039;ESOCKET&#039;, false, &#039;CONN&#039;);
        this._onSocketClose = () =&gt; this._onClose();
        this._onSocketEnd = () =&gt; this._onEnd();
        this._onSocketTimeout = () =&gt; this._onTimeout();
    }

    /**
     * Creates a connection to a SMTP server and sets up connection
     * listener
     */
    connect(connectCallback) {
        if (typeof connectCallback === &#039;function&#039;) {
            this.once(&#039;connect&#039;, () =&gt; {
                this.logger.debug(
                    {
                        tnx: &#039;smtp&#039;
                    },
                    &#039;SMTP handshake finished&#039;
                );
                connectCallback();
            });

            const isDestroyedMessage = this._isDestroyedMessage(&#039;connect&#039;);
            if (isDestroyedMessage) {
                return connectCallback(this._formatError(isDestroyedMessage, &#039;ECONNECTION&#039;, false, &#039;CONN&#039;));
            }
        }

        let opts = {
            port: this.port,
            host: this.host,
            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
            timeout: this.options.dnsTimeout || DNS_TIMEOUT
        };

        if (this.options.localAddress) {
            opts.localAddress = this.options.localAddress;
        }

        let setupConnectionHandlers = () =&gt; {
            this._connectionTimeout = setTimeout(() =&gt; {
                this._onError(&#039;Connection timeout&#039;, &#039;ETIMEDOUT&#039;, false, &#039;CONN&#039;);
            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);

            this._socket.on(&#039;error&#039;, this._onSocketError);
        };

        if (this.options.connection) {
            // connection is already opened
            this._socket = this.options.connection;
            setupConnectionHandlers();

            if (this.secureConnection &amp;&amp; !this.alreadySecured) {
                setImmediate(() =&gt;
                    this._upgradeConnection(err =&gt; {
                        if (err) {
                            this._onError(new Error(&#039;Error initiating TLS - &#039; + (err.message || err)), &#039;ETLS&#039;, false, &#039;CONN&#039;);
                            return;
                        }
                        this._onConnect();
                    })
                );
            } else {
                setImmediate(() =&gt; this._onConnect());
            }
            return;
        } else if (this.options.socket) {
            // socket object is set up but not yet connected
            this._socket = this.options.socket;
            return shared.resolveHostname(opts, (err, resolved) =&gt; {
                if (err) {
                    return setImmediate(() =&gt; this._onError(err, &#039;EDNS&#039;, false, &#039;CONN&#039;));
                }
                this.logger.debug(
                    {
                        tnx: &#039;dns&#039;,
                        source: opts.host,
                        resolved: resolved.host,
                        cached: !!resolved.cached
                    },
                    &#039;Resolved %s as %s [cache %s]&#039;,
                    opts.host,
                    resolved.host,
                    resolved.cached ? &#039;hit&#039; : &#039;miss&#039;
                );
                Object.keys(resolved).forEach(key =&gt; {
                    if (key.charAt(0) !== &#039;_&#039; &amp;&amp; resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket.connect(this.port, this.host, () =&gt; {
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(() =&gt; this._onError(E, &#039;ECONNECTION&#039;, false, &#039;CONN&#039;));
                }
            });
        } else if (this.secureConnection) {
            // connect using tls
            if (this.options.tls) {
                Object.keys(this.options.tls).forEach(key =&gt; {
                    opts[key] = this.options.tls[key];
                });
            }

            // ensure servername for SNI
            if (this.servername &amp;&amp; !opts.servername) {
                opts.servername = this.servername;
            }

            return shared.resolveHostname(opts, (err, resolved) =&gt; {
                if (err) {
                    return setImmediate(() =&gt; this._onError(err, &#039;EDNS&#039;, false, &#039;CONN&#039;));
                }
                this.logger.debug(
                    {
                        tnx: &#039;dns&#039;,
                        source: opts.host,
                        resolved: resolved.host,
                        cached: !!resolved.cached
                    },
                    &#039;Resolved %s as %s [cache %s]&#039;,
                    opts.host,
                    resolved.host,
                    resolved.cached ? &#039;hit&#039; : &#039;miss&#039;
                );
                Object.keys(resolved).forEach(key =&gt; {
                    if (key.charAt(0) !== &#039;_&#039; &amp;&amp; resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = tls.connect(opts, () =&gt; {
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(() =&gt; this._onError(E, &#039;ECONNECTION&#039;, false, &#039;CONN&#039;));
                }
            });
        } else {
            // connect using plaintext
            return shared.resolveHostname(opts, (err, resolved) =&gt; {
                if (err) {
                    return setImmediate(() =&gt; this._onError(err, &#039;EDNS&#039;, false, &#039;CONN&#039;));
                }
                this.logger.debug(
                    {
                        tnx: &#039;dns&#039;,
                        source: opts.host,
                        resolved: resolved.host,
                        cached: !!resolved.cached
                    },
                    &#039;Resolved %s as %s [cache %s]&#039;,
                    opts.host,
                    resolved.host,
                    resolved.cached ? &#039;hit&#039; : &#039;miss&#039;
                );
                Object.keys(resolved).forEach(key =&gt; {
                    if (key.charAt(0) !== &#039;_&#039; &amp;&amp; resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = net.connect(opts, () =&gt; {
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(() =&gt; this._onError(E, &#039;ECONNECTION&#039;, false, &#039;CONN&#039;));
                }
            });
        }
    }

    /**
     * Sends QUIT
     */
    quit() {
        this._sendCommand(&#039;QUIT&#039;);
        this._responseActions.push(this.close);
    }

    /**
     * Closes the connection to the server
     */
    close() {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        this._responseActions = [];

        // allow to run this function only once
        if (this._closing) {
            return;
        }
        this._closing = true;

        let closeMethod = &#039;end&#039;;

        if (this.stage === &#039;init&#039;) {
            // Close the socket immediately when connection timed out
            closeMethod = &#039;destroy&#039;;
        }

        this.logger.debug(
            {
                tnx: &#039;smtp&#039;
            },
            &#039;Closing connection to the server using &quot;%s&quot;&#039;,
            closeMethod
        );

        let socket = (this._socket &amp;&amp; this._socket.socket) || this._socket;

        if (socket &amp;&amp; !socket.destroyed) {
            try {
                socket[closeMethod]();
            } catch (E) {
                // just ignore
            }
        }

        this._destroy();
    }

    /**
     * Authenticate user
     */
    login(authData, callback) {
        const isDestroyedMessage = this._isDestroyedMessage(&#039;login&#039;);
        if (isDestroyedMessage) {
            return callback(this._formatError(isDestroyedMessage, &#039;ECONNECTION&#039;, false, &#039;API&#039;));
        }

        this._auth = authData || {};
        // Select SASL authentication method
        this._authMethod = (this._auth.method || &#039;&#039;).toString().trim().toUpperCase() || false;

        if (!this._authMethod &amp;&amp; this._auth.oauth2 &amp;&amp; !this._auth.credentials) {
            this._authMethod = &#039;XOAUTH2&#039;;
        } else if (!this._authMethod || (this._authMethod === &#039;XOAUTH2&#039; &amp;&amp; !this._auth.oauth2)) {
            // use first supported
            this._authMethod = (this._supportedAuth[0] || &#039;PLAIN&#039;).toUpperCase().trim();
        }

        if (this._authMethod !== &#039;XOAUTH2&#039; &amp;&amp; (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
            if ((this._auth.user &amp;&amp; this._auth.pass) || this.customAuth.has(this._authMethod)) {
                this._auth.credentials = {
                    user: this._auth.user,
                    pass: this._auth.pass,
                    options: this._auth.options
                };
            } else {
                return callback(this._formatError(&#039;Missing credentials for &quot;&#039; + this._authMethod + &#039;&quot;&#039;, &#039;EAUTH&#039;, false, &#039;API&#039;));
            }
        }

        if (this.customAuth.has(this._authMethod)) {
            let handler = this.customAuth.get(this._authMethod);
            let lastResponse;
            let returned = false;

            let resolve = () =&gt; {
                if (returned) {
                    return;
                }
                returned = true;
                this.logger.info(
                    {
                        tnx: &#039;smtp&#039;,
                        username: this._auth.user,
                        action: &#039;authenticated&#039;,
                        method: this._authMethod
                    },
                    &#039;User %s authenticated&#039;,
                    JSON.stringify(this._auth.user)
                );
                this.authenticated = true;
                callback(null, true);
            };

            let reject = err =&gt; {
                if (returned) {
                    return;
                }
                returned = true;
                callback(this._formatError(err, &#039;EAUTH&#039;, lastResponse, &#039;AUTH &#039; + this._authMethod));
            };

            let handlerResponse = handler({
                auth: this._auth,
                method: this._authMethod,

                extensions: [].concat(this._supportedExtensions),
                authMethods: [].concat(this._supportedAuth),
                maxAllowedSize: this._maxAllowedSize || false,

                sendCommand: (cmd, done) =&gt; {
                    let promise;

                    if (!done) {
                        promise = new Promise((resolve, reject) =&gt; {
                            done = shared.callbackPromise(resolve, reject);
                        });
                    }

                    this._responseActions.push(str =&gt; {
                        lastResponse = str;

                        let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
                        let data = {
                            command: cmd,
                            response: str
                        };
                        if (codes) {
                            data.status = Number(codes[1]) || 0;
                            if (codes[2]) {
                                data.code = codes[2];
                            }
                            data.text = str.substr(codes[0].length);
                        } else {
                            data.text = str;
                            data.status = 0; // just in case we need to perform numeric comparisons
                        }
                        done(null, data);
                    });
                    setImmediate(() =&gt; this._sendCommand(cmd));

                    return promise;
                },

                resolve,
                reject
            });

            if (handlerResponse &amp;&amp; typeof handlerResponse.catch === &#039;function&#039;) {
                // a promise was returned
                handlerResponse.then(resolve).catch(reject);
            }

            return;
        }

        switch (this._authMethod) {
            case &#039;XOAUTH2&#039;:
                this._handleXOauth2Token(false, callback);
                return;
            case &#039;LOGIN&#039;:
                this._responseActions.push(str =&gt; {
                    this._actionAUTH_LOGIN_USER(str, callback);
                });
                this._sendCommand(&#039;AUTH LOGIN&#039;);
                return;
            case &#039;PLAIN&#039;:
                this._responseActions.push(str =&gt; {
                    this._actionAUTHComplete(str, callback);
                });
                this._sendCommand(
                    &#039;AUTH PLAIN &#039; +
                        Buffer.from(
                            //this._auth.user+&#039;\u0000&#039;+
                            &#039;\u0000&#039; + // skip authorization identity as it causes problems with some servers
                                this._auth.credentials.user +
                                &#039;\u0000&#039; +
                                this._auth.credentials.pass,
                            &#039;utf-8&#039;
                        ).toString(&#039;base64&#039;),
                    // log entry without passwords
                    &#039;AUTH PLAIN &#039; +
                        Buffer.from(
                            //this._auth.user+&#039;\u0000&#039;+
                            &#039;\u0000&#039; + // skip authorization identity as it causes problems with some servers
                                this._auth.credentials.user +
                                &#039;\u0000&#039; +
                                &#039;/* secret */&#039;,
                            &#039;utf-8&#039;
                        ).toString(&#039;base64&#039;)
                );
                return;
            case &#039;CRAM-MD5&#039;:
                this._responseActions.push(str =&gt; {
                    this._actionAUTH_CRAM_MD5(str, callback);
                });
                this._sendCommand(&#039;AUTH CRAM-MD5&#039;);
                return;
        }

        return callback(this._formatError(&#039;Unknown authentication method &quot;&#039; + this._authMethod + &#039;&quot;&#039;, &#039;EAUTH&#039;, false, &#039;API&#039;));
    }

    /**
     * Sends a message
     *
     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
     * @param {Object} message String, Buffer or a Stream
     * @param {Function} callback Callback to return once sending is completed
     */
    send(envelope, message, done) {
        if (!message) {
            return done(this._formatError(&#039;Empty message&#039;, &#039;EMESSAGE&#039;, false, &#039;API&#039;));
        }

        const isDestroyedMessage = this._isDestroyedMessage(&#039;send message&#039;);
        if (isDestroyedMessage) {
            return done(this._formatError(isDestroyedMessage, &#039;ECONNECTION&#039;, false, &#039;API&#039;));
        }

        // reject larger messages than allowed
        if (this._maxAllowedSize &amp;&amp; envelope.size &gt; this._maxAllowedSize) {
            return setImmediate(() =&gt; {
                done(this._formatError(&#039;Message size larger than allowed &#039; + this._maxAllowedSize, &#039;EMESSAGE&#039;, false, &#039;MAIL FROM&#039;));
            });
        }

        // ensure that callback is only called once
        let returned = false;
        let callback = function () {
            if (returned) {
                return;
            }
            returned = true;

            done(...arguments);
        };

        if (typeof message.on === &#039;function&#039;) {
            message.on(&#039;error&#039;, err =&gt; callback(this._formatError(err, &#039;ESTREAM&#039;, false, &#039;API&#039;)));
        }

        let startTime = Date.now();
        this._setEnvelope(envelope, (err, info) =&gt; {
            if (err) {
                // create passthrough stream to consume to prevent OOM
                let stream = new PassThrough();
                if (typeof message.pipe === &#039;function&#039;) {
                    message.pipe(stream);
                } else {
                    stream.write(message);
                    stream.end();
                }

                return callback(err);
            }
            let envelopeTime = Date.now();
            let stream = this._createSendStream((err, str) =&gt; {
                if (err) {
                    return callback(err);
                }

                info.envelopeTime = envelopeTime - startTime;
                info.messageTime = Date.now() - envelopeTime;
                info.messageSize = stream.outByteCount;
                info.response = str;

                return callback(null, info);
            });
            if (typeof message.pipe === &#039;function&#039;) {
                message.pipe(stream);
            } else {
                stream.write(message);
                stream.end();
            }
        });
    }

    /**
     * Resets connection state
     *
     * @param {Function} callback Callback to return once connection is reset
     */
    reset(callback) {
        this._sendCommand(&#039;RSET&#039;);
        this._responseActions.push(str =&gt; {
            if (str.charAt(0) !== &#039;2&#039;) {
                return callback(this._formatError(&#039;Could not reset session state. response=&#039; + str, &#039;EPROTOCOL&#039;, str, &#039;RSET&#039;));
            }
            this._envelope = false;
            return callback(null, true);
        });
    }

    /**
     * Connection listener that is run when the connection to
     * the server is opened
     *
     * @event
     */
    _onConnect() {
        clearTimeout(this._connectionTimeout);

        this.logger.info(
            {
                tnx: &#039;network&#039;,
                localAddress: this._socket.localAddress,
                localPort: this._socket.localPort,
                remoteAddress: this._socket.remoteAddress,
                remotePort: this._socket.remotePort
            },
            &#039;%s established to %s:%s&#039;,
            this.secure ? &#039;Secure connection&#039; : &#039;Connection&#039;,
            this._socket.remoteAddress,
            this._socket.remotePort
        );

        if (this._destroyed) {
            // Connection was established after we already had canceled it
            this.close();
            return;
        }

        this.stage = &#039;connected&#039;;

        // clear existing listeners for the socket
        this._socket.removeListener(&#039;data&#039;, this._onSocketData);
        this._socket.removeListener(&#039;timeout&#039;, this._onSocketTimeout);
        this._socket.removeListener(&#039;close&#039;, this._onSocketClose);
        this._socket.removeListener(&#039;end&#039;, this._onSocketEnd);

        this._socket.on(&#039;data&#039;, this._onSocketData);
        this._socket.once(&#039;close&#039;, this._onSocketClose);
        this._socket.once(&#039;end&#039;, this._onSocketEnd);

        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
        this._socket.on(&#039;timeout&#039;, this._onSocketTimeout);

        this._greetingTimeout = setTimeout(() =&gt; {
            // if still waiting for greeting, give up
            if (this._socket &amp;&amp; !this._destroyed &amp;&amp; this._responseActions[0] === this._actionGreeting) {
                this._onError(&#039;Greeting never received&#039;, &#039;ETIMEDOUT&#039;, false, &#039;CONN&#039;);
            }
        }, this.options.greetingTimeout || GREETING_TIMEOUT);

        this._responseActions.push(this._actionGreeting);

        // we have a &#039;data&#039; listener set up so resume socket if it was paused
        this._socket.resume();
    }

    /**
     * &#039;data&#039; listener for data coming from the server
     *
     * @event
     * @param {Buffer} chunk Data chunk coming from the server
     */
    _onData(chunk) {
        if (this._destroyed || !chunk || !chunk.length) {
            return;
        }

        let data = (chunk || &#039;&#039;).toString(&#039;binary&#039;);
        let lines = (this._remainder + data).split(/\r?\n/);
        let lastline;

        this._remainder = lines.pop();

        for (let i = 0, len = lines.length; i &lt; len; i++) {
            if (this._responseQueue.length) {
                lastline = this._responseQueue[this._responseQueue.length - 1];
                if (/^\d+-/.test(lastline.split(&#039;\n&#039;).pop())) {
                    this._responseQueue[this._responseQueue.length - 1] += &#039;\n&#039; + lines[i];
                    continue;
                }
            }
            this._responseQueue.push(lines[i]);
        }

        if (this._responseQueue.length) {
            lastline = this._responseQueue[this._responseQueue.length - 1];
            if (/^\d+-/.test(lastline.split(&#039;\n&#039;).pop())) {
                return;
            }
        }

        this._processResponse();
    }

    /**
     * &#039;error&#039; listener for the socket
     *
     * @event
     * @param {Error} err Error object
     * @param {String} type Error name
     */
    _onError(err, type, data, command) {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);

        if (this._destroyed) {
            // just ignore, already closed
            // this might happen when a socket is canceled because of reached timeout
            // but the socket timeout error itself receives only after
            return;
        }

        err = this._formatError(err, type, data, command);

        this.logger.error(data, err.message);

        this.emit(&#039;error&#039;, err);
        this.close();
    }

    _formatError(message, type, response, command) {
        let err;

        if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
            err = message;
        } else {
            err = new Error(message);
        }

        if (type &amp;&amp; type !== &#039;Error&#039;) {
            err.code = type;
        }

        if (response) {
            err.response = response;
            err.message += &#039;: &#039; + response;
        }

        let responseCode = (typeof response === &#039;string&#039; &amp;&amp; Number((response.match(/^\d+/) || [])[0])) || false;
        if (responseCode) {
            err.responseCode = responseCode;
        }

        if (command) {
            err.command = command;
        }

        return err;
    }

    /**
     * &#039;close&#039; listener for the socket
     *
     * @event
     */
    _onClose() {
        let serverResponse = false;

        if (this._remainder &amp;&amp; this._remainder.trim()) {
            if (this.options.debug || this.options.transactionLog) {
                this.logger.debug(
                    {
                        tnx: &#039;server&#039;
                    },
                    this._remainder.replace(/\r?\n$/, &#039;&#039;)
                );
            }
            this.lastServerResponse = serverResponse = this._remainder.trim();
        }

        this.logger.info(
            {
                tnx: &#039;network&#039;
            },
            &#039;Connection closed&#039;
        );

        if (this.upgrading &amp;&amp; !this._destroyed) {
            return this._onError(new Error(&#039;Connection closed unexpectedly&#039;), &#039;ETLS&#039;, serverResponse, &#039;CONN&#039;);
        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) &amp;&amp; !this._destroyed) {
            return this._onError(new Error(&#039;Connection closed unexpectedly&#039;), &#039;ECONNECTION&#039;, serverResponse, &#039;CONN&#039;);
        } else if (/^[45]\d{2}\b/.test(serverResponse)) {
            return this._onError(new Error(&#039;Connection closed unexpectedly&#039;), &#039;ECONNECTION&#039;, serverResponse, &#039;CONN&#039;);
        }

        this._destroy();
    }

    /**
     * &#039;end&#039; listener for the socket
     *
     * @event
     */
    _onEnd() {
        if (this._socket &amp;&amp; !this._socket.destroyed) {
            this._socket.destroy();
        }
    }

    /**
     * &#039;timeout&#039; listener for the socket
     *
     * @event
     */
    _onTimeout() {
        return this._onError(new Error(&#039;Timeout&#039;), &#039;ETIMEDOUT&#039;, false, &#039;CONN&#039;);
    }

    /**
     * Destroys the client, emits &#039;end&#039;
     */
    _destroy() {
        if (this._destroyed) {
            return;
        }
        this._destroyed = true;
        this.emit(&#039;end&#039;);
    }

    /**
     * Upgrades the connection to TLS
     *
     * @param {Function} callback Callback function to run when the connection
     *        has been secured
     */
    _upgradeConnection(callback) {
        // do not remove all listeners or it breaks node v0.10 as there&#039;s
        // apparently a &#039;finish&#039; event set that would be cleared as well

        // we can safely keep &#039;error&#039;, &#039;end&#039;, &#039;close&#039; etc. events
        this._socket.removeListener(&#039;data&#039;, this._onSocketData); // incoming data is going to be gibberish from this point onwards
        this._socket.removeListener(&#039;timeout&#039;, this._onSocketTimeout); // timeout will be re-set for the new socket object

        let socketPlain = this._socket;
        let opts = {
            socket: this._socket,
            host: this.host
        };

        Object.keys(this.options.tls || {}).forEach(key =&gt; {
            opts[key] = this.options.tls[key];
        });

        // ensure servername for SNI
        if (this.servername &amp;&amp; !opts.servername) {
            opts.servername = this.servername;
        }

        this.upgrading = true;
        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch
        try {
            this._socket = tls.connect(opts, () =&gt; {
                this.secure = true;
                this.upgrading = false;
                this._socket.on(&#039;data&#039;, this._onSocketData);

                socketPlain.removeListener(&#039;close&#039;, this._onSocketClose);
                socketPlain.removeListener(&#039;end&#039;, this._onSocketEnd);

                return callback(null, true);
            });
        } catch (err) {
            return callback(err);
        }

        this._socket.on(&#039;error&#039;, this._onSocketError);
        this._socket.once(&#039;close&#039;, this._onSocketClose);
        this._socket.once(&#039;end&#039;, this._onSocketEnd);

        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.
        this._socket.on(&#039;timeout&#039;, this._onSocketTimeout);

        // resume in case the socket was paused
        socketPlain.resume();
    }

    /**
     * Processes queued responses from the server
     *
     * @param {Boolean} force If true, ignores _processing flag
     */
    _processResponse() {
        if (!this._responseQueue.length) {
            return false;
        }

        let str = (this.lastServerResponse = (this._responseQueue.shift() || &#039;&#039;).toString());

        if (/^\d+-/.test(str.split(&#039;\n&#039;).pop())) {
            // keep waiting for the final part of multiline response
            return;
        }

        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug(
                {
                    tnx: &#039;server&#039;
                },
                str.replace(/\r?\n$/, &#039;&#039;)
            );
        }

        if (!str.trim()) {
            // skip unexpected empty lines
            setImmediate(() =&gt; this._processResponse());
        }

        let action = this._responseActions.shift();

        if (typeof action === &#039;function&#039;) {
            action.call(this, str);
            setImmediate(() =&gt; this._processResponse());
        } else {
            return this._onError(new Error(&#039;Unexpected Response&#039;), &#039;EPROTOCOL&#039;, str, &#039;CONN&#039;);
        }
    }

    /**
     * Send a command to the server, append \r\n
     *
     * @param {String} str String to be sent to the server
     * @param {String} logStr Optional string to be used for logging instead of the actual string
     */
    _sendCommand(str, logStr) {
        if (this._destroyed) {
            // Connection already closed, can&#039;t send any more data
            return;
        }

        if (this._socket.destroyed) {
            return this.close();
        }

        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug(
                {
                    tnx: &#039;client&#039;
                },
                (logStr || str || &#039;&#039;).toString().replace(/\r?\n$/, &#039;&#039;)
            );
        }

        this._socket.write(Buffer.from(str + &#039;\r\n&#039;, &#039;utf-8&#039;));
    }

    /**
     * Initiates a new message by submitting envelope data, starting with
     * MAIL FROM: command
     *
     * @param {Object} envelope Envelope object in the form of
     *        {from:&#039;...&#039;, to:[&#039;...&#039;]}
     *        or
     *        {from:{address:&#039;...&#039;,name:&#039;...&#039;}, to:[address:&#039;...&#039;,name:&#039;...&#039;]}
     */
    _setEnvelope(envelope, callback) {
        let args = [];
        let useSmtpUtf8 = false;

        this._envelope = envelope || {};
        this._envelope.from = ((this._envelope.from &amp;&amp; this._envelope.from.address) || this._envelope.from || &#039;&#039;).toString().trim();

        this._envelope.to = [].concat(this._envelope.to || []).map(to =&gt; ((to &amp;&amp; to.address) || to || &#039;&#039;).toString().trim());

        if (!this._envelope.to.length) {
            return callback(this._formatError(&#039;No recipients defined&#039;, &#039;EENVELOPE&#039;, false, &#039;API&#039;));
        }

        if (this._envelope.from &amp;&amp; /[\r\n&lt;&gt;]/.test(this._envelope.from)) {
            return callback(this._formatError(&#039;Invalid sender &#039; + JSON.stringify(this._envelope.from), &#039;EENVELOPE&#039;, false, &#039;API&#039;));
        }

        // check if the sender address uses only ASCII characters,
        // otherwise require usage of SMTPUTF8 extension
        if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
            useSmtpUtf8 = true;
        }

        for (let i = 0, len = this._envelope.to.length; i &lt; len; i++) {
            if (!this._envelope.to[i] || /[\r\n&lt;&gt;]/.test(this._envelope.to[i])) {
                return callback(this._formatError(&#039;Invalid recipient &#039; + JSON.stringify(this._envelope.to[i]), &#039;EENVELOPE&#039;, false, &#039;API&#039;));
            }

            // check if the recipients addresses use only ASCII characters,
            // otherwise require usage of SMTPUTF8 extension
            if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
                useSmtpUtf8 = true;
            }
        }

        // clone the recipients array for latter manipulation
        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
        this._envelope.rejected = [];
        this._envelope.rejectedErrors = [];
        this._envelope.accepted = [];

        if (this._envelope.dsn) {
            try {
                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
            } catch (err) {
                return callback(this._formatError(&#039;Invalid DSN &#039; + err.message, &#039;EENVELOPE&#039;, false, &#039;API&#039;));
            }
        }

        this._responseActions.push(str =&gt; {
            this._actionMAIL(str, callback);
        });

        // If the server supports SMTPUTF8 and the envelope includes an internationalized
        // email address then append SMTPUTF8 keyword to the MAIL FROM command
        if (useSmtpUtf8 &amp;&amp; this._supportedExtensions.includes(&#039;SMTPUTF8&#039;)) {
            args.push(&#039;SMTPUTF8&#039;);
            this._usingSmtpUtf8 = true;
        }

        // If the server supports 8BITMIME and the message might contain non-ascii bytes
        // then append the 8BITMIME keyword to the MAIL FROM command
        if (this._envelope.use8BitMime &amp;&amp; this._supportedExtensions.includes(&#039;8BITMIME&#039;)) {
            args.push(&#039;BODY=8BITMIME&#039;);
            this._using8BitMime = true;
        }

        if (this._envelope.size &amp;&amp; this._supportedExtensions.includes(&#039;SIZE&#039;)) {
            args.push(&#039;SIZE=&#039; + this._envelope.size);
        }

        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the MAIL FROM command
        if (this._envelope.dsn &amp;&amp; this._supportedExtensions.includes(&#039;DSN&#039;)) {
            if (this._envelope.dsn.ret) {
                args.push(&#039;RET=&#039; + shared.encodeXText(this._envelope.dsn.ret));
            }
            if (this._envelope.dsn.envid) {
                args.push(&#039;ENVID=&#039; + shared.encodeXText(this._envelope.dsn.envid));
            }
        }

        this._sendCommand(&#039;MAIL FROM:&lt;&#039; + this._envelope.from + &#039;&gt;&#039; + (args.length ? &#039; &#039; + args.join(&#039; &#039;) : &#039;&#039;));
    }

    _setDsnEnvelope(params) {
        let ret = (params.ret || params.return || &#039;&#039;).toString().toUpperCase() || null;
        if (ret) {
            switch (ret) {
                case &#039;HDRS&#039;:
                case &#039;HEADERS&#039;:
                    ret = &#039;HDRS&#039;;
                    break;
                case &#039;FULL&#039;:
                case &#039;BODY&#039;:
                    ret = &#039;FULL&#039;;
                    break;
            }
        }

        if (ret &amp;&amp; ![&#039;FULL&#039;, &#039;HDRS&#039;].includes(ret)) {
            throw new Error(&#039;ret: &#039; + JSON.stringify(ret));
        }

        let envid = (params.envid || params.id || &#039;&#039;).toString() || null;

        let notify = params.notify || null;
        if (notify) {
            if (typeof notify === &#039;string&#039;) {
                notify = notify.split(&#039;,&#039;);
            }
            notify = notify.map(n =&gt; n.trim().toUpperCase());
            let validNotify = [&#039;NEVER&#039;, &#039;SUCCESS&#039;, &#039;FAILURE&#039;, &#039;DELAY&#039;];
            let invaliNotify = notify.filter(n =&gt; !validNotify.includes(n));
            if (invaliNotify.length || (notify.length &gt; 1 &amp;&amp; notify.includes(&#039;NEVER&#039;))) {
                throw new Error(&#039;notify: &#039; + JSON.stringify(notify.join(&#039;,&#039;)));
            }
            notify = notify.join(&#039;,&#039;);
        }

        let orcpt = (params.recipient || params.orcpt || &#039;&#039;).toString() || null;
        if (orcpt &amp;&amp; orcpt.indexOf(&#039;;&#039;) &lt; 0) {
            orcpt = &#039;rfc822;&#039; + orcpt;
        }

        return {
            ret,
            envid,
            notify,
            orcpt
        };
    }

    _getDsnRcptToArgs() {
        let args = [];
        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the RCPT TO command
        if (this._envelope.dsn &amp;&amp; this._supportedExtensions.includes(&#039;DSN&#039;)) {
            if (this._envelope.dsn.notify) {
                args.push(&#039;NOTIFY=&#039; + shared.encodeXText(this._envelope.dsn.notify));
            }
            if (this._envelope.dsn.orcpt) {
                args.push(&#039;ORCPT=&#039; + shared.encodeXText(this._envelope.dsn.orcpt));
            }
        }
        return args.length ? &#039; &#039; + args.join(&#039; &#039;) : &#039;&#039;;
    }

    _createSendStream(callback) {
        let dataStream = new DataStream();
        let logStream;

        if (this.options.lmtp) {
            this._envelope.accepted.forEach((recipient, i) =&gt; {
                let final = i === this._envelope.accepted.length - 1;
                this._responseActions.push(str =&gt; {
                    this._actionLMTPStream(recipient, final, str, callback);
                });
            });
        } else {
            this._responseActions.push(str =&gt; {
                this._actionSMTPStream(str, callback);
            });
        }

        dataStream.pipe(this._socket, {
            end: false
        });

        if (this.options.debug) {
            logStream = new PassThrough();
            logStream.on(&#039;readable&#039;, () =&gt; {
                let chunk;
                while ((chunk = logStream.read())) {
                    this.logger.debug(
                        {
                            tnx: &#039;message&#039;
                        },
                        chunk.toString(&#039;binary&#039;).replace(/\r?\n$/, &#039;&#039;)
                    );
                }
            });
            dataStream.pipe(logStream);
        }

        dataStream.once(&#039;end&#039;, () =&gt; {
            this.logger.info(
                {
                    tnx: &#039;message&#039;,
                    inByteCount: dataStream.inByteCount,
                    outByteCount: dataStream.outByteCount
                },
                &#039;&lt;%s bytes encoded mime message (source size %s bytes)&gt;&#039;,
                dataStream.outByteCount,
                dataStream.inByteCount
            );
        });

        return dataStream;
    }

    /** ACTIONS **/

    /**
     * Will be run after the connection is created and the server sends
     * a greeting. If the incoming message starts with 220 initiate
     * SMTP session by sending EHLO command
     *
     * @param {String} str Message from the server
     */
    _actionGreeting(str) {
        clearTimeout(this._greetingTimeout);

        if (str.substr(0, 3) !== &#039;220&#039;) {
            this._onError(new Error(&#039;Invalid greeting. response=&#039; + str), &#039;EPROTOCOL&#039;, str, &#039;CONN&#039;);
            return;
        }

        if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand(&#039;LHLO &#039; + this.name);
        } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand(&#039;EHLO &#039; + this.name);
        }
    }

    /**
     * Handles server response for LHLO command. If it yielded in
     * error, emit &#039;error&#039;, otherwise treat this as an EHLO response
     *
     * @param {String} str Message from the server
     */
    _actionLHLO(str) {
        if (str.charAt(0) !== &#039;2&#039;) {
            this._onError(new Error(&#039;Invalid LHLO. response=&#039; + str), &#039;EPROTOCOL&#039;, str, &#039;LHLO&#039;);
            return;
        }

        this._actionEHLO(str);
    }

    /**
     * Handles server response for EHLO command. If it yielded in
     * error, try HELO instead, otherwise initiate TLS negotiation
     * if STARTTLS is supported by the server or move into the
     * authentication phase.
     *
     * @param {String} str Message from the server
     */
    _actionEHLO(str) {
        let match;

        if (str.substr(0, 3) === &#039;421&#039;) {
            this._onError(new Error(&#039;Server terminates connection. response=&#039; + str), &#039;ECONNECTION&#039;, str, &#039;EHLO&#039;);
            return;
        }

        if (str.charAt(0) !== &#039;2&#039;) {
            if (this.options.requireTLS) {
                this._onError(new Error(&#039;EHLO failed but HELO does not support required STARTTLS. response=&#039; + str), &#039;ECONNECTION&#039;, str, &#039;EHLO&#039;);
                return;
            }

            // Try HELO instead
            this._responseActions.push(this._actionHELO);
            this._sendCommand(&#039;HELO &#039; + this.name);
            return;
        }

        this._ehloLines = str
            .split(/\r?\n/)
            .map(line =&gt; line.replace(/^\d+[ -]/, &#039;&#039;).trim())
            .filter(line =&gt; line)
            .slice(1);

        // Detect if the server supports STARTTLS
        if (!this.secure &amp;&amp; !this.options.ignoreTLS &amp;&amp; (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
            this._sendCommand(&#039;STARTTLS&#039;);
            this._responseActions.push(this._actionSTARTTLS);
            return;
        }

        // Detect if the server supports SMTPUTF8
        if (/[ -]SMTPUTF8\b/im.test(str)) {
            this._supportedExtensions.push(&#039;SMTPUTF8&#039;);
        }

        // Detect if the server supports DSN
        if (/[ -]DSN\b/im.test(str)) {
            this._supportedExtensions.push(&#039;DSN&#039;);
        }

        // Detect if the server supports 8BITMIME
        if (/[ -]8BITMIME\b/im.test(str)) {
            this._supportedExtensions.push(&#039;8BITMIME&#039;);
        }

        // Detect if the server supports PIPELINING
        if (/[ -]PIPELINING\b/im.test(str)) {
            this._supportedExtensions.push(&#039;PIPELINING&#039;);
        }

        // Detect if the server supports AUTH
        if (/[ -]AUTH\b/i.test(str)) {
            this.allowsAuth = true;
        }

        // Detect if the server supports PLAIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
            this._supportedAuth.push(&#039;PLAIN&#039;);
        }

        // Detect if the server supports LOGIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
            this._supportedAuth.push(&#039;LOGIN&#039;);
        }

        // Detect if the server supports CRAM-MD5 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
            this._supportedAuth.push(&#039;CRAM-MD5&#039;);
        }

        // Detect if the server supports XOAUTH2 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
            this._supportedAuth.push(&#039;XOAUTH2&#039;);
        }

        // Detect if the server supports SIZE extensions (and the max allowed size)
        if ((match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im))) {
            this._supportedExtensions.push(&#039;SIZE&#039;);
            this._maxAllowedSize = Number(match[1]) || 0;
        }

        this.emit(&#039;connect&#039;);
    }

    /**
     * Handles server response for HELO command. If it yielded in
     * error, emit &#039;error&#039;, otherwise move into the authentication phase.
     *
     * @param {String} str Message from the server
     */
    _actionHELO(str) {
        if (str.charAt(0) !== &#039;2&#039;) {
            this._onError(new Error(&#039;Invalid HELO. response=&#039; + str), &#039;EPROTOCOL&#039;, str, &#039;HELO&#039;);
            return;
        }

        // assume that authentication is enabled (most probably is not though)
        this.allowsAuth = true;

        this.emit(&#039;connect&#039;);
    }

    /**
     * Handles server response for STARTTLS command. If there&#039;s an error
     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
     * succeedes restart the EHLO
     *
     * @param {String} str Message from the server
     */
    _actionSTARTTLS(str) {
        if (str.charAt(0) !== &#039;2&#039;) {
            if (this.options.opportunisticTLS) {
                this.logger.info(
                    {
                        tnx: &#039;smtp&#039;
                    },
                    &#039;Failed STARTTLS upgrade, continuing unencrypted&#039;
                );
                return this.emit(&#039;connect&#039;);
            }
            this._onError(new Error(&#039;Error upgrading connection with STARTTLS&#039;), &#039;ETLS&#039;, str, &#039;STARTTLS&#039;);
            return;
        }

        this._upgradeConnection((err, secured) =&gt; {
            if (err) {
                this._onError(new Error(&#039;Error initiating TLS - &#039; + (err.message || err)), &#039;ETLS&#039;, false, &#039;STARTTLS&#039;);
                return;
            }

            this.logger.info(
                {
                    tnx: &#039;smtp&#039;
                },
                &#039;Connection upgraded with STARTTLS&#039;
            );

            if (secured) {
                // restart session
                if (this.options.lmtp) {
                    this._responseActions.push(this._actionLHLO);
                    this._sendCommand(&#039;LHLO &#039; + this.name);
                } else {
                    this._responseActions.push(this._actionEHLO);
                    this._sendCommand(&#039;EHLO &#039; + this.name);
                }
            } else {
                this.emit(&#039;connect&#039;);
            }
        });
    }

    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * &#039;334 VXNlcm5hbWU6&#039; (base64 for &#039;Username:&#039;). Data to be sent as
     * response needs to be base64 encoded username. We do not need
     * exact match but settle with 334 response in general as some
     * hosts invalidly use a longer message than VXNlcm5hbWU6
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_LOGIN_USER(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting &#039;334 VXNlcm5hbWU6&#039;
            callback(this._formatError(&#039;Invalid login sequence while waiting for &quot;334 VXNlcm5hbWU6&quot;&#039;, &#039;EAUTH&#039;, str, &#039;AUTH LOGIN&#039;));
            return;
        }

        this._responseActions.push(str =&gt; {
            this._actionAUTH_LOGIN_PASS(str, callback);
        });

        this._sendCommand(Buffer.from(this._auth.credentials.user + &#039;&#039;, &#039;utf-8&#039;).toString(&#039;base64&#039;));
    }

    /**
     * Handle the response for AUTH CRAM-MD5 command. We are expecting
     * &#039;334 &lt;challenge string&gt;&#039;. Data to be sent as response needs to be
     * base64 decoded challenge string, MD5 hashed using the password as
     * a HMAC key, prefixed by the username and a space, and finally all
     * base64 encoded again.
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_CRAM_MD5(str, callback) {
        let challengeMatch = str.match(/^334\s+(.+)$/);
        let challengeString = &#039;&#039;;

        if (!challengeMatch) {
            return callback(this._formatError(&#039;Invalid login sequence while waiting for server challenge string&#039;, &#039;EAUTH&#039;, str, &#039;AUTH CRAM-MD5&#039;));
        } else {
            challengeString = challengeMatch[1];
        }

        // Decode from base64
        let base64decoded = Buffer.from(challengeString, &#039;base64&#039;).toString(&#039;ascii&#039;),
            hmacMD5 = crypto.createHmac(&#039;md5&#039;, this._auth.credentials.pass);

        hmacMD5.update(base64decoded);

        let prepended = this._auth.credentials.user + &#039; &#039; + hmacMD5.digest(&#039;hex&#039;);

        this._responseActions.push(str =&gt; {
            this._actionAUTH_CRAM_MD5_PASS(str, callback);
        });

        this._sendCommand(
            Buffer.from(prepended).toString(&#039;base64&#039;),
            // hidden hash for logs
            Buffer.from(this._auth.credentials.user + &#039; /* secret */&#039;).toString(&#039;base64&#039;)
        );
    }

    /**
     * Handles the response to CRAM-MD5 authentication, if there&#039;s no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_CRAM_MD5_PASS(str, callback) {
        if (!str.match(/^235\s+/)) {
            return callback(this._formatError(&#039;Invalid login sequence while waiting for &quot;235&quot;&#039;, &#039;EAUTH&#039;, str, &#039;AUTH CRAM-MD5&#039;));
        }

        this.logger.info(
            {
                tnx: &#039;smtp&#039;,
                username: this._auth.user,
                action: &#039;authenticated&#039;,
                method: this._authMethod
            },
            &#039;User %s authenticated&#039;,
            JSON.stringify(this._auth.user)
        );
        this.authenticated = true;
        callback(null, true);
    }

    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * &#039;334 UGFzc3dvcmQ6&#039; (base64 for &#039;Password:&#039;). Data to be sent as
     * response needs to be base64 encoded password.
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_LOGIN_PASS(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting &#039;334 UGFzc3dvcmQ6&#039;
            return callback(this._formatError(&#039;Invalid login sequence while waiting for &quot;334 UGFzc3dvcmQ6&quot;&#039;, &#039;EAUTH&#039;, str, &#039;AUTH LOGIN&#039;));
        }

        this._responseActions.push(str =&gt; {
            this._actionAUTHComplete(str, callback);
        });

        this._sendCommand(
            Buffer.from((this._auth.credentials.pass || &#039;&#039;).toString(), &#039;utf-8&#039;).toString(&#039;base64&#039;),
            // Hidden pass for logs
            Buffer.from(&#039;/* secret */&#039;, &#039;utf-8&#039;).toString(&#039;base64&#039;)
        );
    }

    /**
     * Handles the response for authentication, if there&#039;s no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */
    _actionAUTHComplete(str, isRetry, callback) {
        if (!callback &amp;&amp; typeof isRetry === &#039;function&#039;) {
            callback = isRetry;
            isRetry = false;
        }

        if (str.substr(0, 3) === &#039;334&#039;) {
            this._responseActions.push(str =&gt; {
                if (isRetry || this._authMethod !== &#039;XOAUTH2&#039;) {
                    this._actionAUTHComplete(str, true, callback);
                } else {
                    // fetch a new OAuth2 access token
                    setImmediate(() =&gt; this._handleXOauth2Token(true, callback));
                }
            });
            this._sendCommand(&#039;&#039;);
            return;
        }

        if (str.charAt(0) !== &#039;2&#039;) {
            this.logger.info(
                {
                    tnx: &#039;smtp&#039;,
                    username: this._auth.user,
                    action: &#039;authfail&#039;,
                    method: this._authMethod
                },
                &#039;User %s failed to authenticate&#039;,
                JSON.stringify(this._auth.user)
            );
            return callback(this._formatError(&#039;Invalid login&#039;, &#039;EAUTH&#039;, str, &#039;AUTH &#039; + this._authMethod));
        }

        this.logger.info(
            {
                tnx: &#039;smtp&#039;,
                username: this._auth.user,
                action: &#039;authenticated&#039;,
                method: this._authMethod
            },
            &#039;User %s authenticated&#039;,
            JSON.stringify(this._auth.user)
        );
        this.authenticated = true;
        callback(null, true);
    }

    /**
     * Handle response for a MAIL FROM: command
     *
     * @param {String} str Message from the server
     */
    _actionMAIL(str, callback) {
        let message, curRecipient;
        if (Number(str.charAt(0)) !== 2) {
            if (this._usingSmtpUtf8 &amp;&amp; /^550 /.test(str) &amp;&amp; /[\x80-\uFFFF]/.test(this._envelope.from)) {
                message = &#039;Internationalized mailbox name not allowed&#039;;
            } else {
                message = &#039;Mail command failed&#039;;
            }
            return callback(this._formatError(message, &#039;EENVELOPE&#039;, str, &#039;MAIL FROM&#039;));
        }

        if (!this._envelope.rcptQueue.length) {
            return callback(this._formatError(&#039;Can\x27t send mail - no recipients defined&#039;, &#039;EENVELOPE&#039;, false, &#039;API&#039;));
        } else {
            this._recipientQueue = [];

            if (this._supportedExtensions.includes(&#039;PIPELINING&#039;)) {
                while (this._envelope.rcptQueue.length) {
                    curRecipient = this._envelope.rcptQueue.shift();
                    this._recipientQueue.push(curRecipient);
                    this._responseActions.push(str =&gt; {
                        this._actionRCPT(str, callback);
                    });
                    this._sendCommand(&#039;RCPT TO:&lt;&#039; + curRecipient + &#039;&gt;&#039; + this._getDsnRcptToArgs());
                }
            } else {
                curRecipient = this._envelope.rcptQueue.shift();
                this._recipientQueue.push(curRecipient);
                this._responseActions.push(str =&gt; {
                    this._actionRCPT(str, callback);
                });
                this._sendCommand(&#039;RCPT TO:&lt;&#039; + curRecipient + &#039;&gt;&#039; + this._getDsnRcptToArgs());
            }
        }
    }

    /**
     * Handle response for a RCPT TO: command
     *
     * @param {String} str Message from the server
     */
    _actionRCPT(str, callback) {
        let message,
            err,
            curRecipient = this._recipientQueue.shift();
        if (Number(str.charAt(0)) !== 2) {
            // this is a soft error
            if (this._usingSmtpUtf8 &amp;&amp; /^553 /.test(str) &amp;&amp; /[\x80-\uFFFF]/.test(curRecipient)) {
                message = &#039;Internationalized mailbox name not allowed&#039;;
            } else {
                message = &#039;Recipient command failed&#039;;
            }
            this._envelope.rejected.push(curRecipient);
            // store error for the failed recipient
            err = this._formatError(message, &#039;EENVELOPE&#039;, str, &#039;RCPT TO&#039;);
            err.recipient = curRecipient;
            this._envelope.rejectedErrors.push(err);
        } else {
            this._envelope.accepted.push(curRecipient);
        }

        if (!this._envelope.rcptQueue.length &amp;&amp; !this._recipientQueue.length) {
            if (this._envelope.rejected.length &lt; this._envelope.to.length) {
                this._responseActions.push(str =&gt; {
                    this._actionDATA(str, callback);
                });
                this._sendCommand(&#039;DATA&#039;);
            } else {
                err = this._formatError(&#039;Can\x27t send mail - all recipients were rejected&#039;, &#039;EENVELOPE&#039;, str, &#039;RCPT TO&#039;);
                err.rejected = this._envelope.rejected;
                err.rejectedErrors = this._envelope.rejectedErrors;
                return callback(err);
            }
        } else if (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push(str =&gt; {
                this._actionRCPT(str, callback);
            });
            this._sendCommand(&#039;RCPT TO:&lt;&#039; + curRecipient + &#039;&gt;&#039; + this._getDsnRcptToArgs());
        }
    }

    /**
     * Handle response for a DATA command
     *
     * @param {String} str Message from the server
     */
    _actionDATA(str, callback) {
        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24
        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit
        if (!/^[23]/.test(str)) {
            return callback(this._formatError(&#039;Data command failed&#039;, &#039;EENVELOPE&#039;, str, &#039;DATA&#039;));
        }

        let response = {
            accepted: this._envelope.accepted,
            rejected: this._envelope.rejected
        };

        if (this._ehloLines &amp;&amp; this._ehloLines.length) {
            response.ehlo = this._ehloLines;
        }

        if (this._envelope.rejectedErrors.length) {
            response.rejectedErrors = this._envelope.rejectedErrors;
        }

        callback(null, response);
    }

    /**
     * Handle response for a DATA stream when using SMTP
     * We expect a single response that defines if the sending succeeded or failed
     *
     * @param {String} str Message from the server
     */
    _actionSMTPStream(str, callback) {
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            return callback(this._formatError(&#039;Message failed&#039;, &#039;EMESSAGE&#039;, str, &#039;DATA&#039;));
        } else {
            // Message sent succesfully
            return callback(null, str);
        }
    }

    /**
     * Handle response for a DATA stream
     * We expect a separate response for every recipient. All recipients can either
     * succeed or fail separately
     *
     * @param {String} recipient The recipient this response applies to
     * @param {Boolean} final Is this the final recipient?
     * @param {String} str Message from the server
     */
    _actionLMTPStream(recipient, final, str, callback) {
        let err;
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            err = this._formatError(&#039;Message failed for recipient &#039; + recipient, &#039;EMESSAGE&#039;, str, &#039;DATA&#039;);
            err.recipient = recipient;
            this._envelope.rejected.push(recipient);
            this._envelope.rejectedErrors.push(err);
            for (let i = 0, len = this._envelope.accepted.length; i &lt; len; i++) {
                if (this._envelope.accepted[i] === recipient) {
                    this._envelope.accepted.splice(i, 1);
                }
            }
        }
        if (final) {
            return callback(null, str);
        }
    }

    _handleXOauth2Token(isRetry, callback) {
        this._auth.oauth2.getToken(isRetry, (err, accessToken) =&gt; {
            if (err) {
                this.logger.info(
                    {
                        tnx: &#039;smtp&#039;,
                        username: this._auth.user,
                        action: &#039;authfail&#039;,
                        method: this._authMethod
                    },
                    &#039;User %s failed to authenticate&#039;,
                    JSON.stringify(this._auth.user)
                );
                return callback(this._formatError(err, &#039;EAUTH&#039;, false, &#039;AUTH XOAUTH2&#039;));
            }
            this._responseActions.push(str =&gt; {
                this._actionAUTHComplete(str, isRetry, callback);
            });
            this._sendCommand(
                &#039;AUTH XOAUTH2 &#039; + this._auth.oauth2.buildXOAuth2Token(accessToken),
                //  Hidden for logs
                &#039;AUTH XOAUTH2 &#039; + this._auth.oauth2.buildXOAuth2Token(&#039;/* secret */&#039;)
            );
        });
    }

    /**
     *
     * @param {string} command
     * @private
     */
    _isDestroyedMessage(command) {
        if (this._destroyed) {
            return &#039;Cannot &#039; + command + &#039; - smtp connection is already destroyed.&#039;;
        }

        if (this._socket) {
            if (this._socket.destroyed) {
                return &#039;Cannot &#039; + command + &#039; - smtp connection socket is already destroyed.&#039;;
            }

            if (!this._socket.writable) {
                return &#039;Cannot &#039; + command + &#039; - smtp connection socket is already half-closed.&#039;;
            }
        }
    }

    _getHostname() {
        // defaul hostname is machine hostname or [IP]
        let defaultHostname;
        try {
            defaultHostname = os.hostname() || &#039;&#039;;
        } catch (err) {
            // fails on windows 7
            defaultHostname = &#039;localhost&#039;;
        }

        // ignore if not FQDN
        if (!defaultHostname || defaultHostname.indexOf(&#039;.&#039;) &lt; 0) {
            defaultHostname = &#039;[127.0.0.1]&#039;;
        }

        // IP should be enclosed in []
        if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
            defaultHostname = &#039;[&#039; + defaultHostname + &#039;]&#039;;
        }

        return defaultHostname;
    }
}

module.exports = SMTPConnection;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
