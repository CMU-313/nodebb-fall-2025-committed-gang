<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/enhanced-resolve/lib/Resolver.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/enhanced-resolve/lib/Resolver.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.52</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">800</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.84</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require(&quot;tapable&quot;);
const createInnerContext = require(&quot;./createInnerContext&quot;);
const { parseIdentifier } = require(&quot;./util/identifier&quot;);
const {
	PathType,
	cachedJoin: join,
	getType,
	normalize,
} = require(&quot;./util/path&quot;);

/** @typedef {import(&quot;./ResolverFactory&quot;).ResolveOptions} ResolveOptions */

/** @typedef {Error &amp; { details?: string }} ErrorWithDetail */

/** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) =&gt; void} ResolveCallback */

/**
 * @typedef {object} PossibleFileSystemError
 * @property {string=} code code
 * @property {number=} errno number
 * @property {string=} path path
 * @property {string=} syscall syscall
 */

/**
 * @template T
 * @callback FileSystemCallback
 * @param {PossibleFileSystemError &amp; Error | null} err
 * @param {T=} result
 */

/**
 * @typedef {string | Buffer | URL} PathLike
 */

/**
 * @typedef {PathLike | number} PathOrFileDescriptor
 */

/**
 * @typedef {object} ObjectEncodingOptions
 * @property {BufferEncoding | null | undefined=} encoding encoding
 */

/**
 * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null} EncodingOption
 */

/** @typedef {(err: NodeJS.ErrnoException | null, result?: string) =&gt; void} StringCallback */
/** @typedef {(err: NodeJS.ErrnoException | null, result?: Buffer) =&gt; void} BufferCallback */
/** @typedef {(err: NodeJS.ErrnoException | null, result?: (string | Buffer)) =&gt; void} StringOrBufferCallback */
/** @typedef {(err: NodeJS.ErrnoException | null, result?: IStats) =&gt; void} StatsCallback */
/** @typedef {(err: NodeJS.ErrnoException | null, result?: IBigIntStats) =&gt; void} BigIntStatsCallback */
/** @typedef {(err: NodeJS.ErrnoException | null, result?: (IStats | IBigIntStats)) =&gt; void} StatsOrBigIntStatsCallback */
/** @typedef {(err: NodeJS.ErrnoException | Error | null, result?: JsonObject) =&gt; void} ReadJsonCallback */

/**
 * @template T
 * @typedef {object} IStatsBase
 * @property {() =&gt; boolean} isFile is file
 * @property {() =&gt; boolean} isDirectory is directory
 * @property {() =&gt; boolean} isBlockDevice is block device
 * @property {() =&gt; boolean} isCharacterDevice is character device
 * @property {() =&gt; boolean} isSymbolicLink is symbolic link
 * @property {() =&gt; boolean} isFIFO is FIFO
 * @property {() =&gt; boolean} isSocket is socket
 * @property {T} dev dev
 * @property {T} ino ino
 * @property {T} mode mode
 * @property {T} nlink nlink
 * @property {T} uid uid
 * @property {T} gid gid
 * @property {T} rdev rdev
 * @property {T} size size
 * @property {T} blksize blksize
 * @property {T} blocks blocks
 * @property {T} atimeMs atime ms
 * @property {T} mtimeMs mtime ms
 * @property {T} ctimeMs ctime ms
 * @property {T} birthtimeMs birthtime ms
 * @property {Date} atime atime
 * @property {Date} mtime mtime
 * @property {Date} ctime ctime
 * @property {Date} birthtime birthtime
 */

/**
 * @typedef {IStatsBase&lt;number&gt;} IStats
 */

/**
 * @typedef {IStatsBase&lt;bigint&gt; &amp; { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint }} IBigIntStats
 */

/**
 * @template {string | Buffer} [T=string]
 * @typedef {object} Dirent
 * @property {() =&gt; boolean} isFile true when is file, otherwise false
 * @property {() =&gt; boolean} isDirectory true when is directory, otherwise false
 * @property {() =&gt; boolean} isBlockDevice true when is block device, otherwise false
 * @property {() =&gt; boolean} isCharacterDevice true when is character device, otherwise false
 * @property {() =&gt; boolean} isSymbolicLink true when is symbolic link, otherwise false
 * @property {() =&gt; boolean} isFIFO true when is FIFO, otherwise false
 * @property {() =&gt; boolean} isSocket true when is socket, otherwise false
 * @property {T} name name
 * @property {string} parentPath path
 * @property {string=} path path
 */

/**
 * @typedef {object} StatOptions
 * @property {(boolean | undefined)=} bigint need bigint values
 */

/**
 * @typedef {object} StatSyncOptions
 * @property {(boolean | undefined)=} bigint need bigint values
 * @property {(boolean | undefined)=} throwIfNoEntry throw if no entry
 */

/**
 * @typedef {{
 * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined } &amp; import(&quot;events&quot;).Abortable) | undefined | null, callback: BufferCallback): void;
 * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined } &amp; import(&quot;events&quot;).Abortable) | BufferEncoding, callback: StringCallback): void;
 * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions &amp; { flag?: string | undefined } &amp; import(&quot;events&quot;).Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;
 * (path: PathOrFileDescriptor, callback: BufferCallback): void;
 * }} ReadFile
 */

/**
 * @typedef {&#039;buffer&#039;| { encoding: &#039;buffer&#039; }} BufferEncodingOption
 */

/**
 * @typedef {{
 * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined } | null): Buffer;
 * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined } | BufferEncoding): string;
 * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions &amp; { flag?: string | undefined }) | BufferEncoding | null): string | Buffer;
 * }} ReadFileSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[]) =&gt; void): void;
 * (path: PathLike, options: { encoding: &#039;buffer&#039;, withFileTypes?: false | undefined, recursive?: boolean | undefined } | &#039;buffer&#039;, callback: (err: NodeJS.ErrnoException | null, files?: Buffer[]) =&gt; void): void;
 * (path: PathLike, options: (ObjectEncodingOptions &amp; { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[] | Buffer[]) =&gt; void): void;
 * (path: PathLike, callback: (err: NodeJS.ErrnoException | null, files?: string[]) =&gt; void): void;
 * (path: PathLike, options: ObjectEncodingOptions &amp; { withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files?: Dirent&lt;string&gt;[]) =&gt; void): void;
 * (path: PathLike, options: { encoding: &#039;buffer&#039;, withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files: Dirent&lt;Buffer&gt;[]) =&gt; void): void;
 * }} Readdir
 */

/**
 * @typedef {{
 * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined; } | BufferEncoding | null): string[];
 * (path: PathLike, options: { encoding: &#039;buffer&#039;, withFileTypes?: false | undefined, recursive?: boolean | undefined } | &#039;buffer&#039;): Buffer[];
 * (path: PathLike, options?: (ObjectEncodingOptions &amp; { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | null): string[] | Buffer[];
 * (path: PathLike, options: ObjectEncodingOptions &amp; { withFileTypes: true, recursive?: boolean | undefined }): Dirent[];
 * (path: PathLike, options: { encoding: &quot;buffer&quot;, withFileTypes: true, recursive?: boolean | undefined }): Dirent&lt;Buffer&gt;[];
 * }} ReaddirSync
 */

/**
 * @typedef {(pathOrFileDescription: PathOrFileDescriptor, callback: ReadJsonCallback) =&gt; void} ReadJson
 */

/**
 * @typedef {(pathOrFileDescription: PathOrFileDescriptor) =&gt; JsonObject} ReadJsonSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * }} Readlink
 */

/**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * }} ReadlinkSync
 */

/**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions &amp; { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions &amp; { bigint: true }, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * }} LStat
 */

/**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions &amp; { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions &amp; { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions &amp; { bigint?: false | undefined }): IStats;
 * (path: PathLike, options: StatSyncOptions &amp; { bigint: true }): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions &amp; { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * }} LStatSync
 */

/**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions &amp; { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions &amp; { bigint: true }, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * }} Stat
 */

/**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions &amp; { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions &amp; { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions &amp; { bigint?: false | undefined }): IStats;
 * (path: PathLike, options: StatSyncOptions &amp; { bigint: true }): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions &amp; { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * }} StatSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * }} RealPath
 */

/**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * }} RealPathSync
 */

/**
 * @typedef {object} FileSystem
 * @property {ReadFile} readFile read file method
 * @property {Readdir} readdir readdir method
 * @property {ReadJson=} readJson read json method
 * @property {Readlink} readlink read link method
 * @property {LStat=} lstat lstat method
 * @property {Stat} stat stat method
 * @property {RealPath=} realpath realpath method
 */

/**
 * @typedef {object} SyncFileSystem
 * @property {ReadFileSync} readFileSync read file sync method
 * @property {ReaddirSync} readdirSync read dir sync method
 * @property {ReadJsonSync=} readJsonSync read json sync method
 * @property {ReadlinkSync} readlinkSync read link sync method
 * @property {LStatSync=} lstatSync lstat sync method
 * @property {StatSync} statSync stat sync method
 * @property {RealPathSync=} realpathSync real path sync method
 */

/**
 * @typedef {object} ParsedIdentifier
 * @property {string} request request
 * @property {string} query query
 * @property {string} fragment fragment
 * @property {boolean} directory is directory
 * @property {boolean} module is module
 * @property {boolean} file is file
 * @property {boolean} internal is internal
 */

/** @typedef {string | number | boolean | null} JsonPrimitive */
/** @typedef {JsonValue[]} JsonArray */
/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */
/** @typedef {{ [Key in string]?: JsonValue | undefined }} JsonObject */

// eslint-disable-next-line jsdoc/require-property
/** @typedef {object} Context */

/**
 * @typedef {object} BaseResolveRequest
 * @property {string | false} path path
 * @property {Context=} context content
 * @property {string=} descriptionFilePath description file path
 * @property {string=} descriptionFileRoot description file root
 * @property {JsonObject=} descriptionFileData description file data
 * @property {string=} relativePath relative path
 * @property {boolean=} ignoreSymlinks true when need to ignore symlinks, otherwise false
 * @property {boolean=} fullySpecified true when full specified, otherwise false
 * @property {string=} __innerRequest inner request for internal usage
 * @property {string=} __innerRequest_request inner request for internal usage
 * @property {string=} __innerRequest_relativePath inner relative path for internal usage
 */

/** @typedef {BaseResolveRequest &amp; Partial&lt;ParsedIdentifier&gt;} ResolveRequest */

/**
 * String with special formatting
 * @typedef {string} StackEntry
 */

/**
 * @template T
 * @typedef {{ add: (item: T) =&gt; void }} WriteOnlySet
 */

/** @typedef {(request: ResolveRequest) =&gt; void} ResolveContextYield */

/**
 * Resolve context
 * @typedef {object} ResolveContext
 * @property {WriteOnlySet&lt;string&gt;=} contextDependencies directories that was found on file system
 * @property {WriteOnlySet&lt;string&gt;=} fileDependencies files that was found on file system
 * @property {WriteOnlySet&lt;string&gt;=} missingDependencies dependencies that was not found on file system
 * @property {Set&lt;StackEntry&gt;=} stack set of hooks&#039; calls. For instance, `resolve → parsedResolve → describedResolve`,
 * @property {((str: string) =&gt; void)=} log log function
 * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results
 */

/** @typedef {AsyncSeriesBailHook&lt;[ResolveRequest, ResolveContext], ResolveRequest | null&gt;} ResolveStepHook */

/**
 * @typedef {object} KnownHooks
 * @property {SyncHook&lt;[ResolveStepHook, ResolveRequest], void&gt;} resolveStep resolve step hook
 * @property {SyncHook&lt;[ResolveRequest, Error]&gt;} noResolve no resolve hook
 * @property {ResolveStepHook} resolve resolve hook
 * @property {AsyncSeriesHook&lt;[ResolveRequest, ResolveContext]&gt;} result result hook
 */

/**
 * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks
 */

/**
 * @param {string} str input string
 * @returns {string} in camel case
 */
function toCamelCase(str) {
	return str.replace(/-([a-z])/g, (str) =&gt; str.slice(1).toUpperCase());
}

class Resolver {
	/**
	 * @param {ResolveStepHook} hook hook
	 * @param {ResolveRequest} request request
	 * @returns {StackEntry} stack entry
	 */
	static createStackEntry(hook, request) {
		return `${hook.name}: (${request.path}) ${request.request || &quot;&quot;}${
			request.query || &quot;&quot;
		}${request.fragment || &quot;&quot;}${request.directory ? &quot; directory&quot; : &quot;&quot;}${
			request.module ? &quot; module&quot; : &quot;&quot;
		}`;
	}

	/**
	 * @param {FileSystem} fileSystem a filesystem
	 * @param {ResolveOptions} options options
	 */
	constructor(fileSystem, options) {
		this.fileSystem = fileSystem;
		this.options = options;
		/** @type {KnownHooks} */
		this.hooks = {
			resolveStep: new SyncHook([&quot;hook&quot;, &quot;request&quot;], &quot;resolveStep&quot;),
			noResolve: new SyncHook([&quot;request&quot;, &quot;error&quot;], &quot;noResolve&quot;),
			resolve: new AsyncSeriesBailHook(
				[&quot;request&quot;, &quot;resolveContext&quot;],
				&quot;resolve&quot;,
			),
			result: new AsyncSeriesHook([&quot;result&quot;, &quot;resolveContext&quot;], &quot;result&quot;),
		};
	}

	/**
	 * @param {string | ResolveStepHook} name hook name or hook itself
	 * @returns {ResolveStepHook} the hook
	 */
	ensureHook(name) {
		if (typeof name !== &quot;string&quot;) {
			return name;
		}
		name = toCamelCase(name);
		if (name.startsWith(&quot;before&quot;)) {
			return /** @type {ResolveStepHook} */ (
				this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({
					stage: -10,
				})
			);
		}
		if (name.startsWith(&quot;after&quot;)) {
			return /** @type {ResolveStepHook} */ (
				this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({
					stage: 10,
				})
			);
		}
		/** @type {ResolveStepHook} */
		const hook = /** @type {KnownHooks &amp; EnsuredHooks} */ (this.hooks)[name];
		if (!hook) {
			/** @type {KnownHooks &amp; EnsuredHooks} */
			(this.hooks)[name] = new AsyncSeriesBailHook(
				[&quot;request&quot;, &quot;resolveContext&quot;],
				name,
			);

			return /** @type {KnownHooks &amp; EnsuredHooks} */ (this.hooks)[name];
		}
		return hook;
	}

	/**
	 * @param {string | ResolveStepHook} name hook name or hook itself
	 * @returns {ResolveStepHook} the hook
	 */
	getHook(name) {
		if (typeof name !== &quot;string&quot;) {
			return name;
		}
		name = toCamelCase(name);
		if (name.startsWith(&quot;before&quot;)) {
			return /** @type {ResolveStepHook} */ (
				this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({
					stage: -10,
				})
			);
		}
		if (name.startsWith(&quot;after&quot;)) {
			return /** @type {ResolveStepHook} */ (
				this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({
					stage: 10,
				})
			);
		}
		/** @type {ResolveStepHook} */
		const hook = /** @type {KnownHooks &amp; EnsuredHooks} */ (this.hooks)[name];
		if (!hook) {
			throw new Error(`Hook ${name} doesn&#039;t exist`);
		}
		return hook;
	}

	/**
	 * @param {object} context context information object
	 * @param {string} path context path
	 * @param {string} request request string
	 * @returns {string | false} result
	 */
	resolveSync(context, path, request) {
		/** @type {Error | null | undefined} */
		let err;
		/** @type {string | false | undefined} */
		let result;
		let sync = false;
		this.resolve(context, path, request, {}, (_err, r) =&gt; {
			err = _err;
			result = r;
			sync = true;
		});
		if (!sync) {
			throw new Error(
				&quot;Cannot &#039;resolveSync&#039; because the fileSystem is not sync. Use &#039;resolve&#039;!&quot;,
			);
		}
		if (err) throw err;
		if (result === undefined) throw new Error(&quot;No result&quot;);
		return result;
	}

	/**
	 * @param {object} context context information object
	 * @param {string} path context path
	 * @param {string} request request string
	 * @param {ResolveContext} resolveContext resolve context
	 * @param {ResolveCallback} callback callback function
	 * @returns {void}
	 */
	resolve(context, path, request, resolveContext, callback) {
		if (!context || typeof context !== &quot;object&quot;) {
			return callback(new Error(&quot;context argument is not an object&quot;));
		}
		if (typeof path !== &quot;string&quot;) {
			return callback(new Error(&quot;path argument is not a string&quot;));
		}
		if (typeof request !== &quot;string&quot;) {
			return callback(new Error(&quot;request argument is not a string&quot;));
		}
		if (!resolveContext) {
			return callback(new Error(&quot;resolveContext argument is not set&quot;));
		}

		/** @type {ResolveRequest} */
		const obj = {
			context,
			path,
			request,
		};

		/** @type {ResolveContextYield | undefined} */
		let yield_;
		let yieldCalled = false;
		/** @type {ResolveContextYield | undefined} */
		let finishYield;
		if (typeof resolveContext.yield === &quot;function&quot;) {
			const old = resolveContext.yield;
			/**
			 * @param {ResolveRequest} obj object
			 */
			yield_ = (obj) =&gt; {
				old(obj);
				yieldCalled = true;
			};
			/**
			 * @param {ResolveRequest} result result
			 * @returns {void}
			 */
			finishYield = (result) =&gt; {
				if (result) {
					/** @type {ResolveContextYield} */ (yield_)(result);
				}
				callback(null);
			};
		}

		const message = `resolve &#039;${request}&#039; in &#039;${path}&#039;`;

		/**
		 * @param {ResolveRequest} result result
		 * @returns {void}
		 */
		const finishResolved = (result) =&gt;
			callback(
				null,
				result.path === false
					? false
					: `${result.path.replace(/#/g, &quot;\0#&quot;)}${
							result.query ? result.query.replace(/#/g, &quot;\0#&quot;) : &quot;&quot;
						}${result.fragment || &quot;&quot;}`,
				result,
			);

		/**
		 * @param {string[]} log logs
		 * @returns {void}
		 */
		const finishWithoutResolve = (log) =&gt; {
			/**
			 * @type {ErrorWithDetail}
			 */
			const error = new Error(`Can&#039;t ${message}`);
			error.details = log.join(&quot;\n&quot;);
			this.hooks.noResolve.call(obj, error);
			return callback(error);
		};

		if (resolveContext.log) {
			// We need log anyway to capture it in case of an error
			const parentLog = resolveContext.log;
			/** @type {string[]} */
			const log = [];
			return this.doResolve(
				this.hooks.resolve,
				obj,
				message,
				{
					log: (msg) =&gt; {
						parentLog(msg);
						log.push(msg);
					},
					yield: yield_,
					fileDependencies: resolveContext.fileDependencies,
					contextDependencies: resolveContext.contextDependencies,
					missingDependencies: resolveContext.missingDependencies,
					stack: resolveContext.stack,
				},
				(err, result) =&gt; {
					if (err) return callback(err);

					if (yieldCalled || (result &amp;&amp; yield_)) {
						return /** @type {ResolveContextYield} */ (finishYield)(
							/** @type {ResolveRequest} */ (result),
						);
					}

					if (result) return finishResolved(result);

					return finishWithoutResolve(log);
				},
			);
		}
		// Try to resolve assuming there is no error
		// We don&#039;t log stuff in this case
		return this.doResolve(
			this.hooks.resolve,
			obj,
			message,
			{
				log: undefined,
				yield: yield_,
				fileDependencies: resolveContext.fileDependencies,
				contextDependencies: resolveContext.contextDependencies,
				missingDependencies: resolveContext.missingDependencies,
				stack: resolveContext.stack,
			},
			(err, result) =&gt; {
				if (err) return callback(err);

				if (yieldCalled || (result &amp;&amp; yield_)) {
					return /** @type {ResolveContextYield} */ (finishYield)(
						/** @type {ResolveRequest} */ (result),
					);
				}

				if (result) return finishResolved(result);

				// log is missing for the error details
				// so we redo the resolving for the log info
				// this is more expensive to the success case
				// is assumed by default
				/** @type {string[]} */
				const log = [];

				return this.doResolve(
					this.hooks.resolve,
					obj,
					message,
					{
						log: (msg) =&gt; log.push(msg),
						yield: yield_,
						stack: resolveContext.stack,
					},
					(err, result) =&gt; {
						if (err) return callback(err);

						// In a case that there is a race condition and yield will be called
						if (yieldCalled || (result &amp;&amp; yield_)) {
							return /** @type {ResolveContextYield} */ (finishYield)(
								/** @type {ResolveRequest} */ (result),
							);
						}

						return finishWithoutResolve(log);
					},
				);
			},
		);
	}

	/**
	 * @param {ResolveStepHook} hook hook
	 * @param {ResolveRequest} request request
	 * @param {null|string} message string
	 * @param {ResolveContext} resolveContext resolver context
	 * @param {(err?: null|Error, result?: ResolveRequest) =&gt; void} callback callback
	 * @returns {void}
	 */
	doResolve(hook, request, message, resolveContext, callback) {
		const stackEntry = Resolver.createStackEntry(hook, request);

		/** @type {Set&lt;string&gt; | undefined} */
		let newStack;
		if (resolveContext.stack) {
			newStack = new Set(resolveContext.stack);
			if (resolveContext.stack.has(stackEntry)) {
				/**
				 * Prevent recursion
				 * @type {Error &amp; {recursion?: boolean}}
				 */
				const recursionError = new Error(
					`Recursion in resolving\nStack:\n  ${[...newStack].join(&quot;\n  &quot;)}`,
				);
				recursionError.recursion = true;
				if (resolveContext.log) {
					resolveContext.log(&quot;abort resolving because of recursion&quot;);
				}
				return callback(recursionError);
			}
			newStack.add(stackEntry);
		} else {
			// creating a set with new Set([item])
			// allocates a new array that has to be garbage collected
			// this is an EXTREMELY hot path, so let&#039;s avoid it
			newStack = new Set();
			newStack.add(stackEntry);
		}
		this.hooks.resolveStep.call(hook, request);

		if (hook.isUsed()) {
			const innerContext = createInnerContext(
				{
					log: resolveContext.log,
					yield: resolveContext.yield,
					fileDependencies: resolveContext.fileDependencies,
					contextDependencies: resolveContext.contextDependencies,
					missingDependencies: resolveContext.missingDependencies,
					stack: newStack,
				},
				message,
			);
			return hook.callAsync(request, innerContext, (err, result) =&gt; {
				if (err) return callback(err);
				if (result) return callback(null, result);
				callback();
			});
		}
		callback();
	}

	/**
	 * @param {string} identifier identifier
	 * @returns {ParsedIdentifier} parsed identifier
	 */
	parse(identifier) {
		const part = {
			request: &quot;&quot;,
			query: &quot;&quot;,
			fragment: &quot;&quot;,
			module: false,
			directory: false,
			file: false,
			internal: false,
		};

		const parsedIdentifier = parseIdentifier(identifier);

		if (!parsedIdentifier) return part;

		[part.request, part.query, part.fragment] = parsedIdentifier;

		if (part.request.length &gt; 0) {
			part.internal = this.isPrivate(identifier);
			part.module = this.isModule(part.request);
			part.directory = this.isDirectory(part.request);
			if (part.directory) {
				part.request = part.request.slice(0, -1);
			}
		}

		return part;
	}

	/**
	 * @param {string} path path
	 * @returns {boolean} true, if the path is a module
	 */
	isModule(path) {
		return getType(path) === PathType.Normal;
	}

	/**
	 * @param {string} path path
	 * @returns {boolean} true, if the path is private
	 */
	isPrivate(path) {
		return getType(path) === PathType.Internal;
	}

	/**
	 * @param {string} path a path
	 * @returns {boolean} true, if the path is a directory path
	 */
	isDirectory(path) {
		return path.endsWith(&quot;/&quot;);
	}

	/**
	 * @param {string} path path
	 * @param {string} request request
	 * @returns {string} joined path
	 */
	join(path, request) {
		return join(path, request);
	}

	/**
	 * @param {string} path path
	 * @returns {string} normalized path
	 */
	normalize(path) {
		return normalize(path);
	}
}

module.exports = Resolver;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
