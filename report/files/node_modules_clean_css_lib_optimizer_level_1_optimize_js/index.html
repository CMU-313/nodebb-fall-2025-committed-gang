<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/clean-css/lib/optimizer/level-1/optimize.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/clean-css/lib/optimizer/level-1/optimize.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.94</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">692</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.61</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var shortenHex = require(&#039;./shorten-hex&#039;);
var shortenHsl = require(&#039;./shorten-hsl&#039;);
var shortenRgb = require(&#039;./shorten-rgb&#039;);
var sortSelectors = require(&#039;./sort-selectors&#039;);
var tidyRules = require(&#039;./tidy-rules&#039;);
var tidyBlock = require(&#039;./tidy-block&#039;);
var tidyAtRule = require(&#039;./tidy-at-rule&#039;);

var Hack = require(&#039;../hack&#039;);
var removeUnused = require(&#039;../remove-unused&#039;);
var restoreFromOptimizing = require(&#039;../restore-from-optimizing&#039;);
var wrapForOptimizing = require(&#039;../wrap-for-optimizing&#039;).all;

var OptimizationLevel = require(&#039;../../options/optimization-level&#039;).OptimizationLevel;

var Token = require(&#039;../../tokenizer/token&#039;);
var Marker = require(&#039;../../tokenizer/marker&#039;);

var formatPosition = require(&#039;../../utils/format-position&#039;);
var split = require(&#039;../../utils/split&#039;);

var serializeRules = require(&#039;../../writer/one-time&#039;).rules;

var IgnoreProperty = &#039;ignore-property&#039;;

var CHARSET_TOKEN = &#039;@charset&#039;;
var CHARSET_REGEXP = new RegExp(&#039;^&#039; + CHARSET_TOKEN, &#039;i&#039;);

var DEFAULT_ROUNDING_PRECISION = require(&#039;../../options/rounding-precision&#039;).DEFAULT;

var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;
var TIME_VALUE = /^(\-?[\d\.]+)(m?s)$/;

var HEX_VALUE_PATTERN = /[0-9a-f]/i;
var PROPERTY_NAME_PATTERN = /^(?:\-chrome\-|\-[\w\-]+\w|\w[\w\-]+\w|\-\-\S+)$/;
var IMPORT_PREFIX_PATTERN = /^@import/i;
var QUOTED_PATTERN = /^(&#039;.*&#039;|&quot;.*&quot;)$/;
var QUOTED_BUT_SAFE_PATTERN = /^[&#039;&quot;][a-zA-Z][a-zA-Z\d\-_]+[&#039;&quot;]$/;
var URL_PREFIX_PATTERN = /^url\(/i;
var LOCAL_PREFIX_PATTERN = /^local\(/i;
var VARIABLE_NAME_PATTERN = /^--\S+$/;

function isLocal(value){
  return LOCAL_PREFIX_PATTERN.test(value);
}

function isNegative(value) {
  return value &amp;&amp; value[1][0] == &#039;-&#039; &amp;&amp; parseFloat(value[1]) &lt; 0;
}

function isQuoted(value) {
  return QUOTED_PATTERN.test(value);
}

function isUrl(value) {
  return URL_PREFIX_PATTERN.test(value);
}

function normalizeUrl(value) {
  return value
    .replace(URL_PREFIX_PATTERN, &#039;url(&#039;)
    .replace(/\\?\n|\\?\r\n/g, &#039;&#039;);
}

function optimizeBackground(property) {
  var values = property.value;

  if (values.length == 1 &amp;&amp; values[0][1] == &#039;none&#039;) {
    values[0][1] = &#039;0 0&#039;;
  }

  if (values.length == 1 &amp;&amp; values[0][1] == &#039;transparent&#039;) {
    values[0][1] = &#039;0 0&#039;;
  }
}

function optimizeBorderRadius(property) {
  var values = property.value;
  var spliceAt;

  if (values.length == 3 &amp;&amp; values[1][1] == &#039;/&#039; &amp;&amp; values[0][1] == values[2][1]) {
    spliceAt = 1;
  } else if (values.length == 5 &amp;&amp; values[2][1] == &#039;/&#039; &amp;&amp; values[0][1] == values[3][1] &amp;&amp; values[1][1] == values[4][1]) {
    spliceAt = 2;
  } else if (values.length == 7 &amp;&amp; values[3][1] == &#039;/&#039; &amp;&amp; values[0][1] == values[4][1] &amp;&amp; values[1][1] == values[5][1] &amp;&amp; values[2][1] == values[6][1]) {
    spliceAt = 3;
  } else if (values.length == 9 &amp;&amp; values[4][1] == &#039;/&#039; &amp;&amp; values[0][1] == values[5][1] &amp;&amp; values[1][1] == values[6][1] &amp;&amp; values[2][1] == values[7][1] &amp;&amp; values[3][1] == values[8][1]) {
    spliceAt = 4;
  }

  if (spliceAt) {
    property.value.splice(spliceAt);
    property.dirty = true;
  }
}

/**
 * @param {string} name
 * @param {string} value
 * @param {Object} compatibility
 * @return {string}
 */
function optimizeColors(name, value, compatibility) {
  if (!value.match(/#|rgb|hsl/gi)) {
    return shortenHex(value);
  }

  value = value
    .replace(/(rgb|hsl)a?\((\-?\d+),(\-?\d+\%?),(\-?\d+\%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi, function (match, colorFn, p1, p2, p3, alpha) {
      return (parseInt(alpha, 10) &gt;= 1 ? colorFn + &#039;(&#039; + [p1,p2,p3].join(&#039;,&#039;) + &#039;)&#039; : match);
    })
    .replace(/rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/gi, function (match, red, green, blue) {
      return shortenRgb(red, green, blue);
    })
    .replace(/hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi, function (match, hue, saturation, lightness) {
      return shortenHsl(hue, saturation, lightness);
    })
    .replace(/(^|[^=&#039;&quot;])#([0-9a-f]{6})/gi, function (match, prefix, color, at, inputValue) {
      var suffix = inputValue[at + match.length];

      if (suffix &amp;&amp; HEX_VALUE_PATTERN.test(suffix)) {
        return match;
      } else if (color[0] == color[1] &amp;&amp; color[2] == color[3] &amp;&amp; color[4] == color[5]) {
        return (prefix + &#039;#&#039; + color[0] + color[2] + color[4]).toLowerCase();
      } else {
        return (prefix + &#039;#&#039; + color).toLowerCase();
      }
    })
    .replace(/(^|[^=&#039;&quot;])#([0-9a-f]{3})/gi, function (match, prefix, color) {
      return prefix + &#039;#&#039; + color.toLowerCase();
    })
    .replace(/(rgb|rgba|hsl|hsla)\(([^\)]+)\)/gi, function (match, colorFunction, colorDef) {
      var tokens = colorDef.split(&#039;,&#039;);
      var colorFnLowercase = colorFunction &amp;&amp; colorFunction.toLowerCase();
      var applies = (colorFnLowercase == &#039;hsl&#039; &amp;&amp; tokens.length == 3) ||
        (colorFnLowercase == &#039;hsla&#039; &amp;&amp; tokens.length == 4) ||
        (colorFnLowercase == &#039;rgb&#039; &amp;&amp; tokens.length === 3 &amp;&amp; colorDef.indexOf(&#039;%&#039;) &gt; 0) ||
        (colorFnLowercase == &#039;rgba&#039; &amp;&amp; tokens.length == 4 &amp;&amp; colorDef.indexOf(&#039;%&#039;) &gt; 0);

      if (!applies) {
        return match;
      }

      if (tokens[1].indexOf(&#039;%&#039;) == -1) {
        tokens[1] += &#039;%&#039;;
      }

      if (tokens[2].indexOf(&#039;%&#039;) == -1) {
        tokens[2] += &#039;%&#039;;
      }

      return colorFunction + &#039;(&#039; + tokens.join(&#039;,&#039;) + &#039;)&#039;;
    });

  if (compatibility.colors.opacity &amp;&amp; name.indexOf(&#039;background&#039;) == -1) {
    value = value.replace(/(?:rgba|hsla)\(0,0%?,0%?,0\)/g, function (match) {
      if (split(value, &#039;,&#039;).pop().indexOf(&#039;gradient(&#039;) &gt; -1) {
        return match;
      }

      return &#039;transparent&#039;;
    });
  }

  return shortenHex(value);
}

function optimizeFilter(property) {
  if (property.value.length == 1) {
    property.value[0][1] = property.value[0][1].replace(/progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, function (match, filter, suffix) {
      return filter.toLowerCase() + suffix;
    });
  }

  property.value[0][1] = property.value[0][1]
    .replace(/,(\S)/g, &#039;, $1&#039;)
    .replace(/ ?= ?/g, &#039;=&#039;);
}

function optimizeFontWeight(property, atIndex) {
  var value = property.value[atIndex][1];

  if (value == &#039;normal&#039;) {
    value = &#039;400&#039;;
  } else if (value == &#039;bold&#039;) {
    value = &#039;700&#039;;
  }

  property.value[atIndex][1] = value;
}

function optimizeMultipleZeros(property) {
  var values = property.value;
  var spliceAt;

  if (values.length == 4 &amp;&amp; values[0][1] === &#039;0&#039; &amp;&amp; values[1][1] === &#039;0&#039; &amp;&amp; values[2][1] === &#039;0&#039; &amp;&amp; values[3][1] === &#039;0&#039;) {
    if (property.name.indexOf(&#039;box-shadow&#039;) &gt; -1) {
      spliceAt = 2;
    } else {
      spliceAt = 1;
    }
  }

  if (spliceAt) {
    property.value.splice(spliceAt);
    property.dirty = true;
  }
}

function optimizeOutline(property) {
  var values = property.value;

  if (values.length == 1 &amp;&amp; values[0][1] == &#039;none&#039;) {
    values[0][1] = &#039;0&#039;;
  }
}

function optimizePixelLengths(_, value, compatibility) {
  if (!WHOLE_PIXEL_VALUE.test(value)) {
    return value;
  }

  return value.replace(WHOLE_PIXEL_VALUE, function (match, val) {
    var newValue;
    var intVal = parseInt(val);

    if (intVal === 0) {
      return match;
    }

    if (compatibility.properties.shorterLengthUnits &amp;&amp; compatibility.units.pt &amp;&amp; intVal * 3 % 4 === 0) {
      newValue = intVal * 3 / 4 + &#039;pt&#039;;
    }

    if (compatibility.properties.shorterLengthUnits &amp;&amp; compatibility.units.pc &amp;&amp; intVal % 16 === 0) {
      newValue = intVal / 16 + &#039;pc&#039;;
    }

    if (compatibility.properties.shorterLengthUnits &amp;&amp; compatibility.units.in &amp;&amp; intVal % 96 === 0) {
      newValue = intVal / 96 + &#039;in&#039;;
    }

    if (newValue) {
      newValue = match.substring(0, match.indexOf(val)) + newValue;
    }

    return newValue &amp;&amp; newValue.length &lt; match.length ? newValue : match;
  });
}

function optimizePrecision(_, value, precisionOptions) {
  if (!precisionOptions.enabled || value.indexOf(&#039;.&#039;) === -1) {
    return value;
  }

  return value
    .replace(precisionOptions.decimalPointMatcher, &#039;$1$2$3&#039;)
    .replace(precisionOptions.zeroMatcher, function (match, integerPart, fractionPart, unit) {
      var multiplier = precisionOptions.units[unit].multiplier;
      var parsedInteger = parseInt(integerPart);
      var integer = isNaN(parsedInteger) ? 0 : parsedInteger;
      var fraction = parseFloat(fractionPart);

      return Math.round((integer + fraction) * multiplier) / multiplier + unit;
    });
}

function optimizeTimeUnits(_, value) {
  if (!TIME_VALUE.test(value))
    return value;

  return value.replace(TIME_VALUE, function (match, val, unit) {
    var newValue;

    if (unit == &#039;ms&#039;) {
      newValue = parseInt(val) / 1000 + &#039;s&#039;;
    } else if (unit == &#039;s&#039;) {
      newValue = parseFloat(val) * 1000 + &#039;ms&#039;;
    }

    return newValue.length &lt; match.length ? newValue : match;
  });
}

function optimizeUnits(name, value, unitsRegexp) {
  if (/^(?:\-moz\-calc|\-webkit\-calc|calc|rgb|hsl|rgba|hsla)\(/.test(value)) {
    return value;
  }

  if (name == &#039;flex&#039; || name == &#039;-ms-flex&#039; || name == &#039;-webkit-flex&#039; || name == &#039;flex-basis&#039; || name == &#039;-webkit-flex-basis&#039;) {
    return value;
  }

  if (value.indexOf(&#039;%&#039;) &gt; 0 &amp;&amp; (name == &#039;height&#039; || name == &#039;max-height&#039; || name == &#039;width&#039; || name == &#039;max-width&#039;)) {
    return value;
  }

  return value
    .replace(unitsRegexp, &#039;$1&#039; + &#039;0&#039; + &#039;$2&#039;)
    .replace(unitsRegexp, &#039;$1&#039; + &#039;0&#039; + &#039;$2&#039;);
}

function optimizeWhitespace(name, value) {
  if (name.indexOf(&#039;filter&#039;) &gt; -1 || value.indexOf(&#039; &#039;) == -1 || value.indexOf(&#039;expression&#039;) === 0) {
    return value;
  }

  if (value.indexOf(Marker.SINGLE_QUOTE) &gt; -1 || value.indexOf(Marker.DOUBLE_QUOTE) &gt; -1) {
    return value;
  }

  value = value.replace(/\s+/g, &#039; &#039;);

  if (value.indexOf(&#039;calc&#039;) &gt; -1) {
    value = value.replace(/\) ?\/ ?/g, &#039;)/ &#039;);
  }

  return value
    .replace(/(\(;?)\s+/g, &#039;$1&#039;)
    .replace(/\s+(;?\))/g, &#039;$1&#039;)
    .replace(/, /g, &#039;,&#039;);
}

function optimizeZeroDegUnit(_, value) {
  if (value.indexOf(&#039;0deg&#039;) == -1) {
    return value;
  }

  return value.replace(/\(0deg\)/g, &#039;(0)&#039;);
}

function optimizeZeroUnits(name, value) {
  if (value.indexOf(&#039;0&#039;) == -1) {
    return value;
  }

  if (value.indexOf(&#039;-&#039;) &gt; -1) {
    value = value
      .replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, &#039;$10$2&#039;)
      .replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, &#039;$10$2&#039;);
  }

  return value
    .replace(/(^|\s)0+([1-9])/g, &#039;$1$2&#039;)
    .replace(/(^|\D)\.0+(\D|$)/g, &#039;$10$2&#039;)
    .replace(/(^|\D)\.0+(\D|$)/g, &#039;$10$2&#039;)
    .replace(/\.([1-9]*)0+(\D|$)/g, function (match, nonZeroPart, suffix) {
      return (nonZeroPart.length &gt; 0 ? &#039;.&#039; : &#039;&#039;) + nonZeroPart + suffix;
    })
    .replace(/(^|\D)0\.(\d)/g, &#039;$1.$2&#039;);
}

function removeQuotes(name, value) {
  if (name == &#039;content&#039; || name.indexOf(&#039;font-variation-settings&#039;) &gt; -1 || name.indexOf(&#039;font-feature-settings&#039;) &gt; -1 || name == &#039;grid&#039; || name.indexOf(&#039;grid-&#039;) &gt; -1) {
    return value;
  }

  return QUOTED_BUT_SAFE_PATTERN.test(value) ?
    value.substring(1, value.length - 1) :
    value;
}

function removeUrlQuotes(value) {
  return /^url\([&#039;&quot;].+[&#039;&quot;]\)$/.test(value) &amp;&amp; !/^url\([&#039;&quot;].*[\*\s\(\)&#039;&quot;].*[&#039;&quot;]\)$/.test(value) &amp;&amp; !/^url\([&#039;&quot;]data:[^;]+;charset/.test(value) ?
    value.replace(/[&quot;&#039;]/g, &#039;&#039;) :
    value;
}

function transformValue(propertyName, propertyValue, rule, transformCallback) {
  var selector = serializeRules(rule);
  var transformedValue = transformCallback(propertyName, propertyValue, selector);

  if (transformedValue === undefined) {
    return propertyValue;
  } else if (transformedValue === false) {
    return IgnoreProperty;
  } else {
    return transformedValue;
  }
}

//

function optimizeBody(rule, properties, context) {
  var options = context.options;
  var levelOptions = options.level[OptimizationLevel.One];
  var property, name, type, value;
  var valueIsUrl;
  var propertyToken;
  var _properties = wrapForOptimizing(properties, true);

  propertyLoop:
  for (var i = 0, l = _properties.length; i &lt; l; i++) {
    property = _properties[i];
    name = property.name;

    if (!PROPERTY_NAME_PATTERN.test(name)) {
      propertyToken = property.all[property.position];
      context.warnings.push(&#039;Invalid property name \&#039;&#039; + name + &#039;\&#039; at &#039; + formatPosition(propertyToken[1][2][0]) + &#039;. Ignoring.&#039;);
      property.unused = true;
    }

    if (property.value.length === 0) {
      propertyToken = property.all[property.position];
      context.warnings.push(&#039;Empty property \&#039;&#039; + name + &#039;\&#039; at &#039; + formatPosition(propertyToken[1][2][0]) + &#039;. Ignoring.&#039;);
      property.unused = true;
    }

    if (property.hack &amp;&amp; (
        (property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) &amp;&amp; !options.compatibility.properties.iePrefixHack ||
        property.hack[0] == Hack.BACKSLASH &amp;&amp; !options.compatibility.properties.ieSuffixHack ||
        property.hack[0] == Hack.BANG &amp;&amp; !options.compatibility.properties.ieBangHack)) {
      property.unused = true;
    }

    if (levelOptions.removeNegativePaddings &amp;&amp; name.indexOf(&#039;padding&#039;) === 0 &amp;&amp; (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {
      property.unused = true;
    }

    if (!options.compatibility.properties.ieFilters &amp;&amp; isLegacyFilter(property)) {
      property.unused = true;
    }

    if (property.unused) {
      continue;
    }

    if (property.block) {
      optimizeBody(rule, property.value[0][1], context);
      continue;
    }

    if (VARIABLE_NAME_PATTERN.test(name)) {
      continue;
    }

    for (var j = 0, m = property.value.length; j &lt; m; j++) {
      type = property.value[j][0];
      value = property.value[j][1];
      valueIsUrl = isUrl(value);

      if (type == Token.PROPERTY_BLOCK) {
        property.unused = true;
        context.warnings.push(&#039;Invalid value token at &#039; + formatPosition(value[0][1][2][0]) + &#039;. Ignoring.&#039;);
        break;
      }

      if (valueIsUrl &amp;&amp; !context.validator.isUrl(value)) {
        property.unused = true;
        context.warnings.push(&#039;Broken URL \&#039;&#039; + value + &#039;\&#039; at &#039; + formatPosition(property.value[j][2][0]) + &#039;. Ignoring.&#039;);
        break;
      }

      if (valueIsUrl) {
        value = levelOptions.normalizeUrls ?
          normalizeUrl(value) :
          value;
        value = !options.compatibility.properties.urlQuotes ?
          removeUrlQuotes(value) :
          value;
      } else if (isQuoted(value) || isLocal(value)) {
        value = levelOptions.removeQuotes ?
          removeQuotes(name, value) :
          value;
      } else {
        value = levelOptions.removeWhitespace ?
          optimizeWhitespace(name, value) :
          value;
        value = optimizePrecision(name, value, options.precision);
        value = optimizePixelLengths(name, value, options.compatibility);
        value = levelOptions.replaceTimeUnits ?
          optimizeTimeUnits(name, value) :
          value;
        value = levelOptions.replaceZeroUnits ?
          optimizeZeroUnits(name, value) :
          value;

        if (options.compatibility.properties.zeroUnits) {
          value = optimizeZeroDegUnit(name, value);
          value = optimizeUnits(name, value, options.unitsRegexp);
        }

        if (options.compatibility.properties.colors) {
          value = optimizeColors(name, value, options.compatibility);
        }
      }

      value = transformValue(name, value, rule, levelOptions.transform);

      if (value === IgnoreProperty) {
        property.unused = true;
        continue propertyLoop;
      }

      property.value[j][1] = value;
    }

    if (levelOptions.replaceMultipleZeros) {
      optimizeMultipleZeros(property);
    }

    if (name == &#039;background&#039; &amp;&amp; levelOptions.optimizeBackground) {
      optimizeBackground(property);
    } else if (name.indexOf(&#039;border&#039;) === 0 &amp;&amp; name.indexOf(&#039;radius&#039;) &gt; 0 &amp;&amp; levelOptions.optimizeBorderRadius) {
      optimizeBorderRadius(property);
    } else if (name == &#039;filter&#039;&amp;&amp; levelOptions.optimizeFilter &amp;&amp; options.compatibility.properties.ieFilters) {
      optimizeFilter(property);
    } else if (name == &#039;font-weight&#039; &amp;&amp; levelOptions.optimizeFontWeight) {
      optimizeFontWeight(property, 0);
    } else if (name == &#039;outline&#039; &amp;&amp; levelOptions.optimizeOutline) {
      optimizeOutline(property);
    }
  }

  restoreFromOptimizing(_properties);
  removeUnused(_properties);
  removeComments(properties, options);
}

function removeComments(tokens, options) {
  var token;
  var i;

  for (i = 0; i &lt; tokens.length; i++) {
    token = tokens[i];

    if (token[0] != Token.COMMENT) {
      continue;
    }

    optimizeComment(token, options);

    if (token[1].length === 0) {
      tokens.splice(i, 1);
      i--;
    }
  }
}

function optimizeComment(token, options) {
  if (token[1][2] == Marker.EXCLAMATION &amp;&amp; (options.level[OptimizationLevel.One].specialComments == &#039;all&#039; || options.commentsKept &lt; options.level[OptimizationLevel.One].specialComments)) {
    options.commentsKept++;
    return;
  }

  token[1] = [];
}

function cleanupCharsets(tokens) {
  var hasCharset = false;

  for (var i = 0, l = tokens.length; i &lt; l; i++) {
    var token = tokens[i];

    if (token[0] != Token.AT_RULE)
      continue;

    if (!CHARSET_REGEXP.test(token[1]))
      continue;

    if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {
      tokens.splice(i, 1);
      i--;
      l--;
    } else {
      hasCharset = true;
      tokens.splice(i, 1);
      tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);
    }
  }
}

function buildUnitRegexp(options) {
  var units = [&#039;px&#039;, &#039;em&#039;, &#039;ex&#039;, &#039;cm&#039;, &#039;mm&#039;, &#039;in&#039;, &#039;pt&#039;, &#039;pc&#039;, &#039;%&#039;];
  var otherUnits = [&#039;ch&#039;, &#039;rem&#039;, &#039;vh&#039;, &#039;vm&#039;, &#039;vmax&#039;, &#039;vmin&#039;, &#039;vw&#039;];

  otherUnits.forEach(function (unit) {
    if (options.compatibility.units[unit]) {
      units.push(unit);
    }
  });

  return new RegExp(&#039;(^|\\s|\\(|,)0(?:&#039; + units.join(&#039;|&#039;) + &#039;)(\\W|$)&#039;, &#039;g&#039;);
}

function buildPrecisionOptions(roundingPrecision) {
  var precisionOptions = {
    matcher: null,
    units: {},
  };
  var optimizable = [];
  var unit;
  var value;

  for (unit in roundingPrecision) {
    value = roundingPrecision[unit];

    if (value != DEFAULT_ROUNDING_PRECISION) {
      precisionOptions.units[unit] = {};
      precisionOptions.units[unit].value = value;
      precisionOptions.units[unit].multiplier = Math.pow(10, value);

      optimizable.push(unit);
    }
  }

  if (optimizable.length &gt; 0) {
    precisionOptions.enabled = true;
    precisionOptions.decimalPointMatcher = new RegExp(&#039;(\\d)\\.($|&#039; + optimizable.join(&#039;|&#039;) + &#039;)($|\\W)&#039;, &#039;g&#039;);
    precisionOptions.zeroMatcher = new RegExp(&#039;(\\d*)(\\.\\d+)(&#039; + optimizable.join(&#039;|&#039;) + &#039;)&#039;, &#039;g&#039;);
  }

  return precisionOptions;
}

function isImport(token) {
  return IMPORT_PREFIX_PATTERN.test(token[1]);
}

function isLegacyFilter(property) {
  var value;

  if (property.name == &#039;filter&#039; || property.name == &#039;-ms-filter&#039;) {
    value = property.value[0][1];

    return value.indexOf(&#039;progid&#039;) &gt; -1 ||
      value.indexOf(&#039;alpha&#039;) === 0 ||
      value.indexOf(&#039;chroma&#039;) === 0;
  } else {
    return false;
  }
}

function level1Optimize(tokens, context) {
  var options = context.options;
  var levelOptions = options.level[OptimizationLevel.One];
  var ie7Hack = options.compatibility.selectors.ie7Hack;
  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
  var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
  var format = options.format;
  var mayHaveCharset = false;
  var afterRules = false;

  options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);
  options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);
  options.commentsKept = options.commentsKept || 0;

  for (var i = 0, l = tokens.length; i &lt; l; i++) {
    var token = tokens[i];

    switch (token[0]) {
      case Token.AT_RULE:
        token[1] = isImport(token) &amp;&amp; afterRules ? &#039;&#039; : token[1];
        token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];
        mayHaveCharset = true;
        break;
      case Token.AT_RULE_BLOCK:
        optimizeBody(token[1], token[2], context);
        afterRules = true;
        break;
      case Token.NESTED_BLOCK:
        token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];
        level1Optimize(token[2], context);
        afterRules = true;
        break;
      case Token.COMMENT:
        optimizeComment(token, options);
        break;
      case Token.RULE:
        token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];
        token[1] = token[1].length &gt; 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];
        optimizeBody(token[1], token[2], context);
        afterRules = true;
        break;
    }

    if (token[0] == Token.COMMENT &amp;&amp; token[1].length === 0 || levelOptions.removeEmpty &amp;&amp; (token[1].length === 0 || (token[2] &amp;&amp; token[2].length === 0))) {
      tokens.splice(i, 1);
      i--;
      l--;
    }
  }

  if (levelOptions.cleanupCharsets &amp;&amp; mayHaveCharset) {
    cleanupCharsets(tokens);
  }

  return tokens;
}

module.exports = level1Optimize;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
