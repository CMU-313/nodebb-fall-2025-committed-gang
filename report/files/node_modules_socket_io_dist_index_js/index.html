<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/socket.io/dist/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/socket.io/dist/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">805</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">79.99</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, &quot;default&quot;, { enumerable: true, value: v });
}) : function(o, v) {
    o[&quot;default&quot;] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== &quot;default&quot; &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.Namespace = exports.Socket = exports.Server = void 0;
const http = require(&quot;http&quot;);
const fs_1 = require(&quot;fs&quot;);
const zlib_1 = require(&quot;zlib&quot;);
const accepts = require(&quot;accepts&quot;);
const stream_1 = require(&quot;stream&quot;);
const path = require(&quot;path&quot;);
const engine_io_1 = require(&quot;engine.io&quot;);
const client_1 = require(&quot;./client&quot;);
const events_1 = require(&quot;events&quot;);
const namespace_1 = require(&quot;./namespace&quot;);
Object.defineProperty(exports, &quot;Namespace&quot;, { enumerable: true, get: function () { return namespace_1.Namespace; } });
const parent_namespace_1 = require(&quot;./parent-namespace&quot;);
const socket_io_adapter_1 = require(&quot;socket.io-adapter&quot;);
const parser = __importStar(require(&quot;socket.io-parser&quot;));
const debug_1 = __importDefault(require(&quot;debug&quot;));
const socket_1 = require(&quot;./socket&quot;);
Object.defineProperty(exports, &quot;Socket&quot;, { enumerable: true, get: function () { return socket_1.Socket; } });
const typed_events_1 = require(&quot;./typed-events&quot;);
const uws_1 = require(&quot;./uws&quot;);
const cors_1 = __importDefault(require(&quot;cors&quot;));
const debug = (0, debug_1.default)(&quot;socket.io:server&quot;);
const clientVersion = require(&quot;../package.json&quot;).version;
const dotMapRegex = /\.map/;
/**
 * Represents a Socket.IO server.
 *
 * @example
 * import { Server } from &quot;socket.io&quot;;
 *
 * const io = new Server();
 *
 * io.on(&quot;connection&quot;, (socket) =&gt; {
 *   console.log(`socket ${socket.id} connected`);
 *
 *   // send an event to the client
 *   socket.emit(&quot;foo&quot;, &quot;bar&quot;);
 *
 *   socket.on(&quot;foobar&quot;, () =&gt; {
 *     // an event was received from the client
 *   });
 *
 *   // upon disconnection
 *   socket.on(&quot;disconnect&quot;, (reason) =&gt; {
 *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
 *   });
 * });
 *
 * io.listen(3000);
 */
class Server extends typed_events_1.StrictEventEmitter {
    constructor(srv, opts = {}) {
        super();
        /**
         * @private
         */
        this._nsps = new Map();
        this.parentNsps = new Map();
        /**
         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular
         * expression.
         *
         * @private
         */
        this.parentNamespacesFromRegExp = new Map();
        if (&quot;object&quot; === typeof srv &amp;&amp;
            srv instanceof Object &amp;&amp;
            !srv.listen) {
            opts = srv;
            srv = undefined;
        }
        this.path(opts.path || &quot;/socket.io&quot;);
        this.connectTimeout(opts.connectTimeout || 45000);
        this.serveClient(false !== opts.serveClient);
        this._parser = opts.parser || parser;
        this.encoder = new this._parser.Encoder();
        this.opts = opts;
        if (opts.connectionStateRecovery) {
            opts.connectionStateRecovery = Object.assign({
                maxDisconnectionDuration: 2 * 60 * 1000,
                skipMiddlewares: true,
            }, opts.connectionStateRecovery);
            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
        }
        else {
            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
        }
        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
        this.sockets = this.of(&quot;/&quot;);
        if (srv || typeof srv == &quot;number&quot;)
            this.attach(srv);
        if (this.opts.cors) {
            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
        }
    }
    get _opts() {
        return this.opts;
    }
    serveClient(v) {
        if (!arguments.length)
            return this._serveClient;
        this._serveClient = v;
        return this;
    }
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */
    _checkNamespace(name, auth, fn) {
        if (this.parentNsps.size === 0)
            return fn(false);
        const keysIterator = this.parentNsps.keys();
        const run = () =&gt; {
            const nextFn = keysIterator.next();
            if (nextFn.done) {
                return fn(false);
            }
            nextFn.value(name, auth, (err, allow) =&gt; {
                if (err || !allow) {
                    return run();
                }
                if (this._nsps.has(name)) {
                    // the namespace was created in the meantime
                    debug(&quot;dynamic namespace %s already exists&quot;, name);
                    return fn(this._nsps.get(name));
                }
                const namespace = this.parentNsps.get(nextFn.value).createChild(name);
                debug(&quot;dynamic namespace %s was created&quot;, name);
                fn(namespace);
            });
        };
        run();
    }
    path(v) {
        if (!arguments.length)
            return this._path;
        this._path = v.replace(/\/$/, &quot;&quot;);
        const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, &quot;\\$&amp;&quot;);
        this.clientPathRegex = new RegExp(&quot;^&quot; +
            escapedPath +
            &quot;/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)&quot;);
        return this;
    }
    connectTimeout(v) {
        if (v === undefined)
            return this._connectTimeout;
        this._connectTimeout = v;
        return this;
    }
    adapter(v) {
        if (!arguments.length)
            return this._adapter;
        this._adapter = v;
        for (const nsp of this._nsps.values()) {
            nsp._initAdapter();
        }
        return this;
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    listen(srv, opts = {}) {
        return this.attach(srv, opts);
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    attach(srv, opts = {}) {
        if (&quot;function&quot; == typeof srv) {
            const msg = &quot;You are trying to attach socket.io to an express &quot; +
                &quot;request handler function. Please pass a http.Server instance.&quot;;
            throw new Error(msg);
        }
        // handle a port as a string
        if (Number(srv) == srv) {
            srv = Number(srv);
        }
        if (&quot;number&quot; == typeof srv) {
            debug(&quot;creating http server and binding to %d&quot;, srv);
            const port = srv;
            srv = http.createServer((req, res) =&gt; {
                res.writeHead(404);
                res.end();
            });
            srv.listen(port);
        }
        // merge the options passed to the Socket.IO server
        Object.assign(opts, this.opts);
        // set engine.io path to `/socket.io`
        opts.path = opts.path || this._path;
        this.initEngine(srv, opts);
        return this;
    }
    attachApp(app /*: TemplatedApp */, opts = {}) {
        // merge the options passed to the Socket.IO server
        Object.assign(opts, this.opts);
        // set engine.io path to `/socket.io`
        opts.path = opts.path || this._path;
        // initialize engine
        debug(&quot;creating uWebSockets.js-based engine with opts %j&quot;, opts);
        const engine = new engine_io_1.uServer(opts);
        engine.attach(app, opts);
        // bind to engine events
        this.bind(engine);
        if (this._serveClient) {
            // attach static file serving
            app.get(`${this._path}/*`, (res, req) =&gt; {
                if (!this.clientPathRegex.test(req.getUrl())) {
                    req.setYield(true);
                    return;
                }
                const filename = req
                    .getUrl()
                    .replace(this._path, &quot;&quot;)
                    .replace(/\?.*$/, &quot;&quot;)
                    .replace(/^\//, &quot;&quot;);
                const isMap = dotMapRegex.test(filename);
                const type = isMap ? &quot;map&quot; : &quot;source&quot;;
                // Per the standard, ETags must be quoted:
                // https://tools.ietf.org/html/rfc7232#section-2.3
                const expectedEtag = &#039;&quot;&#039; + clientVersion + &#039;&quot;&#039;;
                const weakEtag = &quot;W/&quot; + expectedEtag;
                const etag = req.getHeader(&quot;if-none-match&quot;);
                if (etag) {
                    if (expectedEtag === etag || weakEtag === etag) {
                        debug(&quot;serve client %s 304&quot;, type);
                        res.writeStatus(&quot;304 Not Modified&quot;);
                        res.end();
                        return;
                    }
                }
                debug(&quot;serve client %s&quot;, type);
                res.writeHeader(&quot;cache-control&quot;, &quot;public, max-age=0&quot;);
                res.writeHeader(&quot;content-type&quot;, &quot;application/&quot; + (isMap ? &quot;json&quot; : &quot;javascript&quot;) + &quot;; charset=utf-8&quot;);
                res.writeHeader(&quot;etag&quot;, expectedEtag);
                const filepath = path.join(__dirname, &quot;../client-dist/&quot;, filename);
                (0, uws_1.serveFile)(res, filepath);
            });
        }
        (0, uws_1.patchAdapter)(app);
    }
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */
    initEngine(srv, opts) {
        // initialize engine
        debug(&quot;creating engine.io instance with opts %j&quot;, opts);
        this.eio = (0, engine_io_1.attach)(srv, opts);
        // attach static file serving
        if (this._serveClient)
            this.attachServe(srv);
        // Export http server
        this.httpServer = srv;
        // bind to engine events
        this.bind(this.eio);
    }
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */
    attachServe(srv) {
        debug(&quot;attaching client serving req handler&quot;);
        const evs = srv.listeners(&quot;request&quot;).slice(0);
        srv.removeAllListeners(&quot;request&quot;);
        srv.on(&quot;request&quot;, (req, res) =&gt; {
            if (this.clientPathRegex.test(req.url)) {
                if (this._corsMiddleware) {
                    this._corsMiddleware(req, res, () =&gt; {
                        this.serve(req, res);
                    });
                }
                else {
                    this.serve(req, res);
                }
            }
            else {
                for (let i = 0; i &lt; evs.length; i++) {
                    evs[i].call(srv, req, res);
                }
            }
        });
    }
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */
    serve(req, res) {
        const filename = req.url.replace(this._path, &quot;&quot;).replace(/\?.*$/, &quot;&quot;);
        const isMap = dotMapRegex.test(filename);
        const type = isMap ? &quot;map&quot; : &quot;source&quot;;
        // Per the standard, ETags must be quoted:
        // https://tools.ietf.org/html/rfc7232#section-2.3
        const expectedEtag = &#039;&quot;&#039; + clientVersion + &#039;&quot;&#039;;
        const weakEtag = &quot;W/&quot; + expectedEtag;
        const etag = req.headers[&quot;if-none-match&quot;];
        if (etag) {
            if (expectedEtag === etag || weakEtag === etag) {
                debug(&quot;serve client %s 304&quot;, type);
                res.writeHead(304);
                res.end();
                return;
            }
        }
        debug(&quot;serve client %s&quot;, type);
        res.setHeader(&quot;Cache-Control&quot;, &quot;public, max-age=0&quot;);
        res.setHeader(&quot;Content-Type&quot;, &quot;application/&quot; + (isMap ? &quot;json&quot; : &quot;javascript&quot;) + &quot;; charset=utf-8&quot;);
        res.setHeader(&quot;ETag&quot;, expectedEtag);
        Server.sendFile(filename, req, res);
    }
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */
    static sendFile(filename, req, res) {
        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, &quot;../client-dist/&quot;, filename));
        const encoding = accepts(req).encodings([&quot;br&quot;, &quot;gzip&quot;, &quot;deflate&quot;]);
        const onError = (err) =&gt; {
            if (err) {
                res.end();
            }
        };
        switch (encoding) {
            case &quot;br&quot;:
                res.writeHead(200, { &quot;content-encoding&quot;: &quot;br&quot; });
                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
                break;
            case &quot;gzip&quot;:
                res.writeHead(200, { &quot;content-encoding&quot;: &quot;gzip&quot; });
                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
                break;
            case &quot;deflate&quot;:
                res.writeHead(200, { &quot;content-encoding&quot;: &quot;deflate&quot; });
                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
                break;
            default:
                res.writeHead(200);
                (0, stream_1.pipeline)(readStream, res, onError);
        }
    }
    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param engine engine.io (or compatible) server
     * @return self
     */
    bind(engine) {
        // TODO apply strict types to the engine: &quot;connection&quot; event, `close()` and a method to serve static content
        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server
        this.engine = engine;
        this.engine.on(&quot;connection&quot;, this.onconnection.bind(this));
        return this;
    }
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */
    onconnection(conn) {
        debug(&quot;incoming connection with id %s&quot;, conn.id);
        const client = new client_1.Client(this, conn);
        if (conn.protocol === 3) {
            // @ts-ignore
            client.connect(&quot;/&quot;);
        }
        return this;
    }
    /**
     * Looks up a namespace.
     *
     * @example
     * // with a simple string
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // with a regex
     * const dynamicNsp = io.of(/^\/dynamic-\d+$/).on(&quot;connection&quot;, (socket) =&gt; {
     *   const namespace = socket.nsp; // newNamespace.name === &quot;/dynamic-101&quot;
     *
     *   // broadcast to all clients in the given sub-namespace
     *   namespace.emit(&quot;hello&quot;);
     * });
     *
     * @param name - nsp name
     * @param fn optional, nsp `connection` ev handler
     */
    of(name, fn) {
        if (typeof name === &quot;function&quot; || name instanceof RegExp) {
            const parentNsp = new parent_namespace_1.ParentNamespace(this);
            debug(&quot;initializing parent namespace %s&quot;, parentNsp.name);
            if (typeof name === &quot;function&quot;) {
                this.parentNsps.set(name, parentNsp);
            }
            else {
                this.parentNsps.set((nsp, conn, next) =&gt; next(null, name.test(nsp)), parentNsp);
                this.parentNamespacesFromRegExp.set(name, parentNsp);
            }
            if (fn) {
                // @ts-ignore
                parentNsp.on(&quot;connect&quot;, fn);
            }
            return parentNsp;
        }
        if (String(name)[0] !== &quot;/&quot;)
            name = &quot;/&quot; + name;
        let nsp = this._nsps.get(name);
        if (!nsp) {
            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {
                if (regex.test(name)) {
                    debug(&quot;attaching namespace %s to parent namespace %s&quot;, name, regex);
                    return parentNamespace.createChild(name);
                }
            }
            debug(&quot;initializing namespace %s&quot;, name);
            nsp = new namespace_1.Namespace(this, name);
            this._nsps.set(name, nsp);
            if (name !== &quot;/&quot;) {
                // @ts-ignore
                this.sockets.emitReserved(&quot;new_namespace&quot;, nsp);
            }
        }
        if (fn)
            nsp.on(&quot;connect&quot;, fn);
        return nsp;
    }
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     */
    async close(fn) {
        await Promise.allSettled([...this._nsps.values()].map(async (nsp) =&gt; {
            nsp.sockets.forEach((socket) =&gt; {
                socket._onclose(&quot;server shutting down&quot;);
            });
            await nsp.adapter.close();
        }));
        this.engine.close();
        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server
        (0, uws_1.restoreAdapter)();
        if (this.httpServer) {
            this.httpServer.close(fn);
        }
        else {
            fn &amp;&amp; fn();
        }
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * io.use((socket, next) =&gt; {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn) {
        this.sockets.use(fn);
        return this;
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the “foo” event will be broadcast to all connected clients in the “room-101” room
     * io.to(&quot;room-101&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to([&quot;room-101&quot;, &quot;room-102&quot;]).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with multiple chained calls
     * io.to(&quot;room-101&quot;).to(&quot;room-102&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        return this.sockets.to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the &quot;room-101&quot; room
     * io.in(&quot;room-101&quot;).disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return this.sockets.in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the &quot;foo&quot; event will be broadcast to all connected clients, except the ones that are in the &quot;room-101&quot; room
     * io.except(&quot;room-101&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with an array of rooms
     * io.except([&quot;room-101&quot;, &quot;room-102&quot;]).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with multiple chained calls
     * io.except(&quot;room-101&quot;).except(&quot;room-102&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        return this.sockets.except(room);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * io.send(&quot;hello&quot;);
     *
     * // this is equivalent to
     * io.emit(&quot;message&quot;, &quot;hello&quot;);
     *
     * @return self
     */
    send(...args) {
        // This type-cast is needed because EmitEvents likely doesn&#039;t have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.sockets.emit(&quot;message&quot;, ...args);
        return this;
    }
    /**
     * Sends a `message` event to all clients. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
        // This type-cast is needed because EmitEvents likely doesn&#039;t have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.sockets.emit(&quot;message&quot;, ...args);
        return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * io.serverSideEmit(&quot;hello&quot;, &quot;world&quot;);
     *
     * io.on(&quot;hello&quot;, (arg1) =&gt; {
     *   console.log(arg1); // prints &quot;world&quot;
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * io.serverSideEmit(&quot;ping&quot;, (err, responses) =&gt; {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * io.on(&quot;ping&quot;, (cb) =&gt; {
     *   cb(&quot;pong&quot;);
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(ev, ...args) {
        return this.sockets.serverSideEmit(ev, ...args);
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * try {
     *   const responses = await io.serverSideEmitWithAck(&quot;ping&quot;);
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck(ev, ...args) {
        return this.sockets.serverSideEmitWithAck(ev, ...args);
    }
    /**
     * Gets a list of socket ids.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link Server#fetchSockets} instead.
     */
    allSockets() {
        return this.sockets.allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit(&quot;hello&quot;);
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    compress(compress) {
        return this.sockets.compress(compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit(&quot;hello&quot;); // the clients may or may not receive it
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get volatile() {
        return this.sockets.volatile;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the “foo” event will be broadcast to all connected clients on this node
     * io.local.emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        return this.sockets.local;
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * io.timeout(1000).emit(&quot;some-event&quot;, (err, responses) =&gt; {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        return this.sockets.timeout(timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the &quot;room1&quot; room
     * const sockets = await io.in(&quot;room1&quot;).fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit(&quot;hello&quot;);
     *   socket.join(&quot;room1&quot;);
     *   socket.leave(&quot;room2&quot;);
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
        return this.sockets.fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the &quot;room1&quot; room
     * io.socketsJoin(&quot;room1&quot;);
     *
     * // make all socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms
     * io.in(&quot;room1&quot;).socketsJoin([&quot;room2&quot;, &quot;room3&quot;]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
        return this.sockets.socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the &quot;room1&quot; room
     * io.socketsLeave(&quot;room1&quot;);
     *
     * // make all socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms
     * io.in(&quot;room1&quot;).socketsLeave([&quot;room2&quot;, &quot;room3&quot;]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
        return this.sockets.socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the &quot;room1&quot; room disconnect and close the underlying connections
     * io.in(&quot;room1&quot;).disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
        return this.sockets.disconnectSockets(close);
    }
}
exports.Server = Server;
/**
 * Expose main namespace (/).
 */
const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
    return typeof events_1.EventEmitter.prototype[key] === &quot;function&quot;;
});
emitterMethods.forEach(function (fn) {
    Server.prototype[fn] = function () {
        return this.sockets[fn].apply(this.sockets, arguments);
    };
});
module.exports = (srv, opts) =&gt; new Server(srv, opts);
module.exports.Server = Server;
module.exports.Namespace = namespace_1.Namespace;
module.exports.Socket = socket_1.Socket;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
