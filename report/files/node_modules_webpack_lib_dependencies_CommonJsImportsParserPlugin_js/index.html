<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/dependencies/CommonJsImportsParserPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/dependencies/CommonJsImportsParserPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">815</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">76.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.90</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { fileURLToPath } = require(&quot;url&quot;);
const CommentCompilationWarning = require(&quot;../CommentCompilationWarning&quot;);
const RuntimeGlobals = require(&quot;../RuntimeGlobals&quot;);
const UnsupportedFeatureWarning = require(&quot;../UnsupportedFeatureWarning&quot;);
const WebpackError = require(&quot;../WebpackError&quot;);
const BasicEvaluatedExpression = require(&quot;../javascript/BasicEvaluatedExpression&quot;);
const { VariableInfo } = require(&quot;../javascript/JavascriptParser&quot;);
const {
	evaluateToIdentifier,
	evaluateToString,
	expressionIsUnsupported,
	toConstantDependency
} = require(&quot;../javascript/JavascriptParserHelpers&quot;);
const CommonJsFullRequireDependency = require(&quot;./CommonJsFullRequireDependency&quot;);
const CommonJsRequireContextDependency = require(&quot;./CommonJsRequireContextDependency&quot;);
const CommonJsRequireDependency = require(&quot;./CommonJsRequireDependency&quot;);
const ConstDependency = require(&quot;./ConstDependency&quot;);
const ContextDependencyHelpers = require(&quot;./ContextDependencyHelpers&quot;);
const LocalModuleDependency = require(&quot;./LocalModuleDependency&quot;);
const { getLocalModule } = require(&quot;./LocalModulesHelpers&quot;);
const RequireHeaderDependency = require(&quot;./RequireHeaderDependency&quot;);
const RequireResolveContextDependency = require(&quot;./RequireResolveContextDependency&quot;);
const RequireResolveDependency = require(&quot;./RequireResolveDependency&quot;);
const RequireResolveHeaderDependency = require(&quot;./RequireResolveHeaderDependency&quot;);

/** @typedef {import(&quot;estree&quot;).CallExpression} CallExpression */
/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;estree&quot;).NewExpression} NewExpression */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import(&quot;../Dependency&quot;).DependencyLocation} DependencyLocation */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;)} JavascriptParser */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).ImportSource} ImportSource */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).Range} Range */

const createRequireSpecifierTag = Symbol(&quot;createRequire&quot;);
const createdRequireIdentifierTag = Symbol(&quot;createRequire()&quot;);

class CommonJsImportsParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options parser options
	 */
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		const options = this.options;

		const getContext = () =&gt; {
			if (parser.currentTagData) {
				const { context } = parser.currentTagData;
				return context;
			}
		};

		// #region metadata
		/**
		 * @param {string} expression expression
		 * @param {() =&gt; string[]} getMembers get members
		 */
		const tapRequireExpression = (expression, getMembers) =&gt; {
			parser.hooks.typeof
				.for(expression)
				.tap(
					&quot;CommonJsImportsParserPlugin&quot;,
					toConstantDependency(parser, JSON.stringify(&quot;function&quot;))
				);
			parser.hooks.evaluateTypeof
				.for(expression)
				.tap(&quot;CommonJsImportsParserPlugin&quot;, evaluateToString(&quot;function&quot;));
			parser.hooks.evaluateIdentifier
				.for(expression)
				.tap(
					&quot;CommonJsImportsParserPlugin&quot;,
					evaluateToIdentifier(expression, &quot;require&quot;, getMembers, true)
				);
		};
		/**
		 * @param {string | symbol} tag tag
		 */
		const tapRequireExpressionTag = tag =&gt; {
			parser.hooks.typeof
				.for(tag)
				.tap(
					&quot;CommonJsImportsParserPlugin&quot;,
					toConstantDependency(parser, JSON.stringify(&quot;function&quot;))
				);
			parser.hooks.evaluateTypeof
				.for(tag)
				.tap(&quot;CommonJsImportsParserPlugin&quot;, evaluateToString(&quot;function&quot;));
		};
		tapRequireExpression(&quot;require&quot;, () =&gt; []);
		tapRequireExpression(&quot;require.resolve&quot;, () =&gt; [&quot;resolve&quot;]);
		tapRequireExpression(&quot;require.resolveWeak&quot;, () =&gt; [&quot;resolveWeak&quot;]);
		// #endregion

		// Weird stuff //
		parser.hooks.assign
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, expr =&gt; {
				// to not leak to global &quot;require&quot;, we need to define a local require here.
				const dep = new ConstDependency(&quot;var require;&quot;, 0);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				parser.state.module.addPresentationalDependency(dep);
				return true;
			});

		// #region Unsupported
		parser.hooks.expression
			.for(&quot;require.main&quot;)
			.tap(
				&quot;CommonJsImportsParserPlugin&quot;,
				expressionIsUnsupported(
					parser,
					&quot;require.main is not supported by webpack.&quot;
				)
			);
		parser.hooks.call
			.for(&quot;require.main.require&quot;)
			.tap(
				&quot;CommonJsImportsParserPlugin&quot;,
				expressionIsUnsupported(
					parser,
					&quot;require.main.require is not supported by webpack.&quot;
				)
			);
		parser.hooks.expression
			.for(&quot;module.parent.require&quot;)
			.tap(
				&quot;CommonJsImportsParserPlugin&quot;,
				expressionIsUnsupported(
					parser,
					&quot;module.parent.require is not supported by webpack.&quot;
				)
			);
		parser.hooks.call
			.for(&quot;module.parent.require&quot;)
			.tap(
				&quot;CommonJsImportsParserPlugin&quot;,
				expressionIsUnsupported(
					parser,
					&quot;module.parent.require is not supported by webpack.&quot;
				)
			);
		// #endregion

		// #region Renaming
		/**
		 * @param {Expression} expr expression
		 * @returns {boolean} true when set undefined
		 */
		const defineUndefined = expr =&gt; {
			// To avoid &quot;not defined&quot; error, replace the value with undefined
			const dep = new ConstDependency(
				&quot;undefined&quot;,
				/** @type {Range} */ (expr.range)
			);
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			parser.state.module.addPresentationalDependency(dep);
			return false;
		};
		parser.hooks.canRename
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, () =&gt; true);
		parser.hooks.rename
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, defineUndefined);
		// #endregion

		// #region Inspection
		const requireCache = toConstantDependency(
			parser,
			RuntimeGlobals.moduleCache,
			[
				RuntimeGlobals.moduleCache,
				RuntimeGlobals.moduleId,
				RuntimeGlobals.moduleLoaded
			]
		);

		parser.hooks.expression
			.for(&quot;require.cache&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, requireCache);
		// #endregion

		// #region Require as expression
		/**
		 * @param {Expression} expr expression
		 * @returns {boolean} true when handled
		 */
		const requireAsExpressionHandler = expr =&gt; {
			const dep = new CommonJsRequireContextDependency(
				{
					request: /** @type {string} */ (options.unknownContextRequest),
					recursive: /** @type {boolean} */ (options.unknownContextRecursive),
					regExp: /** @type {RegExp} */ (options.unknownContextRegExp),
					mode: &quot;sync&quot;
				},
				/** @type {Range} */ (expr.range),
				undefined,
				parser.scope.inShorthand,
				getContext()
			);
			dep.critical =
				options.unknownContextCritical &amp;&amp;
				&quot;require function is used in a way in which dependencies cannot be statically extracted&quot;;
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			dep.optional = Boolean(parser.scope.inTry);
			parser.state.current.addDependency(dep);
			return true;
		};
		parser.hooks.expression
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, requireAsExpressionHandler);
		// #endregion

		// #region Require
		/**
		 * @param {CallExpression | NewExpression} expr expression
		 * @param {BasicEvaluatedExpression} param param
		 * @returns {boolean | void} true when handled
		 */
		const processRequireItem = (expr, param) =&gt; {
			if (param.isString()) {
				const dep = new CommonJsRequireDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (param.range),
					getContext()
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				dep.optional = Boolean(parser.scope.inTry);
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		/**
		 * @param {CallExpression | NewExpression} expr expression
		 * @param {BasicEvaluatedExpression} param param
		 * @returns {boolean | void} true when handled
		 */
		const processRequireContext = (expr, param) =&gt; {
			const dep = ContextDependencyHelpers.create(
				CommonJsRequireContextDependency,
				/** @type {Range} */ (expr.range),
				param,
				expr,
				options,
				{
					category: &quot;commonjs&quot;
				},
				parser,
				undefined,
				getContext()
			);
			if (!dep) return;
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			dep.optional = Boolean(parser.scope.inTry);
			parser.state.current.addDependency(dep);
			return true;
		};
		/**
		 * @param {boolean} callNew true, when require is called with new
		 * @returns {(expr: CallExpression | NewExpression) =&gt; (boolean | void)} handler
		 */
		const createRequireHandler = callNew =&gt; expr =&gt; {
			if (options.commonjsMagicComments) {
				const { options: requireOptions, errors: commentErrors } =
					parser.parseCommentOptions(/** @type {Range} */ (expr.range));

				if (commentErrors) {
					for (const e of commentErrors) {
						const { comment } = e;
						parser.state.module.addWarning(
							new CommentCompilationWarning(
								`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,
								/** @type {DependencyLocation} */ (comment.loc)
							)
						);
					}
				}
				if (requireOptions &amp;&amp; requireOptions.webpackIgnore !== undefined) {
					if (typeof requireOptions.webpackIgnore !== &quot;boolean&quot;) {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackIgnore\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`,
								/** @type {DependencyLocation} */ (expr.loc)
							)
						);
					} else if (requireOptions.webpackIgnore) {
						// Do not instrument `require()` if `webpackIgnore` is `true`
						return true;
					}
				}
			}

			if (expr.arguments.length !== 1) return;
			let localModule;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				let isExpression = false;
				for (const p of /** @type {BasicEvaluatedExpression[]} */ (
					param.options
				)) {
					const result = processRequireItem(expr, p);
					if (result === undefined) {
						isExpression = true;
					}
				}
				if (!isExpression) {
					const dep = new RequireHeaderDependency(
						/** @type {Range} */ (expr.callee.range)
					);
					dep.loc = /** @type {DependencyLocation} */ (expr.loc);
					parser.state.module.addPresentationalDependency(dep);
					return true;
				}
			}
			if (
				param.isString() &amp;&amp;
				(localModule = getLocalModule(
					parser.state,
					/** @type {string} */ (param.string)
				))
			) {
				localModule.flagUsed();
				const dep = new LocalModuleDependency(
					localModule,
					/** @type {Range} */ (expr.range),
					callNew
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				parser.state.module.addPresentationalDependency(dep);
			} else {
				const result = processRequireItem(expr, param);
				if (result === undefined) {
					processRequireContext(expr, param);
				} else {
					const dep = new RequireHeaderDependency(
						/** @type {Range} */ (expr.callee.range)
					);
					dep.loc = /** @type {DependencyLocation} */ (expr.loc);
					parser.state.module.addPresentationalDependency(dep);
				}
			}
			return true;
		};
		parser.hooks.call
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, createRequireHandler(false));
		parser.hooks.new
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, createRequireHandler(true));
		parser.hooks.call
			.for(&quot;module.require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, createRequireHandler(false));
		parser.hooks.new
			.for(&quot;module.require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, createRequireHandler(true));
		// #endregion

		// #region Require with property access
		/**
		 * @param {Expression} expr expression
		 * @param {string[]} calleeMembers callee members
		 * @param {CallExpression} callExpr call expression
		 * @param {string[]} members members
		 * @param {Range[]} memberRanges member ranges
		 * @returns {boolean | void} true when handled
		 */
		const chainHandler = (
			expr,
			calleeMembers,
			callExpr,
			members,
			memberRanges
		) =&gt; {
			if (callExpr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(callExpr.arguments[0]);
			if (
				param.isString() &amp;&amp;
				!getLocalModule(parser.state, /** @type {string} */ (param.string))
			) {
				const dep = new CommonJsFullRequireDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (expr.range),
					members,
					/** @type {Range[]} */ memberRanges
				);
				dep.asiSafe = !parser.isAsiPosition(
					/** @type {Range} */ (expr.range)[0]
				);
				dep.optional = Boolean(parser.scope.inTry);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		/**
		 * @param {CallExpression} expr expression
		 * @param {string[]} calleeMembers callee members
		 * @param {CallExpression} callExpr call expression
		 * @param {string[]} members members
		 * @param {Range[]} memberRanges member ranges
		 * @returns {boolean | void} true when handled
		 */
		const callChainHandler = (
			expr,
			calleeMembers,
			callExpr,
			members,
			memberRanges
		) =&gt; {
			if (callExpr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(callExpr.arguments[0]);
			if (
				param.isString() &amp;&amp;
				!getLocalModule(parser.state, /** @type {string} */ (param.string))
			) {
				const dep = new CommonJsFullRequireDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (expr.callee.range),
					members,
					/** @type {Range[]} */ memberRanges
				);
				dep.call = true;
				dep.asiSafe = !parser.isAsiPosition(
					/** @type {Range} */ (expr.range)[0]
				);
				dep.optional = Boolean(parser.scope.inTry);
				dep.loc = /** @type {DependencyLocation} */ (expr.callee.loc);
				parser.state.current.addDependency(dep);
				parser.walkExpressions(expr.arguments);
				return true;
			}
		};
		parser.hooks.memberChainOfCallMemberChain
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, chainHandler);
		parser.hooks.memberChainOfCallMemberChain
			.for(&quot;module.require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, chainHandler);
		parser.hooks.callMemberChainOfCallMemberChain
			.for(&quot;require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, callChainHandler);
		parser.hooks.callMemberChainOfCallMemberChain
			.for(&quot;module.require&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, callChainHandler);
		// #endregion

		// #region Require.resolve
		/**
		 * @param {CallExpression} expr call expression
		 * @param {boolean} weak weak
		 * @returns {boolean | void} true when handled
		 */
		const processResolve = (expr, weak) =&gt; {
			if (!weak &amp;&amp; options.commonjsMagicComments) {
				const { options: requireOptions, errors: commentErrors } =
					parser.parseCommentOptions(/** @type {Range} */ (expr.range));

				if (commentErrors) {
					for (const e of commentErrors) {
						const { comment } = e;
						parser.state.module.addWarning(
							new CommentCompilationWarning(
								`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,
								/** @type {DependencyLocation} */ (comment.loc)
							)
						);
					}
				}
				if (requireOptions &amp;&amp; requireOptions.webpackIgnore !== undefined) {
					if (typeof requireOptions.webpackIgnore !== &quot;boolean&quot;) {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackIgnore\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`,
								/** @type {DependencyLocation} */ (expr.loc)
							)
						);
					} else if (requireOptions.webpackIgnore) {
						// Do not instrument `require()` if `webpackIgnore` is `true`
						return true;
					}
				}
			}

			if (expr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				for (const option of /** @type {BasicEvaluatedExpression[]} */ (
					param.options
				)) {
					const result = processResolveItem(expr, option, weak);
					if (result === undefined) {
						processResolveContext(expr, option, weak);
					}
				}
				const dep = new RequireResolveHeaderDependency(
					/** @type {Range} */ (expr.callee.range)
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				parser.state.module.addPresentationalDependency(dep);
				return true;
			}
			const result = processResolveItem(expr, param, weak);
			if (result === undefined) {
				processResolveContext(expr, param, weak);
			}
			const dep = new RequireResolveHeaderDependency(
				/** @type {Range} */ (expr.callee.range)
			);
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			parser.state.module.addPresentationalDependency(dep);
			return true;
		};
		/**
		 * @param {CallExpression} expr call expression
		 * @param {BasicEvaluatedExpression} param param
		 * @param {boolean} weak weak
		 * @returns {boolean | void} true when handled
		 */
		const processResolveItem = (expr, param, weak) =&gt; {
			if (param.isString()) {
				const dep = new RequireResolveDependency(
					/** @type {string} */ (param.string),
					/** @type {Range} */ (param.range),
					getContext()
				);
				dep.loc = /** @type {DependencyLocation} */ (expr.loc);
				dep.optional = Boolean(parser.scope.inTry);
				dep.weak = weak;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		/**
		 * @param {CallExpression} expr call expression
		 * @param {BasicEvaluatedExpression} param param
		 * @param {boolean} weak weak
		 * @returns {boolean | void} true when handled
		 */
		const processResolveContext = (expr, param, weak) =&gt; {
			const dep = ContextDependencyHelpers.create(
				RequireResolveContextDependency,
				/** @type {Range} */ (param.range),
				param,
				expr,
				options,
				{
					category: &quot;commonjs&quot;,
					mode: weak ? &quot;weak&quot; : &quot;sync&quot;
				},
				parser,
				getContext()
			);
			if (!dep) return;
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			dep.optional = Boolean(parser.scope.inTry);
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.call
			.for(&quot;require.resolve&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, expr =&gt; processResolve(expr, false));
		parser.hooks.call
			.for(&quot;require.resolveWeak&quot;)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, expr =&gt; processResolve(expr, true));
		// #endregion

		// #region Create require

		if (!options.createRequire) return;

		/** @type {ImportSource[]} */
		let moduleName = [];
		/** @type {string | undefined} */
		let specifierName;

		if (options.createRequire === true) {
			moduleName = [&quot;module&quot;, &quot;node:module&quot;];
			specifierName = &quot;createRequire&quot;;
		} else {
			let moduleName;
			const match = /^(.*) from (.*)$/.exec(options.createRequire);
			if (match) {
				[, specifierName, moduleName] = match;
			}
			if (!specifierName || !moduleName) {
				const err = new WebpackError(
					`Parsing javascript parser option &quot;createRequire&quot; failed, got ${JSON.stringify(
						options.createRequire
					)}`
				);
				err.details =
					&#039;Expected string in format &quot;createRequire from module&quot;, where &quot;createRequire&quot; is specifier name and &quot;module&quot; name of the module&#039;;
				throw err;
			}
		}

		tapRequireExpressionTag(createdRequireIdentifierTag);
		tapRequireExpressionTag(createRequireSpecifierTag);
		parser.hooks.evaluateCallExpression
			.for(createRequireSpecifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, expr =&gt; {
				const context = parseCreateRequireArguments(expr);
				if (context === undefined) return;
				const ident = parser.evaluatedVariable({
					tag: createdRequireIdentifierTag,
					data: { context },
					next: undefined
				});

				return new BasicEvaluatedExpression()
					.setIdentifier(ident, ident, () =&gt; [])
					.setSideEffects(false)
					.setRange(/** @type {Range} */ (expr.range));
			});
		parser.hooks.unhandledExpressionMemberChain
			.for(createdRequireIdentifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, (expr, members) =&gt;
				expressionIsUnsupported(
					parser,
					`createRequire().${members.join(&quot;.&quot;)} is not supported by webpack.`
				)(expr)
			);
		parser.hooks.canRename
			.for(createdRequireIdentifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, () =&gt; true);
		parser.hooks.canRename
			.for(createRequireSpecifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, () =&gt; true);
		parser.hooks.rename
			.for(createRequireSpecifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, defineUndefined);
		parser.hooks.expression
			.for(createdRequireIdentifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, requireAsExpressionHandler);
		parser.hooks.call
			.for(createdRequireIdentifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, createRequireHandler(false));
		/**
		 * @param {CallExpression} expr call expression
		 * @returns {string | void} context
		 */
		const parseCreateRequireArguments = expr =&gt; {
			const args = expr.arguments;
			if (args.length !== 1) {
				const err = new WebpackError(
					&quot;module.createRequire supports only one argument.&quot;
				);
				err.loc = /** @type {DependencyLocation} */ (expr.loc);
				parser.state.module.addWarning(err);
				return;
			}
			const arg = args[0];
			const evaluated = parser.evaluateExpression(arg);
			if (!evaluated.isString()) {
				const err = new WebpackError(
					&quot;module.createRequire failed parsing argument.&quot;
				);
				err.loc = /** @type {DependencyLocation} */ (arg.loc);
				parser.state.module.addWarning(err);
				return;
			}
			const ctx = /** @type {string} */ (evaluated.string).startsWith(&quot;file://&quot;)
				? fileURLToPath(/** @type {string} */ (evaluated.string))
				: /** @type {string} */ (evaluated.string);
			// argument always should be a filename
			return ctx.slice(0, ctx.lastIndexOf(ctx.startsWith(&quot;/&quot;) ? &quot;/&quot; : &quot;\\&quot;));
		};

		parser.hooks.import.tap(
			{
				name: &quot;CommonJsImportsParserPlugin&quot;,
				stage: -10
			},
			(statement, source) =&gt; {
				if (
					!moduleName.includes(source) ||
					statement.specifiers.length !== 1 ||
					statement.specifiers[0].type !== &quot;ImportSpecifier&quot; ||
					statement.specifiers[0].imported.type !== &quot;Identifier&quot; ||
					statement.specifiers[0].imported.name !== specifierName
				)
					return;
				// clear for &#039;import { createRequire as x } from &quot;module&quot;&#039;
				// if any other specifier was used import module
				const clearDep = new ConstDependency(
					parser.isAsiPosition(/** @type {Range} */ (statement.range)[0])
						? &quot;;&quot;
						: &quot;&quot;,
					/** @type {Range} */ (statement.range)
				);
				clearDep.loc = /** @type {DependencyLocation} */ (statement.loc);
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(/** @type {Range} */ (statement.range)[1]);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			{
				name: &quot;CommonJsImportsParserPlugin&quot;,
				stage: -10
			},
			(statement, source, id, name) =&gt; {
				if (!moduleName.includes(source) || id !== specifierName) return;
				parser.tagVariable(name, createRequireSpecifierTag);
				return true;
			}
		);
		parser.hooks.preDeclarator.tap(
			&quot;CommonJsImportsParserPlugin&quot;,
			declarator =&gt; {
				if (
					declarator.id.type !== &quot;Identifier&quot; ||
					!declarator.init ||
					declarator.init.type !== &quot;CallExpression&quot; ||
					declarator.init.callee.type !== &quot;Identifier&quot;
				)
					return;
				const variableInfo = parser.getVariableInfo(
					declarator.init.callee.name
				);
				if (
					variableInfo instanceof VariableInfo &amp;&amp;
					variableInfo.tagInfo &amp;&amp;
					variableInfo.tagInfo.tag === createRequireSpecifierTag
				) {
					const context = parseCreateRequireArguments(declarator.init);
					if (context === undefined) return;
					parser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {
						name: declarator.id.name,
						context
					});
					return true;
				}
			}
		);

		parser.hooks.memberChainOfCallMemberChain
			.for(createRequireSpecifierTag)
			.tap(
				&quot;CommonJsImportsParserPlugin&quot;,
				(expr, calleeMembers, callExpr, members) =&gt; {
					if (
						calleeMembers.length !== 0 ||
						members.length !== 1 ||
						members[0] !== &quot;cache&quot;
					)
						return;
					// createRequire().cache
					const context = parseCreateRequireArguments(callExpr);
					if (context === undefined) return;
					return requireCache(expr);
				}
			);
		parser.hooks.callMemberChainOfCallMemberChain
			.for(createRequireSpecifierTag)
			.tap(
				&quot;CommonJsImportsParserPlugin&quot;,
				(expr, calleeMembers, innerCallExpression, members) =&gt; {
					if (
						calleeMembers.length !== 0 ||
						members.length !== 1 ||
						members[0] !== &quot;resolve&quot;
					)
						return;
					// createRequire().resolve()
					return processResolve(expr, false);
				}
			);
		parser.hooks.expressionMemberChain
			.for(createdRequireIdentifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, (expr, members) =&gt; {
				// require.cache
				if (members.length === 1 &amp;&amp; members[0] === &quot;cache&quot;) {
					return requireCache(expr);
				}
			});
		parser.hooks.callMemberChain
			.for(createdRequireIdentifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, (expr, members) =&gt; {
				// require.resolve()
				if (members.length === 1 &amp;&amp; members[0] === &quot;resolve&quot;) {
					return processResolve(expr, false);
				}
			});
		parser.hooks.call
			.for(createRequireSpecifierTag)
			.tap(&quot;CommonJsImportsParserPlugin&quot;, expr =&gt; {
				const clearDep = new ConstDependency(
					&quot;/* createRequire() */ undefined&quot;,
					/** @type {Range} */ (expr.range)
				);
				clearDep.loc = /** @type {DependencyLocation} */ (expr.loc);
				parser.state.module.addPresentationalDependency(clearDep);
				return true;
			});
		// #endregion
	}
}
module.exports = CommonJsImportsParserPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
