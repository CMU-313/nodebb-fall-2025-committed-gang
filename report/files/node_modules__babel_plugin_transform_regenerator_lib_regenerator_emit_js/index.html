<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/plugin-transform-regenerator/lib/regenerator/emit.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/plugin-transform-regenerator/lib/regenerator/emit.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">640</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">123.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.21</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.Emitter = void 0;
var _assert = require(&quot;assert&quot;);
var leap = require(&quot;./leap.js&quot;);
var meta = require(&quot;./meta.js&quot;);
var util = require(&quot;./util.js&quot;);
var _core = require(&quot;@babel/core&quot;);
const PENDING_LOCATION = Number.MAX_VALUE;
function getDeclError(node) {
  return new Error(&quot;all declarations should have been transformed into &quot; + &quot;assignments before the Exploder began its work: &quot; + JSON.stringify(node));
}
const catchParamVisitor = {
  Identifier: function (path, state) {
    if (path.node.name === state.catchParamName &amp;&amp; util.isReference(path)) {
      path.replaceWith(state.getSafeParam());
    }
  },
  Scope: function (path, state) {
    if (path.scope.hasOwnBinding(state.catchParamName)) {
      path.skip();
    }
  }
};
class Emitter {
  constructor(contextId, scope, vars, pluginPass) {
    this.nextTempId = void 0;
    this.contextId = void 0;
    this.index = void 0;
    this.indexMap = void 0;
    this.listing = void 0;
    this.returns = void 0;
    this.lastReferenceIndex = 0;
    this.marked = void 0;
    this.insertedLocs = void 0;
    this.finalLoc = void 0;
    this.tryEntries = void 0;
    this.leapManager = void 0;
    this.scope = void 0;
    this.vars = void 0;
    this.pluginPass = void 0;
    this.pluginPass = pluginPass;
    this.scope = scope;
    this.vars = vars;
    this.nextTempId = 0;
    this.contextId = contextId;
    this.listing = [];
    this.index = 0;
    this.indexMap = new Map([[0, 0]]);
    this.returns = new Set();
    this.lastReferenceIndex = 0;
    this.marked = [true];
    this.insertedLocs = new Set();
    this.finalLoc = this.loc();
    this.tryEntries = [];
    this.leapManager = new leap.LeapManager(this);
  }
  loc() {
    const l = _core.types.numericLiteral(PENDING_LOCATION);
    this.insertedLocs.add(l);
    return l;
  }
  getInsertedLocs() {
    return this.insertedLocs;
  }
  getContextId() {
    return _core.types.cloneNode(this.contextId);
  }
  getIndex() {
    if (!this.indexMap.has(this.listing.length)) {
      this.indexMap.set(this.listing.length, ++this.index);
    }
    return this.index;
  }
  mark(loc) {
    if (loc.value === PENDING_LOCATION) {
      loc.value = this.getIndex();
    } else {
      _assert.strictEqual(loc.value, this.index);
    }
    this.marked[this.listing.length] = true;
    if (loc.value &gt; this.lastReferenceIndex) {
      this.lastReferenceIndex = loc.value;
    }
    return loc;
  }
  emit(node) {
    if (_core.types.isExpression(node)) {
      node = _core.types.expressionStatement(node);
    }
    _core.types.assertStatement(node);
    this.listing.push(node);
  }
  emitAssign(lhs, rhs) {
    this.emit(this.assign(lhs, rhs));
    return lhs;
  }
  assign(lhs, rhs) {
    return _core.types.expressionStatement(_core.types.assignmentExpression(&quot;=&quot;, _core.types.cloneNode(lhs), rhs));
  }
  contextProperty(name) {
    const computed = name === &quot;catch&quot;;
    return _core.types.memberExpression(this.getContextId(), computed ? _core.types.stringLiteral(name) : _core.types.identifier(name), !!computed);
  }
  clearPendingException(tryLoc, assignee) {
    const catchCall = _core.types.callExpression(this.contextProperty(&quot;catch&quot;), [_core.types.cloneNode(tryLoc)]);
    if (assignee) {
      this.emitAssign(assignee, catchCall);
    } else {
      this.emit(catchCall);
    }
  }
  jump(toLoc) {
    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;n&quot; : &quot;next&quot;), toLoc);
    this.emit(_core.types.breakStatement());
  }
  jumpIf(test, toLoc) {
    this.emit(_core.types.ifStatement(test, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;n&quot; : &quot;next&quot;), toLoc), _core.types.breakStatement()])));
  }
  jumpIfNot(test, toLoc) {
    let negatedTest;
    if (_core.types.isUnaryExpression(test) &amp;&amp; test.operator === &quot;!&quot;) {
      negatedTest = test.argument;
    } else {
      negatedTest = _core.types.unaryExpression(&quot;!&quot;, test);
    }
    this.emit(_core.types.ifStatement(negatedTest, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;n&quot; : &quot;next&quot;), toLoc), _core.types.breakStatement()])));
  }
  makeContextTempVar() {
    return this.contextProperty(&quot;t&quot; + this.nextTempId++);
  }
  makeTempVar() {
    const id = this.scope.generateUidIdentifier(&quot;t&quot;);
    this.vars.push(_core.types.variableDeclarator(id));
    return _core.types.cloneNode(id);
  }
  getContextFunction() {
    return _core.types.functionExpression(null, [this.getContextId()], _core.types.blockStatement([this.getDispatchLoop()]), false, false);
  }
  getDispatchLoop() {
    const self = this;
    const cases = [];
    let current;
    let alreadyEnded = false;
    self.listing.forEach(function (stmt, i) {
      if (self.marked[i]) {
        cases.push(_core.types.switchCase(_core.types.numericLiteral(self.indexMap.get(i)), current = []));
        alreadyEnded = false;
      }
      if (!alreadyEnded) {
        current.push(stmt);
        if (_core.types.isCompletionStatement(stmt)) alreadyEnded = true;
      }
    });
    this.finalLoc.value = this.getIndex();
    if (util.newHelpersAvailable(this.pluginPass)) {
      if (this.lastReferenceIndex === this.index || !this.returns.has(this.listing.length)) {
        cases.push(_core.types.switchCase(this.finalLoc, [_core.types.returnStatement(_core.types.callExpression(this.contextProperty(&quot;a&quot;), [_core.types.numericLiteral(2)]))]));
      }
    } else {
      cases.push(_core.types.switchCase(this.finalLoc, []), _core.types.switchCase(_core.types.stringLiteral(&quot;end&quot;), [_core.types.returnStatement(_core.types.callExpression(this.contextProperty(&quot;stop&quot;), []))]));
    }
    return _core.types.whileStatement(_core.types.numericLiteral(1), _core.types.switchStatement(util.newHelpersAvailable(this.pluginPass) ? this.tryEntries.length === 0 ? this.contextProperty(&quot;n&quot;) : _core.types.assignmentExpression(&quot;=&quot;, this.contextProperty(&quot;p&quot;), this.contextProperty(&quot;n&quot;)) : _core.types.assignmentExpression(&quot;=&quot;, this.contextProperty(&quot;prev&quot;), this.contextProperty(&quot;next&quot;)), cases));
  }
  getTryLocsList() {
    if (this.tryEntries.length === 0) {
      return null;
    }
    let lastLocValue = 0;
    const arrayExpression = _core.types.arrayExpression(this.tryEntries.map(function (tryEntry) {
      const thisLocValue = tryEntry.firstLoc.value;
      _assert.ok(thisLocValue &gt;= lastLocValue, &quot;try entries out of order&quot;);
      lastLocValue = thisLocValue;
      const ce = tryEntry.catchEntry;
      const fe = tryEntry.finallyEntry;
      const locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];
      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }
      return _core.types.arrayExpression(locs.map(loc =&gt; loc &amp;&amp; _core.types.cloneNode(loc)));
    }));
    if (util.newHelpersAvailable(this.pluginPass)) {
      arrayExpression.elements.reverse();
    }
    return arrayExpression;
  }
  explode(path, ignoreResult) {
    const node = path.node;
    const self = this;
    if (_core.types.isDeclaration(node)) throw getDeclError(node);
    if (path.isStatement()) return self.explodeStatement(path);
    if (path.isExpression()) return self.explodeExpression(path, ignoreResult);
    switch (node.type) {
      case &quot;VariableDeclarator&quot;:
        throw getDeclError(node);
      case &quot;ObjectProperty&quot;:
      case &quot;SwitchCase&quot;:
      case &quot;CatchClause&quot;:
        throw new Error(node.type + &quot; nodes should be handled by their parents&quot;);
      default:
        throw new Error(&quot;unknown Node of type &quot; + JSON.stringify(node.type));
    }
  }
  explodeStatement(path, labelId = null) {
    const stmt = path.node;
    const self = this;
    let before, after, head;
    if (path.isBlockStatement()) {
      path.get(&quot;body&quot;).forEach(function (path) {
        self.explodeStatement(path);
      });
      return;
    }
    if (!meta.containsLeap(stmt)) {
      self.emit(stmt);
      return;
    }
    switch (path.type) {
      case &quot;ExpressionStatement&quot;:
        self.explodeExpression(path.get(&quot;expression&quot;), true);
        break;
      case &quot;LabeledStatement&quot;:
        after = this.loc();
        self.leapManager.withEntry(new leap.LabeledEntry(after, path.node.label), function () {
          self.explodeStatement(path.get(&quot;body&quot;), path.node.label);
        });
        self.mark(after);
        break;
      case &quot;WhileStatement&quot;:
        before = this.loc();
        after = this.loc();
        self.mark(before);
        self.jumpIfNot(self.explodeExpression(path.get(&quot;test&quot;)), after);
        self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {
          self.explodeStatement(path.get(&quot;body&quot;));
        });
        self.jump(before);
        self.mark(after);
        break;
      case &quot;DoWhileStatement&quot;:
        const first = this.loc();
        const test = this.loc();
        after = this.loc();
        self.mark(first);
        self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {
          self.explode(path.get(&quot;body&quot;));
        });
        self.mark(test);
        self.jumpIf(self.explodeExpression(path.get(&quot;test&quot;)), first);
        self.mark(after);
        break;
      case &quot;ForStatement&quot;:
        head = this.loc();
        const update = this.loc();
        after = this.loc();
        if (path.node.init) {
          self.explode(path.get(&quot;init&quot;), true);
        }
        self.mark(head);
        if (path.node.test) {
          self.jumpIfNot(self.explodeExpression(path.get(&quot;test&quot;)), after);
        } else {}
        self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {
          self.explodeStatement(path.get(&quot;body&quot;));
        });
        self.mark(update);
        if (path.node.update) {
          self.explode(path.get(&quot;update&quot;), true);
        }
        self.jump(head);
        self.mark(after);
        break;
      case &quot;TypeCastExpression&quot;:
        return self.explodeExpression(path.get(&quot;expression&quot;));
      case &quot;ForInStatement&quot;:
        head = this.loc();
        after = this.loc();
        const keyIterNextFn = self.makeTempVar();
        const helper = util.newHelpersAvailable(this.pluginPass) ? this.pluginPass.addHelper(&quot;regeneratorKeys&quot;) : util.runtimeProperty(this.pluginPass, &quot;keys&quot;);
        self.emitAssign(keyIterNextFn, _core.types.callExpression(helper, [self.explodeExpression(path.get(&quot;right&quot;))]));
        self.mark(head);
        const keyInfoTmpVar = self.makeTempVar();
        self.jumpIf(_core.types.memberExpression(_core.types.assignmentExpression(&quot;=&quot;, keyInfoTmpVar, _core.types.callExpression(_core.types.cloneNode(keyIterNextFn), [])), _core.types.identifier(&quot;done&quot;), false), after);
        self.emitAssign(path.node.left, _core.types.memberExpression(_core.types.cloneNode(keyInfoTmpVar), _core.types.identifier(&quot;value&quot;), false));
        self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {
          self.explodeStatement(path.get(&quot;body&quot;));
        });
        self.jump(head);
        self.mark(after);
        break;
      case &quot;BreakStatement&quot;:
        self.emitAbruptCompletion({
          type: 3,
          target: self.leapManager.getBreakLoc(path.node.label)
        });
        break;
      case &quot;ContinueStatement&quot;:
        self.emitAbruptCompletion({
          type: 3,
          target: self.leapManager.getContinueLoc(path.node.label)
        });
        break;
      case &quot;SwitchStatement&quot;:
        const disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(&quot;discriminant&quot;)));
        after = this.loc();
        const defaultLoc = this.loc();
        let condition = defaultLoc;
        const caseLocs = [];
        const cases = path.node.cases || [];
        for (let i = cases.length - 1; i &gt;= 0; --i) {
          const c = cases[i];
          if (c.test) {
            condition = _core.types.conditionalExpression(_core.types.binaryExpression(&quot;===&quot;, _core.types.cloneNode(disc), c.test), caseLocs[i] = this.loc(), condition);
          } else {
            caseLocs[i] = defaultLoc;
          }
        }
        const discriminant = path.get(&quot;discriminant&quot;);
        discriminant.replaceWith(condition);
        self.jump(self.explodeExpression(discriminant));
        self.leapManager.withEntry(new leap.SwitchEntry(after), function () {
          path.get(&quot;cases&quot;).forEach(function (casePath) {
            const i = casePath.key;
            self.mark(caseLocs[i]);
            casePath.get(&quot;consequent&quot;).forEach(function (path) {
              self.explodeStatement(path);
            });
          });
        });
        self.mark(after);
        if (defaultLoc.value === PENDING_LOCATION) {
          self.mark(defaultLoc);
          _assert.strictEqual(after.value, defaultLoc.value);
        }
        break;
      case &quot;IfStatement&quot;:
        const elseLoc = path.node.alternate &amp;&amp; this.loc();
        after = this.loc();
        self.jumpIfNot(self.explodeExpression(path.get(&quot;test&quot;)), elseLoc || after);
        self.explodeStatement(path.get(&quot;consequent&quot;));
        if (elseLoc) {
          self.jump(after);
          self.mark(elseLoc);
          self.explodeStatement(path.get(&quot;alternate&quot;));
        }
        self.mark(after);
        break;
      case &quot;ReturnStatement&quot;:
        self.emitAbruptCompletion({
          type: 2,
          value: self.explodeExpression(path.get(&quot;argument&quot;))
        });
        break;
      case &quot;WithStatement&quot;:
        throw new Error(&quot;WithStatement not supported in generator functions.&quot;);
      case &quot;TryStatement&quot;:
        after = this.loc();
        const handler = path.node.handler;
        const catchLoc = handler &amp;&amp; this.loc();
        const catchEntry = catchLoc &amp;&amp; new leap.CatchEntry(catchLoc, handler.param);
        const finallyLoc = path.node.finalizer &amp;&amp; this.loc();
        const finallyEntry = finallyLoc &amp;&amp; new leap.FinallyEntry(finallyLoc, after);
        const tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
        self.tryEntries.push(tryEntry);
        self.updateContextPrevLoc(tryEntry.firstLoc);
        self.leapManager.withEntry(tryEntry, () =&gt; {
          self.explodeStatement(path.get(&quot;block&quot;));
          if (catchLoc) {
            const body = path.node.block.body;
            if (finallyLoc) {
              self.jump(finallyLoc);
            } else if (body.length &amp;&amp; body[body.length - 1].type === &quot;ReturnStatement&quot;) {
              after = null;
            } else {
              self.jump(after);
            }
            self.updateContextPrevLoc(self.mark(catchLoc));
            const bodyPath = path.get(&quot;handler.body&quot;);
            const safeParam = self.makeTempVar();
            if (util.newHelpersAvailable(this.pluginPass)) {
              this.emitAssign(safeParam, self.contextProperty(&quot;v&quot;));
            } else {
              self.clearPendingException(tryEntry.firstLoc, safeParam);
            }
            bodyPath.traverse(catchParamVisitor, {
              getSafeParam: () =&gt; _core.types.cloneNode(safeParam),
              catchParamName: handler.param.name
            });
            self.leapManager.withEntry(catchEntry, function () {
              self.explodeStatement(bodyPath);
            });
          }
          if (finallyLoc) {
            self.updateContextPrevLoc(self.mark(finallyLoc));
            self.leapManager.withEntry(finallyEntry, function () {
              self.explodeStatement(path.get(&quot;finalizer&quot;));
            });
            self.emit(_core.types.returnStatement(_core.types.callExpression(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;f&quot; : &quot;finish&quot;), [finallyEntry.firstLoc])));
          }
        });
        if (after) self.mark(after);
        break;
      case &quot;ThrowStatement&quot;:
        self.emit(_core.types.throwStatement(self.explodeExpression(path.get(&quot;argument&quot;))));
        break;
      case &quot;ClassDeclaration&quot;:
        self.emit(self.explodeClass(path));
        break;
      default:
        throw new Error(&quot;unknown Statement of type &quot; + JSON.stringify(stmt.type));
    }
  }
  emitAbruptCompletion(record) {
    const abruptArgs = [util.newHelpersAvailable(this.pluginPass) ? _core.types.numericLiteral(record.type) : _core.types.stringLiteral(record.type === 3 ? &quot;continue&quot; : &quot;return&quot;)];
    if (record.type === 3) {
      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : _core.types.cloneNode(record.target);
    } else if (record.type === 2) {
      if (record.value) {
        abruptArgs[1] = _core.types.cloneNode(record.value);
      }
    }
    this.emit(_core.types.returnStatement(_core.types.callExpression(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;a&quot; : &quot;abrupt&quot;), abruptArgs)));
    if (record.type === 2) {
      this.returns.add(this.listing.length);
    }
  }
  getUnmarkedCurrentLoc() {
    return _core.types.numericLiteral(this.getIndex());
  }
  updateContextPrevLoc(loc) {
    if (loc) {
      if (loc.value === PENDING_LOCATION) {
        loc.value = this.getIndex();
      } else {
        _assert.strictEqual(loc.value, this.index);
      }
    } else {
      loc = this.getUnmarkedCurrentLoc();
    }
    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;p&quot; : &quot;prev&quot;), loc);
  }
  explodeViaTempVar(tempVar, childPath, hasLeapingChildren, ignoreChildResult) {
    _assert.ok(!ignoreChildResult || !tempVar, &quot;Ignoring the result of a child expression but forcing it to &quot; + &quot;be assigned to a temporary variable?&quot;);
    let result = this.explodeExpression(childPath, ignoreChildResult);
    if (ignoreChildResult) {} else if (tempVar || hasLeapingChildren &amp;&amp; !_core.types.isLiteral(result)) {
      result = this.emitAssign(tempVar || this.makeTempVar(), result);
    }
    return result;
  }
  explodeExpression(path, ignoreResult) {
    const expr = path.node;
    if (!expr) {
      return expr;
    }
    const self = this;
    let result;
    let after;
    function finish(expr) {
      if (ignoreResult) {
        self.emit(expr);
      }
      return expr;
    }
    if (!meta.containsLeap(expr)) {
      return finish(expr);
    }
    const hasLeapingChildren = meta.containsLeap.onlyChildren(expr);
    switch (path.type) {
      case &quot;MemberExpression&quot;:
        return finish(_core.types.memberExpression(self.explodeExpression(path.get(&quot;object&quot;)), path.node.computed ? self.explodeViaTempVar(null, path.get(&quot;property&quot;), hasLeapingChildren) : path.node.property, path.node.computed));
      case &quot;CallExpression&quot;:
        const calleePath = path.get(&quot;callee&quot;);
        const argsPath = path.get(&quot;arguments&quot;);
        let newCallee;
        let newArgs;
        let lastLeapingArgIndex = argsPath.length - 1;
        while (lastLeapingArgIndex &gt;= 0 &amp;&amp; !meta.containsLeap(argsPath[lastLeapingArgIndex].node)) {
          lastLeapingArgIndex--;
        }
        let injectFirstArg = null;
        if (_core.types.isMemberExpression(calleePath.node)) {
          if (lastLeapingArgIndex !== -1) {
            const newObject = self.explodeViaTempVar(self.makeTempVar(), calleePath.get(&quot;object&quot;), hasLeapingChildren);
            const newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get(&quot;property&quot;), hasLeapingChildren) : calleePath.node.property;
            injectFirstArg = newObject;
            newCallee = _core.types.memberExpression(_core.types.memberExpression(_core.types.cloneNode(newObject), newProperty, calleePath.node.computed), _core.types.identifier(&quot;call&quot;), false);
          } else {
            newCallee = self.explodeExpression(calleePath);
          }
        } else {
          newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);
          if (_core.types.isMemberExpression(newCallee)) {
            newCallee = _core.types.sequenceExpression([_core.types.numericLiteral(0), _core.types.cloneNode(newCallee)]);
          }
        }
        if (lastLeapingArgIndex !== -1) {
          newArgs = argsPath.map((argPath, index) =&gt; index &gt;= lastLeapingArgIndex ? self.explodeExpression(argPath) : self.explodeViaTempVar(null, argPath, hasLeapingChildren));
          if (injectFirstArg) newArgs.unshift(injectFirstArg);
          newArgs = newArgs.map(arg =&gt; _core.types.cloneNode(arg));
        } else {
          newArgs = path.node.arguments;
        }
        return finish(_core.types.callExpression(newCallee, newArgs));
      case &quot;NewExpression&quot;:
        return finish(_core.types.newExpression(self.explodeViaTempVar(null, path.get(&quot;callee&quot;), hasLeapingChildren), path.get(&quot;arguments&quot;).map(function (argPath) {
          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
        })));
      case &quot;ObjectExpression&quot;:
        return finish(_core.types.objectExpression(path.get(&quot;properties&quot;).map(function (propPath) {
          if (propPath.isObjectProperty()) {
            return _core.types.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get(&quot;value&quot;), hasLeapingChildren), propPath.node.computed);
          } else {
            return propPath.node;
          }
        })));
      case &quot;ArrayExpression&quot;:
        return finish(_core.types.arrayExpression(path.get(&quot;elements&quot;).map(function (elemPath) {
          if (!elemPath.node) {
            return null;
          }
          if (elemPath.isSpreadElement()) {
            return _core.types.spreadElement(self.explodeViaTempVar(null, elemPath.get(&quot;argument&quot;), hasLeapingChildren));
          } else {
            return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
          }
        })));
      case &quot;SequenceExpression&quot;:
        const lastIndex = path.node.expressions.length - 1;
        path.get(&quot;expressions&quot;).forEach(function (exprPath) {
          if (exprPath.key === lastIndex) {
            result = self.explodeExpression(exprPath, ignoreResult);
          } else {
            self.explodeExpression(exprPath, true);
          }
        });
        return result;
      case &quot;LogicalExpression&quot;:
        after = this.loc();
        if (!ignoreResult) {
          result = self.makeTempVar();
        }
        const left = self.explodeViaTempVar(result, path.get(&quot;left&quot;), hasLeapingChildren);
        if (path.node.operator === &quot;&amp;&amp;&quot;) {
          self.jumpIfNot(left, after);
        } else {
          _assert.strictEqual(path.node.operator, &quot;||&quot;);
          self.jumpIf(left, after);
        }
        self.explodeViaTempVar(result, path.get(&quot;right&quot;), hasLeapingChildren, ignoreResult);
        self.mark(after);
        return result;
      case &quot;ConditionalExpression&quot;:
        const elseLoc = this.loc();
        after = this.loc();
        const test = self.explodeExpression(path.get(&quot;test&quot;));
        self.jumpIfNot(test, elseLoc);
        if (!ignoreResult) {
          result = self.makeTempVar();
        }
        self.explodeViaTempVar(result, path.get(&quot;consequent&quot;), hasLeapingChildren, ignoreResult);
        self.jump(after);
        self.mark(elseLoc);
        self.explodeViaTempVar(result, path.get(&quot;alternate&quot;), hasLeapingChildren, ignoreResult);
        self.mark(after);
        return result;
      case &quot;UnaryExpression&quot;:
        return finish(_core.types.unaryExpression(path.node.operator, self.explodeExpression(path.get(&quot;argument&quot;)), !!path.node.prefix));
      case &quot;BinaryExpression&quot;:
        return finish(_core.types.binaryExpression(path.node.operator, self.explodeViaTempVar(null, path.get(&quot;left&quot;), hasLeapingChildren), self.explodeViaTempVar(null, path.get(&quot;right&quot;), hasLeapingChildren)));
      case &quot;AssignmentExpression&quot;:
        if (path.node.operator === &quot;=&quot;) {
          return finish(_core.types.assignmentExpression(path.node.operator, self.explodeExpression(path.get(&quot;left&quot;)), self.explodeExpression(path.get(&quot;right&quot;))));
        }
        const lhs = self.explodeExpression(path.get(&quot;left&quot;));
        const temp = self.emitAssign(self.makeTempVar(), lhs);
        return finish(_core.types.assignmentExpression(&quot;=&quot;, _core.types.cloneNode(lhs), _core.types.assignmentExpression(path.node.operator, _core.types.cloneNode(temp), self.explodeExpression(path.get(&quot;right&quot;)))));
      case &quot;UpdateExpression&quot;:
        return finish(_core.types.updateExpression(path.node.operator, self.explodeExpression(path.get(&quot;argument&quot;)), path.node.prefix));
      case &quot;YieldExpression&quot;:
        after = this.loc();
        const arg = path.node.argument &amp;&amp; self.explodeExpression(path.get(&quot;argument&quot;));
        if (arg &amp;&amp; path.node.delegate) {
          if (util.newHelpersAvailable(this.pluginPass)) {
            const ret = _core.types.returnStatement(_core.types.callExpression(self.contextProperty(&quot;d&quot;), [_core.types.callExpression(this.pluginPass.addHelper(&quot;regeneratorValues&quot;), [arg]), after]));
            ret.loc = expr.loc;
            self.emit(ret);
            self.mark(after);
            return self.contextProperty(&quot;v&quot;);
          } else {
            const result = self.makeContextTempVar();
            const ret = _core.types.returnStatement(_core.types.callExpression(self.contextProperty(&quot;delegateYield&quot;), [arg, _core.types.stringLiteral(result.property.name), after]));
            ret.loc = expr.loc;
            self.emit(ret);
            self.mark(after);
            return result;
          }
        }
        self.emitAssign(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? &quot;n&quot; : &quot;next&quot;), after);
        const ret = _core.types.returnStatement(_core.types.cloneNode(arg) || null);
        ret.loc = expr.loc;
        self.emit(ret);
        self.mark(after);
        return self.contextProperty(util.newHelpersAvailable(self.pluginPass) ? &quot;v&quot; : &quot;sent&quot;);
      case &quot;ClassExpression&quot;:
        return finish(self.explodeClass(path));
      default:
        throw new Error(&quot;unknown Expression of type &quot; + JSON.stringify(expr.type));
    }
  }
  explodeClass(path) {
    const explodingChildren = [];
    if (path.node.superClass) {
      explodingChildren.push(path.get(&quot;superClass&quot;));
    }
    path.get(&quot;body.body&quot;).forEach(member =&gt; {
      if (member.node.computed) {
        explodingChildren.push(member.get(&quot;key&quot;));
      }
    });
    const hasLeapingChildren = explodingChildren.some(child =&gt; meta.containsLeap(child.node));
    for (let i = 0; i &lt; explodingChildren.length; i++) {
      const child = explodingChildren[i];
      const isLast = i === explodingChildren.length - 1;
      if (isLast) {
        child.replaceWith(this.explodeExpression(child));
      } else {
        child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));
      }
    }
    return path.node;
  }
}
exports.Emitter = Emitter;

//# sourceMappingURL=emit.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
