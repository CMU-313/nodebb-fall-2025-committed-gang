<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/no-extra-parens.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/no-extra-parens.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.08</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1670</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.80</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Disallow parenthesising higher precedence subexpressions.
 * @author Michael Ficarra
 * @deprecated in ESLint v8.53.0
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const {
	isParenthesized: isParenthesizedRaw,
} = require(&quot;@eslint-community/eslint-utils&quot;);
const astUtils = require(&quot;./utils/ast-utils.js&quot;);

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin&quot;,
						url: &quot;https://eslint.style&quot;,
					},
					rule: {
						name: &quot;no-extra-parens&quot;,
						url: &quot;https://eslint.style/rules/no-extra-parens&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description: &quot;Disallow unnecessary parentheses&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/no-extra-parens&quot;,
		},

		fixable: &quot;code&quot;,

		schema: {
			anyOf: [
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [&quot;functions&quot;],
						},
					],
					minItems: 0,
					maxItems: 1,
				},
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [&quot;all&quot;],
						},
						{
							type: &quot;object&quot;,
							properties: {
								conditionalAssign: { type: &quot;boolean&quot; },
								ternaryOperandBinaryExpressions: {
									type: &quot;boolean&quot;,
								},
								nestedBinaryExpressions: { type: &quot;boolean&quot; },
								returnAssign: { type: &quot;boolean&quot; },
								ignoreJSX: {
									enum: [
										&quot;none&quot;,
										&quot;all&quot;,
										&quot;single-line&quot;,
										&quot;multi-line&quot;,
									],
								},
								enforceForArrowConditionals: {
									type: &quot;boolean&quot;,
								},
								enforceForSequenceExpressions: {
									type: &quot;boolean&quot;,
								},
								enforceForNewInMemberExpressions: {
									type: &quot;boolean&quot;,
								},
								enforceForFunctionPrototypeMethods: {
									type: &quot;boolean&quot;,
								},
								allowParensAfterCommentPattern: {
									type: &quot;string&quot;,
								},
							},
							additionalProperties: false,
						},
					],
					minItems: 0,
					maxItems: 2,
				},
			],
		},

		messages: {
			unexpected: &quot;Unnecessary parentheses around expression.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		const tokensToIgnore = new WeakSet();
		const precedence = astUtils.getPrecedence;
		const ALL_NODES = context.options[0] !== &quot;functions&quot;;
		const EXCEPT_COND_ASSIGN =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].conditionalAssign === false;
		const EXCEPT_COND_TERNARY =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].ternaryOperandBinaryExpressions === false;
		const NESTED_BINARY =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].nestedBinaryExpressions === false;
		const EXCEPT_RETURN_ASSIGN =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].returnAssign === false;
		const IGNORE_JSX =
			ALL_NODES &amp;&amp; context.options[1] &amp;&amp; context.options[1].ignoreJSX;
		const IGNORE_ARROW_CONDITIONALS =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].enforceForArrowConditionals === false;
		const IGNORE_SEQUENCE_EXPRESSIONS =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].enforceForSequenceExpressions === false;
		const IGNORE_NEW_IN_MEMBER_EXPR =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].enforceForNewInMemberExpressions === false;
		const IGNORE_FUNCTION_PROTOTYPE_METHODS =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].enforceForFunctionPrototypeMethods === false;
		const ALLOW_PARENS_AFTER_COMMENT_PATTERN =
			ALL_NODES &amp;&amp;
			context.options[1] &amp;&amp;
			context.options[1].allowParensAfterCommentPattern;

		const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({
			type: &quot;AssignmentExpression&quot;,
		});
		const PRECEDENCE_OF_UPDATE_EXPR = precedence({
			type: &quot;UpdateExpression&quot;,
		});

		let reportsBuffer;

		/**
		 * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.
		 * Example: function(){}.call()
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is an immediate `call` or `apply` method call.
		 * @private
		 */
		function isImmediateFunctionPrototypeMethodCall(node) {
			const callNode = astUtils.skipChainExpression(node);

			if (callNode.type !== &quot;CallExpression&quot;) {
				return false;
			}
			const callee = astUtils.skipChainExpression(callNode.callee);

			return (
				callee.type === &quot;MemberExpression&quot; &amp;&amp;
				callee.object.type === &quot;FunctionExpression&quot; &amp;&amp;
				[&quot;call&quot;, &quot;apply&quot;].includes(
					astUtils.getStaticPropertyName(callee),
				)
			);
		}

		/**
		 * Determines if this rule should be enforced for a node given the current configuration.
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the rule should be enforced for this node.
		 * @private
		 */
		function ruleApplies(node) {
			if (node.type === &quot;JSXElement&quot; || node.type === &quot;JSXFragment&quot;) {
				const isSingleLine = node.loc.start.line === node.loc.end.line;

				switch (IGNORE_JSX) {
					// Exclude this JSX element from linting
					case &quot;all&quot;:
						return false;

					// Exclude this JSX element if it is multi-line element
					case &quot;multi-line&quot;:
						return isSingleLine;

					// Exclude this JSX element if it is single-line element
					case &quot;single-line&quot;:
						return !isSingleLine;

					// Nothing special to be done for JSX elements
					case &quot;none&quot;:
						break;

					// no default
				}
			}

			if (
				node.type === &quot;SequenceExpression&quot; &amp;&amp;
				IGNORE_SEQUENCE_EXPRESSIONS
			) {
				return false;
			}

			if (
				isImmediateFunctionPrototypeMethodCall(node) &amp;&amp;
				IGNORE_FUNCTION_PROTOTYPE_METHODS
			) {
				return false;
			}

			return (
				ALL_NODES ||
				node.type === &quot;FunctionExpression&quot; ||
				node.type === &quot;ArrowFunctionExpression&quot;
			);
		}

		/**
		 * Determines if a node is surrounded by parentheses.
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is parenthesised.
		 * @private
		 */
		function isParenthesised(node) {
			return isParenthesizedRaw(1, node, sourceCode);
		}

		/**
		 * Determines if a node is surrounded by parentheses twice.
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is doubly parenthesised.
		 * @private
		 */
		function isParenthesisedTwice(node) {
			return isParenthesizedRaw(2, node, sourceCode);
		}

		/**
		 * Determines if a node is surrounded by (potentially) invalid parentheses.
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is incorrectly parenthesised.
		 * @private
		 */
		function hasExcessParens(node) {
			return ruleApplies(node) &amp;&amp; isParenthesised(node);
		}

		/**
		 * Determines if a node that is expected to be parenthesised is surrounded by
		 * (potentially) invalid extra parentheses.
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.
		 * @private
		 */
		function hasDoubleExcessParens(node) {
			return ruleApplies(node) &amp;&amp; isParenthesisedTwice(node);
		}

		/**
		 * Determines if a node that is expected to be parenthesised is surrounded by
		 * (potentially) invalid extra parentheses with considering precedence level of the node.
		 * If the preference level of the node is not higher or equal to precedence lower limit, it also checks
		 * whether the node is surrounded by parentheses twice or not.
		 * @param {ASTNode} node The node to be checked.
		 * @param {number} precedenceLowerLimit The lower limit of precedence.
		 * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.
		 * @private
		 */
		function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {
			if (ruleApplies(node) &amp;&amp; isParenthesised(node)) {
				if (
					precedence(node) &gt;= precedenceLowerLimit ||
					isParenthesisedTwice(node)
				) {
					return true;
				}
			}
			return false;
		}

		/**
		 * Determines if a node test expression is allowed to have a parenthesised assignment
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the assignment can be parenthesised.
		 * @private
		 */
		function isCondAssignException(node) {
			return (
				EXCEPT_COND_ASSIGN &amp;&amp; node.test.type === &quot;AssignmentExpression&quot;
			);
		}

		/**
		 * Determines if a node is in a return statement
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is in a return statement.
		 * @private
		 */
		function isInReturnStatement(node) {
			for (
				let currentNode = node;
				currentNode;
				currentNode = currentNode.parent
			) {
				if (
					currentNode.type === &quot;ReturnStatement&quot; ||
					(currentNode.type === &quot;ArrowFunctionExpression&quot; &amp;&amp;
						currentNode.body.type !== &quot;BlockStatement&quot;)
				) {
					return true;
				}
			}

			return false;
		}

		/**
		 * Determines if a constructor function is newed-up with parens
		 * @param {ASTNode} newExpression The NewExpression node to be checked.
		 * @returns {boolean} True if the constructor is called with parens.
		 * @private
		 */
		function isNewExpressionWithParens(newExpression) {
			const lastToken = sourceCode.getLastToken(newExpression);
			const penultimateToken = sourceCode.getTokenBefore(lastToken);

			return (
				newExpression.arguments.length &gt; 0 ||
				// The expression should end with its own parens, e.g., new new foo() is not a new expression with parens
				(astUtils.isOpeningParenToken(penultimateToken) &amp;&amp;
					astUtils.isClosingParenToken(lastToken) &amp;&amp;
					newExpression.callee.range[1] &lt; newExpression.range[1])
			);
		}

		/**
		 * Determines if a node is or contains an assignment expression
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is or contains an assignment expression.
		 * @private
		 */
		function containsAssignment(node) {
			if (node.type === &quot;AssignmentExpression&quot;) {
				return true;
			}
			if (
				node.type === &quot;ConditionalExpression&quot; &amp;&amp;
				(node.consequent.type === &quot;AssignmentExpression&quot; ||
					node.alternate.type === &quot;AssignmentExpression&quot;)
			) {
				return true;
			}
			if (
				(node.left &amp;&amp; node.left.type === &quot;AssignmentExpression&quot;) ||
				(node.right &amp;&amp; node.right.type === &quot;AssignmentExpression&quot;)
			) {
				return true;
			}

			return false;
		}

		/**
		 * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the assignment can be parenthesised.
		 * @private
		 */
		function isReturnAssignException(node) {
			if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
				return false;
			}

			if (node.type === &quot;ReturnStatement&quot;) {
				return node.argument &amp;&amp; containsAssignment(node.argument);
			}
			if (
				node.type === &quot;ArrowFunctionExpression&quot; &amp;&amp;
				node.body.type !== &quot;BlockStatement&quot;
			) {
				return containsAssignment(node.body);
			}
			return containsAssignment(node);
		}

		/**
		 * Determines if a node following a [no LineTerminator here] restriction is
		 * surrounded by (potentially) invalid extra parentheses.
		 * @param {Token} token The token preceding the [no LineTerminator here] restriction.
		 * @param {ASTNode} node The node to be checked.
		 * @returns {boolean} True if the node is incorrectly parenthesised.
		 * @private
		 */
		function hasExcessParensNoLineTerminator(token, node) {
			if (token.loc.end.line === node.loc.start.line) {
				return hasExcessParens(node);
			}

			return hasDoubleExcessParens(node);
		}

		/**
		 * Determines whether a node should be preceded by an additional space when removing parens
		 * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
		 * @returns {boolean} `true` if a space should be inserted before the node
		 * @private
		 */
		function requiresLeadingSpace(node) {
			const leftParenToken = sourceCode.getTokenBefore(node);
			const tokenBeforeLeftParen = sourceCode.getTokenBefore(
				leftParenToken,
				{ includeComments: true },
			);
			const tokenAfterLeftParen = sourceCode.getTokenAfter(
				leftParenToken,
				{ includeComments: true },
			);

			return (
				tokenBeforeLeftParen &amp;&amp;
				tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &amp;&amp;
				leftParenToken.range[1] === tokenAfterLeftParen.range[0] &amp;&amp;
				!astUtils.canTokensBeAdjacent(
					tokenBeforeLeftParen,
					tokenAfterLeftParen,
				)
			);
		}

		/**
		 * Determines whether a node should be followed by an additional space when removing parens
		 * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
		 * @returns {boolean} `true` if a space should be inserted after the node
		 * @private
		 */
		function requiresTrailingSpace(node) {
			const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });
			const rightParenToken = nextTwoTokens[0];
			const tokenAfterRightParen = nextTwoTokens[1];
			const tokenBeforeRightParen = sourceCode.getLastToken(node);

			return (
				rightParenToken &amp;&amp;
				tokenAfterRightParen &amp;&amp;
				!sourceCode.isSpaceBetweenTokens(
					rightParenToken,
					tokenAfterRightParen,
				) &amp;&amp;
				!astUtils.canTokensBeAdjacent(
					tokenBeforeRightParen,
					tokenAfterRightParen,
				)
			);
		}

		/**
		 * Determines if a given expression node is an IIFE
		 * @param {ASTNode} node The node to check
		 * @returns {boolean} `true` if the given node is an IIFE
		 */
		function isIIFE(node) {
			const maybeCallNode = astUtils.skipChainExpression(node);

			return (
				maybeCallNode.type === &quot;CallExpression&quot; &amp;&amp;
				maybeCallNode.callee.type === &quot;FunctionExpression&quot;
			);
		}

		/**
		 * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.
		 * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,
		 * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn&#039;t be necessary.
		 * @param {ASTNode} [node] The node to check
		 * @returns {boolean} `true` if the given node can be a valid assignment target
		 */
		function canBeAssignmentTarget(node) {
			return (
				node &amp;&amp;
				(node.type === &quot;Identifier&quot; || node.type === &quot;MemberExpression&quot;)
			);
		}

		/**
		 * Checks if a node is fixable.
		 * A node is fixable if removing a single pair of surrounding parentheses does not turn it
		 * into a directive after fixing other nodes.
		 * Almost all nodes are fixable, except if all of the following conditions are met:
		 * The node is a string Literal
		 * It has a single pair of parentheses
		 * It is the only child of an ExpressionStatement
		 * @param {ASTNode} node The node to evaluate.
		 * @returns {boolean} Whether or not the node is fixable.
		 * @private
		 */
		function isFixable(node) {
			// if it&#039;s not a string literal it can be autofixed
			if (node.type !== &quot;Literal&quot; || typeof node.value !== &quot;string&quot;) {
				return true;
			}
			if (isParenthesisedTwice(node)) {
				return true;
			}
			return !astUtils.isTopLevelExpressionStatement(node.parent);
		}

		/**
		 * Report the node
		 * @param {ASTNode} node node to evaluate
		 * @returns {void}
		 * @private
		 */
		function report(node) {
			const leftParenToken = sourceCode.getTokenBefore(node);
			const rightParenToken = sourceCode.getTokenAfter(node);

			if (!isParenthesisedTwice(node)) {
				if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
					return;
				}

				if (isIIFE(node) &amp;&amp; !isParenthesised(node.callee)) {
					return;
				}

				if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {
					const commentsBeforeLeftParenToken =
						sourceCode.getCommentsBefore(leftParenToken);
					const totalCommentsBeforeLeftParenTokenCount =
						commentsBeforeLeftParenToken.length;
					const ignorePattern = new RegExp(
						ALLOW_PARENS_AFTER_COMMENT_PATTERN,
						&quot;u&quot;,
					);

					if (
						totalCommentsBeforeLeftParenTokenCount &gt; 0 &amp;&amp;
						ignorePattern.test(
							commentsBeforeLeftParenToken[
								totalCommentsBeforeLeftParenTokenCount - 1
							].value,
						)
					) {
						return;
					}
				}
			}

			/**
			 * Finishes reporting
			 * @returns {void}
			 * @private
			 */
			function finishReport() {
				context.report({
					node,
					loc: leftParenToken.loc,
					messageId: &quot;unexpected&quot;,
					fix: isFixable(node)
						? fixer =&gt; {
								const parenthesizedSource =
									sourceCode.text.slice(
										leftParenToken.range[1],
										rightParenToken.range[0],
									);

								return fixer.replaceTextRange(
									[
										leftParenToken.range[0],
										rightParenToken.range[1],
									],
									(requiresLeadingSpace(node) ? &quot; &quot; : &quot;&quot;) +
										parenthesizedSource +
										(requiresTrailingSpace(node)
											? &quot; &quot;
											: &quot;&quot;),
								);
							}
						: null,
				});
			}

			if (reportsBuffer) {
				reportsBuffer.reports.push({ node, finishReport });
				return;
			}

			finishReport();
		}

		/**
		 * Evaluate a argument of the node.
		 * @param {ASTNode} node node to evaluate
		 * @returns {void}
		 * @private
		 */
		function checkArgumentWithPrecedence(node) {
			if (
				hasExcessParensWithPrecedence(node.argument, precedence(node))
			) {
				report(node.argument);
			}
		}

		/**
		 * Check if a member expression contains a call expression
		 * @param {ASTNode} node MemberExpression node to evaluate
		 * @returns {boolean} true if found, false if not
		 */
		function doesMemberExpressionContainCallExpression(node) {
			let currentNode = node.object;
			let currentNodeType = node.object.type;

			while (currentNodeType === &quot;MemberExpression&quot;) {
				currentNode = currentNode.object;
				currentNodeType = currentNode.type;
			}

			return currentNodeType === &quot;CallExpression&quot;;
		}

		/**
		 * Evaluate a new call
		 * @param {ASTNode} node node to evaluate
		 * @returns {void}
		 * @private
		 */
		function checkCallNew(node) {
			const callee = node.callee;

			if (hasExcessParensWithPrecedence(callee, precedence(node))) {
				if (
					hasDoubleExcessParens(callee) ||
					!(
						isIIFE(node) ||
						// (new A)(); new (new A)();
						(callee.type === &quot;NewExpression&quot; &amp;&amp;
							!isNewExpressionWithParens(callee) &amp;&amp;
							!(
								node.type === &quot;NewExpression&quot; &amp;&amp;
								!isNewExpressionWithParens(node)
							)) ||
						// new (a().b)(); new (a.b().c);
						(node.type === &quot;NewExpression&quot; &amp;&amp;
							callee.type === &quot;MemberExpression&quot; &amp;&amp;
							doesMemberExpressionContainCallExpression(
								callee,
							)) ||
						// (a?.b)(); (a?.())();
						(!node.optional &amp;&amp; callee.type === &quot;ChainExpression&quot;)
					)
				) {
					report(node.callee);
				}
			}
			node.arguments
				.filter(arg =&gt;
					hasExcessParensWithPrecedence(
						arg,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					),
				)
				.forEach(report);
		}

		/**
		 * Evaluate binary logicals
		 * @param {ASTNode} node node to evaluate
		 * @returns {void}
		 * @private
		 */
		function checkBinaryLogical(node) {
			const prec = precedence(node);
			const leftPrecedence = precedence(node.left);
			const rightPrecedence = precedence(node.right);
			const isExponentiation = node.operator === &quot;**&quot;;
			const shouldSkipLeft =
				NESTED_BINARY &amp;&amp;
				(node.left.type === &quot;BinaryExpression&quot; ||
					node.left.type === &quot;LogicalExpression&quot;);
			const shouldSkipRight =
				NESTED_BINARY &amp;&amp;
				(node.right.type === &quot;BinaryExpression&quot; ||
					node.right.type === &quot;LogicalExpression&quot;);

			if (!shouldSkipLeft &amp;&amp; hasExcessParens(node.left)) {
				if (
					(!(
						[&quot;AwaitExpression&quot;, &quot;UnaryExpression&quot;].includes(
							node.left.type,
						) &amp;&amp; isExponentiation
					) &amp;&amp;
						!astUtils.isMixedLogicalAndCoalesceExpressions(
							node.left,
							node,
						) &amp;&amp;
						(leftPrecedence &gt; prec ||
							(leftPrecedence === prec &amp;&amp; !isExponentiation))) ||
					isParenthesisedTwice(node.left)
				) {
					report(node.left);
				}
			}

			if (!shouldSkipRight &amp;&amp; hasExcessParens(node.right)) {
				if (
					(!astUtils.isMixedLogicalAndCoalesceExpressions(
						node.right,
						node,
					) &amp;&amp;
						(rightPrecedence &gt; prec ||
							(rightPrecedence === prec &amp;&amp; isExponentiation))) ||
					isParenthesisedTwice(node.right)
				) {
					report(node.right);
				}
			}
		}

		/**
		 * Check the parentheses around the super class of the given class definition.
		 * @param {ASTNode} node The node of class declarations to check.
		 * @returns {void}
		 */
		function checkClass(node) {
			if (!node.superClass) {
				return;
			}

			/*
			 * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.
			 * Otherwise, parentheses are needed.
			 */
			const hasExtraParens =
				precedence(node.superClass) &gt; PRECEDENCE_OF_UPDATE_EXPR
					? hasExcessParens(node.superClass)
					: hasDoubleExcessParens(node.superClass);

			if (hasExtraParens) {
				report(node.superClass);
			}
		}

		/**
		 * Check the parentheses around the argument of the given spread operator.
		 * @param {ASTNode} node The node of spread elements/properties to check.
		 * @returns {void}
		 */
		function checkSpreadOperator(node) {
			if (
				hasExcessParensWithPrecedence(
					node.argument,
					PRECEDENCE_OF_ASSIGNMENT_EXPR,
				)
			) {
				report(node.argument);
			}
		}

		/**
		 * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration
		 * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node
		 * @returns {void}
		 */
		function checkExpressionOrExportStatement(node) {
			const firstToken = isParenthesised(node)
				? sourceCode.getTokenBefore(node)
				: sourceCode.getFirstToken(node);
			const secondToken = sourceCode.getTokenAfter(
				firstToken,
				astUtils.isNotOpeningParenToken,
			);
			const thirdToken = secondToken
				? sourceCode.getTokenAfter(secondToken)
				: null;
			const tokenAfterClosingParens = secondToken
				? sourceCode.getTokenAfter(
						secondToken,
						astUtils.isNotClosingParenToken,
					)
				: null;

			if (
				astUtils.isOpeningParenToken(firstToken) &amp;&amp;
				(astUtils.isOpeningBraceToken(secondToken) ||
					(secondToken.type === &quot;Keyword&quot; &amp;&amp;
						(secondToken.value === &quot;function&quot; ||
							secondToken.value === &quot;class&quot; ||
							(secondToken.value === &quot;let&quot; &amp;&amp;
								tokenAfterClosingParens &amp;&amp;
								(astUtils.isOpeningBracketToken(
									tokenAfterClosingParens,
								) ||
									tokenAfterClosingParens.type ===
										&quot;Identifier&quot;)))) ||
					(secondToken &amp;&amp;
						secondToken.type === &quot;Identifier&quot; &amp;&amp;
						secondToken.value === &quot;async&quot; &amp;&amp;
						thirdToken &amp;&amp;
						thirdToken.type === &quot;Keyword&quot; &amp;&amp;
						thirdToken.value === &quot;function&quot;))
			) {
				tokensToIgnore.add(secondToken);
			}

			const hasExtraParens =
				node.parent.type === &quot;ExportDefaultDeclaration&quot;
					? hasExcessParensWithPrecedence(
							node,
							PRECEDENCE_OF_ASSIGNMENT_EXPR,
						)
					: hasExcessParens(node);

			if (hasExtraParens) {
				report(node);
			}
		}

		/**
		 * Finds the path from the given node to the specified ancestor.
		 * @param {ASTNode} node First node in the path.
		 * @param {ASTNode} ancestor Last node in the path.
		 * @returns {ASTNode[]} Path, including both nodes.
		 * @throws {Error} If the given node does not have the specified ancestor.
		 */
		function pathToAncestor(node, ancestor) {
			const path = [node];
			let currentNode = node;

			while (currentNode !== ancestor) {
				currentNode = currentNode.parent;

				/* c8 ignore start */
				if (currentNode === null) {
					throw new Error(
						&quot;Nodes are not in the ancestor-descendant relationship.&quot;,
					);
				} /* c8 ignore stop */

				path.push(currentNode);
			}

			return path;
		}

		/**
		 * Finds the path from the given node to the specified descendant.
		 * @param {ASTNode} node First node in the path.
		 * @param {ASTNode} descendant Last node in the path.
		 * @returns {ASTNode[]} Path, including both nodes.
		 * @throws {Error} If the given node does not have the specified descendant.
		 */
		function pathToDescendant(node, descendant) {
			return pathToAncestor(descendant, node).reverse();
		}

		/**
		 * Checks whether the syntax of the given ancestor of an &#039;in&#039; expression inside a for-loop initializer
		 * is preventing the &#039;in&#039; keyword from being interpreted as a part of an ill-formed for-in loop.
		 * @param {ASTNode} node Ancestor of an &#039;in&#039; expression.
		 * @param {ASTNode} child Child of the node, ancestor of the same &#039;in&#039; expression or the &#039;in&#039; expression itself.
		 * @returns {boolean} True if the keyword &#039;in&#039; would be interpreted as the &#039;in&#039; operator, without any parenthesis.
		 */
		function isSafelyEnclosingInExpression(node, child) {
			switch (node.type) {
				case &quot;ArrayExpression&quot;:
				case &quot;ArrayPattern&quot;:
				case &quot;BlockStatement&quot;:
				case &quot;ObjectExpression&quot;:
				case &quot;ObjectPattern&quot;:
				case &quot;TemplateLiteral&quot;:
					return true;
				case &quot;ArrowFunctionExpression&quot;:
				case &quot;FunctionExpression&quot;:
					return node.params.includes(child);
				case &quot;CallExpression&quot;:
				case &quot;NewExpression&quot;:
					return node.arguments.includes(child);
				case &quot;MemberExpression&quot;:
					return node.computed &amp;&amp; node.property === child;
				case &quot;ConditionalExpression&quot;:
					return node.consequent === child;
				default:
					return false;
			}
		}

		/**
		 * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.
		 * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.
		 * @returns {void}
		 */
		function startNewReportsBuffering() {
			reportsBuffer = {
				upper: reportsBuffer,
				inExpressionNodes: [],
				reports: [],
			};
		}

		/**
		 * Ends the current reports buffering.
		 * @returns {void}
		 */
		function endCurrentReportsBuffering() {
			const { upper, inExpressionNodes, reports } = reportsBuffer;

			if (upper) {
				upper.inExpressionNodes.push(...inExpressionNodes);
				upper.reports.push(...reports);
			} else {
				// flush remaining reports
				reports.forEach(({ finishReport }) =&gt; finishReport());
			}

			reportsBuffer = upper;
		}

		/**
		 * Checks whether the given node is in the current reports buffer.
		 * @param {ASTNode} node Node to check.
		 * @returns {boolean} True if the node is in the current buffer, false otherwise.
		 */
		function isInCurrentReportsBuffer(node) {
			return reportsBuffer.reports.some(r =&gt; r.node === node);
		}

		/**
		 * Removes the given node from the current reports buffer.
		 * @param {ASTNode} node Node to remove.
		 * @returns {void}
		 */
		function removeFromCurrentReportsBuffer(node) {
			reportsBuffer.reports = reportsBuffer.reports.filter(
				r =&gt; r.node !== node,
			);
		}

		/**
		 * Checks whether a node is a MemberExpression at NewExpression&#039;s callee.
		 * @param {ASTNode} node node to check.
		 * @returns {boolean} True if the node is a MemberExpression at NewExpression&#039;s callee. false otherwise.
		 */
		function isMemberExpInNewCallee(node) {
			if (node.type === &quot;MemberExpression&quot;) {
				return node.parent.type === &quot;NewExpression&quot; &amp;&amp;
					node.parent.callee === node
					? true
					: node.parent.object === node &amp;&amp;
							isMemberExpInNewCallee(node.parent);
			}
			return false;
		}

		/**
		 * Checks if the left-hand side of an assignment is an identifier, the operator is one of
		 * `=`, `&amp;&amp;=`, `||=` or `??=` and the right-hand side is an anonymous class or function.
		 *
		 * As per https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation, an
		 * assignment involving one of the operators `=`, `&amp;&amp;=`, `||=` or `??=` where the right-hand
		 * side is an anonymous class or function and the left-hand side is an *unparenthesized*
		 * identifier has different semantics than other assignments.
		 * Specifically, when an expression like `foo = function () {}` is evaluated, `foo.name`
		 * will be set to the string &quot;foo&quot;, i.e. the identifier name. The same thing does not happen
		 * when evaluating `(foo) = function () {}`.
		 * Since the parenthesizing of the identifier in the left-hand side is significant in this
		 * special case, the parentheses, if present, should not be flagged as unnecessary.
		 * @param {ASTNode} node an AssignmentExpression node.
		 * @returns {boolean} `true` if the left-hand side of the assignment is an identifier, the
		 * operator is one of `=`, `&amp;&amp;=`, `||=` or `??=` and the right-hand side is an anonymous
		 * class or function; otherwise, `false`.
		 */
		function isAnonymousFunctionAssignmentException({
			left,
			operator,
			right,
		}) {
			if (
				left.type === &quot;Identifier&quot; &amp;&amp;
				[&quot;=&quot;, &quot;&amp;&amp;=&quot;, &quot;||=&quot;, &quot;??=&quot;].includes(operator)
			) {
				const rhsType = right.type;

				if (rhsType === &quot;ArrowFunctionExpression&quot;) {
					return true;
				}
				if (
					(rhsType === &quot;FunctionExpression&quot; ||
						rhsType === &quot;ClassExpression&quot;) &amp;&amp;
					!right.id
				) {
					return true;
				}
			}
			return false;
		}

		return {
			ArrayExpression(node) {
				node.elements
					.filter(
						e =&gt;
							e &amp;&amp;
							hasExcessParensWithPrecedence(
								e,
								PRECEDENCE_OF_ASSIGNMENT_EXPR,
							),
					)
					.forEach(report);
			},

			ArrayPattern(node) {
				node.elements
					.filter(e =&gt; canBeAssignmentTarget(e) &amp;&amp; hasExcessParens(e))
					.forEach(report);
			},

			ArrowFunctionExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (
					node.body.type === &quot;ConditionalExpression&quot; &amp;&amp;
					IGNORE_ARROW_CONDITIONALS
				) {
					return;
				}

				if (node.body.type !== &quot;BlockStatement&quot;) {
					const firstBodyToken = sourceCode.getFirstToken(
						node.body,
						astUtils.isNotOpeningParenToken,
					);
					const tokenBeforeFirst =
						sourceCode.getTokenBefore(firstBodyToken);

					if (
						astUtils.isOpeningParenToken(tokenBeforeFirst) &amp;&amp;
						astUtils.isOpeningBraceToken(firstBodyToken)
					) {
						tokensToIgnore.add(firstBodyToken);
					}
					if (
						hasExcessParensWithPrecedence(
							node.body,
							PRECEDENCE_OF_ASSIGNMENT_EXPR,
						)
					) {
						report(node.body);
					}
				}
			},

			AssignmentExpression(node) {
				if (
					canBeAssignmentTarget(node.left) &amp;&amp;
					hasExcessParens(node.left) &amp;&amp;
					(!isAnonymousFunctionAssignmentException(node) ||
						isParenthesisedTwice(node.left))
				) {
					report(node.left);
				}

				if (
					!isReturnAssignException(node) &amp;&amp;
					hasExcessParensWithPrecedence(node.right, precedence(node))
				) {
					report(node.right);
				}
			},

			BinaryExpression(node) {
				if (reportsBuffer &amp;&amp; node.operator === &quot;in&quot;) {
					reportsBuffer.inExpressionNodes.push(node);
				}

				checkBinaryLogical(node);
			},

			CallExpression: checkCallNew,

			ConditionalExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				const availableTypes = new Set([
					&quot;BinaryExpression&quot;,
					&quot;LogicalExpression&quot;,
				]);

				if (
					!(
						EXCEPT_COND_TERNARY &amp;&amp;
						availableTypes.has(node.test.type)
					) &amp;&amp;
					!isCondAssignException(node) &amp;&amp;
					hasExcessParensWithPrecedence(
						node.test,
						precedence({
							type: &quot;LogicalExpression&quot;,
							operator: &quot;||&quot;,
						}),
					)
				) {
					report(node.test);
				}

				if (
					!(
						EXCEPT_COND_TERNARY &amp;&amp;
						availableTypes.has(node.consequent.type)
					) &amp;&amp;
					hasExcessParensWithPrecedence(
						node.consequent,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(node.consequent);
				}

				if (
					!(
						EXCEPT_COND_TERNARY &amp;&amp;
						availableTypes.has(node.alternate.type)
					) &amp;&amp;
					hasExcessParensWithPrecedence(
						node.alternate,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(node.alternate);
				}
			},

			DoWhileStatement(node) {
				if (
					hasExcessParens(node.test) &amp;&amp;
					!isCondAssignException(node)
				) {
					report(node.test);
				}
			},

			ExportDefaultDeclaration: node =&gt;
				checkExpressionOrExportStatement(node.declaration),
			ExpressionStatement: node =&gt;
				checkExpressionOrExportStatement(node.expression),

			ForInStatement(node) {
				if (node.left.type !== &quot;VariableDeclaration&quot;) {
					const firstLeftToken = sourceCode.getFirstToken(
						node.left,
						astUtils.isNotOpeningParenToken,
					);

					if (
						firstLeftToken.value === &quot;let&quot; &amp;&amp;
						astUtils.isOpeningBracketToken(
							sourceCode.getTokenAfter(
								firstLeftToken,
								astUtils.isNotClosingParenToken,
							),
						)
					) {
						// ForInStatement#left expression cannot start with `let[`.
						tokensToIgnore.add(firstLeftToken);
					}
				}

				if (hasExcessParens(node.left)) {
					report(node.left);
				}

				if (hasExcessParens(node.right)) {
					report(node.right);
				}
			},

			ForOfStatement(node) {
				if (node.left.type !== &quot;VariableDeclaration&quot;) {
					const firstLeftToken = sourceCode.getFirstToken(
						node.left,
						astUtils.isNotOpeningParenToken,
					);

					if (firstLeftToken.value === &quot;let&quot;) {
						// ForOfStatement#left expression cannot start with `let`.
						tokensToIgnore.add(firstLeftToken);
					}
				}

				if (hasExcessParens(node.left)) {
					report(node.left);
				}

				if (
					hasExcessParensWithPrecedence(
						node.right,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(node.right);
				}
			},

			ForStatement(node) {
				if (
					node.test &amp;&amp;
					hasExcessParens(node.test) &amp;&amp;
					!isCondAssignException(node)
				) {
					report(node.test);
				}

				if (node.update &amp;&amp; hasExcessParens(node.update)) {
					report(node.update);
				}

				if (node.init) {
					if (node.init.type !== &quot;VariableDeclaration&quot;) {
						const firstToken = sourceCode.getFirstToken(
							node.init,
							astUtils.isNotOpeningParenToken,
						);

						if (
							firstToken.value === &quot;let&quot; &amp;&amp;
							astUtils.isOpeningBracketToken(
								sourceCode.getTokenAfter(
									firstToken,
									astUtils.isNotClosingParenToken,
								),
							)
						) {
							// ForStatement#init expression cannot start with `let[`.
							tokensToIgnore.add(firstToken);
						}
					}

					startNewReportsBuffering();

					if (hasExcessParens(node.init)) {
						report(node.init);
					}
				}
			},

			&quot;ForStatement &gt; *.init:exit&quot;(node) {
				/*
				 * Removing parentheses around `in` expressions might change semantics and cause errors.
				 *
				 * For example, this valid for loop:
				 *      for (let a = (b in c); ;);
				 * after removing parentheses would be treated as an invalid for-in loop:
				 *      for (let a = b in c; ;);
				 */

				if (reportsBuffer.reports.length) {
					reportsBuffer.inExpressionNodes.forEach(
						inExpressionNode =&gt; {
							const path = pathToDescendant(
								node,
								inExpressionNode,
							);
							let nodeToExclude;

							for (let i = 0; i &lt; path.length; i++) {
								const pathNode = path[i];

								if (i &lt; path.length - 1) {
									const nextPathNode = path[i + 1];

									if (
										isSafelyEnclosingInExpression(
											pathNode,
											nextPathNode,
										)
									) {
										// The &#039;in&#039; expression in safely enclosed by the syntax of its ancestor nodes (e.g. by &#039;{}&#039; or &#039;[]&#039;).
										return;
									}
								}

								if (isParenthesised(pathNode)) {
									if (isInCurrentReportsBuffer(pathNode)) {
										// This node was supposed to be reported, but parentheses might be necessary.

										if (isParenthesisedTwice(pathNode)) {
											/*
											 * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.
											 * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.
											 * The remaining pair is safely enclosing the &#039;in&#039; expression.
											 */
											return;
										}

										// Exclude the outermost node only.
										if (!nodeToExclude) {
											nodeToExclude = pathNode;
										}

										// Don&#039;t break the loop here, there might be some safe nodes or parentheses that will stay inside.
									} else {
										// This node will stay parenthesised, the &#039;in&#039; expression in safely enclosed by &#039;()&#039;.
										return;
									}
								}
							}

							// Exclude the node from the list (i.e. treat parentheses as necessary)
							removeFromCurrentReportsBuffer(nodeToExclude);
						},
					);
				}

				endCurrentReportsBuffering();
			},

			IfStatement(node) {
				if (
					hasExcessParens(node.test) &amp;&amp;
					!isCondAssignException(node)
				) {
					report(node.test);
				}
			},

			ImportExpression(node) {
				const { source } = node;

				if (source.type === &quot;SequenceExpression&quot;) {
					if (hasDoubleExcessParens(source)) {
						report(source);
					}
				} else if (hasExcessParens(source)) {
					report(source);
				}
			},

			LogicalExpression: checkBinaryLogical,

			MemberExpression(node) {
				const shouldAllowWrapOnce =
					isMemberExpInNewCallee(node) &amp;&amp;
					doesMemberExpressionContainCallExpression(node);
				const nodeObjHasExcessParens = shouldAllowWrapOnce
					? hasDoubleExcessParens(node.object)
					: hasExcessParens(node.object) &amp;&amp;
						!(
							isImmediateFunctionPrototypeMethodCall(
								node.parent,
							) &amp;&amp;
							node.parent.callee === node &amp;&amp;
							IGNORE_FUNCTION_PROTOTYPE_METHODS
						);

				if (
					nodeObjHasExcessParens &amp;&amp;
					precedence(node.object) &gt;= precedence(node) &amp;&amp;
					(node.computed ||
						!(
							astUtils.isDecimalInteger(node.object) ||
							// RegExp literal is allowed to have parens (#1589)
							(node.object.type === &quot;Literal&quot; &amp;&amp;
								node.object.regex)
						))
				) {
					report(node.object);
				}

				if (
					nodeObjHasExcessParens &amp;&amp;
					node.object.type === &quot;CallExpression&quot;
				) {
					report(node.object);
				}

				if (
					nodeObjHasExcessParens &amp;&amp;
					!IGNORE_NEW_IN_MEMBER_EXPR &amp;&amp;
					node.object.type === &quot;NewExpression&quot; &amp;&amp;
					isNewExpressionWithParens(node.object)
				) {
					report(node.object);
				}

				if (
					nodeObjHasExcessParens &amp;&amp;
					node.optional &amp;&amp;
					node.object.type === &quot;ChainExpression&quot;
				) {
					report(node.object);
				}

				if (node.computed &amp;&amp; hasExcessParens(node.property)) {
					report(node.property);
				}
			},

			&quot;MethodDefinition[computed=true]&quot;(node) {
				if (
					hasExcessParensWithPrecedence(
						node.key,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(node.key);
				}
			},

			NewExpression: checkCallNew,

			ObjectExpression(node) {
				node.properties
					.filter(
						property =&gt;
							property.value &amp;&amp;
							hasExcessParensWithPrecedence(
								property.value,
								PRECEDENCE_OF_ASSIGNMENT_EXPR,
							),
					)
					.forEach(property =&gt; report(property.value));
			},

			ObjectPattern(node) {
				node.properties
					.filter(property =&gt; {
						const value = property.value;

						return (
							canBeAssignmentTarget(value) &amp;&amp;
							hasExcessParens(value)
						);
					})
					.forEach(property =&gt; report(property.value));
			},

			Property(node) {
				if (node.computed) {
					const { key } = node;

					if (
						key &amp;&amp;
						hasExcessParensWithPrecedence(
							key,
							PRECEDENCE_OF_ASSIGNMENT_EXPR,
						)
					) {
						report(key);
					}
				}
			},

			PropertyDefinition(node) {
				if (
					node.computed &amp;&amp;
					hasExcessParensWithPrecedence(
						node.key,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(node.key);
				}

				if (
					node.value &amp;&amp;
					hasExcessParensWithPrecedence(
						node.value,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(node.value);
				}
			},

			RestElement(node) {
				const argument = node.argument;

				if (
					canBeAssignmentTarget(argument) &amp;&amp;
					hasExcessParens(argument)
				) {
					report(argument);
				}
			},

			ReturnStatement(node) {
				const returnToken = sourceCode.getFirstToken(node);

				if (isReturnAssignException(node)) {
					return;
				}

				if (
					node.argument &amp;&amp;
					hasExcessParensNoLineTerminator(
						returnToken,
						node.argument,
					) &amp;&amp;
					// RegExp literal is allowed to have parens (#1589)
					!(node.argument.type === &quot;Literal&quot; &amp;&amp; node.argument.regex)
				) {
					report(node.argument);
				}
			},

			SequenceExpression(node) {
				const precedenceOfNode = precedence(node);

				node.expressions
					.filter(e =&gt;
						hasExcessParensWithPrecedence(e, precedenceOfNode),
					)
					.forEach(report);
			},

			SwitchCase(node) {
				if (node.test &amp;&amp; hasExcessParens(node.test)) {
					report(node.test);
				}
			},

			SwitchStatement(node) {
				if (hasExcessParens(node.discriminant)) {
					report(node.discriminant);
				}
			},

			ThrowStatement(node) {
				const throwToken = sourceCode.getFirstToken(node);

				if (
					hasExcessParensNoLineTerminator(throwToken, node.argument)
				) {
					report(node.argument);
				}
			},

			UnaryExpression: checkArgumentWithPrecedence,
			UpdateExpression(node) {
				if (node.prefix) {
					checkArgumentWithPrecedence(node);
				} else {
					const { argument } = node;
					const operatorToken = sourceCode.getLastToken(node);

					if (
						argument.loc.end.line === operatorToken.loc.start.line
					) {
						checkArgumentWithPrecedence(node);
					} else {
						if (hasDoubleExcessParens(argument)) {
							report(argument);
						}
					}
				}
			},
			AwaitExpression: checkArgumentWithPrecedence,

			VariableDeclarator(node) {
				if (
					node.init &amp;&amp;
					hasExcessParensWithPrecedence(
						node.init,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					) &amp;&amp;
					// RegExp literal is allowed to have parens (#1589)
					!(node.init.type === &quot;Literal&quot; &amp;&amp; node.init.regex)
				) {
					report(node.init);
				}
			},

			WhileStatement(node) {
				if (
					hasExcessParens(node.test) &amp;&amp;
					!isCondAssignException(node)
				) {
					report(node.test);
				}
			},

			WithStatement(node) {
				if (hasExcessParens(node.object)) {
					report(node.object);
				}
			},

			YieldExpression(node) {
				if (node.argument) {
					const yieldToken = sourceCode.getFirstToken(node);

					if (
						(precedence(node.argument) &gt;= precedence(node) &amp;&amp;
							hasExcessParensNoLineTerminator(
								yieldToken,
								node.argument,
							)) ||
						hasDoubleExcessParens(node.argument)
					) {
						report(node.argument);
					}
				}
			},

			ClassDeclaration: checkClass,
			ClassExpression: checkClass,

			SpreadElement: checkSpreadOperator,
			SpreadProperty: checkSpreadOperator,
			ExperimentalSpreadProperty: checkSpreadOperator,

			TemplateLiteral(node) {
				node.expressions
					.filter(e =&gt; e &amp;&amp; hasExcessParens(e))
					.forEach(report);
			},

			AssignmentPattern(node) {
				const { left, right } = node;

				if (canBeAssignmentTarget(left) &amp;&amp; hasExcessParens(left)) {
					report(left);
				}

				if (
					right &amp;&amp;
					hasExcessParensWithPrecedence(
						right,
						PRECEDENCE_OF_ASSIGNMENT_EXPR,
					)
				) {
					report(right);
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
