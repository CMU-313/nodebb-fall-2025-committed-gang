<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@fortawesome/fontawesome-free/js/conflict-detection.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@fortawesome/fontawesome-free/js/conflict-detection.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1109</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">139.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.90</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
(function (global, factory) {
  typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? factory() :
  typeof define === &#039;function&#039; &amp;&amp; define.amd ? define(factory) :
  (factory());
}(this, (function () { &#039;use strict&#039;;

  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r &amp;&amp; (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r &lt; arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _toPrimitive(t, r) {
    if (&quot;object&quot; != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || &quot;default&quot;);
      if (&quot;object&quot; != typeof i) return i;
      throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;);
    }
    return (&quot;string&quot; === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, &quot;string&quot;);
    return &quot;symbol&quot; == typeof i ? i : i + &quot;&quot;;
  }

  let _WINDOW = {};
  let _DOCUMENT = {};
  try {
    if (typeof window !== &#039;undefined&#039;) _WINDOW = window;
    if (typeof document !== &#039;undefined&#039;) _DOCUMENT = document;
  } catch (e) {}
  const {
    userAgent = &#039;&#039;
  } = _WINDOW.navigator || {};
  const WINDOW = _WINDOW;
  const DOCUMENT = _DOCUMENT;
  const IS_BROWSER = !!WINDOW.document;
  const IS_DOM = !!DOCUMENT.documentElement &amp;&amp; !!DOCUMENT.head &amp;&amp; typeof DOCUMENT.addEventListener === &#039;function&#039; &amp;&amp; typeof DOCUMENT.createElement === &#039;function&#039;;
  const IS_IE = ~userAgent.indexOf(&#039;MSIE&#039;) || ~userAgent.indexOf(&#039;Trident/&#039;);

  const functions = [];
  const listener = function () {
    DOCUMENT.removeEventListener(&#039;DOMContentLoaded&#039;, listener);
    loaded = 1;
    functions.map(fn =&gt; fn());
  };
  let loaded = false;
  if (IS_DOM) {
    loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
    if (!loaded) DOCUMENT.addEventListener(&#039;DOMContentLoaded&#039;, listener);
  }
  function domready (fn) {
    if (!IS_DOM) return;
    loaded ? setTimeout(fn, 0) : functions.push(fn);
  }

  function report (_ref) {
    let {
      nodesTested,
      nodesFound
    } = _ref;
    const timedOutTests = {};
    for (let key in nodesFound) {
      if (!(nodesTested.conflict[key] || nodesTested.noConflict[key])) {
        timedOutTests[key] = nodesFound[key];
      }
    }
    const conflictsCount = Object.keys(nodesTested.conflict).length;
    if (conflictsCount &gt; 0) {
      console.info(&quot;%cConflict&quot;.concat(conflictsCount &gt; 1 ? &#039;s&#039; : &#039;&#039;, &quot; found:&quot;), &#039;color: darkred; font-size: large&#039;);
      const data = {};
      for (let key in nodesTested.conflict) {
        const item = nodesTested.conflict[key];
        data[key] = {
          &#039;tagName&#039;: item.tagName,
          &#039;src/href&#039;: item.src || item.href || &#039;n/a&#039;,
          &#039;innerText excerpt&#039;: item.innerText &amp;&amp; item.innerText !== &#039;&#039; ? item.innerText.slice(0, 200) + &#039;...&#039; : &#039;(empty)&#039;
        };
      }
      console.table(data);
    }
    const noConflictsCount = Object.keys(nodesTested.noConflict).length;
    if (noConflictsCount &gt; 0) {
      console.info(&quot;%cNo conflict&quot;.concat(noConflictsCount &gt; 1 ? &#039;s&#039; : &#039;&#039;, &quot; found with &quot;).concat(noConflictsCount === 1 ? &#039;this&#039; : &#039;these&#039;, &quot;:&quot;), &#039;color: green; font-size: large&#039;);
      const data = {};
      for (let key in nodesTested.noConflict) {
        const item = nodesTested.noConflict[key];
        data[key] = {
          &#039;tagName&#039;: item.tagName,
          &#039;src/href&#039;: item.src || item.href || &#039;n/a&#039;,
          &#039;innerText excerpt&#039;: item.innerText &amp;&amp; item.innerText !== &#039;&#039; ? item.innerText.slice(0, 200) + &#039;...&#039; : &#039;(empty)&#039;
        };
      }
      console.table(data);
    }
    const timeOutCount = Object.keys(timedOutTests).length;
    if (timeOutCount &gt; 0) {
      console.info(&quot;%cLeftovers--we timed out before collecting test results for &quot;.concat(timeOutCount === 1 ? &#039;this&#039; : &#039;these&#039;, &quot;:&quot;), &#039;color: blue; font-size: large&#039;);
      const data = {};
      for (let key in timedOutTests) {
        const item = timedOutTests[key];
        data[key] = {
          &#039;tagName&#039;: item.tagName,
          &#039;src/href&#039;: item.src || item.href || &#039;n/a&#039;,
          &#039;innerText excerpt&#039;: item.innerText &amp;&amp; item.innerText !== &#039;&#039; ? item.innerText.slice(0, 200) + &#039;...&#039; : &#039;(empty)&#039;
        };
      }
      console.table(data);
    }
  }

  var commonjsGlobal = typeof window !== &#039;undefined&#039; ? window : typeof global !== &#039;undefined&#039; ? global : typeof self !== &#039;undefined&#039; ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var md5 = createCommonjsModule(function (module) {
    (function ($) {

      /**
       * Add integers, wrapping at 2^32.
       * This uses 16-bit operations internally to work around bugs in interpreters.
       *
       * @param {number} x First integer
       * @param {number} y Second integer
       * @returns {number} Sum
       */
      function safeAdd(x, y) {
        var lsw = (x &amp; 0xffff) + (y &amp; 0xffff);
        var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
        return msw &lt;&lt; 16 | lsw &amp; 0xffff;
      }

      /**
       * Bitwise rotate a 32-bit number to the left.
       *
       * @param {number} num 32-bit number
       * @param {number} cnt Rotation count
       * @returns {number} Rotated number
       */
      function bitRotateLeft(num, cnt) {
        return num &lt;&lt; cnt | num &gt;&gt;&gt; 32 - cnt;
      }

      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} q q
       * @param {number} a a
       * @param {number} b b
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */
      function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */
      function md5ff(a, b, c, d, x, s, t) {
        return md5cmn(b &amp; c | ~b &amp; d, a, b, x, s, t);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */
      function md5gg(a, b, c, d, x, s, t) {
        return md5cmn(b &amp; d | c &amp; ~d, a, b, x, s, t);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */
      function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */
      function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
      }

      /**
       * Calculate the MD5 of an array of little-endian words, and a bit length.
       *
       * @param {Array} x Array of little-endian words
       * @param {number} len Bit length
       * @returns {Array&lt;number&gt;} MD5 Array
       */
      function binlMD5(x, len) {
        /* append padding */
        x[len &gt;&gt; 5] |= 0x80 &lt;&lt; len % 32;
        x[(len + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = len;
        var i;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for (i = 0; i &lt; x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;
          a = md5ff(a, b, c, d, x[i], 7, -680876936);
          d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5gg(b, c, d, a, x[i], 20, -373897302);
          a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5hh(d, a, b, c, x[i], 11, -358537222);
          c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5ii(a, b, c, d, x[i], 6, -198630844);
          d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safeAdd(a, olda);
          b = safeAdd(b, oldb);
          c = safeAdd(c, oldc);
          d = safeAdd(d, oldd);
        }
        return [a, b, c, d];
      }

      /**
       * Convert an array of little-endian words to a string
       *
       * @param {Array&lt;number&gt;} input MD5 Array
       * @returns {string} MD5 string
       */
      function binl2rstr(input) {
        var i;
        var output = &#039;&#039;;
        var length32 = input.length * 32;
        for (i = 0; i &lt; length32; i += 8) {
          output += String.fromCharCode(input[i &gt;&gt; 5] &gt;&gt;&gt; i % 32 &amp; 0xff);
        }
        return output;
      }

      /**
       * Convert a raw string to an array of little-endian words
       * Characters &gt;255 have their high-byte silently ignored.
       *
       * @param {string} input Raw input string
       * @returns {Array&lt;number&gt;} Array of little-endian words
       */
      function rstr2binl(input) {
        var i;
        var output = [];
        output[(input.length &gt;&gt; 2) - 1] = undefined;
        for (i = 0; i &lt; output.length; i += 1) {
          output[i] = 0;
        }
        var length8 = input.length * 8;
        for (i = 0; i &lt; length8; i += 8) {
          output[i &gt;&gt; 5] |= (input.charCodeAt(i / 8) &amp; 0xff) &lt;&lt; i % 32;
        }
        return output;
      }

      /**
       * Calculate the MD5 of a raw string
       *
       * @param {string} s Input string
       * @returns {string} Raw MD5 string
       */
      function rstrMD5(s) {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
      }

      /**
       * Calculates the HMAC-MD5 of a key and some data (raw strings)
       *
       * @param {string} key HMAC key
       * @param {string} data Raw input string
       * @returns {string} Raw MD5 string
       */
      function rstrHMACMD5(key, data) {
        var i;
        var bkey = rstr2binl(key);
        var ipad = [];
        var opad = [];
        var hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length &gt; 16) {
          bkey = binlMD5(bkey, key.length * 8);
        }
        for (i = 0; i &lt; 16; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5c5c5c5c;
        }
        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
      }

      /**
       * Convert a raw string to a hex string
       *
       * @param {string} input Raw input string
       * @returns {string} Hex encoded string
       */
      function rstr2hex(input) {
        var hexTab = &#039;0123456789abcdef&#039;;
        var output = &#039;&#039;;
        var x;
        var i;
        for (i = 0; i &lt; input.length; i += 1) {
          x = input.charCodeAt(i);
          output += hexTab.charAt(x &gt;&gt;&gt; 4 &amp; 0x0f) + hexTab.charAt(x &amp; 0x0f);
        }
        return output;
      }

      /**
       * Encode a string as UTF-8
       *
       * @param {string} input Input string
       * @returns {string} UTF8 string
       */
      function str2rstrUTF8(input) {
        return unescape(encodeURIComponent(input));
      }

      /**
       * Encodes input string as raw MD5 string
       *
       * @param {string} s Input string
       * @returns {string} Raw MD5 string
       */
      function rawMD5(s) {
        return rstrMD5(str2rstrUTF8(s));
      }
      /**
       * Encodes input string as Hex encoded string
       *
       * @param {string} s Input string
       * @returns {string} Hex encoded string
       */
      function hexMD5(s) {
        return rstr2hex(rawMD5(s));
      }
      /**
       * Calculates the raw HMAC-MD5 for the given key and data
       *
       * @param {string} k HMAC key
       * @param {string} d Input string
       * @returns {string} Raw MD5 string
       */
      function rawHMACMD5(k, d) {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
      }
      /**
       * Calculates the Hex encoded HMAC-MD5 for the given key and data
       *
       * @param {string} k HMAC key
       * @param {string} d Input string
       * @returns {string} Raw MD5 string
       */
      function hexHMACMD5(k, d) {
        return rstr2hex(rawHMACMD5(k, d));
      }

      /**
       * Calculates MD5 value for a given string.
       * If a key is provided, calculates the HMAC-MD5 value.
       * Returns a Hex encoded string unless the raw argument is given.
       *
       * @param {string} string Input string
       * @param {string} [key] HMAC key
       * @param {boolean} [raw] Raw output switch
       * @returns {string} MD5 output
       */
      function md5(string, key, raw) {
        if (!key) {
          if (!raw) {
            return hexMD5(string);
          }
          return rawMD5(string);
        }
        if (!raw) {
          return hexHMACMD5(key, string);
        }
        return rawHMACMD5(key, string);
      }
      if (module.exports) {
        module.exports = md5;
      } else {
        $.md5 = md5;
      }
    })(commonjsGlobal);
  });

  function md5ForNode(node) {
    if (null === node || &#039;object&#039; !== typeof node) return undefined;
    if (node.src) {
      return md5(node.src);
    } else if (node.href) {
      return md5(node.href);
    } else if (node.innerText &amp;&amp; &#039;&#039; !== node.innerText) {
      // eslint-disable-line yoda
      return md5(node.innerText);
    } else {
      return undefined;
    }
  }

  const diagScriptId = &#039;fa-kits-diag&#039;;
  const nodeUnderTestId = &#039;fa-kits-node-under-test&#039;;
  const md5Attr = &#039;data-md5&#039;;
  const detectionIgnoreAttr = &#039;data-fa-detection-ignore&#039;;
  const timeoutAttr = &#039;data-fa-detection-timeout&#039;;
  const resultsCollectionMaxWaitAttr = &#039;data-fa-detection-results-collection-max-wait&#039;;
  const silenceErrors = e =&gt; {
    e.preventDefault();
    e.stopPropagation();
  };
  function pollUntil(_ref) {
    let {
      fn = () =&gt; true,
      initialDuration = 1,
      maxDuration = WINDOW.FontAwesomeDetection.timeout,
      showProgress = false,
      progressIndicator
    } = _ref;
    return new Promise(function (resolve, reject) {
      // eslint-disable-line compat/compat
      function poll(duration, cumulativeDuration) {
        setTimeout(function () {
          const result = fn();
          if (showProgress) {
            console.info(progressIndicator);
          }
          if (!!result) {
            // eslint-disable-line no-extra-boolean-cast
            resolve(result);
          } else {
            const nextDuration = 250;
            const nextCumulativeDuration = nextDuration + cumulativeDuration;
            if (nextCumulativeDuration &lt;= maxDuration) {
              poll(nextDuration, nextCumulativeDuration);
            } else {
              reject(&#039;timeout&#039;); // eslint-disable-line prefer-promise-reject-errors
            }
          }
        }, duration);
      }
      poll(initialDuration, 0);
    });
  }
  function detectWebfontConflicts() {
    const linkTags = Array.from(DOCUMENT.getElementsByTagName(&#039;link&#039;)).filter(t =&gt; !t.hasAttribute(detectionIgnoreAttr));
    const styleTags = Array.from(DOCUMENT.getElementsByTagName(&#039;style&#039;)).filter(t =&gt; {
      if (t.hasAttribute(detectionIgnoreAttr)) {
        return false;
      }

      // If the browser has loaded the FA5 CSS, let&#039;s not test that &lt;style&gt; element.
      // Its enough that we&#039;ll be testing for traces of the corresponding JS being loaded, and testing
      // this &lt;style&gt; would only produce a false negative anyway.
      if (WINDOW.FontAwesomeConfig &amp;&amp; t.innerText.match(new RegExp(&quot;svg:not\\(:root\\)\\.&quot;.concat(WINDOW.FontAwesomeConfig.replacementClass)))) {
        return false;
      }
      return true;
    });
    function runDiag(scriptOrLinkTag, md5) {
      const diagFrame = DOCUMENT.createElement(&#039;iframe&#039;);
      // Using &quot;visibility: hidden; position: absolute&quot; instead of &quot;display: none;&quot; because
      // Firefox will not return the expected results for getComputedStyle if our iframe has display: none.
      diagFrame.setAttribute(&#039;style&#039;, &#039;visibility: hidden; position: absolute; height: 0; width: 0;&#039;);
      const testIconId = &#039;fa-test-icon-&#039; + md5;
      const iTag = DOCUMENT.createElement(&#039;i&#039;);
      iTag.setAttribute(&#039;class&#039;, &#039;fa fa-coffee&#039;);
      iTag.setAttribute(&#039;id&#039;, testIconId);
      const diagScript = DOCUMENT.createElement(&#039;script&#039;);
      diagScript.setAttribute(&#039;id&#039;, diagScriptId);

      // WARNING: this function will be toString()&#039;d and assigned to innerText of the diag script
      // element that we&#039;ll be putting into a diagnostic iframe.
      // That means that this code won&#039;t compile until after the outer script has run and injected
      // this code into the iframe. There are some compile time errors that might occur there.
      // For example, using single line (double-slash) comments like this one inside that function
      // will probably cause it to choke. Chrome will show an error like this:
      // Uncaught SyntaxError: Unexpected end of input
      const diagScriptFun = (nodeUnderTestId, testIconId, md5, parentOrigin) =&gt; {
        parent.FontAwesomeDetection.__pollUntil({
          fn: () =&gt; {
            const iEl = document.getElementById(testIconId);
            const computedStyle = window.getComputedStyle(iEl);
            const fontFamily = computedStyle.getPropertyValue(&#039;font-family&#039;);
            if (!!fontFamily.match(/FontAwesome/) || !!fontFamily.match(/Font Awesome [56]/)) {
              return true;
            } else {
              return false;
            }
          }
        }).then(() =&gt; {
          const node = document.getElementById(nodeUnderTestId);
          parent.postMessage({
            type: &#039;fontawesome-conflict&#039;,
            technology: &#039;webfont&#039;,
            href: node.href,
            innerText: node.innerText,
            tagName: node.tagName,
            md5
          }, parentOrigin);
        }).catch(function (e) {
          const node = document.getElementById(nodeUnderTestId);
          if (e === &#039;timeout&#039;) {
            parent.postMessage({
              type: &#039;no-conflict&#039;,
              technology: &#039;webfont&#039;,
              href: node.src,
              innerText: node.innerText,
              tagName: node.tagName,
              md5
            }, parentOrigin);
          } else {
            console.error(e);
          }
        });
      };
      const parentOrigin = WINDOW.location.origin === &#039;file://&#039; ? &#039;*&#039; : WINDOW.location.origin;
      diagScript.innerText = &quot;(&quot;.concat(diagScriptFun.toString(), &quot;)(&#039;&quot;).concat(nodeUnderTestId, &quot;&#039;, &#039;&quot;).concat(testIconId || &#039;foo&#039;, &quot;&#039;, &#039;&quot;).concat(md5, &quot;&#039;, &#039;&quot;).concat(parentOrigin, &quot;&#039;);&quot;);
      diagFrame.onload = function () {
        diagFrame.contentWindow.addEventListener(&#039;error&#039;, silenceErrors, true);
        diagFrame.contentDocument.head.appendChild(diagScript);
        diagFrame.contentDocument.head.appendChild(scriptOrLinkTag);
        diagFrame.contentDocument.body.appendChild(iTag);
      };
      domready(() =&gt; DOCUMENT.body.appendChild(diagFrame));
    }
    const cssByMD5 = {};
    for (let i = 0; i &lt; linkTags.length; i++) {
      const linkUnderTest = DOCUMENT.createElement(&#039;link&#039;);
      linkUnderTest.setAttribute(&#039;id&#039;, nodeUnderTestId);
      linkUnderTest.setAttribute(&#039;href&#039;, linkTags[i].href);
      linkUnderTest.setAttribute(&#039;rel&#039;, linkTags[i].rel);
      const md5ForLink = md5ForNode(linkTags[i]);
      linkUnderTest.setAttribute(md5Attr, md5ForLink);
      cssByMD5[md5ForLink] = linkTags[i];
      runDiag(linkUnderTest, md5ForLink);
    }
    for (let i = 0; i &lt; styleTags.length; i++) {
      var styleUnderTest = DOCUMENT.createElement(&#039;style&#039;);
      styleUnderTest.setAttribute(&#039;id&#039;, nodeUnderTestId);
      const md5ForStyle = md5ForNode(styleTags[i]);
      styleUnderTest.setAttribute(md5Attr, md5ForStyle);
      styleUnderTest.innerText = styleTags[i].innerText;
      cssByMD5[md5ForStyle] = styleTags[i];
      runDiag(styleUnderTest, md5ForStyle);
    }
    return cssByMD5;
  }
  function detectSvgConflicts(currentScript) {
    const scripts = Array.from(DOCUMENT.scripts).filter(t =&gt; !t.hasAttribute(detectionIgnoreAttr) &amp;&amp; t !== currentScript);
    const scriptsByMD5 = {};
    for (let scriptIdx = 0; scriptIdx &lt; scripts.length; scriptIdx++) {
      const diagFrame = DOCUMENT.createElement(&#039;iframe&#039;);
      diagFrame.setAttribute(&#039;style&#039;, &#039;display:none;&#039;);
      const scriptUnderTest = DOCUMENT.createElement(&#039;script&#039;);
      scriptUnderTest.setAttribute(&#039;id&#039;, nodeUnderTestId);
      const md5ForScript = md5ForNode(scripts[scriptIdx]);
      scriptUnderTest.setAttribute(md5Attr, md5ForScript);
      scriptsByMD5[md5ForScript] = scripts[scriptIdx];
      if (scripts[scriptIdx].src !== &#039;&#039;) {
        scriptUnderTest.src = scripts[scriptIdx].src;
      }
      if (scripts[scriptIdx].innerText !== &#039;&#039;) {
        scriptUnderTest.innerText = scripts[scriptIdx].innerText;
      }
      scriptUnderTest.async = true;
      const diagScript = DOCUMENT.createElement(&#039;script&#039;);
      diagScript.setAttribute(&#039;id&#039;, diagScriptId);
      const parentOrigin = WINDOW.location.origin === &#039;file://&#039; ? &#039;*&#039; : WINDOW.location.origin;
      const diagScriptFun = (nodeUnderTestId, md5, parentOrigin) =&gt; {
        parent.FontAwesomeDetection.__pollUntil({
          fn: () =&gt; {
            return !!window.FontAwesomeConfig || !!window.FontAwesomeKitConfig;
          }
        }).then(function () {
          const scriptNode = document.getElementById(nodeUnderTestId);
          parent.postMessage({
            type: &#039;fontawesome-conflict&#039;,
            technology: &#039;js&#039;,
            src: scriptNode.src,
            innerText: scriptNode.innerText,
            tagName: scriptNode.tagName,
            md5
          }, parentOrigin);
        }).catch(function (e) {
          var scriptNode = document.getElementById(nodeUnderTestId);
          if (e === &#039;timeout&#039;) {
            parent.postMessage({
              type: &#039;no-conflict&#039;,
              src: scriptNode.src,
              innerText: scriptNode.innerText,
              tagName: scriptNode.tagName,
              md5
            }, parentOrigin);
          } else {
            console.error(e);
          }
        });
      };
      diagScript.innerText = &quot;(&quot;.concat(diagScriptFun.toString(), &quot;)(&#039;&quot;).concat(nodeUnderTestId, &quot;&#039;, &#039;&quot;).concat(md5ForScript, &quot;&#039;, &#039;&quot;).concat(parentOrigin, &quot;&#039;);&quot;);
      diagFrame.onload = function () {
        diagFrame.contentWindow.addEventListener(&#039;error&#039;, silenceErrors, true);
        diagFrame.contentDocument.head.appendChild(diagScript);
        diagFrame.contentDocument.head.appendChild(scriptUnderTest);
      };
      domready(() =&gt; DOCUMENT.body.appendChild(diagFrame));
    }
    return scriptsByMD5;
  }
  function setDoneResults(_ref2) {
    let {
      nodesTested,
      nodesFound
    } = _ref2;
    WINDOW.FontAwesomeDetection = WINDOW.FontAwesomeDetection || {};
    WINDOW.FontAwesomeDetection.nodesTested = nodesTested;
    WINDOW.FontAwesomeDetection.nodesFound = nodesFound;
    WINDOW.FontAwesomeDetection.detectionDone = true;
  }
  function conflictDetection() {
    let report$$1 = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : () =&gt; {};
    const nodesTested = {
      conflict: {},
      noConflict: {}
    };
    WINDOW.onmessage = function (e) {
      if (WINDOW.location.origin === &#039;file://&#039; || e.origin === WINDOW.location.origin) {
        if (e &amp;&amp; e.data) {
          if (e.data.type === &#039;fontawesome-conflict&#039;) {
            nodesTested.conflict[e.data.md5] = e.data;
          } else if (e.data.type === &#039;no-conflict&#039;) {
            nodesTested.noConflict[e.data.md5] = e.data;
          }
        }
      }
    };
    const scriptsToTest = detectSvgConflicts(DOCUMENT.currentScript);
    const cssToTest = detectWebfontConflicts();
    const nodesFound = _objectSpread2(_objectSpread2({}, scriptsToTest), cssToTest);
    const testCount = Object.keys(scriptsToTest).length + Object.keys(cssToTest).length;

    // The resultsCollectionMaxWait allows for the time between when the tests running under
    // child iframes call postMessage with their results, and when the parent window
    // receives and handles those events with window.onmessage.
    // Making it configurable allows us to test the scenario where this timeout is exceeded.
    // Naming it something very different from &quot;timeout&quot; is to help avoid the potential ambiguity between
    // these two timeout-related settings.
    const masterTimeout = WINDOW.FontAwesomeDetection.timeout + WINDOW.FontAwesomeDetection.resultsCollectionMaxWait;
    console.group(&#039;Font Awesome Detector&#039;);
    if (testCount === 0) {
      console.info(&#039;%cAll Good!&#039;, &#039;color: green; font-size: large&#039;);
      console.info(&#039;We didn\&#039;t find anything that needs testing for conflicts. Ergo, no conflicts.&#039;);
    } else {
      console.info(&quot;Testing &quot;.concat(testCount, &quot; possible conflicts.&quot;));
      console.info(&quot;We&#039;ll wait about &quot;.concat(Math.round(WINDOW.FontAwesomeDetection.timeout / 10) / 100, &quot; seconds while testing these and\n&quot;) + &quot;then up to another &quot;.concat(Math.round(WINDOW.FontAwesomeDetection.resultsCollectionMaxWait / 10) / 100, &quot; to allow the browser time\n&quot;) + &quot;to accumulate the results. But we&#039;ll probably be outta here way before then.\n\n&quot;);
      console.info(&quot;You can adjust those durations by assigning values to these attributes on the &lt;script&gt; element that loads this detection:&quot;);
      console.info(&quot;\t%c&quot;.concat(timeoutAttr, &quot;%c: milliseconds to wait for each test before deciding whether it&#039;s a conflict.&quot;), &#039;font-weight: bold;&#039;, &#039;font-size: normal;&#039;);
      console.info(&quot;\t%c&quot;.concat(resultsCollectionMaxWaitAttr, &quot;%c: milliseconds to wait for the browser to accumulate test results before giving up.&quot;), &#039;font-weight: bold;&#039;, &#039;font-size: normal;&#039;);
      pollUntil({
        // Give this overall timer a little extra cushion
        maxDuration: masterTimeout,
        showProgress: true,
        progressIndicator: &#039;waiting...&#039;,
        fn: () =&gt; {
          return Object.keys(nodesTested.conflict).length + Object.keys(nodesTested.noConflict).length &gt;= testCount;
        }
      }).then(() =&gt; {
        console.info(&#039;DONE!&#039;);
        setDoneResults({
          nodesTested,
          nodesFound
        });
        report$$1({
          nodesTested,
          nodesFound
        });
        console.groupEnd();
      }).catch(e =&gt; {
        if (e === &#039;timeout&#039;) {
          console.info(&#039;TIME OUT! We waited until we got tired. Here\&#039;s what we found:&#039;);
          setDoneResults({
            nodesTested,
            nodesFound
          });
          report$$1({
            nodesTested,
            nodesFound
          });
        } else {
          console.info(&#039;Whoops! We hit an error:&#039;, e);
          console.info(&#039;Here\&#039;s what we\&#039;d found up until that error:&#039;);
          setDoneResults({
            nodesTested,
            nodesFound
          });
          report$$1({
            nodesTested,
            nodesFound
          });
        }
        console.groupEnd();
      });
    }
  }

  // Allow clients to access, and in some cases, override some properties
  const initialConfig = WINDOW.FontAwesomeDetection || {};

  // These can be overridden
  const _default = {
    report,
    timeout: +(DOCUMENT.currentScript.getAttribute(timeoutAttr) || &quot;2000&quot;),
    resultsCollectionMaxWait: +(DOCUMENT.currentScript.getAttribute(resultsCollectionMaxWaitAttr) || &quot;5000&quot;)
  };
  const _config = _objectSpread2(_objectSpread2(_objectSpread2({}, _default), initialConfig), {}, {
    // These cannot be overridden
    __pollUntil: pollUntil,
    md5ForNode,
    detectionDone: false,
    nodesTested: null,
    nodesFound: null
  });
  WINDOW.FontAwesomeDetection = _config;

  var S = {
      classic: {
        fa: &quot;solid&quot;,
        fas: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        far: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fal: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fat: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;,
        fab: &quot;brands&quot;,
        &quot;fa-brands&quot;: &quot;brands&quot;
      },
      duotone: {
        fa: &quot;solid&quot;,
        fad: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        &quot;fa-duotone&quot;: &quot;solid&quot;,
        fadr: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fadl: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fadt: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;
      },
      sharp: {
        fa: &quot;solid&quot;,
        fass: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        fasr: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fasl: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fast: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;
      },
      &quot;sharp-duotone&quot;: {
        fa: &quot;solid&quot;,
        fasds: &quot;solid&quot;,
        &quot;fa-solid&quot;: &quot;solid&quot;,
        fasdr: &quot;regular&quot;,
        &quot;fa-regular&quot;: &quot;regular&quot;,
        fasdl: &quot;light&quot;,
        &quot;fa-light&quot;: &quot;light&quot;,
        fasdt: &quot;thin&quot;,
        &quot;fa-thin&quot;: &quot;thin&quot;
      }
    };
  var s = &quot;classic&quot;;
  var G = {
      classic: {
        900: &quot;fas&quot;,
        400: &quot;far&quot;,
        normal: &quot;far&quot;,
        300: &quot;fal&quot;,
        100: &quot;fat&quot;
      },
      duotone: {
        900: &quot;fad&quot;,
        400: &quot;fadr&quot;,
        300: &quot;fadl&quot;,
        100: &quot;fadt&quot;
      },
      sharp: {
        900: &quot;fass&quot;,
        400: &quot;fasr&quot;,
        300: &quot;fasl&quot;,
        100: &quot;fast&quot;
      },
      &quot;sharp-duotone&quot;: {
        900: &quot;fasds&quot;,
        400: &quot;fasdr&quot;,
        300: &quot;fasdl&quot;,
        100: &quot;fasdt&quot;
      }
    };
  var xt = {
      classic: {
        solid: &quot;fas&quot;,
        regular: &quot;far&quot;,
        light: &quot;fal&quot;,
        thin: &quot;fat&quot;,
        brands: &quot;fab&quot;
      },
      duotone: {
        solid: &quot;fad&quot;,
        regular: &quot;fadr&quot;,
        light: &quot;fadl&quot;,
        thin: &quot;fadt&quot;
      },
      sharp: {
        solid: &quot;fass&quot;,
        regular: &quot;fasr&quot;,
        light: &quot;fasl&quot;,
        thin: &quot;fast&quot;
      },
      &quot;sharp-duotone&quot;: {
        solid: &quot;fasds&quot;,
        regular: &quot;fasdr&quot;,
        light: &quot;fasdl&quot;,
        thin: &quot;fasdt&quot;
      }
    };
  var St = {
      kit: {
        fak: &quot;kit&quot;,
        &quot;fa-kit&quot;: &quot;kit&quot;
      },
      &quot;kit-duotone&quot;: {
        fakd: &quot;kit-duotone&quot;,
        &quot;fa-kit-duotone&quot;: &quot;kit-duotone&quot;
      }
    };
  var Ct = {
    kit: {
      &quot;fa-kit&quot;: &quot;fak&quot;
    },
    &quot;kit-duotone&quot;: {
      &quot;fa-kit-duotone&quot;: &quot;fakd&quot;
    }
  };
  var Wt = {
      kit: {
        fak: &quot;fa-kit&quot;
      },
      &quot;kit-duotone&quot;: {
        fakd: &quot;fa-kit-duotone&quot;
      }
    };
  var Et = {
      kit: {
        kit: &quot;fak&quot;
      },
      &quot;kit-duotone&quot;: {
        &quot;kit-duotone&quot;: &quot;fakd&quot;
      }
    };

  var ua = {
      classic: {
        &quot;fa-brands&quot;: &quot;fab&quot;,
        &quot;fa-duotone&quot;: &quot;fad&quot;,
        &quot;fa-light&quot;: &quot;fal&quot;,
        &quot;fa-regular&quot;: &quot;far&quot;,
        &quot;fa-solid&quot;: &quot;fas&quot;,
        &quot;fa-thin&quot;: &quot;fat&quot;
      },
      duotone: {
        &quot;fa-regular&quot;: &quot;fadr&quot;,
        &quot;fa-light&quot;: &quot;fadl&quot;,
        &quot;fa-thin&quot;: &quot;fadt&quot;
      },
      sharp: {
        &quot;fa-solid&quot;: &quot;fass&quot;,
        &quot;fa-regular&quot;: &quot;fasr&quot;,
        &quot;fa-light&quot;: &quot;fasl&quot;,
        &quot;fa-thin&quot;: &quot;fast&quot;
      },
      &quot;sharp-duotone&quot;: {
        &quot;fa-solid&quot;: &quot;fasds&quot;,
        &quot;fa-regular&quot;: &quot;fasdr&quot;,
        &quot;fa-light&quot;: &quot;fasdl&quot;,
        &quot;fa-thin&quot;: &quot;fasdt&quot;
      }
    },
    ga = {
      classic: {
        fab: &quot;fa-brands&quot;,
        fad: &quot;fa-duotone&quot;,
        fal: &quot;fa-light&quot;,
        far: &quot;fa-regular&quot;,
        fas: &quot;fa-solid&quot;,
        fat: &quot;fa-thin&quot;
      },
      duotone: {
        fadr: &quot;fa-regular&quot;,
        fadl: &quot;fa-light&quot;,
        fadt: &quot;fa-thin&quot;
      },
      sharp: {
        fass: &quot;fa-solid&quot;,
        fasr: &quot;fa-regular&quot;,
        fasl: &quot;fa-light&quot;,
        fast: &quot;fa-thin&quot;
      },
      &quot;sharp-duotone&quot;: {
        fasds: &quot;fa-solid&quot;,
        fasdr: &quot;fa-regular&quot;,
        fasdl: &quot;fa-light&quot;,
        fasdt: &quot;fa-thin&quot;
      }
    };

  const PRODUCTION = (() =&gt; {
    try {
      return process.env.NODE_ENV === &#039;production&#039;;
    } catch (e$$1) {
      return false;
    }
  })();
  function familyProxy(obj) {
    // Defaults to the classic family if family is not available
    return new Proxy(obj, {
      get(target, prop) {
        return prop in target ? target[prop] : target[s];
      }
    });
  }
  const _PREFIX_TO_STYLE = _objectSpread2({}, S);

  // We changed FACSSClassesToStyleId in the icons repo to be canonical and as such, &quot;classic&quot; family does not have any
  // duotone styles.  But we do still need duotone in _PREFIX_TO_STYLE below, so we are manually adding
  // {&#039;fa-duotone&#039;: &#039;duotone&#039;}
  _PREFIX_TO_STYLE[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    &#039;fa-duotone&#039;: &#039;duotone&#039;
  }), S[s]), St[&#039;kit&#039;]), St[&#039;kit-duotone&#039;]);
  const PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
  const _STYLE_TO_PREFIX = _objectSpread2({}, xt);

  // We changed FAStyleIdToShortPrefixId in the icons repo to be canonical and as such, &quot;classic&quot; family does not have any
  // duotone styles.  But we do still need duotone in _STYLE_TO_PREFIX below, so we are manually adding {duotone: &#039;fad&#039;}
  _STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    duotone: &#039;fad&#039;
  }), _STYLE_TO_PREFIX[s]), Et[&#039;kit&#039;]), Et[&#039;kit-duotone&#039;]);
  const STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
  const _PREFIX_TO_LONG_STYLE = _objectSpread2({}, ga);
  _PREFIX_TO_LONG_STYLE[s] = _objectSpread2(_objectSpread2({}, _PREFIX_TO_LONG_STYLE[s]), Wt[&#039;kit&#039;]);
  const PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
  const _LONG_STYLE_TO_PREFIX = _objectSpread2({}, ua);
  _LONG_STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2({}, _LONG_STYLE_TO_PREFIX[s]), Ct[&#039;kit&#039;]);
  const LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
  const _FONT_WEIGHT_TO_PREFIX = _objectSpread2({}, G);
  const FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);

  function bunker(fn) {
    try {
      for (var _len = arguments.length, args = new Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      fn(...args);
    } catch (e) {
      if (!PRODUCTION) {
        throw e;
      }
    }
  }

  bunker(() =&gt; {
    if (IS_BROWSER &amp;&amp; IS_DOM) {
      conflictDetection(window.FontAwesomeDetection.report);
    }
  });

})));
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
