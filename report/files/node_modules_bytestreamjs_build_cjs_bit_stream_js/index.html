<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bytestreamjs/build/cjs/bit_stream.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bytestreamjs/build/cjs/bit_stream.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">401</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">168.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.17</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.BitStream = void 0;
const bit_1 = require(&quot;./bit&quot;);
const byte_stream_1 = require(&quot;./byte_stream&quot;);
class BitStream {
    constructor(parameters) {
        this.buffer = new ArrayBuffer(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = 0;
        if (parameters) {
            if (&quot;byteStream&quot; in parameters) {
                this.fromByteStream(parameters.byteStream);
            }
            if (&quot;view&quot; in parameters) {
                this.fromUint8Array(parameters.view);
            }
            if (&quot;buffer&quot; in parameters) {
                this.fromArrayBuffer(parameters.buffer);
            }
            if (&quot;string&quot; in parameters) {
                this.fromString(parameters.string);
            }
            if (&quot;uint32&quot; in parameters) {
                this.fromUint32(parameters.uint32);
            }
            if (&quot;bitsCount&quot; in parameters &amp;&amp; parameters.bitsCount) {
                this.bitsCount = parameters.bitsCount;
            }
        }
    }
    clear() {
        this.buffer = new ArrayBuffer(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = 0;
    }
    fromByteStream(stream) {
        this.fromUint8Array(stream.view);
    }
    fromArrayBuffer(array) {
        this.buffer = array;
        this.view = new Uint8Array(array);
        this.bitsCount = this.view.length &lt;&lt; 3;
    }
    fromUint8Array(array) {
        this.fromArrayBuffer(new Uint8Array(array).buffer);
    }
    fromString(string) {
        const stringLength = string.length;
        this.buffer = new ArrayBuffer((stringLength &gt;&gt; 3) + ((stringLength % 8) ? 1 : 0));
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = ((stringLength &gt;&gt; 3) + 1) &lt;&lt; 3;
        let byteIndex = 0;
        for (let i = 0; i &lt; stringLength; i++) {
            if (string[i] == &quot;1&quot;)
                this.view[byteIndex] |= 1 &lt;&lt; (7 - (i % 8));
            if (i &amp;&amp; (((i + 1) % 8) == 0))
                byteIndex++;
        }
        if (stringLength % 8)
            this.shiftRight(8 - (stringLength % 8));
        this.bitsCount = stringLength;
    }
    fromUint32(uint32) {
        this.buffer = new ArrayBuffer(4);
        this.view = new Uint8Array(this.buffer);
        const value = new Uint32Array([uint32]);
        const view = new Uint8Array(value.buffer);
        for (let i = 3; i &gt;= 0; i--)
            this.view[i] = view[3 - i];
        this.bitsCount = 32;
    }
    toString(start, length) {
        if (start == null) {
            start = 0;
        }
        if ((start &gt;= this.view.length) || (start &lt; 0)) {
            start = 0;
        }
        if (length == null) {
            length = this.view.length - start;
        }
        if ((length &gt;= this.view.length) || (length &lt; 0)) {
            length = this.view.length - start;
        }
        const result = [];
        for (let i = start; i &lt; (start + length); i++) {
            result.push(bit_1.bitsToStringArray[this.view[i]]);
        }
        return result.join(&quot;&quot;).substring((this.view.length &lt;&lt; 3) - this.bitsCount);
    }
    shiftRight(shift, needShrink = true) {
        if (this.view.length == 0) {
            return;
        }
        if ((shift &lt; 0) || (shift &gt; 8)) {
            throw new Error(&quot;The \&quot;shift\&quot; parameter must be in range 0-8&quot;);
        }
        if (shift &gt; this.bitsCount) {
            throw new Error(&quot;The \&quot;shift\&quot; parameter can not be bigger than \&quot;this.bitsCount\&quot;&quot;);
        }
        const shiftMask = 0xFF &gt;&gt; (8 - shift);
        this.view[this.view.length - 1] &gt;&gt;= shift;
        for (let i = (this.view.length - 2); i &gt;= 0; i--) {
            this.view[i + 1] |= (this.view[i] &amp; shiftMask) &lt;&lt; (8 - shift);
            this.view[i] &gt;&gt;= shift;
        }
        this.bitsCount -= shift;
        if (this.bitsCount == 0) {
            this.clear();
        }
        if (needShrink) {
            this.shrink();
        }
    }
    shiftLeft(shift) {
        if (this.view.length == 0) {
            return;
        }
        if ((shift &lt; 0) || (shift &gt; 8)) {
            throw new Error(&quot;The \&quot;shift\&quot; parameter must be in range 0-8&quot;);
        }
        if (shift &gt; this.bitsCount) {
            throw new Error(&quot;The \&quot;shift\&quot; parameter can not be bigger than \&quot;this.bitsCount\&quot;&quot;);
        }
        const bitsOffset = this.bitsCount &amp; 0x07;
        if (bitsOffset &gt; shift) {
            this.view[0] &amp;= 0xFF &gt;&gt; (bitsOffset + shift);
        }
        else {
            const view = this.view.slice(1);
            view[0] &amp;= 0xFF &gt;&gt; (shift - bitsOffset);
            this.buffer = view.buffer;
            this.view = view;
        }
        this.bitsCount -= shift;
        if (this.bitsCount == 0) {
            this.clear();
        }
    }
    slice(start = 0, end = 0) {
        let valueShift = 0;
        if (this.bitsCount % 8) {
            valueShift = (8 - (this.bitsCount % 8));
        }
        start += valueShift;
        end += valueShift;
        const maxEnd = (this.view.length &lt;&lt; 3) - 1;
        if ((start &lt; 0) || (start &gt; maxEnd)) {
            return new BitStream();
        }
        if (!end) {
            end = maxEnd;
        }
        if ((end &lt; 0) || (end &gt; maxEnd)) {
            return new BitStream();
        }
        if ((end - start + 1) &gt; this.bitsCount) {
            return new BitStream();
        }
        const startIndex = start &gt;&gt; 3;
        const startOffset = start &amp; 0x07;
        const endIndex = end &gt;&gt; 3;
        const endOffset = end &amp; 0x07;
        const bitsLength = ((endIndex - startIndex) == 0) ? 1 : (endIndex - startIndex + 1);
        const result = new BitStream({
            buffer: this.buffer.slice(startIndex, startIndex + bitsLength),
            bitsCount: bitsLength &lt;&lt; 3,
        });
        result.view[0] &amp;= (0xFF &gt;&gt; startOffset);
        result.view[bitsLength] &amp;= (0xFF &lt;&lt; (7 - endOffset));
        if (7 - endOffset) {
            result.shiftRight(7 - endOffset, false);
        }
        result.bitsCount = (end - start + 1);
        result.shrink();
        return result;
    }
    copy(start = 0, length = 0) {
        const maxEnd = (this.view.length &lt;&lt; 3) - 1;
        if ((start &lt; 0) || (start &gt; maxEnd)) {
            return new BitStream();
        }
        if (!length) {
            length = (this.view.length &lt;&lt; 3) - start - 1;
        }
        if (length &gt; this.bitsCount) {
            return new BitStream();
        }
        return this.slice(start, start + length - 1);
    }
    shrink() {
        const currentLength = (this.bitsCount &gt;&gt; 3) + ((this.bitsCount % 8) ? 1 : 0);
        if (currentLength &lt; this.view.length) {
            const view = this.view.slice(this.view.length - currentLength, (this.view.length - currentLength) + currentLength);
            this.view = view;
            this.buffer = view.buffer;
        }
    }
    reverseBytes() {
        for (let i = 0; i &lt; this.view.length; i++) {
            this.view[i] = ((this.view[i] * 0x0802 &amp; 0x22110) | (this.view[i] * 0x8020 &amp; 0x88440)) * 0x10101 &gt;&gt; 16;
        }
        if (this.bitsCount % 8) {
            const currentLength = (this.bitsCount &gt;&gt; 3) + ((this.bitsCount % 8) ? 1 : 0);
            this.view[this.view.length - currentLength] &gt;&gt;= (8 - (this.bitsCount &amp; 0x07));
        }
    }
    reverseValue() {
        const initialValue = this.toString();
        const initialValueLength = initialValue.length;
        const reversedValue = new Array(initialValueLength);
        for (let i = 0; i &lt; initialValueLength; i++) {
            reversedValue[initialValueLength - 1 - i] = initialValue[i];
        }
        this.fromString(reversedValue.join(&quot;&quot;));
    }
    getNumberValue() {
        const byteLength = (this.view.length - 1);
        if (byteLength &gt; 3) {
            return (-1);
        }
        if (byteLength == (-1)) {
            return 0;
        }
        const value = new Uint32Array(1);
        const view = new Uint8Array(value.buffer);
        for (let i = byteLength; i &gt;= 0; i--) {
            view[byteLength - i] = this.view[i];
        }
        return value[0];
    }
    findPattern(pattern, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString(),
        });
        const stringPattern = new byte_stream_1.ByteStream({
            string: pattern.toString()
        });
        return stringStream.findPattern(stringPattern, start, length, backward);
    }
    findFirstIn(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString(),
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.findFirstIn(stringPatterns, start, length, backward);
    }
    findAllIn(patterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.findAllIn(stringPatterns, start, length);
    }
    findAllPatternIn(pattern, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPattern = new byte_stream_1.ByteStream({
            string: pattern.toString()
        });
        return stringStream.findAllPatternIn(stringPattern, start, length);
    }
    findFirstNotIn(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.findFirstNotIn(stringPatterns, start, length, backward);
    }
    findAllNotIn(patterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.findAllNotIn(stringPatterns, start, length);
    }
    findFirstSequence(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.findFirstSequence(stringPatterns, start, length, backward);
    }
    findAllSequences(patterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.findAllSequences(stringPatterns, start, length);
    }
    findPairedPatterns(leftPattern, rightPattern, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringLeftPattern = new byte_stream_1.ByteStream({
            string: leftPattern.toString()
        });
        const stringRightPattern = new byte_stream_1.ByteStream({
            string: rightPattern.toString()
        });
        return stringStream.findPairedPatterns(stringLeftPattern, stringRightPattern, start, length);
    }
    findPairedArrays(inputLeftPatterns, inputRightPatterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringLeftPatterns = new Array(inputLeftPatterns.length);
        for (let i = 0; i &lt; inputLeftPatterns.length; i++) {
            stringLeftPatterns[i] = new byte_stream_1.ByteStream({
                string: inputLeftPatterns[i].toString()
            });
        }
        const stringRightPatterns = new Array(inputRightPatterns.length);
        for (let i = 0; i &lt; inputRightPatterns.length; i++) {
            stringRightPatterns[i] = new byte_stream_1.ByteStream({
                string: inputRightPatterns[i].toString()
            });
        }
        return stringStream.findPairedArrays(stringLeftPatterns, stringRightPatterns, start, length);
    }
    replacePattern(searchPattern, replacePattern, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringSearchPattern = new byte_stream_1.ByteStream({
            string: searchPattern.toString()
        });
        const stringReplacePattern = new byte_stream_1.ByteStream({
            string: replacePattern.toString()
        });
        if (stringStream.replacePattern(stringSearchPattern, stringReplacePattern, start, length)) {
            this.fromString(stringStream.toString());
            return true;
        }
        return false;
    }
    skipPatterns(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.skipPatterns(stringPatterns, start, length, backward);
    }
    skipNotPatterns(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
            string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i &lt; patterns.length; i++) {
            stringPatterns[i] = new byte_stream_1.ByteStream({
                string: patterns[i].toString()
            });
        }
        return stringStream.skipNotPatterns(stringPatterns, start, length, backward);
    }
    append(stream) {
        this.fromString([
            this.toString(),
            stream.toString()
        ].join(&quot;&quot;));
    }
}
exports.BitStream = BitStream;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
