<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/build/SignedCertificateTimestampList.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/build/SignedCertificateTimestampList.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">692</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">98.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.73</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
	value: true
});
exports.verifySCTsForCertificate = exports.SignedCertificateTimestamp = undefined;

//**************************************************************************************
/**
 * Verify SignedCertificateTimestamp for specific certificate content
 * @param {Certificate} certificate Certificate for which verification would be performed
 * @param {Certificate} issuerCertificate Certificate of the issuer of target certificate
 * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)
 * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format
 * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format
 * @param {Number} [index=-1] Index of SignedCertificateTimestamp inside SignedCertificateTimestampList (for -1 would verify all)
 * @return {Array} Array of verification results
 */
let verifySCTsForCertificate = exports.verifySCTsForCertificate = (() =&gt; {
	var _ref = _asyncToGenerator(function* (certificate, issuerCertificate, logs, index = -1) {
		//region Initial variables
		let parsedValue = null;
		let tbs;
		let issuerId;

		const stream = new _bytestreamjs.SeqStream();

		let preCert;
		//endregion

		//region Get a &quot;crypto&quot; extension
		const crypto = (0, _common.getCrypto)();
		if (typeof crypto === &quot;undefined&quot;) return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion

		//region Remove certificate extension
		for (let i = 0; i &lt; certificate.extensions.length; i++) {
			switch (certificate.extensions[i].extnID) {
				case &quot;1.3.6.1.4.1.11129.2.4.2&quot;:
					{
						parsedValue = certificate.extensions[i].parsedValue;

						if (parsedValue.timestamps.length === 0) throw new Error(&quot;Nothing to verify in the certificate&quot;);

						certificate.extensions.splice(i, 1);
					}
					break;
				default:
			}
		}
		//endregion

		//region Check we do have what to verify
		if (parsedValue === null) throw new Error(&quot;No SignedCertificateTimestampList extension in the specified certificate&quot;);
		//endregion

		//region Prepare modifier TBS value
		tbs = certificate.encodeTBS().toBER(false);
		//endregion

		//region Initialize &quot;issuer_key_hash&quot; value
		issuerId = yield crypto.digest({ name: &quot;SHA-256&quot; }, new Uint8Array(issuerCertificate.subjectPublicKeyInfo.toSchema().toBER(false)));
		//endregion

		//region Make final &quot;PreCert&quot; value
		stream.appendView(new Uint8Array(issuerId));
		stream.appendUint24(tbs.byteLength);
		stream.appendView(new Uint8Array(tbs));

		preCert = stream._stream._buffer.slice(0, stream._length);
		//endregion

		//region Call verification function for specified index
		if (index === -1) {
			const verifyArray = [];

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = parsedValue.timestamps[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					const timestamp = _step4.value;

					const verifyResult = yield timestamp.verify(logs, preCert, 1);
					verifyArray.push(verifyResult);
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			return verifyArray;
		}

		if (index &gt;= parsedValue.timestamps.length) index = parsedValue.timestamps.length - 1;

		return [yield parsedValue.timestamps[index].verify(logs, preCert, 1)];
		//endregion
	});

	return function verifySCTsForCertificate(_x, _x2, _x3) {
		return _ref.apply(this, arguments);
	};
})();
//**********************************************************************************


var _asn1js = require(&quot;asn1js&quot;);

var asn1js = _interopRequireWildcard(_asn1js);

var _pvutils = require(&quot;pvutils&quot;);

var _bytestreamjs = require(&quot;bytestreamjs&quot;);

var _common = require(&quot;./common.js&quot;);

var _PublicKeyInfo = require(&quot;./PublicKeyInfo.js&quot;);

var _PublicKeyInfo2 = _interopRequireDefault(_PublicKeyInfo);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(&quot;next&quot;, value); }, function (err) { step(&quot;throw&quot;, err); }); } } return step(&quot;next&quot;); }); }; }

//**************************************************************************************
class SignedCertificateTimestamp {
	//**********************************************************************************
	/**
  * Constructor for SignedCertificateTimestamp class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {number}
   * @description version
   */
		this.version = (0, _pvutils.getParametersValue)(parameters, &quot;version&quot;, SignedCertificateTimestamp.defaultValues(&quot;version&quot;));
		/**
   * @type {ArrayBuffer}
   * @description logID
   */
		this.logID = (0, _pvutils.getParametersValue)(parameters, &quot;logID&quot;, SignedCertificateTimestamp.defaultValues(&quot;logID&quot;));
		/**
   * @type {Date}
   * @description timestamp
   */
		this.timestamp = (0, _pvutils.getParametersValue)(parameters, &quot;timestamp&quot;, SignedCertificateTimestamp.defaultValues(&quot;timestamp&quot;));
		/**
   * @type {ArrayBuffer}
   * @description extensions
   */
		this.extensions = (0, _pvutils.getParametersValue)(parameters, &quot;extensions&quot;, SignedCertificateTimestamp.defaultValues(&quot;extensions&quot;));
		/**
   * @type {string}
   * @description hashAlgorithm
   */
		this.hashAlgorithm = (0, _pvutils.getParametersValue)(parameters, &quot;hashAlgorithm&quot;, SignedCertificateTimestamp.defaultValues(&quot;hashAlgorithm&quot;));
		/**
   * @type {string}
   * @description signatureAlgorithm
   */
		this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, &quot;signatureAlgorithm&quot;, SignedCertificateTimestamp.defaultValues(&quot;signatureAlgorithm&quot;));
		/**
   * @type {Object}
   * @description signature
   */
		this.signature = (0, _pvutils.getParametersValue)(parameters, &quot;signature&quot;, SignedCertificateTimestamp.defaultValues(&quot;signature&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion

		//region If input argument array contains &quot;stream&quot;
		if (&quot;stream&quot; in parameters) this.fromStream(parameters.stream);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;version&quot;:
				return 0;
			case &quot;logID&quot;:
			case &quot;extensions&quot;:
				return new ArrayBuffer(0);
			case &quot;timestamp&quot;:
				return new Date(0);
			case &quot;hashAlgorithm&quot;:
			case &quot;signatureAlgorithm&quot;:
				return &quot;&quot;;
			case &quot;signature&quot;:
				return new asn1js.Any();
			default:
				throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		if (schema instanceof asn1js.RawData === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for SignedCertificateTimestamp&quot;);

		const seqStream = new _bytestreamjs.SeqStream({
			stream: new _bytestreamjs.ByteStream({
				buffer: schema.data
			})
		});

		this.fromStream(seqStream);
	}
	//**********************************************************************************
	/**
  * Convert SeqStream data into current class
  * @param {!SeqStream} stream
  */
	fromStream(stream) {
		const blockLength = stream.getUint16();

		this.version = stream.getBlock(1)[0];

		if (this.version === 0) {
			this.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);
			this.timestamp = new Date((0, _pvutils.utilFromBase)(new Uint8Array(stream.getBlock(8)), 8));

			//region Extensions
			const extensionsLength = stream.getUint16();
			this.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0);
			//endregion

			//region Hash algorithm
			switch (stream.getBlock(1)[0]) {
				case 0:
					this.hashAlgorithm = &quot;none&quot;;
					break;
				case 1:
					this.hashAlgorithm = &quot;md5&quot;;
					break;
				case 2:
					this.hashAlgorithm = &quot;sha1&quot;;
					break;
				case 3:
					this.hashAlgorithm = &quot;sha224&quot;;
					break;
				case 4:
					this.hashAlgorithm = &quot;sha256&quot;;
					break;
				case 5:
					this.hashAlgorithm = &quot;sha384&quot;;
					break;
				case 6:
					this.hashAlgorithm = &quot;sha512&quot;;
					break;
				default:
					throw new Error(&quot;Object&#039;s stream was not correct for SignedCertificateTimestamp&quot;);
			}
			//endregion

			//region Signature algorithm
			switch (stream.getBlock(1)[0]) {
				case 0:
					this.signatureAlgorithm = &quot;anonymous&quot;;
					break;
				case 1:
					this.signatureAlgorithm = &quot;rsa&quot;;
					break;
				case 2:
					this.signatureAlgorithm = &quot;dsa&quot;;
					break;
				case 3:
					this.signatureAlgorithm = &quot;ecdsa&quot;;
					break;
				default:
					throw new Error(&quot;Object&#039;s stream was not correct for SignedCertificateTimestamp&quot;);
			}
			//endregion

			//region Signature
			const signatureLength = stream.getUint16();
			const signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);

			const asn1 = asn1js.fromBER(signatureData);
			if (asn1.offset === -1) throw new Error(&quot;Object&#039;s stream was not correct for SignedCertificateTimestamp&quot;);

			this.signature = asn1.result;
			//endregion

			if (blockLength !== 47 + extensionsLength + signatureLength) throw new Error(&quot;Object&#039;s stream was not correct for SignedCertificateTimestamp&quot;);
		}
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		const stream = this.toStream();

		return new asn1js.RawData({ data: stream.stream.buffer });
	}
	//**********************************************************************************
	/**
  * Convert current object to SeqStream data
  * @returns {SeqStream} SeqStream object
  */
	toStream() {
		const stream = new _bytestreamjs.SeqStream();

		stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);
		stream.appendChar(this.version);
		stream.appendView(new Uint8Array(this.logID));

		const timeBuffer = new ArrayBuffer(8);
		const timeView = new Uint8Array(timeBuffer);

		const baseArray = (0, _pvutils.utilToBase)(this.timestamp.valueOf(), 8);
		timeView.set(baseArray, 8 - baseArray.byteLength);

		stream.appendView(timeView);
		stream.appendUint16(this.extensions.byteLength);

		if (this.extensions.byteLength) stream.appendView(new Uint8Array(this.extensions));

		let _hashAlgorithm;

		switch (this.hashAlgorithm.toLowerCase()) {
			case &quot;none&quot;:
				_hashAlgorithm = 0;
				break;
			case &quot;md5&quot;:
				_hashAlgorithm = 1;
				break;
			case &quot;sha1&quot;:
				_hashAlgorithm = 2;
				break;
			case &quot;sha224&quot;:
				_hashAlgorithm = 3;
				break;
			case &quot;sha256&quot;:
				_hashAlgorithm = 4;
				break;
			case &quot;sha384&quot;:
				_hashAlgorithm = 5;
				break;
			case &quot;sha512&quot;:
				_hashAlgorithm = 6;
				break;
			default:
				throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
		}

		stream.appendChar(_hashAlgorithm);

		let _signatureAlgorithm;

		switch (this.signatureAlgorithm.toLowerCase()) {
			case &quot;anonymous&quot;:
				_signatureAlgorithm = 0;
				break;
			case &quot;rsa&quot;:
				_signatureAlgorithm = 1;
				break;
			case &quot;dsa&quot;:
				_signatureAlgorithm = 2;
				break;
			case &quot;ecdsa&quot;:
				_signatureAlgorithm = 3;
				break;
			default:
				throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
		}

		stream.appendChar(_signatureAlgorithm);

		const _signature = this.signature.toBER(false);

		stream.appendUint16(_signature.byteLength);
		stream.appendView(new Uint8Array(_signature));

		return stream;
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		return {
			version: this.version,
			logID: (0, _pvutils.bufferToHexCodes)(this.logID),
			timestamp: this.timestamp,
			extensions: (0, _pvutils.bufferToHexCodes)(this.extensions),
			hashAlgorithm: this.hashAlgorithm,
			signatureAlgorithm: this.signatureAlgorithm,
			signature: this.signature.toJSON()
		};
	}
	//**********************************************************************************
	/**
  * Verify SignedCertificateTimestamp for specific input data
  * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)
  * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format
  * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format
  * @param {ArrayBuffer} data Data to verify signature against. Could be encoded Certificate or encoded PreCert
  * @param {Number} [dataType=0] Type = 0 (data is encoded Certificate), type = 1 (data is encoded PreCert)
  * @return {Promise&lt;void&gt;}
  */
	verify(logs, data, dataType = 0) {
		var _this = this;

		return _asyncToGenerator(function* () {
			//region Initial variables
			let logId = (0, _pvutils.toBase64)((0, _pvutils.arrayBufferToString)(_this.logID));

			let publicKeyBase64 = null;
			let publicKeyInfo;

			let stream = new _bytestreamjs.SeqStream();
			//endregion

			//region Found and init public key
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = logs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					const log = _step.value;

					if (log.log_id === logId) {
						publicKeyBase64 = log.key;
						break;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			if (publicKeyBase64 === null) throw new Error(`Public key not found for CT with logId: ${logId}`);

			const asn1 = asn1js.fromBER((0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(publicKeyBase64)));
			if (asn1.offset === -1) throw new Error(`Incorrect key value for CT Log with logId: ${logId}`);

			publicKeyInfo = new _PublicKeyInfo2.default({ schema: asn1.result });
			//endregion

			//region Initialize signed data block
			stream.appendChar(0x00); // sct_version
			stream.appendChar(0x00); // signature_type = certificate_timestamp

			const timeBuffer = new ArrayBuffer(8);
			const timeView = new Uint8Array(timeBuffer);

			const baseArray = (0, _pvutils.utilToBase)(_this.timestamp.valueOf(), 8);
			timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);

			stream.appendView(timeView);

			stream.appendUint16(dataType);

			if (dataType === 0) stream.appendUint24(data.byteLength);

			stream.appendView(new Uint8Array(data));

			stream.appendUint16(_this.extensions.byteLength);

			if (_this.extensions.byteLength !== 0) stream.appendView(new Uint8Array(_this.extensions));
			//endregion

			//region Perform verification
			return (0, _common.getEngine)().subtle.verifyWithPublicKey(stream._stream._buffer.slice(0, stream._length), { valueBlock: { valueHex: _this.signature.toBER(false) } }, publicKeyInfo, { algorithmId: &quot;&quot; }, &quot;SHA-256&quot;);
			//endregion
		})();
	}
	//**********************************************************************************
}
exports.SignedCertificateTimestamp = SignedCertificateTimestamp; //**************************************************************************************
/**
 * Class from RFC6962
 */

class SignedCertificateTimestampList {
	//**********************************************************************************
	/**
  * Constructor for SignedCertificateTimestampList class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {Array.&lt;SignedCertificateTimestamp&gt;}
   * @description timestamps
   */
		this.timestamps = (0, _pvutils.getParametersValue)(parameters, &quot;timestamps&quot;, SignedCertificateTimestampList.defaultValues(&quot;timestamps&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;timestamps&quot;:
				return [];
			default:
				throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Compare values with default values for all class members
  * @param {string} memberName String name for a class member
  * @param {*} memberValue Value to compare with default value
  */
	static compareWithDefault(memberName, memberValue) {
		switch (memberName) {
			case &quot;timestamps&quot;:
				return memberValue.length === 0;
			default:
				throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		//SignedCertificateTimestampList ::= OCTET STRING

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [optional]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		if (&quot;optional&quot; in names === false) names.optional = false;

		return new asn1js.OctetString({
			name: names.blockName || &quot;SignedCertificateTimestampList&quot;,
			optional: names.optional
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Check the schema is valid
		if (schema instanceof asn1js.OctetString === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for SignedCertificateTimestampList&quot;);
		//endregion

		//region Get internal properties from parsed schema
		const seqStream = new _bytestreamjs.SeqStream({
			stream: new _bytestreamjs.ByteStream({
				buffer: schema.valueBlock.valueHex
			})
		});

		let dataLength = seqStream.getUint16();
		if (dataLength !== seqStream.length) throw new Error(&quot;Object&#039;s schema was not verified against input data for SignedCertificateTimestampList&quot;);

		while (seqStream.length) this.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		//region Initial variables
		const stream = new _bytestreamjs.SeqStream();

		let overallLength = 0;

		const timestampsData = [];
		//endregion

		//region Get overall length
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = this.timestamps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				const timestamp = _step2.value;

				const timestampStream = timestamp.toStream();
				timestampsData.push(timestampStream);
				overallLength += timestampStream.stream.buffer.byteLength;
			}
			//endregion
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		stream.appendUint16(overallLength);

		//region Set data from all timestamps
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = timestampsData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				const timestamp = _step3.value;

				stream.appendView(timestamp.stream.view);
			} //endregion
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		return new asn1js.OctetString({ valueHex: stream.stream.buffer.slice(0) });
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		return {
			timestamps: Array.from(this.timestamps, element =&gt; element.toJSON())
		};
	}
	//**********************************************************************************
}exports.default = SignedCertificateTimestampList;
//# sourceMappingURL=SignedCertificateTimestampList.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
