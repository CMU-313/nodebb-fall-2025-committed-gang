<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1413</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">116.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.19</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const ConditionalInitFragment = require(&quot;../ConditionalInitFragment&quot;);
const Dependency = require(&quot;../Dependency&quot;);
const { UsageState } = require(&quot;../ExportsInfo&quot;);
const HarmonyLinkingError = require(&quot;../HarmonyLinkingError&quot;);
const InitFragment = require(&quot;../InitFragment&quot;);
const RuntimeGlobals = require(&quot;../RuntimeGlobals&quot;);
const Template = require(&quot;../Template&quot;);
const { countIterable } = require(&quot;../util/IterableHelpers&quot;);
const { first, combine } = require(&quot;../util/SetHelpers&quot;);
const makeSerializable = require(&quot;../util/makeSerializable&quot;);
const propertyAccess = require(&quot;../util/propertyAccess&quot;);
const { propertyName } = require(&quot;../util/propertyName&quot;);
const {
	getRuntimeKey,
	keyToRuntime,
	filterRuntime
} = require(&quot;../util/runtime&quot;);
const HarmonyExportInitFragment = require(&quot;./HarmonyExportInitFragment&quot;);
const HarmonyImportDependency = require(&quot;./HarmonyImportDependency&quot;);
const processExportInfo = require(&quot;./processExportInfo&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).ReplaceSource} ReplaceSource */
/** @typedef {import(&quot;../ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;../Dependency&quot;).ExportsSpec} ExportsSpec */
/** @typedef {import(&quot;../Dependency&quot;).GetConditionFn} GetConditionFn */
/** @typedef {import(&quot;../Dependency&quot;).ReferencedExport} ReferencedExport */
/** @typedef {import(&quot;../Dependency&quot;).TRANSITIVE} TRANSITIVE */
/** @typedef {import(&quot;../Dependency&quot;).UpdateHashContext} UpdateHashContext */
/** @typedef {import(&quot;../DependencyTemplate&quot;).DependencyTemplateContext} DependencyTemplateContext */
/** @typedef {import(&quot;../ExportsInfo&quot;)} ExportsInfo */
/** @typedef {import(&quot;../ExportsInfo&quot;).ExportInfo} ExportInfo */
/** @typedef {import(&quot;../ExportsInfo&quot;).UsedName} UsedName */
/** @typedef {import(&quot;../Generator&quot;).GenerateContext} GenerateContext */
/** @typedef {import(&quot;../Module&quot;)} Module */
/** @typedef {import(&quot;../Module&quot;).BuildMeta} BuildMeta */
/** @typedef {import(&quot;../Module&quot;).RuntimeRequirements} RuntimeRequirements */
/** @typedef {import(&quot;../ModuleGraph&quot;)} ModuleGraph */
/** @typedef {import(&quot;../ModuleGraphConnection&quot;)} ModuleGraphConnection */
/** @typedef {import(&quot;../ModuleGraphConnection&quot;).ConnectionState} ConnectionState */
/** @typedef {import(&quot;../RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {import(&quot;../WebpackError&quot;)} WebpackError */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).ImportAttributes} ImportAttributes */
/** @typedef {import(&quot;../serialization/ObjectMiddleware&quot;).ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import(&quot;../serialization/ObjectMiddleware&quot;).ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import(&quot;../util/Hash&quot;)} Hash */
/** @typedef {import(&quot;../util/runtime&quot;).RuntimeSpec} RuntimeSpec */
/** @typedef {import(&quot;./HarmonyImportDependency&quot;).ExportPresenceMode} ExportPresenceMode */
/** @typedef {import(&quot;./processExportInfo&quot;).ReferencedExports} ReferencedExports */

/** @typedef {&quot;missing&quot;|&quot;unused&quot;|&quot;empty-star&quot;|&quot;reexport-dynamic-default&quot;|&quot;reexport-named-default&quot;|&quot;reexport-namespace-object&quot;|&quot;reexport-fake-namespace-object&quot;|&quot;reexport-undefined&quot;|&quot;normal-reexport&quot;|&quot;dynamic-reexport&quot;} ExportModeType */

const { ExportPresenceModes } = HarmonyImportDependency;

const idsSymbol = Symbol(&quot;HarmonyExportImportedSpecifierDependency.ids&quot;);

class NormalReexportItem {
	/**
	 * @param {string} name export name
	 * @param {string[]} ids reexported ids from other module
	 * @param {ExportInfo} exportInfo export info from other module
	 * @param {boolean} checked true, if it should be checked at runtime if this export exists
	 * @param {boolean} hidden true, if it is hidden behind another active export in the same module
	 */
	constructor(name, ids, exportInfo, checked, hidden) {
		this.name = name;
		this.ids = ids;
		this.exportInfo = exportInfo;
		this.checked = checked;
		this.hidden = hidden;
	}
}

/** @typedef {Set&lt;string&gt;} ExportModeIgnored */
/** @typedef {Set&lt;string&gt;} ExportModeHidden */

class ExportMode {
	/**
	 * @param {ExportModeType} type type of the mode
	 */
	constructor(type) {
		/** @type {ExportModeType} */
		this.type = type;

		// for &quot;normal-reexport&quot;:
		/** @type {NormalReexportItem[] | null} */
		this.items = null;

		// for &quot;reexport-named-default&quot; | &quot;reexport-fake-namespace-object&quot; | &quot;reexport-namespace-object&quot;
		/** @type {string | null} */
		this.name = null;
		/** @type {ExportInfo | null} */
		this.partialNamespaceExportInfo = null;

		// for &quot;dynamic-reexport&quot;:
		/** @type {ExportModeIgnored | null} */
		this.ignored = null;

		// for &quot;dynamic-reexport&quot; | &quot;empty-star&quot;:
		/** @type {ExportModeHidden | undefined | null} */
		this.hidden = null;

		// for &quot;missing&quot;:
		/** @type {string | null} */
		this.userRequest = null;

		// for &quot;reexport-fake-namespace-object&quot;:
		/** @type {number} */
		this.fakeType = 0;
	}
}

/** @typedef {string[]} Names */
/** @typedef {number[]} DependencyIndices */

/**
 * @param {ModuleGraph} moduleGraph module graph
 * @param {HarmonyExportImportedSpecifierDependency[]} dependencies dependencies
 * @param {TODO=} additionalDependency additional dependency
 * @returns {{ names: Names, dependencyIndices: DependencyIndices }} result
 */
const determineExportAssignments = (
	moduleGraph,
	dependencies,
	additionalDependency
) =&gt; {
	const names = new Set();
	/** @type {number[]} */
	const dependencyIndices = [];

	if (additionalDependency) {
		dependencies = dependencies.concat(additionalDependency);
	}

	for (const dep of dependencies) {
		const i = dependencyIndices.length;
		dependencyIndices[i] = names.size;
		const otherImportedModule = moduleGraph.getModule(dep);
		if (otherImportedModule) {
			const exportsInfo = moduleGraph.getExportsInfo(otherImportedModule);
			for (const exportInfo of exportsInfo.exports) {
				if (
					exportInfo.provided === true &amp;&amp;
					exportInfo.name !== &quot;default&quot; &amp;&amp;
					!names.has(exportInfo.name)
				) {
					names.add(exportInfo.name);
					dependencyIndices[i] = names.size;
				}
			}
		}
	}
	dependencyIndices.push(names.size);

	return { names: Array.from(names), dependencyIndices };
};

/**
 * @param {object} options options
 * @param {Names} options.names names
 * @param {DependencyIndices} options.dependencyIndices dependency indices
 * @param {string} name name
 * @param {Iterable&lt;HarmonyExportImportedSpecifierDependency&gt;} dependencies dependencies
 * @returns {HarmonyExportImportedSpecifierDependency | undefined} found dependency or nothing
 */
const findDependencyForName = (
	{ names, dependencyIndices },
	name,
	dependencies
) =&gt; {
	const dependenciesIt = dependencies[Symbol.iterator]();
	const dependencyIndicesIt = dependencyIndices[Symbol.iterator]();
	let dependenciesItResult = dependenciesIt.next();
	let dependencyIndicesItResult = dependencyIndicesIt.next();
	if (dependencyIndicesItResult.done) return;
	for (let i = 0; i &lt; names.length; i++) {
		while (i &gt;= dependencyIndicesItResult.value) {
			dependenciesItResult = dependenciesIt.next();
			dependencyIndicesItResult = dependencyIndicesIt.next();
			if (dependencyIndicesItResult.done) return;
		}
		if (names[i] === name) return dependenciesItResult.value;
	}
	return undefined;
};

/**
 * @param {ModuleGraph} moduleGraph the module graph
 * @param {HarmonyExportImportedSpecifierDependency} dep the dependency
 * @param {string} runtimeKey the runtime key
 * @returns {ExportMode} the export mode
 */
const getMode = (moduleGraph, dep, runtimeKey) =&gt; {
	const importedModule = moduleGraph.getModule(dep);

	if (!importedModule) {
		const mode = new ExportMode(&quot;missing&quot;);

		mode.userRequest = dep.userRequest;

		return mode;
	}

	const name = dep.name;
	const runtime = keyToRuntime(runtimeKey);
	const parentModule = /** @type {Module} */ (moduleGraph.getParentModule(dep));
	const exportsInfo = moduleGraph.getExportsInfo(parentModule);

	if (
		name
			? exportsInfo.getUsed(name, runtime) === UsageState.Unused
			: exportsInfo.isUsed(runtime) === false
	) {
		const mode = new ExportMode(&quot;unused&quot;);

		mode.name = name || &quot;*&quot;;

		return mode;
	}

	const importedExportsType = importedModule.getExportsType(
		moduleGraph,
		/** @type {BuildMeta} */
		(parentModule.buildMeta).strictHarmonyModule
	);

	const ids = dep.getIds(moduleGraph);

	// Special handling for reexporting the default export
	// from non-namespace modules
	if (name &amp;&amp; ids.length &gt; 0 &amp;&amp; ids[0] === &quot;default&quot;) {
		switch (importedExportsType) {
			case &quot;dynamic&quot;: {
				const mode = new ExportMode(&quot;reexport-dynamic-default&quot;);

				mode.name = name;

				return mode;
			}
			case &quot;default-only&quot;:
			case &quot;default-with-named&quot;: {
				const exportInfo = exportsInfo.getReadOnlyExportInfo(name);
				const mode = new ExportMode(&quot;reexport-named-default&quot;);

				mode.name = name;
				mode.partialNamespaceExportInfo = exportInfo;

				return mode;
			}
		}
	}

	// reexporting with a fixed name
	if (name) {
		let mode;
		const exportInfo = exportsInfo.getReadOnlyExportInfo(name);

		if (ids.length &gt; 0) {
			// export { name as name }
			switch (importedExportsType) {
				case &quot;default-only&quot;:
					mode = new ExportMode(&quot;reexport-undefined&quot;);
					mode.name = name;
					break;
				default:
					mode = new ExportMode(&quot;normal-reexport&quot;);
					mode.items = [
						new NormalReexportItem(name, ids, exportInfo, false, false)
					];
					break;
			}
		} else {
			// export * as name
			switch (importedExportsType) {
				case &quot;default-only&quot;:
					mode = new ExportMode(&quot;reexport-fake-namespace-object&quot;);
					mode.name = name;
					mode.partialNamespaceExportInfo = exportInfo;
					mode.fakeType = 0;
					break;
				case &quot;default-with-named&quot;:
					mode = new ExportMode(&quot;reexport-fake-namespace-object&quot;);
					mode.name = name;
					mode.partialNamespaceExportInfo = exportInfo;
					mode.fakeType = 2;
					break;
				case &quot;dynamic&quot;:
				default:
					mode = new ExportMode(&quot;reexport-namespace-object&quot;);
					mode.name = name;
					mode.partialNamespaceExportInfo = exportInfo;
			}
		}

		return mode;
	}

	// Star reexporting

	const { ignoredExports, exports, checked, hidden } = dep.getStarReexports(
		moduleGraph,
		runtime,
		exportsInfo,
		importedModule
	);
	if (!exports) {
		// We have too few info about the modules
		// Delegate the logic to the runtime code

		const mode = new ExportMode(&quot;dynamic-reexport&quot;);
		mode.ignored = ignoredExports;
		mode.hidden = hidden;

		return mode;
	}

	if (exports.size === 0) {
		const mode = new ExportMode(&quot;empty-star&quot;);
		mode.hidden = hidden;

		return mode;
	}

	const mode = new ExportMode(&quot;normal-reexport&quot;);

	mode.items = Array.from(
		exports,
		exportName =&gt;
			new NormalReexportItem(
				exportName,
				[exportName],
				exportsInfo.getReadOnlyExportInfo(exportName),
				/** @type {Set&lt;string&gt;} */
				(checked).has(exportName),
				false
			)
	);
	if (hidden !== undefined) {
		for (const exportName of hidden) {
			mode.items.push(
				new NormalReexportItem(
					exportName,
					[exportName],
					exportsInfo.getReadOnlyExportInfo(exportName),
					false,
					true
				)
			);
		}
	}

	return mode;
};

/** @typedef {string[]} Ids */
/** @typedef {Set&lt;string&gt;} Exports */
/** @typedef {Set&lt;string&gt;} Checked */
/** @typedef {Set&lt;string&gt;} Hidden */
/** @typedef {Set&lt;string&gt;} IgnoredExports */

class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
	/**
	 * @param {string} request the request string
	 * @param {number} sourceOrder the order in the original source file
	 * @param {Ids} ids the requested export name of the imported module
	 * @param {string | null} name the export name of for this module
	 * @param {Set&lt;string&gt;} activeExports other named exports in the module
	 * @param {ReadonlyArray&lt;HarmonyExportImportedSpecifierDependency&gt; | Iterable&lt;HarmonyExportImportedSpecifierDependency&gt; | null} otherStarExports other star exports in the module before this import
	 * @param {ExportPresenceMode} exportPresenceMode mode of checking export names
	 * @param {HarmonyStarExportsList | null} allStarExports all star exports in the module
	 * @param {ImportAttributes=} attributes import attributes
	 */
	constructor(
		request,
		sourceOrder,
		ids,
		name,
		activeExports,
		otherStarExports,
		exportPresenceMode,
		allStarExports,
		attributes
	) {
		super(request, sourceOrder, attributes);

		this.ids = ids;
		this.name = name;
		this.activeExports = activeExports;
		this.otherStarExports = otherStarExports;
		this.exportPresenceMode = exportPresenceMode;
		this.allStarExports = allStarExports;
	}

	/**
	 * @returns {boolean | TRANSITIVE} true, when changes to the referenced module could affect the referencing module; TRANSITIVE, when changes to the referenced module could affect referencing modules of the referencing module
	 */
	couldAffectReferencingModule() {
		return Dependency.TRANSITIVE;
	}

	// TODO webpack 6 remove
	get id() {
		throw new Error(&quot;id was renamed to ids and type changed to string[]&quot;);
	}

	// TODO webpack 6 remove
	getId() {
		throw new Error(&quot;id was renamed to ids and type changed to string[]&quot;);
	}

	// TODO webpack 6 remove
	setId() {
		throw new Error(&quot;id was renamed to ids and type changed to string[]&quot;);
	}

	get type() {
		return &quot;harmony export imported specifier&quot;;
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @returns {Ids} the imported id
	 */
	getIds(moduleGraph) {
		return moduleGraph.getMeta(this)[idsSymbol] || this.ids;
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {Ids} ids the imported ids
	 * @returns {void}
	 */
	setIds(moduleGraph, ids) {
		moduleGraph.getMeta(this)[idsSymbol] = ids;
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {RuntimeSpec} runtime the runtime
	 * @returns {ExportMode} the export mode
	 */
	getMode(moduleGraph, runtime) {
		return moduleGraph.dependencyCacheProvide(
			this,
			getRuntimeKey(runtime),
			getMode
		);
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {RuntimeSpec} runtime the runtime
	 * @param {ExportsInfo} exportsInfo exports info about the current module (optional)
	 * @param {Module} importedModule the imported module (optional)
	 * @returns {{exports?: Exports, checked?: Checked, ignoredExports: IgnoredExports, hidden?: Hidden}} information
	 */
	getStarReexports(
		moduleGraph,
		runtime,
		exportsInfo = moduleGraph.getExportsInfo(
			/** @type {Module} */ (moduleGraph.getParentModule(this))
		),
		importedModule = /** @type {Module} */ (moduleGraph.getModule(this))
	) {
		const importedExportsInfo = moduleGraph.getExportsInfo(importedModule);
		const noExtraExports =
			importedExportsInfo.otherExportsInfo.provided === false;
		const noExtraImports =
			exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused;

		const ignoredExports = new Set([&quot;default&quot;, ...this.activeExports]);

		let hiddenExports;
		const otherStarExports =
			this._discoverActiveExportsFromOtherStarExports(moduleGraph);
		if (otherStarExports !== undefined) {
			hiddenExports = new Set();
			for (let i = 0; i &lt; otherStarExports.namesSlice; i++) {
				hiddenExports.add(otherStarExports.names[i]);
			}
			for (const e of ignoredExports) hiddenExports.delete(e);
		}

		if (!noExtraExports &amp;&amp; !noExtraImports) {
			return {
				ignoredExports,
				hidden: hiddenExports
			};
		}

		/** @type {Exports} */
		const exports = new Set();
		/** @type {Checked} */
		const checked = new Set();
		/** @type {Hidden | undefined} */
		const hidden = hiddenExports !== undefined ? new Set() : undefined;

		if (noExtraImports) {
			for (const exportInfo of exportsInfo.orderedExports) {
				const name = exportInfo.name;
				if (ignoredExports.has(name)) continue;
				if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
				const importedExportInfo =
					importedExportsInfo.getReadOnlyExportInfo(name);
				if (importedExportInfo.provided === false) continue;
				if (hiddenExports !== undefined &amp;&amp; hiddenExports.has(name)) {
					/** @type {Set&lt;string&gt;} */
					(hidden).add(name);
					continue;
				}
				exports.add(name);
				if (importedExportInfo.provided === true) continue;
				checked.add(name);
			}
		} else if (noExtraExports) {
			for (const importedExportInfo of importedExportsInfo.orderedExports) {
				const name = importedExportInfo.name;
				if (ignoredExports.has(name)) continue;
				if (importedExportInfo.provided === false) continue;
				const exportInfo = exportsInfo.getReadOnlyExportInfo(name);
				if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
				if (hiddenExports !== undefined &amp;&amp; hiddenExports.has(name)) {
					/** @type {ExportModeHidden} */
					(hidden).add(name);
					continue;
				}
				exports.add(name);
				if (importedExportInfo.provided === true) continue;
				checked.add(name);
			}
		}

		return { ignoredExports, exports, checked, hidden };
	}

	/**
	 * @param {ModuleGraph} moduleGraph module graph
	 * @returns {null | false | GetConditionFn} function to determine if the connection is active
	 */
	getCondition(moduleGraph) {
		return (connection, runtime) =&gt; {
			const mode = this.getMode(moduleGraph, runtime);
			return mode.type !== &quot;unused&quot; &amp;&amp; mode.type !== &quot;empty-star&quot;;
		};
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @returns {ConnectionState} how this dependency connects the module to referencing modules
	 */
	getModuleEvaluationSideEffectsState(moduleGraph) {
		return false;
	}

	/**
	 * Returns list of exports referenced by this dependency
	 * @param {ModuleGraph} moduleGraph module graph
	 * @param {RuntimeSpec} runtime the runtime for which the module is analysed
	 * @returns {(string[] | ReferencedExport)[]} referenced exports
	 */
	getReferencedExports(moduleGraph, runtime) {
		const mode = this.getMode(moduleGraph, runtime);

		switch (mode.type) {
			case &quot;missing&quot;:
			case &quot;unused&quot;:
			case &quot;empty-star&quot;:
			case &quot;reexport-undefined&quot;:
				return Dependency.NO_EXPORTS_REFERENCED;

			case &quot;reexport-dynamic-default&quot;:
				return Dependency.EXPORTS_OBJECT_REFERENCED;

			case &quot;reexport-named-default&quot;: {
				if (!mode.partialNamespaceExportInfo)
					return Dependency.EXPORTS_OBJECT_REFERENCED;
				/** @type {ReferencedExports} */
				const referencedExports = [];
				processExportInfo(
					runtime,
					referencedExports,
					[],
					/** @type {ExportInfo} */ (mode.partialNamespaceExportInfo)
				);
				return referencedExports;
			}

			case &quot;reexport-namespace-object&quot;:
			case &quot;reexport-fake-namespace-object&quot;: {
				if (!mode.partialNamespaceExportInfo)
					return Dependency.EXPORTS_OBJECT_REFERENCED;
				/** @type {ReferencedExports} */
				const referencedExports = [];
				processExportInfo(
					runtime,
					referencedExports,
					[],
					/** @type {ExportInfo} */ (mode.partialNamespaceExportInfo),
					mode.type === &quot;reexport-fake-namespace-object&quot;
				);
				return referencedExports;
			}

			case &quot;dynamic-reexport&quot;:
				return Dependency.EXPORTS_OBJECT_REFERENCED;

			case &quot;normal-reexport&quot;: {
				/** @type {ReferencedExports} */
				const referencedExports = [];
				for (const {
					ids,
					exportInfo,
					hidden
				} of /** @type {NormalReexportItem[]} */ (mode.items)) {
					if (hidden) continue;
					processExportInfo(runtime, referencedExports, ids, exportInfo, false);
				}
				return referencedExports;
			}

			default:
				throw new Error(`Unknown mode ${mode.type}`);
		}
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @returns {{ names: Names, namesSlice: number, dependencyIndices: DependencyIndices, dependencyIndex: number } | undefined} exported names and their origin dependency
	 */
	_discoverActiveExportsFromOtherStarExports(moduleGraph) {
		if (!this.otherStarExports) return;

		const i =
			&quot;length&quot; in this.otherStarExports
				? this.otherStarExports.length
				: countIterable(this.otherStarExports);
		if (i === 0) return;

		if (this.allStarExports) {
			const { names, dependencyIndices } = moduleGraph.cached(
				determineExportAssignments,
				this.allStarExports.dependencies
			);

			return {
				names,
				namesSlice: dependencyIndices[i - 1],
				dependencyIndices,
				dependencyIndex: i
			};
		}

		const { names, dependencyIndices } = moduleGraph.cached(
			determineExportAssignments,
			this.otherStarExports,
			this
		);

		return {
			names,
			namesSlice: dependencyIndices[i - 1],
			dependencyIndices,
			dependencyIndex: i
		};
	}

	/**
	 * Returns the exported names
	 * @param {ModuleGraph} moduleGraph module graph
	 * @returns {ExportsSpec | undefined} export names
	 */
	getExports(moduleGraph) {
		const mode = this.getMode(moduleGraph, undefined);

		switch (mode.type) {
			case &quot;missing&quot;:
				return;
			case &quot;dynamic-reexport&quot;: {
				const from =
					/** @type {ModuleGraphConnection} */
					(moduleGraph.getConnection(this));
				return {
					exports: true,
					from,
					canMangle: false,
					excludeExports: mode.hidden
						? combine(
								/** @type {ExportModeIgnored} */ (mode.ignored),
								mode.hidden
							)
						: /** @type {ExportModeIgnored} */ (mode.ignored),
					hideExports: mode.hidden,
					dependencies: [from.module]
				};
			}
			case &quot;empty-star&quot;:
				return {
					exports: [],
					hideExports: mode.hidden,
					dependencies: [/** @type {Module} */ (moduleGraph.getModule(this))]
				};
			// falls through
			case &quot;normal-reexport&quot;: {
				const from =
					/** @type {ModuleGraphConnection} */
					(moduleGraph.getConnection(this));
				return {
					exports: Array.from(
						/** @type {NormalReexportItem[]} */ (mode.items),
						item =&gt; ({
							name: item.name,
							from,
							export: item.ids,
							hidden: item.hidden
						})
					),
					priority: 1,
					dependencies: [from.module]
				};
			}
			case &quot;reexport-dynamic-default&quot;: {
				const from =
					/** @type {ModuleGraphConnection} */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string} */ (mode.name),
							from,
							export: [&quot;default&quot;]
						}
					],
					priority: 1,
					dependencies: [from.module]
				};
			}
			case &quot;reexport-undefined&quot;:
				return {
					exports: [/** @type {string} */ (mode.name)],
					dependencies: [/** @type {Module} */ (moduleGraph.getModule(this))]
				};
			case &quot;reexport-fake-namespace-object&quot;: {
				const from =
					/** @type {ModuleGraphConnection} */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string} */ (mode.name),
							from,
							export: null,
							exports: [
								{
									name: &quot;default&quot;,
									canMangle: false,
									from,
									export: null
								}
							]
						}
					],
					priority: 1,
					dependencies: [from.module]
				};
			}
			case &quot;reexport-namespace-object&quot;: {
				const from =
					/** @type {ModuleGraphConnection} */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string} */ (mode.name),
							from,
							export: null
						}
					],
					priority: 1,
					dependencies: [from.module]
				};
			}
			case &quot;reexport-named-default&quot;: {
				const from =
					/** @type {ModuleGraphConnection} */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string} */ (mode.name),
							from,
							export: [&quot;default&quot;]
						}
					],
					priority: 1,
					dependencies: [from.module]
				};
			}
			default:
				throw new Error(`Unknown mode ${mode.type}`);
		}
	}

	/**
	 * @param {ModuleGraph} moduleGraph module graph
	 * @returns {ExportPresenceMode} effective mode
	 */
	_getEffectiveExportPresenceLevel(moduleGraph) {
		if (this.exportPresenceMode !== ExportPresenceModes.AUTO)
			return this.exportPresenceMode;
		const module = /** @type {Module} */ (moduleGraph.getParentModule(this));
		return /** @type {BuildMeta} */ (module.buildMeta).strictHarmonyModule
			? ExportPresenceModes.ERROR
			: ExportPresenceModes.WARN;
	}

	/**
	 * Returns warnings
	 * @param {ModuleGraph} moduleGraph module graph
	 * @returns {WebpackError[] | null | undefined} warnings
	 */
	getWarnings(moduleGraph) {
		const exportsPresence = this._getEffectiveExportPresenceLevel(moduleGraph);
		if (exportsPresence === ExportPresenceModes.WARN) {
			return this._getErrors(moduleGraph);
		}
		return null;
	}

	/**
	 * Returns errors
	 * @param {ModuleGraph} moduleGraph module graph
	 * @returns {WebpackError[] | null | undefined} errors
	 */
	getErrors(moduleGraph) {
		const exportsPresence = this._getEffectiveExportPresenceLevel(moduleGraph);
		if (exportsPresence === ExportPresenceModes.ERROR) {
			return this._getErrors(moduleGraph);
		}
		return null;
	}

	/**
	 * @param {ModuleGraph} moduleGraph module graph
	 * @returns {WebpackError[] | undefined} errors
	 */
	_getErrors(moduleGraph) {
		const ids = this.getIds(moduleGraph);
		let errors = this.getLinkingErrors(
			moduleGraph,
			ids,
			`(reexported as &#039;${this.name}&#039;)`
		);
		if (ids.length === 0 &amp;&amp; this.name === null) {
			const potentialConflicts =
				this._discoverActiveExportsFromOtherStarExports(moduleGraph);
			if (potentialConflicts &amp;&amp; potentialConflicts.namesSlice &gt; 0) {
				const ownNames = new Set(
					potentialConflicts.names.slice(
						potentialConflicts.namesSlice,
						potentialConflicts.dependencyIndices[
							potentialConflicts.dependencyIndex
						]
					)
				);
				const importedModule = moduleGraph.getModule(this);
				if (importedModule) {
					const exportsInfo = moduleGraph.getExportsInfo(importedModule);
					/** @type {Map&lt;string, string[]&gt;} */
					const conflicts = new Map();
					for (const exportInfo of exportsInfo.orderedExports) {
						if (exportInfo.provided !== true) continue;
						if (exportInfo.name === &quot;default&quot;) continue;
						if (this.activeExports.has(exportInfo.name)) continue;
						if (ownNames.has(exportInfo.name)) continue;
						const conflictingDependency = findDependencyForName(
							potentialConflicts,
							exportInfo.name,
							this.allStarExports
								? this.allStarExports.dependencies
								: [
										.../** @type {Iterable&lt;HarmonyExportImportedSpecifierDependency&gt;} */
										(this.otherStarExports),
										this
									]
						);
						if (!conflictingDependency) continue;
						const target = exportInfo.getTerminalBinding(moduleGraph);
						if (!target) continue;
						const conflictingModule =
							/** @type {Module} */
							(moduleGraph.getModule(conflictingDependency));
						if (conflictingModule === importedModule) continue;
						const conflictingExportInfo = moduleGraph.getExportInfo(
							conflictingModule,
							exportInfo.name
						);
						const conflictingTarget =
							conflictingExportInfo.getTerminalBinding(moduleGraph);
						if (!conflictingTarget) continue;
						if (target === conflictingTarget) continue;
						const list = conflicts.get(conflictingDependency.request);
						if (list === undefined) {
							conflicts.set(conflictingDependency.request, [exportInfo.name]);
						} else {
							list.push(exportInfo.name);
						}
					}
					for (const [request, exports] of conflicts) {
						if (!errors) errors = [];
						errors.push(
							new HarmonyLinkingError(
								`The requested module &#039;${
									this.request
								}&#039; contains conflicting star exports for the ${
									exports.length &gt; 1 ? &quot;names&quot; : &quot;name&quot;
								} ${exports
									.map(e =&gt; `&#039;${e}&#039;`)
									.join(&quot;, &quot;)} with the previous requested module &#039;${request}&#039;`
							)
						);
					}
				}
			}
		}
		return errors;
	}

	/**
	 * @param {ObjectSerializerContext} context context
	 */
	serialize(context) {
		const { write, setCircularReference } = context;

		setCircularReference(this);
		write(this.ids);
		write(this.name);
		write(this.activeExports);
		write(this.otherStarExports);
		write(this.exportPresenceMode);
		write(this.allStarExports);

		super.serialize(context);
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 */
	deserialize(context) {
		const { read, setCircularReference } = context;

		setCircularReference(this);
		this.ids = read();
		this.name = read();
		this.activeExports = read();
		this.otherStarExports = read();
		this.exportPresenceMode = read();
		this.allStarExports = read();

		super.deserialize(context);
	}
}

makeSerializable(
	HarmonyExportImportedSpecifierDependency,
	&quot;webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency&quot;
);

module.exports = HarmonyExportImportedSpecifierDependency;

HarmonyExportImportedSpecifierDependency.Template = class HarmonyExportImportedSpecifierDependencyTemplate extends (
	HarmonyImportDependency.Template
) {
	/**
	 * @param {Dependency} dependency the dependency for which the template should be applied
	 * @param {ReplaceSource} source the current replace source which can be modified
	 * @param {DependencyTemplateContext} templateContext the context object
	 * @returns {void}
	 */
	apply(dependency, source, templateContext) {
		const { moduleGraph, runtime, concatenationScope } = templateContext;

		const dep = /** @type {HarmonyExportImportedSpecifierDependency} */ (
			dependency
		);

		const mode = dep.getMode(moduleGraph, runtime);

		if (concatenationScope) {
			switch (mode.type) {
				case &quot;reexport-undefined&quot;:
					concatenationScope.registerRawExport(
						/** @type {NonNullable&lt;ExportMode[&quot;name&quot;]&gt;} */ (mode.name),
						&quot;/* reexport non-default export from non-harmony */ undefined&quot;
					);
			}
			return;
		}

		if (mode.type !== &quot;unused&quot; &amp;&amp; mode.type !== &quot;empty-star&quot;) {
			super.apply(dependency, source, templateContext);

			this._addExportFragments(
				templateContext.initFragments,
				dep,
				mode,
				templateContext.module,
				moduleGraph,
				runtime,
				templateContext.runtimeTemplate,
				templateContext.runtimeRequirements
			);
		}
	}

	/**
	 * @param {InitFragment&lt;GenerateContext&gt;[]} initFragments target array for init fragments
	 * @param {HarmonyExportImportedSpecifierDependency} dep dependency
	 * @param {ExportMode} mode the export mode
	 * @param {Module} module the current module
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {RuntimeSpec} runtime the runtime
	 * @param {RuntimeTemplate} runtimeTemplate the runtime template
	 * @param {RuntimeRequirements} runtimeRequirements runtime requirements
	 * @returns {void}
	 */
	_addExportFragments(
		initFragments,
		dep,
		mode,
		module,
		moduleGraph,
		runtime,
		runtimeTemplate,
		runtimeRequirements
	) {
		const importedModule = /** @type {Module} */ (moduleGraph.getModule(dep));
		const importVar = dep.getImportVar(moduleGraph);

		switch (mode.type) {
			case &quot;missing&quot;:
			case &quot;empty-star&quot;:
				initFragments.push(
					new InitFragment(
						&quot;/* empty/unused harmony star reexport */\n&quot;,
						InitFragment.STAGE_HARMONY_EXPORTS,
						1
					)
				);
				break;

			case &quot;unused&quot;:
				initFragments.push(
					new InitFragment(
						`${Template.toNormalComment(
							`unused harmony reexport ${mode.name}`
						)}\n`,
						InitFragment.STAGE_HARMONY_EXPORTS,
						1
					)
				);
				break;

			case &quot;reexport-dynamic-default&quot;:
				initFragments.push(
					this.getReexportFragment(
						module,
						&quot;reexport default from dynamic&quot;,
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string} */ (mode.name), runtime),
						importVar,
						null,
						runtimeRequirements
					)
				);
				break;

			case &quot;reexport-fake-namespace-object&quot;:
				initFragments.push(
					...this.getReexportFakeNamespaceObjectFragments(
						module,
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string} */ (mode.name), runtime),
						importVar,
						mode.fakeType,
						runtimeRequirements
					)
				);
				break;

			case &quot;reexport-undefined&quot;:
				initFragments.push(
					this.getReexportFragment(
						module,
						&quot;reexport non-default export from non-harmony&quot;,
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string} */ (mode.name), runtime),
						&quot;undefined&quot;,
						&quot;&quot;,
						runtimeRequirements
					)
				);
				break;

			case &quot;reexport-named-default&quot;:
				initFragments.push(
					this.getReexportFragment(
						module,
						&quot;reexport default export from named module&quot;,
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string} */ (mode.name), runtime),
						importVar,
						&quot;&quot;,
						runtimeRequirements
					)
				);
				break;

			case &quot;reexport-namespace-object&quot;:
				initFragments.push(
					this.getReexportFragment(
						module,
						&quot;reexport module object&quot;,
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string} */ (mode.name), runtime),
						importVar,
						&quot;&quot;,
						runtimeRequirements
					)
				);
				break;

			case &quot;normal-reexport&quot;:
				for (const {
					name,
					ids,
					checked,
					hidden
				} of /** @type {NormalReexportItem[]} */ (mode.items)) {
					if (hidden) continue;
					if (checked) {
						const connection = moduleGraph.getConnection(dep);
						const key = `harmony reexport (checked) ${importVar} ${name}`;
						const runtimeCondition = dep.weak
							? false
							: connection
								? filterRuntime(runtime, r =&gt; connection.isTargetActive(r))
								: true;
						initFragments.push(
							new ConditionalInitFragment(
								`/* harmony reexport (checked) */ ${this.getConditionalReexportStatement(
									module,
									name,
									importVar,
									ids,
									runtimeRequirements
								)}`,
								moduleGraph.isAsync(importedModule)
									? InitFragment.STAGE_ASYNC_HARMONY_IMPORTS
									: InitFragment.STAGE_HARMONY_IMPORTS,
								dep.sourceOrder,
								key,
								runtimeCondition
							)
						);
					} else {
						initFragments.push(
							this.getReexportFragment(
								module,
								&quot;reexport safe&quot;,
								moduleGraph.getExportsInfo(module).getUsedName(name, runtime),
								importVar,
								moduleGraph
									.getExportsInfo(importedModule)
									.getUsedName(ids, runtime),
								runtimeRequirements
							)
						);
					}
				}
				break;

			case &quot;dynamic-reexport&quot;: {
				const ignored = mode.hidden
					? combine(
							/** @type {ExportModeIgnored} */
							(mode.ignored),
							mode.hidden
						)
					: /** @type {ExportModeIgnored} */ (mode.ignored);
				const modern =
					runtimeTemplate.supportsConst() &amp;&amp;
					runtimeTemplate.supportsArrowFunction();
				let content =
					&quot;/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n&quot; +
					`/* harmony reexport (unknown) */ for(${
						modern ? &quot;const&quot; : &quot;var&quot;
					} __WEBPACK_IMPORT_KEY__ in ${importVar}) `;

				// Filter out exports which are defined by other exports
				// and filter out default export because it cannot be reexported with *
				if (ignored.size &gt; 1) {
					content += `if(${JSON.stringify(
						Array.from(ignored)
					)}.indexOf(__WEBPACK_IMPORT_KEY__) &lt; 0) `;
				} else if (ignored.size === 1) {
					content += `if(__WEBPACK_IMPORT_KEY__ !== ${JSON.stringify(
						first(ignored)
					)}) `;
				}

				content += &quot;__WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = &quot;;
				content += modern
					? `() =&gt; ${importVar}[__WEBPACK_IMPORT_KEY__]`
					: `function(key) { return ${importVar}[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)`;

				runtimeRequirements.add(RuntimeGlobals.exports);
				runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);

				const exportsName = module.exportsArgument;
				initFragments.push(
					new InitFragment(
						`${content}\n/* harmony reexport (unknown) */ ${RuntimeGlobals.definePropertyGetters}(${exportsName}, __WEBPACK_REEXPORT_OBJECT__);\n`,
						moduleGraph.isAsync(importedModule)
							? InitFragment.STAGE_ASYNC_HARMONY_IMPORTS
							: InitFragment.STAGE_HARMONY_IMPORTS,
						dep.sourceOrder
					)
				);
				break;
			}

			default:
				throw new Error(`Unknown mode ${mode.type}`);
		}
	}

	/**
	 * @param {Module} module the current module
	 * @param {string} comment comment
	 * @param {UsedName} key key
	 * @param {string} name name
	 * @param {string | string[] | null | false} valueKey value key
	 * @param {RuntimeRequirements} runtimeRequirements runtime requirements
	 * @returns {HarmonyExportInitFragment} harmony export init fragment
	 */
	getReexportFragment(
		module,
		comment,
		key,
		name,
		valueKey,
		runtimeRequirements
	) {
		const returnValue = this.getReturnValue(name, valueKey);

		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);

		const map = new Map();
		map.set(key, `/* ${comment} */ ${returnValue}`);

		return new HarmonyExportInitFragment(module.exportsArgument, map);
	}

	/**
	 * @param {Module} module module
	 * @param {string | string[] | false} key key
	 * @param {string} name name
	 * @param {number} fakeType fake type
	 * @param {RuntimeRequirements} runtimeRequirements runtime requirements
	 * @returns {[InitFragment&lt;GenerateContext&gt;, HarmonyExportInitFragment]} init fragments
	 */
	getReexportFakeNamespaceObjectFragments(
		module,
		key,
		name,
		fakeType,
		runtimeRequirements
	) {
		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
		runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);

		const map = new Map();
		map.set(
			key,
			`/* reexport fake namespace object from non-harmony */ ${name}_namespace_cache || (${name}_namespace_cache = ${
				RuntimeGlobals.createFakeNamespaceObject
			}(${name}${fakeType ? `, ${fakeType}` : &quot;&quot;}))`
		);

		return [
			new InitFragment(
				`var ${name}_namespace_cache;\n`,
				InitFragment.STAGE_CONSTANTS,
				-1,
				`${name}_namespace_cache`
			),
			new HarmonyExportInitFragment(module.exportsArgument, map)
		];
	}

	/**
	 * @param {Module} module module
	 * @param {string} key key
	 * @param {string} name name
	 * @param {string | string[] | false} valueKey value key
	 * @param {RuntimeRequirements} runtimeRequirements runtime requirements
	 * @returns {string} result
	 */
	getConditionalReexportStatement(
		module,
		key,
		name,
		valueKey,
		runtimeRequirements
	) {
		if (valueKey === false) {
			return &quot;/* unused export */\n&quot;;
		}

		const exportsName = module.exportsArgument;
		const returnValue = this.getReturnValue(name, valueKey);

		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
		runtimeRequirements.add(RuntimeGlobals.hasOwnProperty);

		return `if(${RuntimeGlobals.hasOwnProperty}(${name}, ${JSON.stringify(
			valueKey[0]
		)})) ${
			RuntimeGlobals.definePropertyGetters
		}(${exportsName}, { ${propertyName(
			key
		)}: function() { return ${returnValue}; } });\n`;
	}

	/**
	 * @param {string} name name
	 * @param {null | false | string | string[]} valueKey value key
	 * @returns {string | undefined} value
	 */
	getReturnValue(name, valueKey) {
		if (valueKey === null) {
			return `${name}_default.a`;
		}

		if (valueKey === &quot;&quot;) {
			return name;
		}

		if (valueKey === false) {
			return &quot;/* unused export */ undefined&quot;;
		}

		return `${name}${propertyAccess(valueKey)}`;
	}
};

class HarmonyStarExportsList {
	constructor() {
		/** @type {HarmonyExportImportedSpecifierDependency[]} */
		this.dependencies = [];
	}

	/**
	 * @param {HarmonyExportImportedSpecifierDependency} dep dependency
	 * @returns {void}
	 */
	push(dep) {
		this.dependencies.push(dep);
	}

	slice() {
		return this.dependencies.slice();
	}

	/**
	 * @param {ObjectSerializerContext} context context
	 */
	serialize({ write, setCircularReference }) {
		setCircularReference(this);
		write(this.dependencies);
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 */
	deserialize({ read, setCircularReference }) {
		setCircularReference(this);
		this.dependencies = read();
	}
}

makeSerializable(
	HarmonyStarExportsList,
	&quot;webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency&quot;,
	&quot;HarmonyStarExportsList&quot;
);

module.exports.HarmonyStarExportsList = HarmonyStarExportsList;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
