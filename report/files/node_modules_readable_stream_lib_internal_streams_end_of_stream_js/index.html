<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/readable-stream/lib/internal/streams/end-of-stream.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/readable-stream/lib/internal/streams/end-of-stream.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">287</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.56</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

&#039;use strict&#039;

/* replacement start */

const process = require(&#039;process/&#039;)

/* replacement end */

const { AbortError, codes } = require(&#039;../../ours/errors&#039;)
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes
const { kEmptyObject, once } = require(&#039;../../ours/util&#039;)
const { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require(&#039;../validators&#039;)
const { Promise, PromisePrototypeThen, SymbolDispose } = require(&#039;../../ours/primordials&#039;)
const {
  isClosed,
  isReadable,
  isReadableNodeStream,
  isReadableStream,
  isReadableFinished,
  isReadableErrored,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableFinished,
  isWritableErrored,
  isNodeStream,
  willEmitClose: _willEmitClose,
  kIsClosedPromise
} = require(&#039;./utils&#039;)
let addAbortListener
function isRequest(stream) {
  return stream.setHeader &amp;&amp; typeof stream.abort === &#039;function&#039;
}
const nop = () =&gt; {}
function eos(stream, options, callback) {
  var _options$readable, _options$writable
  if (arguments.length === 2) {
    callback = options
    options = kEmptyObject
  } else if (options == null) {
    options = kEmptyObject
  } else {
    validateObject(options, &#039;options&#039;)
  }
  validateFunction(callback, &#039;callback&#039;)
  validateAbortSignal(options.signal, &#039;options.signal&#039;)
  callback = once(callback)
  if (isReadableStream(stream) || isWritableStream(stream)) {
    return eosWeb(stream, options, callback)
  }
  if (!isNodeStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE(&#039;stream&#039;, [&#039;ReadableStream&#039;, &#039;WritableStream&#039;, &#039;Stream&#039;], stream)
  }
  const readable =
    (_options$readable = options.readable) !== null &amp;&amp; _options$readable !== undefined
      ? _options$readable
      : isReadableNodeStream(stream)
  const writable =
    (_options$writable = options.writable) !== null &amp;&amp; _options$writable !== undefined
      ? _options$writable
      : isWritableNodeStream(stream)
  const wState = stream._writableState
  const rState = stream._readableState
  const onlegacyfinish = () =&gt; {
    if (!stream.writable) {
      onfinish()
    }
  }

  // TODO (ronag): Improve soft detection to include core modules and
  // common ecosystem modules that do properly emit &#039;close&#039; but fail
  // this generic check.
  let willEmitClose =
    _willEmitClose(stream) &amp;&amp; isReadableNodeStream(stream) === readable &amp;&amp; isWritableNodeStream(stream) === writable
  let writableFinished = isWritableFinished(stream, false)
  const onfinish = () =&gt; {
    writableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose &amp;&amp; (!stream.readable || readable)) {
      return
    }
    if (!readable || readableFinished) {
      callback.call(stream)
    }
  }
  let readableFinished = isReadableFinished(stream, false)
  const onend = () =&gt; {
    readableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose &amp;&amp; (!stream.writable || writable)) {
      return
    }
    if (!writable || writableFinished) {
      callback.call(stream)
    }
  }
  const onerror = (err) =&gt; {
    callback.call(stream, err)
  }
  let closed = isClosed(stream)
  const onclose = () =&gt; {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored &amp;&amp; typeof errored !== &#039;boolean&#039;) {
      return callback.call(stream, errored)
    }
    if (readable &amp;&amp; !readableFinished &amp;&amp; isReadableNodeStream(stream, true)) {
      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    if (writable &amp;&amp; !writableFinished) {
      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    callback.call(stream)
  }
  const onclosed = () =&gt; {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored &amp;&amp; typeof errored !== &#039;boolean&#039;) {
      return callback.call(stream, errored)
    }
    callback.call(stream)
  }
  const onrequest = () =&gt; {
    stream.req.on(&#039;finish&#039;, onfinish)
  }
  if (isRequest(stream)) {
    stream.on(&#039;complete&#039;, onfinish)
    if (!willEmitClose) {
      stream.on(&#039;abort&#039;, onclose)
    }
    if (stream.req) {
      onrequest()
    } else {
      stream.on(&#039;request&#039;, onrequest)
    }
  } else if (writable &amp;&amp; !wState) {
    // legacy streams
    stream.on(&#039;end&#039;, onlegacyfinish)
    stream.on(&#039;close&#039;, onlegacyfinish)
  }

  // Not all streams will emit &#039;close&#039; after &#039;aborted&#039;.
  if (!willEmitClose &amp;&amp; typeof stream.aborted === &#039;boolean&#039;) {
    stream.on(&#039;aborted&#039;, onclose)
  }
  stream.on(&#039;end&#039;, onend)
  stream.on(&#039;finish&#039;, onfinish)
  if (options.error !== false) {
    stream.on(&#039;error&#039;, onerror)
  }
  stream.on(&#039;close&#039;, onclose)
  if (closed) {
    process.nextTick(onclose)
  } else if (
    (wState !== null &amp;&amp; wState !== undefined &amp;&amp; wState.errorEmitted) ||
    (rState !== null &amp;&amp; rState !== undefined &amp;&amp; rState.errorEmitted)
  ) {
    if (!willEmitClose) {
      process.nextTick(onclosed)
    }
  } else if (
    !readable &amp;&amp;
    (!willEmitClose || isReadable(stream)) &amp;&amp;
    (writableFinished || isWritable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (
    !writable &amp;&amp;
    (!willEmitClose || isWritable(stream)) &amp;&amp;
    (readableFinished || isReadable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (rState &amp;&amp; stream.req &amp;&amp; stream.aborted) {
    process.nextTick(onclosed)
  }
  const cleanup = () =&gt; {
    callback = nop
    stream.removeListener(&#039;aborted&#039;, onclose)
    stream.removeListener(&#039;complete&#039;, onfinish)
    stream.removeListener(&#039;abort&#039;, onclose)
    stream.removeListener(&#039;request&#039;, onrequest)
    if (stream.req) stream.req.removeListener(&#039;finish&#039;, onfinish)
    stream.removeListener(&#039;end&#039;, onlegacyfinish)
    stream.removeListener(&#039;close&#039;, onlegacyfinish)
    stream.removeListener(&#039;finish&#039;, onfinish)
    stream.removeListener(&#039;end&#039;, onend)
    stream.removeListener(&#039;error&#039;, onerror)
    stream.removeListener(&#039;close&#039;, onclose)
  }
  if (options.signal &amp;&amp; !closed) {
    const abort = () =&gt; {
      // Keep it because cleanup removes it.
      const endCallback = callback
      cleanup()
      endCallback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      addAbortListener = addAbortListener || require(&#039;../../ours/util&#039;).addAbortListener
      const disposable = addAbortListener(options.signal, abort)
      const originalCallback = callback
      callback = once((...args) =&gt; {
        disposable[SymbolDispose]()
        originalCallback.apply(stream, args)
      })
    }
  }
  return cleanup
}
function eosWeb(stream, options, callback) {
  let isAborted = false
  let abort = nop
  if (options.signal) {
    abort = () =&gt; {
      isAborted = true
      callback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      addAbortListener = addAbortListener || require(&#039;../../ours/util&#039;).addAbortListener
      const disposable = addAbortListener(options.signal, abort)
      const originalCallback = callback
      callback = once((...args) =&gt; {
        disposable[SymbolDispose]()
        originalCallback.apply(stream, args)
      })
    }
  }
  const resolverFn = (...args) =&gt; {
    if (!isAborted) {
      process.nextTick(() =&gt; callback.apply(stream, args))
    }
  }
  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)
  return nop
}
function finished(stream, opts) {
  var _opts
  let autoCleanup = false
  if (opts === null) {
    opts = kEmptyObject
  }
  if ((_opts = opts) !== null &amp;&amp; _opts !== undefined &amp;&amp; _opts.cleanup) {
    validateBoolean(opts.cleanup, &#039;cleanup&#039;)
    autoCleanup = opts.cleanup
  }
  return new Promise((resolve, reject) =&gt; {
    const cleanup = eos(stream, opts, (err) =&gt; {
      if (autoCleanup) {
        cleanup()
      }
      if (err) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}
module.exports = eos
module.exports.finished = finished
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
