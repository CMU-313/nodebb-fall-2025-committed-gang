<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-useless-return.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-useless-return.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">402</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">39.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.60</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Disallow redundant return statements
 * @author Teddy Katz
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;),
	FixTracker = require(&quot;./utils/fix-tracker&quot;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Removes the given element from the array.
 * @param {Array} array The source array to remove.
 * @param {any} element The target item to remove.
 * @returns {void}
 */
function remove(array, element) {
	const index = array.indexOf(element);

	if (index !== -1) {
		array.splice(index, 1);
	}
}

/**
 * Checks whether it can remove the given return statement or not.
 * @param {ASTNode} node The return statement node to check.
 * @returns {boolean} `true` if the node is removable.
 */
function isRemovable(node) {
	return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}

/**
 * Checks whether the given return statement is in a `finally` block or not.
 * @param {ASTNode} node The return statement node to check.
 * @returns {boolean} `true` if the node is in a `finally` block.
 */
function isInFinally(node) {
	for (
		let currentNode = node;
		currentNode &amp;&amp; currentNode.parent &amp;&amp; !astUtils.isFunction(currentNode);
		currentNode = currentNode.parent
	) {
		if (
			currentNode.parent.type === &quot;TryStatement&quot; &amp;&amp;
			currentNode.parent.finalizer === currentNode
		) {
			return true;
		}
	}

	return false;
}

/**
 * Checks all segments in a set and returns true if any are reachable.
 * @param {Set&lt;CodePathSegment&gt;} segments The segments to check.
 * @returns {boolean} True if any segment is reachable; false otherwise.
 */
function isAnySegmentReachable(segments) {
	for (const segment of segments) {
		if (segment.reachable) {
			return true;
		}
	}

	return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		docs: {
			description: &quot;Disallow redundant return statements&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/no-useless-return&quot;,
		},

		fixable: &quot;code&quot;,
		schema: [],

		messages: {
			unnecessaryReturn: &quot;Unnecessary return statement.&quot;,
		},
	},

	create(context) {
		const segmentInfoMap = new WeakMap();
		const sourceCode = context.sourceCode;
		let scopeInfo = null;

		/**
		 * Checks whether the given segment is terminated by a return statement or not.
		 * @param {CodePathSegment} segment The segment to check.
		 * @returns {boolean} `true` if the segment is terminated by a return statement, or if it&#039;s still a part of unreachable.
		 */
		function isReturned(segment) {
			const info = segmentInfoMap.get(segment);

			return !info || info.returned;
		}

		/**
		 * Collects useless return statements from the given previous segments.
		 *
		 * A previous segment may be an unreachable segment.
		 * In that case, the information object of the unreachable segment is not
		 * initialized because `onCodePathSegmentStart` event is not notified for
		 * unreachable segments.
		 * This goes to the previous segments of the unreachable segment recursively
		 * if the unreachable segment was generated by a return statement. Otherwise,
		 * this ignores the unreachable segment.
		 *
		 * This behavior would simulate code paths for the case that the return
		 * statement does not exist.
		 * @param {ASTNode[]} uselessReturns The collected return statements.
		 * @param {CodePathSegment[]} prevSegments The previous segments to traverse.
		 * @param {WeakSet&lt;CodePathSegment&gt;} [providedTraversedSegments] A set of segments that have already been traversed in this call
		 * @returns {ASTNode[]} `uselessReturns`.
		 */
		function getUselessReturns(
			uselessReturns,
			prevSegments,
			providedTraversedSegments,
		) {
			const traversedSegments =
				providedTraversedSegments || new WeakSet();

			for (const segment of prevSegments) {
				if (!segment.reachable) {
					if (!traversedSegments.has(segment)) {
						traversedSegments.add(segment);
						getUselessReturns(
							uselessReturns,
							segment.allPrevSegments.filter(isReturned),
							traversedSegments,
						);
					}
					continue;
				}

				if (segmentInfoMap.has(segment)) {
					uselessReturns.push(
						...segmentInfoMap.get(segment).uselessReturns,
					);
				}
			}

			return uselessReturns;
		}

		/**
		 * Removes the return statements on the given segment from the useless return
		 * statement list.
		 *
		 * This segment may be an unreachable segment.
		 * In that case, the information object of the unreachable segment is not
		 * initialized because `onCodePathSegmentStart` event is not notified for
		 * unreachable segments.
		 * This goes to the previous segments of the unreachable segment recursively
		 * if the unreachable segment was generated by a return statement. Otherwise,
		 * this ignores the unreachable segment.
		 *
		 * This behavior would simulate code paths for the case that the return
		 * statement does not exist.
		 * @param {CodePathSegment} segment The segment to get return statements.
		 * @param {Set&lt;CodePathSegment&gt;} usedUnreachableSegments A set of segments that have already been traversed in this call.
		 * @returns {void}
		 */
		function markReturnStatementsOnSegmentAsUsed(
			segment,
			usedUnreachableSegments,
		) {
			if (!segment.reachable) {
				usedUnreachableSegments.add(segment);
				segment.allPrevSegments
					.filter(isReturned)
					.filter(
						prevSegment =&gt;
							!usedUnreachableSegments.has(prevSegment),
					)
					.forEach(prevSegment =&gt;
						markReturnStatementsOnSegmentAsUsed(
							prevSegment,
							usedUnreachableSegments,
						),
					);
				return;
			}

			const info = segmentInfoMap.get(segment);

			if (!info) {
				return;
			}

			info.uselessReturns = info.uselessReturns.filter(node =&gt; {
				if (
					scopeInfo.traversedTryBlockStatements &amp;&amp;
					scopeInfo.traversedTryBlockStatements.length &gt; 0
				) {
					const returnInitialRange = node.range[0];
					const returnFinalRange = node.range[1];

					const areBlocksInRange =
						scopeInfo.traversedTryBlockStatements.some(
							tryBlockStatement =&gt; {
								const blockInitialRange =
									tryBlockStatement.range[0];
								const blockFinalRange =
									tryBlockStatement.range[1];

								return (
									returnInitialRange &gt;= blockInitialRange &amp;&amp;
									returnFinalRange &lt;= blockFinalRange
								);
							},
						);

					if (areBlocksInRange) {
						return true;
					}
				}

				remove(scopeInfo.uselessReturns, node);
				return false;
			});
		}

		/**
		 * Removes the return statements on the current segments from the useless
		 * return statement list.
		 *
		 * This function will be called at every statement except FunctionDeclaration,
		 * BlockStatement, and BreakStatement.
		 *
		 * - FunctionDeclarations are always executed whether it&#039;s returned or not.
		 * - BlockStatements do nothing.
		 * - BreakStatements go the next merely.
		 * @returns {void}
		 */
		function markReturnStatementsOnCurrentSegmentsAsUsed() {
			scopeInfo.currentSegments.forEach(segment =&gt;
				markReturnStatementsOnSegmentAsUsed(segment, new Set()),
			);
		}

		//----------------------------------------------------------------------
		// Public
		//----------------------------------------------------------------------

		return {
			// Makes and pushes a new scope information.
			onCodePathStart(codePath) {
				scopeInfo = {
					upper: scopeInfo,
					uselessReturns: [],
					traversedTryBlockStatements: [],
					codePath,
					currentSegments: new Set(),
				};
			},

			// Reports useless return statements if exist.
			onCodePathEnd() {
				for (const node of scopeInfo.uselessReturns) {
					context.report({
						node,
						loc: node.loc,
						messageId: &quot;unnecessaryReturn&quot;,
						fix(fixer) {
							if (
								isRemovable(node) &amp;&amp;
								!sourceCode.getCommentsInside(node).length
							) {
								/*
								 * Extend the replacement range to include the
								 * entire function to avoid conflicting with
								 * no-else-return.
								 * https://github.com/eslint/eslint/issues/8026
								 */
								return new FixTracker(fixer, sourceCode)
									.retainEnclosingFunction(node)
									.remove(node);
							}
							return null;
						},
					});
				}

				scopeInfo = scopeInfo.upper;
			},

			/*
			 * Initializes segments.
			 * NOTE: This event is notified for only reachable segments.
			 */
			onCodePathSegmentStart(segment) {
				scopeInfo.currentSegments.add(segment);

				const info = {
					uselessReturns: getUselessReturns(
						[],
						segment.allPrevSegments,
					),
					returned: false,
				};

				// Stores the info.
				segmentInfoMap.set(segment, info);
			},

			onUnreachableCodePathSegmentStart(segment) {
				scopeInfo.currentSegments.add(segment);
			},

			onUnreachableCodePathSegmentEnd(segment) {
				scopeInfo.currentSegments.delete(segment);
			},

			onCodePathSegmentEnd(segment) {
				scopeInfo.currentSegments.delete(segment);
			},

			// Adds ReturnStatement node to check whether it&#039;s useless or not.
			ReturnStatement(node) {
				if (node.argument) {
					markReturnStatementsOnCurrentSegmentsAsUsed();
				}
				if (
					node.argument ||
					astUtils.isInLoop(node) ||
					isInFinally(node) ||
					// Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
					!isAnySegmentReachable(scopeInfo.currentSegments)
				) {
					return;
				}

				for (const segment of scopeInfo.currentSegments) {
					const info = segmentInfoMap.get(segment);

					if (info) {
						info.uselessReturns.push(node);
						info.returned = true;
					}
				}
				scopeInfo.uselessReturns.push(node);
			},

			&quot;TryStatement &gt; BlockStatement.block:exit&quot;(node) {
				scopeInfo.traversedTryBlockStatements.push(node);
			},

			&quot;TryStatement:exit&quot;() {
				scopeInfo.traversedTryBlockStatements.pop();
			},

			/*
			 * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
			 * Removes return statements of the current segments from the useless return statement list.
			 */
			ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportDefaultDeclaration:
				markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
