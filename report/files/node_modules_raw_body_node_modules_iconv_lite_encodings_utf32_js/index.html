<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/raw-body/node_modules/iconv-lite/encodings/utf32.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/raw-body/node_modules/iconv-lite/encodings/utf32.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">308</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;

var Buffer = require(&quot;safer-buffer&quot;).Buffer

// == UTF32-LE/BE codec. ==========================================================

exports._utf32 = Utf32Codec

function Utf32Codec (codecOptions, iconv) {
  this.iconv = iconv
  this.bomAware = true
  this.isLE = codecOptions.isLE
}

exports.utf32le = { type: &quot;_utf32&quot;, isLE: true }
exports.utf32be = { type: &quot;_utf32&quot;, isLE: false }

// Aliases
exports.ucs4le = &quot;utf32le&quot;
exports.ucs4be = &quot;utf32be&quot;

Utf32Codec.prototype.encoder = Utf32Encoder
Utf32Codec.prototype.decoder = Utf32Decoder

// -- Encoding

function Utf32Encoder (options, codec) {
  this.isLE = codec.isLE
  this.highSurrogate = 0
}

Utf32Encoder.prototype.write = function (str) {
  var src = Buffer.from(str, &quot;ucs2&quot;)
  var dst = Buffer.alloc(src.length * 2)
  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE
  var offset = 0

  for (var i = 0; i &lt; src.length; i += 2) {
    var code = src.readUInt16LE(i)
    var isHighSurrogate = (code &gt;= 0xD800 &amp;&amp; code &lt; 0xDC00)
    var isLowSurrogate = (code &gt;= 0xDC00 &amp;&amp; code &lt; 0xE000)

    if (this.highSurrogate) {
      if (isHighSurrogate || !isLowSurrogate) {
        // There shouldn&#039;t be two high surrogates in a row, nor a high surrogate which isn&#039;t followed by a low
        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
        // (technically wrong, but expected by some applications, like Windows file names).
        write32.call(dst, this.highSurrogate, offset)
        offset += 4
      } else {
        // Create 32-bit value from high and low surrogates;
        var codepoint = (((this.highSurrogate - 0xD800) &lt;&lt; 10) | (code - 0xDC00)) + 0x10000

        write32.call(dst, codepoint, offset)
        offset += 4
        this.highSurrogate = 0

        continue
      }
    }

    if (isHighSurrogate) { this.highSurrogate = code } else {
      // Even if the current character is a low surrogate, with no previous high surrogate, we&#039;ll
      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
      // unpaired high surrogates.
      write32.call(dst, code, offset)
      offset += 4
      this.highSurrogate = 0
    }
  }

  if (offset &lt; dst.length) { dst = dst.slice(0, offset) }

  return dst
}

Utf32Encoder.prototype.end = function () {
  // Treat any leftover high surrogate as a semi-valid independent character.
  if (!this.highSurrogate) { return }

  var buf = Buffer.alloc(4)

  if (this.isLE) { buf.writeUInt32LE(this.highSurrogate, 0) } else { buf.writeUInt32BE(this.highSurrogate, 0) }

  this.highSurrogate = 0

  return buf
}

// -- Decoding

function Utf32Decoder (options, codec) {
  this.isLE = codec.isLE
  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0)
  this.overflow = []
}

Utf32Decoder.prototype.write = function (src) {
  if (src.length === 0) { return &quot;&quot; }

  var i = 0
  var codepoint = 0
  var dst = Buffer.alloc(src.length + 4)
  var offset = 0
  var isLE = this.isLE
  var overflow = this.overflow
  var badChar = this.badChar

  if (overflow.length &gt; 0) {
    for (; i &lt; src.length &amp;&amp; overflow.length &lt; 4; i++) { overflow.push(src[i]) }

    if (overflow.length === 4) {
      // NOTE: codepoint is a signed int32 and can be negative.
      // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
      if (isLE) {
        codepoint = overflow[i] | (overflow[i + 1] &lt;&lt; 8) | (overflow[i + 2] &lt;&lt; 16) | (overflow[i + 3] &lt;&lt; 24)
      } else {
        codepoint = overflow[i + 3] | (overflow[i + 2] &lt;&lt; 8) | (overflow[i + 1] &lt;&lt; 16) | (overflow[i] &lt;&lt; 24)
      }
      overflow.length = 0

      offset = _writeCodepoint(dst, offset, codepoint, badChar)
    }
  }

  // Main loop. Should be as optimized as possible.
  for (; i &lt; src.length - 3; i += 4) {
    // NOTE: codepoint is a signed int32 and can be negative.
    if (isLE) {
      codepoint = src[i] | (src[i + 1] &lt;&lt; 8) | (src[i + 2] &lt;&lt; 16) | (src[i + 3] &lt;&lt; 24)
    } else {
      codepoint = src[i + 3] | (src[i + 2] &lt;&lt; 8) | (src[i + 1] &lt;&lt; 16) | (src[i] &lt;&lt; 24)
    }
    offset = _writeCodepoint(dst, offset, codepoint, badChar)
  }

  // Keep overflowing bytes.
  for (; i &lt; src.length; i++) {
    overflow.push(src[i])
  }

  return dst.slice(0, offset).toString(&quot;ucs2&quot;)
}

function _writeCodepoint (dst, offset, codepoint, badChar) {
  // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
  if (codepoint &lt; 0 || codepoint &gt; 0x10FFFF) {
    // Not a valid Unicode codepoint
    codepoint = badChar
  }

  // Ephemeral Planes: Write high surrogate.
  if (codepoint &gt;= 0x10000) {
    codepoint -= 0x10000

    var high = 0xD800 | (codepoint &gt;&gt; 10)
    dst[offset++] = high &amp; 0xff
    dst[offset++] = high &gt;&gt; 8

    // Low surrogate is written below.
    var codepoint = 0xDC00 | (codepoint &amp; 0x3FF)
  }

  // Write BMP char or low surrogate.
  dst[offset++] = codepoint &amp; 0xff
  dst[offset++] = codepoint &gt;&gt; 8

  return offset
};

Utf32Decoder.prototype.end = function () {
  this.overflow.length = 0
}

// == UTF-32 Auto codec =============================================================
// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
// Encoder/decoder default can be changed: iconv.decode(buf, &#039;utf32&#039;, {defaultEncoding: &#039;utf-32be&#039;});

// Encoder prepends BOM (which can be overridden with (addBOM: false}).

exports.utf32 = Utf32AutoCodec
exports.ucs4 = &quot;utf32&quot;

function Utf32AutoCodec (options, iconv) {
  this.iconv = iconv
}

Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder
Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder

// -- Encoding

function Utf32AutoEncoder (options, codec) {
  options = options || {}

  if (options.addBOM === undefined) {
    options.addBOM = true
  }

  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || &quot;utf-32le&quot;, options)
}

Utf32AutoEncoder.prototype.write = function (str) {
  return this.encoder.write(str)
}

Utf32AutoEncoder.prototype.end = function () {
  return this.encoder.end()
}

// -- Decoding

function Utf32AutoDecoder (options, codec) {
  this.decoder = null
  this.initialBufs = []
  this.initialBufsLen = 0
  this.options = options || {}
  this.iconv = codec.iconv
}

Utf32AutoDecoder.prototype.write = function (buf) {
  if (!this.decoder) {
    // Codec is not chosen yet. Accumulate initial bytes.
    this.initialBufs.push(buf)
    this.initialBufsLen += buf.length

    if (this.initialBufsLen &lt; 32) // We need more bytes to use space heuristic (see below)
    { return &quot;&quot; }

    // We have enough bytes -&gt; detect endianness.
    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)
    this.decoder = this.iconv.getDecoder(encoding, this.options)

    var resStr = &quot;&quot;
    for (var i = 0; i &lt; this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }

    this.initialBufs.length = this.initialBufsLen = 0
    return resStr
  }

  return this.decoder.write(buf)
}

Utf32AutoDecoder.prototype.end = function () {
  if (!this.decoder) {
    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)
    this.decoder = this.iconv.getDecoder(encoding, this.options)

    var resStr = &quot;&quot;
    for (var i = 0; i &lt; this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }

    var trail = this.decoder.end()
    if (trail) { resStr += trail }

    this.initialBufs.length = this.initialBufsLen = 0
    return resStr
  }

  return this.decoder.end()
}

function detectEncoding (bufs, defaultEncoding) {
  var b = []
  var charsProcessed = 0
  var invalidLE = 0; var invalidBE = 0   // Number of invalid chars when decoded as LE or BE.
  var bmpCharsLE = 0; var bmpCharsBE = 0 // Number of BMP chars when decoded as LE or BE.

  outerLoop:
  for (var i = 0; i &lt; bufs.length; i++) {
    var buf = bufs[i]
    for (var j = 0; j &lt; buf.length; j++) {
      b.push(buf[j])
      if (b.length === 4) {
        if (charsProcessed === 0) {
          // Check BOM first.
          if (b[0] === 0xFF &amp;&amp; b[1] === 0xFE &amp;&amp; b[2] === 0 &amp;&amp; b[3] === 0) {
            return &quot;utf-32le&quot;
          }
          if (b[0] === 0 &amp;&amp; b[1] === 0 &amp;&amp; b[2] === 0xFE &amp;&amp; b[3] === 0xFF) {
            return &quot;utf-32be&quot;
          }
        }

        if (b[0] !== 0 || b[1] &gt; 0x10) invalidBE++
        if (b[3] !== 0 || b[2] &gt; 0x10) invalidLE++

        if (b[0] === 0 &amp;&amp; b[1] === 0 &amp;&amp; (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++
        if ((b[0] !== 0 || b[1] !== 0) &amp;&amp; b[2] === 0 &amp;&amp; b[3] === 0) bmpCharsLE++

        b.length = 0
        charsProcessed++

        if (charsProcessed &gt;= 100) {
          break outerLoop
        }
      }
    }
  }

  // Make decisions.
  if (bmpCharsBE - invalidBE &gt; bmpCharsLE - invalidLE) return &quot;utf-32be&quot;
  if (bmpCharsBE - invalidBE &lt; bmpCharsLE - invalidLE) return &quot;utf-32le&quot;

  // Couldn&#039;t decide (likely all zeros or not enough data).
  return defaultEncoding || &quot;utf-32le&quot;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
