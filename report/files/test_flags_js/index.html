<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/flags.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/flags.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1197</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">103.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.81</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const nconf = require(&#039;nconf&#039;);
const util = require(&#039;util&#039;);

const sleep = util.promisify(setTimeout);

const db = require(&#039;./mocks/databasemock&#039;);
const helpers = require(&#039;./helpers&#039;);
const request = require(&#039;../src/request&#039;);
const Flags = require(&#039;../src/flags&#039;);
const Categories = require(&#039;../src/categories&#039;);
const Topics = require(&#039;../src/topics&#039;);
const Posts = require(&#039;../src/posts&#039;);
const User = require(&#039;../src/user&#039;);
const Groups = require(&#039;../src/groups&#039;);
const Meta = require(&#039;../src/meta&#039;);
const Privileges = require(&#039;../src/privileges&#039;);
const plugins = require(&#039;../src/plugins&#039;);
const utils = require(&#039;../src/utils&#039;);
const api = require(&#039;../src/api&#039;);

describe(&#039;Flags&#039;, () =&gt; {
	let uid1;
	let adminUid;
	let uid3;
	let moderatorUid;
	let jar;
	let csrfToken;
	let category;
	before(async () =&gt; {
		const dummyEmailerHook = async (data) =&gt; {};
		// Attach an emailer hook so related requests do not error
		plugins.hooks.register(&#039;flags-test&#039;, {
			hook: &#039;static:email.send&#039;,
			method: dummyEmailerHook,
		});

		// Create some stuff to flag
		uid1 = await User.create({ username: &#039;testUser&#039;, password: &#039;abcdef&#039;, email: &#039;b@c.com&#039; });

		adminUid = await User.create({ username: &#039;testUser2&#039;, password: &#039;abcdef&#039;, email: &#039;c@d.com&#039; });
		await Groups.join(&#039;administrators&#039;, adminUid);

		category = await Categories.create({
			name: &#039;test category&#039;,
		});
		await Topics.post({
			cid: category.cid,
			uid: uid1,
			title: &#039;Topic to flag&#039;,
			content: &#039;This is flaggable content&#039;,
		});

		uid3 = await User.create({
			username: &#039;unprivileged&#039;, password: &#039;abcdef&#039;, email: &#039;d@e.com&#039;,
		});

		moderatorUid = await User.create({
			username: &#039;moderator&#039;, password: &#039;abcdef&#039;,
		});
		await Privileges.categories.give([&#039;moderate&#039;], category.cid, [moderatorUid]);

		const login = await helpers.loginUser(&#039;moderator&#039;, &#039;abcdef&#039;);
		jar = login.jar;
		csrfToken = login.csrf_token;
	});

	after(() =&gt; {
		plugins.hooks.unregister(&#039;flags-test&#039;, &#039;static:email.send&#039;);
	});

	describe(&#039;.create()&#039;, () =&gt; {
		it(&#039;should create a flag and return its data&#039;, (done) =&gt; {
			Flags.create(&#039;post&#039;, 1, 1, &#039;Test flag&#039;, (err, flagData) =&gt; {
				assert.ifError(err);
				const compare = {
					flagId: 1,
					targetId: 1,
					type: &#039;post&#039;,
					state: &#039;open&#039;,
					target_readable: &#039;Post 1&#039;,
				};
				assert(flagData);
				for (const key of Object.keys(compare)) {
					assert.ok(flagData[key], `undefined key ${key}`);
					assert.equal(flagData[key], compare[key]);
				}

				done();
			});
		});

		it(&#039;should add the flag to the byCid zset for category 1 if it is of type post&#039;, (done) =&gt; {
			db.isSortedSetMember(`flags:byCid:${1}`, 1, (err, isMember) =&gt; {
				assert.ifError(err);
				assert.ok(isMember);
				done();
			});
		});

		it(&#039;should add the flag to the byPid zset for pid 1 if it is of type post&#039;, (done) =&gt; {
			db.isSortedSetMember(`flags:byPid:${1}`, 1, (err, isMember) =&gt; {
				assert.ifError(err);
				assert.ok(isMember);
				done();
			});
		});
	});

	describe(&#039;.addReport()&#039;, () =&gt; {
		let flagId;
		let postData;

		before(async () =&gt; {
			// Create a topic and flag it
			({ postData } = await Topics.post({
				cid: category.cid,
				uid: uid1,
				title: utils.generateUUID(),
				content: utils.generateUUID(),
			}));
			({ flagId } = await Flags.create(&#039;post&#039;, postData.pid, adminUid, utils.generateUUID()));
		});

		after(async () =&gt; {
			Flags.purge([flagId]);
		});

		it(&#039;should add a report to an existing flag&#039;, async () =&gt; {
			await Flags.addReport(flagId, &#039;post&#039;, postData.pid, uid3, utils.generateUUID(), Date.now());

			const reports = await db.getSortedSetMembers(`flag:${flagId}:reports`);
			assert.strictEqual(reports.length, 2);
		});

		it(&#039;should add an additional report even if same user calls it again&#039;, async () =&gt; {
			// This isn&#039;t exposed to the end user, but is possible via direct method call
			await Flags.addReport(flagId, &#039;post&#039;, postData.pid, uid3, utils.generateUUID(), Date.now());

			const reports = await db.getSortedSetMembers(`flag:${flagId}:reports`);
			assert.strictEqual(reports.length, 3);
		});
	});

	describe(&#039;.rescindReport()&#039;, () =&gt; {
		let flagId;
		let postData;

		before(async () =&gt; {
			// Create a topic and flag it
			({ postData } = await Topics.post({
				cid: category.cid,
				uid: uid1,
				title: utils.generateUUID(),
				content: utils.generateUUID(),
			}));
			({ flagId } = await Flags.create(&#039;post&#039;, postData.pid, adminUid, utils.generateUUID()));
		});

		after(async () =&gt; {
			Flags.purge([flagId]);
		});

		it(&#039;should remove a report from an existing flag&#039;, async () =&gt; {
			await Flags.create(&#039;post&#039;, postData.pid, uid3, utils.generateUUID());
			await Flags.rescindReport(&#039;post&#039;, postData.pid, uid3);
			const reports = await Flags.getReports(flagId);

			assert.strictEqual(reports.length, 1);
			assert(reports.every(({ reporter }) =&gt; reporter.uid !== uid3));
		});

		it(&#039;should automatically mark the flag resolved if there are no reports remaining after removal&#039;, async () =&gt; {
			await Flags.rescindReport(&#039;post&#039;, postData.pid, adminUid);
			const reports = await Flags.getReports(flagId);
			const { state } = await Flags.get(flagId);

			assert.strictEqual(reports.length, 0);
			assert.strictEqual(state, &#039;resolved&#039;);
		});
	});

	describe(&#039;.exists()&#039;, () =&gt; {
		it(&#039;should return Boolean True if a flag matching the flag hash already exists&#039;, (done) =&gt; {
			Flags.exists(&#039;post&#039;, 1, 1, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(true, exists);
				done();
			});
		});

		it(&#039;should return Boolean False if a flag matching the flag hash does not already exists&#039;, (done) =&gt; {
			Flags.exists(&#039;post&#039;, 1, 2, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(false, exists);
				done();
			});
		});
	});

	describe(&#039;.targetExists()&#039;, () =&gt; {
		it(&#039;should return Boolean True if the targeted element exists&#039;, (done) =&gt; {
			Flags.targetExists(&#039;post&#039;, 1, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(true, exists);
				done();
			});
		});

		it(&#039;should return Boolean False if the targeted element does not exist&#039;, (done) =&gt; {
			Flags.targetExists(&#039;post&#039;, 15, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(false, exists);
				done();
			});
		});
	});

	describe(&#039;.get()&#039;, () =&gt; {
		it(&#039;should retrieve and display a flag\&#039;s data&#039;, (done) =&gt; {
			Flags.get(1, (err, flagData) =&gt; {
				assert.ifError(err);
				const compare = {
					flagId: 1,
					targetId: 1,
					type: &#039;post&#039;,
					state: &#039;open&#039;,
					target_readable: &#039;Post 1&#039;,
				};
				assert(flagData);
				for (const key of Object.keys(compare)) {
					assert.ok(flagData[key], `undefined key ${key}`);
					assert.equal(flagData[key], compare[key]);
				}

				done();
			});
		});

		it(&#039;should show user history for admins&#039;, async () =&gt; {
			await Groups.join(&#039;administrators&#039;, moderatorUid);
			const { body: flagData } = await request.get(`${nconf.get(&#039;url&#039;)}/api/flags/1`, {
				jar,
				headers: {
					&#039;x-csrf-token&#039;: csrfToken,
				},
			});

			assert(flagData.history);
			assert(Array.isArray(flagData.history));

			await Groups.leave(&#039;administrators&#039;, moderatorUid);
		});

		it(&#039;should show user history for global moderators&#039;, async () =&gt; {
			await Groups.join(&#039;Global Moderators&#039;, moderatorUid);
			const { body: flagData } = await request.get(`${nconf.get(&#039;url&#039;)}/api/flags/1`, {
				jar,
				headers: {
					&#039;x-csrf-token&#039;: csrfToken,
				},
			});

			assert(flagData.history);
			assert(Array.isArray(flagData.history));

			await Groups.leave(&#039;Global Moderators&#039;, moderatorUid);
		});
	});

	describe(&#039;.list()&#039;, () =&gt; {
		it(&#039;should show a list of flags (with one item)&#039;, (done) =&gt; {
			Flags.list({
				filters: {},
				uid: 1,
			}, (err, payload) =&gt; {
				assert.ifError(err);
				assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
				assert.ok(payload.hasOwnProperty(&#039;page&#039;));
				assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
				assert.ok(Array.isArray(payload.flags));
				assert.equal(payload.flags.length, 1);

				Flags.get(payload.flags[0].flagId, (err, flagData) =&gt; {
					assert.ifError(err);
					assert.equal(payload.flags[0].flagId, flagData.flagId);
					assert.equal(payload.flags[0].description, flagData.description);
					done();
				});
			});
		});

		describe(&#039;(with filters)&#039;, () =&gt; {
			it(&#039;should return a filtered list of flags if said filters are passed in&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						state: &#039;open&#039;,
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, parseInt(payload.flags[0].flagId, 10));
					done();
				});
			});

			it(&#039;should return no flags if a filter with no matching flags is used&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						state: &#039;rejected&#039;,
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(0, payload.flags.length);
					done();
				});
			});

			it(&#039;should return a flag when filtered by cid 1&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						cid: 1,
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, payload.flags.length);
					done();
				});
			});

			it(&#039;shouldn\&#039;t return a flag when filtered by cid 2&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						cid: 2,
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(0, payload.flags.length);
					done();
				});
			});

			it(&#039;should return a flag when filtered by both cid 1 and 2&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						cid: [1, 2],
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, payload.flags.length);
					done();
				});
			});

			it(&#039;should return one flag if filtered by both cid 1 and 2 and open state&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						cid: [1, 2],
						state: &#039;open&#039;,
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(1, payload.flags.length);
					done();
				});
			});

			it(&#039;should return no flag if filtered by both cid 1 and 2 and non-open state&#039;, (done) =&gt; {
				Flags.list({
					filters: {
						cid: [1, 2],
						state: &#039;resolved&#039;,
					},
					uid: 1,
				}, (err, payload) =&gt; {
					assert.ifError(err);
					assert.ok(payload.hasOwnProperty(&#039;flags&#039;));
					assert.ok(payload.hasOwnProperty(&#039;page&#039;));
					assert.ok(payload.hasOwnProperty(&#039;pageCount&#039;));
					assert.ok(Array.isArray(payload.flags));
					assert.strictEqual(0, payload.flags.length);
					done();
				});
			});
		});

		describe(&#039;(with sort)&#039;, () =&gt; {
			before(async () =&gt; {
				// Create a second flag to test sorting
				const post = await Topics.reply({
					tid: 1,
					uid: uid1,
					content: &#039;this is a reply -- flag me&#039;,
				});
				await Flags.create(&#039;post&#039;, post.pid, adminUid, &#039;another flag&#039;);
				await Flags.create(&#039;post&#039;, 1, uid3, &#039;additional flag report&#039;);
			});

			it(&#039;should return sorted flags latest first if no sort is passed in&#039;, async () =&gt; {
				const payload = await Flags.list({
					uid: adminUid,
				});

				assert(payload.flags.every((cur, idx) =&gt; {
					if (idx === payload.flags.length - 1) {
						return true;
					}

					const next = payload.flags[idx + 1];
					return parseInt(cur.datetime, 10) &gt; parseInt(next.datetime, 10);
				}));
			});

			it(&#039;should return sorted flags oldest first if &quot;oldest&quot; sort is passed in&#039;, async () =&gt; {
				const payload = await Flags.list({
					uid: adminUid,
					sort: &#039;oldest&#039;,
				});

				assert(payload.flags.every((cur, idx) =&gt; {
					if (idx === payload.flags.length - 1) {
						return true;
					}

					const next = payload.flags[idx + 1];
					return parseInt(cur.datetime, 10) &lt; parseInt(next.datetime, 10);
				}));
			});

			it(&#039;should return flags with more reports first if &quot;reports&quot; sort is passed in&#039;, async () =&gt; {
				const payload = await Flags.list({
					uid: adminUid,
					sort: &#039;reports&#039;,
				});

				assert(payload.flags.every((cur, idx) =&gt; {
					if (idx === payload.flags.length - 1) {
						return true;
					}

					const next = payload.flags[idx + 1];
					return parseInt(cur.heat, 10) &gt;= parseInt(next.heat, 10);
				}));
			});
		});
	});

	describe(&#039;.update()&#039;, () =&gt; {
		it(&#039;should alter a flag\&#039;s various attributes and persist them to the database&#039;, (done) =&gt; {
			Flags.update(1, adminUid, {
				state: &#039;wip&#039;,
				assignee: adminUid,
			}, (err) =&gt; {
				assert.ifError(err);
				db.getObjectFields(&#039;flag:1&#039;, [&#039;state&#039;, &#039;assignee&#039;], (err, data) =&gt; {
					if (err) {
						throw err;
					}

					assert.strictEqual(&#039;wip&#039;, data.state);
					assert.ok(!isNaN(parseInt(data.assignee, 10)));
					assert.strictEqual(adminUid, parseInt(data.assignee, 10));
					done();
				});
			});
		});

		it(&#039;should persist to the flag\&#039;s history&#039;, (done) =&gt; {
			Flags.getHistory(1, (err, history) =&gt; {
				if (err) {
					throw err;
				}

				history.forEach((change) =&gt; {
					switch (change.attribute) {
						case &#039;state&#039;:
							assert.strictEqual(&#039;[[flags:state-wip]]&#039;, change.value);
							break;

						case &#039;assignee&#039;:
							assert.strictEqual(1, change.value);
							break;
					}
				});

				done();
			});
		});

		it(&#039;should allow assignment if user is an admin and do nothing otherwise&#039;, async () =&gt; {
			await Flags.update(1, adminUid, {
				assignee: adminUid,
			});
			let assignee = await db.getObjectField(&#039;flag:1&#039;, &#039;assignee&#039;);
			assert.strictEqual(adminUid, parseInt(assignee, 10));

			await Flags.update(1, adminUid, {
				assignee: uid3,
			});
			assignee = await db.getObjectField(&#039;flag:1&#039;, &#039;assignee&#039;);
			assert.strictEqual(adminUid, parseInt(assignee, 10));
		});

		it(&#039;should allow assignment if user is a global mod and do nothing otherwise&#039;, async () =&gt; {
			await Groups.join(&#039;Global Moderators&#039;, uid3);

			await Flags.update(1, uid3, {
				assignee: uid3,
			});
			let assignee = await db.getObjectField(&#039;flag:1&#039;, &#039;assignee&#039;);
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Flags.update(1, uid3, {
				assignee: uid1,
			});
			assignee = await db.getObjectField(&#039;flag:1&#039;, &#039;assignee&#039;);
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Groups.leave(&#039;Global Moderators&#039;, uid3);
		});

		it(&#039;should allow assignment if user is a mod of the category, do nothing otherwise&#039;, async () =&gt; {
			await Groups.join(`cid:${category.cid}:privileges:moderate`, uid3);

			await Flags.update(1, uid3, {
				assignee: uid3,
			});
			let assignee = await db.getObjectField(&#039;flag:1&#039;, &#039;assignee&#039;);
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Flags.update(1, uid3, {
				assignee: uid1,
			});
			assignee = await db.getObjectField(&#039;flag:1&#039;, &#039;assignee&#039;);
			assert.strictEqual(uid3, parseInt(assignee, 10));

			await Groups.leave(`cid:${category.cid}:privileges:moderate`, uid3);
		});

		it(&#039;should do nothing when you attempt to set a bogus state&#039;, async () =&gt; {
			await Flags.update(1, adminUid, {
				state: &#039;hocus pocus&#039;,
			});

			const state = await db.getObjectField(&#039;flag:1&#039;, &#039;state&#039;);
			assert.strictEqual(&#039;wip&#039;, state);
		});

		describe(&#039;resolve/reject&#039;, () =&gt; {
			let result;
			let flagObj;
			beforeEach(async () =&gt; {
				result = await Topics.post({
					cid: category.cid,
					uid: uid3,
					title: &#039;Topic to flag&#039;,
					content: &#039;This is flaggable content&#039;,
				});
				flagObj = await api.flags.create({ uid: uid1 }, { type: &#039;post&#039;, id: result.postData.pid, reason: &#039;spam&#039; });
				await sleep(2000);
			});

			it(&#039;should rescind notification if flag is resolved&#039;, async () =&gt; {
				let userNotifs = await User.notifications.getAll(adminUid);
				assert(userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));

				await Flags.update(flagObj.flagId, adminUid, {
					state: &#039;resolved&#039;,
				});

				userNotifs = await User.notifications.getAll(adminUid);
				assert(!userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));
			});

			it(&#039;should rescind notification if flag is rejected&#039;, async () =&gt; {
				let userNotifs = await User.notifications.getAll(adminUid);
				assert(userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));

				await Flags.update(flagObj.flagId, adminUid, {
					state: &#039;rejected&#039;,
				});

				userNotifs = await User.notifications.getAll(adminUid);
				assert(!userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));
			});

			it(&#039;should do nothing if flag is resolved but ACP action is not &quot;rescind&quot;&#039;, async () =&gt; {
				Meta.config[&#039;flags:actionOnResolve&#039;] = &#039;&#039;;

				let userNotifs = await User.notifications.getAll(adminUid);
				assert(userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));

				await Flags.update(flagObj.flagId, adminUid, {
					state: &#039;resolved&#039;,
				});

				userNotifs = await User.notifications.getAll(adminUid);
				assert(userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));

				delete Meta.config[&#039;flags:actionOnResolve&#039;];
			});

			it(&#039;should do nothing if flag is rejected but ACP action is not &quot;rescind&quot;&#039;, async () =&gt; {
				Meta.config[&#039;flags:actionOnReject&#039;] = &#039;&#039;;

				let userNotifs = await User.notifications.getAll(adminUid);
				assert(userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));

				await Flags.update(flagObj.flagId, adminUid, {
					state: &#039;rejected&#039;,
				});

				userNotifs = await User.notifications.getAll(adminUid);
				assert(userNotifs.includes(`flag:post:${result.postData.pid}:${uid1}`));

				delete Meta.config[&#039;flags:actionOnReject&#039;];
			});
		});
	});

	describe(&#039;.getTarget()&#039;, () =&gt; {
		it(&#039;should return a post\&#039;s data if queried with type &quot;post&quot;&#039;, (done) =&gt; {
			Flags.getTarget(&#039;post&#039;, 1, 1, (err, data) =&gt; {
				assert.ifError(err);
				const compare = {
					uid: 1,
					pid: 1,
					content: &#039;This is flaggable content&#039;,
				};

				for (const key of Object.keys(compare)) {
					assert.ok(data[key]);
					assert.equal(data[key], compare[key]);
				}

				done();
			});
		});

		it(&#039;should return a user\&#039;s data if queried with type &quot;user&quot;&#039;, (done) =&gt; {
			Flags.getTarget(&#039;user&#039;, 1, 1, (err, data) =&gt; {
				assert.ifError(err);
				const compare = {
					uid: 1,
					username: &#039;testUser&#039;,
					email: &#039;b@c.com&#039;,
				};

				for (const key of Object.keys(compare)) {
					assert.ok(data[key]);
					assert.equal(data[key], compare[key]);
				}

				done();
			});
		});

		it(&#039;should return a plain object with no properties if the target no longer exists&#039;, (done) =&gt; {
			Flags.getTarget(&#039;user&#039;, 15, 1, (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(0, Object.keys(data).length);
				done();
			});
		});
	});

	describe(&#039;.validate()&#039;, () =&gt; {
		it(&#039;should error out if type is post and post is deleted&#039;, (done) =&gt; {
			Posts.delete(1, 1, (err) =&gt; {
				if (err) {
					throw err;
				}

				Flags.validate({
					type: &#039;post&#039;,
					id: 1,
					uid: 1,
				}, (err) =&gt; {
					assert.ok(err);
					assert.strictEqual(&#039;[[error:post-deleted]]&#039;, err.message);
					Posts.restore(1, 1, done);
				});
			});
		});

		it(&#039;should not pass validation if flag threshold is set and user rep does not meet it&#039;, (done) =&gt; {
			Meta.configs.set(&#039;min:rep:flag&#039;, &#039;50&#039;, (err) =&gt; {
				assert.ifError(err);

				Flags.validate({
					type: &#039;post&#039;,
					id: 1,
					uid: 3,
				}, (err) =&gt; {
					assert.ok(err);
					assert.strictEqual(&#039;[[error:not-enough-reputation-to-flag, 50]]&#039;, err.message);
					Meta.configs.set(&#039;min:rep:flag&#039;, 0, done);
				});
			});
		});

		it(&#039;should not error if user blocked target&#039;, async () =&gt; {
			const apiFlags = require(&#039;../src/api/flags&#039;);
			const reporterUid = await User.create({ username: &#039;reporter&#039; });
			const reporteeUid = await User.create({ username: &#039;reportee&#039; });
			await User.blocks.add(reporteeUid, reporterUid);
			const data = await Topics.post({
				cid: 1,
				uid: reporteeUid,
				title: &#039;Another topic&#039;,
				content: &#039;This is flaggable content&#039;,
			});
			await apiFlags.create({ uid: reporterUid }, {
				type: &#039;post&#039;,
				id: data.postData.pid,
				reason: &#039;spam&#039;,
			});
		});

		it(&#039;should send back error if reporter does not exist&#039;, (done) =&gt; {
			Flags.validate({ uid: 123123123, id: 1, type: &#039;post&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:no-user]]&#039;);
				done();
			});
		});
	});

	describe(&#039;.appendNote()&#039;, () =&gt; {
		it(&#039;should add a note to a flag&#039;, (done) =&gt; {
			Flags.appendNote(1, 1, &#039;this is my note&#039;, (err) =&gt; {
				assert.ifError(err);

				db.getSortedSetRange(&#039;flag:1:notes&#039;, 0, -1, (err, notes) =&gt; {
					if (err) {
						throw err;
					}

					assert.strictEqual(&#039;[1,&quot;this is my note&quot;]&#039;, notes[0]);
					setTimeout(done, 10);
				});
			});
		});

		it(&#039;should be a JSON string&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;flag:1:notes&#039;, 0, -1, (err, notes) =&gt; {
				if (err) {
					throw err;
				}

				try {
					JSON.parse(notes[0]);
				} catch (e) {
					assert.ifError(e);
				}

				done();
			});
		});

		it(&#039;should insert a note in the past if a datetime is passed in&#039;, async () =&gt; {
			await Flags.appendNote(1, 1, &#039;this is the first note&#039;, 1626446956652);
			const note = (await db.getSortedSetRange(&#039;flag:1:notes&#039;, 0, 0)).pop();
			assert.strictEqual(&#039;[1,&quot;this is the first note&quot;]&#039;, note);
		});
	});

	describe(&#039;.getNotes()&#039;, () =&gt; {
		before((done) =&gt; {
			// Add a second note
			Flags.appendNote(1, 1, &#039;this is the second note&#039;, done);
		});

		it(&#039;return should match a predefined spec&#039;, (done) =&gt; {
			Flags.getNotes(1, (err, notes) =&gt; {
				assert.ifError(err);
				const compare = {
					uid: 1,
					content: &#039;this is my note&#039;,
				};

				const data = notes[1];
				for (const key of Object.keys(compare)) {
					assert.ok(data[key]);
					assert.strictEqual(data[key], compare[key]);
				}

				done();
			});
		});

		it(&#039;should retrieve a list of notes, from newest to oldest&#039;, (done) =&gt; {
			Flags.getNotes(1, (err, notes) =&gt; {
				assert.ifError(err);
				assert(notes[0].datetime &gt; notes[1].datetime, `${notes[0].datetime}-${notes[1].datetime}`);
				assert.strictEqual(&#039;this is the second note&#039;, notes[0].content);
				done();
			});
		});
	});

	describe(&#039;.appendHistory()&#039;, () =&gt; {
		let entries;
		before((done) =&gt; {
			db.sortedSetCard(&#039;flag:1:history&#039;, (err, count) =&gt; {
				entries = count;
				done(err);
			});
		});

		it(&#039;should add a new entry into a flag\&#039;s history&#039;, (done) =&gt; {
			Flags.appendHistory(1, 1, {
				state: &#039;rejected&#039;,
			}, (err) =&gt; {
				assert.ifError(err);

				Flags.getHistory(1, (err, history) =&gt; {
					if (err) {
						throw err;
					}

					// 1 for the new event appended, 2 for username/email change
					assert.strictEqual(entries + 3, history.length);
					done();
				});
			});
		});
	});

	describe(&#039;.getHistory()&#039;, () =&gt; {
		it(&#039;should retrieve a flag\&#039;s history&#039;, (done) =&gt; {
			Flags.getHistory(1, (err, history) =&gt; {
				assert.ifError(err);
				assert.strictEqual(history[0].fields.state, &#039;[[flags:state-rejected]]&#039;);
				done();
			});
		});
	});

	describe(&#039;(v3 API)&#039;, () =&gt; {
		let pid;
		let tid;
		let jar;
		let csrfToken;
		before(async () =&gt; {
			const login = await helpers.loginUser(&#039;testUser2&#039;, &#039;abcdef&#039;);
			jar = login.jar;
			csrfToken = login.csrf_token;

			const result = await Topics.post({
				cid: 1,
				uid: 1,
				title: &#039;Another topic&#039;,
				content: &#039;This is flaggable content&#039;,
			});
			pid = result.postData.pid;
			tid = result.topicData.tid;
		});

		describe(&#039;.create()&#039;, () =&gt; {
			it(&#039;should create a flag with no errors&#039;, async () =&gt; {
				await request.post(`${nconf.get(&#039;url&#039;)}/api/v3/flags`, {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
					body: {
						type: &#039;post&#039;,
						id: pid,
						reason: &#039;foobar&#039;,
					},
				});

				const exists = await Flags.exists(&#039;post&#039;, pid, 2);
				assert(exists);
			});

			it(&#039;should escape flag reason&#039;, async () =&gt; {
				const postData = await Topics.reply({
					tid: tid,
					uid: 1,
					content: &#039;This is flaggable content&#039;,
				});

				const { body } = await request.post(`${nconf.get(&#039;url&#039;)}/api/v3/flags`, {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
					body: {
						type: &#039;post&#039;,
						id: postData.pid,
						reason: &#039;&quot;&lt;script&gt;alert(\&#039;ok\&#039;);&lt;/script&gt;&#039;,
					},
				});

				const flagData = await Flags.get(body.response.flagId);
				assert.strictEqual(flagData.reports[0].value, &#039;&amp;quot;&amp;lt;script&amp;gt;alert(&amp;#x27;ok&amp;#x27;);&amp;lt;&amp;#x2F;script&amp;gt;&#039;);
			});

			it(&#039;should escape filters&#039;, async () =&gt; {
				const { body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/flags?quick=&quot;&lt;script&gt;alert(&#039;foo&#039;);&lt;/script&gt;`, { jar });
				assert.strictEqual(body.filters.quick, &#039;&amp;quot;&amp;lt;script&amp;gt;alert(&amp;#x27;foo&amp;#x27;);&amp;lt;&amp;#x2F;script&amp;gt;&#039;);
			});

			it(&#039;should not allow flagging post in private category&#039;, async () =&gt; {
				const category = await Categories.create({ name: &#039;private category&#039; });

				await Privileges.categories.rescind([&#039;groups:topics:read&#039;], category.cid, &#039;registered-users&#039;);
				await Groups.join(&#039;private category&#039;, uid3);
				const result = await Topics.post({
					cid: category.cid,
					uid: uid3,
					title: &#039;private topic&#039;,
					content: &#039;private post&#039;,
				});
				const login = await helpers.loginUser(&#039;unprivileged&#039;, &#039;abcdef&#039;);
				const jar3 = login.jar;
				const csrfToken = await helpers.getCsrfToken(jar3);

				const { response, body } = await request.post(`${nconf.get(&#039;url&#039;)}/api/v3/flags`, {
					jar: jar3,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
					body: {
						type: &#039;post&#039;,
						id: result.postData.pid,
						reason: &#039;foobar&#039;,
					},
				});
				assert.strictEqual(response.statusCode, 403);

				// Handle dev mode test
				delete body.stack;

				assert.deepStrictEqual(body, {
					status: {
						code: &#039;forbidden&#039;,
						message: &#039;You do not have enough privileges for this action.&#039;,
					},
					response: {},
				});
			});
		});

		describe(&#039;.update()&#039;, () =&gt; {
			it(&#039;should update a flag\&#039;s properties&#039;, async () =&gt; {
				const { body } = await request.put(`${nconf.get(&#039;url&#039;)}/api/v3/flags/4`, {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
					body: {
						state: &#039;wip&#039;,
					},
				});

				const { history } = body.response;
				assert(Array.isArray(history));
				assert(history[0].fields.hasOwnProperty(&#039;state&#039;));
				assert.strictEqual(&#039;[[flags:state-wip]]&#039;, history[0].fields.state);
			});
		});

		describe(&#039;.rescind()&#039;, () =&gt; {
			it(&#039;should remove a flag\&#039;s report&#039;, async () =&gt; {
				const { response } = await request.del(`${nconf.get(&#039;url&#039;)}/api/v3/flags/4/report`, {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
				});

				assert.strictEqual(response.statusCode, 200);
			});
		});

		describe(&#039;.appendNote()&#039;, () =&gt; {
			it(&#039;should append a note to the flag&#039;, async () =&gt; {
				const { body } = await request.post(`${nconf.get(&#039;url&#039;)}/api/v3/flags/4/notes`, {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
					body: {
						note: &#039;lorem ipsum dolor sit amet&#039;,
						datetime: 1626446956652,
					},
				});
				const { response } = body;
				assert(response.hasOwnProperty(&#039;notes&#039;));
				assert(Array.isArray(response.notes));
				assert.strictEqual(&#039;lorem ipsum dolor sit amet&#039;, response.notes[0].content);
				assert.strictEqual(2, response.notes[0].uid);

				assert(response.hasOwnProperty(&#039;history&#039;));
				assert(Array.isArray(response.history));
				assert.strictEqual(1, Object.keys(response.history[response.history.length - 1].fields).length);
				assert(response.history[response.history.length - 1].fields.hasOwnProperty(&#039;notes&#039;));
			});
		});

		describe(&#039;.deleteNote()&#039;, () =&gt; {
			it(&#039;should delete a note from a flag&#039;, async () =&gt; {
				const { body } = await request.del(`${nconf.get(&#039;url&#039;)}/api/v3/flags/4/notes/1626446956652`, {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrfToken,
					},
				});
				const { response } = body;
				assert(Array.isArray(response.history));
				assert(Array.isArray(response.notes));
				assert.strictEqual(response.notes.length, 0);
			});
		});

		describe(&#039;access control&#039;, () =&gt; {
			let uid;
			let jar;
			let csrf_token;
			let requests;

			let flaggerUid;
			let flagId;

			const noteTime = Date.now();

			before(async () =&gt; {
				uid = await User.create({ username: &#039;flags-access-control&#039;, password: &#039;abcdef&#039; });
				({ jar, csrf_token } = await helpers.loginUser(&#039;flags-access-control&#039;, &#039;abcdef&#039;));
				console.log(&#039;cs&#039;, csrfToken);
				flaggerUid = await User.create({ username: &#039;flags-access-control-flagger&#039;, password: &#039;abcdef&#039; });
			});

			beforeEach(async () =&gt; {
				// Reset uid back to unprivileged user
				await Groups.leave(&#039;administrators&#039;, uid);
				await Groups.leave(&#039;Global Moderators&#039;, uid);
				await Privileges.categories.rescind([&#039;moderate&#039;], 1, [uid]);

				const { postData } = await Topics.post({
					uid,
					cid: 1,
					title: utils.generateUUID(),
					content: utils.generateUUID(),
				});

				({ flagId } = await Flags.create(&#039;post&#039;, postData.pid, flaggerUid, &#039;spam&#039;));
				const commonOpts = {
					jar,
					headers: {
						&#039;x-csrf-token&#039;: csrf_token,
					},
				};
				requests = new Set([
					{
						...commonOpts,
						method: &#039;get&#039;,
						uri: `${nconf.get(&#039;url&#039;)}/api/v3/flags/${flagId}`,
					},
					{
						...commonOpts,
						method: &#039;put&#039;,
						uri: `${nconf.get(&#039;url&#039;)}/api/v3/flags/${flagId}`,
						body: {
							state: &#039;wip&#039;,
						},
					},
					{
						...commonOpts,
						method: &#039;post&#039;,
						uri: `${nconf.get(&#039;url&#039;)}/api/v3/flags/${flagId}/notes`,
						body: {
							note: &#039;test note&#039;,
							datetime: noteTime,
						},
					},
					{
						...commonOpts,
						method: &#039;delete&#039;,
						uri: `${nconf.get(&#039;url&#039;)}/api/v3/flags/${flagId}/notes/${noteTime}`,
					},
					{
						...commonOpts,
						method: &#039;delete&#039;,
						uri: `${nconf.get(&#039;url&#039;)}/api/v3/flags/${flagId}`,
					},
				]);
			});

			it(&#039;should not allow access to privileged flag endpoints to guests&#039;, async () =&gt; {
				for (let opts of requests) {
					opts = { ...opts };
					delete opts.jar;
					delete opts.headers;

					// eslint-disable-next-line no-await-in-loop
					const { response } = await request[opts.method](opts.uri, opts);
					const { statusCode } = response;
					assert(statusCode.toString().startsWith(4), `${opts.method.toUpperCase()} ${opts.uri} =&gt; ${statusCode}`);
				}
			});

			it(&#039;should not allow access to privileged flag endpoints to regular users&#039;, async () =&gt; {
				for (const opts of requests) {
					// eslint-disable-next-line no-await-in-loop
					const { response } = await request[opts.method](opts.uri, opts);
					const { statusCode } = response;
					assert(statusCode.toString().startsWith(4), `${opts.method.toUpperCase()} ${opts.uri} =&gt; ${statusCode}`);
				}
			});

			it(&#039;should allow access to privileged endpoints to administrators&#039;, async () =&gt; {
				await Groups.join(&#039;administrators&#039;, uid);

				for (const opts of requests) {
					// eslint-disable-next-line no-await-in-loop
					const { response } = await request[opts.method](opts.uri, opts);
					const { statusCode } = response;
					assert.strictEqual(statusCode, 200, `${opts.method.toUpperCase()} ${opts.uri} =&gt; ${statusCode}`);
				}
			});

			it(&#039;should allow access to privileged endpoints to global moderators&#039;, async () =&gt; {
				await Groups.join(&#039;Global Moderators&#039;, uid);

				for (const opts of requests) {
					// eslint-disable-next-line no-await-in-loop
					const { response } = await request[opts.method](opts.uri, opts);
					const { statusCode } = response;
					assert.strictEqual(statusCode, 200, `${opts.method.toUpperCase()} ${opts.uri} =&gt; ${statusCode}`);
				}
			});

			it(&#039;should allow access to privileged endpoints to moderators if the flag target is a post in a cid they moderate&#039;, async () =&gt; {
				await Privileges.categories.give([&#039;moderate&#039;], 1, [uid]);

				for (const opts of requests) {
					// eslint-disable-next-line no-await-in-loop
					const { response } = await request[opts.method](opts.uri, opts);
					const { statusCode } = response;
					assert.strictEqual(statusCode, 200, `${opts.method.toUpperCase()} ${opts.uri} =&gt; ${statusCode}`);
				}
			});

			it(&#039;should NOT allow access to privileged endpoints to moderators if the flag target is a post in a cid they DO NOT moderate&#039;, async () =&gt; {
				// This is a new category the user will moderate, but the flagged post is in a different category
				const { cid } = await Categories.create({
					name: utils.generateUUID(),
				});
				await Privileges.categories.give([&#039;moderate&#039;], cid, [uid]);

				for (const opts of requests) {
					// eslint-disable-next-line no-await-in-loop
					const { response } = await request[opts.method](opts.uri, opts);
					const { statusCode } = response;
					assert(statusCode.toString().startsWith(4), `${opts.method.toUpperCase()} ${opts.uri} =&gt; ${statusCode}`);
				}
			});
		});


	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
