<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@stylistic/eslint-plugin-js/dist/rules/function-paren-newline.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@stylistic/eslint-plugin-js/dist/rules/function-paren-newline.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">197</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.27</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { c as createRule, s as isFunction, i as isTokenOnSameLine, e as isOpeningParenToken, f as isClosingParenToken } from &#039;../utils.js&#039;;
import &#039;eslint-visitor-keys&#039;;
import &#039;espree&#039;;

var functionParenNewline = createRule({
  name: &quot;function-paren-newline&quot;,
  package: &quot;js&quot;,
  meta: {
    type: &quot;layout&quot;,
    docs: {
      description: &quot;Enforce consistent line breaks inside function parentheses&quot;
    },
    fixable: &quot;whitespace&quot;,
    schema: [
      {
        oneOf: [
          {
            type: &quot;string&quot;,
            enum: [&quot;always&quot;, &quot;never&quot;, &quot;consistent&quot;, &quot;multiline&quot;, &quot;multiline-arguments&quot;]
          },
          {
            type: &quot;object&quot;,
            properties: {
              minItems: {
                type: &quot;integer&quot;,
                minimum: 0
              }
            },
            additionalProperties: false
          }
        ]
      }
    ],
    messages: {
      expectedBefore: &quot;Expected newline before &#039;)&#039;.&quot;,
      expectedAfter: &quot;Expected newline after &#039;(&#039;.&quot;,
      expectedBetween: &quot;Expected newline between arguments/params.&quot;,
      unexpectedBefore: &quot;Unexpected newline before &#039;)&#039;.&quot;,
      unexpectedAfter: &quot;Unexpected newline after &#039;(&#039;.&quot;
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    const rawOption = context.options[0] || &quot;multiline&quot;;
    const multilineOption = rawOption === &quot;multiline&quot;;
    const multilineArgumentsOption = rawOption === &quot;multiline-arguments&quot;;
    const consistentOption = rawOption === &quot;consistent&quot;;
    let minItems;
    if (typeof rawOption === &quot;object&quot;)
      minItems = rawOption.minItems;
    else if (rawOption === &quot;always&quot;)
      minItems = 0;
    else if (rawOption === &quot;never&quot;)
      minItems = Infinity;
    function shouldHaveNewlines(elements, hasLeftNewline) {
      if (multilineArgumentsOption &amp;&amp; elements.length === 1)
        return hasLeftNewline;
      if (multilineOption || multilineArgumentsOption)
        return elements.some((element, index) =&gt; index !== elements.length - 1 &amp;&amp; element.loc.end.line !== elements[index + 1].loc.start.line);
      if (consistentOption)
        return hasLeftNewline;
      return minItems == null || elements.length &gt;= minItems;
    }
    function validateParens(parens, elements) {
      const leftParen = parens.leftParen;
      const rightParen = parens.rightParen;
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
      const hasLeftNewline = !isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightParen, rightParen);
      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
      if (hasLeftNewline &amp;&amp; !needsNewlines) {
        context.report({
          node: leftParen,
          messageId: &quot;unexpectedAfter&quot;,
          fix(fixer) {
            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
          }
        });
      } else if (!hasLeftNewline &amp;&amp; needsNewlines) {
        context.report({
          node: leftParen,
          messageId: &quot;expectedAfter&quot;,
          fix: (fixer) =&gt; fixer.insertTextAfter(leftParen, &quot;\n&quot;)
        });
      }
      if (hasRightNewline &amp;&amp; !needsNewlines) {
        context.report({
          node: rightParen,
          messageId: &quot;unexpectedBefore&quot;,
          fix(fixer) {
            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
          }
        });
      } else if (!hasRightNewline &amp;&amp; needsNewlines) {
        context.report({
          node: rightParen,
          messageId: &quot;expectedBefore&quot;,
          fix: (fixer) =&gt; fixer.insertTextBefore(rightParen, &quot;\n&quot;)
        });
      }
    }
    function validateArguments(parens, elements) {
      const leftParen = parens.leftParen;
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      const hasLeftNewline = !isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
      for (let i = 0; i &lt;= elements.length - 2; i++) {
        const currentElement = elements[i];
        const nextElement = elements[i + 1];
        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;
        if (!hasNewLine &amp;&amp; needsNewlines) {
          context.report({
            node: currentElement,
            messageId: &quot;expectedBetween&quot;,
            fix: (fixer) =&gt; fixer.insertTextBefore(nextElement, &quot;\n&quot;)
          });
        }
      }
    }
    function getParenTokens(node) {
      const isOpeningParenTokenOutsideTypeParameter = () =&gt; {
        let typeParameterOpeningLevel = 0;
        return (token) =&gt; {
          if (token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;&lt;&quot;)
            typeParameterOpeningLevel += 1;
          if (token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;&gt;&quot;)
            typeParameterOpeningLevel -= 1;
          return typeParameterOpeningLevel !== 0 ? false : isOpeningParenToken(token);
        };
      };
      switch (node.type) {
        case &quot;NewExpression&quot;:
          if (!node.arguments.length &amp;&amp; !(isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &amp;&amp; isClosingParenToken(sourceCode.getLastToken(node)) &amp;&amp; node.callee.range[1] &lt; node.range[1])) {
            return null;
          }
        // falls through
        case &quot;CallExpression&quot;:
          return {
            leftParen: sourceCode.getTokenAfter(node.callee, isOpeningParenTokenOutsideTypeParameter()),
            rightParen: sourceCode.getLastToken(node)
          };
        case &quot;FunctionDeclaration&quot;:
        case &quot;FunctionExpression&quot;: {
          const leftParen = sourceCode.getFirstToken(node, isOpeningParenTokenOutsideTypeParameter());
          const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], isClosingParenToken) : sourceCode.getTokenAfter(leftParen);
          return { leftParen, rightParen };
        }
        case &quot;ArrowFunctionExpression&quot;: {
          const firstToken = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });
          if (!isOpeningParenToken(firstToken)) {
            return null;
          }
          const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], isClosingParenToken) : sourceCode.getTokenAfter(firstToken);
          return {
            leftParen: firstToken,
            rightParen
          };
        }
        case &quot;ImportExpression&quot;: {
          const leftParen = sourceCode.getFirstToken(node, 1);
          const rightParen = sourceCode.getLastToken(node);
          return { leftParen, rightParen };
        }
        default:
          throw new TypeError(`unexpected node with type ${node.type}`);
      }
    }
    return {
      [[
        &quot;ArrowFunctionExpression&quot;,
        &quot;CallExpression&quot;,
        &quot;FunctionDeclaration&quot;,
        &quot;FunctionExpression&quot;,
        &quot;ImportExpression&quot;,
        &quot;NewExpression&quot;
      ].join(&quot;, &quot;)](node) {
        const parens = getParenTokens(node);
        let params;
        if (node.type === &quot;ImportExpression&quot;)
          params = [node.source, ...node.options ? [node.options] : []];
        else if (isFunction(node))
          params = node.params;
        else
          params = node.arguments;
        if (parens) {
          validateParens(parens, params);
          if (multilineArgumentsOption)
            validateArguments(parens, params);
        }
      }
    };
  }
});

export { functionParenNewline as default };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
