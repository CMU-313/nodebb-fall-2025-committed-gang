<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/send/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/send/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1143</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">94.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.28</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

&#039;use strict&#039;

/**
 * Module dependencies.
 * @private
 */

var createError = require(&#039;http-errors&#039;)
var debug = require(&#039;debug&#039;)(&#039;send&#039;)
var deprecate = require(&#039;depd&#039;)(&#039;send&#039;)
var destroy = require(&#039;destroy&#039;)
var encodeUrl = require(&#039;encodeurl&#039;)
var escapeHtml = require(&#039;escape-html&#039;)
var etag = require(&#039;etag&#039;)
var fresh = require(&#039;fresh&#039;)
var fs = require(&#039;fs&#039;)
var mime = require(&#039;mime&#039;)
var ms = require(&#039;ms&#039;)
var onFinished = require(&#039;on-finished&#039;)
var parseRange = require(&#039;range-parser&#039;)
var path = require(&#039;path&#039;)
var statuses = require(&#039;statuses&#039;)
var Stream = require(&#039;stream&#039;)
var util = require(&#039;util&#039;)

/**
 * Path function references.
 * @private
 */

var extname = path.extname
var join = path.join
var normalize = path.normalize
var resolve = path.resolve
var sep = path.sep

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/

/**
 * Module exports.
 * @public
 */

module.exports = send
module.exports.mime = mime

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send (req, path, options) {
  return new SendStream(req, path, options)
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream (req, path, options) {
  Stream.call(this)

  var opts = options || {}

  this.options = opts
  this.path = path
  this.req = req

  this._acceptRanges = opts.acceptRanges !== undefined
    ? Boolean(opts.acceptRanges)
    : true

  this._cacheControl = opts.cacheControl !== undefined
    ? Boolean(opts.cacheControl)
    : true

  this._etag = opts.etag !== undefined
    ? Boolean(opts.etag)
    : true

  this._dotfiles = opts.dotfiles !== undefined
    ? opts.dotfiles
    : &#039;ignore&#039;

  if (this._dotfiles !== &#039;ignore&#039; &amp;&amp; this._dotfiles !== &#039;allow&#039; &amp;&amp; this._dotfiles !== &#039;deny&#039;) {
    throw new TypeError(&#039;dotfiles option must be &quot;allow&quot;, &quot;deny&quot;, or &quot;ignore&quot;&#039;)
  }

  this._hidden = Boolean(opts.hidden)

  if (opts.hidden !== undefined) {
    deprecate(&#039;hidden: use dotfiles: \&#039;&#039; + (this._hidden ? &#039;allow&#039; : &#039;ignore&#039;) + &#039;\&#039; instead&#039;)
  }

  // legacy support
  if (opts.dotfiles === undefined) {
    this._dotfiles = undefined
  }

  this._extensions = opts.extensions !== undefined
    ? normalizeList(opts.extensions, &#039;extensions option&#039;)
    : []

  this._immutable = opts.immutable !== undefined
    ? Boolean(opts.immutable)
    : false

  this._index = opts.index !== undefined
    ? normalizeList(opts.index, &#039;index option&#039;)
    : [&#039;index.html&#039;]

  this._lastModified = opts.lastModified !== undefined
    ? Boolean(opts.lastModified)
    : true

  this._maxage = opts.maxAge || opts.maxage
  this._maxage = typeof this._maxage === &#039;string&#039;
    ? ms(this._maxage)
    : Number(this._maxage)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0

  this._root = opts.root
    ? resolve(opts.root)
    : null

  if (!this._root &amp;&amp; opts.from) {
    this.from(opts.from)
  }
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, Stream)

/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.etag = deprecate.function(function etag (val) {
  this._etag = Boolean(val)
  debug(&#039;etag %s&#039;, this._etag)
  return this
}, &#039;send.etag: pass etag as option&#039;)

/**
 * Enable or disable &quot;hidden&quot; (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = deprecate.function(function hidden (val) {
  this._hidden = Boolean(val)
  this._dotfiles = undefined
  debug(&#039;hidden %s&#039;, this._hidden)
  return this
}, &#039;send.hidden: use dotfiles option&#039;)

/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = deprecate.function(function index (paths) {
  var index = !paths ? [] : normalizeList(paths, &#039;paths argument&#039;)
  debug(&#039;index %o&#039;, paths)
  this._index = index
  return this
}, &#039;send.index: pass index as option&#039;)

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = function root (path) {
  this._root = resolve(String(path))
  debug(&#039;root %s&#039;, this._root)
  return this
}

SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
  &#039;send.from: pass root as option&#039;)

SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
  &#039;send.root: pass root as option&#039;)

/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
  this._maxage = typeof maxAge === &#039;string&#039;
    ? ms(maxAge)
    : Number(maxAge)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0
  debug(&#039;max-age %d&#039;, this._maxage)
  return this
}, &#039;send.maxage: pass maxAge as option&#039;)

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error (status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, &#039;error&#039;)) {
    return this.emit(&#039;error&#039;, createHttpError(status, err))
  }

  var res = this.res
  var msg = statuses.message[status] || String(status)
  var doc = createHtmlDocument(&#039;Error&#039;, escapeHtml(msg))

  // clear existing headers
  clearHeaders(res)

  // add error headers
  if (err &amp;&amp; err.headers) {
    setHeaders(res, err.headers)
  }

  // send basic response
  res.statusCode = status
  res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;)
  res.setHeader(&#039;Content-Length&#039;, Buffer.byteLength(doc))
  res.setHeader(&#039;Content-Security-Policy&#039;, &quot;default-src &#039;none&#039;&quot;)
  res.setHeader(&#039;X-Content-Type-Options&#039;, &#039;nosniff&#039;)
  res.end(doc)
}

/**
 * Check if the pathname ends with &quot;/&quot;.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
  return this.path[this.path.length - 1] === &#039;/&#039;
}

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET () {
  return this.req.headers[&#039;if-match&#039;] ||
    this.req.headers[&#039;if-unmodified-since&#039;] ||
    this.req.headers[&#039;if-none-match&#039;] ||
    this.req.headers[&#039;if-modified-since&#039;]
}

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
  var req = this.req
  var res = this.res

  // if-match
  var match = req.headers[&#039;if-match&#039;]
  if (match) {
    var etag = res.getHeader(&#039;ETag&#039;)
    return !etag || (match !== &#039;*&#039; &amp;&amp; parseTokenList(match).every(function (match) {
      return match !== etag &amp;&amp; match !== &#039;W/&#039; + etag &amp;&amp; &#039;W/&#039; + match !== etag
    }))
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate(req.headers[&#039;if-unmodified-since&#039;])
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res.getHeader(&#039;Last-Modified&#039;))
    return isNaN(lastModified) || lastModified &gt; unmodifiedSince
  }

  return false
}

/**
 * Strip various content header fields for a change in entity.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
  var res = this.res

  res.removeHeader(&#039;Content-Encoding&#039;)
  res.removeHeader(&#039;Content-Language&#039;)
  res.removeHeader(&#039;Content-Length&#039;)
  res.removeHeader(&#039;Content-Range&#039;)
  res.removeHeader(&#039;Content-Type&#039;)
}

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified () {
  var res = this.res
  debug(&#039;not modified&#039;)
  this.removeContentHeaderFields()
  res.statusCode = 304
  res.end()
}

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
  var err = new Error(&#039;Can\&#039;t set headers after they are sent.&#039;)
  debug(&#039;headers already sent&#039;)
  this.error(500, err)
}

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable () {
  var statusCode = this.res.statusCode
  return (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) ||
    statusCode === 304
}

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError (error) {
  switch (error.code) {
    case &#039;ENAMETOOLONG&#039;:
    case &#039;ENOENT&#039;:
    case &#039;ENOTDIR&#039;:
      this.error(404, error)
      break
    default:
      this.error(500, error)
      break
  }
}

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh () {
  return fresh(this.req.headers, {
    etag: this.res.getHeader(&#039;ETag&#039;),
    &#039;last-modified&#039;: this.res.getHeader(&#039;Last-Modified&#039;)
  })
}

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh () {
  var ifRange = this.req.headers[&#039;if-range&#039;]

  if (!ifRange) {
    return true
  }

  // if-range as etag
  if (ifRange.indexOf(&#039;&quot;&#039;) !== -1) {
    var etag = this.res.getHeader(&#039;ETag&#039;)
    return Boolean(etag &amp;&amp; ifRange.indexOf(etag) !== -1)
  }

  // if-range as modified date
  var lastModified = this.res.getHeader(&#039;Last-Modified&#039;)
  return parseHttpDate(lastModified) &lt;= parseHttpDate(ifRange)
}

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect (path) {
  var res = this.res

  if (hasListeners(this, &#039;directory&#039;)) {
    this.emit(&#039;directory&#039;, res, path)
    return
  }

  if (this.hasTrailingSlash()) {
    this.error(403)
    return
  }

  var loc = encodeUrl(collapseLeadingSlashes(this.path + &#039;/&#039;))
  var doc = createHtmlDocument(&#039;Redirecting&#039;, &#039;Redirecting to &#039; + escapeHtml(loc))

  // redirect
  res.statusCode = 301
  res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=UTF-8&#039;)
  res.setHeader(&#039;Content-Length&#039;, Buffer.byteLength(doc))
  res.setHeader(&#039;Content-Security-Policy&#039;, &quot;default-src &#039;none&#039;&quot;)
  res.setHeader(&#039;X-Content-Type-Options&#039;, &#039;nosniff&#039;)
  res.setHeader(&#039;Location&#039;, loc)
  res.end(doc)
}

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe (res) {
  // root path
  var root = this._root

  // references
  this.res = res

  // decode the path
  var path = decode(this.path)
  if (path === -1) {
    this.error(400)
    return res
  }

  // null byte(s)
  if (~path.indexOf(&#039;\0&#039;)) {
    this.error(400)
    return res
  }

  var parts
  if (root !== null) {
    // normalize
    if (path) {
      path = normalize(&#039;.&#039; + sep + path)
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path)) {
      debug(&#039;malicious path &quot;%s&quot;&#039;, path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = path.split(sep)

    // join / normalize from optional root dir
    path = normalize(join(root, path))
  } else {
    // &quot;..&quot; is malicious without &quot;root&quot;
    if (UP_PATH_REGEXP.test(path)) {
      debug(&#039;malicious path &quot;%s&quot;&#039;, path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = normalize(path).split(sep)

    // resolve the path
    path = resolve(path)
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    var access = this._dotfiles

    // legacy support
    if (access === undefined) {
      access = parts[parts.length - 1][0] === &#039;.&#039;
        ? (this._hidden ? &#039;allow&#039; : &#039;ignore&#039;)
        : &#039;allow&#039;
    }

    debug(&#039;%s dotfile &quot;%s&quot;&#039;, access, path)
    switch (access) {
      case &#039;allow&#039;:
        break
      case &#039;deny&#039;:
        this.error(403)
        return res
      case &#039;ignore&#039;:
      default:
        this.error(404)
        return res
    }
  }

  // index file support
  if (this._index.length &amp;&amp; this.hasTrailingSlash()) {
    this.sendIndex(path)
    return res
  }

  this.sendFile(path)
  return res
}

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send (path, stat) {
  var len = stat.size
  var options = this.options
  var opts = {}
  var res = this.res
  var req = this.req
  var ranges = req.headers.range
  var offset = options.start || 0

  if (headersSent(res)) {
    // impossible to send now
    this.headersAlreadySent()
    return
  }

  debug(&#039;pipe &quot;%s&quot;&#039;, path)

  // set header fields
  this.setHeader(path, stat)

  // set content-type
  this.type(path)

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412)
      return
    }

    if (this.isCachable() &amp;&amp; this.isFresh()) {
      this.notModified()
      return
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset)
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1
    if (len &gt; bytes) len = bytes
  }

  // Range support
  if (this._acceptRanges &amp;&amp; BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = parseRange(len, ranges, {
      combine: true
    })

    // If-Range support
    if (!this.isRangeFresh()) {
      debug(&#039;range stale&#039;)
      ranges = -2
    }

    // unsatisfiable
    if (ranges === -1) {
      debug(&#039;range unsatisfiable&#039;)

      // Content-Range
      res.setHeader(&#039;Content-Range&#039;, contentRange(&#039;bytes&#039;, len))

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: { &#039;Content-Range&#039;: res.getHeader(&#039;Content-Range&#039;) }
      })
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 &amp;&amp; ranges.length === 1) {
      debug(&#039;range %j&#039;, ranges)

      // Content-Range
      res.statusCode = 206
      res.setHeader(&#039;Content-Range&#039;, contentRange(&#039;bytes&#039;, len, ranges[0]))

      // adjust for requested range
      offset += ranges[0].start
      len = ranges[0].end - ranges[0].start + 1
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop]
  }

  // set read options
  opts.start = offset
  opts.end = Math.max(offset, offset + len - 1)

  // content-length
  res.setHeader(&#039;Content-Length&#039;, len)

  // HEAD support
  if (req.method === &#039;HEAD&#039;) {
    res.end()
    return
  }

  this.stream(path, opts)
}

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile (path) {
  var i = 0
  var self = this

  debug(&#039;stat &quot;%s&quot;&#039;, path)
  fs.stat(path, function onstat (err, stat) {
    if (err &amp;&amp; err.code === &#039;ENOENT&#039; &amp;&amp; !extname(path) &amp;&amp; path[path.length - 1] !== sep) {
      // not found, check extensions
      return next(err)
    }
    if (err) return self.onStatError(err)
    if (stat.isDirectory()) return self.redirect(path)
    self.emit(&#039;file&#039;, path, stat)
    self.send(path, stat)
  })

  function next (err) {
    if (self._extensions.length &lt;= i) {
      return err
        ? self.onStatError(err)
        : self.error(404)
    }

    var p = path + &#039;.&#039; + self._extensions[i++]

    debug(&#039;stat &quot;%s&quot;&#039;, p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit(&#039;file&#039;, p, stat)
      self.send(p, stat)
    })
  }
}

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex (path) {
  var i = -1
  var self = this

  function next (err) {
    if (++i &gt;= self._index.length) {
      if (err) return self.onStatError(err)
      return self.error(404)
    }

    var p = join(path, self._index[i])

    debug(&#039;stat &quot;%s&quot;&#039;, p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit(&#039;file&#039;, p, stat)
      self.send(p, stat)
    })
  }

  next()
}

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream (path, options) {
  var self = this
  var res = this.res

  // pipe
  var stream = fs.createReadStream(path, options)
  this.emit(&#039;stream&#039;, stream)
  stream.pipe(res)

  // cleanup
  function cleanup () {
    destroy(stream, true)
  }

  // response finished, cleanup
  onFinished(res, cleanup)

  // error handling
  stream.on(&#039;error&#039;, function onerror (err) {
    // clean up stream early
    cleanup()

    // error
    self.onStatError(err)
  })

  // end
  stream.on(&#039;end&#039;, function onend () {
    self.emit(&#039;end&#039;)
  })
}

/**
 * Set content-type based on `path`
 * if it hasn&#039;t been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type (path) {
  var res = this.res

  if (res.getHeader(&#039;Content-Type&#039;)) return

  var type = mime.lookup(path)

  if (!type) {
    debug(&#039;no content-type&#039;)
    return
  }

  var charset = mime.charsets.lookup(type)

  debug(&#039;content-type %s&#039;, type)
  res.setHeader(&#039;Content-Type&#039;, type + (charset ? &#039;; charset=&#039; + charset : &#039;&#039;))
}

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader (path, stat) {
  var res = this.res

  this.emit(&#039;headers&#039;, res, path, stat)

  if (this._acceptRanges &amp;&amp; !res.getHeader(&#039;Accept-Ranges&#039;)) {
    debug(&#039;accept ranges&#039;)
    res.setHeader(&#039;Accept-Ranges&#039;, &#039;bytes&#039;)
  }

  if (this._cacheControl &amp;&amp; !res.getHeader(&#039;Cache-Control&#039;)) {
    var cacheControl = &#039;public, max-age=&#039; + Math.floor(this._maxage / 1000)

    if (this._immutable) {
      cacheControl += &#039;, immutable&#039;
    }

    debug(&#039;cache-control %s&#039;, cacheControl)
    res.setHeader(&#039;Cache-Control&#039;, cacheControl)
  }

  if (this._lastModified &amp;&amp; !res.getHeader(&#039;Last-Modified&#039;)) {
    var modified = stat.mtime.toUTCString()
    debug(&#039;modified %s&#039;, modified)
    res.setHeader(&#039;Last-Modified&#039;, modified)
  }

  if (this._etag &amp;&amp; !res.getHeader(&#039;ETag&#039;)) {
    var val = etag(stat)
    debug(&#039;etag %s&#039;, val)
    res.setHeader(&#039;ETag&#039;, val)
  }
}

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders (res) {
  var headers = getHeaderNames(res)

  for (var i = 0; i &lt; headers.length; i++) {
    res.removeHeader(headers[i])
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i &lt; str.length; i++) {
    if (str[i] !== &#039;/&#039;) {
      break
    }
  }

  return i &gt; 1
    ? &#039;/&#039; + str.substr(i)
    : str
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile (parts) {
  for (var i = 0; i &lt; parts.length; i++) {
    var part = parts[i]
    if (part.length &gt; 1 &amp;&amp; part[0] === &#039;.&#039;) {
      return true
    }
  }

  return false
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange (type, size, range) {
  return type + &#039; &#039; + (range ? range.start + &#039;-&#039; + range.end : &#039;*&#039;) + &#039;/&#039; + size
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return &#039;&lt;!DOCTYPE html&gt;\n&#039; +
    &#039;&lt;html lang=&quot;en&quot;&gt;\n&#039; +
    &#039;&lt;head&gt;\n&#039; +
    &#039;&lt;meta charset=&quot;utf-8&quot;&gt;\n&#039; +
    &#039;&lt;title&gt;&#039; + title + &#039;&lt;/title&gt;\n&#039; +
    &#039;&lt;/head&gt;\n&#039; +
    &#039;&lt;body&gt;\n&#039; +
    &#039;&lt;pre&gt;&#039; + body + &#039;&lt;/pre&gt;\n&#039; +
    &#039;&lt;/body&gt;\n&#039; +
    &#039;&lt;/html&gt;\n&#039;
}

/**
 * Create a HttpError object from simple arguments.
 *
 * @param {number} status
 * @param {Error|object} err
 * @private
 */

function createHttpError (status, err) {
  if (!err) {
    return createError(status)
  }

  return err instanceof Error
    ? createError(status, err, { expose: false })
    : createError(status, err)
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode (path) {
  try {
    return decodeURIComponent(path)
  } catch (err) {
    return -1
  }
}

/**
 * Get the header names on a respnse.
 *
 * @param {object} res
 * @returns {array[string]}
 * @private
 */

function getHeaderNames (res) {
  return typeof res.getHeaderNames !== &#039;function&#039;
    ? Object.keys(res._headers || {})
    : res.getHeaderNames()
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js &gt;= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners (emitter, type) {
  var count = typeof emitter.listenerCount !== &#039;function&#039;
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count &gt; 0
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent (res) {
  return typeof res.headersSent !== &#039;boolean&#039;
    ? Boolean(res._header)
    : res.headersSent
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList (val, name) {
  var list = [].concat(val || [])

  for (var i = 0; i &lt; list.length; i++) {
    if (typeof list[i] !== &#039;string&#039;) {
      throw new TypeError(name + &#039; must be array of strings or false&#039;)
    }
  }

  return list
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date &amp;&amp; Date.parse(date)

  return typeof timestamp === &#039;number&#039;
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i &lt; len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(str.substring(start, end))
        }
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  if (start !== end) {
    list.push(str.substring(start, end))
  }

  return list
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  var keys = Object.keys(headers)

  for (var i = 0; i &lt; keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
