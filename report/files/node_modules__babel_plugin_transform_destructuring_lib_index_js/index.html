<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/plugin-transform-destructuring/lib/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/plugin-transform-destructuring/lib/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">576</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">131.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.38</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

Object.defineProperty(exports, &#039;__esModule&#039;, { value: true });

var helperPluginUtils = require(&#039;@babel/helper-plugin-utils&#039;);
var core = require(&#039;@babel/core&#039;);

function isPureVoid(node) {
  return core.types.isUnaryExpression(node) &amp;&amp; node.operator === &quot;void&quot; &amp;&amp; core.types.isPureish(node.argument);
}
function unshiftForXStatementBody(statementPath, newStatements) {
  statementPath.ensureBlock();
  const {
    scope,
    node
  } = statementPath;
  const bodyScopeBindings = statementPath.get(&quot;body&quot;).scope.bindings;
  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(name =&gt; scope.hasBinding(name));
  if (hasShadowedBlockScopedBindings) {
    node.body = core.types.blockStatement([...newStatements, node.body]);
  } else {
    node.body.body.unshift(...newStatements);
  }
}
function hasArrayRest(pattern) {
  return pattern.elements.some(elem =&gt; core.types.isRestElement(elem));
}
function hasObjectRest(pattern) {
  return pattern.properties.some(prop =&gt; core.types.isRestElement(prop));
}
const STOP_TRAVERSAL = {};
const arrayUnpackVisitor = (node, ancestors, state) =&gt; {
  if (!ancestors.length) {
    return;
  }
  if (core.types.isIdentifier(node) &amp;&amp; core.types.isReferenced(node, ancestors[ancestors.length - 1].node) &amp;&amp; state.bindings[node.name]) {
    state.deopt = true;
    throw STOP_TRAVERSAL;
  }
};
class DestructuringTransformer {
  constructor(opts) {
    this.blockHoist = void 0;
    this.operator = void 0;
    this.arrayRefSet = void 0;
    this.nodes = void 0;
    this.scope = void 0;
    this.kind = void 0;
    this.iterableIsArray = void 0;
    this.arrayLikeIsIterable = void 0;
    this.objectRestNoSymbols = void 0;
    this.useBuiltIns = void 0;
    this.addHelper = void 0;
    this.blockHoist = opts.blockHoist;
    this.operator = opts.operator;
    this.arrayRefSet = new Set();
    this.nodes = opts.nodes || [];
    this.scope = opts.scope;
    this.kind = opts.kind;
    this.iterableIsArray = opts.iterableIsArray;
    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
    this.objectRestNoSymbols = opts.objectRestNoSymbols;
    this.useBuiltIns = opts.useBuiltIns;
    this.addHelper = opts.addHelper;
  }
  getExtendsHelper() {
    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier(&quot;Object&quot;), core.types.identifier(&quot;assign&quot;)) : this.addHelper(&quot;extends&quot;);
  }
  buildVariableAssignment(id, init) {
    let op = this.operator;
    if (core.types.isMemberExpression(id) || core.types.isOptionalMemberExpression(id)) op = &quot;=&quot;;
    let node;
    if (op) {
      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));
    } else {
      let nodeInit;
      if (this.kind === &quot;const&quot; &amp;&amp; init === null) {
        nodeInit = this.scope.buildUndefinedNode();
      } else {
        nodeInit = core.types.cloneNode(init);
      }
      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);
    }
    node._blockHoist = this.blockHoist;
    return node;
  }
  buildVariableDeclaration(id, init) {
    const declar = core.types.variableDeclaration(&quot;var&quot;, [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);
    declar._blockHoist = this.blockHoist;
    return declar;
  }
  push(id, _init) {
    const init = core.types.cloneNode(_init);
    if (core.types.isObjectPattern(id)) {
      this.pushObjectPattern(id, init);
    } else if (core.types.isArrayPattern(id)) {
      this.pushArrayPattern(id, init);
    } else if (core.types.isAssignmentPattern(id)) {
      this.pushAssignmentPattern(id, init);
    } else {
      this.nodes.push(this.buildVariableAssignment(id, init));
    }
  }
  toArray(node, count) {
    if (this.iterableIsArray || core.types.isIdentifier(node) &amp;&amp; this.arrayRefSet.has(node.name)) {
      return node;
    } else {
      const {
        scope,
        arrayLikeIsIterable
      } = this;
      if (core.types.isIdentifier(node)) {
        const binding = scope.getBinding(node.name);
        if (binding != null &amp;&amp; binding.constant &amp;&amp; binding.path.isGenericType(&quot;Array&quot;)) {
          return node;
        }
      }
      if (core.types.isArrayExpression(node)) {
        return node;
      }
      if (core.types.isIdentifier(node, {
        name: &quot;arguments&quot;
      })) {
        return core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
      }
      let helperName;
      const args = [node];
      if (typeof count === &quot;number&quot;) {
        args.push(core.types.numericLiteral(count));
        helperName = &quot;slicedToArray&quot;;
      } else {
        helperName = &quot;toArray&quot;;
      }
      if (arrayLikeIsIterable) {
        args.unshift(scope.path.hub.addHelper(helperName));
        helperName = &quot;maybeArrayLike&quot;;
      }
      return core.types.callExpression(scope.path.hub.addHelper(helperName), args);
    }
  }
  pushAssignmentPattern({
    left,
    right
  }, valueRef) {
    if (isPureVoid(valueRef)) {
      this.push(left, right);
      return;
    }
    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression(&quot;===&quot;, core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));
    if (core.types.isPattern(left)) {
      let patternId;
      let node;
      if (this.kind === &quot;const&quot; || this.kind === &quot;let&quot;) {
        patternId = this.scope.generateUidIdentifier(tempId.name);
        node = this.buildVariableDeclaration(patternId, tempConditional);
      } else {
        patternId = tempId;
        node = core.types.expressionStatement(core.types.assignmentExpression(&quot;=&quot;, core.types.cloneNode(tempId), tempConditional));
      }
      this.nodes.push(node);
      this.push(left, patternId);
    } else {
      this.nodes.push(this.buildVariableAssignment(left, tempConditional));
    }
  }
  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, name =&gt; this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);
    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
  }
  pushObjectProperty(prop, propRef) {
    if (core.types.isLiteral(prop.key)) prop.computed = true;
    const pattern = prop.value;
    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);
    if (core.types.isPattern(pattern)) {
      this.push(pattern, objRef);
    } else {
      this.nodes.push(this.buildVariableAssignment(pattern, objRef));
    }
  }
  pushObjectPattern(pattern, objRef) {
    if (!pattern.properties.length) {
      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(&quot;objectDestructuringEmpty&quot;), isPureVoid(objRef) ? [] : [objRef])));
      return;
    }
    if (pattern.properties.length &gt; 1 &amp;&amp; !this.scope.isStatic(objRef)) {
      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
      this.nodes.push(this.buildVariableDeclaration(temp, objRef));
      objRef = temp;
    }
    if (hasObjectRest(pattern)) {
      let copiedPattern;
      for (let i = 0; i &lt; pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        if (core.types.isRestElement(prop)) {
          break;
        }
        const key = prop.key;
        if (prop.computed &amp;&amp; !this.scope.isPure(key)) {
          const name = this.scope.generateUidIdentifierBasedOnNode(key);
          this.nodes.push(this.buildVariableDeclaration(name, key));
          if (!copiedPattern) {
            copiedPattern = pattern = Object.assign({}, pattern, {
              properties: pattern.properties.slice()
            });
          }
          copiedPattern.properties[i] = Object.assign({}, prop, {
            key: name
          });
        }
      }
    }
    for (let i = 0; i &lt; pattern.properties.length; i++) {
      const prop = pattern.properties[i];
      if (core.types.isRestElement(prop)) {
        this.pushObjectRest(pattern, objRef, prop, i);
      } else {
        this.pushObjectProperty(prop, objRef);
      }
    }
  }
  canUnpackArrayPattern(pattern, arr) {
    if (!core.types.isArrayExpression(arr)) return false;
    if (pattern.elements.length &gt; arr.elements.length) return;
    if (pattern.elements.length &lt; arr.elements.length &amp;&amp; !hasArrayRest(pattern)) {
      return false;
    }
    for (const elem of pattern.elements) {
      if (!elem) return false;
      if (core.types.isMemberExpression(elem)) return false;
    }
    for (const elem of arr.elements) {
      if (core.types.isSpreadElement(elem)) return false;
      if (core.types.isCallExpression(elem)) return false;
      if (core.types.isMemberExpression(elem)) return false;
    }
    const bindings = core.types.getBindingIdentifiers(pattern);
    const state = {
      deopt: false,
      bindings
    };
    try {
      core.types.traverse(arr, arrayUnpackVisitor, state);
    } catch (e) {
      if (e !== STOP_TRAVERSAL) throw e;
    }
    return !state.deopt;
  }
  pushUnpackedArrayPattern(pattern, arr) {
    const holeToUndefined = el =&gt; el != null ? el : this.scope.buildUndefinedNode();
    for (let i = 0; i &lt; pattern.elements.length; i++) {
      const elem = pattern.elements[i];
      if (core.types.isRestElement(elem)) {
        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i).map(holeToUndefined)));
      } else {
        this.push(elem, holeToUndefined(arr.elements[i]));
      }
    }
  }
  pushArrayPattern(pattern, arrayRef) {
    if (arrayRef === null) {
      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(&quot;objectDestructuringEmpty&quot;), [])));
      return;
    }
    if (!pattern.elements) return;
    if (this.canUnpackArrayPattern(pattern, arrayRef)) {
      this.pushUnpackedArrayPattern(pattern, arrayRef);
      return;
    }
    const count = !hasArrayRest(pattern) &amp;&amp; pattern.elements.length;
    const toArray = this.toArray(arrayRef, count);
    if (core.types.isIdentifier(toArray)) {
      arrayRef = toArray;
    } else {
      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
      this.arrayRefSet.add(arrayRef.name);
      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
    }
    for (let i = 0; i &lt; pattern.elements.length; i++) {
      const elem = pattern.elements[i];
      if (!elem) continue;
      let elemRef;
      if (core.types.isRestElement(elem)) {
        elemRef = this.toArray(arrayRef);
        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier(&quot;slice&quot;)), [core.types.numericLiteral(i)]);
        this.push(elem.argument, elemRef);
      } else {
        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);
        this.push(elem, elemRef);
      }
    }
  }
  init(pattern, ref) {
    if (!core.types.isArrayExpression(ref) &amp;&amp; !core.types.isMemberExpression(ref)) {
      const memo = this.scope.maybeGenerateMemoised(ref, true);
      if (memo) {
        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));
        ref = memo;
      }
    }
    this.push(pattern, ref);
    return this.nodes;
  }
}
function buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {
  const keys = [];
  let allLiteral = true;
  let hasTemplateLiteral = false;
  for (let i = 0; i &lt; excludedKeys.length; i++) {
    const prop = excludedKeys[i];
    const key = prop.key;
    if (core.types.isIdentifier(key) &amp;&amp; !prop.computed) {
      keys.push(core.types.stringLiteral(key.name));
    } else if (core.types.isTemplateLiteral(key)) {
      keys.push(core.types.cloneNode(key));
      hasTemplateLiteral = true;
    } else if (core.types.isLiteral(key)) {
      keys.push(core.types.stringLiteral(String(key.value)));
    } else if (core.types.isPrivateName(key)) ; else {
      keys.push(core.types.cloneNode(key));
      allLiteral = false;
    }
  }
  let value;
  if (keys.length === 0) {
    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier(&quot;Object&quot;), core.types.identifier(&quot;assign&quot;)) : addHelper(&quot;extends&quot;);
    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(addHelper(&quot;objectDestructuringEmpty&quot;), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])]);
  } else {
    let keyExpression = core.types.arrayExpression(keys);
    if (!allLiteral) {
      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier(&quot;map&quot;)), [addHelper(&quot;toPropertyKey&quot;)]);
    } else if (!hasTemplateLiteral &amp;&amp; !core.types.isProgram(scope.block)) {
      const programScope = scope.getProgramParent();
      const id = programScope.generateUidIdentifier(&quot;excluded&quot;);
      programScope.push({
        id,
        init: keyExpression,
        kind: &quot;const&quot;
      });
      keyExpression = core.types.cloneNode(id);
    }
    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? &quot;Loose&quot; : &quot;&quot;}`), [core.types.cloneNode(objRef), keyExpression]);
  }
  return value;
}
function convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
  const {
    node,
    scope
  } = path;
  const nodeKind = node.kind;
  const nodeLoc = node.loc;
  const nodes = [];
  for (let i = 0; i &lt; node.declarations.length; i++) {
    const declar = node.declarations[i];
    const patternId = declar.init;
    const pattern = declar.id;
    const destructuring = new DestructuringTransformer({
      blockHoist: node._blockHoist,
      nodes: nodes,
      scope: scope,
      kind: node.kind,
      iterableIsArray,
      arrayLikeIsIterable,
      useBuiltIns,
      objectRestNoSymbols,
      addHelper
    });
    if (core.types.isPattern(pattern)) {
      destructuring.init(pattern, patternId);
      if (+i !== node.declarations.length - 1) {
        core.types.inherits(nodes[nodes.length - 1], declar);
      }
    } else {
      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));
    }
  }
  let tail = null;
  let nodesOut = [];
  for (const node of nodes) {
    if (core.types.isVariableDeclaration(node)) {
      if (tail !== null) {
        tail.declarations.push(...node.declarations);
        continue;
      } else {
        node.kind = nodeKind;
        tail = node;
      }
    } else {
      tail = null;
    }
    if (!node.loc) {
      node.loc = nodeLoc;
    }
    nodesOut.push(node);
  }
  if (nodesOut.length === 2 &amp;&amp; core.types.isVariableDeclaration(nodesOut[0]) &amp;&amp; core.types.isExpressionStatement(nodesOut[1]) &amp;&amp; core.types.isCallExpression(nodesOut[1].expression) &amp;&amp; nodesOut[0].declarations.length === 1) {
    const expr = nodesOut[1].expression;
    expr.arguments = [nodesOut[0].declarations[0].init];
    nodesOut = [expr];
  } else {
    if (core.types.isForStatement(path.parent, {
      init: node
    }) &amp;&amp; !nodesOut.some(v =&gt; core.types.isVariableDeclaration(v))) {
      for (let i = 0; i &lt; nodesOut.length; i++) {
        const node = nodesOut[i];
        if (core.types.isExpressionStatement(node)) {
          nodesOut[i] = node.expression;
        }
      }
    }
  }
  if (nodesOut.length === 1) {
    path.replaceWith(nodesOut[0]);
  } else {
    path.replaceWithMultiple(nodesOut);
  }
  scope.crawl();
}
function convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
  const {
    node,
    scope,
    parentPath
  } = path;
  const nodes = [];
  const destructuring = new DestructuringTransformer({
    operator: node.operator,
    scope: scope,
    nodes: nodes,
    arrayLikeIsIterable,
    iterableIsArray,
    objectRestNoSymbols,
    useBuiltIns,
    addHelper
  });
  let ref;
  if (!parentPath.isExpressionStatement() &amp;&amp; !parentPath.isSequenceExpression() || path.isCompletionRecord()) {
    ref = scope.generateUidIdentifierBasedOnNode(node.right, &quot;ref&quot;);
    nodes.push(core.types.variableDeclaration(&quot;var&quot;, [core.types.variableDeclarator(ref, node.right)]));
    if (core.types.isArrayExpression(node.right)) {
      destructuring.arrayRefSet.add(ref.name);
    }
  }
  destructuring.init(node.left, ref || node.right);
  if (ref) {
    if (parentPath.isArrowFunctionExpression()) {
      path.replaceWith(core.types.blockStatement([]));
      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));
    } else {
      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));
    }
  }
  path.replaceWithMultiple(nodes);
  scope.crawl();
}

function variableDeclarationHasDestructuringPattern(node) {
  for (const declar of node.declarations) {
    if (core.types.isPattern(declar.id) &amp;&amp; declar.id.type !== &quot;VoidPattern&quot;) {
      return true;
    }
  }
  return false;
}
var index = helperPluginUtils.declare((api, options) =&gt; {
  var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;
  api.assertVersion(7);
  const {
    useBuiltIns = false
  } = options;
  const iterableIsArray = (_ref = (_api$assumption = api.assumption(&quot;iterableIsArray&quot;)) != null ? _api$assumption : options.loose) != null ? _ref : false;
  const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(&quot;arrayLikeIsIterable&quot;)) != null ? _ref2 : false;
  const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption(&quot;objectRestNoSymbols&quot;)) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;
  return {
    name: &quot;transform-destructuring&quot;,
    visitor: {
      ExportNamedDeclaration(path) {
        const declaration = path.get(&quot;declaration&quot;);
        if (!declaration.isVariableDeclaration()) return;
        if (!variableDeclarationHasDestructuringPattern(declaration.node)) return;
        {
          var _path$splitExportDecl;
          (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require(&quot;@babel/traverse&quot;).NodePath.prototype.splitExportDeclaration;
        }
        path.splitExportDeclaration();
      },
      ForXStatement(path) {
        const {
          node,
          scope
        } = path;
        const left = node.left;
        if (core.types.isPattern(left)) {
          const temp = scope.generateUidIdentifier(&quot;ref&quot;);
          node.left = core.types.variableDeclaration(&quot;var&quot;, [core.types.variableDeclarator(temp)]);
          path.ensureBlock();
          const statementBody = path.node.body.body;
          const nodes = [];
          if (statementBody.length === 0 &amp;&amp; path.isCompletionRecord()) {
            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
          }
          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression(&quot;=&quot;, left, core.types.cloneNode(temp))));
          unshiftForXStatementBody(path, nodes);
          scope.crawl();
          return;
        }
        if (!core.types.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!core.types.isPattern(pattern) || pattern.type === &quot;VoidPattern&quot;) return;
        const key = scope.generateUidIdentifier(&quot;ref&quot;);
        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: left.kind,
          scope: scope,
          nodes: nodes,
          arrayLikeIsIterable,
          iterableIsArray,
          objectRestNoSymbols,
          useBuiltIns,
          addHelper: name =&gt; this.addHelper(name)
        });
        destructuring.init(pattern, key);
        unshiftForXStatementBody(path, nodes);
        scope.crawl();
      },
      CatchClause({
        node,
        scope
      }) {
        const pattern = node.param;
        if (!core.types.isPattern(pattern)) return;
        const ref = scope.generateUidIdentifier(&quot;ref&quot;);
        node.param = ref;
        const nodes = [];
        const destructuring = new DestructuringTransformer({
          kind: &quot;let&quot;,
          scope: scope,
          nodes: nodes,
          arrayLikeIsIterable,
          iterableIsArray,
          objectRestNoSymbols,
          useBuiltIns,
          addHelper: name =&gt; this.addHelper(name)
        });
        destructuring.init(pattern, ref);
        node.body.body = [...nodes, ...node.body.body];
        scope.crawl();
      },
      AssignmentExpression(path, state) {
        if (!core.types.isPattern(path.node.left)) return;
        convertAssignmentExpression(path, name =&gt; state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
      },
      VariableDeclaration(path, state) {
        const {
          node,
          parent
        } = path;
        if (core.types.isForXStatement(parent)) return;
        if (!parent || !path.container) return;
        if (!variableDeclarationHasDestructuringPattern(node)) return;
        convertVariableDeclaration(path, name =&gt; state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
      }
    }
  };
});

exports.buildObjectExcludingKeys = buildObjectExcludingKeys;
exports.default = index;
exports.unshiftForXStatementBody = unshiftForXStatementBody;
//# sourceMappingURL=index.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
