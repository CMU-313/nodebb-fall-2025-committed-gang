<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/request/request.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/request/request.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1554</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">108.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">19.02</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

var http = require(&#039;http&#039;)
var https = require(&#039;https&#039;)
var url = require(&#039;url&#039;)
var util = require(&#039;util&#039;)
var stream = require(&#039;stream&#039;)
var zlib = require(&#039;zlib&#039;)
var aws2 = require(&#039;aws-sign2&#039;)
var aws4 = require(&#039;aws4&#039;)
var httpSignature = require(&#039;http-signature&#039;)
var mime = require(&#039;mime-types&#039;)
var caseless = require(&#039;caseless&#039;)
var ForeverAgent = require(&#039;forever-agent&#039;)
var FormData = require(&#039;form-data&#039;)
var extend = require(&#039;extend&#039;)
var isstream = require(&#039;isstream&#039;)
var isTypedArray = require(&#039;is-typedarray&#039;).strict
var helpers = require(&#039;./lib/helpers&#039;)
var cookies = require(&#039;./lib/cookies&#039;)
var getProxyFromURI = require(&#039;./lib/getProxyFromURI&#039;)
var Querystring = require(&#039;./lib/querystring&#039;).Querystring
var Har = require(&#039;./lib/har&#039;).Har
var Auth = require(&#039;./lib/auth&#039;).Auth
var OAuth = require(&#039;./lib/oauth&#039;).OAuth
var hawk = require(&#039;./lib/hawk&#039;)
var Multipart = require(&#039;./lib/multipart&#039;).Multipart
var Redirect = require(&#039;./lib/redirect&#039;).Redirect
var Tunnel = require(&#039;./lib/tunnel&#039;).Tunnel
var now = require(&#039;performance-now&#039;)
var Buffer = require(&#039;safe-buffer&#039;).Buffer

var safeStringify = helpers.safeStringify
var isReadStream = helpers.isReadStream
var toBase64 = helpers.toBase64
var defer = helpers.defer
var copy = helpers.copy
var version = helpers.version
var globalCookieJar = cookies.jar()

var globalPool = {}

function filterForNonReserved (reserved, options) {
  // Filter out properties that are not reserved.
  // Reserved values are passed in at call site.

  var object = {}
  for (var i in options) {
    var notReserved = (reserved.indexOf(i) === -1)
    if (notReserved) {
      object[i] = options[i]
    }
  }
  return object
}

function filterOutReservedFunctions (reserved, options) {
  // Filter out properties that are functions and are reserved.
  // Reserved values are passed in at call site.

  var object = {}
  for (var i in options) {
    var isReserved = !(reserved.indexOf(i) === -1)
    var isFunction = (typeof options[i] === &#039;function&#039;)
    if (!(isReserved &amp;&amp; isFunction)) {
      object[i] = options[i]
    }
  }
  return object
}

// Return a simpler request object to allow serialization
function requestToJSON () {
  var self = this
  return {
    uri: self.uri,
    method: self.method,
    headers: self.headers
  }
}

// Return a simpler response object to allow serialization
function responseToJSON () {
  var self = this
  return {
    statusCode: self.statusCode,
    body: self.body,
    headers: self.headers,
    request: requestToJSON.call(self.request)
  }
}

function Request (options) {
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this

  // start with HAR, then override with additional options
  if (options.har) {
    self._har = new Har(self)
    options = self._har.options(options)
  }

  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype)
  var nonReserved = filterForNonReserved(reserved, options)

  extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (options.method) {
    self.explicitMethod = true
  }
  self._qs = new Querystring(self)
  self._auth = new Auth(self)
  self._oauth = new OAuth(self)
  self._multipart = new Multipart(self)
  self._redirect = new Redirect(self)
  self._tunnel = new Tunnel(self)
  self.init(options)
}

util.inherits(Request, stream.Stream)

// Debugging
Request.debug = process.env.NODE_DEBUG &amp;&amp; /\brequest\b/.test(process.env.NODE_DEBUG)
function debug () {
  if (Request.debug) {
    console.error(&#039;REQUEST %s&#039;, util.format.apply(util, arguments))
  }
}
Request.prototype.debug = debug

Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) {
    options = {}
  }
  self.headers = self.headers ? copy(self.headers) : {}

  // Delete headers with value undefined since they break
  // ClientRequest.OutgoingMessage.setHeader in node 0.12
  for (var headerName in self.headers) {
    if (typeof self.headers[headerName] === &#039;undefined&#039;) {
      delete self.headers[headerName]
    }
  }

  caseless.httpify(self, self.headers)

  if (!self.method) {
    self.method = options.method || &#039;GET&#039;
  }
  if (!self.localAddress) {
    self.localAddress = options.localAddress
  }

  self._qs.init(options)

  debug(options)
  if (!self.pool &amp;&amp; self.pool !== false) {
    self.pool = globalPool
  }
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback &amp;&amp; self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) {
        return // Print a warning maybe?
      }
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on(&#039;error&#039;, self.callback.bind())
    self.on(&#039;complete&#039;, self.callback.bind(self, null))
  }

  // People use this property instead all the time, so support it
  if (!self.uri &amp;&amp; self.url) {
    self.uri = self.url
    delete self.url
  }

  // If there&#039;s a baseUrl, then use it as the base URL (i.e. uri must be
  // specified as a relative path and is appended to baseUrl).
  if (self.baseUrl) {
    if (typeof self.baseUrl !== &#039;string&#039;) {
      return self.emit(&#039;error&#039;, new Error(&#039;options.baseUrl must be a string&#039;))
    }

    if (typeof self.uri !== &#039;string&#039;) {
      return self.emit(&#039;error&#039;, new Error(&#039;options.uri must be a string when using options.baseUrl&#039;))
    }

    if (self.uri.indexOf(&#039;//&#039;) === 0 || self.uri.indexOf(&#039;://&#039;) !== -1) {
      return self.emit(&#039;error&#039;, new Error(&#039;options.uri must be a path when using options.baseUrl&#039;))
    }

    // Handle all cases to make sure that there&#039;s only one slash between
    // baseUrl and uri.
    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf(&#039;/&#039;) === self.baseUrl.length - 1
    var uriStartsWithSlash = self.uri.indexOf(&#039;/&#039;) === 0

    if (baseUrlEndsWithSlash &amp;&amp; uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri.slice(1)
    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri
    } else if (self.uri === &#039;&#039;) {
      self.uri = self.baseUrl
    } else {
      self.uri = self.baseUrl + &#039;/&#039; + self.uri
    }
    delete self.baseUrl
  }

  // A URI is needed by this point, emit error if we haven&#039;t been able to get one
  if (!self.uri) {
    return self.emit(&#039;error&#039;, new Error(&#039;options.uri is a required argument&#039;))
  }

  // If a string URI/URL was given, parse it into a URL object
  if (typeof self.uri === &#039;string&#039;) {
    self.uri = url.parse(self.uri)
  }

  // Some URL objects are not from a URL parsed string and need href added
  if (!self.uri.href) {
    self.uri.href = url.format(self.uri)
  }

  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
  if (self.uri.protocol === &#039;unix:&#039;) {
    return self.emit(&#039;error&#039;, new Error(&#039;`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`&#039;))
  }

  // Support Unix Sockets
  if (self.uri.host === &#039;unix&#039;) {
    self.enableUnixSocket()
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (!self.uri.pathname) { self.uri.pathname = &#039;/&#039; }

  if (!(self.uri.host || (self.uri.hostname &amp;&amp; self.uri.port)) &amp;&amp; !self.uri.isUnix) {
    // Invalid URI: it may generate lot of bad errors, like &#039;TypeError: Cannot call method `indexOf` of undefined&#039; in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = &#039;Invalid URI &quot;&#039; + faultyUri + &#039;&quot;&#039;
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (they didn&#039;t call request directly with this URL)
      // they should be warned that it can be caused by a redirection (can save some hair)
      message += &#039;. This can be caused by a crappy redirection.&#039;
    }
    // This error was fatal
    self.abort()
    return self.emit(&#039;error&#039;, new Error(message))
  }

  if (!self.hasOwnProperty(&#039;proxy&#039;)) {
    self.proxy = getProxyFromURI(self.uri)
  }

  self.tunnel = self._tunnel.isEnabled()
  if (self.proxy) {
    self._tunnel.setup(options)
  }

  self._redirect.onRequest(options)

  self.setHost = false
  if (!self.hasHeader(&#039;host&#039;)) {
    var hostHeaderName = self.originalHostHeaderName || &#039;host&#039;
    self.setHeader(hostHeaderName, self.uri.host)
    // Drop :port suffix from Host header if known protocol.
    if (self.uri.port) {
      if ((self.uri.port === &#039;80&#039; &amp;&amp; self.uri.protocol === &#039;http:&#039;) ||
          (self.uri.port === &#039;443&#039; &amp;&amp; self.uri.protocol === &#039;https:&#039;)) {
        self.setHeader(hostHeaderName, self.uri.hostname)
      }
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.port) {
    if (self.uri.protocol === &#039;http:&#039;) { self.uri.port = 80 } else if (self.uri.protocol === &#039;https:&#039;) { self.uri.port = 443 }
  }

  if (self.proxy &amp;&amp; !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.formData) {
    var formData = options.formData
    var requestForm = self.form()
    var appendFormValue = function (key, value) {
      if (value &amp;&amp; value.hasOwnProperty(&#039;value&#039;) &amp;&amp; value.hasOwnProperty(&#039;options&#039;)) {
        requestForm.append(key, value.value, value.options)
      } else {
        requestForm.append(key, value)
      }
    }
    for (var formKey in formData) {
      if (formData.hasOwnProperty(formKey)) {
        var formValue = formData[formKey]
        if (formValue instanceof Array) {
          for (var j = 0; j &lt; formValue.length; j++) {
            appendFormValue(formKey, formValue[j])
          }
        } else {
          appendFormValue(formKey, formValue)
        }
      }
    }
  }

  if (options.qs) {
    self.qs(options.qs)
  }

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || &#039;&#039;)
  }

  if (self.path.length === 0) {
    self.path = &#039;/&#039;
  }

  // Auth must happen last in case signing is dependent on other headers
  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    if (Object.prototype.hasOwnProperty.call(options.auth, &#039;username&#039;)) {
      options.auth.user = options.auth.username
    }
    if (Object.prototype.hasOwnProperty.call(options.auth, &#039;password&#039;)) {
      options.auth.pass = options.auth.password
    }

    self.auth(
      options.auth.user,
      options.auth.pass,
      options.auth.sendImmediately,
      options.auth.bearer
    )
  }

  if (self.gzip &amp;&amp; !self.hasHeader(&#039;accept-encoding&#039;)) {
    self.setHeader(&#039;accept-encoding&#039;, &#039;gzip, deflate&#039;)
  }

  if (self.uri.auth &amp;&amp; !self.hasHeader(&#039;authorization&#039;)) {
    var uriAuthPieces = self.uri.auth.split(&#039;:&#039;).map(function (item) { return self._qs.unescape(item) })
    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(&#039;:&#039;), true)
  }

  if (!self.tunnel &amp;&amp; self.proxy &amp;&amp; self.proxy.auth &amp;&amp; !self.hasHeader(&#039;proxy-authorization&#039;)) {
    var proxyAuthPieces = self.proxy.auth.split(&#039;:&#039;).map(function (item) { return self._qs.unescape(item) })
    var authHeader = &#039;Basic &#039; + toBase64(proxyAuthPieces.join(&#039;:&#039;))
    self.setHeader(&#039;proxy-authorization&#039;, authHeader)
  }

  if (self.proxy &amp;&amp; !self.tunnel) {
    self.path = (self.uri.protocol + &#039;//&#039; + self.uri.host + self.path)
  }

  if (options.json) {
    self.json(options.json)
  }
  if (options.multipart) {
    self.multipart(options.multipart)
  }

  if (options.time) {
    self.timing = true

    // NOTE: elapsedTime is deprecated in favor of .timings
    self.elapsedTime = self.elapsedTime || 0
  }

  function setContentLength () {
    if (isTypedArray(self.body)) {
      self.body = Buffer.from(self.body)
    }

    if (!self.hasHeader(&#039;content-length&#039;)) {
      var length
      if (typeof self.body === &#039;string&#039;) {
        length = Buffer.byteLength(self.body)
      } else if (Array.isArray(self.body)) {
        length = self.body.reduce(function (a, b) { return a + b.length }, 0)
      } else {
        length = self.body.length
      }

      if (length) {
        self.setHeader(&#039;content-length&#039;, length)
      } else {
        self.emit(&#039;error&#039;, new Error(&#039;Argument error, options.body.&#039;))
      }
    }
  }
  if (self.body &amp;&amp; !isstream(self.body)) {
    setContentLength()
  }

  if (options.oauth) {
    self.oauth(options.oauth)
  } else if (self._oauth.params &amp;&amp; self.hasHeader(&#039;authorization&#039;)) {
    self.oauth(self._oauth.params)
  }

  var protocol = self.proxy &amp;&amp; !self.tunnel ? self.proxy.protocol : self.uri.protocol
  var defaultModules = {&#039;http:&#039;: http, &#039;https:&#039;: https}
  var httpModules = self.httpModules || {}

  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) {
    return self.emit(&#039;error&#039;, new Error(&#039;Invalid protocol: &#039; + protocol))
  }

  if (options.ca) {
    self.ca = options.ca
  }

  if (!self.agent) {
    if (options.agentOptions) {
      self.agentOptions = options.agentOptions
    }

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      var v = version()
      // use ForeverAgent in node 0.10- only
      if (v.major === 0 &amp;&amp; v.minor &lt;= 10) {
        self.agentClass = protocol === &#039;http:&#039; ? ForeverAgent : ForeverAgent.SSL
      } else {
        self.agentClass = self.httpModule.Agent
        self.agentOptions = self.agentOptions || {}
        self.agentOptions.keepAlive = true
      }
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getNewAgent()
  }

  self.on(&#039;pipe&#039;, function (src) {
    if (self.ntick &amp;&amp; self._started) {
      self.emit(&#039;error&#039;, new Error(&#039;You cannot pipe to this stream after the outbound request has started.&#039;))
    }
    self.src = src
    if (isReadStream(src)) {
      if (!self.hasHeader(&#039;content-type&#039;)) {
        self.setHeader(&#039;content-type&#039;, mime.lookup(src.path))
      }
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.hasHeader(i)) {
            self.setHeader(i, src.headers[i])
          }
        }
      }
      if (self._json &amp;&amp; !self.hasHeader(&#039;content-type&#039;)) {
        self.setHeader(&#039;content-type&#039;, &#039;application/json&#039;)
      }
      if (src.method &amp;&amp; !self.explicitMethod) {
        self.method = src.method
      }
    }

  // self.on(&#039;pipe&#039;, function () {
  //   console.error(&#039;You have already piped to this stream. Pipeing twice is likely to break the request.&#039;)
  // })
  })

  defer(function () {
    if (self._aborted) {
      return
    }

    var end = function () {
      if (self._form) {
        if (!self._auth.hasAuth) {
          self._form.pipe(self)
        } else if (self._auth.hasAuth &amp;&amp; self._auth.sentAuth) {
          self._form.pipe(self)
        }
      }
      if (self._multipart &amp;&amp; self._multipart.chunked) {
        self._multipart.body.pipe(self)
      }
      if (self.body) {
        if (isstream(self.body)) {
          self.body.pipe(self)
        } else {
          setContentLength()
          if (Array.isArray(self.body)) {
            self.body.forEach(function (part) {
              self.write(part)
            })
          } else {
            self.write(self.body)
          }
          self.end()
        }
      } else if (self.requestBodyStream) {
        console.warn(&#039;options.requestBodyStream is deprecated, please pass the request object to stream.pipe.&#039;)
        self.requestBodyStream.pipe(self)
      } else if (!self.src) {
        if (self._auth.hasAuth &amp;&amp; !self._auth.sentAuth) {
          self.end()
          return
        }
        if (self.method !== &#039;GET&#039; &amp;&amp; typeof self.method !== &#039;undefined&#039;) {
          self.setHeader(&#039;content-length&#039;, 0)
        }
        self.end()
      }
    }

    if (self._form &amp;&amp; !self.hasHeader(&#039;content-length&#039;)) {
      // Before ending the request, we had to compute the length of the whole form, asyncly
      self.setHeader(self._form.getHeaders(), true)
      self._form.getLength(function (err, length) {
        if (!err &amp;&amp; !isNaN(length)) {
          self.setHeader(&#039;content-length&#039;, length)
        }
        end()
      })
    } else {
      end()
    }

    self.ntick = true
  })
}

Request.prototype.getNewAgent = function () {
  var self = this
  var Agent = self.agentClass
  var options = {}
  if (self.agentOptions) {
    for (var i in self.agentOptions) {
      options[i] = self.agentOptions[i]
    }
  }
  if (self.ca) {
    options.ca = self.ca
  }
  if (self.ciphers) {
    options.ciphers = self.ciphers
  }
  if (self.secureProtocol) {
    options.secureProtocol = self.secureProtocol
  }
  if (self.secureOptions) {
    options.secureOptions = self.secureOptions
  }
  if (typeof self.rejectUnauthorized !== &#039;undefined&#039;) {
    options.rejectUnauthorized = self.rejectUnauthorized
  }

  if (self.cert &amp;&amp; self.key) {
    options.key = self.key
    options.cert = self.cert
  }

  if (self.pfx) {
    options.pfx = self.pfx
  }

  if (self.passphrase) {
    options.passphrase = self.passphrase
  }

  var poolKey = &#039;&#039;

  // different types of agents are in different pools
  if (Agent !== self.httpModule.Agent) {
    poolKey += Agent.name
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = self.proxy
  if (typeof proxy === &#039;string&#039;) {
    proxy = url.parse(proxy)
  }
  var isHttps = (proxy &amp;&amp; proxy.protocol === &#039;https:&#039;) || this.uri.protocol === &#039;https:&#039;

  if (isHttps) {
    if (options.ca) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== &#039;undefined&#039;) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.rejectUnauthorized
    }

    if (options.cert) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.cert.toString(&#039;ascii&#039;) + options.key.toString(&#039;ascii&#039;)
    }

    if (options.pfx) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.pfx.toString(&#039;ascii&#039;)
    }

    if (options.ciphers) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.ciphers
    }

    if (options.secureProtocol) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.secureProtocol
    }

    if (options.secureOptions) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.secureOptions
    }
  }

  if (self.pool === globalPool &amp;&amp; !poolKey &amp;&amp; Object.keys(options).length === 0 &amp;&amp; self.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return self.httpModule.globalAgent
  }

  // we&#039;re using a stored agent.  Make sure it&#039;s protocol-specific
  poolKey = self.uri.protocol + poolKey

  // generate a new agent for this setting if none yet exists
  if (!self.pool[poolKey]) {
    self.pool[poolKey] = new Agent(options)
    // properly set maxSockets on new agents
    if (self.pool.maxSockets) {
      self.pool[poolKey].maxSockets = self.pool.maxSockets
    }
  }

  return self.pool[poolKey]
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self.timing) {
    // All timings will be relative to this request&#039;s startTime.  In order to do this,
    // we need to capture the wall-clock start time (via Date), immediately followed
    // by the high-resolution timer (via now()).  While these two won&#039;t be set
    // at the _exact_ same time, they should be close enough to be able to calculate
    // high-resolution, monotonically non-decreasing timestamps relative to startTime.
    var startTime = new Date().getTime()
    var startTimeNow = now()
  }

  if (self._aborted) {
    return
  }

  self._started = true
  self.method = self.method || &#039;GET&#039;
  self.href = self.uri.href

  if (self.src &amp;&amp; self.src.stat &amp;&amp; self.src.stat.size &amp;&amp; !self.hasHeader(&#039;content-length&#039;)) {
    self.setHeader(&#039;content-length&#039;, self.src.stat.size)
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don&#039;t remove it, we&#039;re gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug(&#039;make request&#039;, self.uri.href)

  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we
  // should delete it for now since we handle timeouts manually for better
  // consistency with node versions before v6.8.0
  delete reqOptions.timeout

  try {
    self.req = self.httpModule.request(reqOptions)
  } catch (err) {
    self.emit(&#039;error&#039;, err)
    return
  }

  if (self.timing) {
    self.startTime = startTime
    self.startTimeNow = startTimeNow

    // Timing values will all be relative to startTime (by comparing to startTimeNow
    // so we have an accurate clock)
    self.timings = {}
  }

  var timeout
  if (self.timeout &amp;&amp; !self.timeoutTimer) {
    if (self.timeout &lt; 0) {
      timeout = 0
    } else if (typeof self.timeout === &#039;number&#039; &amp;&amp; isFinite(self.timeout)) {
      timeout = self.timeout
    }
  }

  self.req.on(&#039;response&#039;, self.onRequestResponse.bind(self))
  self.req.on(&#039;error&#039;, self.onRequestError.bind(self))
  self.req.on(&#039;drain&#039;, function () {
    self.emit(&#039;drain&#039;)
  })

  self.req.on(&#039;socket&#039;, function (socket) {
    // `._connecting` was the old property which was made public in node v6.1.0
    var isConnecting = socket._connecting || socket.connecting
    if (self.timing) {
      self.timings.socket = now() - self.startTimeNow

      if (isConnecting) {
        var onLookupTiming = function () {
          self.timings.lookup = now() - self.startTimeNow
        }

        var onConnectTiming = function () {
          self.timings.connect = now() - self.startTimeNow
        }

        socket.once(&#039;lookup&#039;, onLookupTiming)
        socket.once(&#039;connect&#039;, onConnectTiming)

        // clean up timing event listeners if needed on error
        self.req.once(&#039;error&#039;, function () {
          socket.removeListener(&#039;lookup&#039;, onLookupTiming)
          socket.removeListener(&#039;connect&#039;, onConnectTiming)
        })
      }
    }

    var setReqTimeout = function () {
      // This timeout sets the amount of time to wait *between* bytes sent
      // from the server once connected.
      //
      // In particular, it&#039;s useful for erroring if the server fails to send
      // data halfway through streaming a response.
      self.req.setTimeout(timeout, function () {
        if (self.req) {
          self.abort()
          var e = new Error(&#039;ESOCKETTIMEDOUT&#039;)
          e.code = &#039;ESOCKETTIMEDOUT&#039;
          e.connect = false
          self.emit(&#039;error&#039;, e)
        }
      })
    }
    if (timeout !== undefined) {
      // Only start the connection timer if we&#039;re actually connecting a new
      // socket, otherwise if we&#039;re already connected (because this is a
      // keep-alive connection) do not bother. This is important since we won&#039;t
      // get a &#039;connect&#039; event for an already connected socket.
      if (isConnecting) {
        var onReqSockConnect = function () {
          socket.removeListener(&#039;connect&#039;, onReqSockConnect)
          self.clearTimeout()
          setReqTimeout()
        }

        socket.on(&#039;connect&#039;, onReqSockConnect)

        self.req.on(&#039;error&#039;, function (err) { // eslint-disable-line handle-callback-err
          socket.removeListener(&#039;connect&#039;, onReqSockConnect)
        })

        // Set a timeout in memory - this block will throw if the server takes more
        // than `timeout` to write the HTTP status and headers (corresponding to
        // the on(&#039;response&#039;) event on the client). NB: this measures wall-clock
        // time, not the time between bytes sent by the server.
        self.timeoutTimer = setTimeout(function () {
          socket.removeListener(&#039;connect&#039;, onReqSockConnect)
          self.abort()
          var e = new Error(&#039;ETIMEDOUT&#039;)
          e.code = &#039;ETIMEDOUT&#039;
          e.connect = true
          self.emit(&#039;error&#039;, e)
        }, timeout)
      } else {
        // We&#039;re already connected
        setReqTimeout()
      }
    }
    self.emit(&#039;socket&#039;, socket)
  })

  self.emit(&#039;request&#039;, self.req)
}

Request.prototype.onRequestError = function (error) {
  var self = this
  if (self._aborted) {
    return
  }
  if (self.req &amp;&amp; self.req._reusedSocket &amp;&amp; error.code === &#039;ECONNRESET&#039; &amp;&amp;
    self.agent.addRequestNoreuse) {
    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
    self.start()
    self.req.end()
    return
  }
  self.clearTimeout()
  self.emit(&#039;error&#039;, error)
}

Request.prototype.onRequestResponse = function (response) {
  var self = this

  if (self.timing) {
    self.timings.response = now() - self.startTimeNow
  }

  debug(&#039;onRequestResponse&#039;, self.uri.href, response.statusCode, response.headers)
  response.on(&#039;end&#039;, function () {
    if (self.timing) {
      self.timings.end = now() - self.startTimeNow
      response.timingStart = self.startTime

      // fill in the blanks for any periods that didn&#039;t trigger, such as
      // no lookup or connect due to keep alive
      if (!self.timings.socket) {
        self.timings.socket = 0
      }
      if (!self.timings.lookup) {
        self.timings.lookup = self.timings.socket
      }
      if (!self.timings.connect) {
        self.timings.connect = self.timings.lookup
      }
      if (!self.timings.response) {
        self.timings.response = self.timings.connect
      }

      debug(&#039;elapsed time&#039;, self.timings.end)

      // elapsedTime includes all redirects
      self.elapsedTime += Math.round(self.timings.end)

      // NOTE: elapsedTime is deprecated in favor of .timings
      response.elapsedTime = self.elapsedTime

      // timings is just for the final fetch
      response.timings = self.timings

      // pre-calculate phase timings as well
      response.timingPhases = {
        wait: self.timings.socket,
        dns: self.timings.lookup - self.timings.socket,
        tcp: self.timings.connect - self.timings.lookup,
        firstByte: self.timings.response - self.timings.connect,
        download: self.timings.end - self.timings.response,
        total: self.timings.end
      }
    }
    debug(&#039;response end&#039;, self.uri.href, response.statusCode, response.headers)
  })

  if (self._aborted) {
    debug(&#039;aborted&#039;, self.uri.href)
    response.resume()
    return
  }

  self.response = response
  response.request = self
  response.toJSON = responseToJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &amp;&amp;
    self.strictSSL &amp;&amp; (!response.hasOwnProperty(&#039;socket&#039;) ||
    !response.socket.authorized)) {
    debug(&#039;strict ssl error&#039;, self.uri.href)
    var sslErr = response.hasOwnProperty(&#039;socket&#039;) ? response.socket.authorizationError : self.uri.href + &#039; does not support SSL&#039;
    self.emit(&#039;error&#039;, new Error(&#039;SSL Error: &#039; + sslErr))
    return
  }

  // Save the original host before any redirect (if it changes, we need to
  // remove any authorization headers).  Also remember the case of the header
  // name because lots of broken servers expect Host instead of host and we
  // want the caller to be able to specify this.
  self.originalHost = self.getHeader(&#039;host&#039;)
  if (!self.originalHostHeaderName) {
    self.originalHostHeaderName = self.hasHeader(&#039;host&#039;)
  }
  if (self.setHost) {
    self.removeHeader(&#039;host&#039;)
  }
  self.clearTimeout()

  var targetCookieJar = (self._jar &amp;&amp; self._jar.setCookie) ? self._jar : globalCookieJar
  var addCookie = function (cookie) {
    // set the cookie if it&#039;s domain in the href&#039;s domain.
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
    } catch (e) {
      self.emit(&#039;error&#039;, e)
    }
  }

  response.caseless = caseless(response.headers)

  if (response.caseless.has(&#039;set-cookie&#039;) &amp;&amp; (!self._disableCookies)) {
    var headerName = response.caseless.has(&#039;set-cookie&#039;)
    if (Array.isArray(response.headers[headerName])) {
      response.headers[headerName].forEach(addCookie)
    } else {
      addCookie(response.headers[headerName])
    }
  }

  if (self._redirect.onResponse(response)) {
    return // Ignore the rest of the response
  } else {
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on(&#039;close&#039;, function () {
      if (!self._ended) {
        self.response.emit(&#039;end&#039;)
      }
    })

    response.once(&#039;end&#039;, function () {
      self._ended = true
    })

    var noBody = function (code) {
      return (
        self.method === &#039;HEAD&#039; ||
        // Informational
        (code &gt;= 100 &amp;&amp; code &lt; 200) ||
        // No Content
        code === 204 ||
        // Not Modified
        code === 304
      )
    }

    var responseContent
    if (self.gzip &amp;&amp; !noBody(response.statusCode)) {
      var contentEncoding = response.headers[&#039;content-encoding&#039;] || &#039;identity&#039;
      contentEncoding = contentEncoding.trim().toLowerCase()

      // Be more lenient with decoding compressed responses, since (very rarely)
      // servers send slightly invalid gzip responses that are still accepted
      // by common browsers.
      // Always using Z_SYNC_FLUSH is what cURL does.
      var zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      }

      if (contentEncoding === &#039;gzip&#039;) {
        responseContent = zlib.createGunzip(zlibOptions)
        response.pipe(responseContent)
      } else if (contentEncoding === &#039;deflate&#039;) {
        responseContent = zlib.createInflate(zlibOptions)
        response.pipe(responseContent)
      } else {
        // Since previous versions didn&#039;t check for Content-Encoding header,
        // ignore any invalid values to preserve backwards-compatibility
        if (contentEncoding !== &#039;identity&#039;) {
          debug(&#039;ignoring unrecognized Content-Encoding &#039; + contentEncoding)
        }
        responseContent = response
      }
    } else {
      responseContent = response
    }

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error(&#039;Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.&#039;)
      } else {
        responseContent.setEncoding(self.encoding)
      }
    }

    if (self._paused) {
      responseContent.pause()
    }

    self.responseContent = responseContent

    self.emit(&#039;response&#039;, response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    responseContent.on(&#039;data&#039;, function (chunk) {
      if (self.timing &amp;&amp; !self.responseStarted) {
        self.responseStartTime = (new Date()).getTime()

        // NOTE: responseStartTime is deprecated in favor of .timings
        response.responseStartTime = self.responseStartTime
      }
      self._destdata = true
      self.emit(&#039;data&#039;, chunk)
    })
    responseContent.once(&#039;end&#039;, function (chunk) {
      self.emit(&#039;end&#039;, chunk)
    })
    responseContent.on(&#039;error&#039;, function (error) {
      self.emit(&#039;error&#039;, error)
    })
    responseContent.on(&#039;close&#039;, function () { self.emit(&#039;close&#039;) })

    if (self.callback) {
      self.readResponseBody(response)
    } else { // if no callback
      self.on(&#039;end&#039;, function () {
        if (self._aborted) {
          debug(&#039;aborted&#039;, self.uri.href)
          return
        }
        self.emit(&#039;complete&#039;, response)
      })
    }
  }
  debug(&#039;finish init function&#039;, self.uri.href)
}

Request.prototype.readResponseBody = function (response) {
  var self = this
  debug(&quot;reading response&#039;s body&quot;)
  var buffers = []
  var bufferLength = 0
  var strings = []

  self.on(&#039;data&#039;, function (chunk) {
    if (!Buffer.isBuffer(chunk)) {
      strings.push(chunk)
    } else if (chunk.length) {
      bufferLength += chunk.length
      buffers.push(chunk)
    }
  })
  self.on(&#039;end&#039;, function () {
    debug(&#039;end event&#039;, self.uri.href)
    if (self._aborted) {
      debug(&#039;aborted&#039;, self.uri.href)
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffers = []
      bufferLength = 0
      return
    }

    if (bufferLength) {
      debug(&#039;has body&#039;, self.uri.href, bufferLength)
      response.body = Buffer.concat(buffers, bufferLength)
      if (self.encoding !== null) {
        response.body = response.body.toString(self.encoding)
      }
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffers = []
      bufferLength = 0
    } else if (strings.length) {
      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
      // Strip this value out when the encoding is set to &#039;utf8&#039;, as upstream consumers won&#039;t expect it and it breaks JSON.parse().
      if (self.encoding === &#039;utf8&#039; &amp;&amp; strings[0].length &gt; 0 &amp;&amp; strings[0][0] === &#039;\uFEFF&#039;) {
        strings[0] = strings[0].substring(1)
      }
      response.body = strings.join(&#039;&#039;)
    }

    if (self._json) {
      try {
        response.body = JSON.parse(response.body, self._jsonReviver)
      } catch (e) {
        debug(&#039;invalid JSON received&#039;, self.uri.href)
      }
    }
    debug(&#039;emitting complete&#039;, self.uri.href)
    if (typeof response.body === &#039;undefined&#039; &amp;&amp; !self._json) {
      response.body = self.encoding === null ? Buffer.alloc(0) : &#039;&#039;
    }
    self.emit(&#039;complete&#039;, response, response.body)
  })
}

Request.prototype.abort = function () {
  var self = this
  self._aborted = true

  if (self.req) {
    self.req.abort()
  } else if (self.response) {
    self.response.destroy()
  }

  self.clearTimeout()
  self.emit(&#039;abort&#039;)
}

Request.prototype.pipeDest = function (dest) {
  var self = this
  var response = self.response
  // Called after the response is received
  if (dest.headers &amp;&amp; !dest.headersSent) {
    if (response.caseless.has(&#039;content-type&#039;)) {
      var ctname = response.caseless.has(&#039;content-type&#039;)
      if (dest.setHeader) {
        dest.setHeader(ctname, response.headers[ctname])
      } else {
        dest.headers[ctname] = response.headers[ctname]
      }
    }

    if (response.caseless.has(&#039;content-length&#039;)) {
      var clname = response.caseless.has(&#039;content-length&#039;)
      if (dest.setHeader) {
        dest.setHeader(clname, response.headers[clname])
      } else {
        dest.headers[clname] = response.headers[clname]
      }
    }
  }
  if (dest.setHeader &amp;&amp; !dest.headersSent) {
    for (var i in response.headers) {
      // If the response content is being decoded, the Content-Encoding header
      // of the response doesn&#039;t represent the piped content, so don&#039;t pass it.
      if (!self.gzip || i !== &#039;content-encoding&#039;) {
        dest.setHeader(i, response.headers[i])
      }
    }
    dest.statusCode = response.statusCode
  }
  if (self.pipefilter) {
    self.pipefilter(response, dest)
  }
}

Request.prototype.qs = function (q, clobber) {
  var self = this
  var base
  if (!clobber &amp;&amp; self.uri.query) {
    base = self._qs.parse(self.uri.query)
  } else {
    base = {}
  }

  for (var i in q) {
    base[i] = q[i]
  }

  var qs = self._qs.stringify(base)

  if (qs === &#039;&#039;) {
    return self
  }

  self.uri = url.parse(self.uri.href.split(&#039;?&#039;)[0] + &#039;?&#039; + qs)
  self.url = self.uri
  self.path = self.uri.path

  if (self.uri.host === &#039;unix&#039;) {
    self.enableUnixSocket()
  }

  return self
}
Request.prototype.form = function (form) {
  var self = this
  if (form) {
    if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader(&#039;content-type&#039;))) {
      self.setHeader(&#039;content-type&#039;, &#039;application/x-www-form-urlencoded&#039;)
    }
    self.body = (typeof form === &#039;string&#039;)
      ? self._qs.rfc3986(form.toString(&#039;utf8&#039;))
      : self._qs.stringify(form).toString(&#039;utf8&#039;)
    return self
  }
  // create form-data object
  self._form = new FormData()
  self._form.on(&#039;error&#039;, function (err) {
    err.message = &#039;form-data: &#039; + err.message
    self.emit(&#039;error&#039;, err)
    self.abort()
  })
  return self._form
}
Request.prototype.multipart = function (multipart) {
  var self = this

  self._multipart.onRequest(multipart)

  if (!self._multipart.chunked) {
    self.body = self._multipart.body
  }

  return self
}
Request.prototype.json = function (val) {
  var self = this

  if (!self.hasHeader(&#039;accept&#039;)) {
    self.setHeader(&#039;accept&#039;, &#039;application/json&#039;)
  }

  if (typeof self.jsonReplacer === &#039;function&#039;) {
    self._jsonReplacer = self.jsonReplacer
  }

  self._json = true
  if (typeof val === &#039;boolean&#039;) {
    if (self.body !== undefined) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader(&#039;content-type&#039;))) {
        self.body = safeStringify(self.body, self._jsonReplacer)
      } else {
        self.body = self._qs.rfc3986(self.body)
      }
      if (!self.hasHeader(&#039;content-type&#039;)) {
        self.setHeader(&#039;content-type&#039;, &#039;application/json&#039;)
      }
    }
  } else {
    self.body = safeStringify(val, self._jsonReplacer)
    if (!self.hasHeader(&#039;content-type&#039;)) {
      self.setHeader(&#039;content-type&#039;, &#039;application/json&#039;)
    }
  }

  if (typeof self.jsonReviver === &#039;function&#039;) {
    self._jsonReviver = self.jsonReviver
  }

  return self
}
Request.prototype.getHeader = function (name, headers) {
  var self = this
  var result, re, match
  if (!headers) {
    headers = self.headers
  }
  Object.keys(headers).forEach(function (key) {
    if (key.length !== name.length) {
      return
    }
    re = new RegExp(name, &#039;i&#039;)
    match = key.match(re)
    if (match) {
      result = headers[key]
    }
  })
  return result
}
Request.prototype.enableUnixSocket = function () {
  // Get the socket &amp; request paths from the URL
  var unixParts = this.uri.path.split(&#039;:&#039;)
  var host = unixParts[0]
  var path = unixParts[1]
  // Apply unix properties to request
  this.socketPath = host
  this.uri.pathname = path
  this.uri.path = path
  this.uri.host = host
  this.uri.hostname = host
  this.uri.isUnix = true
}

Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
  var self = this

  self._auth.onRequest(user, pass, sendImmediately, bearer)

  return self
}
Request.prototype.aws = function (opts, now) {
  var self = this

  if (!now) {
    self._aws = opts
    return self
  }

  if (opts.sign_version === 4 || opts.sign_version === &#039;4&#039;) {
    // use aws4
    var options = {
      host: self.uri.host,
      path: self.uri.path,
      method: self.method,
      headers: self.headers,
      body: self.body
    }
    if (opts.service) {
      options.service = opts.service
    }
    var signRes = aws4.sign(options, {
      accessKeyId: opts.key,
      secretAccessKey: opts.secret,
      sessionToken: opts.session
    })
    self.setHeader(&#039;authorization&#039;, signRes.headers.Authorization)
    self.setHeader(&#039;x-amz-date&#039;, signRes.headers[&#039;X-Amz-Date&#039;])
    if (signRes.headers[&#039;X-Amz-Security-Token&#039;]) {
      self.setHeader(&#039;x-amz-security-token&#039;, signRes.headers[&#039;X-Amz-Security-Token&#039;])
    }
  } else {
    // default: use aws-sign2
    var date = new Date()
    self.setHeader(&#039;date&#039;, date.toUTCString())
    var auth = {
      key: opts.key,
      secret: opts.secret,
      verb: self.method.toUpperCase(),
      date: date,
      contentType: self.getHeader(&#039;content-type&#039;) || &#039;&#039;,
      md5: self.getHeader(&#039;content-md5&#039;) || &#039;&#039;,
      amazonHeaders: aws2.canonicalizeHeaders(self.headers)
    }
    var path = self.uri.path
    if (opts.bucket &amp;&amp; path) {
      auth.resource = &#039;/&#039; + opts.bucket + path
    } else if (opts.bucket &amp;&amp; !path) {
      auth.resource = &#039;/&#039; + opts.bucket
    } else if (!opts.bucket &amp;&amp; path) {
      auth.resource = path
    } else if (!opts.bucket &amp;&amp; !path) {
      auth.resource = &#039;/&#039;
    }
    auth.resource = aws2.canonicalizeResource(auth.resource)
    self.setHeader(&#039;authorization&#039;, aws2.authorization(auth))
  }

  return self
}
Request.prototype.httpSignature = function (opts) {
  var self = this
  httpSignature.signRequest({
    getHeader: function (header) {
      return self.getHeader(header, self.headers)
    },
    setHeader: function (header, value) {
      self.setHeader(header, value)
    },
    method: self.method,
    path: self.path
  }, opts)
  debug(&#039;httpSignature authorization&#039;, self.getHeader(&#039;authorization&#039;))

  return self
}
Request.prototype.hawk = function (opts) {
  var self = this
  self.setHeader(&#039;Authorization&#039;, hawk.header(self.uri, self.method, opts))
}
Request.prototype.oauth = function (_oauth) {
  var self = this

  self._oauth.onRequest(_oauth)

  return self
}

Request.prototype.jar = function (jar) {
  var self = this
  var cookies

  if (self._redirect.redirectsFollowed === 0) {
    self.originalCookieHeader = self.getHeader(&#039;cookie&#039;)
  }

  if (!jar) {
    // disable cookies
    cookies = false
    self._disableCookies = true
  } else {
    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar
    var urihref = self.uri.href
    // fetch cookie in the Specified host
    if (targetCookieJar) {
      cookies = targetCookieJar.getCookieString(urihref)
    }
  }

  // if need cookie and cookie is not empty
  if (cookies &amp;&amp; cookies.length) {
    if (self.originalCookieHeader) {
      // Don&#039;t overwrite existing Cookie header
      self.setHeader(&#039;cookie&#039;, self.originalCookieHeader + &#039;; &#039; + cookies)
    } else {
      self.setHeader(&#039;cookie&#039;, cookies)
    }
  }
  self._jar = jar
  return self
}

// Stream API
Request.prototype.pipe = function (dest, opts) {
  var self = this

  if (self.response) {
    if (self._destdata) {
      self.emit(&#039;error&#039;, new Error(&#039;You cannot pipe after data has been emitted from the response.&#039;))
    } else if (self._ended) {
      self.emit(&#039;error&#039;, new Error(&#039;You cannot pipe after the response has been ended.&#039;))
    } else {
      stream.Stream.prototype.pipe.call(self, dest, opts)
      self.pipeDest(dest)
      return dest
    }
  } else {
    self.dests.push(dest)
    stream.Stream.prototype.pipe.call(self, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  var self = this
  if (self._aborted) { return }

  if (!self._started) {
    self.start()
  }
  if (self.req) {
    return self.req.write.apply(self.req, arguments)
  }
}
Request.prototype.end = function (chunk) {
  var self = this
  if (self._aborted) { return }

  if (chunk) {
    self.write(chunk)
  }
  if (!self._started) {
    self.start()
  }
  if (self.req) {
    self.req.end()
  }
}
Request.prototype.pause = function () {
  var self = this
  if (!self.responseContent) {
    self._paused = true
  } else {
    self.responseContent.pause.apply(self.responseContent, arguments)
  }
}
Request.prototype.resume = function () {
  var self = this
  if (!self.responseContent) {
    self._paused = false
  } else {
    self.responseContent.resume.apply(self.responseContent, arguments)
  }
}
Request.prototype.destroy = function () {
  var self = this
  this.clearTimeout()
  if (!self._ended) {
    self.end()
  } else if (self.response) {
    self.response.destroy()
  }
}

Request.prototype.clearTimeout = function () {
  if (this.timeoutTimer) {
    clearTimeout(this.timeoutTimer)
    this.timeoutTimer = null
  }
}

Request.defaultProxyHeaderWhiteList =
  Tunnel.defaultProxyHeaderWhiteList.slice()

Request.defaultProxyHeaderExclusiveList =
  Tunnel.defaultProxyHeaderExclusiveList.slice()

// Exports

Request.prototype.toJSON = requestToJSON
module.exports = Request
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
