<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/object-shorthand.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/object-shorthand.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">628</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">44.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to enforce concise object methods and properties.
 * @author Jamund Ferguson
 */

&quot;use strict&quot;;

const OPTIONS = {
	always: &quot;always&quot;,
	never: &quot;never&quot;,
	methods: &quot;methods&quot;,
	properties: &quot;properties&quot;,
	consistent: &quot;consistent&quot;,
	consistentAsNeeded: &quot;consistent-as-needed&quot;,
};

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		docs: {
			description:
				&quot;Require or disallow method and property shorthand syntax for object literals&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/object-shorthand&quot;,
		},

		fixable: &quot;code&quot;,

		schema: {
			anyOf: [
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [
								&quot;always&quot;,
								&quot;methods&quot;,
								&quot;properties&quot;,
								&quot;never&quot;,
								&quot;consistent&quot;,
								&quot;consistent-as-needed&quot;,
							],
						},
					],
					minItems: 0,
					maxItems: 1,
				},
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [&quot;always&quot;, &quot;methods&quot;, &quot;properties&quot;],
						},
						{
							type: &quot;object&quot;,
							properties: {
								avoidQuotes: {
									type: &quot;boolean&quot;,
								},
							},
							additionalProperties: false,
						},
					],
					minItems: 0,
					maxItems: 2,
				},
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [&quot;always&quot;, &quot;methods&quot;],
						},
						{
							type: &quot;object&quot;,
							properties: {
								ignoreConstructors: {
									type: &quot;boolean&quot;,
								},
								methodsIgnorePattern: {
									type: &quot;string&quot;,
								},
								avoidQuotes: {
									type: &quot;boolean&quot;,
								},
								avoidExplicitReturnArrows: {
									type: &quot;boolean&quot;,
								},
							},
							additionalProperties: false,
						},
					],
					minItems: 0,
					maxItems: 2,
				},
			],
		},

		messages: {
			expectedAllPropertiesShorthanded:
				&quot;Expected shorthand for all properties.&quot;,
			expectedLiteralMethodLongform:
				&quot;Expected longform method syntax for string literal keys.&quot;,
			expectedPropertyShorthand: &quot;Expected property shorthand.&quot;,
			expectedPropertyLongform: &quot;Expected longform property syntax.&quot;,
			expectedMethodShorthand: &quot;Expected method shorthand.&quot;,
			expectedMethodLongform: &quot;Expected longform method syntax.&quot;,
			unexpectedMix:
				&quot;Unexpected mix of shorthand and non-shorthand properties.&quot;,
		},
	},

	create(context) {
		const APPLY = context.options[0] || OPTIONS.always;
		const APPLY_TO_METHODS =
			APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
		const APPLY_TO_PROPS =
			APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
		const APPLY_NEVER = APPLY === OPTIONS.never;
		const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
		const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;

		const PARAMS = context.options[1] || {};
		const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
		const METHODS_IGNORE_PATTERN = PARAMS.methodsIgnorePattern
			? new RegExp(PARAMS.methodsIgnorePattern, &quot;u&quot;)
			: null;
		const AVOID_QUOTES = PARAMS.avoidQuotes;
		const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
		const sourceCode = context.sourceCode;

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		const CTOR_PREFIX_REGEX = /[^_$0-9]/u;

		/**
		 * Determines if the first character of the name is a capital letter.
		 * @param {string} name The name of the node to evaluate.
		 * @returns {boolean} True if the first character of the property name is a capital letter, false if not.
		 * @private
		 */
		function isConstructor(name) {
			const match = CTOR_PREFIX_REGEX.exec(name);

			// Not a constructor if name has no characters apart from &#039;_&#039;, &#039;$&#039; and digits e.g. &#039;_&#039;, &#039;$$&#039;, &#039;_8&#039;
			if (!match) {
				return false;
			}

			const firstChar = name.charAt(match.index);

			return firstChar === firstChar.toUpperCase();
		}

		/**
		 * Determines if the property can have a shorthand form.
		 * @param {ASTNode} property Property AST node
		 * @returns {boolean} True if the property can have a shorthand form
		 * @private
		 */
		function canHaveShorthand(property) {
			return (
				property.kind !== &quot;set&quot; &amp;&amp;
				property.kind !== &quot;get&quot; &amp;&amp;
				property.type !== &quot;SpreadElement&quot; &amp;&amp;
				property.type !== &quot;SpreadProperty&quot; &amp;&amp;
				property.type !== &quot;ExperimentalSpreadProperty&quot;
			);
		}

		/**
		 * Checks whether a node is a string literal.
		 * @param {ASTNode} node Any AST node.
		 * @returns {boolean} `true` if it is a string literal.
		 */
		function isStringLiteral(node) {
			return node.type === &quot;Literal&quot; &amp;&amp; typeof node.value === &quot;string&quot;;
		}

		/**
		 * Determines if the property is a shorthand or not.
		 * @param {ASTNode} property Property AST node
		 * @returns {boolean} True if the property is considered shorthand, false if not.
		 * @private
		 */
		function isShorthand(property) {
			// property.method is true when `{a(){}}`.
			return property.shorthand || property.method;
		}

		/**
		 * Determines if the property&#039;s key and method or value are named equally.
		 * @param {ASTNode} property Property AST node
		 * @returns {boolean} True if the key and value are named equally, false if not.
		 * @private
		 */
		function isRedundant(property) {
			const value = property.value;

			if (value.type === &quot;FunctionExpression&quot;) {
				return !value.id; // Only anonymous should be shorthand method.
			}
			if (value.type === &quot;Identifier&quot;) {
				return astUtils.getStaticPropertyName(property) === value.name;
			}

			return false;
		}

		/**
		 * Ensures that an object&#039;s properties are consistently shorthand, or not shorthand at all.
		 * @param {ASTNode} node Property AST node
		 * @param {boolean} checkRedundancy Whether to check longform redundancy
		 * @returns {void}
		 */
		function checkConsistency(node, checkRedundancy) {
			// We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.
			const properties = node.properties.filter(canHaveShorthand);

			// Do we still have properties left after filtering the getters and setters?
			if (properties.length &gt; 0) {
				const shorthandProperties = properties.filter(isShorthand);

				/*
				 * If we do not have an equal number of longform properties as
				 * shorthand properties, we are using the annotations inconsistently
				 */
				if (shorthandProperties.length !== properties.length) {
					// We have at least 1 shorthand property
					if (shorthandProperties.length &gt; 0) {
						context.report({ node, messageId: &quot;unexpectedMix&quot; });
					} else if (checkRedundancy) {
						/*
						 * If all properties of the object contain a method or value with a name matching it&#039;s key,
						 * all the keys are redundant.
						 */
						const canAlwaysUseShorthand =
							properties.every(isRedundant);

						if (canAlwaysUseShorthand) {
							context.report({
								node,
								messageId: &quot;expectedAllPropertiesShorthanded&quot;,
							});
						}
					}
				}
			}
		}

		/**
		 * Fixes a FunctionExpression node by making it into a shorthand property.
		 * @param {SourceCodeFixer} fixer The fixer object
		 * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value
		 * @returns {Object} A fix for this node
		 */
		function makeFunctionShorthand(fixer, node) {
			const firstKeyToken = node.computed
				? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)
				: sourceCode.getFirstToken(node.key);
			const lastKeyToken = node.computed
				? sourceCode.getFirstTokenBetween(
						node.key,
						node.value,
						astUtils.isClosingBracketToken,
					)
				: sourceCode.getLastToken(node.key);
			const keyText = sourceCode.text.slice(
				firstKeyToken.range[0],
				lastKeyToken.range[1],
			);
			let keyPrefix = &quot;&quot;;

			// key: /* */ () =&gt; {}
			if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {
				return null;
			}

			if (node.value.async) {
				keyPrefix += &quot;async &quot;;
			}
			if (node.value.generator) {
				keyPrefix += &quot;*&quot;;
			}

			const fixRange = [firstKeyToken.range[0], node.range[1]];
			const methodPrefix = keyPrefix + keyText;

			if (node.value.type === &quot;FunctionExpression&quot;) {
				const functionToken = sourceCode
					.getTokens(node.value)
					.find(
						token =&gt;
							token.type === &quot;Keyword&quot; &amp;&amp;
							token.value === &quot;function&quot;,
					);
				const tokenBeforeParams = node.value.generator
					? sourceCode.getTokenAfter(functionToken)
					: functionToken;

				return fixer.replaceTextRange(
					fixRange,
					methodPrefix +
						sourceCode.text.slice(
							tokenBeforeParams.range[1],
							node.value.range[1],
						),
				);
			}

			const arrowToken = sourceCode.getTokenBefore(
				node.value.body,
				astUtils.isArrowToken,
			);
			const fnBody = sourceCode.text.slice(
				arrowToken.range[1],
				node.value.range[1],
			);

			// First token should not be `async`
			const firstValueToken = sourceCode.getFirstToken(node.value, {
				skip: node.value.async ? 1 : 0,
			});

			const sliceStart = firstValueToken.range[0];
			const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];
			const shouldAddParens =
				node.value.params.length === 1 &amp;&amp;
				node.value.params[0].range[0] === sliceStart;

			const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);
			const newParamText = shouldAddParens
				? `(${oldParamText})`
				: oldParamText;

			return fixer.replaceTextRange(
				fixRange,
				methodPrefix + newParamText + fnBody,
			);
		}

		/**
		 * Fixes a FunctionExpression node by making it into a longform property.
		 * @param {SourceCodeFixer} fixer The fixer object
		 * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value
		 * @returns {Object} A fix for this node
		 */
		function makeFunctionLongform(fixer, node) {
			const firstKeyToken = node.computed
				? sourceCode.getTokens(node).find(token =&gt; token.value === &quot;[&quot;)
				: sourceCode.getFirstToken(node.key);
			const lastKeyToken = node.computed
				? sourceCode
						.getTokensBetween(node.key, node.value)
						.find(token =&gt; token.value === &quot;]&quot;)
				: sourceCode.getLastToken(node.key);
			const keyText = sourceCode.text.slice(
				firstKeyToken.range[0],
				lastKeyToken.range[1],
			);
			let functionHeader = &quot;function&quot;;

			if (node.value.async) {
				functionHeader = `async ${functionHeader}`;
			}
			if (node.value.generator) {
				functionHeader = `${functionHeader}*`;
			}

			return fixer.replaceTextRange(
				[node.range[0], lastKeyToken.range[1]],
				`${keyText}: ${functionHeader}`,
			);
		}

		/*
		 * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),
		 * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is
		 * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical
		 * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,
		 * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.
		 * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them
		 * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,
		 * because converting it into a method would change the value of one of the lexical identifiers.
		 */
		const lexicalScopeStack = [];
		const arrowsWithLexicalIdentifiers = new WeakSet();
		const argumentsIdentifiers = new WeakSet();

		/**
		 * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.
		 * Also, this marks all `arguments` identifiers so that they can be detected later.
		 * @param {ASTNode} node The node representing the function.
		 * @returns {void}
		 */
		function enterFunction(node) {
			lexicalScopeStack.unshift(new Set());
			sourceCode
				.getScope(node)
				.variables.filter(variable =&gt; variable.name === &quot;arguments&quot;)
				.forEach(variable =&gt; {
					variable.references
						.map(ref =&gt; ref.identifier)
						.forEach(identifier =&gt;
							argumentsIdentifiers.add(identifier),
						);
				});
		}

		/**
		 * Exits a function. This pops the current set of arrow functions off the lexical scope stack.
		 * @returns {void}
		 */
		function exitFunction() {
			lexicalScopeStack.shift();
		}

		/**
		 * Marks the current function as having a lexical keyword. This implies that all arrow functions
		 * in the current lexical scope contain a reference to this lexical keyword.
		 * @returns {void}
		 */
		function reportLexicalIdentifier() {
			lexicalScopeStack[0].forEach(arrowFunction =&gt;
				arrowsWithLexicalIdentifiers.add(arrowFunction),
			);
		}

		//--------------------------------------------------------------------------
		// Public
		//--------------------------------------------------------------------------

		return {
			Program: enterFunction,
			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			&quot;Program:exit&quot;: exitFunction,
			&quot;FunctionDeclaration:exit&quot;: exitFunction,
			&quot;FunctionExpression:exit&quot;: exitFunction,

			ArrowFunctionExpression(node) {
				lexicalScopeStack[0].add(node);
			},
			&quot;ArrowFunctionExpression:exit&quot;(node) {
				lexicalScopeStack[0].delete(node);
			},

			ThisExpression: reportLexicalIdentifier,
			Super: reportLexicalIdentifier,
			MetaProperty(node) {
				if (
					node.meta.name === &quot;new&quot; &amp;&amp;
					node.property.name === &quot;target&quot;
				) {
					reportLexicalIdentifier();
				}
			},
			Identifier(node) {
				if (argumentsIdentifiers.has(node)) {
					reportLexicalIdentifier();
				}
			},

			ObjectExpression(node) {
				if (APPLY_CONSISTENT) {
					checkConsistency(node, false);
				} else if (APPLY_CONSISTENT_AS_NEEDED) {
					checkConsistency(node, true);
				}
			},

			&quot;Property:exit&quot;(node) {
				const isConciseProperty = node.method || node.shorthand;

				// Ignore destructuring assignment
				if (node.parent.type === &quot;ObjectPattern&quot;) {
					return;
				}

				// getters and setters are ignored
				if (node.kind === &quot;get&quot; || node.kind === &quot;set&quot;) {
					return;
				}

				// only computed methods can fail the following checks
				if (
					node.computed &amp;&amp;
					node.value.type !== &quot;FunctionExpression&quot; &amp;&amp;
					node.value.type !== &quot;ArrowFunctionExpression&quot;
				) {
					return;
				}

				//--------------------------------------------------------------
				// Checks for property/method shorthand.
				if (isConciseProperty) {
					if (
						node.method &amp;&amp;
						(APPLY_NEVER ||
							(AVOID_QUOTES &amp;&amp; isStringLiteral(node.key)))
					) {
						const messageId = APPLY_NEVER
							? &quot;expectedMethodLongform&quot;
							: &quot;expectedLiteralMethodLongform&quot;;

						// { x() {} } should be written as { x: function() {} }
						context.report({
							node,
							messageId,
							fix: fixer =&gt; makeFunctionLongform(fixer, node),
						});
					} else if (APPLY_NEVER) {
						// { x } should be written as { x: x }
						context.report({
							node,
							messageId: &quot;expectedPropertyLongform&quot;,
							fix: fixer =&gt;
								fixer.insertTextAfter(
									node.key,
									`: ${node.key.name}`,
								),
						});
					}
				} else if (
					APPLY_TO_METHODS &amp;&amp;
					!node.value.id &amp;&amp;
					(node.value.type === &quot;FunctionExpression&quot; ||
						node.value.type === &quot;ArrowFunctionExpression&quot;)
				) {
					if (
						IGNORE_CONSTRUCTORS &amp;&amp;
						node.key.type === &quot;Identifier&quot; &amp;&amp;
						isConstructor(node.key.name)
					) {
						return;
					}

					if (METHODS_IGNORE_PATTERN) {
						const propertyName =
							astUtils.getStaticPropertyName(node);

						if (
							propertyName !== null &amp;&amp;
							METHODS_IGNORE_PATTERN.test(propertyName)
						) {
							return;
						}
					}

					if (AVOID_QUOTES &amp;&amp; isStringLiteral(node.key)) {
						return;
					}

					// {[x]: function(){}} should be written as {[x]() {}}
					if (
						node.value.type === &quot;FunctionExpression&quot; ||
						(node.value.type === &quot;ArrowFunctionExpression&quot; &amp;&amp;
							node.value.body.type === &quot;BlockStatement&quot; &amp;&amp;
							AVOID_EXPLICIT_RETURN_ARROWS &amp;&amp;
							!arrowsWithLexicalIdentifiers.has(node.value))
					) {
						context.report({
							node,
							messageId: &quot;expectedMethodShorthand&quot;,
							fix: fixer =&gt; makeFunctionShorthand(fixer, node),
						});
					}
				} else if (
					node.value.type === &quot;Identifier&quot; &amp;&amp;
					node.key.name === node.value.name &amp;&amp;
					APPLY_TO_PROPS
				) {
					// {x: x} should be written as {x}
					context.report({
						node,
						messageId: &quot;expectedPropertyShorthand&quot;,
						fix(fixer) {
							// x: /* */ x
							// x: (/* */ x)
							if (sourceCode.getCommentsInside(node).length &gt; 0) {
								return null;
							}

							return fixer.replaceText(node, node.value.name);
						},
					});
				} else if (
					node.value.type === &quot;Identifier&quot; &amp;&amp;
					node.key.type === &quot;Literal&quot; &amp;&amp;
					node.key.value === node.value.name &amp;&amp;
					APPLY_TO_PROPS
				) {
					if (AVOID_QUOTES) {
						return;
					}

					// {&quot;x&quot;: x} should be written as {x}
					context.report({
						node,
						messageId: &quot;expectedPropertyShorthand&quot;,
						fix(fixer) {
							// &quot;x&quot;: /* */ x
							// &quot;x&quot;: (/* */ x)
							if (sourceCode.getCommentsInside(node).length &gt; 0) {
								return null;
							}

							return fixer.replaceText(node, node.value.name);
						},
					});
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
