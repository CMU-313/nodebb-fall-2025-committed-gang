<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/luxon/src/impl/formatter.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/luxon/src/impl/formatter.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">410</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">66.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.50</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import * as English from &quot;./english.js&quot;;
import * as Formats from &quot;./formats.js&quot;;
import { padStart } from &quot;./util.js&quot;;

function stringifyTokens(splits, tokenToString) {
  let s = &quot;&quot;;
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}

const macroTokenToFormatOpts = {
  D: Formats.DATE_SHORT,
  DD: Formats.DATE_MED,
  DDD: Formats.DATE_FULL,
  DDDD: Formats.DATE_HUGE,
  t: Formats.TIME_SIMPLE,
  tt: Formats.TIME_WITH_SECONDS,
  ttt: Formats.TIME_WITH_SHORT_OFFSET,
  tttt: Formats.TIME_WITH_LONG_OFFSET,
  T: Formats.TIME_24_SIMPLE,
  TT: Formats.TIME_24_WITH_SECONDS,
  TTT: Formats.TIME_24_WITH_SHORT_OFFSET,
  TTTT: Formats.TIME_24_WITH_LONG_OFFSET,
  f: Formats.DATETIME_SHORT,
  ff: Formats.DATETIME_MED,
  fff: Formats.DATETIME_FULL,
  ffff: Formats.DATETIME_HUGE,
  F: Formats.DATETIME_SHORT_WITH_SECONDS,
  FF: Formats.DATETIME_MED_WITH_SECONDS,
  FFF: Formats.DATETIME_FULL_WITH_SECONDS,
  FFFF: Formats.DATETIME_HUGE_WITH_SECONDS,
};

/**
 * @private
 */

export default class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }

  static parseFormat(fmt) {
    // white-space is always considered a literal in user-provided formats
    // the &quot; &quot; token has a special meaning (see unitForToken)

    let current = null,
      currentFull = &quot;&quot;,
      bracketed = false;
    const splits = [];
    for (let i = 0; i &lt; fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === &quot;&#039;&quot;) {
        if (currentFull.length &gt; 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = &quot;&quot;;
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length &gt; 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length &gt; 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }

    return splits;
  }

  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }

  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }

  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }

  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }

  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }

  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }

  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }

  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    const opts = { ...this.opts };

    if (p &gt; 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  }

  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === &quot;en&quot;,
      useDateTimeFormatter = this.loc.outputCalendar &amp;&amp; this.loc.outputCalendar !== &quot;gregory&quot;,
      string = (opts, extract) =&gt; this.loc.extract(dt, opts, extract),
      formatOffset = (opts) =&gt; {
        if (dt.isOffsetFixed &amp;&amp; dt.offset === 0 &amp;&amp; opts.allowZ) {
          return &quot;Z&quot;;
        }

        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : &quot;&quot;;
      },
      meridiem = () =&gt;
        knownEnglish
          ? English.meridiemForDateTime(dt)
          : string({ hour: &quot;numeric&quot;, hourCycle: &quot;h12&quot; }, &quot;dayperiod&quot;),
      month = (length, standalone) =&gt;
        knownEnglish
          ? English.monthForDateTime(dt, length)
          : string(standalone ? { month: length } : { month: length, day: &quot;numeric&quot; }, &quot;month&quot;),
      weekday = (length, standalone) =&gt;
        knownEnglish
          ? English.weekdayForDateTime(dt, length)
          : string(
              standalone ? { weekday: length } : { weekday: length, month: &quot;long&quot;, day: &quot;numeric&quot; },
              &quot;weekday&quot;
            ),
      maybeMacro = (token) =&gt; {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = (length) =&gt;
        knownEnglish ? English.eraForDateTime(dt, length) : string({ era: length }, &quot;era&quot;),
      tokenToString = (token) =&gt; {
        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols
        switch (token) {
          // ms
          case &quot;S&quot;:
            return this.num(dt.millisecond);
          case &quot;u&quot;:
          // falls through
          case &quot;SSS&quot;:
            return this.num(dt.millisecond, 3);
          // seconds
          case &quot;s&quot;:
            return this.num(dt.second);
          case &quot;ss&quot;:
            return this.num(dt.second, 2);
          // fractional seconds
          case &quot;uu&quot;:
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case &quot;uuu&quot;:
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case &quot;m&quot;:
            return this.num(dt.minute);
          case &quot;mm&quot;:
            return this.num(dt.minute, 2);
          // hours
          case &quot;h&quot;:
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case &quot;hh&quot;:
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case &quot;H&quot;:
            return this.num(dt.hour);
          case &quot;HH&quot;:
            return this.num(dt.hour, 2);
          // offset
          case &quot;Z&quot;:
            // like +6
            return formatOffset({ format: &quot;narrow&quot;, allowZ: this.opts.allowZ });
          case &quot;ZZ&quot;:
            // like +06:00
            return formatOffset({ format: &quot;short&quot;, allowZ: this.opts.allowZ });
          case &quot;ZZZ&quot;:
            // like +0600
            return formatOffset({ format: &quot;techie&quot;, allowZ: this.opts.allowZ });
          case &quot;ZZZZ&quot;:
            // like EST
            return dt.zone.offsetName(dt.ts, { format: &quot;short&quot;, locale: this.loc.locale });
          case &quot;ZZZZZ&quot;:
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, { format: &quot;long&quot;, locale: this.loc.locale });
          // zone
          case &quot;z&quot;:
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case &quot;a&quot;:
            return meridiem();
          // dates
          case &quot;d&quot;:
            return useDateTimeFormatter ? string({ day: &quot;numeric&quot; }, &quot;day&quot;) : this.num(dt.day);
          case &quot;dd&quot;:
            return useDateTimeFormatter ? string({ day: &quot;2-digit&quot; }, &quot;day&quot;) : this.num(dt.day, 2);
          // weekdays - standalone
          case &quot;c&quot;:
            // like 1
            return this.num(dt.weekday);
          case &quot;ccc&quot;:
            // like &#039;Tues&#039;
            return weekday(&quot;short&quot;, true);
          case &quot;cccc&quot;:
            // like &#039;Tuesday&#039;
            return weekday(&quot;long&quot;, true);
          case &quot;ccccc&quot;:
            // like &#039;T&#039;
            return weekday(&quot;narrow&quot;, true);
          // weekdays - format
          case &quot;E&quot;:
            // like 1
            return this.num(dt.weekday);
          case &quot;EEE&quot;:
            // like &#039;Tues&#039;
            return weekday(&quot;short&quot;, false);
          case &quot;EEEE&quot;:
            // like &#039;Tuesday&#039;
            return weekday(&quot;long&quot;, false);
          case &quot;EEEEE&quot;:
            // like &#039;T&#039;
            return weekday(&quot;narrow&quot;, false);
          // months - standalone
          case &quot;L&quot;:
            // like 1
            return useDateTimeFormatter
              ? string({ month: &quot;numeric&quot;, day: &quot;numeric&quot; }, &quot;month&quot;)
              : this.num(dt.month);
          case &quot;LL&quot;:
            // like 01, doesn&#039;t seem to work
            return useDateTimeFormatter
              ? string({ month: &quot;2-digit&quot;, day: &quot;numeric&quot; }, &quot;month&quot;)
              : this.num(dt.month, 2);
          case &quot;LLL&quot;:
            // like Jan
            return month(&quot;short&quot;, true);
          case &quot;LLLL&quot;:
            // like January
            return month(&quot;long&quot;, true);
          case &quot;LLLLL&quot;:
            // like J
            return month(&quot;narrow&quot;, true);
          // months - format
          case &quot;M&quot;:
            // like 1
            return useDateTimeFormatter
              ? string({ month: &quot;numeric&quot; }, &quot;month&quot;)
              : this.num(dt.month);
          case &quot;MM&quot;:
            // like 01
            return useDateTimeFormatter
              ? string({ month: &quot;2-digit&quot; }, &quot;month&quot;)
              : this.num(dt.month, 2);
          case &quot;MMM&quot;:
            // like Jan
            return month(&quot;short&quot;, false);
          case &quot;MMMM&quot;:
            // like January
            return month(&quot;long&quot;, false);
          case &quot;MMMMM&quot;:
            // like J
            return month(&quot;narrow&quot;, false);
          // years
          case &quot;y&quot;:
            // like 2014
            return useDateTimeFormatter ? string({ year: &quot;numeric&quot; }, &quot;year&quot;) : this.num(dt.year);
          case &quot;yy&quot;:
            // like 14
            return useDateTimeFormatter
              ? string({ year: &quot;2-digit&quot; }, &quot;year&quot;)
              : this.num(dt.year.toString().slice(-2), 2);
          case &quot;yyyy&quot;:
            // like 0012
            return useDateTimeFormatter
              ? string({ year: &quot;numeric&quot; }, &quot;year&quot;)
              : this.num(dt.year, 4);
          case &quot;yyyyyy&quot;:
            // like 000012
            return useDateTimeFormatter
              ? string({ year: &quot;numeric&quot; }, &quot;year&quot;)
              : this.num(dt.year, 6);
          // eras
          case &quot;G&quot;:
            // like AD
            return era(&quot;short&quot;);
          case &quot;GG&quot;:
            // like Anno Domini
            return era(&quot;long&quot;);
          case &quot;GGGGG&quot;:
            return era(&quot;narrow&quot;);
          case &quot;kk&quot;:
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case &quot;kkkk&quot;:
            return this.num(dt.weekYear, 4);
          case &quot;W&quot;:
            return this.num(dt.weekNumber);
          case &quot;WW&quot;:
            return this.num(dt.weekNumber, 2);
          case &quot;n&quot;:
            return this.num(dt.localWeekNumber);
          case &quot;nn&quot;:
            return this.num(dt.localWeekNumber, 2);
          case &quot;ii&quot;:
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case &quot;iiii&quot;:
            return this.num(dt.localWeekYear, 4);
          case &quot;o&quot;:
            return this.num(dt.ordinal);
          case &quot;ooo&quot;:
            return this.num(dt.ordinal, 3);
          case &quot;q&quot;:
            // like 1
            return this.num(dt.quarter);
          case &quot;qq&quot;:
            // like 01
            return this.num(dt.quarter, 2);
          case &quot;X&quot;:
            return this.num(Math.floor(dt.ts / 1000));
          case &quot;x&quot;:
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }

  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) =&gt; {
        switch (token[0]) {
          case &quot;S&quot;:
            return &quot;millisecond&quot;;
          case &quot;s&quot;:
            return &quot;second&quot;;
          case &quot;m&quot;:
            return &quot;minute&quot;;
          case &quot;h&quot;:
            return &quot;hour&quot;;
          case &quot;d&quot;:
            return &quot;day&quot;;
          case &quot;w&quot;:
            return &quot;week&quot;;
          case &quot;M&quot;:
            return &quot;month&quot;;
          case &quot;y&quot;:
            return &quot;year&quot;;
          default:
            return null;
        }
      },
      tokenToString = (lildur) =&gt; (token) =&gt; {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce(
        (found, { literal, val }) =&gt; (literal ? found : found.concat(val)),
        []
      ),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) =&gt; t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
