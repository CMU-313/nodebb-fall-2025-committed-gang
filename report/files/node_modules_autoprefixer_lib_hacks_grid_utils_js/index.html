<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/autoprefixer/lib/hacks/grid-utils.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/autoprefixer/lib/hacks/grid-utils.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1114</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">113.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">let parser = require(&#039;postcss-value-parser&#039;)
let list = require(&#039;postcss&#039;).list

let uniq = require(&#039;../utils&#039;).uniq
let escapeRegexp = require(&#039;../utils&#039;).escapeRegexp
let splitSelector = require(&#039;../utils&#039;).splitSelector

function convert(value) {
  if (
    value &amp;&amp;
    value.length === 2 &amp;&amp;
    value[0] === &#039;span&#039; &amp;&amp;
    parseInt(value[1], 10) &gt; 0
  ) {
    return [false, parseInt(value[1], 10)]
  }

  if (value &amp;&amp; value.length === 1 &amp;&amp; parseInt(value[0], 10) &gt; 0) {
    return [parseInt(value[0], 10), false]
  }

  return [false, false]
}

exports.translate = translate

function translate(values, startIndex, endIndex) {
  let startValue = values[startIndex]
  let endValue = values[endIndex]

  if (!startValue) {
    return [false, false]
  }

  let [start, spanStart] = convert(startValue)
  let [end, spanEnd] = convert(endValue)

  if (start &amp;&amp; !endValue) {
    return [start, false]
  }

  if (spanStart &amp;&amp; end) {
    return [end - spanStart, spanStart]
  }

  if (start &amp;&amp; spanEnd) {
    return [start, spanEnd]
  }

  if (start &amp;&amp; end) {
    return [start, end - start]
  }

  return [false, false]
}

exports.parse = parse

function parse(decl) {
  let node = parser(decl.value)

  let values = []
  let current = 0
  values[current] = []

  for (let i of node.nodes) {
    if (i.type === &#039;div&#039;) {
      current += 1
      values[current] = []
    } else if (i.type === &#039;word&#039;) {
      values[current].push(i.value)
    }
  }

  return values
}

exports.insertDecl = insertDecl

function insertDecl(decl, prop, value) {
  if (value &amp;&amp; !decl.parent.some(i =&gt; i.prop === `-ms-${prop}`)) {
    decl.cloneBefore({
      prop: `-ms-${prop}`,
      value: value.toString()
    })
  }
}

// Track transforms

exports.prefixTrackProp = prefixTrackProp

function prefixTrackProp({ prefix, prop }) {
  return prefix + prop.replace(&#039;template-&#039;, &#039;&#039;)
}

function transformRepeat({ nodes }, { gap }) {
  let { count, size } = nodes.reduce(
    (result, node) =&gt; {
      if (node.type === &#039;div&#039; &amp;&amp; node.value === &#039;,&#039;) {
        result.key = &#039;size&#039;
      } else {
        result[result.key].push(parser.stringify(node))
      }
      return result
    },
    {
      count: [],
      key: &#039;count&#039;,
      size: []
    }
  )

  // insert gap values
  if (gap) {
    size = size.filter(i =&gt; i.trim())
    let val = []
    for (let i = 1; i &lt;= count; i++) {
      size.forEach((item, index) =&gt; {
        if (index &gt; 0 || i &gt; 1) {
          val.push(gap)
        }
        val.push(item)
      })
    }

    return val.join(&#039; &#039;)
  }

  return `(${size.join(&#039;&#039;)})[${count.join(&#039;&#039;)}]`
}

exports.prefixTrackValue = prefixTrackValue

function prefixTrackValue({ gap, value }) {
  let result = parser(value).nodes.reduce((nodes, node) =&gt; {
    if (node.type === &#039;function&#039; &amp;&amp; node.value === &#039;repeat&#039;) {
      return nodes.concat({
        type: &#039;word&#039;,
        value: transformRepeat(node, { gap })
      })
    }
    if (gap &amp;&amp; node.type === &#039;space&#039;) {
      return nodes.concat(
        {
          type: &#039;space&#039;,
          value: &#039; &#039;
        },
        {
          type: &#039;word&#039;,
          value: gap
        },
        node
      )
    }
    return nodes.concat(node)
  }, [])

  return parser.stringify(result)
}

// Parse grid-template-areas

let DOTS = /^\.+$/

function track(start, end) {
  return { end, span: end - start, start }
}

function getColumns(line) {
  return line.trim().split(/\s+/g)
}

exports.parseGridAreas = parseGridAreas

function parseGridAreas({ gap, rows }) {
  return rows.reduce((areas, line, rowIndex) =&gt; {
    if (gap.row) rowIndex *= 2

    if (line.trim() === &#039;&#039;) return areas

    getColumns(line).forEach((area, columnIndex) =&gt; {
      if (DOTS.test(area)) return

      if (gap.column) columnIndex *= 2

      if (typeof areas[area] === &#039;undefined&#039;) {
        areas[area] = {
          column: track(columnIndex + 1, columnIndex + 2),
          row: track(rowIndex + 1, rowIndex + 2)
        }
      } else {
        let { column, row } = areas[area]

        column.start = Math.min(column.start, columnIndex + 1)
        column.end = Math.max(column.end, columnIndex + 2)
        column.span = column.end - column.start

        row.start = Math.min(row.start, rowIndex + 1)
        row.end = Math.max(row.end, rowIndex + 2)
        row.span = row.end - row.start
      }
    })

    return areas
  }, {})
}

// Parse grid-template

function testTrack(node) {
  return node.type === &#039;word&#039; &amp;&amp; /^\[.+]$/.test(node.value)
}

function verifyRowSize(result) {
  if (result.areas.length &gt; result.rows.length) {
    result.rows.push(&#039;auto&#039;)
  }
  return result
}

exports.parseTemplate = parseTemplate

function parseTemplate({ decl, gap }) {
  let gridTemplate = parser(decl.value).nodes.reduce(
    (result, node) =&gt; {
      let { type, value } = node

      if (testTrack(node) || type === &#039;space&#039;) return result

      // area
      if (type === &#039;string&#039;) {
        result = verifyRowSize(result)
        result.areas.push(value)
      }

      // values and function
      if (type === &#039;word&#039; || type === &#039;function&#039;) {
        result[result.key].push(parser.stringify(node))
      }

      // divider(/)
      if (type === &#039;div&#039; &amp;&amp; value === &#039;/&#039;) {
        result.key = &#039;columns&#039;
        result = verifyRowSize(result)
      }

      return result
    },
    {
      areas: [],
      columns: [],
      key: &#039;rows&#039;,
      rows: []
    }
  )

  return {
    areas: parseGridAreas({
      gap,
      rows: gridTemplate.areas
    }),
    columns: prefixTrackValue({
      gap: gap.column,
      value: gridTemplate.columns.join(&#039; &#039;)
    }),
    rows: prefixTrackValue({
      gap: gap.row,
      value: gridTemplate.rows.join(&#039; &#039;)
    })
  }
}

// Insert parsed grid areas

/**
 * Get an array of -ms- prefixed props and values
 * @param  {Object} [area] area object with column and row data
 * @param  {Boolean} [addRowSpan] should we add grid-column-row value?
 * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?
 * @return {Array&lt;Object&gt;}
 */
function getMSDecls(area, addRowSpan = false, addColumnSpan = false) {
  let result = [
    {
      prop: &#039;-ms-grid-row&#039;,
      value: String(area.row.start)
    }
  ]
  if (area.row.span &gt; 1 || addRowSpan) {
    result.push({
      prop: &#039;-ms-grid-row-span&#039;,
      value: String(area.row.span)
    })
  }
  result.push({
    prop: &#039;-ms-grid-column&#039;,
    value: String(area.column.start)
  })
  if (area.column.span &gt; 1 || addColumnSpan) {
    result.push({
      prop: &#039;-ms-grid-column-span&#039;,
      value: String(area.column.span)
    })
  }
  return result
}

function getParentMedia(parent) {
  if (parent.type === &#039;atrule&#039; &amp;&amp; parent.name === &#039;media&#039;) {
    return parent
  }
  if (!parent.parent) {
    return false
  }
  return getParentMedia(parent.parent)
}

/**
 * change selectors for rules with duplicate grid-areas.
 * @param  {Array&lt;Rule&gt;} rules
 * @param  {Array&lt;String&gt;} templateSelectors
 * @return {Array&lt;Rule&gt;} rules with changed selectors
 */
function changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {
  ruleSelectors = ruleSelectors.map(selector =&gt; {
    let selectorBySpace = list.space(selector)
    let selectorByComma = list.comma(selector)

    if (selectorBySpace.length &gt; selectorByComma.length) {
      selector = selectorBySpace.slice(-1).join(&#039;&#039;)
    }
    return selector
  })

  return ruleSelectors.map(ruleSelector =&gt; {
    let newSelector = templateSelectors.map((tplSelector, index) =&gt; {
      let space = index === 0 ? &#039;&#039; : &#039; &#039;
      return `${space}${tplSelector} &gt; ${ruleSelector}`
    })

    return newSelector
  })
}

/**
 * check if selector of rules are equal
 * @param  {Rule} ruleA
 * @param  {Rule} ruleB
 * @return {Boolean}
 */
function selectorsEqual(ruleA, ruleB) {
  return ruleA.selectors.some(sel =&gt; {
    return ruleB.selectors.includes(sel)
  })
}

/**
 * Parse data from all grid-template(-areas) declarations
 * @param  {Root} css css root
 * @return {Object} parsed data
 */
function parseGridTemplatesData(css) {
  let parsed = []

  // we walk through every grid-template(-areas) declaration and store
  // data with the same area names inside the item
  css.walkDecls(/grid-template(-areas)?$/, d =&gt; {
    let rule = d.parent
    let media = getParentMedia(rule)
    let gap = getGridGap(d)
    let inheritedGap = inheritGridGap(d, gap)
    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })
    let areaNames = Object.keys(areas)

    // skip node if it doesn&#039;t have areas
    if (areaNames.length === 0) {
      return true
    }

    // check parsed array for item that include the same area names
    // return index of that item
    let index = parsed.reduce((acc, { allAreas }, idx) =&gt; {
      let hasAreas = allAreas &amp;&amp; areaNames.some(area =&gt; allAreas.includes(area))
      return hasAreas ? idx : acc
    }, null)

    if (index !== null) {
      // index is found, add the grid-template data to that item
      let { allAreas, rules } = parsed[index]

      // check if rule has no duplicate area names
      let hasNoDuplicates = rules.some(r =&gt; {
        return r.hasDuplicates === false &amp;&amp; selectorsEqual(r, rule)
      })

      let duplicatesFound = false

      // check need to gather all duplicate area names
      let duplicateAreaNames = rules.reduce((acc, r) =&gt; {
        if (!r.params &amp;&amp; selectorsEqual(r, rule)) {
          duplicatesFound = true
          return r.duplicateAreaNames
        }
        if (!duplicatesFound) {
          areaNames.forEach(name =&gt; {
            if (r.areas[name]) {
              acc.push(name)
            }
          })
        }
        return uniq(acc)
      }, [])

      // update grid-row/column-span values for areas with duplicate
      // area names. @see #1084 and #1146
      rules.forEach(r =&gt; {
        areaNames.forEach(name =&gt; {
          let area = r.areas[name]
          if (area &amp;&amp; area.row.span !== areas[name].row.span) {
            areas[name].row.updateSpan = true
          }

          if (area &amp;&amp; area.column.span !== areas[name].column.span) {
            areas[name].column.updateSpan = true
          }
        })
      })

      parsed[index].allAreas = uniq([...allAreas, ...areaNames])
      parsed[index].rules.push({
        areas,
        duplicateAreaNames,
        hasDuplicates: !hasNoDuplicates,
        node: rule,
        params: media.params,
        selectors: rule.selectors
      })
    } else {
      // index is NOT found, push the new item to the parsed array
      parsed.push({
        allAreas: areaNames,
        areasCount: 0,
        rules: [
          {
            areas,
            duplicateAreaNames: [],
            duplicateRules: [],
            hasDuplicates: false,
            node: rule,
            params: media.params,
            selectors: rule.selectors
          }
        ]
      })
    }

    return undefined
  })

  return parsed
}

/**
 * insert prefixed grid-area declarations
 * @param  {Root}  css css root
 * @param  {Function} isDisabled check if the rule is disabled
 * @return {void}
 */
exports.insertAreas = insertAreas

function insertAreas(css, isDisabled) {
  // parse grid-template declarations
  let gridTemplatesData = parseGridTemplatesData(css)

  // return undefined if no declarations found
  if (gridTemplatesData.length === 0) {
    return undefined
  }

  // we need to store the rules that we will insert later
  let rulesToInsert = {}

  css.walkDecls(&#039;grid-area&#039;, gridArea =&gt; {
    let gridAreaRule = gridArea.parent
    let hasPrefixedRow = gridAreaRule.first.prop === &#039;-ms-grid-row&#039;
    let gridAreaMedia = getParentMedia(gridAreaRule)

    if (isDisabled(gridArea)) {
      return undefined
    }

    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)

    let value = gridArea.value
    // found the data that matches grid-area identifier
    let data = gridTemplatesData.filter(d =&gt; d.allAreas.includes(value))[0]

    if (!data) {
      return true
    }

    let lastArea = data.allAreas[data.allAreas.length - 1]
    let selectorBySpace = list.space(gridAreaRule.selector)
    let selectorByComma = list.comma(gridAreaRule.selector)
    let selectorIsComplex =
      selectorBySpace.length &gt; 1 &amp;&amp;
      selectorBySpace.length &gt; selectorByComma.length

    // prevent doubling of prefixes
    if (hasPrefixedRow) {
      return false
    }

    // create the empty object with the key as the last area name
    // e.g if we have templates with &quot;a b c&quot; values, &quot;c&quot; will be the last area
    if (!rulesToInsert[lastArea]) {
      rulesToInsert[lastArea] = {}
    }

    let lastRuleIsSet = false

    // walk through every grid-template rule data
    for (let rule of data.rules) {
      let area = rule.areas[value]
      let hasDuplicateName = rule.duplicateAreaNames.includes(value)

      // if we can&#039;t find the area name, update lastRule and continue
      if (!area) {
        let lastRule = rulesToInsert[lastArea].lastRule
        let lastRuleIndex
        if (lastRule) {
          lastRuleIndex = css.index(lastRule)
        } else {
          /* c8 ignore next 2 */
          lastRuleIndex = -1
        }

        if (gridAreaRuleIndex &gt; lastRuleIndex) {
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
        }
        continue
      }

      // for grid-templates inside media rule we need to create empty
      // array to push prefixed grid-area rules later
      if (rule.params &amp;&amp; !rulesToInsert[lastArea][rule.params]) {
        rulesToInsert[lastArea][rule.params] = []
      }

      if ((!rule.hasDuplicates || !hasDuplicateName) &amp;&amp; !rule.params) {
        // grid-template has no duplicates and not inside media rule

        getMSDecls(area, false, false)
          .reverse()
          .forEach(i =&gt;
            gridAreaRule.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        rulesToInsert[lastArea].lastRule = gridAreaRule
        lastRuleIsSet = true
      } else if (rule.hasDuplicates &amp;&amp; !rule.params &amp;&amp; !selectorIsComplex) {
        // grid-template has duplicates and not inside media rule
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =&gt;
            cloned.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        cloned.selectors = changeDuplicateAreaSelectors(
          cloned.selectors,
          rule.selectors
        )

        if (rulesToInsert[lastArea].lastRule) {
          rulesToInsert[lastArea].lastRule.after(cloned)
        }
        rulesToInsert[lastArea].lastRule = cloned
        lastRuleIsSet = true
      } else if (
        rule.hasDuplicates &amp;&amp;
        !rule.params &amp;&amp;
        selectorIsComplex &amp;&amp;
        gridAreaRule.selector.includes(rule.selectors[0])
      ) {
        // grid-template has duplicates and not inside media rule
        // and the selector is complex
        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d =&gt; d.remove())
        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =&gt;
            gridAreaRule.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )
      } else if (rule.params) {
        // grid-template is inside media rule
        // if we&#039;re inside media rule, we need to store prefixed rules
        // inside rulesToInsert object to be able to preserve the order of media
        // rules and merge them easily
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =&gt;
            cloned.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        if (rule.hasDuplicates &amp;&amp; hasDuplicateName) {
          cloned.selectors = changeDuplicateAreaSelectors(
            cloned.selectors,
            rule.selectors
          )
        }

        cloned.raws = rule.node.raws

        if (css.index(rule.node.parent) &gt; gridAreaRuleIndex) {
          // append the prefixed rules right inside media rule
          // with grid-template
          rule.node.parent.append(cloned)
        } else {
          // store the rule to insert later
          rulesToInsert[lastArea][rule.params].push(cloned)
        }

        // set new rule as last rule ONLY if we didn&#039;t set lastRule for
        // this grid-area before
        if (!lastRuleIsSet) {
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
        }
      }
    }

    return undefined
  })

  // append stored rules inside the media rules
  Object.keys(rulesToInsert).forEach(area =&gt; {
    let data = rulesToInsert[area]
    let lastRule = data.lastRule
    Object.keys(data)
      .reverse()
      .filter(p =&gt; p !== &#039;lastRule&#039;)
      .forEach(params =&gt; {
        if (data[params].length &gt; 0 &amp;&amp; lastRule) {
          lastRule.after({ name: &#039;media&#039;, params })
          lastRule.next().append(data[params])
        }
      })
  })

  return undefined
}

/**
 * Warn user if grid area identifiers are not found
 * @param  {Object} areas
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnMissedAreas = warnMissedAreas

function warnMissedAreas(areas, decl, result) {
  let missed = Object.keys(areas)

  decl.root().walkDecls(&#039;grid-area&#039;, gridArea =&gt; {
    missed = missed.filter(e =&gt; e !== gridArea.value)
  })

  if (missed.length &gt; 0) {
    decl.warn(result, &#039;Can not find grid areas: &#039; + missed.join(&#039;, &#039;))
  }

  return undefined
}

/**
 * compare selectors with grid-area rule and grid-template rule
 * show warning if grid-template selector is not found
 * (this function used for grid-area rule)
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound

function warnTemplateSelectorNotFound(decl, result) {
  let rule = decl.parent
  let root = decl.root()
  let duplicatesFound = false

  // slice selector array. Remove the last part (for comparison)
  let slicedSelectorArr = list
    .space(rule.selector)
    .filter(str =&gt; str !== &#039;&gt;&#039;)
    .slice(0, -1)

  // we need to compare only if selector is complex.
  // e.g &#039;.grid-cell&#039; is simple, but &#039;.parent &gt; .grid-cell&#039; is complex
  if (slicedSelectorArr.length &gt; 0) {
    let gridTemplateFound = false
    let foundAreaSelector = null

    root.walkDecls(/grid-template(-areas)?$/, d =&gt; {
      let parent = d.parent
      let templateSelectors = parent.selectors

      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) })
      let hasArea = areas[decl.value]

      // find the the matching selectors
      for (let tplSelector of templateSelectors) {
        if (gridTemplateFound) {
          break
        }
        let tplSelectorArr = list.space(tplSelector).filter(str =&gt; str !== &#039;&gt;&#039;)

        gridTemplateFound = tplSelectorArr.every(
          (item, idx) =&gt; item === slicedSelectorArr[idx]
        )
      }

      if (gridTemplateFound || !hasArea) {
        return true
      }

      if (!foundAreaSelector) {
        foundAreaSelector = parent.selector
      }

      // if we found the duplicate area with different selector
      if (foundAreaSelector &amp;&amp; foundAreaSelector !== parent.selector) {
        duplicatesFound = true
      }

      return undefined
    })

    // warn user if we didn&#039;t find template
    if (!gridTemplateFound &amp;&amp; duplicatesFound) {
      decl.warn(
        result,
        &#039;Autoprefixer cannot find a grid-template &#039; +
          `containing the duplicate grid-area &quot;${decl.value}&quot; ` +
          `with full selector matching: ${slicedSelectorArr.join(&#039; &#039;)}`
      )
    }
  }
}

/**
 * warn user if both grid-area and grid-(row|column)
 * declarations are present in the same rule
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnIfGridRowColumnExists = warnIfGridRowColumnExists

function warnIfGridRowColumnExists(decl, result) {
  let rule = decl.parent
  let decls = []
  rule.walkDecls(/^grid-(row|column)/, d =&gt; {
    if (
      !d.prop.endsWith(&#039;-end&#039;) &amp;&amp;
      !d.value.startsWith(&#039;span&#039;) &amp;&amp;
      !d.prop.endsWith(&#039;-gap&#039;)
    ) {
      decls.push(d)
    }
  })
  if (decls.length &gt; 0) {
    decls.forEach(d =&gt; {
      d.warn(
        result,
        &#039;You already have a grid-area declaration present in the rule. &#039; +
          `You should use either grid-area or ${d.prop}, not both`
      )
    })
  }

  return undefined
}

// Gap utils

exports.getGridGap = getGridGap

function getGridGap(decl) {
  let gap = {}

  // try to find gap
  let testGap = /^(grid-)?((row|column)-)?gap$/
  decl.parent.walkDecls(testGap, ({ prop, value }) =&gt; {
    if (/^(grid-)?gap$/.test(prop)) {
      let [row, , column] = parser(value).nodes

      gap.row = row &amp;&amp; parser.stringify(row)
      gap.column = column ? parser.stringify(column) : gap.row
    }
    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value
    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value
  })

  return gap
}

/**
 * parse media parameters (for example &#039;min-width: 500px&#039;)
 * @param  {String} params parameter to parse
 * @return {}
 */
function parseMediaParams(params) {
  if (!params) {
    return []
  }
  let parsed = parser(params)
  let prop
  let value

  parsed.walk(node =&gt; {
    if (node.type === &#039;word&#039; &amp;&amp; /min|max/g.test(node.value)) {
      prop = node.value
    } else if (node.value.includes(&#039;px&#039;)) {
      value = parseInt(node.value.replace(/\D/g, &#039;&#039;))
    }
  })

  return [prop, value]
}

/**
 * Compare the selectors and decide if we
 * need to inherit gap from compared selector or not.
 * @type {String} selA
 * @type {String} selB
 * @return {Boolean}
 */
function shouldInheritGap(selA, selB) {
  let result

  // get arrays of selector split in 3-deep array
  let splitSelectorArrA = splitSelector(selA)
  let splitSelectorArrB = splitSelector(selB)

  if (splitSelectorArrA[0].length &lt; splitSelectorArrB[0].length) {
    // abort if selectorA has lower descendant specificity then selectorB
    // (e.g &#039;.grid&#039; and &#039;.hello .world .grid&#039;)
    return false
  } else if (splitSelectorArrA[0].length &gt; splitSelectorArrB[0].length) {
    // if selectorA has higher descendant specificity then selectorB
    // (e.g &#039;.foo .bar .grid&#039; and &#039;.grid&#039;)

    let idx = splitSelectorArrA[0].reduce((res, [item], index) =&gt; {
      let firstSelectorPart = splitSelectorArrB[0][0][0]
      if (item === firstSelectorPart) {
        return index
      }
      return false
    }, false)

    if (idx) {
      result = splitSelectorArrB[0].every((arr, index) =&gt; {
        return arr.every(
          (part, innerIndex) =&gt;
            // because selectorA has more space elements, we need to slice
            // selectorA array by &#039;idx&#039; number to compare them
            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part
        )
      })
    }
  } else {
    // if selectorA has the same descendant specificity as selectorB
    // this condition covers cases such as: &#039;.grid.foo.bar&#039; and &#039;.grid&#039;
    result = splitSelectorArrB.some(byCommaArr =&gt; {
      return byCommaArr.every((bySpaceArr, index) =&gt; {
        return bySpaceArr.every(
          (part, innerIndex) =&gt; splitSelectorArrA[0][index][innerIndex] === part
        )
      })
    })
  }

  return result
}
/**
 * inherit grid gap values from the closest rule above
 * with the same selector
 * @param  {Declaration} decl
 * @param  {Object} gap gap values
 * @return {Object | Boolean} return gap values or false (if not found)
 */
exports.inheritGridGap = inheritGridGap

function inheritGridGap(decl, gap) {
  let rule = decl.parent
  let mediaRule = getParentMedia(rule)
  let root = rule.root()

  // get an array of selector split in 3-deep array
  let splitSelectorArr = splitSelector(rule.selector)

  // abort if the rule already has gaps
  if (Object.keys(gap).length &gt; 0) {
    return false
  }

  // e.g [&#039;min-width&#039;]
  let [prop] = parseMediaParams(mediaRule.params)

  let lastBySpace = splitSelectorArr[0]

  // get escaped value from the selector
  // if we have &#039;.grid-2.foo.bar&#039; selector, will be &#039;\.grid\-2&#039;
  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])

  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`)

  // find the closest rule with the same selector
  let closestRuleGap
  root.walkRules(regexp, r =&gt; {
    let gridGap

    // abort if are checking the same rule
    if (rule.toString() === r.toString()) {
      return false
    }

    // find grid-gap values
    r.walkDecls(&#039;grid-gap&#039;, d =&gt; (gridGap = getGridGap(d)))

    // skip rule without gaps
    if (!gridGap || Object.keys(gridGap).length === 0) {
      return true
    }

    // skip rules that should not be inherited from
    if (!shouldInheritGap(rule.selector, r.selector)) {
      return true
    }

    let media = getParentMedia(r)
    if (media) {
      // if we are inside media, we need to check that media props match
      // e.g (&#039;min-width&#039; === &#039;min-width&#039;)
      let propToCompare = parseMediaParams(media.params)[0]
      if (propToCompare === prop) {
        closestRuleGap = gridGap
        return true
      }
    } else {
      closestRuleGap = gridGap
      return true
    }

    return undefined
  })

  // if we find the closest gap object
  if (closestRuleGap &amp;&amp; Object.keys(closestRuleGap).length &gt; 0) {
    return closestRuleGap
  }
  return false
}

exports.warnGridGap = warnGridGap

function warnGridGap({ decl, gap, hasColumns, result }) {
  let hasBothGaps = gap.row &amp;&amp; gap.column
  if (!hasColumns &amp;&amp; (hasBothGaps || (gap.column &amp;&amp; !gap.row))) {
    delete gap.column
    decl.warn(
      result,
      &#039;Can not implement grid-gap without grid-template-columns&#039;
    )
  }
}

/**
 * normalize the grid-template-rows/columns values
 * @param  {String} str grid-template-rows/columns value
 * @return {Array} normalized array with values
 * @example
 * let normalized = normalizeRowColumn(&#039;1fr repeat(2, 20px 50px) 1fr&#039;)
 * normalized // &lt;= [&#039;1fr&#039;, &#039;20px&#039;, &#039;50px&#039;, &#039;20px&#039;, &#039;50px&#039;, &#039;1fr&#039;]
 */
function normalizeRowColumn(str) {
  let normalized = parser(str).nodes.reduce((result, node) =&gt; {
    if (node.type === &#039;function&#039; &amp;&amp; node.value === &#039;repeat&#039;) {
      let key = &#039;count&#039;

      let [count, value] = node.nodes.reduce(
        (acc, n) =&gt; {
          if (n.type === &#039;word&#039; &amp;&amp; key === &#039;count&#039;) {
            acc[0] = Math.abs(parseInt(n.value))
            return acc
          }
          if (n.type === &#039;div&#039; &amp;&amp; n.value === &#039;,&#039;) {
            key = &#039;value&#039;
            return acc
          }
          if (key === &#039;value&#039;) {
            acc[1] += parser.stringify(n)
          }
          return acc
        },
        [0, &#039;&#039;]
      )

      if (count) {
        for (let i = 0; i &lt; count; i++) {
          result.push(value)
        }
      }

      return result
    }
    if (node.type === &#039;space&#039;) {
      return result
    }
    return result.concat(parser.stringify(node))
  }, [])

  return normalized
}

exports.autoplaceGridItems = autoplaceGridItems

/**
 * Autoplace grid items
 * @param {Declaration} decl
 * @param {Result} result
 * @param {Object} gap gap values
 * @param {String} autoflowValue grid-auto-flow value
 * @return {void}
 * @see https://github.com/postcss/autoprefixer/issues/1148
 */
function autoplaceGridItems(decl, result, gap, autoflowValue = &#039;row&#039;) {
  let { parent } = decl

  let rowDecl = parent.nodes.find(i =&gt; i.prop === &#039;grid-template-rows&#039;)
  let rows = normalizeRowColumn(rowDecl.value)
  let columns = normalizeRowColumn(decl.value)

  // Build array of area names with dummy values. If we have 3 columns and
  // 2 rows, filledRows will be equal to [&#039;1 2 3&#039;, &#039;4 5 6&#039;]
  let filledRows = rows.map((_, rowIndex) =&gt; {
    return Array.from(
      { length: columns.length },
      (v, k) =&gt; k + rowIndex * columns.length + 1
    ).join(&#039; &#039;)
  })

  let areas = parseGridAreas({ gap, rows: filledRows })
  let keys = Object.keys(areas)
  let items = keys.map(i =&gt; areas[i])

  // Change the order of cells if grid-auto-flow value is &#039;column&#039;
  if (autoflowValue.includes(&#039;column&#039;)) {
    items = items.sort((a, b) =&gt; a.column.start - b.column.start)
  }

  // Insert new rules
  items.reverse().forEach((item, index) =&gt; {
    let { column, row } = item
    let nodeSelector = parent.selectors
      .map(sel =&gt; sel + ` &gt; *:nth-child(${keys.length - index})`)
      .join(&#039;, &#039;)

    // create new rule
    let node = parent.clone().removeAll()

    // change rule selector
    node.selector = nodeSelector

    // insert prefixed row/column values
    node.append({ prop: &#039;-ms-grid-row&#039;, value: row.start })
    node.append({ prop: &#039;-ms-grid-column&#039;, value: column.start })

    // insert rule
    parent.after(node)
  })

  return undefined
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
