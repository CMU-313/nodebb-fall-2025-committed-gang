<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodemailer/lib/smtp-pool/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodemailer/lib/smtp-pool/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">649</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">81.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const EventEmitter = require(&#039;events&#039;);
const PoolResource = require(&#039;./pool-resource&#039;);
const SMTPConnection = require(&#039;../smtp-connection&#039;);
const wellKnown = require(&#039;../well-known&#039;);
const shared = require(&#039;../shared&#039;);
const packageData = require(&#039;../../package.json&#039;);

/**
 * Creates a SMTP pool transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options SMTP Connection options
 */
class SMTPPool extends EventEmitter {
    constructor(options) {
        super();

        options = options || {};
        if (typeof options === &#039;string&#039;) {
            options = {
                url: options
            };
        }

        let urlData;
        let service = options.service;

        if (typeof options.getSocket === &#039;function&#039;) {
            this.getSocket = options.getSocket;
        }

        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }

        this.options = shared.assign(
            false, // create new object
            options, // regular options
            urlData, // url options
            service &amp;&amp; wellKnown(service) // wellknown options
        );

        this.options.maxConnections = this.options.maxConnections || 5;
        this.options.maxMessages = this.options.maxMessages || 100;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || &#039;smtp-pool&#039;
        });

        // temporary object
        let connection = new SMTPConnection(this.options);

        this.name = &#039;SMTP (pool)&#039;;
        this.version = packageData.version + &#039;[client:&#039; + connection.version + &#039;]&#039;;

        this._rateLimit = {
            counter: 0,
            timeout: null,
            waiting: [],
            checkpoint: false,
            delta: Number(this.options.rateDelta) || 1000,
            limit: Number(this.options.rateLimit) || 0
        };
        this._closed = false;
        this._queue = [];
        this._connections = [];
        this._connectionCounter = 0;

        this.idling = true;

        setImmediate(() =&gt; {
            if (this.idling) {
                this.emit(&#039;idle&#039;);
            }
        });
    }

    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */
    getSocket(options, callback) {
        // return immediatelly
        return setImmediate(() =&gt; callback(null, false));
    }

    /**
     * Queues an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
        if (this._closed) {
            return false;
        }

        this._queue.push({
            mail,
            requeueAttempts: 0,
            callback
        });

        if (this.idling &amp;&amp; this._queue.length &gt;= this.options.maxConnections) {
            this.idling = false;
        }

        setImmediate(() =&gt; this._processMessages());

        return true;
    }

    /**
     * Closes all connections in the pool. If there is a message being sent, the connection
     * is closed later
     */
    close() {
        let connection;
        let len = this._connections.length;
        this._closed = true;

        // clear rate limit timer if it exists
        clearTimeout(this._rateLimit.timeout);

        if (!len &amp;&amp; !this._queue.length) {
            return;
        }

        // remove all available connections
        for (let i = len - 1; i &gt;= 0; i--) {
            if (this._connections[i] &amp;&amp; this._connections[i].available) {
                connection = this._connections[i];
                connection.close();
                this.logger.info(
                    {
                        tnx: &#039;connection&#039;,
                        cid: connection.id,
                        action: &#039;removed&#039;
                    },
                    &#039;Connection #%s removed&#039;,
                    connection.id
                );
            }
        }

        if (len &amp;&amp; !this._connections.length) {
            this.logger.debug(
                {
                    tnx: &#039;connection&#039;
                },
                &#039;All connections removed&#039;
            );
        }

        if (!this._queue.length) {
            return;
        }

        // make sure that entire queue would be cleaned
        let invokeCallbacks = () =&gt; {
            if (!this._queue.length) {
                this.logger.debug(
                    {
                        tnx: &#039;connection&#039;
                    },
                    &#039;Pending queue entries cleared&#039;
                );
                return;
            }
            let entry = this._queue.shift();
            if (entry &amp;&amp; typeof entry.callback === &#039;function&#039;) {
                try {
                    entry.callback(new Error(&#039;Connection pool was closed&#039;));
                } catch (E) {
                    this.logger.error(
                        {
                            err: E,
                            tnx: &#039;callback&#039;,
                            cid: connection.id
                        },
                        &#039;Callback error for #%s: %s&#039;,
                        connection.id,
                        E.message
                    );
                }
            }
            setImmediate(invokeCallbacks);
        };
        setImmediate(invokeCallbacks);
    }

    /**
     * Check the queue and available connections. If there is a message to be sent and there is
     * an available connection, then use this connection to send the mail
     */
    _processMessages() {
        let connection;
        let i, len;

        // do nothing if already closed
        if (this._closed) {
            return;
        }

        // do nothing if queue is empty
        if (!this._queue.length) {
            if (!this.idling) {
                // no pending jobs
                this.idling = true;
                this.emit(&#039;idle&#039;);
            }
            return;
        }

        // find first available connection
        for (i = 0, len = this._connections.length; i &lt; len; i++) {
            if (this._connections[i].available) {
                connection = this._connections[i];
                break;
            }
        }

        if (!connection &amp;&amp; this._connections.length &lt; this.options.maxConnections) {
            connection = this._createConnection();
        }

        if (!connection) {
            // no more free connection slots available
            this.idling = false;
            return;
        }

        // check if there is free space in the processing queue
        if (!this.idling &amp;&amp; this._queue.length &lt; this.options.maxConnections) {
            this.idling = true;
            this.emit(&#039;idle&#039;);
        }

        let entry = (connection.queueEntry = this._queue.shift());
        entry.messageId = (connection.queueEntry.mail.message.getHeader(&#039;message-id&#039;) || &#039;&#039;).replace(/[&lt;&gt;\s]/g, &#039;&#039;);

        connection.available = false;

        this.logger.debug(
            {
                tnx: &#039;pool&#039;,
                cid: connection.id,
                messageId: entry.messageId,
                action: &#039;assign&#039;
            },
            &#039;Assigned message &lt;%s&gt; to #%s (%s)&#039;,
            entry.messageId,
            connection.id,
            connection.messages + 1
        );

        if (this._rateLimit.limit) {
            this._rateLimit.counter++;
            if (!this._rateLimit.checkpoint) {
                this._rateLimit.checkpoint = Date.now();
            }
        }

        connection.send(entry.mail, (err, info) =&gt; {
            // only process callback if current handler is not changed
            if (entry === connection.queueEntry) {
                try {
                    entry.callback(err, info);
                } catch (E) {
                    this.logger.error(
                        {
                            err: E,
                            tnx: &#039;callback&#039;,
                            cid: connection.id
                        },
                        &#039;Callback error for #%s: %s&#039;,
                        connection.id,
                        E.message
                    );
                }
                connection.queueEntry = false;
            }
        });
    }

    /**
     * Creates a new pool resource
     */
    _createConnection() {
        let connection = new PoolResource(this);

        connection.id = ++this._connectionCounter;

        this.logger.info(
            {
                tnx: &#039;pool&#039;,
                cid: connection.id,
                action: &#039;conection&#039;
            },
            &#039;Created new pool resource #%s&#039;,
            connection.id
        );

        // resource comes available
        connection.on(&#039;available&#039;, () =&gt; {
            this.logger.debug(
                {
                    tnx: &#039;connection&#039;,
                    cid: connection.id,
                    action: &#039;available&#039;
                },
                &#039;Connection #%s became available&#039;,
                connection.id
            );

            if (this._closed) {
                // if already closed run close() that will remove this connections from connections list
                this.close();
            } else {
                // check if there&#039;s anything else to send
                this._processMessages();
            }
        });

        // resource is terminated with an error
        connection.once(&#039;error&#039;, err =&gt; {
            if (err.code !== &#039;EMAXLIMIT&#039;) {
                this.logger.error(
                    {
                        err,
                        tnx: &#039;pool&#039;,
                        cid: connection.id
                    },
                    &#039;Pool Error for #%s: %s&#039;,
                    connection.id,
                    err.message
                );
            } else {
                this.logger.debug(
                    {
                        tnx: &#039;pool&#039;,
                        cid: connection.id,
                        action: &#039;maxlimit&#039;
                    },
                    &#039;Max messages limit exchausted for #%s&#039;,
                    connection.id
                );
            }

            if (connection.queueEntry) {
                try {
                    connection.queueEntry.callback(err);
                } catch (E) {
                    this.logger.error(
                        {
                            err: E,
                            tnx: &#039;callback&#039;,
                            cid: connection.id
                        },
                        &#039;Callback error for #%s: %s&#039;,
                        connection.id,
                        E.message
                    );
                }
                connection.queueEntry = false;
            }

            // remove the erroneus connection from connections list
            this._removeConnection(connection);

            this._continueProcessing();
        });

        connection.once(&#039;close&#039;, () =&gt; {
            this.logger.info(
                {
                    tnx: &#039;connection&#039;,
                    cid: connection.id,
                    action: &#039;closed&#039;
                },
                &#039;Connection #%s was closed&#039;,
                connection.id
            );

            this._removeConnection(connection);

            if (connection.queueEntry) {
                // If the connection closed when sending, add the message to the queue again
                // if max number of requeues is not reached yet
                // Note that we must wait a bit.. because the callback of the &#039;error&#039; handler might be called
                // in the next event loop
                setTimeout(() =&gt; {
                    if (connection.queueEntry) {
                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                            this._requeueEntryOnConnectionClose(connection);
                        } else {
                            this._failDeliveryOnConnectionClose(connection);
                        }
                    }
                    this._continueProcessing();
                }, 50);
            } else {
                this._continueProcessing();
            }
        });

        this._connections.push(connection);

        return connection;
    }

    _shouldRequeuOnConnectionClose(queueEntry) {
        if (this.options.maxRequeues === undefined || this.options.maxRequeues &lt; 0) {
            return true;
        }

        return queueEntry.requeueAttempts &lt; this.options.maxRequeues;
    }

    _failDeliveryOnConnectionClose(connection) {
        if (connection.queueEntry &amp;&amp; connection.queueEntry.callback) {
            try {
                connection.queueEntry.callback(new Error(&#039;Reached maximum number of retries after connection was closed&#039;));
            } catch (E) {
                this.logger.error(
                    {
                        err: E,
                        tnx: &#039;callback&#039;,
                        messageId: connection.queueEntry.messageId,
                        cid: connection.id
                    },
                    &#039;Callback error for #%s: %s&#039;,
                    connection.id,
                    E.message
                );
            }
            connection.queueEntry = false;
        }
    }

    _requeueEntryOnConnectionClose(connection) {
        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
        this.logger.debug(
            {
                tnx: &#039;pool&#039;,
                cid: connection.id,
                messageId: connection.queueEntry.messageId,
                action: &#039;requeue&#039;
            },
            &#039;Re-queued message &lt;%s&gt; for #%s. Attempt: #%s&#039;,
            connection.queueEntry.messageId,
            connection.id,
            connection.queueEntry.requeueAttempts
        );
        this._queue.unshift(connection.queueEntry);
        connection.queueEntry = false;
    }

    /**
     * Continue to process message if the pool hasn&#039;t closed
     */
    _continueProcessing() {
        if (this._closed) {
            this.close();
        } else {
            setTimeout(() =&gt; this._processMessages(), 100);
        }
    }

    /**
     * Remove resource from pool
     *
     * @param {Object} connection The PoolResource to remove
     */
    _removeConnection(connection) {
        let index = this._connections.indexOf(connection);

        if (index !== -1) {
            this._connections.splice(index, 1);
        }
    }

    /**
     * Checks if connections have hit current rate limit and if so, queues the availability callback
     *
     * @param {Function} callback Callback function to run once rate limiter has been cleared
     */
    _checkRateLimit(callback) {
        if (!this._rateLimit.limit) {
            return callback();
        }

        let now = Date.now();

        if (this._rateLimit.counter &lt; this._rateLimit.limit) {
            return callback();
        }

        this._rateLimit.waiting.push(callback);

        if (this._rateLimit.checkpoint &lt;= now - this._rateLimit.delta) {
            return this._clearRateLimit();
        } else if (!this._rateLimit.timeout) {
            this._rateLimit.timeout = setTimeout(() =&gt; this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
            this._rateLimit.checkpoint = now;
        }
    }

    /**
     * Clears current rate limit limitation and runs paused callback
     */
    _clearRateLimit() {
        clearTimeout(this._rateLimit.timeout);
        this._rateLimit.timeout = null;
        this._rateLimit.counter = 0;
        this._rateLimit.checkpoint = false;

        // resume all paused connections
        while (this._rateLimit.waiting.length) {
            let cb = this._rateLimit.waiting.shift();
            setImmediate(cb);
        }
    }

    /**
     * Returns true if there are free slots in the queue
     */
    isIdle() {
        return this.idling;
    }

    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
        let promise;

        if (!callback) {
            promise = new Promise((resolve, reject) =&gt; {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        let auth = new PoolResource(this).auth;

        this.getSocket(this.options, (err, socketOptions) =&gt; {
            if (err) {
                return callback(err);
            }

            let options = this.options;
            if (socketOptions &amp;&amp; socketOptions.connection) {
                this.logger.info(
                    {
                        tnx: &#039;proxy&#039;,
                        remoteAddress: socketOptions.connection.remoteAddress,
                        remotePort: socketOptions.connection.remotePort,
                        destHost: options.host || &#039;&#039;,
                        destPort: options.port || &#039;&#039;,
                        action: &#039;connected&#039;
                    },
                    &#039;Using proxied socket from %s:%s to %s:%s&#039;,
                    socketOptions.connection.remoteAddress,
                    socketOptions.connection.remotePort,
                    options.host || &#039;&#039;,
                    options.port || &#039;&#039;
                );
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach(key =&gt; {
                    options[key] = socketOptions[key];
                });
            }

            let connection = new SMTPConnection(options);
            let returned = false;

            connection.once(&#039;error&#039;, err =&gt; {
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });

            connection.once(&#039;end&#039;, () =&gt; {
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error(&#039;Connection closed&#039;));
            });

            let finalize = () =&gt; {
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };

            connection.connect(() =&gt; {
                if (returned) {
                    return;
                }

                if (auth &amp;&amp; (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, err =&gt; {
                        if (returned) {
                            return;
                        }

                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }

                        finalize();
                    });
                } else if (!auth &amp;&amp; connection.allowsAuth &amp;&amp; options.forceAuth) {
                    let err = new Error(&#039;Authentication info was not provided&#039;);
                    err.code = &#039;NoAuth&#039;;

                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });

        return promise;
    }
}

// expose to the world
module.exports = SMTPPool;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
