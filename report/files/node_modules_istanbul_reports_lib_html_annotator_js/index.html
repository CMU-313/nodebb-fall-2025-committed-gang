<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/istanbul-reports/lib/html/annotator.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/istanbul-reports/lib/html/annotator.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">306</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">55.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.60</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
&#039;use strict&#039;;

const InsertionText = require(&#039;./insertion-text&#039;);
const lt = &#039;\u0001&#039;;
const gt = &#039;\u0002&#039;;
const RE_LT = /&lt;/g;
const RE_GT = /&gt;/g;
const RE_AMP = /&amp;/g;
// eslint-disable-next-line
var RE_lt = /\u0001/g;
// eslint-disable-next-line
var RE_gt = /\u0002/g;

function title(str) {
    return &#039; title=&quot;&#039; + str + &#039;&quot; &#039;;
}

function customEscape(text) {
    text = String(text);
    return text
        .replace(RE_AMP, &#039;&amp;amp;&#039;)
        .replace(RE_LT, &#039;&amp;lt;&#039;)
        .replace(RE_GT, &#039;&amp;gt;&#039;)
        .replace(RE_lt, &#039;&lt;&#039;)
        .replace(RE_gt, &#039;&gt;&#039;);
}

function annotateLines(fileCoverage, structuredText) {
    const lineStats = fileCoverage.getLineCoverage();
    if (!lineStats) {
        return;
    }
    Object.entries(lineStats).forEach(([lineNumber, count]) =&gt; {
        if (structuredText[lineNumber]) {
            structuredText[lineNumber].covered = count &gt; 0 ? &#039;yes&#039; : &#039;no&#039;;
            structuredText[lineNumber].hits = count;
        }
    });
}

function annotateStatements(fileCoverage, structuredText) {
    const statementStats = fileCoverage.s;
    const statementMeta = fileCoverage.statementMap;
    Object.entries(statementStats).forEach(([stName, count]) =&gt; {
        const meta = statementMeta[stName];
        const type = count &gt; 0 ? &#039;yes&#039; : &#039;no&#039;;
        const startCol = meta.start.column;
        let endCol = meta.end.column + 1;
        const startLine = meta.start.line;
        const endLine = meta.end.line;
        const openSpan =
            lt +
            &#039;span class=&quot;&#039; +
            (meta.skip ? &#039;cstat-skip&#039; : &#039;cstat-no&#039;) +
            &#039;&quot;&#039; +
            title(&#039;statement not covered&#039;) +
            gt;
        const closeSpan = lt + &#039;/span&#039; + gt;
        let text;

        if (type === &#039;no&#039; &amp;&amp; structuredText[startLine]) {
            if (endLine !== startLine) {
                endCol = structuredText[startLine].text.originalLength();
            }
            text = structuredText[startLine].text;
            text.wrap(
                startCol,
                openSpan,
                startCol &lt; endCol ? endCol : text.originalLength(),
                closeSpan
            );
        }
    });
}

function annotateFunctions(fileCoverage, structuredText) {
    const fnStats = fileCoverage.f;
    const fnMeta = fileCoverage.fnMap;
    if (!fnStats) {
        return;
    }
    Object.entries(fnStats).forEach(([fName, count]) =&gt; {
        const meta = fnMeta[fName];
        const type = count &gt; 0 ? &#039;yes&#039; : &#039;no&#039;;
        // Some versions of the instrumenter in the wild populate &#039;func&#039;
        // but not &#039;decl&#039;:
        const decl = meta.decl || meta.loc;
        const startCol = decl.start.column;
        let endCol = decl.end.column + 1;
        const startLine = decl.start.line;
        const endLine = decl.end.line;
        const openSpan =
            lt +
            &#039;span class=&quot;&#039; +
            (meta.skip ? &#039;fstat-skip&#039; : &#039;fstat-no&#039;) +
            &#039;&quot;&#039; +
            title(&#039;function not covered&#039;) +
            gt;
        const closeSpan = lt + &#039;/span&#039; + gt;
        let text;

        if (type === &#039;no&#039; &amp;&amp; structuredText[startLine]) {
            if (endLine !== startLine) {
                endCol = structuredText[startLine].text.originalLength();
            }
            text = structuredText[startLine].text;
            text.wrap(
                startCol,
                openSpan,
                startCol &lt; endCol ? endCol : text.originalLength(),
                closeSpan
            );
        }
    });
}

function annotateBranches(fileCoverage, structuredText) {
    const branchStats = fileCoverage.b;
    const branchMeta = fileCoverage.branchMap;
    if (!branchStats) {
        return;
    }

    Object.entries(branchStats).forEach(([branchName, branchArray]) =&gt; {
        const sumCount = branchArray.reduce((p, n) =&gt; p + n, 0);
        const metaArray = branchMeta[branchName].locations;
        let i;
        let count;
        let meta;
        let startCol;
        let endCol;
        let startLine;
        let endLine;
        let openSpan;
        let closeSpan;
        let text;

        // only highlight if partial branches are missing or if there is a
        // single uncovered branch.
        if (sumCount &gt; 0 || (sumCount === 0 &amp;&amp; branchArray.length === 1)) {
            // Need to recover the metaArray placeholder item to count an implicit else
            if (
                // Check if the branch is a conditional if branch.
                branchMeta[branchName].type === &#039;if&#039; &amp;&amp;
                // Check if the branch has an implicit else.
                branchArray.length === 2 &amp;&amp;
                // Check if the implicit else branch is unaccounted for.
                metaArray.length === 1 &amp;&amp;
                // Check if the implicit else branch is uncovered.
                branchArray[1] === 0
            ) {
                metaArray[1] = {
                    start: {},
                    end: {}
                };
            }

            for (
                i = 0;
                i &lt; branchArray.length &amp;&amp; i &lt; metaArray.length;
                i += 1
            ) {
                count = branchArray[i];
                meta = metaArray[i];
                startCol = meta.start.column;
                endCol = meta.end.column + 1;
                startLine = meta.start.line;
                endLine = meta.end.line;
                openSpan =
                    lt +
                    &#039;span class=&quot;branch-&#039; +
                    i +
                    &#039; &#039; +
                    (meta.skip ? &#039;cbranch-skip&#039; : &#039;cbranch-no&#039;) +
                    &#039;&quot;&#039; +
                    title(&#039;branch not covered&#039;) +
                    gt;
                closeSpan = lt + &#039;/span&#039; + gt;

                // If the branch is an implicit else from an if statement,
                // then the coverage report won&#039;t show a statistic.
                // Therefore, the previous branch will be used to report that
                // there is no coverage on that implicit branch.
                if (
                    count === 0 &amp;&amp;
                    startLine === undefined &amp;&amp;
                    branchMeta[branchName].type === &#039;if&#039;
                ) {
                    const prevMeta = metaArray[i - 1];
                    startCol = prevMeta.start.column;
                    endCol = prevMeta.end.column + 1;
                    startLine = prevMeta.start.line;
                    endLine = prevMeta.end.line;
                }

                if (count === 0 &amp;&amp; structuredText[startLine]) {
                    //skip branches taken
                    if (endLine !== startLine) {
                        endCol = structuredText[
                            startLine
                        ].text.originalLength();
                    }
                    text = structuredText[startLine].text;
                    if (branchMeta[branchName].type === &#039;if&#039;) {
                        // &#039;if&#039; is a special case
                        // since the else branch might not be visible, being nonexistent
                        text.insertAt(
                            startCol,
                            lt +
                                &#039;span class=&quot;&#039; +
                                (meta.skip
                                    ? &#039;skip-if-branch&#039;
                                    : &#039;missing-if-branch&#039;) +
                                &#039;&quot;&#039; +
                                title(
                                    (i === 0 ? &#039;if&#039; : &#039;else&#039;) +
                                        &#039; path not taken&#039;
                                ) +
                                gt +
                                (i === 0 ? &#039;I&#039; : &#039;E&#039;) +
                                lt +
                                &#039;/span&#039; +
                                gt,
                            true,
                            false
                        );
                    } else {
                        text.wrap(
                            startCol,
                            openSpan,
                            startCol &lt; endCol ? endCol : text.originalLength(),
                            closeSpan
                        );
                    }
                }
            }
        }
    });
}

function annotateSourceCode(fileCoverage, sourceStore) {
    let codeArray;
    let lineCoverageArray;
    try {
        const sourceText = sourceStore.getSource(fileCoverage.path);
        const code = sourceText.split(/(?:\r?\n)|\r/);
        let count = 0;
        const structured = code.map(str =&gt; {
            count += 1;
            return {
                line: count,
                covered: &#039;neutral&#039;,
                hits: 0,
                text: new InsertionText(str, true)
            };
        });
        structured.unshift({
            line: 0,
            covered: null,
            text: new InsertionText(&#039;&#039;)
        });
        annotateLines(fileCoverage, structured);
        //note: order is important, since statements typically result in spanning the whole line and doing branches late
        //causes mismatched tags
        annotateBranches(fileCoverage, structured);
        annotateFunctions(fileCoverage, structured);
        annotateStatements(fileCoverage, structured);
        structured.shift();

        codeArray = structured.map(
            item =&gt; customEscape(item.text.toString()) || &#039;&amp;nbsp;&#039;
        );

        lineCoverageArray = structured.map(item =&gt; ({
            covered: item.covered,
            hits: item.hits &gt; 0 ? item.hits + &#039;x&#039; : &#039;&amp;nbsp;&#039;
        }));

        return {
            annotatedCode: codeArray,
            lineCoverage: lineCoverageArray,
            maxLines: structured.length
        };
    } catch (ex) {
        codeArray = [ex.message];
        lineCoverageArray = [{ covered: &#039;no&#039;, hits: 0 }];
        String(ex.stack || &#039;&#039;)
            .split(/\r?\n/)
            .forEach(line =&gt; {
                codeArray.push(line);
                lineCoverageArray.push({ covered: &#039;no&#039;, hits: 0 });
            });
        return {
            annotatedCode: codeArray,
            lineCoverage: lineCoverageArray,
            maxLines: codeArray.length
        };
    }
}

module.exports = annotateSourceCode;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
