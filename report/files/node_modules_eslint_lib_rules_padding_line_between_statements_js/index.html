<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/padding-line-between-statements.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/padding-line-between-statements.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">613</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">40.58</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.90</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to require or disallow newlines between statements
 * @author Toru Nagashima
 * @deprecated in ESLint v8.53.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const LT = `[${Array.from(astUtils.LINEBREAKS).join(&quot;&quot;)}]`;
const PADDING_LINE_SEQUENCE = new RegExp(
	String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`,
	&quot;u&quot;,
);
const CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
const CJS_IMPORT = /^require\(/u;

/**
 * Creates tester which check if a node starts with specific keyword.
 * @param {string} keyword The keyword to test.
 * @returns {Object} the created tester.
 * @private
 */
function newKeywordTester(keyword) {
	return {
		test: (node, sourceCode) =&gt;
			sourceCode.getFirstToken(node).value === keyword,
	};
}

/**
 * Creates tester which check if a node starts with specific keyword and spans a single line.
 * @param {string} keyword The keyword to test.
 * @returns {Object} the created tester.
 * @private
 */
function newSinglelineKeywordTester(keyword) {
	return {
		test: (node, sourceCode) =&gt;
			node.loc.start.line === node.loc.end.line &amp;&amp;
			sourceCode.getFirstToken(node).value === keyword,
	};
}

/**
 * Creates tester which check if a node starts with specific keyword and spans multiple lines.
 * @param {string} keyword The keyword to test.
 * @returns {Object} the created tester.
 * @private
 */
function newMultilineKeywordTester(keyword) {
	return {
		test: (node, sourceCode) =&gt;
			node.loc.start.line !== node.loc.end.line &amp;&amp;
			sourceCode.getFirstToken(node).value === keyword,
	};
}

/**
 * Creates tester which check if a node is specific type.
 * @param {string} type The node type to test.
 * @returns {Object} the created tester.
 * @private
 */
function newNodeTypeTester(type) {
	return {
		test: node =&gt; node.type === type,
	};
}

/**
 * Checks the given node is an expression statement of IIFE.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} `true` if the node is an expression statement of IIFE.
 * @private
 */
function isIIFEStatement(node) {
	if (node.type === &quot;ExpressionStatement&quot;) {
		let call = astUtils.skipChainExpression(node.expression);

		if (call.type === &quot;UnaryExpression&quot;) {
			call = astUtils.skipChainExpression(call.argument);
		}
		return (
			call.type === &quot;CallExpression&quot; &amp;&amp; astUtils.isFunction(call.callee)
		);
	}
	return false;
}

/**
 * Checks whether the given node is a block-like statement.
 * This checks the last token of the node is the closing brace of a block.
 * @param {SourceCode} sourceCode The source code to get tokens.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} `true` if the node is a block-like statement.
 * @private
 */
function isBlockLikeStatement(sourceCode, node) {
	// do-while with a block is a block-like statement.
	if (
		node.type === &quot;DoWhileStatement&quot; &amp;&amp;
		node.body.type === &quot;BlockStatement&quot;
	) {
		return true;
	}

	/*
	 * IIFE is a block-like statement specially from
	 * JSCS#disallowPaddingNewLinesAfterBlocks.
	 */
	if (isIIFEStatement(node)) {
		return true;
	}

	// Checks the last token is a closing brace of blocks.
	const lastToken = sourceCode.getLastToken(
		node,
		astUtils.isNotSemicolonToken,
	);
	const belongingNode =
		lastToken &amp;&amp; astUtils.isClosingBraceToken(lastToken)
			? sourceCode.getNodeByRangeIndex(lastToken.range[0])
			: null;

	return (
		Boolean(belongingNode) &amp;&amp;
		(belongingNode.type === &quot;BlockStatement&quot; ||
			belongingNode.type === &quot;SwitchStatement&quot;)
	);
}

/**
 * Gets the actual last token.
 *
 * If a semicolon is semicolon-less style&#039;s semicolon, this ignores it.
 * For example:
 *
 *     foo()
 *     ;[1, 2, 3].forEach(bar)
 * @param {SourceCode} sourceCode The source code to get tokens.
 * @param {ASTNode} node The node to get.
 * @returns {Token} The actual last token.
 * @private
 */
function getActualLastToken(sourceCode, node) {
	const semiToken = sourceCode.getLastToken(node);
	const prevToken = sourceCode.getTokenBefore(semiToken);
	const nextToken = sourceCode.getTokenAfter(semiToken);
	const isSemicolonLessStyle = Boolean(
		prevToken &amp;&amp;
			nextToken &amp;&amp;
			prevToken.range[0] &gt;= node.range[0] &amp;&amp;
			astUtils.isSemicolonToken(semiToken) &amp;&amp;
			semiToken.loc.start.line !== prevToken.loc.end.line &amp;&amp;
			semiToken.loc.end.line === nextToken.loc.start.line,
	);

	return isSemicolonLessStyle ? prevToken : semiToken;
}

/**
 * This returns the concatenation of the first 2 captured strings.
 * @param {string} _ Unused. Whole matched string.
 * @param {string} trailingSpaces The trailing spaces of the first line.
 * @param {string} indentSpaces The indentation spaces of the last line.
 * @returns {string} The concatenation of trailingSpaces and indentSpaces.
 * @private
 */
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
	return trailingSpaces + indentSpaces;
}

/**
 * Check and report statements for `any` configuration.
 * It does nothing.
 * @returns {void}
 * @private
 */
function verifyForAny() {}

/**
 * Check and report statements for `never` configuration.
 * This autofix removes blank lines between the given 2 statements.
 * However, if comments exist between 2 blank lines, it does not remove those
 * blank lines automatically.
 * @param {RuleContext} context The rule context to report.
 * @param {ASTNode} _ Unused. The previous node to check.
 * @param {ASTNode} nextNode The next node to check.
 * @param {Array&lt;Token[]&gt;} paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns {void}
 * @private
 */
function verifyForNever(context, _, nextNode, paddingLines) {
	if (paddingLines.length === 0) {
		return;
	}

	context.report({
		node: nextNode,
		messageId: &quot;unexpectedBlankLine&quot;,
		fix(fixer) {
			if (paddingLines.length &gt;= 2) {
				return null;
			}

			const prevToken = paddingLines[0][0];
			const nextToken = paddingLines[0][1];
			const start = prevToken.range[1];
			const end = nextToken.range[0];
			const text = context.sourceCode.text
				.slice(start, end)
				.replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);

			return fixer.replaceTextRange([start, end], text);
		},
	});
}

/**
 * Check and report statements for `always` configuration.
 * This autofix inserts a blank line between the given 2 statements.
 * If the `prevNode` has trailing comments, it inserts a blank line after the
 * trailing comments.
 * @param {RuleContext} context The rule context to report.
 * @param {ASTNode} prevNode The previous node to check.
 * @param {ASTNode} nextNode The next node to check.
 * @param {Array&lt;Token[]&gt;} paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns {void}
 * @private
 */
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
	if (paddingLines.length &gt; 0) {
		return;
	}

	context.report({
		node: nextNode,
		messageId: &quot;expectedBlankLine&quot;,
		fix(fixer) {
			const sourceCode = context.sourceCode;
			let prevToken = getActualLastToken(sourceCode, prevNode);
			const nextToken =
				sourceCode.getFirstTokenBetween(prevToken, nextNode, {
					includeComments: true,

					/**
					 * Skip the trailing comments of the previous node.
					 * This inserts a blank line after the last trailing comment.
					 *
					 * For example:
					 *
					 *     foo(); // trailing comment.
					 *     // comment.
					 *     bar();
					 *
					 * Get fixed to:
					 *
					 *     foo(); // trailing comment.
					 *
					 *     // comment.
					 *     bar();
					 * @param {Token} token The token to check.
					 * @returns {boolean} `true` if the token is not a trailing comment.
					 * @private
					 */
					filter(token) {
						if (astUtils.isTokenOnSameLine(prevToken, token)) {
							prevToken = token;
							return false;
						}
						return true;
					},
				}) || nextNode;
			const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)
				? &quot;\n\n&quot;
				: &quot;\n&quot;;

			return fixer.insertTextAfter(prevToken, insertText);
		},
	});
}

/**
 * Types of blank lines.
 * `any`, `never`, and `always` are defined.
 * Those have `verify` method to check and report statements.
 * @private
 */
const PaddingTypes = {
	any: { verify: verifyForAny },
	never: { verify: verifyForNever },
	always: { verify: verifyForAlways },
};

/**
 * Types of statements.
 * Those have `test` method to check it matches to the given statement.
 * @private
 */
const StatementTypes = {
	&quot;*&quot;: { test: () =&gt; true },
	&quot;block-like&quot;: {
		test: (node, sourceCode) =&gt; isBlockLikeStatement(sourceCode, node),
	},
	&quot;cjs-export&quot;: {
		test: (node, sourceCode) =&gt;
			node.type === &quot;ExpressionStatement&quot; &amp;&amp;
			node.expression.type === &quot;AssignmentExpression&quot; &amp;&amp;
			CJS_EXPORT.test(sourceCode.getText(node.expression.left)),
	},
	&quot;cjs-import&quot;: {
		test: (node, sourceCode) =&gt;
			node.type === &quot;VariableDeclaration&quot; &amp;&amp;
			node.declarations.length &gt; 0 &amp;&amp;
			Boolean(node.declarations[0].init) &amp;&amp;
			CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init)),
	},
	directive: {
		test: astUtils.isDirective,
	},
	expression: {
		test: node =&gt;
			node.type === &quot;ExpressionStatement&quot; &amp;&amp; !astUtils.isDirective(node),
	},
	iife: {
		test: isIIFEStatement,
	},
	&quot;multiline-block-like&quot;: {
		test: (node, sourceCode) =&gt;
			node.loc.start.line !== node.loc.end.line &amp;&amp;
			isBlockLikeStatement(sourceCode, node),
	},
	&quot;multiline-expression&quot;: {
		test: node =&gt;
			node.loc.start.line !== node.loc.end.line &amp;&amp;
			node.type === &quot;ExpressionStatement&quot; &amp;&amp;
			!astUtils.isDirective(node),
	},

	&quot;multiline-const&quot;: newMultilineKeywordTester(&quot;const&quot;),
	&quot;multiline-let&quot;: newMultilineKeywordTester(&quot;let&quot;),
	&quot;multiline-var&quot;: newMultilineKeywordTester(&quot;var&quot;),
	&quot;singleline-const&quot;: newSinglelineKeywordTester(&quot;const&quot;),
	&quot;singleline-let&quot;: newSinglelineKeywordTester(&quot;let&quot;),
	&quot;singleline-var&quot;: newSinglelineKeywordTester(&quot;var&quot;),

	block: newNodeTypeTester(&quot;BlockStatement&quot;),
	empty: newNodeTypeTester(&quot;EmptyStatement&quot;),
	function: newNodeTypeTester(&quot;FunctionDeclaration&quot;),

	break: newKeywordTester(&quot;break&quot;),
	case: newKeywordTester(&quot;case&quot;),
	class: newKeywordTester(&quot;class&quot;),
	const: newKeywordTester(&quot;const&quot;),
	continue: newKeywordTester(&quot;continue&quot;),
	debugger: newKeywordTester(&quot;debugger&quot;),
	default: newKeywordTester(&quot;default&quot;),
	do: newKeywordTester(&quot;do&quot;),
	export: newKeywordTester(&quot;export&quot;),
	for: newKeywordTester(&quot;for&quot;),
	if: newKeywordTester(&quot;if&quot;),
	import: newKeywordTester(&quot;import&quot;),
	let: newKeywordTester(&quot;let&quot;),
	return: newKeywordTester(&quot;return&quot;),
	switch: newKeywordTester(&quot;switch&quot;),
	throw: newKeywordTester(&quot;throw&quot;),
	try: newKeywordTester(&quot;try&quot;),
	var: newKeywordTester(&quot;var&quot;),
	while: newKeywordTester(&quot;while&quot;),
	with: newKeywordTester(&quot;with&quot;),
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin&quot;,
						url: &quot;https://eslint.style&quot;,
					},
					rule: {
						name: &quot;padding-line-between-statements&quot;,
						url: &quot;https://eslint.style/rules/padding-line-between-statements&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description: &quot;Require or disallow padding lines between statements&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/padding-line-between-statements&quot;,
		},

		fixable: &quot;whitespace&quot;,

		schema: {
			definitions: {
				paddingType: {
					enum: Object.keys(PaddingTypes),
				},
				statementType: {
					anyOf: [
						{ enum: Object.keys(StatementTypes) },
						{
							type: &quot;array&quot;,
							items: { enum: Object.keys(StatementTypes) },
							minItems: 1,
							uniqueItems: true,
						},
					],
				},
			},
			type: &quot;array&quot;,
			items: {
				type: &quot;object&quot;,
				properties: {
					blankLine: { $ref: &quot;#/definitions/paddingType&quot; },
					prev: { $ref: &quot;#/definitions/statementType&quot; },
					next: { $ref: &quot;#/definitions/statementType&quot; },
				},
				additionalProperties: false,
				required: [&quot;blankLine&quot;, &quot;prev&quot;, &quot;next&quot;],
			},
		},

		messages: {
			unexpectedBlankLine: &quot;Unexpected blank line before this statement.&quot;,
			expectedBlankLine: &quot;Expected blank line before this statement.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;
		const configureList = context.options || [];
		let scopeInfo = null;

		/**
		 * Processes to enter to new scope.
		 * This manages the current previous statement.
		 * @returns {void}
		 * @private
		 */
		function enterScope() {
			scopeInfo = {
				upper: scopeInfo,
				prevNode: null,
			};
		}

		/**
		 * Processes to exit from the current scope.
		 * @returns {void}
		 * @private
		 */
		function exitScope() {
			scopeInfo = scopeInfo.upper;
		}

		/**
		 * Checks whether the given node matches the given type.
		 * @param {ASTNode} node The statement node to check.
		 * @param {string|string[]} type The statement type to check.
		 * @returns {boolean} `true` if the statement node matched the type.
		 * @private
		 */
		function match(node, type) {
			let innerStatementNode = node;

			while (innerStatementNode.type === &quot;LabeledStatement&quot;) {
				innerStatementNode = innerStatementNode.body;
			}
			if (Array.isArray(type)) {
				return type.some(match.bind(null, innerStatementNode));
			}
			return StatementTypes[type].test(innerStatementNode, sourceCode);
		}

		/**
		 * Finds the last matched configure from configureList.
		 * @param {ASTNode} prevNode The previous statement to match.
		 * @param {ASTNode} nextNode The current statement to match.
		 * @returns {Object} The tester of the last matched configure.
		 * @private
		 */
		function getPaddingType(prevNode, nextNode) {
			for (let i = configureList.length - 1; i &gt;= 0; --i) {
				const configure = configureList[i];
				const matched =
					match(prevNode, configure.prev) &amp;&amp;
					match(nextNode, configure.next);

				if (matched) {
					return PaddingTypes[configure.blankLine];
				}
			}
			return PaddingTypes.any;
		}

		/**
		 * Gets padding line sequences between the given 2 statements.
		 * Comments are separators of the padding line sequences.
		 * @param {ASTNode} prevNode The previous statement to count.
		 * @param {ASTNode} nextNode The current statement to count.
		 * @returns {Array&lt;Token[]&gt;} The array of token pairs.
		 * @private
		 */
		function getPaddingLineSequences(prevNode, nextNode) {
			const pairs = [];
			let prevToken = getActualLastToken(sourceCode, prevNode);

			if (nextNode.loc.start.line - prevToken.loc.end.line &gt;= 2) {
				do {
					const token = sourceCode.getTokenAfter(prevToken, {
						includeComments: true,
					});

					if (token.loc.start.line - prevToken.loc.end.line &gt;= 2) {
						pairs.push([prevToken, token]);
					}
					prevToken = token;
				} while (prevToken.range[0] &lt; nextNode.range[0]);
			}

			return pairs;
		}

		/**
		 * Verify padding lines between the given node and the previous node.
		 * @param {ASTNode} node The node to verify.
		 * @returns {void}
		 * @private
		 */
		function verify(node) {
			const parentType = node.parent.type;
			const validParent =
				astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||
				parentType === &quot;SwitchStatement&quot;;

			if (!validParent) {
				return;
			}

			// Save this node as the current previous statement.
			const prevNode = scopeInfo.prevNode;

			// Verify.
			if (prevNode) {
				const type = getPaddingType(prevNode, node);
				const paddingLines = getPaddingLineSequences(prevNode, node);

				type.verify(context, prevNode, node, paddingLines);
			}

			scopeInfo.prevNode = node;
		}

		/**
		 * Verify padding lines between the given node and the previous node.
		 * Then process to enter to new scope.
		 * @param {ASTNode} node The node to verify.
		 * @returns {void}
		 * @private
		 */
		function verifyThenEnterScope(node) {
			verify(node);
			enterScope();
		}

		return {
			Program: enterScope,
			BlockStatement: enterScope,
			SwitchStatement: enterScope,
			StaticBlock: enterScope,
			&quot;Program:exit&quot;: exitScope,
			&quot;BlockStatement:exit&quot;: exitScope,
			&quot;SwitchStatement:exit&quot;: exitScope,
			&quot;StaticBlock:exit&quot;: exitScope,

			&quot;:statement&quot;: verify,

			SwitchCase: verifyThenEnterScope,
			&quot;SwitchCase:exit&quot;: exitScope,
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
