<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/living/range/Range-impl.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/living/range/Range-impl.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">898</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">154.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.56</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const DOMException = require(&quot;../generated/DOMException&quot;);

const { clone } = require(&quot;../node&quot;);
const NODE_TYPE = require(&quot;../node-type&quot;);
const { parseFragment } = require(&quot;../../browser/parser/index&quot;);

const { HTML_NS } = require(&quot;../helpers/namespaces&quot;);
const { domSymbolTree } = require(&quot;../helpers/internal-constants&quot;);
const { compareBoundaryPointsPosition } = require(&quot;./boundary-point&quot;);
const { nodeRoot, nodeLength, isInclusiveAncestor } = require(&quot;../helpers/node&quot;);
const { createElement } = require(&quot;../helpers/create-element&quot;);

const AbstractRangeImpl = require(&quot;./AbstractRange-impl&quot;).implementation;

const Range = require(&quot;../generated/Range&quot;);
const DocumentFragment = require(&quot;../generated/DocumentFragment&quot;);
const { implForWrapper } = require(&quot;../generated/utils&quot;);

const RANGE_COMPARISON_TYPE = {
  START_TO_START: 0,
  START_TO_END: 1,
  END_TO_END: 2,
  END_TO_START: 3
};

class RangeImpl extends AbstractRangeImpl {
  constructor(globalObject, args, privateData) {
    super(globalObject, args, privateData);

    const defaultBoundaryPoint = {
      node: implForWrapper(globalObject._document),
      offset: 0
    };

    const {
      start = defaultBoundaryPoint,
      end = defaultBoundaryPoint
    } = privateData;

    this._setLiveRangeStart(start.node, start.offset);
    this._setLiveRangeEnd(end.node, end.offset);
  }

  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer
  get commonAncestorContainer() {
    const { _start, _end } = this;

    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {
      if (isInclusiveAncestor(container, _end.node)) {
        return container;
      }
    }

    return null;
  }

  // https://dom.spec.whatwg.org/#dom-range-setstart
  setStart(node, offset) {
    setBoundaryPointStart(this, node, offset);
  }

  // https://dom.spec.whatwg.org/#dom-range-setend
  setEnd(node, offset) {
    setBoundaryPointEnd(this, node, offset);
  }

  // https://dom.spec.whatwg.org/#dom-range-setstartbefore
  setStartBefore(node) {
    const parent = domSymbolTree.parent(node);

    if (!parent) {
      throw DOMException.create(this._globalObject, [&quot;The given Node has no parent.&quot;, &quot;InvalidNodeTypeError&quot;]);
    }

    setBoundaryPointStart(this, parent, domSymbolTree.index(node));
  }

  // https://dom.spec.whatwg.org/#dom-range-setstartafter
  setStartAfter(node) {
    const parent = domSymbolTree.parent(node);

    if (!parent) {
      throw DOMException.create(this._globalObject, [&quot;The given Node has no parent.&quot;, &quot;InvalidNodeTypeError&quot;]);
    }

    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);
  }

  // https://dom.spec.whatwg.org/#dom-range-setendbefore
  setEndBefore(node) {
    const parent = domSymbolTree.parent(node);

    if (!parent) {
      throw DOMException.create(this._globalObject, [&quot;The given Node has no parent.&quot;, &quot;InvalidNodeTypeError&quot;]);
    }

    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));
  }

  // https://dom.spec.whatwg.org/#dom-range-setendafter
  setEndAfter(node) {
    const parent = domSymbolTree.parent(node);

    if (!parent) {
      throw DOMException.create(this._globalObject, [&quot;The given Node has no parent.&quot;, &quot;InvalidNodeTypeError&quot;]);
    }

    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);
  }

  // https://dom.spec.whatwg.org/#dom-range-collapse
  collapse(toStart) {
    if (toStart) {
      this._setLiveRangeEnd(this._start.node, this._start.offset);
    } else {
      this._setLiveRangeStart(this._end.node, this._end.offset);
    }
  }

  // https://dom.spec.whatwg.org/#dom-range-selectnode
  selectNode(node) {
    selectNodeWithinRange(node, this);
  }

  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents
  selectNodeContents(node) {
    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
      throw DOMException.create(this._globalObject, [
        &quot;DocumentType Node can&#039;t be used as boundary point.&quot;,
        &quot;InvalidNodeTypeError&quot;
      ]);
    }

    const length = nodeLength(node);

    this._setLiveRangeStart(node, 0);
    this._setLiveRangeEnd(node, length);
  }

  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints
  compareBoundaryPoints(how, sourceRange) {
    if (
      how !== RANGE_COMPARISON_TYPE.START_TO_START &amp;&amp;
      how !== RANGE_COMPARISON_TYPE.START_TO_END &amp;&amp;
      how !== RANGE_COMPARISON_TYPE.END_TO_END &amp;&amp;
      how !== RANGE_COMPARISON_TYPE.END_TO_START
    ) {
      const message = &quot;The comparison method provided must be one of &#039;START_TO_START&#039;, &#039;START_TO_END&#039;, &#039;END_TO_END&#039;, &quot; +
                      &quot;or &#039;END_TO_START&#039;.&quot;;
      throw DOMException.create(this._globalObject, [message, &quot;NotSupportedError&quot;]);
    }

    if (this._root !== sourceRange._root) {
      throw DOMException.create(this._globalObject, [&quot;The two Ranges are not in the same tree.&quot;, &quot;WrongDocumentError&quot;]);
    }

    let thisPoint, otherPoint;
    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {
      thisPoint = this._start;
      otherPoint = sourceRange._start;
    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {
      thisPoint = this._end;
      otherPoint = sourceRange._start;
    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {
      thisPoint = this._end;
      otherPoint = sourceRange._end;
    } else {
      thisPoint = this._start;
      otherPoint = sourceRange._end;
    }

    return compareBoundaryPointsPosition(thisPoint, otherPoint);
  }

  // https://dom.spec.whatwg.org/#dom-range-deletecontents
  deleteContents() {
    if (this.collapsed) {
      return;
    }

    const { _start: originalStart, _end: originalEnd } = this;

    if (
      originalStart.node === originalEnd.node &amp;&amp;
      (
        originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||
        originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
        originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE
      )
    ) {
      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, &quot;&quot;);
      return;
    }

    const nodesToRemove = [];
    let currentNode = this._start.node;
    const endNode = nextNodeDescendant(this._end.node);
    while (currentNode &amp;&amp; currentNode !== endNode) {
      if (
        isContained(currentNode, this) &amp;&amp;
        !isContained(domSymbolTree.parent(currentNode), this)
      ) {
        nodesToRemove.push(currentNode);
      }

      currentNode = domSymbolTree.following(currentNode);
    }

    let newNode, newOffset;
    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {
      newNode = originalStart.node;
      newOffset = originalStart.offset;
    } else {
      let referenceNode = originalStart.node;

      while (
        referenceNode &amp;&amp;
        !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)
      ) {
        referenceNode = domSymbolTree.parent(referenceNode);
      }

      newNode = domSymbolTree.parent(referenceNode);
      newOffset = domSymbolTree.index(referenceNode) + 1;
    }

    if (
      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||
      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE
    ) {
      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, &quot;&quot;);
    }

    for (const node of nodesToRemove) {
      const parent = domSymbolTree.parent(node);
      parent.removeChild(node);
    }

    if (
      originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE ||
      originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE
    ) {
      originalEnd.node.replaceData(0, originalEnd.offset, &quot;&quot;);
    }

    this._setLiveRangeStart(newNode, newOffset);
    this._setLiveRangeEnd(newNode, newOffset);
  }

  // https://dom.spec.whatwg.org/#dom-range-extractcontents
  extractContents() {
    return extractRange(this);
  }

  // https://dom.spec.whatwg.org/#dom-range-clonecontents
  cloneContents() {
    return cloneRange(this);
  }

  // https://dom.spec.whatwg.org/#dom-range-insertnode
  insertNode(node) {
    insertNodeInRange(node, this);
  }

  // https://dom.spec.whatwg.org/#dom-range-surroundcontents
  surroundContents(newParent) {
    let node = this.commonAncestorContainer;
    const endNode = nextNodeDescendant(node);
    while (node !== endNode) {
      if (node.nodeType !== NODE_TYPE.TEXT_NODE &amp;&amp; isPartiallyContained(node, this)) {
        throw DOMException.create(this._globalObject, [
          &quot;The Range has partially contains a non-Text node.&quot;,
          &quot;InvalidStateError&quot;
        ]);
      }

      node = domSymbolTree.following(node);
    }

    if (
      newParent.nodeType === NODE_TYPE.DOCUMENT_NODE ||
      newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE ||
      newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE
    ) {
      throw DOMException.create(this._globalObject, [&quot;Invalid element type.&quot;, &quot;InvalidNodeTypeError&quot;]);
    }

    const fragment = extractRange(this);

    while (domSymbolTree.firstChild(newParent)) {
      newParent.removeChild(domSymbolTree.firstChild(newParent));
    }

    insertNodeInRange(newParent, this);

    newParent.appendChild(fragment);

    selectNodeWithinRange(newParent, this);
  }

  // https://dom.spec.whatwg.org/#dom-range-clonerange
  cloneRange() {
    const { _start, _end, _globalObject } = this;

    return Range.createImpl(_globalObject, [], {
      start: { node: _start.node, offset: _start.offset },
      end: { node: _end.node, offset: _end.offset }
    });
  }

  // https://dom.spec.whatwg.org/#dom-range-detach
  detach() {
    // Do nothing by spec!
  }

  // https://dom.spec.whatwg.org/#dom-range-ispointinrange
  isPointInRange(node, offset) {
    if (nodeRoot(node) !== this._root) {
      return false;
    }

    validateSetBoundaryPoint(node, offset);

    const bp = { node, offset };

    if (
      compareBoundaryPointsPosition(bp, this._start) === -1 ||
      compareBoundaryPointsPosition(bp, this._end) === 1
    ) {
      return false;
    }

    return true;
  }

  // https://dom.spec.whatwg.org/#dom-range-comparepoint
  comparePoint(node, offset) {
    if (nodeRoot(node) !== this._root) {
      throw DOMException.create(this._globalObject, [
        &quot;The given Node and the Range are not in the same tree.&quot;,
        &quot;WrongDocumentError&quot;
      ]);
    }

    validateSetBoundaryPoint(node, offset);

    const bp = { node, offset };
    if (compareBoundaryPointsPosition(bp, this._start) === -1) {
      return -1;
    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {
      return 1;
    }

    return 0;
  }

  // https://dom.spec.whatwg.org/#dom-range-intersectsnode
  intersectsNode(node) {
    if (nodeRoot(node) !== this._root) {
      return false;
    }

    const parent = domSymbolTree.parent(node);
    if (!parent) {
      return true;
    }

    const offset = domSymbolTree.index(node);

    return (
      compareBoundaryPointsPosition({ node: parent, offset }, this._end) === -1 &amp;&amp;
      compareBoundaryPointsPosition({ node: parent, offset: offset + 1 }, this._start) === 1
    );
  }

  // https://dom.spec.whatwg.org/#dom-range-stringifier
  toString() {
    let s = &quot;&quot;;
    const { _start, _end } = this;

    if (_start.node === _end.node &amp;&amp; _start.node.nodeType === NODE_TYPE.TEXT_NODE) {
      return _start.node.data.slice(_start.offset, _end.offset);
    }

    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {
      s += _start.node.data.slice(_start.offset);
    }

    let currentNode = _start.node;
    const endNode = nextNodeDescendant(_end.node);
    while (currentNode &amp;&amp; currentNode !== endNode) {
      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE &amp;&amp; isContained(currentNode, this)) {
        s += currentNode.data;
      }

      currentNode = domSymbolTree.following(currentNode);
    }

    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {
      s += _end.node.data.slice(0, _end.offset);
    }

    return s;
  }

  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment
  createContextualFragment(fragment) {
    const { node } = this._start;

    let element;
    switch (node.nodeType) {
      case NODE_TYPE.DOCUMENT_NODE:
      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:
        element = null;
        break;

      case NODE_TYPE.ELEMENT_NODE:
        element = node;
        break;

      case NODE_TYPE.TEXT_NODE:
      case NODE_TYPE.COMMENT_NODE:
        element = node.parentElement;
        break;

      default:
        throw new Error(&quot;Internal error: Invalid range start node&quot;);
    }

    if (
      element === null || (
        element._ownerDocument._parsingMode === &quot;html&quot; &amp;&amp;
        element._localName === &quot;html&quot; &amp;&amp;
        element._namespaceURI === HTML_NS
      )
    ) {
      element = createElement(node._ownerDocument, &quot;body&quot;, HTML_NS);
    }

    return parseFragment(fragment, element);
  }

  // https://dom.spec.whatwg.org/#concept-range-root
  get _root() {
    return nodeRoot(this._start.node);
  }

  _setLiveRangeStart(node, offset) {
    if (
      this._start &amp;&amp;
      this._start.node !== node &amp;&amp;
      this._start.node !== this._end.node
    ) {
      this._start.node._referencedRanges.delete(this);
    }

    if (!node._referencedRanges.has(this)) {
      node._referencedRanges.add(this);
    }

    this._start = {
      node,
      offset
    };
  }

  _setLiveRangeEnd(node, offset) {
    if (
      this._end &amp;&amp;
      this._end.node !== node &amp;&amp;
      this._end.node !== this._start.node
    ) {
      this._end.node._referencedRanges.delete(this);
    }

    if (!node._referencedRanges.has(this)) {
      node._referencedRanges.add(this);
    }

    this._end = {
      node,
      offset
    };
  }
}


function nextNodeDescendant(node) {
  while (node &amp;&amp; !domSymbolTree.nextSibling(node)) {
    node = domSymbolTree.parent(node);
  }

  if (!node) {
    return null;
  }

  return domSymbolTree.nextSibling(node);
}

// https://dom.spec.whatwg.org/#concept-range-bp-set
function validateSetBoundaryPoint(node, offset) {
  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
    throw DOMException.create(node._globalObject, [
      &quot;DocumentType Node can&#039;t be used as boundary point.&quot;,
      &quot;InvalidNodeTypeError&quot;
    ]);
  }

  if (offset &gt; nodeLength(node)) {
    throw DOMException.create(node._globalObject, [&quot;Offset out of bound.&quot;, &quot;IndexSizeError&quot;]);
  }
}
function setBoundaryPointStart(range, node, offset) {
  validateSetBoundaryPoint(node, offset);

  const bp = { node, offset };
  if (
    nodeRoot(node) !== range._root ||
    compareBoundaryPointsPosition(bp, range._end) === 1
  ) {
    range._setLiveRangeEnd(node, offset);
  }

  range._setLiveRangeStart(node, offset);
}
function setBoundaryPointEnd(range, node, offset) {
  validateSetBoundaryPoint(node, offset);

  const bp = { node, offset };
  if (
    nodeRoot(node) !== range._root ||
    compareBoundaryPointsPosition(bp, range._start) === -1
  ) {
    range._setLiveRangeStart(node, offset);
  }

  range._setLiveRangeEnd(node, offset);
}

// https://dom.spec.whatwg.org/#concept-range-select
function selectNodeWithinRange(node, range) {
  const parent = domSymbolTree.parent(node);

  if (!parent) {
    throw DOMException.create(node._globalObject, [&quot;The given Node has no parent.&quot;, &quot;InvalidNodeTypeError&quot;]);
  }

  const index = domSymbolTree.index(node);

  range._setLiveRangeStart(parent, index);
  range._setLiveRangeEnd(parent, index + 1);
}

// https://dom.spec.whatwg.org/#contained
function isContained(node, range) {
  const { _start, _end } = range;
  return (
    compareBoundaryPointsPosition({ node, offset: 0 }, _start) === 1 &amp;&amp;
    compareBoundaryPointsPosition({ node, offset: nodeLength(node) }, _end) === -1
  );
}

// https://dom.spec.whatwg.org/#partially-contained
function isPartiallyContained(node, range) {
  const { _start, _end } = range;
  return (
    (isInclusiveAncestor(node, _start.node) &amp;&amp; !isInclusiveAncestor(node, _end.node)) ||
    (!isInclusiveAncestor(node, _start.node) &amp;&amp; isInclusiveAncestor(node, _end.node))
  );
}

// https://dom.spec.whatwg.org/#concept-range-insert
function insertNodeInRange(node, range) {
  const { node: startNode, offset: startOffset } = range._start;

  if (
    startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
    startNode.nodeType === NODE_TYPE.COMMENT_NODE ||
    (startNode.nodeType === NODE_TYPE.TEXT_NODE &amp;&amp; !domSymbolTree.parent(startNode)) ||
    node === startNode
  ) {
    throw DOMException.create(node._globalObject, [&quot;Invalid start node.&quot;, &quot;HierarchyRequestError&quot;]);
  }

  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ?
    startNode :
    domSymbolTree.childrenToArray(startNode)[startOffset] || null;
  const parent = !referenceNode ?
    startNode :
    domSymbolTree.parent(referenceNode);

  parent._preInsertValidity(node, referenceNode);

  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {
    referenceNode = startNode.splitText(startOffset);
  }

  if (node === referenceNode) {
    referenceNode = domSymbolTree.nextSibling(referenceNode);
  }

  const nodeParent = domSymbolTree.parent(node);
  if (nodeParent) {
    nodeParent.removeChild(node);
  }

  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);
  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;

  parent.insertBefore(node, referenceNode);

  if (range.collapsed) {
    range._setLiveRangeEnd(parent, newOffset);
  }
}

// https://dom.spec.whatwg.org/#concept-range-clone
function cloneRange(range) {
  const { _start: originalStart, _end: originalEnd, _globalObject } = range;

  const fragment = DocumentFragment.createImpl(_globalObject, [], {
    ownerDocument: originalStart.node._ownerDocument
  });

  if (range.collapsed) {
    return fragment;
  }

  if (
    originalStart.node === originalEnd.node &amp;&amp;
    (
      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||
      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE
    )
  ) {
    const cloned = clone(originalStart.node);
    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);

    fragment.appendChild(cloned);

    return fragment;
  }

  let commonAncestor = originalStart.node;
  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {
    commonAncestor = domSymbolTree.parent(commonAncestor);
  }

  let firstPartialContainedChild = null;
  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {
    let candidate = domSymbolTree.firstChild(commonAncestor);
    while (!firstPartialContainedChild) {
      if (isPartiallyContained(candidate, range)) {
        firstPartialContainedChild = candidate;
      }

      candidate = domSymbolTree.nextSibling(candidate);
    }
  }

  let lastPartiallyContainedChild = null;
  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {
    let candidate = domSymbolTree.lastChild(commonAncestor);
    while (!lastPartiallyContainedChild) {
      if (isPartiallyContained(candidate, range)) {
        lastPartiallyContainedChild = candidate;
      }

      candidate = domSymbolTree.previousSibling(candidate);
    }
  }

  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)
    .filter(node =&gt; isContained(node, range));

  const hasDoctypeChildren = containedChildren.some(node =&gt; node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);
  if (hasDoctypeChildren) {
    throw DOMException.create(range._globalObject, [&quot;Invalid document type element.&quot;, &quot;HierarchyRequestError&quot;]);
  }

  if (
    firstPartialContainedChild !== null &amp;&amp;
    (
      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||
      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE
    )
  ) {
    const cloned = clone(originalStart.node);
    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);

    fragment.appendChild(cloned);
  } else if (firstPartialContainedChild !== null) {
    const cloned = clone(firstPartialContainedChild);
    fragment.appendChild(cloned);

    const subrange = Range.createImpl(_globalObject, [], {
      start: { node: originalStart.node, offset: originalStart.offset },
      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }
    });

    const subfragment = cloneRange(subrange);
    cloned.appendChild(subfragment);
  }

  for (const containedChild of containedChildren) {
    const cloned = clone(containedChild, undefined, true);
    fragment.appendChild(cloned);
  }

  if (
    lastPartiallyContainedChild !== null &amp;&amp;
    (
      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||
      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE
    )
  ) {
    const cloned = clone(originalEnd.node);
    cloned._data = cloned.substringData(0, originalEnd.offset);

    fragment.appendChild(cloned);
  } else if (lastPartiallyContainedChild !== null) {
    const cloned = clone(lastPartiallyContainedChild);
    fragment.appendChild(cloned);

    const subrange = Range.createImpl(_globalObject, [], {
      start: { node: lastPartiallyContainedChild, offset: 0 },
      end: { node: originalEnd.node, offset: originalEnd.offset }
    });

    const subfragment = cloneRange(subrange);
    cloned.appendChild(subfragment);
  }

  return fragment;
}

// https://dom.spec.whatwg.org/#concept-range-extract
function extractRange(range) {
  const { _start: originalStart, _end: originalEnd, _globalObject } = range;

  const fragment = DocumentFragment.createImpl(_globalObject, [], {
    ownerDocument: originalStart.node._ownerDocument
  });

  if (range.collapsed) {
    return fragment;
  }

  if (
    originalStart.node === originalEnd.node &amp;&amp;
    (
      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||
      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE
    )
  ) {
    const cloned = clone(originalStart.node);
    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);

    fragment.appendChild(cloned);
    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, &quot;&quot;);

    return fragment;
  }

  let commonAncestor = originalStart.node;
  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {
    commonAncestor = domSymbolTree.parent(commonAncestor);
  }

  let firstPartialContainedChild = null;
  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {
    let candidate = domSymbolTree.firstChild(commonAncestor);
    while (!firstPartialContainedChild) {
      if (isPartiallyContained(candidate, range)) {
        firstPartialContainedChild = candidate;
      }

      candidate = domSymbolTree.nextSibling(candidate);
    }
  }

  let lastPartiallyContainedChild = null;
  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {
    let candidate = domSymbolTree.lastChild(commonAncestor);
    while (!lastPartiallyContainedChild) {
      if (isPartiallyContained(candidate, range)) {
        lastPartiallyContainedChild = candidate;
      }

      candidate = domSymbolTree.previousSibling(candidate);
    }
  }

  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)
    .filter(node =&gt; isContained(node, range));

  const hasDoctypeChildren = containedChildren.some(node =&gt; node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);
  if (hasDoctypeChildren) {
    throw DOMException.create(range._globalObject, [&quot;Invalid document type element.&quot;, &quot;HierarchyRequestError&quot;]);
  }

  let newNode, newOffset;
  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {
    newNode = originalStart.node;
    newOffset = originalStart.offset;
  } else {
    let referenceNode = originalStart.node;

    while (
      referenceNode &amp;&amp;
      !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)
    ) {
      referenceNode = domSymbolTree.parent(referenceNode);
    }

    newNode = domSymbolTree.parent(referenceNode);
    newOffset = domSymbolTree.index(referenceNode) + 1;
  }

  if (
    firstPartialContainedChild !== null &amp;&amp;
    (
      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||
      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE
    )
  ) {
    const cloned = clone(originalStart.node);
    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);

    fragment.appendChild(cloned);

    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, &quot;&quot;);
  } else if (firstPartialContainedChild !== null) {
    const cloned = clone(firstPartialContainedChild);
    fragment.appendChild(cloned);

    const subrange = Range.createImpl(_globalObject, [], {
      start: { node: originalStart.node, offset: originalStart.offset },
      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }
    });

    const subfragment = extractRange(subrange);
    cloned.appendChild(subfragment);
  }

  for (const containedChild of containedChildren) {
    fragment.appendChild(containedChild);
  }

  if (
    lastPartiallyContainedChild !== null &amp;&amp;
    (
      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||
      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||
      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE
    )
  ) {
    const cloned = clone(originalEnd.node);
    cloned._data = cloned.substringData(0, originalEnd.offset);

    fragment.appendChild(cloned);

    originalEnd.node.replaceData(0, originalEnd.offset, &quot;&quot;);
  } else if (lastPartiallyContainedChild !== null) {
    const cloned = clone(lastPartiallyContainedChild);
    fragment.appendChild(cloned);

    const subrange = Range.createImpl(_globalObject, [], {
      start: { node: lastPartiallyContainedChild, offset: 0 },
      end: { node: originalEnd.node, offset: originalEnd.offset }
    });

    const subfragment = extractRange(subrange);
    cloned.appendChild(subfragment);
  }

  range._setLiveRangeStart(newNode, newOffset);
  range._setLiveRangeEnd(newNode, newOffset);

  return fragment;
}

module.exports = {
  implementation: RangeImpl,

  setBoundaryPointStart,
  setBoundaryPointEnd
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
