<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/websocket-driver/lib/websocket/driver/hybi.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/websocket-driver/lib/websocket/driver/hybi.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.87</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">484</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">97.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.49</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var Buffer     = require(&#039;safe-buffer&#039;).Buffer,
    crypto     = require(&#039;crypto&#039;),
    util       = require(&#039;util&#039;),
    Extensions = require(&#039;websocket-extensions&#039;),
    Base       = require(&#039;./base&#039;),
    Frame      = require(&#039;./hybi/frame&#039;),
    Message    = require(&#039;./hybi/message&#039;);

var Hybi = function(request, url, options) {
  Base.apply(this, arguments);

  this._extensions     = new Extensions();
  this._stage          = 0;
  this._masking        = this._options.masking;
  this._protocols      = this._options.protocols || [];
  this._requireMasking = this._options.requireMasking;
  this._pingCallbacks  = {};

  if (typeof this._protocols === &#039;string&#039;)
    this._protocols = this._protocols.split(/ *, */);

  if (!this._request) return;

  var protos    = this._request.headers[&#039;sec-websocket-protocol&#039;],
      supported = this._protocols;

  if (protos !== undefined) {
    if (typeof protos === &#039;string&#039;) protos = protos.split(/ *, */);
    this.protocol = protos.filter(function(p) { return supported.indexOf(p) &gt;= 0 })[0];
  }

  this.version = &#039;hybi-&#039; + Hybi.VERSION;
};
util.inherits(Hybi, Base);

Hybi.VERSION = &#039;13&#039;;

Hybi.mask = function(payload, mask, offset) {
  if (!mask || mask.length === 0) return payload;
  offset = offset || 0;

  for (var i = 0, n = payload.length - offset; i &lt; n; i++) {
    payload[offset + i] = payload[offset + i] ^ mask[i % 4];
  }
  return payload;
};

Hybi.generateAccept = function(key) {
  var sha1 = crypto.createHash(&#039;sha1&#039;);
  sha1.update(key + Hybi.GUID);
  return sha1.digest(&#039;base64&#039;);
};

Hybi.GUID = &#039;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#039;;

var instance = {
  FIN:    0x80,
  MASK:   0x80,
  RSV1:   0x40,
  RSV2:   0x20,
  RSV3:   0x10,
  OPCODE: 0x0F,
  LENGTH: 0x7F,

  OPCODES: {
    continuation: 0,
    text:         1,
    binary:       2,
    close:        8,
    ping:         9,
    pong:         10
  },

  OPCODE_CODES:    [0, 1, 2, 8, 9, 10],
  MESSAGE_OPCODES: [0, 1, 2],
  OPENING_OPCODES: [1, 2],

  ERRORS: {
    normal_closure:       1000,
    going_away:           1001,
    protocol_error:       1002,
    unacceptable:         1003,
    encoding_error:       1007,
    policy_violation:     1008,
    too_large:            1009,
    extension_error:      1010,
    unexpected_condition: 1011
  },

  ERROR_CODES:        [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011],
  DEFAULT_ERROR_CODE: 1000,
  MIN_RESERVED_ERROR: 3000,
  MAX_RESERVED_ERROR: 4999,

  // http://www.w3.org/International/questions/qa-forms-utf-8.en.php
  UTF8_MATCH: /^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,

  addExtension: function(extension) {
    this._extensions.add(extension);
    return true;
  },

  parse: function(chunk) {
    this._reader.put(chunk);
    var buffer = true;
    while (buffer) {
      switch (this._stage) {
        case 0:
          buffer = this._reader.read(1);
          if (buffer) this._parseOpcode(buffer[0]);
          break;

        case 1:
          buffer = this._reader.read(1);
          if (buffer) this._parseLength(buffer[0]);
          break;

        case 2:
          buffer = this._reader.read(this._frame.lengthBytes);
          if (buffer) this._parseExtendedLength(buffer);
          break;

        case 3:
          buffer = this._reader.read(4);
          if (buffer) {
            this._stage = 4;
            this._frame.maskingKey = buffer;
          }
          break;

        case 4:
          buffer = this._reader.read(this._frame.length);
          if (buffer) {
            this._stage = 0;
            this._emitFrame(buffer);
          }
          break;

        default:
          buffer = null;
      }
    }
  },

  text: function(message) {
    if (this.readyState &gt; 1) return false;
    return this.frame(message, &#039;text&#039;);
  },

  binary: function(message) {
    if (this.readyState &gt; 1) return false;
    return this.frame(message, &#039;binary&#039;);
  },

  ping: function(message, callback) {
    if (this.readyState &gt; 1) return false;
    message = message || &#039;&#039;;
    if (callback) this._pingCallbacks[message] = callback;
    return this.frame(message, &#039;ping&#039;);
  },

  pong: function(message) {
      if (this.readyState &gt; 1) return false;
      message = message ||&#039;&#039;;
      return this.frame(message, &#039;pong&#039;);
  },

  close: function(reason, code) {
    reason = reason || &#039;&#039;;
    code   = code   || this.ERRORS.normal_closure;

    if (this.readyState &lt;= 0) {
      this.readyState = 3;
      this.emit(&#039;close&#039;, new Base.CloseEvent(code, reason));
      return true;
    } else if (this.readyState === 1) {
      this.readyState = 2;
      this._extensions.close(function() { this.frame(reason, &#039;close&#039;, code) }, this);
      return true;
    } else {
      return false;
    }
  },

  frame: function(buffer, type, code) {
    if (this.readyState &lt;= 0) return this._queue([buffer, type, code]);
    if (this.readyState &gt; 2) return false;

    if (buffer instanceof Array)    buffer = Buffer.from(buffer);
    if (typeof buffer === &#039;number&#039;) buffer = buffer.toString();

    var message = new Message(),
        isText  = (typeof buffer === &#039;string&#039;),
        payload, copy;

    message.rsv1   = message.rsv2 = message.rsv3 = false;
    message.opcode = this.OPCODES[type || (isText ? &#039;text&#039; : &#039;binary&#039;)];

    payload = isText ? Buffer.from(buffer, &#039;utf8&#039;) : buffer;

    if (code) {
      copy = payload;
      payload = Buffer.allocUnsafe(2 + copy.length);
      payload.writeUInt16BE(code, 0);
      copy.copy(payload, 2);
    }
    message.data = payload;

    var onMessageReady = function(message) {
      var frame = new Frame();

      frame.final   = true;
      frame.rsv1    = message.rsv1;
      frame.rsv2    = message.rsv2;
      frame.rsv3    = message.rsv3;
      frame.opcode  = message.opcode;
      frame.masked  = !!this._masking;
      frame.length  = message.data.length;
      frame.payload = message.data;

      if (frame.masked) frame.maskingKey = crypto.randomBytes(4);

      this._sendFrame(frame);
    };

    if (this.MESSAGE_OPCODES.indexOf(message.opcode) &gt;= 0)
      this._extensions.processOutgoingMessage(message, function(error, message) {
        if (error) return this._fail(&#039;extension_error&#039;, error.message);
        onMessageReady.call(this, message);
      }, this);
    else
      onMessageReady.call(this, message);

    return true;
  },

  _sendFrame: function(frame) {
    var length = frame.length,
        header = (length &lt;= 125) ? 2 : (length &lt;= 65535 ? 4 : 10),
        offset = header + (frame.masked ? 4 : 0),
        buffer = Buffer.allocUnsafe(offset + length),
        masked = frame.masked ? this.MASK : 0;

    buffer[0] = (frame.final ? this.FIN : 0) |
                (frame.rsv1 ? this.RSV1 : 0) |
                (frame.rsv2 ? this.RSV2 : 0) |
                (frame.rsv3 ? this.RSV3 : 0) |
                frame.opcode;

    if (length &lt;= 125) {
      buffer[1] = masked | length;
    } else if (length &lt;= 65535) {
      buffer[1] = masked | 126;
      buffer.writeUInt16BE(length, 2);
    } else {
      buffer[1] = masked | 127;
      buffer.writeUInt32BE(Math.floor(length / 0x100000000), 2);
      buffer.writeUInt32BE(length % 0x100000000, 6);
    }

    frame.payload.copy(buffer, offset);

    if (frame.masked) {
      frame.maskingKey.copy(buffer, header);
      Hybi.mask(buffer, frame.maskingKey, offset);
    }

    this._write(buffer);
  },

  _handshakeResponse: function() {
    var secKey  = this._request.headers[&#039;sec-websocket-key&#039;],
        version = this._request.headers[&#039;sec-websocket-version&#039;];

    if (version !== Hybi.VERSION)
      throw new Error(&#039;Unsupported WebSocket version: &#039; + version);

    if (typeof secKey !== &#039;string&#039;)
      throw new Error(&#039;Missing handshake request header: Sec-WebSocket-Key&#039;);

    this._headers.set(&#039;Upgrade&#039;, &#039;websocket&#039;);
    this._headers.set(&#039;Connection&#039;, &#039;Upgrade&#039;);
    this._headers.set(&#039;Sec-WebSocket-Accept&#039;, Hybi.generateAccept(secKey));

    if (this.protocol) this._headers.set(&#039;Sec-WebSocket-Protocol&#039;, this.protocol);

    var extensions = this._extensions.generateResponse(this._request.headers[&#039;sec-websocket-extensions&#039;]);
    if (extensions) this._headers.set(&#039;Sec-WebSocket-Extensions&#039;, extensions);

    var start   = &#039;HTTP/1.1 101 Switching Protocols&#039;,
        headers = [start, this._headers.toString(), &#039;&#039;];

    return Buffer.from(headers.join(&#039;\r\n&#039;), &#039;utf8&#039;);
  },

  _shutdown: function(code, reason, error) {
    delete this._frame;
    delete this._message;
    this._stage = 5;

    var sendCloseFrame = (this.readyState === 1);
    this.readyState = 2;

    this._extensions.close(function() {
      if (sendCloseFrame) this.frame(reason, &#039;close&#039;, code);
      this.readyState = 3;
      if (error) this.emit(&#039;error&#039;, new Error(reason));
      this.emit(&#039;close&#039;, new Base.CloseEvent(code, reason));
    }, this);
  },

  _fail: function(type, message) {
    if (this.readyState &gt; 1) return;
    this._shutdown(this.ERRORS[type], message, true);
  },

  _parseOpcode: function(octet) {
    var rsvs = [this.RSV1, this.RSV2, this.RSV3].map(function(rsv) {
      return (octet &amp; rsv) === rsv;
    });

    var frame = this._frame = new Frame();

    frame.final  = (octet &amp; this.FIN) === this.FIN;
    frame.rsv1   = rsvs[0];
    frame.rsv2   = rsvs[1];
    frame.rsv3   = rsvs[2];
    frame.opcode = (octet &amp; this.OPCODE);

    this._stage = 1;

    if (!this._extensions.validFrameRsv(frame))
      return this._fail(&#039;protocol_error&#039;,
          &#039;One or more reserved bits are on: reserved1 = &#039; + (frame.rsv1 ? 1 : 0) +
          &#039;, reserved2 = &#039; + (frame.rsv2 ? 1 : 0) +
          &#039;, reserved3 = &#039; + (frame.rsv3 ? 1 : 0));

    if (this.OPCODE_CODES.indexOf(frame.opcode) &lt; 0)
      return this._fail(&#039;protocol_error&#039;, &#039;Unrecognized frame opcode: &#039; + frame.opcode);

    if (this.MESSAGE_OPCODES.indexOf(frame.opcode) &lt; 0 &amp;&amp; !frame.final)
      return this._fail(&#039;protocol_error&#039;, &#039;Received fragmented control frame: opcode = &#039; + frame.opcode);

    if (this._message &amp;&amp; this.OPENING_OPCODES.indexOf(frame.opcode) &gt;= 0)
      return this._fail(&#039;protocol_error&#039;, &#039;Received new data frame but previous continuous frame is unfinished&#039;);
  },

  _parseLength: function(octet) {
    var frame = this._frame;
    frame.masked = (octet &amp; this.MASK) === this.MASK;
    frame.length = (octet &amp; this.LENGTH);

    if (frame.length &gt;= 0 &amp;&amp; frame.length &lt;= 125) {
      this._stage = frame.masked ? 3 : 4;
      if (!this._checkFrameLength()) return;
    } else {
      this._stage = 2;
      frame.lengthBytes = (frame.length === 126 ? 2 : 8);
    }

    if (this._requireMasking &amp;&amp; !frame.masked)
      return this._fail(&#039;unacceptable&#039;, &#039;Received unmasked frame but masking is required&#039;);
  },

  _parseExtendedLength: function(buffer) {
    var frame = this._frame;
    frame.length = this._readUInt(buffer);

    this._stage = frame.masked ? 3 : 4;

    if (this.MESSAGE_OPCODES.indexOf(frame.opcode) &lt; 0 &amp;&amp; frame.length &gt; 125)
      return this._fail(&#039;protocol_error&#039;, &#039;Received control frame having too long payload: &#039; + frame.length);

    if (!this._checkFrameLength()) return;
  },

  _checkFrameLength: function() {
    var length = this._message ? this._message.length : 0;

    if (length + this._frame.length &gt; this._maxLength) {
      this._fail(&#039;too_large&#039;, &#039;WebSocket frame length too large&#039;);
      return false;
    } else {
      return true;
    }
  },

  _emitFrame: function(buffer) {
    var frame   = this._frame,
        payload = frame.payload = Hybi.mask(buffer, frame.maskingKey),
        opcode  = frame.opcode,
        message,
        code, reason,
        callbacks, callback;

    delete this._frame;

    if (opcode === this.OPCODES.continuation) {
      if (!this._message) return this._fail(&#039;protocol_error&#039;, &#039;Received unexpected continuation frame&#039;);
      this._message.pushFrame(frame);
    }

    if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {
      this._message = new Message();
      this._message.pushFrame(frame);
    }

    if (frame.final &amp;&amp; this.MESSAGE_OPCODES.indexOf(opcode) &gt;= 0)
      return this._emitMessage(this._message);

    if (opcode === this.OPCODES.close) {
      code   = (payload.length &gt;= 2) ? payload.readUInt16BE(0) : null;
      reason = (payload.length &gt; 2) ? this._encode(payload.slice(2)) : null;

      if (!(payload.length === 0) &amp;&amp;
          !(code !== null &amp;&amp; code &gt;= this.MIN_RESERVED_ERROR &amp;&amp; code &lt;= this.MAX_RESERVED_ERROR) &amp;&amp;
          this.ERROR_CODES.indexOf(code) &lt; 0)
        code = this.ERRORS.protocol_error;

      if (payload.length &gt; 125 || (payload.length &gt; 2 &amp;&amp; !reason))
        code = this.ERRORS.protocol_error;

      this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || &#039;&#039;);
    }

    if (opcode === this.OPCODES.ping) {
      this.frame(payload, &#039;pong&#039;);
      this.emit(&#039;ping&#039;, new Base.PingEvent(payload.toString()))
    }

    if (opcode === this.OPCODES.pong) {
      callbacks = this._pingCallbacks;
      message   = this._encode(payload);
      callback  = callbacks[message];

      delete callbacks[message];
      if (callback) callback()

      this.emit(&#039;pong&#039;, new Base.PongEvent(payload.toString()))
    }
  },

  _emitMessage: function(message) {
    var message = this._message;
    message.read();

    delete this._message;

    this._extensions.processIncomingMessage(message, function(error, message) {
      if (error) return this._fail(&#039;extension_error&#039;, error.message);

      var payload = message.data;
      if (message.opcode === this.OPCODES.text) payload = this._encode(payload);

      if (payload === null)
        return this._fail(&#039;encoding_error&#039;, &#039;Could not decode a text frame as UTF-8&#039;);
      else
        this.emit(&#039;message&#039;, new Base.MessageEvent(payload));
    }, this);
  },

  _encode: function(buffer) {
    try {
      var string = buffer.toString(&#039;binary&#039;, 0, buffer.length);
      if (!this.UTF8_MATCH.test(string)) return null;
    } catch (e) {}
    return buffer.toString(&#039;utf8&#039;, 0, buffer.length);
  },

  _readUInt: function(buffer) {
    if (buffer.length === 2) return buffer.readUInt16BE(0);

    return buffer.readUInt32BE(0) * 0x100000000 +
           buffer.readUInt32BE(4);
  }
};

for (var key in instance)
  Hybi.prototype[key] = instance[key];

module.exports = Hybi;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
