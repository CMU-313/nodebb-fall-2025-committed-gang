<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/js-yaml/lib/js-yaml/dumper.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/js-yaml/lib/js-yaml/dumper.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">851</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">95.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

/*eslint-disable no-use-before-define*/

var common              = require(&#039;./common&#039;);
var YAMLException       = require(&#039;./exception&#039;);
var DEFAULT_FULL_SCHEMA = require(&#039;./schema/default_full&#039;);
var DEFAULT_SAFE_SCHEMA = require(&#039;./schema/default_safe&#039;);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* &quot; */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* &amp; */
var CHAR_SINGLE_QUOTE         = 0x27; /* &#039; */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* &gt; */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = &#039;\\0&#039;;
ESCAPE_SEQUENCES[0x07]   = &#039;\\a&#039;;
ESCAPE_SEQUENCES[0x08]   = &#039;\\b&#039;;
ESCAPE_SEQUENCES[0x09]   = &#039;\\t&#039;;
ESCAPE_SEQUENCES[0x0A]   = &#039;\\n&#039;;
ESCAPE_SEQUENCES[0x0B]   = &#039;\\v&#039;;
ESCAPE_SEQUENCES[0x0C]   = &#039;\\f&#039;;
ESCAPE_SEQUENCES[0x0D]   = &#039;\\r&#039;;
ESCAPE_SEQUENCES[0x1B]   = &#039;\\e&#039;;
ESCAPE_SEQUENCES[0x22]   = &#039;\\&quot;&#039;;
ESCAPE_SEQUENCES[0x5C]   = &#039;\\\\&#039;;
ESCAPE_SEQUENCES[0x85]   = &#039;\\N&#039;;
ESCAPE_SEQUENCES[0xA0]   = &#039;\\_&#039;;
ESCAPE_SEQUENCES[0x2028] = &#039;\\L&#039;;
ESCAPE_SEQUENCES[0x2029] = &#039;\\P&#039;;

var DEPRECATED_BOOLEANS_SYNTAX = [
  &#039;y&#039;, &#039;Y&#039;, &#039;yes&#039;, &#039;Yes&#039;, &#039;YES&#039;, &#039;on&#039;, &#039;On&#039;, &#039;ON&#039;,
  &#039;n&#039;, &#039;N&#039;, &#039;no&#039;, &#039;No&#039;, &#039;NO&#039;, &#039;off&#039;, &#039;Off&#039;, &#039;OFF&#039;
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index &lt; length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === &#039;!!&#039;) {
      tag = &#039;tag:yaml.org,2002:&#039; + tag.slice(2);
    }
    type = schema.compiledTypeMap[&#039;fallback&#039;][tag];

    if (type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character &lt;= 0xFF) {
    handle = &#039;x&#039;;
    length = 2;
  } else if (character &lt;= 0xFFFF) {
    handle = &#039;u&#039;;
    length = 4;
  } else if (character &lt;= 0xFFFFFFFF) {
    handle = &#039;U&#039;;
    length = 8;
  } else {
    throw new YAMLException(&#039;code point within a string may not be greater than 0xFFFFFFFF&#039;);
  }

  return &#039;\\&#039; + handle + common.repeat(&#039;0&#039;, length - string.length) + string;
}

function State(options) {
  this.schema        = options[&#039;schema&#039;] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options[&#039;indent&#039;] || 2));
  this.noArrayIndent = options[&#039;noArrayIndent&#039;] || false;
  this.skipInvalid   = options[&#039;skipInvalid&#039;] || false;
  this.flowLevel     = (common.isNothing(options[&#039;flowLevel&#039;]) ? -1 : options[&#039;flowLevel&#039;]);
  this.styleMap      = compileStyleMap(this.schema, options[&#039;styles&#039;] || null);
  this.sortKeys      = options[&#039;sortKeys&#039;] || false;
  this.lineWidth     = options[&#039;lineWidth&#039;] || 80;
  this.noRefs        = options[&#039;noRefs&#039;] || false;
  this.noCompatMode  = options[&#039;noCompatMode&#039;] || false;
  this.condenseFlow  = options[&#039;condenseFlow&#039;] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = &#039;&#039;;

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(&#039; &#039;, spaces),
      position = 0,
      next = -1,
      result = &#039;&#039;,
      line,
      length = string.length;

  while (position &lt; length) {
    next = string.indexOf(&#039;\n&#039;, position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length &amp;&amp; line !== &#039;\n&#039;) result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return &#039;\n&#039; + common.repeat(&#039; &#039;, state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index &lt; length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: &quot;any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory&quot;
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 &lt;= c &amp;&amp; c &lt;= 0x00007E)
      || ((0x000A1 &lt;= c &amp;&amp; c &lt;= 0x00D7FF) &amp;&amp; c !== 0x2028 &amp;&amp; c !== 0x2029)
      || ((0x0E000 &lt;= c &amp;&amp; c &lt;= 0x00FFFD) &amp;&amp; c !== 0xFEFF /* BOM */)
      ||  (0x10000 &lt;= c &amp;&amp; c &lt;= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) &amp;&amp; !isWhitespace(c)
    // byte-order-mark
    &amp;&amp; c !== 0xFEFF
    // b-char
    &amp;&amp; c !== CHAR_CARRIAGE_RETURN
    &amp;&amp; c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - &quot;:&quot; - &quot;#&quot;
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) &amp;&amp; c !== 0xFEFF
    // - c-flow-indicator
    &amp;&amp; c !== CHAR_COMMA
    &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    // - &quot;:&quot; - &quot;#&quot;
    // /* An ns-char preceding */ &quot;#&quot;
    &amp;&amp; c !== CHAR_COLON
    &amp;&amp; ((c !== CHAR_SHARP) || (prev &amp;&amp; isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) &amp;&amp; c !== 0xFEFF
    &amp;&amp; !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    &amp;&amp; c !== CHAR_MINUS
    &amp;&amp; c !== CHAR_QUESTION
    &amp;&amp; c !== CHAR_COLON
    &amp;&amp; c !== CHAR_COMMA
    &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&amp;” | “*” | “!” | “|” | “=” | “&gt;” | “&#039;” | “&quot;”
    &amp;&amp; c !== CHAR_SHARP
    &amp;&amp; c !== CHAR_AMPERSAND
    &amp;&amp; c !== CHAR_ASTERISK
    &amp;&amp; c !== CHAR_EXCLAMATION
    &amp;&amp; c !== CHAR_VERTICAL_LINE
    &amp;&amp; c !== CHAR_EQUALS
    &amp;&amp; c !== CHAR_GREATER_THAN
    &amp;&amp; c !== CHAR_SINGLE_QUOTE
    &amp;&amp; c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    &amp;&amp; c !== CHAR_PERCENT
    &amp;&amp; c !== CHAR_COMMERCIAL_AT
    &amp;&amp; c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 =&gt; no limit.
// Pre-conditions: str.length &gt; 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.
//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          &amp;&amp; !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i &lt; string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i &gt; 0 ? string.charCodeAt(i - 1) : null;
      plain = plain &amp;&amp; isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i &lt; string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
             string[previousLineBreak + 1] !== &#039; &#039;);
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i &gt; 0 ? string.charCodeAt(i - 1) : null;
      plain = plain &amp;&amp; isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;
      (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
       string[previousLineBreak + 1] !== &#039; &#039;));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they&#039;re more readable and they don&#039;t add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak &amp;&amp; !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string &#039;true&#039; vs. the boolean true.
    return plain &amp;&amp; !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel &gt; 9 &amp;&amp; needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.
//    • Ending newline    =&gt; removed then restored.
//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return &quot;&#039;&#039;&quot;;
    }
    if (!state.noCompatMode &amp;&amp;
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return &quot;&#039;&quot; + string + &quot;&#039;&quot;;
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel &gt; -1 &amp;&amp; level &gt;= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return &quot;&#039;&quot; + string.replace(/&#039;/g, &quot;&#039;&#039;&quot;) + &quot;&#039;&quot;;
      case STYLE_LITERAL:
        return &#039;|&#039; + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return &#039;&gt;&#039; + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return &#039;&quot;&#039; + escapeString(string, lineWidth) + &#039;&quot;&#039;;
      default:
        throw new YAMLException(&#039;impossible error: invalid scalar style&#039;);
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : &#039;&#039;;

  // note the special case: the string &#039;\n&#039; counts as a &quot;trailing&quot; empty line.
  var clip =          string[string.length - 1] === &#039;\n&#039;;
  var keep = clip &amp;&amp; (string[string.length - 2] === &#039;\n&#039; || string === &#039;\n&#039;);
  var chomp = keep ? &#039;+&#039; : (clip ? &#039;&#039; : &#039;-&#039;);

  return indentIndicator + chomp + &#039;\n&#039;;
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === &#039;\n&#039; ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they&#039;re before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf(&#039;\n&#039;);
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven&#039;t reached the first content line yet, don&#039;t add an extra \n.
  var prevMoreIndented = string[0] === &#039;\n&#039; || string[0] === &#039; &#039;;
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === &#039; &#039;);
    result += prefix
      + (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== &#039;&#039;
        ? &#039;\n&#039; : &#039;&#039;)
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === &#039;&#039; || line[0] === &#039; &#039;) return line;

  // Since a more-indented line adds a \n, breaks can&#039;t be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be &lt;= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = &#039;&#039;;

  // Invariants: 0 &lt;= start &lt;= length-1.
  //   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.
  // Inside the loop:
  //   A match implies length &gt;= 2, so curr and next are &lt;= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start &lt;= width
    if (next - start &gt; width) {
      end = (curr &gt; start) ? curr : next; // derive end &lt;= length-2
      result += &#039;\n&#039; + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start &lt;= length-1
    }
    curr = next;
  }

  // By the invariants, start &lt;= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += &#039;\n&#039;;
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start &gt; width &amp;&amp; curr &gt; start) {
    result += line.slice(start, curr) + &#039;\n&#039; + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = &#039;&#039;;
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i &lt; string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section &quot;3.7 Surrogates&quot;).
    if (char &gt;= 0xD800 &amp;&amp; char &lt;= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar &gt;= 0xDC00 &amp;&amp; nextChar &lt;= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq &amp;&amp; isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = &#039;&#039;,
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += &#039;,&#039; + (!state.condenseFlow ? &#039; &#039; : &#039;&#039;);
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = &#039;[&#039; + _result + &#039;]&#039;;
}

function writeBlockSequence(state, level, object, compact) {
  var _result = &#039;&#039;,
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += &#039;-&#039;;
      } else {
        _result += &#039;- &#039;;
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || &#039;[]&#039;; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = &#039;&#039;,
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {

    pairBuffer = &#039;&#039;;
    if (index !== 0) pairBuffer += &#039;, &#039;;

    if (state.condenseFlow) pairBuffer += &#039;&quot;&#039;;

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length &gt; 1024) pairBuffer += &#039;? &#039;;

    pairBuffer += state.dump + (state.condenseFlow ? &#039;&quot;&#039; : &#039;&#039;) + &#039;:&#039; + (state.condenseFlow ? &#039;&#039; : &#039; &#039;);

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = &#039;{&#039; + _result + &#039;}&#039;;
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = &#039;&#039;,
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === &#039;function&#039;) {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException(&#039;sortKeys must be a boolean or a function&#039;);
  }

  for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
    pairBuffer = &#039;&#039;;

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) ||
                   (state.dump &amp;&amp; state.dump.length &gt; 1024);

    if (explicitPair) {
      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += &#039;?&#039;;
      } else {
        pairBuffer += &#039;? &#039;;
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += &#039;:&#039;;
    } else {
      pairBuffer += &#039;: &#039;;
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || &#039;{}&#039;; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index &lt; length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &amp;&amp;
        (!type.instanceOf || ((typeof object === &#039;object&#039;) &amp;&amp; (object instanceof type.instanceOf))) &amp;&amp;
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : &#039;?&#039;;

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === &#039;[object Function]&#039;) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException(&#039;!&lt;&#039; + type.tag + &#039;&gt; tag resolver accepts not &quot;&#039; + style + &#039;&quot; style&#039;);
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel &lt; 0 || state.flowLevel &gt; level);
  }

  var objectOrArray = type === &#039;[object Object]&#039; || type === &#039;[object Array]&#039;,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) || duplicate || (state.indent !== 2 &amp;&amp; level &gt; 0)) {
    compact = false;
  }

  if (duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {
    state.dump = &#039;*ref_&#039; + duplicateIndex;
  } else {
    if (objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === &#039;[object Object]&#039;) {
      if (block &amp;&amp; (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
        }
      }
    } else if (type === &#039;[object Array]&#039;) {
      var arrayLevel = (state.noArrayIndent &amp;&amp; (level &gt; 0)) ? level - 1 : level;
      if (block &amp;&amp; (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
        }
      }
    } else if (type === &#039;[object String]&#039;) {
      if (state.tag !== &#039;?&#039;) {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException(&#039;unacceptable kind of an object to dump &#039; + type);
    }

    if (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) {
      state.dump = &#039;!&lt;&#039; + state.tag + &#039;&gt; &#039; + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index &lt; length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null &amp;&amp; typeof object === &#039;object&#039;) {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index &lt; length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + &#039;\n&#039;;

  return &#039;&#039;;
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
