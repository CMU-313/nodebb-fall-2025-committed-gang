<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/chokidar/handler.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/chokidar/handler.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">636</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.NodeFsHandler = exports.EVENTS = exports.isIBMi = exports.isFreeBSD = exports.isLinux = exports.isMacos = exports.isWindows = exports.IDENTITY_FN = exports.EMPTY_FN = exports.STR_CLOSE = exports.STR_END = exports.STR_DATA = void 0;
const fs_1 = require(&quot;fs&quot;);
const promises_1 = require(&quot;fs/promises&quot;);
const sysPath = require(&quot;path&quot;);
const os_1 = require(&quot;os&quot;);
exports.STR_DATA = &#039;data&#039;;
exports.STR_END = &#039;end&#039;;
exports.STR_CLOSE = &#039;close&#039;;
const EMPTY_FN = () =&gt; { };
exports.EMPTY_FN = EMPTY_FN;
const IDENTITY_FN = (val) =&gt; val;
exports.IDENTITY_FN = IDENTITY_FN;
const pl = process.platform;
exports.isWindows = pl === &#039;win32&#039;;
exports.isMacos = pl === &#039;darwin&#039;;
exports.isLinux = pl === &#039;linux&#039;;
exports.isFreeBSD = pl === &#039;freebsd&#039;;
exports.isIBMi = (0, os_1.type)() === &#039;OS400&#039;;
exports.EVENTS = {
    ALL: &#039;all&#039;,
    READY: &#039;ready&#039;,
    ADD: &#039;add&#039;,
    CHANGE: &#039;change&#039;,
    ADD_DIR: &#039;addDir&#039;,
    UNLINK: &#039;unlink&#039;,
    UNLINK_DIR: &#039;unlinkDir&#039;,
    RAW: &#039;raw&#039;,
    ERROR: &#039;error&#039;,
};
const EV = exports.EVENTS;
const THROTTLE_MODE_WATCH = &#039;watch&#039;;
const statMethods = { lstat: promises_1.lstat, stat: promises_1.stat };
const KEY_LISTENERS = &#039;listeners&#039;;
const KEY_ERR = &#039;errHandlers&#039;;
const KEY_RAW = &#039;rawEmitters&#039;;
const HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];
// prettier-ignore
const binaryExtensions = new Set([
    &#039;3dm&#039;, &#039;3ds&#039;, &#039;3g2&#039;, &#039;3gp&#039;, &#039;7z&#039;, &#039;a&#039;, &#039;aac&#039;, &#039;adp&#039;, &#039;afdesign&#039;, &#039;afphoto&#039;, &#039;afpub&#039;, &#039;ai&#039;,
    &#039;aif&#039;, &#039;aiff&#039;, &#039;alz&#039;, &#039;ape&#039;, &#039;apk&#039;, &#039;appimage&#039;, &#039;ar&#039;, &#039;arj&#039;, &#039;asf&#039;, &#039;au&#039;, &#039;avi&#039;,
    &#039;bak&#039;, &#039;baml&#039;, &#039;bh&#039;, &#039;bin&#039;, &#039;bk&#039;, &#039;bmp&#039;, &#039;btif&#039;, &#039;bz2&#039;, &#039;bzip2&#039;,
    &#039;cab&#039;, &#039;caf&#039;, &#039;cgm&#039;, &#039;class&#039;, &#039;cmx&#039;, &#039;cpio&#039;, &#039;cr2&#039;, &#039;cur&#039;, &#039;dat&#039;, &#039;dcm&#039;, &#039;deb&#039;, &#039;dex&#039;, &#039;djvu&#039;,
    &#039;dll&#039;, &#039;dmg&#039;, &#039;dng&#039;, &#039;doc&#039;, &#039;docm&#039;, &#039;docx&#039;, &#039;dot&#039;, &#039;dotm&#039;, &#039;dra&#039;, &#039;DS_Store&#039;, &#039;dsk&#039;, &#039;dts&#039;,
    &#039;dtshd&#039;, &#039;dvb&#039;, &#039;dwg&#039;, &#039;dxf&#039;,
    &#039;ecelp4800&#039;, &#039;ecelp7470&#039;, &#039;ecelp9600&#039;, &#039;egg&#039;, &#039;eol&#039;, &#039;eot&#039;, &#039;epub&#039;, &#039;exe&#039;,
    &#039;f4v&#039;, &#039;fbs&#039;, &#039;fh&#039;, &#039;fla&#039;, &#039;flac&#039;, &#039;flatpak&#039;, &#039;fli&#039;, &#039;flv&#039;, &#039;fpx&#039;, &#039;fst&#039;, &#039;fvt&#039;,
    &#039;g3&#039;, &#039;gh&#039;, &#039;gif&#039;, &#039;graffle&#039;, &#039;gz&#039;, &#039;gzip&#039;,
    &#039;h261&#039;, &#039;h263&#039;, &#039;h264&#039;, &#039;icns&#039;, &#039;ico&#039;, &#039;ief&#039;, &#039;img&#039;, &#039;ipa&#039;, &#039;iso&#039;,
    &#039;jar&#039;, &#039;jpeg&#039;, &#039;jpg&#039;, &#039;jpgv&#039;, &#039;jpm&#039;, &#039;jxr&#039;, &#039;key&#039;, &#039;ktx&#039;,
    &#039;lha&#039;, &#039;lib&#039;, &#039;lvp&#039;, &#039;lz&#039;, &#039;lzh&#039;, &#039;lzma&#039;, &#039;lzo&#039;,
    &#039;m3u&#039;, &#039;m4a&#039;, &#039;m4v&#039;, &#039;mar&#039;, &#039;mdi&#039;, &#039;mht&#039;, &#039;mid&#039;, &#039;midi&#039;, &#039;mj2&#039;, &#039;mka&#039;, &#039;mkv&#039;, &#039;mmr&#039;, &#039;mng&#039;,
    &#039;mobi&#039;, &#039;mov&#039;, &#039;movie&#039;, &#039;mp3&#039;,
    &#039;mp4&#039;, &#039;mp4a&#039;, &#039;mpeg&#039;, &#039;mpg&#039;, &#039;mpga&#039;, &#039;mxu&#039;,
    &#039;nef&#039;, &#039;npx&#039;, &#039;numbers&#039;, &#039;nupkg&#039;,
    &#039;o&#039;, &#039;odp&#039;, &#039;ods&#039;, &#039;odt&#039;, &#039;oga&#039;, &#039;ogg&#039;, &#039;ogv&#039;, &#039;otf&#039;, &#039;ott&#039;,
    &#039;pages&#039;, &#039;pbm&#039;, &#039;pcx&#039;, &#039;pdb&#039;, &#039;pdf&#039;, &#039;pea&#039;, &#039;pgm&#039;, &#039;pic&#039;, &#039;png&#039;, &#039;pnm&#039;, &#039;pot&#039;, &#039;potm&#039;,
    &#039;potx&#039;, &#039;ppa&#039;, &#039;ppam&#039;,
    &#039;ppm&#039;, &#039;pps&#039;, &#039;ppsm&#039;, &#039;ppsx&#039;, &#039;ppt&#039;, &#039;pptm&#039;, &#039;pptx&#039;, &#039;psd&#039;, &#039;pya&#039;, &#039;pyc&#039;, &#039;pyo&#039;, &#039;pyv&#039;,
    &#039;qt&#039;,
    &#039;rar&#039;, &#039;ras&#039;, &#039;raw&#039;, &#039;resources&#039;, &#039;rgb&#039;, &#039;rip&#039;, &#039;rlc&#039;, &#039;rmf&#039;, &#039;rmvb&#039;, &#039;rpm&#039;, &#039;rtf&#039;, &#039;rz&#039;,
    &#039;s3m&#039;, &#039;s7z&#039;, &#039;scpt&#039;, &#039;sgi&#039;, &#039;shar&#039;, &#039;snap&#039;, &#039;sil&#039;, &#039;sketch&#039;, &#039;slk&#039;, &#039;smv&#039;, &#039;snk&#039;, &#039;so&#039;,
    &#039;stl&#039;, &#039;suo&#039;, &#039;sub&#039;, &#039;swf&#039;,
    &#039;tar&#039;, &#039;tbz&#039;, &#039;tbz2&#039;, &#039;tga&#039;, &#039;tgz&#039;, &#039;thmx&#039;, &#039;tif&#039;, &#039;tiff&#039;, &#039;tlz&#039;, &#039;ttc&#039;, &#039;ttf&#039;, &#039;txz&#039;,
    &#039;udf&#039;, &#039;uvh&#039;, &#039;uvi&#039;, &#039;uvm&#039;, &#039;uvp&#039;, &#039;uvs&#039;, &#039;uvu&#039;,
    &#039;viv&#039;, &#039;vob&#039;,
    &#039;war&#039;, &#039;wav&#039;, &#039;wax&#039;, &#039;wbmp&#039;, &#039;wdp&#039;, &#039;weba&#039;, &#039;webm&#039;, &#039;webp&#039;, &#039;whl&#039;, &#039;wim&#039;, &#039;wm&#039;, &#039;wma&#039;,
    &#039;wmv&#039;, &#039;wmx&#039;, &#039;woff&#039;, &#039;woff2&#039;, &#039;wrm&#039;, &#039;wvx&#039;,
    &#039;xbm&#039;, &#039;xif&#039;, &#039;xla&#039;, &#039;xlam&#039;, &#039;xls&#039;, &#039;xlsb&#039;, &#039;xlsm&#039;, &#039;xlsx&#039;, &#039;xlt&#039;, &#039;xltm&#039;, &#039;xltx&#039;, &#039;xm&#039;,
    &#039;xmind&#039;, &#039;xpi&#039;, &#039;xpm&#039;, &#039;xwd&#039;, &#039;xz&#039;,
    &#039;z&#039;, &#039;zip&#039;, &#039;zipx&#039;,
]);
const isBinaryPath = (filePath) =&gt; binaryExtensions.has(sysPath.extname(filePath).slice(1).toLowerCase());
// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) =&gt; {
    if (val instanceof Set) {
        val.forEach(fn);
    }
    else {
        fn(val);
    }
};
const addAndConvert = (main, prop, item) =&gt; {
    let container = main[prop];
    if (!(container instanceof Set)) {
        main[prop] = container = new Set([container]);
    }
    container.add(item);
};
const clearItem = (cont) =&gt; (key) =&gt; {
    const set = cont[key];
    if (set instanceof Set) {
        set.clear();
    }
    else {
        delete cont[key];
    }
};
const delFromSet = (main, prop, item) =&gt; {
    const container = main[prop];
    if (container instanceof Set) {
        container.delete(item);
    }
    else if (container === item) {
        delete main[prop];
    }
};
const isEmptySet = (val) =&gt; (val instanceof Set ? val.size === 0 : !val);
const FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param path to be watched
 * @param options to be passed to fs_watch
 * @param listener main event handler
 * @param errHandler emits info about errors
 * @param emitRaw emits raw event data
 * @returns {NativeFsWatcher}
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
    const handleEvent = (rawEvent, evPath) =&gt; {
        listener(path);
        emitRaw(rawEvent, evPath, { watchedPath: path });
        // emit based on events occurring for files from a directory&#039;s watcher in
        // case the file&#039;s watcher misses it (and rely on throttling to de-dupe)
        if (evPath &amp;&amp; path !== evPath) {
            fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
        }
    };
    try {
        return (0, fs_1.watch)(path, {
            persistent: options.persistent,
        }, handleEvent);
    }
    catch (error) {
        errHandler(error);
        return undefined;
    }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param fullPath absolute path bound to fs_watch instance
 */
const fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) =&gt; {
    const cont = FsWatchInstances.get(fullPath);
    if (!cont)
        return;
    foreach(cont[listenerType], (listener) =&gt; {
        listener(val1, val2, val3);
    });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param path
 * @param fullPath absolute path
 * @param options to be passed to fs_watch
 * @param handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) =&gt; {
    const { listener, errHandler, rawEmitter } = handlers;
    let cont = FsWatchInstances.get(fullPath);
    let watcher;
    if (!options.persistent) {
        watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
        if (!watcher)
            return;
        return watcher.close.bind(watcher);
    }
    if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
    }
    else {
        watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
        fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
            return;
        watcher.on(EV.ERROR, async (error) =&gt; {
            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
            if (cont)
                cont.watcherUnusable = true; // documented since Node 10.4.1
            // Workaround for https://github.com/joyent/node/issues/4337
            if (exports.isWindows &amp;&amp; error.code === &#039;EPERM&#039;) {
                try {
                    const fd = await (0, promises_1.open)(path, &#039;r&#039;);
                    await fd.close();
                    broadcastErr(error);
                }
                catch (err) {
                    // do nothing
                }
            }
            else {
                broadcastErr(error);
            }
        });
        cont = {
            listeners: listener,
            errHandlers: errHandler,
            rawEmitters: rawEmitter,
            watcher,
        };
        FsWatchInstances.set(fullPath, cont);
    }
    // const index = cont.listeners.indexOf(listener);
    // removes this instance&#039;s listeners and closes the underlying fs_watch
    // instance if there are no more listeners left
    return () =&gt; {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
            // Check to protect against issue gh-730.
            // if (cont.watcherUnusable) {
            cont.watcher.close();
            // }
            FsWatchInstances.delete(fullPath);
            HANDLER_KEYS.forEach(clearItem(cont));
            // @ts-ignore
            cont.watcher = undefined;
            Object.freeze(cont);
        }
    };
};
// fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param path to be watched
 * @param fullPath absolute path
 * @param options options to be passed to fs_watchFile
 * @param handlers container for event listener functions
 * @returns closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) =&gt; {
    const { listener, rawEmitter } = handlers;
    let cont = FsWatchFileInstances.get(fullPath);
    // let listeners = new Set();
    // let rawEmitters = new Set();
    const copts = cont &amp;&amp; cont.options;
    if (copts &amp;&amp; (copts.persistent &lt; options.persistent || copts.interval &gt; options.interval)) {
        // &quot;Upgrade&quot; the watcher to persistence or a quicker interval.
        // This creates some unlikely edge case issues if the user mixes
        // settings in a very weird way, but solving for those cases
        // doesn&#039;t seem worthwhile for the added complexity.
        // listeners = cont.listeners;
        // rawEmitters = cont.rawEmitters;
        (0, fs_1.unwatchFile)(fullPath);
        cont = undefined;
    }
    if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
    }
    else {
        // TODO
        // listeners.add(listener);
        // rawEmitters.add(rawEmitter);
        cont = {
            listeners: listener,
            rawEmitters: rawEmitter,
            options,
            watcher: (0, fs_1.watchFile)(fullPath, options, (curr, prev) =&gt; {
                foreach(cont.rawEmitters, (rawEmitter) =&gt; {
                    rawEmitter(EV.CHANGE, fullPath, { curr, prev });
                });
                const currmtime = curr.mtimeMs;
                if (curr.size !== prev.size || currmtime &gt; prev.mtimeMs || currmtime === 0) {
                    foreach(cont.listeners, (listener) =&gt; listener(path, curr));
                }
            }),
        };
        FsWatchFileInstances.set(fullPath, cont);
    }
    // const index = cont.listeners.indexOf(listener);
    // Removes this instance&#039;s listeners and closes the underlying fs_watchFile
    // instance if there are no more listeners left.
    return () =&gt; {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
            FsWatchFileInstances.delete(fullPath);
            (0, fs_1.unwatchFile)(fullPath);
            cont.options = cont.watcher = undefined;
            Object.freeze(cont);
        }
    };
};
/**
 * @mixin
 */
class NodeFsHandler {
    constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) =&gt; fsW._handleError(error);
    }
    /**
     * Watch file for changes with fs_watchFile or fs_watch.
     * @param path to file or dir
     * @param listener on fs change
     * @returns closer for the watcher instance
     */
    _watchWithNodeFs(path, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path);
        const basename = sysPath.basename(path);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath.resolve(path);
        const options = {
            persistent: opts.persistent,
        };
        if (!listener)
            listener = exports.EMPTY_FN;
        let closer;
        if (opts.usePolling) {
            const enableBin = opts.interval !== opts.binaryInterval;
            options.interval = enableBin &amp;&amp; isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
            closer = setFsWatchFileListener(path, absolutePath, options, {
                listener,
                rawEmitter: this.fsw._emitRaw,
            });
        }
        else {
            closer = setFsWatchListener(path, absolutePath, options, {
                listener,
                errHandler: this._boundHandleError,
                rawEmitter: this.fsw._emitRaw,
            });
        }
        return closer;
    }
    /**
     * Watch a file and emit add event if warranted.
     * @returns closer for the watcher instance
     */
    _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
            return;
        }
        const dirname = sysPath.dirname(file);
        const basename = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        // stats is always present
        let prevStats = stats;
        // if the file is already being watched, do nothing
        if (parent.has(basename))
            return;
        const listener = async (path, newStats) =&gt; {
            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
                return;
            if (!newStats || newStats.mtimeMs === 0) {
                try {
                    const newStats = await (0, promises_1.stat)(file);
                    if (this.fsw.closed)
                        return;
                    // Check that change event was not fired because of changed only accessTime.
                    const at = newStats.atimeMs;
                    const mt = newStats.mtimeMs;
                    if (!at || at &lt;= mt || mt !== prevStats.mtimeMs) {
                        this.fsw._emit(EV.CHANGE, file, newStats);
                    }
                    if ((exports.isMacos || exports.isLinux || exports.isFreeBSD) &amp;&amp; prevStats.ino !== newStats.ino) {
                        this.fsw._closeFile(path);
                        prevStats = newStats;
                        const closer = this._watchWithNodeFs(file, listener);
                        if (closer)
                            this.fsw._addPathCloser(path, closer);
                    }
                    else {
                        prevStats = newStats;
                    }
                }
                catch (error) {
                    // Fix issues where mtime is null but file is still present
                    this.fsw._remove(dirname, basename);
                }
                // add is about to be emitted if file not already tracked in parent
            }
            else if (parent.has(basename)) {
                // Check that change event was not fired because of changed only accessTime.
                const at = newStats.atimeMs;
                const mt = newStats.mtimeMs;
                if (!at || at &lt;= mt || mt !== prevStats.mtimeMs) {
                    this.fsw._emit(EV.CHANGE, file, newStats);
                }
                prevStats = newStats;
            }
        };
        // kick off the watcher
        const closer = this._watchWithNodeFs(file, listener);
        // emit an add event if we&#039;re supposed to
        if (!(initialAdd &amp;&amp; this.fsw.options.ignoreInitial) &amp;&amp; this.fsw._isntIgnored(file)) {
            if (!this.fsw._throttle(EV.ADD, file, 0))
                return;
            this.fsw._emit(EV.ADD, file, stats);
        }
        return closer;
    }
    /**
     * Handle symlinks encountered while reading a dir.
     * @param entry returned by readdirp
     * @param directory path of dir being read
     * @param path of this item
     * @param item basename of this item
     * @returns true if no more processing is needed for this entry.
     */
    async _handleSymlink(entry, directory, path, item) {
        if (this.fsw.closed) {
            return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
            // watch symlink directly (don&#039;t follow) and detect changes
            this.fsw._incrReadyCount();
            let linkPath;
            try {
                linkPath = await (0, promises_1.realpath)(path);
            }
            catch (e) {
                this.fsw._emitReady();
                return true;
            }
            if (this.fsw.closed)
                return;
            if (dir.has(item)) {
                if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                    this.fsw._symlinkPaths.set(full, linkPath);
                    this.fsw._emit(EV.CHANGE, path, entry.stats);
                }
            }
            else {
                dir.add(item);
                this.fsw._symlinkPaths.set(full, linkPath);
                this.fsw._emit(EV.ADD, path, entry.stats);
            }
            this.fsw._emitReady();
            return true;
        }
        // don&#039;t follow the same symlink more than once
        if (this.fsw._symlinkPaths.has(full)) {
            return true;
        }
        this.fsw._symlinkPaths.set(full, true);
    }
    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        // Normalize the directory name on Windows
        directory = sysPath.join(directory, &#039;&#039;);
        throttler = this.fsw._throttle(&#039;readdir&#039;, directory, 1000);
        if (!throttler)
            return;
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = new Set();
        let stream = this.fsw._readdirp(directory, {
            fileFilter: (entry) =&gt; wh.filterPath(entry),
            directoryFilter: (entry) =&gt; wh.filterDir(entry),
        });
        if (!stream)
            return;
        stream
            .on(exports.STR_DATA, async (entry) =&gt; {
            if (this.fsw.closed) {
                stream = undefined;
                return;
            }
            const item = entry.path;
            let path = sysPath.join(directory, item);
            current.add(item);
            if (entry.stats.isSymbolicLink() &amp;&amp;
                (await this._handleSymlink(entry, directory, path, item))) {
                return;
            }
            if (this.fsw.closed) {
                stream = undefined;
                return;
            }
            // Files that present in current directory snapshot
            // but absent in previous are added to watch list and
            // emit `add` event.
            if (item === target || (!target &amp;&amp; !previous.has(item))) {
                this.fsw._incrReadyCount();
                // ensure relativeness of path is preserved in case of watcher reuse
                path = sysPath.join(dir, sysPath.relative(dir, path));
                this._addToNodeFs(path, initialAdd, wh, depth + 1);
            }
        })
            .on(EV.ERROR, this._boundHandleError);
        return new Promise((resolve, reject) =&gt; {
            if (!stream)
                return reject();
            stream.once(exports.STR_END, () =&gt; {
                if (this.fsw.closed) {
                    stream = undefined;
                    return;
                }
                const wasThrottled = throttler ? throttler.clear() : false;
                resolve(undefined);
                // Files that absent in current directory snapshot
                // but present in previous emit `remove` event
                // and are removed from @watched[directory].
                previous
                    .getChildren()
                    .filter((item) =&gt; {
                    return item !== directory &amp;&amp; !current.has(item);
                })
                    .forEach((item) =&gt; {
                    this.fsw._remove(directory, item);
                });
                stream = undefined;
                // one more time for any missed in case changes came in extremely quickly
                if (wasThrottled)
                    this._handleRead(directory, false, wh, target, dir, depth, throttler);
            });
        });
    }
    /**
     * Read directory to add / remove files from `@watched` list and re-read it on change.
     * @param dir fs path
     * @param stats
     * @param initialAdd
     * @param depth relative to user-supplied path
     * @param target child path targeted for watch
     * @param wh Common watch helpers for this path
     * @param realpath
     * @returns closer for the watcher instance.
     */
    async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd &amp;&amp; this.fsw.options.ignoreInitial) &amp;&amp; !target &amp;&amp; !tracked) {
            this.fsw._emit(EV.ADD_DIR, dir, stats);
        }
        // ensure dir is tracked (harmless if redundant)
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth &lt;= oDepth) &amp;&amp; !this.fsw._symlinkPaths.has(realpath)) {
            if (!target) {
                await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
                if (this.fsw.closed)
                    return;
            }
            closer = this._watchWithNodeFs(dir, (dirPath, stats) =&gt; {
                // if current directory is removed, do nothing
                if (stats &amp;&amp; stats.mtimeMs === 0)
                    return;
                this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
            });
        }
        return closer;
    }
    /**
     * Handle added file, directory, or glob pattern.
     * Delegates call to _handleFile / _handleDir after checks.
     * @param path to file or ir
     * @param initialAdd was the file added at watch instantiation?
     * @param priorWh depth relative to user-supplied path
     * @param depth Child path actually targeted for watch
     * @param target Child path actually targeted for watch
     */
    async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path) || this.fsw.closed) {
            ready();
            return false;
        }
        const wh = this.fsw._getWatchHelpers(path);
        if (priorWh) {
            wh.filterPath = (entry) =&gt; priorWh.filterPath(entry);
            wh.filterDir = (entry) =&gt; priorWh.filterDir(entry);
        }
        // evaluate what is at the path we&#039;re being asked to watch
        try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
                return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
                ready();
                return false;
            }
            const follow = this.fsw.options.followSymlinks;
            let closer;
            if (stats.isDirectory()) {
                const absPath = sysPath.resolve(path);
                const targetPath = follow ? await (0, promises_1.realpath)(path) : path;
                if (this.fsw.closed)
                    return;
                closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
                if (this.fsw.closed)
                    return;
                // preserve this symlink&#039;s target path
                if (absPath !== targetPath &amp;&amp; targetPath !== undefined) {
                    this.fsw._symlinkPaths.set(absPath, targetPath);
                }
            }
            else if (stats.isSymbolicLink()) {
                const targetPath = follow ? await (0, promises_1.realpath)(path) : path;
                if (this.fsw.closed)
                    return;
                const parent = sysPath.dirname(wh.watchPath);
                this.fsw._getWatchedDir(parent).add(wh.watchPath);
                this.fsw._emit(EV.ADD, wh.watchPath, stats);
                closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
                if (this.fsw.closed)
                    return;
                // preserve this symlink&#039;s target path
                if (targetPath !== undefined) {
                    this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);
                }
            }
            else {
                closer = this._handleFile(wh.watchPath, stats, initialAdd);
            }
            ready();
            if (closer)
                this.fsw._addPathCloser(path, closer);
            return false;
        }
        catch (error) {
            if (this.fsw._handleError(error)) {
                ready();
                return path;
            }
        }
    }
}
exports.NodeFsHandler = NodeFsHandler;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
