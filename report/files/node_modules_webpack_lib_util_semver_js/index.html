<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/util/semver.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/util/semver.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">603</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">120.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.79</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

/** @typedef {import(&quot;../RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {string | number | undefined} SemVerRangeItem */
/** @typedef {(SemVerRangeItem | SemVerRangeItem[])[]} SemVerRange */

/**
 * @param {string} str version string
 * @returns {SemVerRange} parsed version
 */
const parseVersion = str =&gt; {
	/**
	 * @param {str} str str
	 * @returns {(string | number)[]} result
	 */
	var splitAndConvert = function (str) {
		return str.split(&quot;.&quot;).map(function (item) {
			// eslint-disable-next-line eqeqeq
			return +item == /** @type {EXPECTED_ANY} */ (item) ? +item : item;
		});
	};

	var match =
		/** @type {RegExpExecArray} */
		(/^([^-+]+)?(?:-([^+]+))?(?:\+(.+))?$/.exec(str));

	/** @type {(string | number | undefined | [])[]} */
	var ver = match[1] ? splitAndConvert(match[1]) : [];

	if (match[2]) {
		ver.length++;
		ver.push.apply(ver, splitAndConvert(match[2]));
	}

	if (match[3]) {
		ver.push([]);
		ver.push.apply(ver, splitAndConvert(match[3]));
	}

	return ver;
};
module.exports.parseVersion = parseVersion;

/* eslint-disable eqeqeq */
/**
 * @param {string} a version
 * @param {string} b version
 * @returns {boolean} true, iff a &lt; b
 */
const versionLt = (a, b) =&gt; {
	// @ts-expect-error
	a = parseVersion(a);
	// @ts-expect-error
	b = parseVersion(b);
	var i = 0;
	for (;;) {
		// a       b  EOA     object  undefined  number  string
		// EOA        a == b  a &lt; b   b &lt; a      a &lt; b   a &lt; b
		// object     b &lt; a   (0)     b &lt; a      a &lt; b   a &lt; b
		// undefined  a &lt; b   a &lt; b   (0)        a &lt; b   a &lt; b
		// number     b &lt; a   b &lt; a   b &lt; a      (1)     a &lt; b
		// string     b &lt; a   b &lt; a   b &lt; a      b &lt; a   (1)
		// EOA end of array
		// (0) continue on
		// (1) compare them via &quot;&lt;&quot;

		// Handles first row in table
		if (i &gt;= a.length) return i &lt; b.length &amp;&amp; (typeof b[i])[0] != &quot;u&quot;;

		var aValue = a[i];
		var aType = (typeof aValue)[0];

		// Handles first column in table
		if (i &gt;= b.length) return aType == &quot;u&quot;;

		var bValue = b[i];
		var bType = (typeof bValue)[0];

		if (aType == bType) {
			if (aType != &quot;o&quot; &amp;&amp; aType != &quot;u&quot; &amp;&amp; aValue != bValue) {
				return aValue &lt; bValue;
			}
			i++;
		} else {
			// Handles remaining cases
			if (aType == &quot;o&quot; &amp;&amp; bType == &quot;n&quot;) return true;
			return bType == &quot;s&quot; || aType == &quot;u&quot;;
		}
	}
};
/* eslint-enable eqeqeq */
module.exports.versionLt = versionLt;

/**
 * @param {string} str range string
 * @returns {SemVerRange} parsed range
 */
module.exports.parseRange = str =&gt; {
	/**
	 * @param {string} str str
	 * @returns {(string | number)[]} result
	 */
	const splitAndConvert = str =&gt; {
		return str
			.split(&quot;.&quot;)
			.map(item =&gt; (item !== &quot;NaN&quot; &amp;&amp; `${+item}` === item ? +item : item));
	};

	// see https://docs.npmjs.com/misc/semver#range-grammar for grammar
	/**
	 * @param {string} str str
	 * @returns {SemVerRangeItem[]}
	 */
	const parsePartial = str =&gt; {
		const match =
			/** @type {RegExpExecArray} */
			(/^([^-+]+)?(?:-([^+]+))?(?:\+(.+))?$/.exec(str));
		/** @type {SemVerRangeItem[]} */
		const ver = match[1] ? [0, ...splitAndConvert(match[1])] : [0];

		if (match[2]) {
			ver.length++;
			ver.push.apply(ver, splitAndConvert(match[2]));
		}

		// remove trailing any matchers
		let last = ver[ver.length - 1];
		while (
			ver.length &amp;&amp;
			(last === undefined || /^[*xX]$/.test(/** @type {string} */ (last)))
		) {
			ver.pop();
			last = ver[ver.length - 1];
		}

		return ver;
	};

	/**
	 *
	 * @param {SemVerRangeItem[]} range range
	 * @returns {SemVerRangeItem[]}
	 */
	const toFixed = range =&gt; {
		if (range.length === 1) {
			// Special case for &quot;*&quot; is &quot;x.x.x&quot; instead of &quot;=&quot;
			return [0];
		} else if (range.length === 2) {
			// Special case for &quot;1&quot; is &quot;1.x.x&quot; instead of &quot;=1&quot;
			return [1, ...range.slice(1)];
		} else if (range.length === 3) {
			// Special case for &quot;1.2&quot; is &quot;1.2.x&quot; instead of &quot;=1.2&quot;
			return [2, ...range.slice(1)];
		}

		return [range.length, ...range.slice(1)];
	};

	/**
	 *
	 * @param {SemVerRangeItem[]} range
	 * @returns {SemVerRangeItem[]} result
	 */
	const negate = range =&gt; {
		return [-(/** @type { [number]} */ (range)[0]) - 1, ...range.slice(1)];
	};

	/**
	 * @param {string} str str
	 * @returns {SemVerRange}
	 */
	const parseSimple = str =&gt; {
		// simple       ::= primitive | partial | tilde | caret
		// primitive    ::= ( &#039;&lt;&#039; | &#039;&gt;&#039; | &#039;&gt;=&#039; | &#039;&lt;=&#039; | &#039;=&#039; | &#039;!&#039; ) ( &#039; &#039; ) * partial
		// tilde        ::= &#039;~&#039; ( &#039; &#039; ) * partial
		// caret        ::= &#039;^&#039; ( &#039; &#039; ) * partial
		const match = /^(\^|~|&lt;=|&lt;|&gt;=|&gt;|=|v|!)/.exec(str);
		const start = match ? match[0] : &quot;&quot;;
		const remainder = parsePartial(
			start.length ? str.slice(start.length).trim() : str.trim()
		);

		switch (start) {
			case &quot;^&quot;:
				if (remainder.length &gt; 1 &amp;&amp; remainder[1] === 0) {
					if (remainder.length &gt; 2 &amp;&amp; remainder[2] === 0) {
						return [3, ...remainder.slice(1)];
					}
					return [2, ...remainder.slice(1)];
				}
				return [1, ...remainder.slice(1)];
			case &quot;~&quot;:
				if (remainder.length === 2 &amp;&amp; remainder[0] === 0) {
					return [1, ...remainder.slice(1)];
				}
				return [2, ...remainder.slice(1)];
			case &quot;&gt;=&quot;:
				return remainder;
			case &quot;=&quot;:
			case &quot;v&quot;:
			case &quot;&quot;:
				return toFixed(remainder);
			case &quot;&lt;&quot;:
				return negate(remainder);
			case &quot;&gt;&quot;: {
				// and( &gt;=, not( = ) ) =&gt; &gt;=, =, not, and
				const fixed = toFixed(remainder);
				// eslint-disable-next-line no-sparse-arrays
				return [, fixed, 0, remainder, 2];
			}
			case &quot;&lt;=&quot;:
				// or( &lt;, = ) =&gt; &lt;, =, or
				// eslint-disable-next-line no-sparse-arrays
				return [, toFixed(remainder), negate(remainder), 1];
			case &quot;!&quot;: {
				// not =
				const fixed = toFixed(remainder);
				// eslint-disable-next-line no-sparse-arrays
				return [, fixed, 0];
			}
			default:
				throw new Error(&quot;Unexpected start value&quot;);
		}
	};

	/**
	 *
	 * @param {SemVerRangeItem[][]} items items
	 * @param {number} fn fn
	 * @returns {SemVerRange} result
	 */
	const combine = (items, fn) =&gt; {
		if (items.length === 1) return items[0];
		const arr = [];
		for (const item of items.slice().reverse()) {
			if (0 in item) {
				arr.push(item);
			} else {
				arr.push(...item.slice(1));
			}
		}

		// eslint-disable-next-line no-sparse-arrays
		return [, ...arr, ...items.slice(1).map(() =&gt; fn)];
	};

	/**
	 * @param {string} str str
	 * @returns {SemVerRange}
	 */
	const parseRange = str =&gt; {
		// range      ::= hyphen | simple ( &#039; &#039; ( &#039; &#039; ) * simple ) * | &#039;&#039;
		// hyphen     ::= partial ( &#039; &#039; ) * &#039; - &#039; ( &#039; &#039; ) * partial
		const items = str.split(/\s+-\s+/);

		if (items.length === 1) {
			str = str.trim();

			/** @type {SemVerRangeItem[][]} */
			const items = [];
			const r = /[-0-9A-Za-z]\s+/g;
			var start = 0;
			var match;
			while ((match = r.exec(str))) {
				const end = match.index + 1;
				items.push(
					/** @type {SemVerRangeItem[]} */
					(parseSimple(str.slice(start, end).trim()))
				);
				start = end;
			}
			items.push(
				/** @type {SemVerRangeItem[]} */
				(parseSimple(str.slice(start).trim()))
			);
			return combine(items, 2);
		}

		const a = parsePartial(items[0]);
		const b = parsePartial(items[1]);
		// &gt;=a &lt;=b =&gt; and( &gt;=a, or( &lt;b, =b ) ) =&gt; &gt;=a, &lt;b, =b, or, and
		// eslint-disable-next-line no-sparse-arrays
		return [, toFixed(b), negate(b), 1, a, 2];
	};

	/**
	 * @param {string} str str
	 * @returns {SemVerRange}
	 */
	const parseLogicalOr = str =&gt; {
		// range-set  ::= range ( logical-or range ) *
		// logical-or ::= ( &#039; &#039; ) * &#039;||&#039; ( &#039; &#039; ) *
		const items =
			/** @type {SemVerRangeItem[][]} */
			(str.split(/\s*\|\|\s*/).map(parseRange));

		return combine(items, 1);
	};

	return parseLogicalOr(str);
};

/* eslint-disable eqeqeq */
/**
 * @param {SemVerRange} range
 * @returns {string}
 */
const rangeToString = range =&gt; {
	var fixCount = /** @type {number} */ (range[0]);
	var str = &quot;&quot;;
	if (range.length === 1) {
		return &quot;*&quot;;
	} else if (fixCount + 0.5) {
		str +=
			fixCount == 0
				? &quot;&gt;=&quot;
				: fixCount == -1
					? &quot;&lt;&quot;
					: fixCount == 1
						? &quot;^&quot;
						: fixCount == 2
							? &quot;~&quot;
							: fixCount &gt; 0
								? &quot;=&quot;
								: &quot;!=&quot;;
		var needDot = 1;
		for (var i = 1; i &lt; range.length; i++) {
			var item = range[i];
			var t = (typeof item)[0];
			needDot--;
			str +=
				t == &quot;u&quot;
					? // undefined: prerelease marker, add an &quot;-&quot;
						&quot;-&quot;
					: // number or string: add the item, set flag to add an &quot;.&quot; between two of them
						(needDot &gt; 0 ? &quot;.&quot; : &quot;&quot;) + ((needDot = 2), item);
		}
		return str;
	}
	/** @type {string[]} */
	var stack = [];
	// eslint-disable-next-line no-redeclare
	for (var i = 1; i &lt; range.length; i++) {
		// eslint-disable-next-line no-redeclare
		var item = range[i];
		stack.push(
			item === 0
				? &quot;not(&quot; + pop() + &quot;)&quot;
				: item === 1
					? &quot;(&quot; + pop() + &quot; || &quot; + pop() + &quot;)&quot;
					: item === 2
						? stack.pop() + &quot; &quot; + stack.pop()
						: rangeToString(/** @type {SemVerRange} */ (item))
		);
	}
	return pop();

	function pop() {
		return /** @type {string} */ (stack.pop()).replace(/^\((.+)\)$/, &quot;$1&quot;);
	}
};

module.exports.rangeToString = rangeToString;

/**
 * @param {SemVerRange} range version range
 * @param {string} version the version
 * @returns {boolean} if version satisfy the range
 */
const satisfy = (range, version) =&gt; {
	if (0 in range) {
		// @ts-expect-error
		version = parseVersion(version);
		var fixCount = /** @type {number} */ (range[0]);
		// when negated is set it swill set for &lt; instead of &gt;=
		var negated = fixCount &lt; 0;
		if (negated) fixCount = -fixCount - 1;
		for (var i = 0, j = 1, isEqual = true; ; j++, i++) {
			// cspell:word nequal nequ

			// when isEqual = true:
			// range         version: EOA/object  undefined  number    string
			// EOA                    equal       block      big-ver   big-ver
			// undefined              bigger      next       big-ver   big-ver
			// number                 smaller     block      cmp       big-cmp
			// fixed number           smaller     block      cmp-fix   differ
			// string                 smaller     block      differ    cmp
			// fixed string           smaller     block      small-cmp cmp-fix

			// when isEqual = false:
			// range         version: EOA/object  undefined  number    string
			// EOA                    nequal      block      next-ver  next-ver
			// undefined              nequal      block      next-ver  next-ver
			// number                 nequal      block      next      next
			// fixed number           nequal      block      next      next   (this never happens)
			// string                 nequal      block      next      next
			// fixed string           nequal      block      next      next   (this never happens)

			// EOA end of array
			// equal (version is equal range):
			//   when !negated: return true,
			//   when negated: return false
			// bigger (version is bigger as range):
			//   when fixed: return false,
			//   when !negated: return true,
			//   when negated: return false,
			// smaller (version is smaller as range):
			//   when !negated: return false,
			//   when negated: return true
			// nequal (version is not equal range (&gt; resp &lt;)): return true
			// block (version is in different prerelease area): return false
			// differ (version is different from fixed range (string vs. number)): return false
			// next: continues to the next items
			// next-ver: when fixed: return false, continues to the next item only for the version, sets isEqual=false
			// big-ver: when fixed || negated: return false, continues to the next item only for the version, sets isEqual=false
			// next-nequ: continues to the next items, sets isEqual=false
			// cmp (negated === false): version &lt; range =&gt; return false, version &gt; range =&gt; next-nequ, else =&gt; next
			// cmp (negated === true): version &gt; range =&gt; return false, version &lt; range =&gt; next-nequ, else =&gt; next
			// cmp-fix: version == range =&gt; next, else =&gt; return false
			// big-cmp: when negated =&gt; return false, else =&gt; next-nequ
			// small-cmp: when negated =&gt; next-nequ, else =&gt; return false

			var rangeType =
				/** @type {&quot;s&quot; | &quot;n&quot; | &quot;u&quot; | &quot;&quot;} */
				(j &lt; range.length ? (typeof range[j])[0] : &quot;&quot;);

			/** @type {number | string | undefined} */
			var versionValue;
			/** @type {&quot;n&quot; | &quot;s&quot; | &quot;u&quot; | &quot;o&quot; | undefined} */
			var versionType;

			// Handles first column in both tables (end of version or object)
			if (
				i &gt;= version.length ||
				((versionValue = version[i]),
				(versionType = /** @type {&quot;n&quot; | &quot;s&quot; | &quot;u&quot; | &quot;o&quot;} */ (
					(typeof versionValue)[0]
				)) == &quot;o&quot;)
			) {
				// Handles nequal
				if (!isEqual) return true;
				// Handles bigger
				if (rangeType == &quot;u&quot;) return j &gt; fixCount &amp;&amp; !negated;
				// Handles equal and smaller: (range === EOA) XOR negated
				return (rangeType == &quot;&quot;) != negated; // equal + smaller
			}

			// Handles second column in both tables (version = undefined)
			if (versionType == &quot;u&quot;) {
				if (!isEqual || rangeType != &quot;u&quot;) {
					return false;
				}
			}

			// switch between first and second table
			else if (isEqual) {
				// Handle diagonal
				if (rangeType == versionType) {
					if (j &lt;= fixCount) {
						// Handles &quot;cmp-fix&quot; cases
						if (versionValue != range[j]) {
							return false;
						}
					} else {
						// Handles &quot;cmp&quot; cases
						if (
							negated
								? versionValue &gt; /** @type {(number | string)[]} */ (range)[j]
								: versionValue &lt; /** @type {(number | string)[]} */ (range)[j]
						) {
							return false;
						}
						if (versionValue != range[j]) isEqual = false;
					}
				}

				// Handle big-ver
				else if (rangeType != &quot;s&quot; &amp;&amp; rangeType != &quot;n&quot;) {
					if (negated || j &lt;= fixCount) return false;
					isEqual = false;
					j--;
				}

				// Handle differ, big-cmp and small-cmp
				else if (j &lt;= fixCount || versionType &lt; rangeType != negated) {
					return false;
				} else {
					isEqual = false;
				}
			} else {
				// Handles all &quot;next-ver&quot; cases in the second table
				// eslint-disable-next-line no-lonely-if
				if (rangeType != &quot;s&quot; &amp;&amp; rangeType != &quot;n&quot;) {
					isEqual = false;
					j--;
				}

				// next is applied by default
			}
		}
	}

	/** @type {(boolean | number)[]} */
	var stack = [];
	var p = stack.pop.bind(stack);
	// eslint-disable-next-line no-redeclare
	for (var i = 1; i &lt; range.length; i++) {
		var item = /** @type {SemVerRangeItem[] | 0 | 1 | 2} */ (range[i]);

		stack.push(
			item == 1
				? /** @type {() =&gt; number} */ (p)() | /** @type {() =&gt; number} */ (p)()
				: item == 2
					? /** @type {() =&gt; number} */ (p)() &amp;
						/** @type {() =&gt; number} */ (p)()
					: item
						? satisfy(item, version)
						: !p()
		);
	}
	return !!p();
};
/* eslint-enable eqeqeq */
module.exports.satisfy = satisfy;

/**
 * @param {SemVerRange | string | number | false | undefined} json
 * @returns {string}
 */
module.exports.stringifyHoley = json =&gt; {
	switch (typeof json) {
		case &quot;undefined&quot;:
			return &quot;&quot;;
		case &quot;object&quot;:
			if (Array.isArray(json)) {
				let str = &quot;[&quot;;
				for (let i = 0; i &lt; json.length; i++) {
					if (i !== 0) str += &quot;,&quot;;
					str += this.stringifyHoley(json[i]);
				}
				str += &quot;]&quot;;
				return str;
			}

			return JSON.stringify(json);
		default:
			return JSON.stringify(json);
	}
};

//#region runtime code: parseVersion
/**
 * @param {RuntimeTemplate} runtimeTemplate
 * @returns {string}
 */
exports.parseVersionRuntimeCode = runtimeTemplate =&gt;
	`var parseVersion = ${runtimeTemplate.basicFunction(&quot;str&quot;, [
		&quot;// see webpack/lib/util/semver.js for original code&quot;,
		`var p=${runtimeTemplate.supportsArrowFunction() ? &quot;p=&gt;&quot; : &quot;function(p)&quot;}{return p.split(&quot;.&quot;).map((${runtimeTemplate.supportsArrowFunction() ? &quot;p=&gt;&quot; : &quot;function(p)&quot;}{return+p==p?+p:p}))},n=/^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str),r=n[1]?p(n[1]):[];return n[2]&amp;&amp;(r.length++,r.push.apply(r,p(n[2]))),n[3]&amp;&amp;(r.push([]),r.push.apply(r,p(n[3]))),r;`
	])}`;
//#endregion

//#region runtime code: versionLt
/**
 * @param {RuntimeTemplate} runtimeTemplate
 * @returns {string}
 */
exports.versionLtRuntimeCode = runtimeTemplate =&gt;
	`var versionLt = ${runtimeTemplate.basicFunction(&quot;a, b&quot;, [
		&quot;// see webpack/lib/util/semver.js for original code&quot;,
		&#039;a=parseVersion(a),b=parseVersion(b);for(var r=0;;){if(r&gt;=a.length)return r&lt;b.length&amp;&amp;&quot;u&quot;!=(typeof b[r])[0];var e=a[r],n=(typeof e)[0];if(r&gt;=b.length)return&quot;u&quot;==n;var t=b[r],f=(typeof t)[0];if(n!=f)return&quot;o&quot;==n&amp;&amp;&quot;n&quot;==f||(&quot;s&quot;==f||&quot;u&quot;==n);if(&quot;o&quot;!=n&amp;&amp;&quot;u&quot;!=n&amp;&amp;e!=t)return e&lt;t;r++}&#039;
	])}`;
//#endregion

//#region runtime code: rangeToString
/**
 * @param {RuntimeTemplate} runtimeTemplate
 * @returns {string}
 */
exports.rangeToStringRuntimeCode = runtimeTemplate =&gt;
	`var rangeToString = ${runtimeTemplate.basicFunction(&quot;range&quot;, [
		&quot;// see webpack/lib/util/semver.js for original code&quot;,
		&#039;var r=range[0],n=&quot;&quot;;if(1===range.length)return&quot;*&quot;;if(r+.5){n+=0==r?&quot;&gt;=&quot;:-1==r?&quot;&lt;&quot;:1==r?&quot;^&quot;:2==r?&quot;~&quot;:r&gt;0?&quot;=&quot;:&quot;!=&quot;;for(var e=1,a=1;a&lt;range.length;a++){e--,n+=&quot;u&quot;==(typeof(t=range[a]))[0]?&quot;-&quot;:(e&gt;0?&quot;.&quot;:&quot;&quot;)+(e=2,t)}return n}var g=[];for(a=1;a&lt;range.length;a++){var t=range[a];g.push(0===t?&quot;not(&quot;+o()+&quot;)&quot;:1===t?&quot;(&quot;+o()+&quot; || &quot;+o()+&quot;)&quot;:2===t?g.pop()+&quot; &quot;+g.pop():rangeToString(t))}return o();function o(){return g.pop().replace(/^\\((.+)\\)$/,&quot;$1&quot;)}&#039;
	])}`;
//#endregion

//#region runtime code: satisfy
/**
 * @param {RuntimeTemplate} runtimeTemplate
 * @returns {string}
 */
exports.satisfyRuntimeCode = runtimeTemplate =&gt;
	`var satisfy = ${runtimeTemplate.basicFunction(&quot;range, version&quot;, [
		&quot;// see webpack/lib/util/semver.js for original code&quot;,
		&#039;if(0 in range){version=parseVersion(version);var e=range[0],r=e&lt;0;r&amp;&amp;(e=-e-1);for(var n=0,i=1,a=!0;;i++,n++){var f,s,g=i&lt;range.length?(typeof range[i])[0]:&quot;&quot;;if(n&gt;=version.length||&quot;o&quot;==(s=(typeof(f=version[n]))[0]))return!a||(&quot;u&quot;==g?i&gt;e&amp;&amp;!r:&quot;&quot;==g!=r);if(&quot;u&quot;==s){if(!a||&quot;u&quot;!=g)return!1}else if(a)if(g==s)if(i&lt;=e){if(f!=range[i])return!1}else{if(r?f&gt;range[i]:f&lt;range[i])return!1;f!=range[i]&amp;&amp;(a=!1)}else if(&quot;s&quot;!=g&amp;&amp;&quot;n&quot;!=g){if(r||i&lt;=e)return!1;a=!1,i--}else{if(i&lt;=e||s&lt;g!=r)return!1;a=!1}else&quot;s&quot;!=g&amp;&amp;&quot;n&quot;!=g&amp;&amp;(a=!1,i--)}}var t=[],o=t.pop.bind(t);for(n=1;n&lt;range.length;n++){var u=range[n];t.push(1==u?o()|o():2==u?o()&amp;o():u?satisfy(u,version):!o())}return!!o();&#039;
	])}`;
//#endregion
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
