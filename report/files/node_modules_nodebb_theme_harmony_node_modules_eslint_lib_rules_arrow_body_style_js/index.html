<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/arrow-body-style.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/arrow-body-style.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">50.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">419</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">32.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to require braces in arrow function body.
 * @author Alberto Rodr√≠guez
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		defaultOptions: [&quot;as-needed&quot;],

		docs: {
			description: &quot;Require braces around arrow function bodies&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/arrow-body-style&quot;,
		},

		schema: {
			anyOf: [
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [&quot;always&quot;, &quot;never&quot;],
						},
					],
					minItems: 0,
					maxItems: 1,
				},
				{
					type: &quot;array&quot;,
					items: [
						{
							enum: [&quot;as-needed&quot;],
						},
						{
							type: &quot;object&quot;,
							properties: {
								requireReturnForObjectLiteral: {
									type: &quot;boolean&quot;,
								},
							},
							additionalProperties: false,
						},
					],
					minItems: 0,
					maxItems: 2,
				},
			],
		},

		fixable: &quot;code&quot;,

		messages: {
			unexpectedOtherBlock:
				&quot;Unexpected block statement surrounding arrow body.&quot;,
			unexpectedEmptyBlock:
				&quot;Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=&gt;`.&quot;,
			unexpectedObjectBlock:
				&quot;Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=&gt;`.&quot;,
			unexpectedSingleBlock:
				&quot;Unexpected block statement surrounding arrow body; move the returned value immediately after the `=&gt;`.&quot;,
			expectedBlock: &quot;Expected block statement surrounding arrow body.&quot;,
		},
	},

	create(context) {
		const options = context.options;
		const always = options[0] === &quot;always&quot;;
		const asNeeded = options[0] === &quot;as-needed&quot;;
		const never = options[0] === &quot;never&quot;;
		const requireReturnForObjectLiteral =
			options[1] &amp;&amp; options[1].requireReturnForObjectLiteral;
		const sourceCode = context.sourceCode;
		let funcInfo = null;

		/**
		 * Checks whether the given node has ASI problem or not.
		 * @param {Token} token The token to check.
		 * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.
		 */
		function hasASIProblem(token) {
			return (
				token &amp;&amp;
				token.type === &quot;Punctuator&quot; &amp;&amp;
				/^[([/`+-]/u.test(token.value)
			);
		}

		/**
		 * Gets the closing parenthesis by the given node.
		 * @param {ASTNode} node first node after an opening parenthesis.
		 * @returns {Token} The found closing parenthesis token.
		 */
		function findClosingParen(node) {
			let nodeToCheck = node;

			while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {
				nodeToCheck = nodeToCheck.parent;
			}
			return sourceCode.getTokenAfter(nodeToCheck);
		}

		/**
		 * Check whether the node is inside of a for loop&#039;s init
		 * @param {ASTNode} node node is inside for loop
		 * @returns {boolean} `true` if the node is inside of a for loop, else `false`
		 */
		function isInsideForLoopInitializer(node) {
			if (node &amp;&amp; node.parent) {
				if (
					node.parent.type === &quot;ForStatement&quot; &amp;&amp;
					node.parent.init === node
				) {
					return true;
				}
				return isInsideForLoopInitializer(node.parent);
			}
			return false;
		}

		/**
		 * Determines whether a arrow function body needs braces
		 * @param {ASTNode} node The arrow function node.
		 * @returns {void}
		 */
		function validate(node) {
			const arrowBody = node.body;

			if (arrowBody.type === &quot;BlockStatement&quot;) {
				const blockBody = arrowBody.body;

				if (blockBody.length !== 1 &amp;&amp; !never) {
					return;
				}

				if (
					asNeeded &amp;&amp;
					requireReturnForObjectLiteral &amp;&amp;
					blockBody[0].type === &quot;ReturnStatement&quot; &amp;&amp;
					blockBody[0].argument &amp;&amp;
					blockBody[0].argument.type === &quot;ObjectExpression&quot;
				) {
					return;
				}

				if (
					never ||
					(asNeeded &amp;&amp; blockBody[0].type === &quot;ReturnStatement&quot;)
				) {
					let messageId;

					if (blockBody.length === 0) {
						messageId = &quot;unexpectedEmptyBlock&quot;;
					} else if (
						blockBody.length &gt; 1 ||
						blockBody[0].type !== &quot;ReturnStatement&quot;
					) {
						messageId = &quot;unexpectedOtherBlock&quot;;
					} else if (blockBody[0].argument === null) {
						messageId = &quot;unexpectedSingleBlock&quot;;
					} else if (
						astUtils.isOpeningBraceToken(
							sourceCode.getFirstToken(blockBody[0], { skip: 1 }),
						)
					) {
						messageId = &quot;unexpectedObjectBlock&quot;;
					} else {
						messageId = &quot;unexpectedSingleBlock&quot;;
					}

					context.report({
						node,
						loc: arrowBody.loc,
						messageId,
						fix(fixer) {
							const fixes = [];

							if (
								blockBody.length !== 1 ||
								blockBody[0].type !== &quot;ReturnStatement&quot; ||
								!blockBody[0].argument ||
								hasASIProblem(
									sourceCode.getTokenAfter(arrowBody),
								)
							) {
								return fixes;
							}

							const openingBrace =
								sourceCode.getFirstToken(arrowBody);
							const closingBrace =
								sourceCode.getLastToken(arrowBody);
							const firstValueToken = sourceCode.getFirstToken(
								blockBody[0],
								1,
							);
							const lastValueToken = sourceCode.getLastToken(
								blockBody[0],
							);
							const commentsExist =
								sourceCode.commentsExistBetween(
									openingBrace,
									firstValueToken,
								) ||
								sourceCode.commentsExistBetween(
									lastValueToken,
									closingBrace,
								);

							/*
							 * Remove tokens around the return value.
							 * If comments don&#039;t exist, remove extra spaces as well.
							 */
							if (commentsExist) {
								fixes.push(
									fixer.remove(openingBrace),
									fixer.remove(closingBrace),
									fixer.remove(
										sourceCode.getTokenAfter(openingBrace),
									), // return keyword
								);
							} else {
								fixes.push(
									fixer.removeRange([
										openingBrace.range[0],
										firstValueToken.range[0],
									]),
									fixer.removeRange([
										lastValueToken.range[1],
										closingBrace.range[1],
									]),
								);
							}

							/*
							 * If the first token of the return value is `{` or the return value is a sequence expression,
							 * enclose the return value by parentheses to avoid syntax error.
							 */
							if (
								astUtils.isOpeningBraceToken(firstValueToken) ||
								blockBody[0].argument.type ===
									&quot;SequenceExpression&quot; ||
								(funcInfo.hasInOperator &amp;&amp;
									isInsideForLoopInitializer(node))
							) {
								if (
									!astUtils.isParenthesised(
										sourceCode,
										blockBody[0].argument,
									)
								) {
									fixes.push(
										fixer.insertTextBefore(
											firstValueToken,
											&quot;(&quot;,
										),
										fixer.insertTextAfter(
											lastValueToken,
											&quot;)&quot;,
										),
									);
								}
							}

							/*
							 * If the last token of the return statement is semicolon, remove it.
							 * Non-block arrow body is an expression, not a statement.
							 */
							if (astUtils.isSemicolonToken(lastValueToken)) {
								fixes.push(fixer.remove(lastValueToken));
							}

							return fixes;
						},
					});
				}
			} else {
				if (
					always ||
					(asNeeded &amp;&amp;
						requireReturnForObjectLiteral &amp;&amp;
						arrowBody.type === &quot;ObjectExpression&quot;)
				) {
					context.report({
						node,
						loc: arrowBody.loc,
						messageId: &quot;expectedBlock&quot;,
						fix(fixer) {
							const fixes = [];
							const arrowToken = sourceCode.getTokenBefore(
								arrowBody,
								astUtils.isArrowToken,
							);
							const [
								firstTokenAfterArrow,
								secondTokenAfterArrow,
							] = sourceCode.getTokensAfter(arrowToken, {
								count: 2,
							});
							const lastToken = sourceCode.getLastToken(node);

							let parenthesisedObjectLiteral = null;

							if (
								astUtils.isOpeningParenToken(
									firstTokenAfterArrow,
								) &amp;&amp;
								astUtils.isOpeningBraceToken(
									secondTokenAfterArrow,
								)
							) {
								const braceNode =
									sourceCode.getNodeByRangeIndex(
										secondTokenAfterArrow.range[0],
									);

								if (braceNode.type === &quot;ObjectExpression&quot;) {
									parenthesisedObjectLiteral = braceNode;
								}
							}

							// If the value is object literal, remove parentheses which were forced by syntax.
							if (parenthesisedObjectLiteral) {
								const openingParenToken = firstTokenAfterArrow;
								const openingBraceToken = secondTokenAfterArrow;

								if (
									astUtils.isTokenOnSameLine(
										openingParenToken,
										openingBraceToken,
									)
								) {
									fixes.push(
										fixer.replaceText(
											openingParenToken,
											&quot;{return &quot;,
										),
									);
								} else {
									// Avoid ASI
									fixes.push(
										fixer.replaceText(
											openingParenToken,
											&quot;{&quot;,
										),
										fixer.insertTextBefore(
											openingBraceToken,
											&quot;return &quot;,
										),
									);
								}

								// Closing paren for the object doesn&#039;t have to be lastToken, e.g.: () =&gt; ({}).foo()
								fixes.push(
									fixer.remove(
										findClosingParen(
											parenthesisedObjectLiteral,
										),
									),
								);
								fixes.push(
									fixer.insertTextAfter(lastToken, &quot;}&quot;),
								);
							} else {
								fixes.push(
									fixer.insertTextBefore(
										firstTokenAfterArrow,
										&quot;{return &quot;,
									),
								);
								fixes.push(
									fixer.insertTextAfter(lastToken, &quot;}&quot;),
								);
							}

							return fixes;
						},
					});
				}
			}
		}

		return {
			&quot;BinaryExpression[operator=&#039;in&#039;]&quot;() {
				let info = funcInfo;

				while (info) {
					info.hasInOperator = true;
					info = info.upper;
				}
			},
			ArrowFunctionExpression() {
				funcInfo = {
					upper: funcInfo,
					hasInOperator: false,
				};
			},
			&quot;ArrowFunctionExpression:exit&quot;(node) {
				validate(node);
				funcInfo = funcInfo.upper;
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
