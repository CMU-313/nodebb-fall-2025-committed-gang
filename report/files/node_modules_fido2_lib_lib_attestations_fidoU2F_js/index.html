<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/lib/attestations/fidoU2F.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/lib/attestations/fidoU2F.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">161</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">32.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint-disable no-invalid-this */
// validators are a mixin, so it&#039;s okay that we&#039;re using &#039;this&#039; all over the place

&quot;use strict&quot;;

const {
	printHex,
	coerceToArrayBuffer,
	coerceToBase64,
	abToBuf,
	abToPem,
} = require(&quot;../utils&quot;);

const {
	Certificate,
	CertManager,
} = require(&quot;../certUtils&quot;);

const crypto = require(&quot;crypto&quot;);
const rootCertList = require(&quot;./u2fRootCerts&quot;);

function fidoU2fParseFn(attStmt) {
	var ret = new Map();
	var x5c = attStmt.x5c;
	var sig = attStmt.sig;

	if (!Array.isArray(x5c)) {
		throw new TypeError(&quot;expected U2F attestation x5c field to be of type Array&quot;);
	}

	if (x5c.length &lt; 1) {
		throw new TypeError(&quot;no certificates in U2F x5c field&quot;);
	}

	var newX5c = [];
	for (let cert of x5c) {
		cert = coerceToArrayBuffer(cert, &quot;U2F x5c cert&quot;);
		newX5c.push(cert);
	}
	// first certificate MUST be the attestation cert
	ret.set(&quot;attCert&quot;, newX5c.shift());
	// the rest of the certificates (if any) are the certificate chain
	ret.set(&quot;x5c&quot;, newX5c);

	sig = coerceToArrayBuffer(sig, &quot;U2F signature&quot;);
	ret.set(&quot;sig&quot;, sig);

	return ret;
}

async function fidoU2fValidateFn() {
	var x5c = this.authnrData.get(&quot;x5c&quot;);
	var parsedAttCert = this.authnrData.get(&quot;attCert&quot;);

	// validate cert chain
	if (x5c.length &gt; 0) {
		throw new Error(&quot;cert chain not validated&quot;);
	}
	this.audit.journal.add(&quot;x5c&quot;);

	// make sure our root certs are loaded
	if (CertManager.getCerts().size === 0) {
		rootCertList.forEach((cert) =&gt; CertManager.addCert(cert));
	}

	// decode attestation cert
	var attCert = new Certificate(coerceToBase64(parsedAttCert, &quot;parsedAttCert&quot;));
	try {
		await attCert.verify();
	} catch (e) {
		let err = e;
		if (err.message === &quot;Please provide issuer certificate as a parameter&quot;) {
			// err = new Error(&quot;Root attestation certificate for this token could not be found. Please contact your security key vendor.&quot;);
			this.audit.warning.set(&quot;attesation-not-validated&quot;, &quot;could not validate attestation because the root attestation certification could not be found&quot;);
		} else {
			throw err;
		}
	}

	// https: //fidoalliance.org/specs/fido-u2f-v1.2-ps-20170411/fido-u2f-authenticator-transports-extension-v1.2-ps-20170411.html
	// cert MUST be x.509v3
	if (attCert.getVersion() !== 3) {
		throw new Error(&quot;expected U2F attestation certificate to be x.509v3&quot;);
	}

	// save certificate warnings, info, and extensions in our audit information
	attCert.getExtensions().forEach((v, k) =&gt; this.audit.info.set(k, v));
	attCert.info.forEach((v, k) =&gt; this.audit.info.set(k, v));
	attCert.warning.forEach((v, k) =&gt; this.audit.warning.set(k, v));
	this.audit.journal.add(&quot;attCert&quot;);

	// https://w3c.github.io/webauthn/#fido-u2f-attestation
	// certificate public key is not an Elliptic Curve (EC) public key over the P-256 curve, terminate this algorithm and return an appropriate error
	var jwk = this.authnrData.get(&quot;credentialPublicKeyJwk&quot;);
	if (jwk.kty !== &quot;EC&quot; ||
        jwk.crv !== &quot;P-256&quot;) {
		throw new Error(&quot;bad U2F key type&quot;);
	}

	// rpIdHash from authenticatorData, and the claimed credentialId and credentialPublicKey from authenticatorData.attestedCredentialData
	var rpIdHash = this.authnrData.get(&quot;rpIdHash&quot;);
	var credId = this.authnrData.get(&quot;credId&quot;);

	// create clientDataHash
	var rawClientData = this.clientData.get(&quot;rawClientDataJson&quot;);
	const hash = crypto.createHash(&quot;sha256&quot;);
	hash.update(abToBuf(rawClientData));
	var clientDataHashBuf = hash.digest();
	var clientDataHash = new Uint8Array(clientDataHashBuf).buffer;

	// Convert the COSE_KEY formatted credentialPublicKey (see Section 7 of [RFC8152]) to CTAP1/U2F public Key format [FIDO-CTAP]
	//      Let publicKeyU2F represent the result of the conversion operation and set its first byte to 0x04. Note: This signifies uncompressed ECC key format.
	//      Extract the value corresponding to the &quot;-2&quot; key (representing x coordinate) from credentialPublicKey, confirm its size to be of 32 bytes and concatenate it with publicKeyU2F. If size differs or &quot;-2&quot; key is not found, terminate this algorithm and return an appropriate error.
	var x = coerceToArrayBuffer(jwk.x, &quot;U2F public key x component&quot;);
	if (x.byteLength !== 32) {
		throw new Error(&quot;U2F public key x component was wrong size&quot;);
	}

	//      Extract the value corresponding to the &quot;-3&quot; key (representing y coordinate) from credentialPublicKey, confirm its size to be of 32 bytes and concatenate it with publicKeyU2F. If size differs or &quot;-3&quot; key is not found, terminate this algorithm and return an appropriate error.
	var y = coerceToArrayBuffer(jwk.y, &quot;U2F public key y component&quot;);
	if (y.byteLength !== 32) {
		throw new Error(&quot;U2F public key y component was wrong size&quot;);
	}

	// Let verificationData be the concatenation of (0x00 || rpIdHash || clientDataHash || credentialId || publicKeyU2F) (see Section 4.3 of [FIDO-U2F-Message-Formats]).
	var verificationData = new Uint8Array([
		0x00,
		...new Uint8Array(rpIdHash),
		...new Uint8Array(clientDataHash),
		...new Uint8Array(credId),
		0x04,
		...new Uint8Array(x),
		...new Uint8Array(y),
	]);

	// Verify the sig using verificationData and certificate public key per [SEC1].
	var sig = this.authnrData.get(&quot;sig&quot;);
	var attCertPem = abToPem(&quot;CERTIFICATE&quot;, parsedAttCert);

	const verify = crypto.createVerify(&quot;SHA256&quot;);
	verify.write(abToBuf(verificationData));
	verify.end();
	var res = verify.verify(attCertPem, abToBuf(sig));
	if (!res) {
		throw new Error(&quot;U2F attestation signature verification failed&quot;);
	}
	this.audit.journal.add(&quot;sig&quot;);

	// If successful, return attestation type Basic with the attestation trust path set to x5c.
	this.audit.info.set(&quot;attestation-type&quot;, &quot;basic&quot;);

	this.audit.journal.add(&quot;fmt&quot;);
	return true;
}

module.exports = {
	name: &quot;fido-u2f&quot;,
	parseFn: fidoU2fParseFn,
	validateFn: fidoU2fValidateFn,
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
