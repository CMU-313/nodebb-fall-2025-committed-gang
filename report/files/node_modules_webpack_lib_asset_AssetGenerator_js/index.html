<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/asset/AssetGenerator.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/asset/AssetGenerator.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">807</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">87.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.20</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sergey Melyukov @smelukov
*/

&quot;use strict&quot;;

const mimeTypes = require(&quot;mime-types&quot;);
const path = require(&quot;path&quot;);
const { RawSource } = require(&quot;webpack-sources&quot;);
const ConcatenationScope = require(&quot;../ConcatenationScope&quot;);
const Generator = require(&quot;../Generator&quot;);
const {
	NO_TYPES,
	ASSET_TYPES,
	ASSET_AND_JS_TYPES,
	ASSET_AND_JS_AND_CSS_URL_TYPES,
	ASSET_AND_CSS_URL_TYPES,
	JS_TYPES,
	JS_AND_CSS_URL_TYPES,
	CSS_URL_TYPES
} = require(&quot;../ModuleSourceTypesConstants&quot;);
const { ASSET_MODULE_TYPE } = require(&quot;../ModuleTypeConstants&quot;);
const RuntimeGlobals = require(&quot;../RuntimeGlobals&quot;);
const CssUrlDependency = require(&quot;../dependencies/CssUrlDependency&quot;);
const createHash = require(&quot;../util/createHash&quot;);
const { makePathsRelative } = require(&quot;../util/identifier&quot;);
const nonNumericOnlyHash = require(&quot;../util/nonNumericOnlyHash&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).AssetGeneratorDataUrlOptions} AssetGeneratorDataUrlOptions */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).AssetGeneratorOptions} AssetGeneratorOptions */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).AssetModuleFilename} AssetModuleFilename */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).AssetModuleOutputPath} AssetModuleOutputPath */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).AssetResourceGeneratorOptions} AssetResourceGeneratorOptions */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).HashFunction} HashFunction */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).RawPublicPath} RawPublicPath */
/** @typedef {import(&quot;../ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;../Compilation&quot;)} Compilation */
/** @typedef {import(&quot;../Compilation&quot;).AssetInfo} AssetInfo */
/** @typedef {import(&quot;../Compilation&quot;).InterpolatedPathAndAssetInfo} InterpolatedPathAndAssetInfo */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../Generator&quot;).GenerateContext} GenerateContext */
/** @typedef {import(&quot;../Generator&quot;).UpdateHashContext} UpdateHashContext */
/** @typedef {import(&quot;../Module&quot;)} Module */
/** @typedef {import(&quot;../Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;../Module&quot;).BuildMeta} BuildMeta */
/** @typedef {import(&quot;../Module&quot;).ConcatenationBailoutReasonContext} ConcatenationBailoutReasonContext */
/** @typedef {import(&quot;../Module&quot;).SourceTypes} SourceTypes */
/** @typedef {import(&quot;../ModuleGraph&quot;)} ModuleGraph */
/** @typedef {import(&quot;../NormalModule&quot;)} NormalModule */
/** @typedef {import(&quot;../RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {import(&quot;../TemplatedPathPlugin&quot;).TemplatePath} TemplatePath */
/** @typedef {import(&quot;../util/Hash&quot;)} Hash */
/** @typedef {import(&quot;../util/runtime&quot;).RuntimeSpec} RuntimeSpec */

/**
 * @template T
 * @template U
 * @param {string | Array&lt;T&gt; | Set&lt;T&gt; | undefined} a a
 * @param {string | Array&lt;U&gt; | Set&lt;U&gt; | undefined} b b
 * @returns {Array&lt;T&gt; &amp; Array&lt;U&gt;} array
 */
const mergeMaybeArrays = (a, b) =&gt; {
	const set = new Set();
	if (Array.isArray(a)) for (const item of a) set.add(item);
	else set.add(a);
	if (Array.isArray(b)) for (const item of b) set.add(item);
	else set.add(b);
	return Array.from(set);
};

/**
 * @param {AssetInfo} a a
 * @param {AssetInfo} b b
 * @returns {AssetInfo} object
 */
const mergeAssetInfo = (a, b) =&gt; {
	/** @type {AssetInfo} */
	const result = { ...a, ...b };
	for (const key of Object.keys(a)) {
		if (key in b) {
			if (a[key] === b[key]) continue;
			switch (key) {
				case &quot;fullhash&quot;:
				case &quot;chunkhash&quot;:
				case &quot;modulehash&quot;:
				case &quot;contenthash&quot;:
					result[key] = mergeMaybeArrays(a[key], b[key]);
					break;
				case &quot;immutable&quot;:
				case &quot;development&quot;:
				case &quot;hotModuleReplacement&quot;:
				case &quot;javascriptModule&quot;:
					result[key] = a[key] || b[key];
					break;
				case &quot;related&quot;:
					result[key] = mergeRelatedInfo(
						/** @type {NonNullable&lt;AssetInfo[&quot;related&quot;]&gt;} */
						(a[key]),
						/** @type {NonNullable&lt;AssetInfo[&quot;related&quot;]&gt;} */
						(b[key])
					);
					break;
				default:
					throw new Error(`Can&#039;t handle conflicting asset info for ${key}`);
			}
		}
	}
	return result;
};

/**
 * @param {NonNullable&lt;AssetInfo[&quot;related&quot;]&gt;} a a
 * @param {NonNullable&lt;AssetInfo[&quot;related&quot;]&gt;} b b
 * @returns {NonNullable&lt;AssetInfo[&quot;related&quot;]&gt;} object
 */
const mergeRelatedInfo = (a, b) =&gt; {
	const result = { ...a, ...b };
	for (const key of Object.keys(a)) {
		if (key in b) {
			if (a[key] === b[key]) continue;
			result[key] = mergeMaybeArrays(a[key], b[key]);
		}
	}
	return result;
};

/**
 * @param {&quot;base64&quot; | false} encoding encoding
 * @param {Source} source source
 * @returns {string} encoded data
 */
const encodeDataUri = (encoding, source) =&gt; {
	/** @type {string | undefined} */
	let encodedContent;

	switch (encoding) {
		case &quot;base64&quot;: {
			encodedContent = source.buffer().toString(&quot;base64&quot;);
			break;
		}
		case false: {
			const content = source.source();

			if (typeof content !== &quot;string&quot;) {
				encodedContent = content.toString(&quot;utf-8&quot;);
			}

			encodedContent = encodeURIComponent(
				/** @type {string} */
				(encodedContent)
			).replace(
				/[!&#039;()*]/g,
				character =&gt;
					`%${/** @type {number} */ (character.codePointAt(0)).toString(16)}`
			);
			break;
		}
		default:
			throw new Error(`Unsupported encoding &#039;${encoding}&#039;`);
	}

	return encodedContent;
};

/**
 * @param {string} encoding encoding
 * @param {string} content content
 * @returns {Buffer} decoded content
 */
const decodeDataUriContent = (encoding, content) =&gt; {
	const isBase64 = encoding === &quot;base64&quot;;

	if (isBase64) {
		return Buffer.from(content, &quot;base64&quot;);
	}

	// If we can&#039;t decode return the original body
	try {
		return Buffer.from(decodeURIComponent(content), &quot;ascii&quot;);
	} catch (_) {
		return Buffer.from(content, &quot;ascii&quot;);
	}
};

const DEFAULT_ENCODING = &quot;base64&quot;;

class AssetGenerator extends Generator {
	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {AssetGeneratorOptions[&quot;dataUrl&quot;]=} dataUrlOptions the options for the data url
	 * @param {AssetModuleFilename=} filename override for output.assetModuleFilename
	 * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath
	 * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import
	 * @param {boolean=} emit generate output asset
	 */
	constructor(
		moduleGraph,
		dataUrlOptions,
		filename,
		publicPath,
		outputPath,
		emit
	) {
		super();
		this.dataUrlOptions = dataUrlOptions;
		this.filename = filename;
		this.publicPath = publicPath;
		this.outputPath = outputPath;
		this.emit = emit;
		this._moduleGraph = moduleGraph;
	}

	/**
	 * @param {NormalModule} module module
	 * @param {RuntimeTemplate} runtimeTemplate runtime template
	 * @returns {string} source file name
	 */
	static getSourceFileName(module, runtimeTemplate) {
		return makePathsRelative(
			runtimeTemplate.compilation.compiler.context,
			module.matchResource || module.resource,
			runtimeTemplate.compilation.compiler.root
		).replace(/^\.\//, &quot;&quot;);
	}

	/**
	 * @param {NormalModule} module module
	 * @param {RuntimeTemplate} runtimeTemplate runtime template
	 * @returns {[string, string]} return full hash and non-numeric full hash
	 */
	static getFullContentHash(module, runtimeTemplate) {
		const hash = createHash(
			/** @type {HashFunction} */
			(runtimeTemplate.outputOptions.hashFunction)
		);

		if (runtimeTemplate.outputOptions.hashSalt) {
			hash.update(runtimeTemplate.outputOptions.hashSalt);
		}

		const source = module.originalSource();

		if (source) {
			hash.update(source.buffer());
		}

		if (module.error) {
			hash.update(module.error.toString());
		}

		const fullContentHash = /** @type {string} */ (
			hash.digest(runtimeTemplate.outputOptions.hashDigest)
		);

		/** @type {string} */
		const contentHash = nonNumericOnlyHash(
			fullContentHash,
			/** @type {number} */
			(runtimeTemplate.outputOptions.hashDigestLength)
		);

		return [fullContentHash, contentHash];
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {Pick&lt;AssetResourceGeneratorOptions, &quot;filename&quot; | &quot;outputPath&quot;&gt;} generatorOptions generator options
	 * @param {{ runtime: RuntimeSpec, runtimeTemplate: RuntimeTemplate, chunkGraph: ChunkGraph }} generateContext context for generate
	 * @param {string} contentHash the content hash
	 * @returns {{ filename: string, originalFilename: string, assetInfo: AssetInfo }} info
	 */
	static getFilenameWithInfo(
		module,
		generatorOptions,
		{ runtime, runtimeTemplate, chunkGraph },
		contentHash
	) {
		const assetModuleFilename =
			generatorOptions.filename ||
			/** @type {AssetModuleFilename} */
			(runtimeTemplate.outputOptions.assetModuleFilename);

		const sourceFilename = AssetGenerator.getSourceFileName(
			module,
			runtimeTemplate
		);
		let { path: filename, info: assetInfo } =
			runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, {
				module,
				runtime,
				filename: sourceFilename,
				chunkGraph,
				contentHash
			});

		const originalFilename = filename;

		if (generatorOptions.outputPath) {
			const { path: outputPath, info } =
				runtimeTemplate.compilation.getAssetPathWithInfo(
					generatorOptions.outputPath,
					{
						module,
						runtime,
						filename: sourceFilename,
						chunkGraph,
						contentHash
					}
				);
			filename = path.posix.join(outputPath, filename);
			assetInfo = mergeAssetInfo(assetInfo, info);
		}

		return { originalFilename, filename, assetInfo };
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {Pick&lt;AssetResourceGeneratorOptions, &quot;publicPath&quot;&gt;} generatorOptions generator options
	 * @param {GenerateContext} generateContext context for generate
	 * @param {string} filename the filename
	 * @param {AssetInfo} assetInfo the asset info
	 * @param {string} contentHash the content hash
	 * @returns {{ assetPath: string, assetInfo: AssetInfo }} asset path and info
	 */
	static getAssetPathWithInfo(
		module,
		generatorOptions,
		{ runtime, runtimeTemplate, type, chunkGraph, runtimeRequirements },
		filename,
		assetInfo,
		contentHash
	) {
		const sourceFilename = AssetGenerator.getSourceFileName(
			module,
			runtimeTemplate
		);

		let assetPath;

		if (generatorOptions.publicPath !== undefined &amp;&amp; type === &quot;javascript&quot;) {
			const { path, info } = runtimeTemplate.compilation.getAssetPathWithInfo(
				generatorOptions.publicPath,
				{
					module,
					runtime,
					filename: sourceFilename,
					chunkGraph,
					contentHash
				}
			);
			assetInfo = mergeAssetInfo(assetInfo, info);
			assetPath = JSON.stringify(path + filename);
		} else if (
			generatorOptions.publicPath !== undefined &amp;&amp;
			type === &quot;css-url&quot;
		) {
			const { path, info } = runtimeTemplate.compilation.getAssetPathWithInfo(
				generatorOptions.publicPath,
				{
					module,
					runtime,
					filename: sourceFilename,
					chunkGraph,
					contentHash
				}
			);
			assetInfo = mergeAssetInfo(assetInfo, info);
			assetPath = path + filename;
		} else if (type === &quot;javascript&quot;) {
			// add __webpack_require__.p
			runtimeRequirements.add(RuntimeGlobals.publicPath);
			assetPath = runtimeTemplate.concatenation(
				{ expr: RuntimeGlobals.publicPath },
				filename
			);
		} else if (type === &quot;css-url&quot;) {
			const compilation = runtimeTemplate.compilation;
			const path =
				compilation.outputOptions.publicPath === &quot;auto&quot;
					? CssUrlDependency.PUBLIC_PATH_AUTO
					: compilation.getAssetPath(
							/** @type {TemplatePath} */
							(compilation.outputOptions.publicPath),
							{
								hash: compilation.hash
							}
						);

			assetPath = path + filename;
		}

		return {
			// eslint-disable-next-line object-shorthand
			assetPath: /** @type {string} */ (assetPath),
			assetInfo: { sourceFilename, ...assetInfo }
		};
	}

	/**
	 * @param {NormalModule} module module for which the bailout reason should be determined
	 * @param {ConcatenationBailoutReasonContext} context context
	 * @returns {string | undefined} reason why this module can&#039;t be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(module, context) {
		return undefined;
	}

	/**
	 * @param {NormalModule} module module
	 * @returns {string} mime type
	 */
	getMimeType(module) {
		if (typeof this.dataUrlOptions === &quot;function&quot;) {
			throw new Error(
				&quot;This method must not be called when dataUrlOptions is a function&quot;
			);
		}

		/** @type {string | boolean | undefined} */
		let mimeType =
			/** @type {AssetGeneratorDataUrlOptions} */
			(this.dataUrlOptions).mimetype;
		if (mimeType === undefined) {
			const ext = path.extname(
				/** @type {string} */
				(module.nameForCondition())
			);
			if (
				module.resourceResolveData &amp;&amp;
				module.resourceResolveData.mimetype !== undefined
			) {
				mimeType =
					module.resourceResolveData.mimetype +
					module.resourceResolveData.parameters;
			} else if (ext) {
				mimeType = mimeTypes.lookup(ext);

				if (typeof mimeType !== &quot;string&quot;) {
					throw new Error(
						&quot;DataUrl can&#039;t be generated automatically, &quot; +
							`because there is no mimetype for &quot;${ext}&quot; in mimetype database. ` +
							&#039;Either pass a mimetype via &quot;generator.mimetype&quot; or &#039; +
							&#039;use type: &quot;asset/resource&quot; to create a resource file instead of a DataUrl&#039;
					);
				}
			}
		}

		if (typeof mimeType !== &quot;string&quot;) {
			throw new Error(
				&quot;DataUrl can&#039;t be generated automatically. &quot; +
					&#039;Either pass a mimetype via &quot;generator.mimetype&quot; or &#039; +
					&#039;use type: &quot;asset/resource&quot; to create a resource file instead of a DataUrl&#039;
			);
		}

		return /** @type {string} */ (mimeType);
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @returns {string} DataURI
	 */
	generateDataUri(module) {
		const source = /** @type {Source} */ (module.originalSource());

		let encodedSource;

		if (typeof this.dataUrlOptions === &quot;function&quot;) {
			encodedSource = this.dataUrlOptions.call(null, source.source(), {
				filename: module.matchResource || module.resource,
				module
			});
		} else {
			/** @type {&quot;base64&quot; | false | undefined} */
			let encoding =
				/** @type {AssetGeneratorDataUrlOptions} */
				(this.dataUrlOptions).encoding;
			if (
				encoding === undefined &amp;&amp;
				module.resourceResolveData &amp;&amp;
				module.resourceResolveData.encoding !== undefined
			) {
				encoding = module.resourceResolveData.encoding;
			}
			if (encoding === undefined) {
				encoding = DEFAULT_ENCODING;
			}
			const mimeType = this.getMimeType(module);

			let encodedContent;

			if (
				module.resourceResolveData &amp;&amp;
				module.resourceResolveData.encoding === encoding &amp;&amp;
				decodeDataUriContent(
					module.resourceResolveData.encoding,
					module.resourceResolveData.encodedContent
				).equals(source.buffer())
			) {
				encodedContent = module.resourceResolveData.encodedContent;
			} else {
				encodedContent = encodeDataUri(encoding, source);
			}

			encodedSource = `data:${mimeType}${
				encoding ? `;${encoding}` : &quot;&quot;
			},${encodedContent}`;
		}

		return encodedSource;
	}

	/**
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {GenerateContext} generateContext context for generate
	 * @returns {Source | null} generated code
	 */
	generate(module, generateContext) {
		const {
			type,
			getData,
			runtimeTemplate,
			runtimeRequirements,
			concatenationScope
		} = generateContext;

		let content;

		const needContent = type === &quot;javascript&quot; || type === &quot;css-url&quot;;

		const data = getData ? getData() : undefined;

		if (
			/** @type {BuildInfo} */
			(module.buildInfo).dataUrl &amp;&amp;
			needContent
		) {
			const encodedSource = this.generateDataUri(module);
			content =
				type === &quot;javascript&quot; ? JSON.stringify(encodedSource) : encodedSource;

			if (data) {
				data.set(&quot;url&quot;, { [type]: content, ...data.get(&quot;url&quot;) });
			}
		} else {
			const [fullContentHash, contentHash] = AssetGenerator.getFullContentHash(
				module,
				runtimeTemplate
			);

			if (data) {
				data.set(&quot;fullContentHash&quot;, fullContentHash);
				data.set(&quot;contentHash&quot;, contentHash);
			}

			/** @type {BuildInfo} */
			(module.buildInfo).fullContentHash = fullContentHash;

			const { originalFilename, filename, assetInfo } =
				AssetGenerator.getFilenameWithInfo(
					module,
					{ filename: this.filename, outputPath: this.outputPath },
					generateContext,
					contentHash
				);

			if (data) {
				data.set(&quot;filename&quot;, filename);
			}

			let { assetPath, assetInfo: newAssetInfo } =
				AssetGenerator.getAssetPathWithInfo(
					module,
					{ publicPath: this.publicPath },
					generateContext,
					originalFilename,
					assetInfo,
					contentHash
				);

			if (data &amp;&amp; (type === &quot;javascript&quot; || type === &quot;css-url&quot;)) {
				data.set(&quot;url&quot;, { [type]: assetPath, ...data.get(&quot;url&quot;) });
			}

			if (data &amp;&amp; data.get(&quot;assetInfo&quot;)) {
				newAssetInfo = mergeAssetInfo(data.get(&quot;assetInfo&quot;), newAssetInfo);
			}

			if (data) {
				data.set(&quot;assetInfo&quot;, newAssetInfo);
			}

			// Due to code generation caching module.buildInfo.XXX can&#039;t used to store such information
			// It need to be stored in the code generation results instead, where it&#039;s cached too
			// TODO webpack 6 For back-compat reasons we also store in on module.buildInfo
			/** @type {BuildInfo} */
			(module.buildInfo).filename = filename;

			/** @type {BuildInfo} */
			(module.buildInfo).assetInfo = newAssetInfo;

			content = assetPath;
		}

		if (type === &quot;javascript&quot;) {
			if (concatenationScope) {
				concatenationScope.registerNamespaceExport(
					ConcatenationScope.NAMESPACE_OBJECT_EXPORT
				);

				return new RawSource(
					`${runtimeTemplate.supportsConst() ? &quot;const&quot; : &quot;var&quot;} ${
						ConcatenationScope.NAMESPACE_OBJECT_EXPORT
					} = ${content};`
				);
			}

			runtimeRequirements.add(RuntimeGlobals.module);

			return new RawSource(`${RuntimeGlobals.module}.exports = ${content};`);
		} else if (type === &quot;css-url&quot;) {
			return null;
		}

		return /** @type {Source} */ (module.originalSource());
	}

	/**
	 * @param {Error} error the error
	 * @param {NormalModule} module module for which the code should be generated
	 * @param {GenerateContext} generateContext context for generate
	 * @returns {Source | null} generated code
	 */
	generateError(error, module, generateContext) {
		switch (generateContext.type) {
			case &quot;asset&quot;: {
				return new RawSource(error.message);
			}
			case &quot;javascript&quot;: {
				return new RawSource(
					`throw new Error(${JSON.stringify(error.message)});`
				);
			}
			default:
				return null;
		}
	}

	/**
	 * @param {NormalModule} module fresh module
	 * @returns {SourceTypes} available types (do not mutate)
	 */
	getTypes(module) {
		const sourceTypes = new Set();
		const connections = this._moduleGraph.getIncomingConnections(module);

		for (const connection of connections) {
			if (!connection.originModule) {
				continue;
			}

			sourceTypes.add(connection.originModule.type.split(&quot;/&quot;)[0]);
		}

		if ((module.buildInfo &amp;&amp; module.buildInfo.dataUrl) || this.emit === false) {
			if (sourceTypes) {
				if (sourceTypes.has(&quot;javascript&quot;) &amp;&amp; sourceTypes.has(&quot;css&quot;)) {
					return JS_AND_CSS_URL_TYPES;
				} else if (sourceTypes.has(&quot;javascript&quot;)) {
					return JS_TYPES;
				} else if (sourceTypes.has(&quot;css&quot;)) {
					return CSS_URL_TYPES;
				}
			}

			return NO_TYPES;
		}

		if (sourceTypes) {
			if (sourceTypes.has(&quot;javascript&quot;) &amp;&amp; sourceTypes.has(&quot;css&quot;)) {
				return ASSET_AND_JS_AND_CSS_URL_TYPES;
			} else if (sourceTypes.has(&quot;javascript&quot;)) {
				return ASSET_AND_JS_TYPES;
			} else if (sourceTypes.has(&quot;css&quot;)) {
				return ASSET_AND_CSS_URL_TYPES;
			}
		}

		return ASSET_TYPES;
	}

	/**
	 * @param {NormalModule} module the module
	 * @param {string=} type source type
	 * @returns {number} estimate size of the module
	 */
	getSize(module, type) {
		switch (type) {
			case ASSET_MODULE_TYPE: {
				const originalSource = module.originalSource();

				if (!originalSource) {
					return 0;
				}

				return originalSource.size();
			}
			default:
				if (module.buildInfo &amp;&amp; module.buildInfo.dataUrl) {
					const originalSource = module.originalSource();

					if (!originalSource) {
						return 0;
					}

					// roughly for data url
					// Example: m.exports=&quot;data:image/png;base64,ag82/f+2==&quot;
					// 4/3 = base64 encoding
					// 34 = ~ data url header + footer + rounding
					return originalSource.size() * 1.34 + 36;
				}
				// it&#039;s only estimated so this number is probably fine
				// Example: m.exports=r.p+&quot;0123456789012345678901.ext&quot;
				return 42;
		}
	}

	/**
	 * @param {Hash} hash hash that will be modified
	 * @param {UpdateHashContext} updateHashContext context for updating hash
	 */
	updateHash(hash, updateHashContext) {
		const { module } = updateHashContext;

		if (
			/** @type {BuildInfo} */
			(module.buildInfo).dataUrl
		) {
			hash.update(&quot;data-url&quot;);
			// this.dataUrlOptions as function should be pure and only depend on input source and filename
			// therefore it doesn&#039;t need to be hashed
			if (typeof this.dataUrlOptions === &quot;function&quot;) {
				const ident = /** @type {{ ident?: string }} */ (this.dataUrlOptions)
					.ident;
				if (ident) hash.update(ident);
			} else {
				const dataUrlOptions =
					/** @type {AssetGeneratorDataUrlOptions} */
					(this.dataUrlOptions);
				if (
					dataUrlOptions.encoding &amp;&amp;
					dataUrlOptions.encoding !== DEFAULT_ENCODING
				) {
					hash.update(dataUrlOptions.encoding);
				}
				if (dataUrlOptions.mimetype) hash.update(dataUrlOptions.mimetype);
				// computed mimetype depends only on module filename which is already part of the hash
			}
		} else {
			hash.update(&quot;resource&quot;);

			const { module, chunkGraph, runtime } = updateHashContext;
			const runtimeTemplate =
				/** @type {NonNullable&lt;UpdateHashContext[&quot;runtimeTemplate&quot;]&gt;} */
				(updateHashContext.runtimeTemplate);

			const pathData = {
				module,
				runtime,
				filename: AssetGenerator.getSourceFileName(module, runtimeTemplate),
				chunkGraph,
				contentHash: runtimeTemplate.contentHashReplacement
			};

			if (typeof this.publicPath === &quot;function&quot;) {
				hash.update(&quot;path&quot;);
				const assetInfo = {};
				hash.update(this.publicPath(pathData, assetInfo));
				hash.update(JSON.stringify(assetInfo));
			} else if (this.publicPath) {
				hash.update(&quot;path&quot;);
				hash.update(this.publicPath);
			} else {
				hash.update(&quot;no-path&quot;);
			}

			const assetModuleFilename =
				this.filename ||
				/** @type {AssetModuleFilename} */
				(runtimeTemplate.outputOptions.assetModuleFilename);
			const { path: filename, info } =
				runtimeTemplate.compilation.getAssetPathWithInfo(
					assetModuleFilename,
					pathData
				);
			hash.update(filename);
			hash.update(JSON.stringify(info));
		}
	}
}

module.exports = AssetGenerator;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
