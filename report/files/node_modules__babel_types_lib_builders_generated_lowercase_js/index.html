<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/types/lib/builders/generated/lowercase.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/types/lib/builders/generated/lowercase.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2897</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">44.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">37.44</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classAccessorProperty = classAccessorProperty;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.import = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importExpression = importExpression;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.super = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumBody = exports.tsEnumBody = tsEnumBody;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSTemplateLiteralType = exports.tsTemplateLiteralType = tsTemplateLiteralType;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidPattern = voidPattern;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;
var _validate = require(&quot;../../validators/validate.js&quot;);
var _deprecationWarning = require(&quot;../../utils/deprecationWarning.js&quot;);
var utils = require(&quot;../../definitions/utils.js&quot;);
const {
  validateInternal: validate
} = _validate;
const {
  NODE_FIELDS
} = utils;
function bigIntLiteral(value) {
  if (typeof value === &quot;bigint&quot;) {
    value = value.toString();
  }
  const node = {
    type: &quot;BigIntLiteral&quot;,
    value
  };
  const defs = NODE_FIELDS.BigIntLiteral;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function arrayExpression(elements = []) {
  const node = {
    type: &quot;ArrayExpression&quot;,
    elements
  };
  const defs = NODE_FIELDS.ArrayExpression;
  validate(defs.elements, node, &quot;elements&quot;, elements, 1);
  return node;
}
function assignmentExpression(operator, left, right) {
  const node = {
    type: &quot;AssignmentExpression&quot;,
    operator,
    left,
    right
  };
  const defs = NODE_FIELDS.AssignmentExpression;
  validate(defs.operator, node, &quot;operator&quot;, operator);
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function binaryExpression(operator, left, right) {
  const node = {
    type: &quot;BinaryExpression&quot;,
    operator,
    left,
    right
  };
  const defs = NODE_FIELDS.BinaryExpression;
  validate(defs.operator, node, &quot;operator&quot;, operator);
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function interpreterDirective(value) {
  const node = {
    type: &quot;InterpreterDirective&quot;,
    value
  };
  const defs = NODE_FIELDS.InterpreterDirective;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function directive(value) {
  const node = {
    type: &quot;Directive&quot;,
    value
  };
  const defs = NODE_FIELDS.Directive;
  validate(defs.value, node, &quot;value&quot;, value, 1);
  return node;
}
function directiveLiteral(value) {
  const node = {
    type: &quot;DirectiveLiteral&quot;,
    value
  };
  const defs = NODE_FIELDS.DirectiveLiteral;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function blockStatement(body, directives = []) {
  const node = {
    type: &quot;BlockStatement&quot;,
    body,
    directives
  };
  const defs = NODE_FIELDS.BlockStatement;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.directives, node, &quot;directives&quot;, directives, 1);
  return node;
}
function breakStatement(label = null) {
  const node = {
    type: &quot;BreakStatement&quot;,
    label
  };
  const defs = NODE_FIELDS.BreakStatement;
  validate(defs.label, node, &quot;label&quot;, label, 1);
  return node;
}
function callExpression(callee, _arguments) {
  const node = {
    type: &quot;CallExpression&quot;,
    callee,
    arguments: _arguments
  };
  const defs = NODE_FIELDS.CallExpression;
  validate(defs.callee, node, &quot;callee&quot;, callee, 1);
  validate(defs.arguments, node, &quot;arguments&quot;, _arguments, 1);
  return node;
}
function catchClause(param = null, body) {
  const node = {
    type: &quot;CatchClause&quot;,
    param,
    body
  };
  const defs = NODE_FIELDS.CatchClause;
  validate(defs.param, node, &quot;param&quot;, param, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function conditionalExpression(test, consequent, alternate) {
  const node = {
    type: &quot;ConditionalExpression&quot;,
    test,
    consequent,
    alternate
  };
  const defs = NODE_FIELDS.ConditionalExpression;
  validate(defs.test, node, &quot;test&quot;, test, 1);
  validate(defs.consequent, node, &quot;consequent&quot;, consequent, 1);
  validate(defs.alternate, node, &quot;alternate&quot;, alternate, 1);
  return node;
}
function continueStatement(label = null) {
  const node = {
    type: &quot;ContinueStatement&quot;,
    label
  };
  const defs = NODE_FIELDS.ContinueStatement;
  validate(defs.label, node, &quot;label&quot;, label, 1);
  return node;
}
function debuggerStatement() {
  return {
    type: &quot;DebuggerStatement&quot;
  };
}
function doWhileStatement(test, body) {
  const node = {
    type: &quot;DoWhileStatement&quot;,
    test,
    body
  };
  const defs = NODE_FIELDS.DoWhileStatement;
  validate(defs.test, node, &quot;test&quot;, test, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function emptyStatement() {
  return {
    type: &quot;EmptyStatement&quot;
  };
}
function expressionStatement(expression) {
  const node = {
    type: &quot;ExpressionStatement&quot;,
    expression
  };
  const defs = NODE_FIELDS.ExpressionStatement;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function file(program, comments = null, tokens = null) {
  const node = {
    type: &quot;File&quot;,
    program,
    comments,
    tokens
  };
  const defs = NODE_FIELDS.File;
  validate(defs.program, node, &quot;program&quot;, program, 1);
  validate(defs.comments, node, &quot;comments&quot;, comments, 1);
  validate(defs.tokens, node, &quot;tokens&quot;, tokens);
  return node;
}
function forInStatement(left, right, body) {
  const node = {
    type: &quot;ForInStatement&quot;,
    left,
    right,
    body
  };
  const defs = NODE_FIELDS.ForInStatement;
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function forStatement(init = null, test = null, update = null, body) {
  const node = {
    type: &quot;ForStatement&quot;,
    init,
    test,
    update,
    body
  };
  const defs = NODE_FIELDS.ForStatement;
  validate(defs.init, node, &quot;init&quot;, init, 1);
  validate(defs.test, node, &quot;test&quot;, test, 1);
  validate(defs.update, node, &quot;update&quot;, update, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function functionDeclaration(id = null, params, body, generator = false, async = false) {
  const node = {
    type: &quot;FunctionDeclaration&quot;,
    id,
    params,
    body,
    generator,
    async
  };
  const defs = NODE_FIELDS.FunctionDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.generator, node, &quot;generator&quot;, generator);
  validate(defs.async, node, &quot;async&quot;, async);
  return node;
}
function functionExpression(id = null, params, body, generator = false, async = false) {
  const node = {
    type: &quot;FunctionExpression&quot;,
    id,
    params,
    body,
    generator,
    async
  };
  const defs = NODE_FIELDS.FunctionExpression;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.generator, node, &quot;generator&quot;, generator);
  validate(defs.async, node, &quot;async&quot;, async);
  return node;
}
function identifier(name) {
  const node = {
    type: &quot;Identifier&quot;,
    name
  };
  const defs = NODE_FIELDS.Identifier;
  validate(defs.name, node, &quot;name&quot;, name);
  return node;
}
function ifStatement(test, consequent, alternate = null) {
  const node = {
    type: &quot;IfStatement&quot;,
    test,
    consequent,
    alternate
  };
  const defs = NODE_FIELDS.IfStatement;
  validate(defs.test, node, &quot;test&quot;, test, 1);
  validate(defs.consequent, node, &quot;consequent&quot;, consequent, 1);
  validate(defs.alternate, node, &quot;alternate&quot;, alternate, 1);
  return node;
}
function labeledStatement(label, body) {
  const node = {
    type: &quot;LabeledStatement&quot;,
    label,
    body
  };
  const defs = NODE_FIELDS.LabeledStatement;
  validate(defs.label, node, &quot;label&quot;, label, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function stringLiteral(value) {
  const node = {
    type: &quot;StringLiteral&quot;,
    value
  };
  const defs = NODE_FIELDS.StringLiteral;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function numericLiteral(value) {
  const node = {
    type: &quot;NumericLiteral&quot;,
    value
  };
  const defs = NODE_FIELDS.NumericLiteral;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function nullLiteral() {
  return {
    type: &quot;NullLiteral&quot;
  };
}
function booleanLiteral(value) {
  const node = {
    type: &quot;BooleanLiteral&quot;,
    value
  };
  const defs = NODE_FIELDS.BooleanLiteral;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function regExpLiteral(pattern, flags = &quot;&quot;) {
  const node = {
    type: &quot;RegExpLiteral&quot;,
    pattern,
    flags
  };
  const defs = NODE_FIELDS.RegExpLiteral;
  validate(defs.pattern, node, &quot;pattern&quot;, pattern);
  validate(defs.flags, node, &quot;flags&quot;, flags);
  return node;
}
function logicalExpression(operator, left, right) {
  const node = {
    type: &quot;LogicalExpression&quot;,
    operator,
    left,
    right
  };
  const defs = NODE_FIELDS.LogicalExpression;
  validate(defs.operator, node, &quot;operator&quot;, operator);
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function memberExpression(object, property, computed = false, optional = null) {
  const node = {
    type: &quot;MemberExpression&quot;,
    object,
    property,
    computed,
    optional
  };
  const defs = NODE_FIELDS.MemberExpression;
  validate(defs.object, node, &quot;object&quot;, object, 1);
  validate(defs.property, node, &quot;property&quot;, property, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.optional, node, &quot;optional&quot;, optional);
  return node;
}
function newExpression(callee, _arguments) {
  const node = {
    type: &quot;NewExpression&quot;,
    callee,
    arguments: _arguments
  };
  const defs = NODE_FIELDS.NewExpression;
  validate(defs.callee, node, &quot;callee&quot;, callee, 1);
  validate(defs.arguments, node, &quot;arguments&quot;, _arguments, 1);
  return node;
}
function program(body, directives = [], sourceType = &quot;script&quot;, interpreter = null) {
  const node = {
    type: &quot;Program&quot;,
    body,
    directives,
    sourceType,
    interpreter
  };
  const defs = NODE_FIELDS.Program;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.directives, node, &quot;directives&quot;, directives, 1);
  validate(defs.sourceType, node, &quot;sourceType&quot;, sourceType);
  validate(defs.interpreter, node, &quot;interpreter&quot;, interpreter, 1);
  return node;
}
function objectExpression(properties) {
  const node = {
    type: &quot;ObjectExpression&quot;,
    properties
  };
  const defs = NODE_FIELDS.ObjectExpression;
  validate(defs.properties, node, &quot;properties&quot;, properties, 1);
  return node;
}
function objectMethod(kind = &quot;method&quot;, key, params, body, computed = false, generator = false, async = false) {
  const node = {
    type: &quot;ObjectMethod&quot;,
    kind,
    key,
    params,
    body,
    computed,
    generator,
    async
  };
  const defs = NODE_FIELDS.ObjectMethod;
  validate(defs.kind, node, &quot;kind&quot;, kind);
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.generator, node, &quot;generator&quot;, generator);
  validate(defs.async, node, &quot;async&quot;, async);
  return node;
}
function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
  const node = {
    type: &quot;ObjectProperty&quot;,
    key,
    value,
    computed,
    shorthand,
    decorators
  };
  const defs = NODE_FIELDS.ObjectProperty;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.shorthand, node, &quot;shorthand&quot;, shorthand);
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  return node;
}
function restElement(argument) {
  const node = {
    type: &quot;RestElement&quot;,
    argument
  };
  const defs = NODE_FIELDS.RestElement;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function returnStatement(argument = null) {
  const node = {
    type: &quot;ReturnStatement&quot;,
    argument
  };
  const defs = NODE_FIELDS.ReturnStatement;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function sequenceExpression(expressions) {
  const node = {
    type: &quot;SequenceExpression&quot;,
    expressions
  };
  const defs = NODE_FIELDS.SequenceExpression;
  validate(defs.expressions, node, &quot;expressions&quot;, expressions, 1);
  return node;
}
function parenthesizedExpression(expression) {
  const node = {
    type: &quot;ParenthesizedExpression&quot;,
    expression
  };
  const defs = NODE_FIELDS.ParenthesizedExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function switchCase(test = null, consequent) {
  const node = {
    type: &quot;SwitchCase&quot;,
    test,
    consequent
  };
  const defs = NODE_FIELDS.SwitchCase;
  validate(defs.test, node, &quot;test&quot;, test, 1);
  validate(defs.consequent, node, &quot;consequent&quot;, consequent, 1);
  return node;
}
function switchStatement(discriminant, cases) {
  const node = {
    type: &quot;SwitchStatement&quot;,
    discriminant,
    cases
  };
  const defs = NODE_FIELDS.SwitchStatement;
  validate(defs.discriminant, node, &quot;discriminant&quot;, discriminant, 1);
  validate(defs.cases, node, &quot;cases&quot;, cases, 1);
  return node;
}
function thisExpression() {
  return {
    type: &quot;ThisExpression&quot;
  };
}
function throwStatement(argument) {
  const node = {
    type: &quot;ThrowStatement&quot;,
    argument
  };
  const defs = NODE_FIELDS.ThrowStatement;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function tryStatement(block, handler = null, finalizer = null) {
  const node = {
    type: &quot;TryStatement&quot;,
    block,
    handler,
    finalizer
  };
  const defs = NODE_FIELDS.TryStatement;
  validate(defs.block, node, &quot;block&quot;, block, 1);
  validate(defs.handler, node, &quot;handler&quot;, handler, 1);
  validate(defs.finalizer, node, &quot;finalizer&quot;, finalizer, 1);
  return node;
}
function unaryExpression(operator, argument, prefix = true) {
  const node = {
    type: &quot;UnaryExpression&quot;,
    operator,
    argument,
    prefix
  };
  const defs = NODE_FIELDS.UnaryExpression;
  validate(defs.operator, node, &quot;operator&quot;, operator);
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  validate(defs.prefix, node, &quot;prefix&quot;, prefix);
  return node;
}
function updateExpression(operator, argument, prefix = false) {
  const node = {
    type: &quot;UpdateExpression&quot;,
    operator,
    argument,
    prefix
  };
  const defs = NODE_FIELDS.UpdateExpression;
  validate(defs.operator, node, &quot;operator&quot;, operator);
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  validate(defs.prefix, node, &quot;prefix&quot;, prefix);
  return node;
}
function variableDeclaration(kind, declarations) {
  const node = {
    type: &quot;VariableDeclaration&quot;,
    kind,
    declarations
  };
  const defs = NODE_FIELDS.VariableDeclaration;
  validate(defs.kind, node, &quot;kind&quot;, kind);
  validate(defs.declarations, node, &quot;declarations&quot;, declarations, 1);
  return node;
}
function variableDeclarator(id, init = null) {
  const node = {
    type: &quot;VariableDeclarator&quot;,
    id,
    init
  };
  const defs = NODE_FIELDS.VariableDeclarator;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.init, node, &quot;init&quot;, init, 1);
  return node;
}
function whileStatement(test, body) {
  const node = {
    type: &quot;WhileStatement&quot;,
    test,
    body
  };
  const defs = NODE_FIELDS.WhileStatement;
  validate(defs.test, node, &quot;test&quot;, test, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function withStatement(object, body) {
  const node = {
    type: &quot;WithStatement&quot;,
    object,
    body
  };
  const defs = NODE_FIELDS.WithStatement;
  validate(defs.object, node, &quot;object&quot;, object, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function assignmentPattern(left, right) {
  const node = {
    type: &quot;AssignmentPattern&quot;,
    left,
    right
  };
  const defs = NODE_FIELDS.AssignmentPattern;
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function arrayPattern(elements) {
  const node = {
    type: &quot;ArrayPattern&quot;,
    elements
  };
  const defs = NODE_FIELDS.ArrayPattern;
  validate(defs.elements, node, &quot;elements&quot;, elements, 1);
  return node;
}
function arrowFunctionExpression(params, body, async = false) {
  const node = {
    type: &quot;ArrowFunctionExpression&quot;,
    params,
    body,
    async,
    expression: null
  };
  const defs = NODE_FIELDS.ArrowFunctionExpression;
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.async, node, &quot;async&quot;, async);
  return node;
}
function classBody(body) {
  const node = {
    type: &quot;ClassBody&quot;,
    body
  };
  const defs = NODE_FIELDS.ClassBody;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function classExpression(id = null, superClass = null, body, decorators = null) {
  const node = {
    type: &quot;ClassExpression&quot;,
    id,
    superClass,
    body,
    decorators
  };
  const defs = NODE_FIELDS.ClassExpression;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.superClass, node, &quot;superClass&quot;, superClass, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  return node;
}
function classDeclaration(id = null, superClass = null, body, decorators = null) {
  const node = {
    type: &quot;ClassDeclaration&quot;,
    id,
    superClass,
    body,
    decorators
  };
  const defs = NODE_FIELDS.ClassDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.superClass, node, &quot;superClass&quot;, superClass, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  return node;
}
function exportAllDeclaration(source) {
  const node = {
    type: &quot;ExportAllDeclaration&quot;,
    source
  };
  const defs = NODE_FIELDS.ExportAllDeclaration;
  validate(defs.source, node, &quot;source&quot;, source, 1);
  return node;
}
function exportDefaultDeclaration(declaration) {
  const node = {
    type: &quot;ExportDefaultDeclaration&quot;,
    declaration
  };
  const defs = NODE_FIELDS.ExportDefaultDeclaration;
  validate(defs.declaration, node, &quot;declaration&quot;, declaration, 1);
  return node;
}
function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
  const node = {
    type: &quot;ExportNamedDeclaration&quot;,
    declaration,
    specifiers,
    source
  };
  const defs = NODE_FIELDS.ExportNamedDeclaration;
  validate(defs.declaration, node, &quot;declaration&quot;, declaration, 1);
  validate(defs.specifiers, node, &quot;specifiers&quot;, specifiers, 1);
  validate(defs.source, node, &quot;source&quot;, source, 1);
  return node;
}
function exportSpecifier(local, exported) {
  const node = {
    type: &quot;ExportSpecifier&quot;,
    local,
    exported
  };
  const defs = NODE_FIELDS.ExportSpecifier;
  validate(defs.local, node, &quot;local&quot;, local, 1);
  validate(defs.exported, node, &quot;exported&quot;, exported, 1);
  return node;
}
function forOfStatement(left, right, body, _await = false) {
  const node = {
    type: &quot;ForOfStatement&quot;,
    left,
    right,
    body,
    await: _await
  };
  const defs = NODE_FIELDS.ForOfStatement;
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.await, node, &quot;await&quot;, _await);
  return node;
}
function importDeclaration(specifiers, source) {
  const node = {
    type: &quot;ImportDeclaration&quot;,
    specifiers,
    source
  };
  const defs = NODE_FIELDS.ImportDeclaration;
  validate(defs.specifiers, node, &quot;specifiers&quot;, specifiers, 1);
  validate(defs.source, node, &quot;source&quot;, source, 1);
  return node;
}
function importDefaultSpecifier(local) {
  const node = {
    type: &quot;ImportDefaultSpecifier&quot;,
    local
  };
  const defs = NODE_FIELDS.ImportDefaultSpecifier;
  validate(defs.local, node, &quot;local&quot;, local, 1);
  return node;
}
function importNamespaceSpecifier(local) {
  const node = {
    type: &quot;ImportNamespaceSpecifier&quot;,
    local
  };
  const defs = NODE_FIELDS.ImportNamespaceSpecifier;
  validate(defs.local, node, &quot;local&quot;, local, 1);
  return node;
}
function importSpecifier(local, imported) {
  const node = {
    type: &quot;ImportSpecifier&quot;,
    local,
    imported
  };
  const defs = NODE_FIELDS.ImportSpecifier;
  validate(defs.local, node, &quot;local&quot;, local, 1);
  validate(defs.imported, node, &quot;imported&quot;, imported, 1);
  return node;
}
function importExpression(source, options = null) {
  const node = {
    type: &quot;ImportExpression&quot;,
    source,
    options
  };
  const defs = NODE_FIELDS.ImportExpression;
  validate(defs.source, node, &quot;source&quot;, source, 1);
  validate(defs.options, node, &quot;options&quot;, options, 1);
  return node;
}
function metaProperty(meta, property) {
  const node = {
    type: &quot;MetaProperty&quot;,
    meta,
    property
  };
  const defs = NODE_FIELDS.MetaProperty;
  validate(defs.meta, node, &quot;meta&quot;, meta, 1);
  validate(defs.property, node, &quot;property&quot;, property, 1);
  return node;
}
function classMethod(kind = &quot;method&quot;, key, params, body, computed = false, _static = false, generator = false, async = false) {
  const node = {
    type: &quot;ClassMethod&quot;,
    kind,
    key,
    params,
    body,
    computed,
    static: _static,
    generator,
    async
  };
  const defs = NODE_FIELDS.ClassMethod;
  validate(defs.kind, node, &quot;kind&quot;, kind);
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.static, node, &quot;static&quot;, _static);
  validate(defs.generator, node, &quot;generator&quot;, generator);
  validate(defs.async, node, &quot;async&quot;, async);
  return node;
}
function objectPattern(properties) {
  const node = {
    type: &quot;ObjectPattern&quot;,
    properties
  };
  const defs = NODE_FIELDS.ObjectPattern;
  validate(defs.properties, node, &quot;properties&quot;, properties, 1);
  return node;
}
function spreadElement(argument) {
  const node = {
    type: &quot;SpreadElement&quot;,
    argument
  };
  const defs = NODE_FIELDS.SpreadElement;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function _super() {
  return {
    type: &quot;Super&quot;
  };
}
function taggedTemplateExpression(tag, quasi) {
  const node = {
    type: &quot;TaggedTemplateExpression&quot;,
    tag,
    quasi
  };
  const defs = NODE_FIELDS.TaggedTemplateExpression;
  validate(defs.tag, node, &quot;tag&quot;, tag, 1);
  validate(defs.quasi, node, &quot;quasi&quot;, quasi, 1);
  return node;
}
function templateElement(value, tail = false) {
  const node = {
    type: &quot;TemplateElement&quot;,
    value,
    tail
  };
  const defs = NODE_FIELDS.TemplateElement;
  validate(defs.value, node, &quot;value&quot;, value);
  validate(defs.tail, node, &quot;tail&quot;, tail);
  return node;
}
function templateLiteral(quasis, expressions) {
  const node = {
    type: &quot;TemplateLiteral&quot;,
    quasis,
    expressions
  };
  const defs = NODE_FIELDS.TemplateLiteral;
  validate(defs.quasis, node, &quot;quasis&quot;, quasis, 1);
  validate(defs.expressions, node, &quot;expressions&quot;, expressions, 1);
  return node;
}
function yieldExpression(argument = null, delegate = false) {
  const node = {
    type: &quot;YieldExpression&quot;,
    argument,
    delegate
  };
  const defs = NODE_FIELDS.YieldExpression;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  validate(defs.delegate, node, &quot;delegate&quot;, delegate);
  return node;
}
function awaitExpression(argument) {
  const node = {
    type: &quot;AwaitExpression&quot;,
    argument
  };
  const defs = NODE_FIELDS.AwaitExpression;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function _import() {
  return {
    type: &quot;Import&quot;
  };
}
function exportNamespaceSpecifier(exported) {
  const node = {
    type: &quot;ExportNamespaceSpecifier&quot;,
    exported
  };
  const defs = NODE_FIELDS.ExportNamespaceSpecifier;
  validate(defs.exported, node, &quot;exported&quot;, exported, 1);
  return node;
}
function optionalMemberExpression(object, property, computed = false, optional) {
  const node = {
    type: &quot;OptionalMemberExpression&quot;,
    object,
    property,
    computed,
    optional
  };
  const defs = NODE_FIELDS.OptionalMemberExpression;
  validate(defs.object, node, &quot;object&quot;, object, 1);
  validate(defs.property, node, &quot;property&quot;, property, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.optional, node, &quot;optional&quot;, optional);
  return node;
}
function optionalCallExpression(callee, _arguments, optional) {
  const node = {
    type: &quot;OptionalCallExpression&quot;,
    callee,
    arguments: _arguments,
    optional
  };
  const defs = NODE_FIELDS.OptionalCallExpression;
  validate(defs.callee, node, &quot;callee&quot;, callee, 1);
  validate(defs.arguments, node, &quot;arguments&quot;, _arguments, 1);
  validate(defs.optional, node, &quot;optional&quot;, optional);
  return node;
}
function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
  const node = {
    type: &quot;ClassProperty&quot;,
    key,
    value,
    typeAnnotation,
    decorators,
    computed,
    static: _static
  };
  const defs = NODE_FIELDS.ClassProperty;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.static, node, &quot;static&quot;, _static);
  return node;
}
function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
  const node = {
    type: &quot;ClassAccessorProperty&quot;,
    key,
    value,
    typeAnnotation,
    decorators,
    computed,
    static: _static
  };
  const defs = NODE_FIELDS.ClassAccessorProperty;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  validate(defs.computed, node, &quot;computed&quot;, computed);
  validate(defs.static, node, &quot;static&quot;, _static);
  return node;
}
function classPrivateProperty(key, value = null, decorators = null, _static = false) {
  const node = {
    type: &quot;ClassPrivateProperty&quot;,
    key,
    value,
    decorators,
    static: _static
  };
  const defs = NODE_FIELDS.ClassPrivateProperty;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  validate(defs.static, node, &quot;static&quot;, _static);
  return node;
}
function classPrivateMethod(kind = &quot;method&quot;, key, params, body, _static = false) {
  const node = {
    type: &quot;ClassPrivateMethod&quot;,
    kind,
    key,
    params,
    body,
    static: _static
  };
  const defs = NODE_FIELDS.ClassPrivateMethod;
  validate(defs.kind, node, &quot;kind&quot;, kind);
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.static, node, &quot;static&quot;, _static);
  return node;
}
function privateName(id) {
  const node = {
    type: &quot;PrivateName&quot;,
    id
  };
  const defs = NODE_FIELDS.PrivateName;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  return node;
}
function staticBlock(body) {
  const node = {
    type: &quot;StaticBlock&quot;,
    body
  };
  const defs = NODE_FIELDS.StaticBlock;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function importAttribute(key, value) {
  const node = {
    type: &quot;ImportAttribute&quot;,
    key,
    value
  };
  const defs = NODE_FIELDS.ImportAttribute;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  return node;
}
function anyTypeAnnotation() {
  return {
    type: &quot;AnyTypeAnnotation&quot;
  };
}
function arrayTypeAnnotation(elementType) {
  const node = {
    type: &quot;ArrayTypeAnnotation&quot;,
    elementType
  };
  const defs = NODE_FIELDS.ArrayTypeAnnotation;
  validate(defs.elementType, node, &quot;elementType&quot;, elementType, 1);
  return node;
}
function booleanTypeAnnotation() {
  return {
    type: &quot;BooleanTypeAnnotation&quot;
  };
}
function booleanLiteralTypeAnnotation(value) {
  const node = {
    type: &quot;BooleanLiteralTypeAnnotation&quot;,
    value
  };
  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function nullLiteralTypeAnnotation() {
  return {
    type: &quot;NullLiteralTypeAnnotation&quot;
  };
}
function classImplements(id, typeParameters = null) {
  const node = {
    type: &quot;ClassImplements&quot;,
    id,
    typeParameters
  };
  const defs = NODE_FIELDS.ClassImplements;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function declareClass(id, typeParameters = null, _extends = null, body) {
  const node = {
    type: &quot;DeclareClass&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  };
  const defs = NODE_FIELDS.DeclareClass;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.extends, node, &quot;extends&quot;, _extends, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function declareFunction(id) {
  const node = {
    type: &quot;DeclareFunction&quot;,
    id
  };
  const defs = NODE_FIELDS.DeclareFunction;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  return node;
}
function declareInterface(id, typeParameters = null, _extends = null, body) {
  const node = {
    type: &quot;DeclareInterface&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  };
  const defs = NODE_FIELDS.DeclareInterface;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.extends, node, &quot;extends&quot;, _extends, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function declareModule(id, body, kind = null) {
  const node = {
    type: &quot;DeclareModule&quot;,
    id,
    body,
    kind
  };
  const defs = NODE_FIELDS.DeclareModule;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.kind, node, &quot;kind&quot;, kind);
  return node;
}
function declareModuleExports(typeAnnotation) {
  const node = {
    type: &quot;DeclareModuleExports&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.DeclareModuleExports;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function declareTypeAlias(id, typeParameters = null, right) {
  const node = {
    type: &quot;DeclareTypeAlias&quot;,
    id,
    typeParameters,
    right
  };
  const defs = NODE_FIELDS.DeclareTypeAlias;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function declareOpaqueType(id, typeParameters = null, supertype = null) {
  const node = {
    type: &quot;DeclareOpaqueType&quot;,
    id,
    typeParameters,
    supertype
  };
  const defs = NODE_FIELDS.DeclareOpaqueType;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.supertype, node, &quot;supertype&quot;, supertype, 1);
  return node;
}
function declareVariable(id) {
  const node = {
    type: &quot;DeclareVariable&quot;,
    id
  };
  const defs = NODE_FIELDS.DeclareVariable;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  return node;
}
function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
  const node = {
    type: &quot;DeclareExportDeclaration&quot;,
    declaration,
    specifiers,
    source,
    attributes
  };
  const defs = NODE_FIELDS.DeclareExportDeclaration;
  validate(defs.declaration, node, &quot;declaration&quot;, declaration, 1);
  validate(defs.specifiers, node, &quot;specifiers&quot;, specifiers, 1);
  validate(defs.source, node, &quot;source&quot;, source, 1);
  validate(defs.attributes, node, &quot;attributes&quot;, attributes, 1);
  return node;
}
function declareExportAllDeclaration(source, attributes = null) {
  const node = {
    type: &quot;DeclareExportAllDeclaration&quot;,
    source,
    attributes
  };
  const defs = NODE_FIELDS.DeclareExportAllDeclaration;
  validate(defs.source, node, &quot;source&quot;, source, 1);
  validate(defs.attributes, node, &quot;attributes&quot;, attributes, 1);
  return node;
}
function declaredPredicate(value) {
  const node = {
    type: &quot;DeclaredPredicate&quot;,
    value
  };
  const defs = NODE_FIELDS.DeclaredPredicate;
  validate(defs.value, node, &quot;value&quot;, value, 1);
  return node;
}
function existsTypeAnnotation() {
  return {
    type: &quot;ExistsTypeAnnotation&quot;
  };
}
function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
  const node = {
    type: &quot;FunctionTypeAnnotation&quot;,
    typeParameters,
    params,
    rest,
    returnType
  };
  const defs = NODE_FIELDS.FunctionTypeAnnotation;
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.rest, node, &quot;rest&quot;, rest, 1);
  validate(defs.returnType, node, &quot;returnType&quot;, returnType, 1);
  return node;
}
function functionTypeParam(name = null, typeAnnotation) {
  const node = {
    type: &quot;FunctionTypeParam&quot;,
    name,
    typeAnnotation
  };
  const defs = NODE_FIELDS.FunctionTypeParam;
  validate(defs.name, node, &quot;name&quot;, name, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function genericTypeAnnotation(id, typeParameters = null) {
  const node = {
    type: &quot;GenericTypeAnnotation&quot;,
    id,
    typeParameters
  };
  const defs = NODE_FIELDS.GenericTypeAnnotation;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function inferredPredicate() {
  return {
    type: &quot;InferredPredicate&quot;
  };
}
function interfaceExtends(id, typeParameters = null) {
  const node = {
    type: &quot;InterfaceExtends&quot;,
    id,
    typeParameters
  };
  const defs = NODE_FIELDS.InterfaceExtends;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
  const node = {
    type: &quot;InterfaceDeclaration&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  };
  const defs = NODE_FIELDS.InterfaceDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.extends, node, &quot;extends&quot;, _extends, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function interfaceTypeAnnotation(_extends = null, body) {
  const node = {
    type: &quot;InterfaceTypeAnnotation&quot;,
    extends: _extends,
    body
  };
  const defs = NODE_FIELDS.InterfaceTypeAnnotation;
  validate(defs.extends, node, &quot;extends&quot;, _extends, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function intersectionTypeAnnotation(types) {
  const node = {
    type: &quot;IntersectionTypeAnnotation&quot;,
    types
  };
  const defs = NODE_FIELDS.IntersectionTypeAnnotation;
  validate(defs.types, node, &quot;types&quot;, types, 1);
  return node;
}
function mixedTypeAnnotation() {
  return {
    type: &quot;MixedTypeAnnotation&quot;
  };
}
function emptyTypeAnnotation() {
  return {
    type: &quot;EmptyTypeAnnotation&quot;
  };
}
function nullableTypeAnnotation(typeAnnotation) {
  const node = {
    type: &quot;NullableTypeAnnotation&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.NullableTypeAnnotation;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function numberLiteralTypeAnnotation(value) {
  const node = {
    type: &quot;NumberLiteralTypeAnnotation&quot;,
    value
  };
  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function numberTypeAnnotation() {
  return {
    type: &quot;NumberTypeAnnotation&quot;
  };
}
function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
  const node = {
    type: &quot;ObjectTypeAnnotation&quot;,
    properties,
    indexers,
    callProperties,
    internalSlots,
    exact
  };
  const defs = NODE_FIELDS.ObjectTypeAnnotation;
  validate(defs.properties, node, &quot;properties&quot;, properties, 1);
  validate(defs.indexers, node, &quot;indexers&quot;, indexers, 1);
  validate(defs.callProperties, node, &quot;callProperties&quot;, callProperties, 1);
  validate(defs.internalSlots, node, &quot;internalSlots&quot;, internalSlots, 1);
  validate(defs.exact, node, &quot;exact&quot;, exact);
  return node;
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
  const node = {
    type: &quot;ObjectTypeInternalSlot&quot;,
    id,
    value,
    optional,
    static: _static,
    method
  };
  const defs = NODE_FIELDS.ObjectTypeInternalSlot;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.optional, node, &quot;optional&quot;, optional);
  validate(defs.static, node, &quot;static&quot;, _static);
  validate(defs.method, node, &quot;method&quot;, method);
  return node;
}
function objectTypeCallProperty(value) {
  const node = {
    type: &quot;ObjectTypeCallProperty&quot;,
    value,
    static: null
  };
  const defs = NODE_FIELDS.ObjectTypeCallProperty;
  validate(defs.value, node, &quot;value&quot;, value, 1);
  return node;
}
function objectTypeIndexer(id = null, key, value, variance = null) {
  const node = {
    type: &quot;ObjectTypeIndexer&quot;,
    id,
    key,
    value,
    variance,
    static: null
  };
  const defs = NODE_FIELDS.ObjectTypeIndexer;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.variance, node, &quot;variance&quot;, variance, 1);
  return node;
}
function objectTypeProperty(key, value, variance = null) {
  const node = {
    type: &quot;ObjectTypeProperty&quot;,
    key,
    value,
    variance,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    static: null
  };
  const defs = NODE_FIELDS.ObjectTypeProperty;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  validate(defs.variance, node, &quot;variance&quot;, variance, 1);
  return node;
}
function objectTypeSpreadProperty(argument) {
  const node = {
    type: &quot;ObjectTypeSpreadProperty&quot;,
    argument
  };
  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function opaqueType(id, typeParameters = null, supertype = null, impltype) {
  const node = {
    type: &quot;OpaqueType&quot;,
    id,
    typeParameters,
    supertype,
    impltype
  };
  const defs = NODE_FIELDS.OpaqueType;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.supertype, node, &quot;supertype&quot;, supertype, 1);
  validate(defs.impltype, node, &quot;impltype&quot;, impltype, 1);
  return node;
}
function qualifiedTypeIdentifier(id, qualification) {
  const node = {
    type: &quot;QualifiedTypeIdentifier&quot;,
    id,
    qualification
  };
  const defs = NODE_FIELDS.QualifiedTypeIdentifier;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.qualification, node, &quot;qualification&quot;, qualification, 1);
  return node;
}
function stringLiteralTypeAnnotation(value) {
  const node = {
    type: &quot;StringLiteralTypeAnnotation&quot;,
    value
  };
  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function stringTypeAnnotation() {
  return {
    type: &quot;StringTypeAnnotation&quot;
  };
}
function symbolTypeAnnotation() {
  return {
    type: &quot;SymbolTypeAnnotation&quot;
  };
}
function thisTypeAnnotation() {
  return {
    type: &quot;ThisTypeAnnotation&quot;
  };
}
function tupleTypeAnnotation(types) {
  const node = {
    type: &quot;TupleTypeAnnotation&quot;,
    types
  };
  const defs = NODE_FIELDS.TupleTypeAnnotation;
  validate(defs.types, node, &quot;types&quot;, types, 1);
  return node;
}
function typeofTypeAnnotation(argument) {
  const node = {
    type: &quot;TypeofTypeAnnotation&quot;,
    argument
  };
  const defs = NODE_FIELDS.TypeofTypeAnnotation;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function typeAlias(id, typeParameters = null, right) {
  const node = {
    type: &quot;TypeAlias&quot;,
    id,
    typeParameters,
    right
  };
  const defs = NODE_FIELDS.TypeAlias;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function typeAnnotation(typeAnnotation) {
  const node = {
    type: &quot;TypeAnnotation&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TypeAnnotation;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function typeCastExpression(expression, typeAnnotation) {
  const node = {
    type: &quot;TypeCastExpression&quot;,
    expression,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TypeCastExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function typeParameter(bound = null, _default = null, variance = null) {
  const node = {
    type: &quot;TypeParameter&quot;,
    bound,
    default: _default,
    variance,
    name: null
  };
  const defs = NODE_FIELDS.TypeParameter;
  validate(defs.bound, node, &quot;bound&quot;, bound, 1);
  validate(defs.default, node, &quot;default&quot;, _default, 1);
  validate(defs.variance, node, &quot;variance&quot;, variance, 1);
  return node;
}
function typeParameterDeclaration(params) {
  const node = {
    type: &quot;TypeParameterDeclaration&quot;,
    params
  };
  const defs = NODE_FIELDS.TypeParameterDeclaration;
  validate(defs.params, node, &quot;params&quot;, params, 1);
  return node;
}
function typeParameterInstantiation(params) {
  const node = {
    type: &quot;TypeParameterInstantiation&quot;,
    params
  };
  const defs = NODE_FIELDS.TypeParameterInstantiation;
  validate(defs.params, node, &quot;params&quot;, params, 1);
  return node;
}
function unionTypeAnnotation(types) {
  const node = {
    type: &quot;UnionTypeAnnotation&quot;,
    types
  };
  const defs = NODE_FIELDS.UnionTypeAnnotation;
  validate(defs.types, node, &quot;types&quot;, types, 1);
  return node;
}
function variance(kind) {
  const node = {
    type: &quot;Variance&quot;,
    kind
  };
  const defs = NODE_FIELDS.Variance;
  validate(defs.kind, node, &quot;kind&quot;, kind);
  return node;
}
function voidTypeAnnotation() {
  return {
    type: &quot;VoidTypeAnnotation&quot;
  };
}
function enumDeclaration(id, body) {
  const node = {
    type: &quot;EnumDeclaration&quot;,
    id,
    body
  };
  const defs = NODE_FIELDS.EnumDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function enumBooleanBody(members) {
  const node = {
    type: &quot;EnumBooleanBody&quot;,
    members,
    explicitType: null,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumBooleanBody;
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function enumNumberBody(members) {
  const node = {
    type: &quot;EnumNumberBody&quot;,
    members,
    explicitType: null,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumNumberBody;
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function enumStringBody(members) {
  const node = {
    type: &quot;EnumStringBody&quot;,
    members,
    explicitType: null,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumStringBody;
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function enumSymbolBody(members) {
  const node = {
    type: &quot;EnumSymbolBody&quot;,
    members,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumSymbolBody;
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function enumBooleanMember(id) {
  const node = {
    type: &quot;EnumBooleanMember&quot;,
    id,
    init: null
  };
  const defs = NODE_FIELDS.EnumBooleanMember;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  return node;
}
function enumNumberMember(id, init) {
  const node = {
    type: &quot;EnumNumberMember&quot;,
    id,
    init
  };
  const defs = NODE_FIELDS.EnumNumberMember;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.init, node, &quot;init&quot;, init, 1);
  return node;
}
function enumStringMember(id, init) {
  const node = {
    type: &quot;EnumStringMember&quot;,
    id,
    init
  };
  const defs = NODE_FIELDS.EnumStringMember;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.init, node, &quot;init&quot;, init, 1);
  return node;
}
function enumDefaultedMember(id) {
  const node = {
    type: &quot;EnumDefaultedMember&quot;,
    id
  };
  const defs = NODE_FIELDS.EnumDefaultedMember;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  return node;
}
function indexedAccessType(objectType, indexType) {
  const node = {
    type: &quot;IndexedAccessType&quot;,
    objectType,
    indexType
  };
  const defs = NODE_FIELDS.IndexedAccessType;
  validate(defs.objectType, node, &quot;objectType&quot;, objectType, 1);
  validate(defs.indexType, node, &quot;indexType&quot;, indexType, 1);
  return node;
}
function optionalIndexedAccessType(objectType, indexType) {
  const node = {
    type: &quot;OptionalIndexedAccessType&quot;,
    objectType,
    indexType,
    optional: null
  };
  const defs = NODE_FIELDS.OptionalIndexedAccessType;
  validate(defs.objectType, node, &quot;objectType&quot;, objectType, 1);
  validate(defs.indexType, node, &quot;indexType&quot;, indexType, 1);
  return node;
}
function jsxAttribute(name, value = null) {
  const node = {
    type: &quot;JSXAttribute&quot;,
    name,
    value
  };
  const defs = NODE_FIELDS.JSXAttribute;
  validate(defs.name, node, &quot;name&quot;, name, 1);
  validate(defs.value, node, &quot;value&quot;, value, 1);
  return node;
}
function jsxClosingElement(name) {
  const node = {
    type: &quot;JSXClosingElement&quot;,
    name
  };
  const defs = NODE_FIELDS.JSXClosingElement;
  validate(defs.name, node, &quot;name&quot;, name, 1);
  return node;
}
function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
  const node = {
    type: &quot;JSXElement&quot;,
    openingElement,
    closingElement,
    children,
    selfClosing
  };
  const defs = NODE_FIELDS.JSXElement;
  validate(defs.openingElement, node, &quot;openingElement&quot;, openingElement, 1);
  validate(defs.closingElement, node, &quot;closingElement&quot;, closingElement, 1);
  validate(defs.children, node, &quot;children&quot;, children, 1);
  validate(defs.selfClosing, node, &quot;selfClosing&quot;, selfClosing);
  return node;
}
function jsxEmptyExpression() {
  return {
    type: &quot;JSXEmptyExpression&quot;
  };
}
function jsxExpressionContainer(expression) {
  const node = {
    type: &quot;JSXExpressionContainer&quot;,
    expression
  };
  const defs = NODE_FIELDS.JSXExpressionContainer;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function jsxSpreadChild(expression) {
  const node = {
    type: &quot;JSXSpreadChild&quot;,
    expression
  };
  const defs = NODE_FIELDS.JSXSpreadChild;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function jsxIdentifier(name) {
  const node = {
    type: &quot;JSXIdentifier&quot;,
    name
  };
  const defs = NODE_FIELDS.JSXIdentifier;
  validate(defs.name, node, &quot;name&quot;, name);
  return node;
}
function jsxMemberExpression(object, property) {
  const node = {
    type: &quot;JSXMemberExpression&quot;,
    object,
    property
  };
  const defs = NODE_FIELDS.JSXMemberExpression;
  validate(defs.object, node, &quot;object&quot;, object, 1);
  validate(defs.property, node, &quot;property&quot;, property, 1);
  return node;
}
function jsxNamespacedName(namespace, name) {
  const node = {
    type: &quot;JSXNamespacedName&quot;,
    namespace,
    name
  };
  const defs = NODE_FIELDS.JSXNamespacedName;
  validate(defs.namespace, node, &quot;namespace&quot;, namespace, 1);
  validate(defs.name, node, &quot;name&quot;, name, 1);
  return node;
}
function jsxOpeningElement(name, attributes, selfClosing = false) {
  const node = {
    type: &quot;JSXOpeningElement&quot;,
    name,
    attributes,
    selfClosing
  };
  const defs = NODE_FIELDS.JSXOpeningElement;
  validate(defs.name, node, &quot;name&quot;, name, 1);
  validate(defs.attributes, node, &quot;attributes&quot;, attributes, 1);
  validate(defs.selfClosing, node, &quot;selfClosing&quot;, selfClosing);
  return node;
}
function jsxSpreadAttribute(argument) {
  const node = {
    type: &quot;JSXSpreadAttribute&quot;,
    argument
  };
  const defs = NODE_FIELDS.JSXSpreadAttribute;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  return node;
}
function jsxText(value) {
  const node = {
    type: &quot;JSXText&quot;,
    value
  };
  const defs = NODE_FIELDS.JSXText;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function jsxFragment(openingFragment, closingFragment, children) {
  const node = {
    type: &quot;JSXFragment&quot;,
    openingFragment,
    closingFragment,
    children
  };
  const defs = NODE_FIELDS.JSXFragment;
  validate(defs.openingFragment, node, &quot;openingFragment&quot;, openingFragment, 1);
  validate(defs.closingFragment, node, &quot;closingFragment&quot;, closingFragment, 1);
  validate(defs.children, node, &quot;children&quot;, children, 1);
  return node;
}
function jsxOpeningFragment() {
  return {
    type: &quot;JSXOpeningFragment&quot;
  };
}
function jsxClosingFragment() {
  return {
    type: &quot;JSXClosingFragment&quot;
  };
}
function noop() {
  return {
    type: &quot;Noop&quot;
  };
}
function placeholder(expectedNode, name) {
  const node = {
    type: &quot;Placeholder&quot;,
    expectedNode,
    name
  };
  const defs = NODE_FIELDS.Placeholder;
  validate(defs.expectedNode, node, &quot;expectedNode&quot;, expectedNode);
  validate(defs.name, node, &quot;name&quot;, name, 1);
  return node;
}
function v8IntrinsicIdentifier(name) {
  const node = {
    type: &quot;V8IntrinsicIdentifier&quot;,
    name
  };
  const defs = NODE_FIELDS.V8IntrinsicIdentifier;
  validate(defs.name, node, &quot;name&quot;, name);
  return node;
}
function argumentPlaceholder() {
  return {
    type: &quot;ArgumentPlaceholder&quot;
  };
}
function bindExpression(object, callee) {
  const node = {
    type: &quot;BindExpression&quot;,
    object,
    callee
  };
  const defs = NODE_FIELDS.BindExpression;
  validate(defs.object, node, &quot;object&quot;, object, 1);
  validate(defs.callee, node, &quot;callee&quot;, callee, 1);
  return node;
}
function decorator(expression) {
  const node = {
    type: &quot;Decorator&quot;,
    expression
  };
  const defs = NODE_FIELDS.Decorator;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function doExpression(body, async = false) {
  const node = {
    type: &quot;DoExpression&quot;,
    body,
    async
  };
  const defs = NODE_FIELDS.DoExpression;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  validate(defs.async, node, &quot;async&quot;, async);
  return node;
}
function exportDefaultSpecifier(exported) {
  const node = {
    type: &quot;ExportDefaultSpecifier&quot;,
    exported
  };
  const defs = NODE_FIELDS.ExportDefaultSpecifier;
  validate(defs.exported, node, &quot;exported&quot;, exported, 1);
  return node;
}
function recordExpression(properties) {
  const node = {
    type: &quot;RecordExpression&quot;,
    properties
  };
  const defs = NODE_FIELDS.RecordExpression;
  validate(defs.properties, node, &quot;properties&quot;, properties, 1);
  return node;
}
function tupleExpression(elements = []) {
  const node = {
    type: &quot;TupleExpression&quot;,
    elements
  };
  const defs = NODE_FIELDS.TupleExpression;
  validate(defs.elements, node, &quot;elements&quot;, elements, 1);
  return node;
}
function decimalLiteral(value) {
  const node = {
    type: &quot;DecimalLiteral&quot;,
    value
  };
  const defs = NODE_FIELDS.DecimalLiteral;
  validate(defs.value, node, &quot;value&quot;, value);
  return node;
}
function moduleExpression(body) {
  const node = {
    type: &quot;ModuleExpression&quot;,
    body
  };
  const defs = NODE_FIELDS.ModuleExpression;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function topicReference() {
  return {
    type: &quot;TopicReference&quot;
  };
}
function pipelineTopicExpression(expression) {
  const node = {
    type: &quot;PipelineTopicExpression&quot;,
    expression
  };
  const defs = NODE_FIELDS.PipelineTopicExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function pipelineBareFunction(callee) {
  const node = {
    type: &quot;PipelineBareFunction&quot;,
    callee
  };
  const defs = NODE_FIELDS.PipelineBareFunction;
  validate(defs.callee, node, &quot;callee&quot;, callee, 1);
  return node;
}
function pipelinePrimaryTopicReference() {
  return {
    type: &quot;PipelinePrimaryTopicReference&quot;
  };
}
function voidPattern() {
  return {
    type: &quot;VoidPattern&quot;
  };
}
function tsParameterProperty(parameter) {
  const node = {
    type: &quot;TSParameterProperty&quot;,
    parameter
  };
  const defs = NODE_FIELDS.TSParameterProperty;
  validate(defs.parameter, node, &quot;parameter&quot;, parameter, 1);
  return node;
}
function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
  const node = {
    type: &quot;TSDeclareFunction&quot;,
    id,
    typeParameters,
    params,
    returnType
  };
  const defs = NODE_FIELDS.TSDeclareFunction;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.returnType, node, &quot;returnType&quot;, returnType, 1);
  return node;
}
function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
  const node = {
    type: &quot;TSDeclareMethod&quot;,
    decorators,
    key,
    typeParameters,
    params,
    returnType
  };
  const defs = NODE_FIELDS.TSDeclareMethod;
  validate(defs.decorators, node, &quot;decorators&quot;, decorators, 1);
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.params, node, &quot;params&quot;, params, 1);
  validate(defs.returnType, node, &quot;returnType&quot;, returnType, 1);
  return node;
}
function tsQualifiedName(left, right) {
  const node = {
    type: &quot;TSQualifiedName&quot;,
    left,
    right
  };
  const defs = NODE_FIELDS.TSQualifiedName;
  validate(defs.left, node, &quot;left&quot;, left, 1);
  validate(defs.right, node, &quot;right&quot;, right, 1);
  return node;
}
function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: &quot;TSCallSignatureDeclaration&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSCallSignatureDeclaration;
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.parameters, node, &quot;parameters&quot;, parameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: &quot;TSConstructSignatureDeclaration&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.parameters, node, &quot;parameters&quot;, parameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsPropertySignature(key, typeAnnotation = null) {
  const node = {
    type: &quot;TSPropertySignature&quot;,
    key,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSPropertySignature;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: &quot;TSMethodSignature&quot;,
    key,
    typeParameters,
    parameters,
    typeAnnotation,
    kind: null
  };
  const defs = NODE_FIELDS.TSMethodSignature;
  validate(defs.key, node, &quot;key&quot;, key, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.parameters, node, &quot;parameters&quot;, parameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsIndexSignature(parameters, typeAnnotation = null) {
  const node = {
    type: &quot;TSIndexSignature&quot;,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSIndexSignature;
  validate(defs.parameters, node, &quot;parameters&quot;, parameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsAnyKeyword() {
  return {
    type: &quot;TSAnyKeyword&quot;
  };
}
function tsBooleanKeyword() {
  return {
    type: &quot;TSBooleanKeyword&quot;
  };
}
function tsBigIntKeyword() {
  return {
    type: &quot;TSBigIntKeyword&quot;
  };
}
function tsIntrinsicKeyword() {
  return {
    type: &quot;TSIntrinsicKeyword&quot;
  };
}
function tsNeverKeyword() {
  return {
    type: &quot;TSNeverKeyword&quot;
  };
}
function tsNullKeyword() {
  return {
    type: &quot;TSNullKeyword&quot;
  };
}
function tsNumberKeyword() {
  return {
    type: &quot;TSNumberKeyword&quot;
  };
}
function tsObjectKeyword() {
  return {
    type: &quot;TSObjectKeyword&quot;
  };
}
function tsStringKeyword() {
  return {
    type: &quot;TSStringKeyword&quot;
  };
}
function tsSymbolKeyword() {
  return {
    type: &quot;TSSymbolKeyword&quot;
  };
}
function tsUndefinedKeyword() {
  return {
    type: &quot;TSUndefinedKeyword&quot;
  };
}
function tsUnknownKeyword() {
  return {
    type: &quot;TSUnknownKeyword&quot;
  };
}
function tsVoidKeyword() {
  return {
    type: &quot;TSVoidKeyword&quot;
  };
}
function tsThisType() {
  return {
    type: &quot;TSThisType&quot;
  };
}
function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: &quot;TSFunctionType&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSFunctionType;
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.parameters, node, &quot;parameters&quot;, parameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: &quot;TSConstructorType&quot;,
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSConstructorType;
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.parameters, node, &quot;parameters&quot;, parameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsTypeReference(typeName, typeParameters = null) {
  const node = {
    type: &quot;TSTypeReference&quot;,
    typeName,
    typeParameters
  };
  const defs = NODE_FIELDS.TSTypeReference;
  validate(defs.typeName, node, &quot;typeName&quot;, typeName, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
  const node = {
    type: &quot;TSTypePredicate&quot;,
    parameterName,
    typeAnnotation,
    asserts
  };
  const defs = NODE_FIELDS.TSTypePredicate;
  validate(defs.parameterName, node, &quot;parameterName&quot;, parameterName, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  validate(defs.asserts, node, &quot;asserts&quot;, asserts);
  return node;
}
function tsTypeQuery(exprName, typeParameters = null) {
  const node = {
    type: &quot;TSTypeQuery&quot;,
    exprName,
    typeParameters
  };
  const defs = NODE_FIELDS.TSTypeQuery;
  validate(defs.exprName, node, &quot;exprName&quot;, exprName, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function tsTypeLiteral(members) {
  const node = {
    type: &quot;TSTypeLiteral&quot;,
    members
  };
  const defs = NODE_FIELDS.TSTypeLiteral;
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function tsArrayType(elementType) {
  const node = {
    type: &quot;TSArrayType&quot;,
    elementType
  };
  const defs = NODE_FIELDS.TSArrayType;
  validate(defs.elementType, node, &quot;elementType&quot;, elementType, 1);
  return node;
}
function tsTupleType(elementTypes) {
  const node = {
    type: &quot;TSTupleType&quot;,
    elementTypes
  };
  const defs = NODE_FIELDS.TSTupleType;
  validate(defs.elementTypes, node, &quot;elementTypes&quot;, elementTypes, 1);
  return node;
}
function tsOptionalType(typeAnnotation) {
  const node = {
    type: &quot;TSOptionalType&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSOptionalType;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsRestType(typeAnnotation) {
  const node = {
    type: &quot;TSRestType&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSRestType;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsNamedTupleMember(label, elementType, optional = false) {
  const node = {
    type: &quot;TSNamedTupleMember&quot;,
    label,
    elementType,
    optional
  };
  const defs = NODE_FIELDS.TSNamedTupleMember;
  validate(defs.label, node, &quot;label&quot;, label, 1);
  validate(defs.elementType, node, &quot;elementType&quot;, elementType, 1);
  validate(defs.optional, node, &quot;optional&quot;, optional);
  return node;
}
function tsUnionType(types) {
  const node = {
    type: &quot;TSUnionType&quot;,
    types
  };
  const defs = NODE_FIELDS.TSUnionType;
  validate(defs.types, node, &quot;types&quot;, types, 1);
  return node;
}
function tsIntersectionType(types) {
  const node = {
    type: &quot;TSIntersectionType&quot;,
    types
  };
  const defs = NODE_FIELDS.TSIntersectionType;
  validate(defs.types, node, &quot;types&quot;, types, 1);
  return node;
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
  const node = {
    type: &quot;TSConditionalType&quot;,
    checkType,
    extendsType,
    trueType,
    falseType
  };
  const defs = NODE_FIELDS.TSConditionalType;
  validate(defs.checkType, node, &quot;checkType&quot;, checkType, 1);
  validate(defs.extendsType, node, &quot;extendsType&quot;, extendsType, 1);
  validate(defs.trueType, node, &quot;trueType&quot;, trueType, 1);
  validate(defs.falseType, node, &quot;falseType&quot;, falseType, 1);
  return node;
}
function tsInferType(typeParameter) {
  const node = {
    type: &quot;TSInferType&quot;,
    typeParameter
  };
  const defs = NODE_FIELDS.TSInferType;
  validate(defs.typeParameter, node, &quot;typeParameter&quot;, typeParameter, 1);
  return node;
}
function tsParenthesizedType(typeAnnotation) {
  const node = {
    type: &quot;TSParenthesizedType&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSParenthesizedType;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsTypeOperator(typeAnnotation, operator = &quot;keyof&quot;) {
  const node = {
    type: &quot;TSTypeOperator&quot;,
    typeAnnotation,
    operator
  };
  const defs = NODE_FIELDS.TSTypeOperator;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  validate(defs.operator, node, &quot;operator&quot;, operator);
  return node;
}
function tsIndexedAccessType(objectType, indexType) {
  const node = {
    type: &quot;TSIndexedAccessType&quot;,
    objectType,
    indexType
  };
  const defs = NODE_FIELDS.TSIndexedAccessType;
  validate(defs.objectType, node, &quot;objectType&quot;, objectType, 1);
  validate(defs.indexType, node, &quot;indexType&quot;, indexType, 1);
  return node;
}
function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
  const node = {
    type: &quot;TSMappedType&quot;,
    typeParameter,
    typeAnnotation,
    nameType
  };
  const defs = NODE_FIELDS.TSMappedType;
  validate(defs.typeParameter, node, &quot;typeParameter&quot;, typeParameter, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  validate(defs.nameType, node, &quot;nameType&quot;, nameType, 1);
  return node;
}
function tsTemplateLiteralType(quasis, types) {
  const node = {
    type: &quot;TSTemplateLiteralType&quot;,
    quasis,
    types
  };
  const defs = NODE_FIELDS.TSTemplateLiteralType;
  validate(defs.quasis, node, &quot;quasis&quot;, quasis, 1);
  validate(defs.types, node, &quot;types&quot;, types, 1);
  return node;
}
function tsLiteralType(literal) {
  const node = {
    type: &quot;TSLiteralType&quot;,
    literal
  };
  const defs = NODE_FIELDS.TSLiteralType;
  validate(defs.literal, node, &quot;literal&quot;, literal, 1);
  return node;
}
function tsExpressionWithTypeArguments(expression, typeParameters = null) {
  const node = {
    type: &quot;TSExpressionWithTypeArguments&quot;,
    expression,
    typeParameters
  };
  const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
  const node = {
    type: &quot;TSInterfaceDeclaration&quot;,
    id,
    typeParameters,
    extends: _extends,
    body
  };
  const defs = NODE_FIELDS.TSInterfaceDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.extends, node, &quot;extends&quot;, _extends, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function tsInterfaceBody(body) {
  const node = {
    type: &quot;TSInterfaceBody&quot;,
    body
  };
  const defs = NODE_FIELDS.TSInterfaceBody;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
  const node = {
    type: &quot;TSTypeAliasDeclaration&quot;,
    id,
    typeParameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSTypeAliasDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsInstantiationExpression(expression, typeParameters = null) {
  const node = {
    type: &quot;TSInstantiationExpression&quot;,
    expression,
    typeParameters
  };
  const defs = NODE_FIELDS.TSInstantiationExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function tsAsExpression(expression, typeAnnotation) {
  const node = {
    type: &quot;TSAsExpression&quot;,
    expression,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSAsExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsSatisfiesExpression(expression, typeAnnotation) {
  const node = {
    type: &quot;TSSatisfiesExpression&quot;,
    expression,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSSatisfiesExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsTypeAssertion(typeAnnotation, expression) {
  const node = {
    type: &quot;TSTypeAssertion&quot;,
    typeAnnotation,
    expression
  };
  const defs = NODE_FIELDS.TSTypeAssertion;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function tsEnumBody(members) {
  const node = {
    type: &quot;TSEnumBody&quot;,
    members
  };
  const defs = NODE_FIELDS.TSEnumBody;
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function tsEnumDeclaration(id, members) {
  const node = {
    type: &quot;TSEnumDeclaration&quot;,
    id,
    members
  };
  const defs = NODE_FIELDS.TSEnumDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.members, node, &quot;members&quot;, members, 1);
  return node;
}
function tsEnumMember(id, initializer = null) {
  const node = {
    type: &quot;TSEnumMember&quot;,
    id,
    initializer
  };
  const defs = NODE_FIELDS.TSEnumMember;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.initializer, node, &quot;initializer&quot;, initializer, 1);
  return node;
}
function tsModuleDeclaration(id, body) {
  const node = {
    type: &quot;TSModuleDeclaration&quot;,
    id,
    body,
    kind: null
  };
  const defs = NODE_FIELDS.TSModuleDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function tsModuleBlock(body) {
  const node = {
    type: &quot;TSModuleBlock&quot;,
    body
  };
  const defs = NODE_FIELDS.TSModuleBlock;
  validate(defs.body, node, &quot;body&quot;, body, 1);
  return node;
}
function tsImportType(argument, qualifier = null, typeParameters = null) {
  const node = {
    type: &quot;TSImportType&quot;,
    argument,
    qualifier,
    typeParameters
  };
  const defs = NODE_FIELDS.TSImportType;
  validate(defs.argument, node, &quot;argument&quot;, argument, 1);
  validate(defs.qualifier, node, &quot;qualifier&quot;, qualifier, 1);
  validate(defs.typeParameters, node, &quot;typeParameters&quot;, typeParameters, 1);
  return node;
}
function tsImportEqualsDeclaration(id, moduleReference) {
  const node = {
    type: &quot;TSImportEqualsDeclaration&quot;,
    id,
    moduleReference,
    isExport: null
  };
  const defs = NODE_FIELDS.TSImportEqualsDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  validate(defs.moduleReference, node, &quot;moduleReference&quot;, moduleReference, 1);
  return node;
}
function tsExternalModuleReference(expression) {
  const node = {
    type: &quot;TSExternalModuleReference&quot;,
    expression
  };
  const defs = NODE_FIELDS.TSExternalModuleReference;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function tsNonNullExpression(expression) {
  const node = {
    type: &quot;TSNonNullExpression&quot;,
    expression
  };
  const defs = NODE_FIELDS.TSNonNullExpression;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function tsExportAssignment(expression) {
  const node = {
    type: &quot;TSExportAssignment&quot;,
    expression
  };
  const defs = NODE_FIELDS.TSExportAssignment;
  validate(defs.expression, node, &quot;expression&quot;, expression, 1);
  return node;
}
function tsNamespaceExportDeclaration(id) {
  const node = {
    type: &quot;TSNamespaceExportDeclaration&quot;,
    id
  };
  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
  validate(defs.id, node, &quot;id&quot;, id, 1);
  return node;
}
function tsTypeAnnotation(typeAnnotation) {
  const node = {
    type: &quot;TSTypeAnnotation&quot;,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSTypeAnnotation;
  validate(defs.typeAnnotation, node, &quot;typeAnnotation&quot;, typeAnnotation, 1);
  return node;
}
function tsTypeParameterInstantiation(params) {
  const node = {
    type: &quot;TSTypeParameterInstantiation&quot;,
    params
  };
  const defs = NODE_FIELDS.TSTypeParameterInstantiation;
  validate(defs.params, node, &quot;params&quot;, params, 1);
  return node;
}
function tsTypeParameterDeclaration(params) {
  const node = {
    type: &quot;TSTypeParameterDeclaration&quot;,
    params
  };
  const defs = NODE_FIELDS.TSTypeParameterDeclaration;
  validate(defs.params, node, &quot;params&quot;, params, 1);
  return node;
}
function tsTypeParameter(constraint = null, _default = null, name) {
  const node = {
    type: &quot;TSTypeParameter&quot;,
    constraint,
    default: _default,
    name
  };
  const defs = NODE_FIELDS.TSTypeParameter;
  validate(defs.constraint, node, &quot;constraint&quot;, constraint, 1);
  validate(defs.default, node, &quot;default&quot;, _default, 1);
  validate(defs.name, node, &quot;name&quot;, name);
  return node;
}
function NumberLiteral(value) {
  (0, _deprecationWarning.default)(&quot;NumberLiteral&quot;, &quot;NumericLiteral&quot;, &quot;The node type &quot;);
  return numericLiteral(value);
}
function RegexLiteral(pattern, flags = &quot;&quot;) {
  (0, _deprecationWarning.default)(&quot;RegexLiteral&quot;, &quot;RegExpLiteral&quot;, &quot;The node type &quot;);
  return regExpLiteral(pattern, flags);
}
function RestProperty(argument) {
  (0, _deprecationWarning.default)(&quot;RestProperty&quot;, &quot;RestElement&quot;, &quot;The node type &quot;);
  return restElement(argument);
}
function SpreadProperty(argument) {
  (0, _deprecationWarning.default)(&quot;SpreadProperty&quot;, &quot;SpreadElement&quot;, &quot;The node type &quot;);
  return spreadElement(argument);
}

//# sourceMappingURL=lowercase.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
