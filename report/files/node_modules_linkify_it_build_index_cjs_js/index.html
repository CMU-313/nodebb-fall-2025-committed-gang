<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/linkify-it/build/index.cjs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/linkify-it/build/index.cjs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">833</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">76.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.85</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var uc_micro = require(&#039;uc.micro&#039;);

function reFactory (opts) {
  const re = {};
  opts = opts || {};

  re.src_Any = uc_micro.Any.source;
  re.src_Cc = uc_micro.Cc.source;
  re.src_Z = uc_micro.Z.source;
  re.src_P = uc_micro.P.source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join(&#039;|&#039;);

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [re.src_Z, re.src_Cc].join(&#039;|&#039;);

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  const text_separators = &#039;[&gt;&lt;\uff5c]&#039;;

  // All possible word characters (everything without punctuation, spaces &amp; controls)
  // Defined via punctuation &amp; spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter = &#039;(?:(?!&#039; + text_separators + &#039;|&#039; + re.src_ZPCc + &#039;)&#039; + re.src_Any + &#039;)&#039;;
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = &#039;(?:(?![0-9]|&#039; + src_ZPCc + &#039;)&#039; + src_Any + &#039;)&#039;;

  re.src_ip4 =

    &#039;(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&#039;;

  // Prohibit any of &quot;@/[]()&quot; in user/pass to avoid wrong domain fetch.
  re.src_auth = &#039;(?:(?:(?!&#039; + re.src_ZCc + &#039;|[@/\\[\\]()]).)+@)?&#039;;

  re.src_port =

    &#039;(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?&#039;;

  re.src_host_terminator =

    &#039;(?=$|&#039; + text_separators + &#039;|&#039; + re.src_ZPCc + &#039;)&#039; +
    &#039;(?!&#039; + (opts[&#039;---&#039;] ? &#039;-(?!--)|&#039; : &#039;-|&#039;) + &#039;_|:\\d|\\.-|\\.(?!$|&#039; + re.src_ZPCc + &#039;))&#039;;

  re.src_path =

    &#039;(?:&#039; +
      &#039;[/?#]&#039; +
        &#039;(?:&#039; +
          &#039;(?!&#039; + re.src_ZCc + &#039;|&#039; + text_separators + &#039;|[()[\\]{}.,&quot;\&#039;?!\\-;]).|&#039; +
          &#039;\\[(?:(?!&#039; + re.src_ZCc + &#039;|\\]).)*\\]|&#039; +
          &#039;\\((?:(?!&#039; + re.src_ZCc + &#039;|[)]).)*\\)|&#039; +
          &#039;\\{(?:(?!&#039; + re.src_ZCc + &#039;|[}]).)*\\}|&#039; +
          &#039;\\&quot;(?:(?!&#039; + re.src_ZCc + &#039;|[&quot;]).)+\\&quot;|&#039; +
          &quot;\\&#039;(?:(?!&quot; + re.src_ZCc + &quot;|[&#039;]).)+\\&#039;|&quot; +

          // allow `I&#039;m_king` if no pair found
          &quot;\\&#039;(?=&quot; + re.src_pseudo_letter + &#039;|[-])|&#039; +

          // google has many dots in &quot;google search&quot; links (#66, #81).
          // github has ... in commit range links,
          // Restrict to
          // - english
          // - percent-encoded
          // - parts of file path
          // - params separator
          // until more examples found.
          &#039;\\.{2,}[a-zA-Z0-9%/&amp;]|&#039; +

          &#039;\\.(?!&#039; + re.src_ZCc + &#039;|[.]|$)|&#039; +
          (opts[&#039;---&#039;]
            ? &#039;\\-(?!--(?:[^-]|$))(?:-*)|&#039; // `---` =&gt; long dash, terminate
            : &#039;\\-+|&#039;
          ) +
          // allow `,,,` in paths
          &#039;,(?!&#039; + re.src_ZCc + &#039;|$)|&#039; +

          // allow `;` if not followed by space-like char
          &#039;;(?!&#039; + re.src_ZCc + &#039;|$)|&#039; +

          // allow `!!!` in paths, but not at the end
          &#039;\\!+(?!&#039; + re.src_ZCc + &#039;|[!]|$)|&#039; +

          &#039;\\?(?!&#039; + re.src_ZCc + &#039;|[?]|$)&#039; +
        &#039;)+&#039; +
      &#039;|\\/&#039; +
    &#039;)?&#039;;

  // Allow anything in markdown spec, forbid quote (&quot;) at the first position
  // because emails enclosed in quotes are far more common
  re.src_email_name =

    &#039;[\\-;:&amp;=\\+\\$,\\.a-zA-Z0-9_][\\-;:&amp;=\\+\\$,\\&quot;\\.a-zA-Z0-9_]*&#039;;

  re.src_xn =

    &#039;xn--[a-z0-9\\-]{1,59}&#039;;

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

    // Allow letters &amp; digits (http://test1)
    &#039;(?:&#039; +
      re.src_xn +
      &#039;|&#039; +
      re.src_pseudo_letter + &#039;{1,63}&#039; +
    &#039;)&#039;;

  re.src_domain =

    &#039;(?:&#039; +
      re.src_xn +
      &#039;|&#039; +
      &#039;(?:&#039; + re.src_pseudo_letter + &#039;)&#039; +
      &#039;|&#039; +
      &#039;(?:&#039; + re.src_pseudo_letter + &#039;(?:-|&#039; + re.src_pseudo_letter + &#039;){0,61}&#039; + re.src_pseudo_letter + &#039;)&#039; +
    &#039;)&#039;;

  re.src_host =

    &#039;(?:&#039; +
    // Don&#039;t need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // &#039;|&#039; +
      &#039;(?:(?:(?:&#039; + re.src_domain + &#039;)\\.)*&#039; + re.src_domain/* _root */ + &#039;)&#039; +
    &#039;)&#039;;

  re.tpl_host_fuzzy =

    &#039;(?:&#039; +
      re.src_ip4 +
    &#039;|&#039; +
      &#039;(?:(?:(?:&#039; + re.src_domain + &#039;)\\.)+(?:%TLDS%))&#039; +
    &#039;)&#039;;

  re.tpl_host_no_ip_fuzzy =

    &#039;(?:(?:(?:&#039; + re.src_domain + &#039;)\\.)+(?:%TLDS%))&#039;;

  re.src_host_strict =

    re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict =

    re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict =

    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;

  //
  // Main rules
  //

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test =

    &#039;localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:&#039; + re.src_ZPCc + &#039;|&gt;|$))&#039;;

  re.tpl_email_fuzzy =

      &#039;(^|&#039; + text_separators + &#039;|&quot;|\\(|&#039; + re.src_ZCc + &#039;)&#039; +
      &#039;(&#039; + re.src_email_name + &#039;@&#039; + re.tpl_host_fuzzy_strict + &#039;)&#039;;

  re.tpl_link_fuzzy =
      // Fuzzy link can&#039;t be prepended with .:/\- and non punctuation.
      // but can start with &gt; (markdown blockquote)
      &#039;(^|(?![.:/\\-_@])(?:[$+&lt;=&gt;^`|\uff5c]|&#039; + re.src_ZPCc + &#039;))&#039; +
      &#039;((?![$+&lt;=&gt;^`|\uff5c])&#039; + re.tpl_host_port_fuzzy_strict + re.src_path + &#039;)&#039;;

  re.tpl_link_no_ip_fuzzy =
      // Fuzzy link can&#039;t be prepended with .:/\- and non punctuation.
      // but can start with &gt; (markdown blockquote)
      &#039;(^|(?![.:/\\-_@])(?:[$+&lt;=&gt;^`|\uff5c]|&#039; + re.src_ZPCc + &#039;))&#039; +
      &#039;((?![$+&lt;=&gt;^`|\uff5c])&#039; + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + &#039;)&#039;;

  return re
}

//
// Helpers
//

// Merge objects
//
function assign (obj /* from1, from2, from3, ... */) {
  const sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj
}

function _class (obj) { return Object.prototype.toString.call(obj) }
function isString (obj) { return _class(obj) === &#039;[object String]&#039; }
function isObject (obj) { return _class(obj) === &#039;[object Object]&#039; }
function isRegExp (obj) { return _class(obj) === &#039;[object RegExp]&#039; }
function isFunction (obj) { return _class(obj) === &#039;[object Function]&#039; }

function escapeRE (str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, &#039;\\$&amp;&#039;) }

//

const defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj (obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    /* eslint-disable-next-line no-prototype-builtins */
    return acc || defaultOptions.hasOwnProperty(k)
  }, false)
}

const defaultSchemas = {
  &#039;http:&#039;: {
    validate: function (text, pos, self) {
      const tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because &quot;host&quot;-containing variables can change on tlds update.
        self.re.http = new RegExp(
          &#039;^\\/\\/&#039; + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, &#039;i&#039;
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length
      }
      return 0
    }
  },
  &#039;https:&#039;: &#039;http:&#039;,
  &#039;ftp:&#039;: &#039;http:&#039;,
  &#039;//&#039;: {
    validate: function (text, pos, self) {
      const tail = text.slice(pos);

      if (!self.re.no_http) {
      // compile lazily, because &quot;host&quot;-containing variables can change on tlds update.
        self.re.no_http = new RegExp(
          &#039;^&#039; +
          self.re.src_auth +
          // Don&#039;t allow single-level domains, because of false positives like &#039;//test&#039;
          // with code comments
          &#039;(?:localhost|(?:(?:&#039; + self.re.src_domain + &#039;)\\.)+&#039; + self.re.src_domain_root + &#039;)&#039; +
          self.re.src_port +
          self.re.src_host_terminator +
          self.re.src_path,

          &#039;i&#039;
        );
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` &amp; `///`, that protects from errors in protocol name
        if (pos &gt;= 3 &amp;&amp; text[pos - 3] === &#039;:&#039;) { return 0 }
        if (pos &gt;= 3 &amp;&amp; text[pos - 3] === &#039;/&#039;) { return 0 }
        return tail.match(self.re.no_http)[0].length
      }
      return 0
    }
  },
  &#039;mailto:&#039;: {
    validate: function (text, pos, self) {
      const tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp(
          &#039;^&#039; + self.re.src_email_name + &#039;@&#039; + self.re.src_host_strict, &#039;i&#039;
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length
      }
      return 0
    }
  }
};

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
/* eslint-disable-next-line max-len */
const tlds_2ch_src_re = &#039;a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]&#039;;

// DON&#039;T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
const tlds_default = &#039;biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф&#039;.split(&#039;|&#039;);

function resetScanCache (self) {
  self.__index__ = -1;
  self.__text_cache__ = &#039;&#039;;
}

function createValidator (re) {
  return function (text, pos) {
    const tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length
    }
    return 0
  }
}

function createNormalizer () {
  return function (match, self) {
    self.normalize(match);
  }
}

// Schemas compiler. Build regexps.
//
function compile (self) {
  // Load &amp; clone RE patterns.
  const re = self.re = reFactory(self.__opts__);

  // Define dynamic patterns
  const tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join(&#039;|&#039;);

  function untpl (tpl) { return tpl.replace(&#039;%TLDS%&#039;, re.src_tlds) }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), &#039;i&#039;);
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), &#039;i&#039;);
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), &#039;i&#039;);
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), &#039;i&#039;);

  //
  // Compile each schema
  //

  const aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError (name, val) {
    throw new Error(&#039;(LinkifyIt) Invalid schema &quot;&#039; + name + &#039;&quot;: &#039; + val)
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    const val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) { return }

    const compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return
    }

    if (isString(val)) {
      aliases.push(name);
      return
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return
    }

    self.__compiled__[alias].validate =
      self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize =
      self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[&#039;&#039;] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  const slist = Object.keys(self.__compiled__)
    .filter(function (name) {
      // Filter disabled &amp; fake schemas
      return name.length &gt; 0 &amp;&amp; self.__compiled__[name]
    })
    .map(escapeRE)
    .join(&#039;|&#039;);
  // (?!_) cause 1.5x slowdown
  self.re.schema_test = RegExp(&#039;(^|(?!_)(?:[&gt;&lt;\uff5c]|&#039; + re.src_ZPCc + &#039;))(&#039; + slist + &#039;)&#039;, &#039;i&#039;);
  self.re.schema_search = RegExp(&#039;(^|(?!_)(?:[&gt;&lt;\uff5c]|&#039; + re.src_ZPCc + &#039;))(&#039; + slist + &#039;)&#039;, &#039;ig&#039;);
  self.re.schema_at_start = RegExp(&#039;^&#039; + self.re.schema_search.source, &#039;i&#039;);

  self.re.pretest = RegExp(
    &#039;(&#039; + self.re.schema_test.source + &#039;)|(&#039; + self.re.host_fuzzy_test.source + &#039;)|@&#039;,
    &#039;i&#039;
  );

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match (self, shift) {
  const start = self.__index__;
  const end = self.__last_index__;
  const text = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -&gt; String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -&gt; Number
   *
   * First position of matched string.
   **/
  this.index = start + shift;
  /**
   * Match#lastIndex -&gt; Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -&gt; String
   *
   * Matched string.
   **/
  this.raw = text;
  /**
   * Match#text -&gt; String
   *
   * Notmalized text of matched string.
   **/
  this.text = text;
  /**
   * Match#url -&gt; String
   *
   * Normalized url of matched string.
   **/
  this.url = text;
}

function createMatch (self, shift) {
  const match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match
}

/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` &amp; `//...` links
 * - &quot;fuzzy&quot; links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text &amp; url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt (schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options)
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position
  this.__schema__ = &#039;&#039;;
  this.__text_cache__ = &#039;&#039;;

  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};

  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;

  this.re = {};

  compile(this);
}

/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add (schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this
};

/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set (options) {
  this.__opts__ = assign(this.__opts__, options);
  return this
};

/**
 * LinkifyIt#test(text) -&gt; Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test (text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) { return false }

  let m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that&#039;s the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break
      }
    }
  }

  if (this.__opts__.fuzzyLink &amp;&amp; this.__compiled__[&#039;http:&#039;]) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos &gt;= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ &lt; 0 || tld_pos &lt; this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;

          if (this.__index__ &lt; 0 || shift &lt; this.__index__) {
            this.__schema__ = &#039;&#039;;
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail &amp;&amp; this.__compiled__[&#039;mailto:&#039;]) {
    // guess schemaless emails
    at_pos = text.indexOf(&#039;@&#039;);
    if (at_pos &gt;= 0) {
      // We can&#039;t skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ &lt; 0 || shift &lt; this.__index__ ||
            (shift === this.__index__ &amp;&amp; next &gt; this.__last_index__)) {
          this.__schema__ = &#039;mailto:&#039;;
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ &gt;= 0
};

/**
 * LinkifyIt#pretest(text) -&gt; Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest (text) {
  return this.re.pretest.test(text)
};

/**
 * LinkifyIt#testSchemaAt(text, name, position) -&gt; Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt (text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this)
};

/**
 * LinkifyIt#match(text) -&gt; Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match (text) {
  const result = [];
  let shift = 0;

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ &gt;= 0 &amp;&amp; this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  let tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result
  }

  return null
};

/**
 * LinkifyIt#matchAtStart(text) -&gt; Match|null
 *
 * Returns fully-formed (not fuzzy) link if it starts at the beginning
 * of the string, and null otherwise.
 **/
LinkifyIt.prototype.matchAtStart = function matchAtStart (text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) return null

  const m = this.re.schema_at_start.exec(text);
  if (!m) return null

  const len = this.testSchemaAt(text, m[2], m[0].length);
  if (!len) return null

  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;

  return createMatch(this, 0)
};

/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -&gt; this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds (list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this
  }

  this.__tlds__ = this.__tlds__.concat(list)
    .sort()
    .filter(function (el, idx, arr) {
      return el !== arr[idx - 1]
    })
    .reverse();

  compile(this);
  return this
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it&#039;s own).
 **/
LinkifyIt.prototype.normalize = function normalize (match) {
  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) { match.url = &#039;http://&#039; + match.url; }

  if (match.schema === &#039;mailto:&#039; &amp;&amp; !/^mailto:/i.test(match.url)) {
    match.url = &#039;mailto:&#039; + match.url;
  }
};

/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile () {
};

module.exports = LinkifyIt;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
