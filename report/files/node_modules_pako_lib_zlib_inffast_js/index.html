<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pako/lib/zlib/inffast.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pako/lib/zlib/inffast.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">22.73</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">345</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">110.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided &#039;as-is&#039;, without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 16209;       /* got a data error -- remain here until reset */
const TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in &gt;= 6
        strm.avail_out &gt;= 258
        start &gt;= strm.avail_out
        state.bits &lt; 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in &gt;= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out &gt;= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in &lt; last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()&#039;s initial strm.output */
  let end;                    /* while out &lt; end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 &lt;&lt; state.lenbits) - 1;
  dmask = (1 &lt;&lt; state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits &lt; 15) {
      hold += input[_in++] &lt;&lt; bits;
      bits += 8;
      hold += input[_in++] &lt;&lt; bits;
      bits += 8;
    }

    here = lcode[hold &amp; lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here &gt;&gt;&gt; 24/*here.bits*/;
      hold &gt;&gt;&gt;= op;
      bits -= op;
      op = (here &gt;&gt;&gt; 16) &amp; 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
        //        &quot;inflate:         literal &#039;%c&#039;\n&quot; :
        //        &quot;inflate:         literal 0x%02x\n&quot;, here.val));
        output[_out++] = here &amp; 0xffff/*here.val*/;
      }
      else if (op &amp; 16) {                     /* length base */
        len = here &amp; 0xffff/*here.val*/;
        op &amp;= 15;                           /* number of extra bits */
        if (op) {
          if (bits &lt; op) {
            hold += input[_in++] &lt;&lt; bits;
            bits += 8;
          }
          len += hold &amp; ((1 &lt;&lt; op) - 1);
          hold &gt;&gt;&gt;= op;
          bits -= op;
        }
        //Tracevv((stderr, &quot;inflate:         length %u\n&quot;, len));
        if (bits &lt; 15) {
          hold += input[_in++] &lt;&lt; bits;
          bits += 8;
          hold += input[_in++] &lt;&lt; bits;
          bits += 8;
        }
        here = dcode[hold &amp; dmask];

        dodist:
        for (;;) { // goto emulation
          op = here &gt;&gt;&gt; 24/*here.bits*/;
          hold &gt;&gt;&gt;= op;
          bits -= op;
          op = (here &gt;&gt;&gt; 16) &amp; 0xff/*here.op*/;

          if (op &amp; 16) {                      /* distance base */
            dist = here &amp; 0xffff/*here.val*/;
            op &amp;= 15;                       /* number of extra bits */
            if (bits &lt; op) {
              hold += input[_in++] &lt;&lt; bits;
              bits += 8;
              if (bits &lt; op) {
                hold += input[_in++] &lt;&lt; bits;
                bits += 8;
              }
            }
            dist += hold &amp; ((1 &lt;&lt; op) - 1);
//#ifdef INFLATE_STRICT
            if (dist &gt; dmax) {
              strm.msg = &#039;invalid distance too far back&#039;;
              state.mode = BAD;
              break top;
            }
//#endif
            hold &gt;&gt;&gt;= op;
            bits -= op;
            //Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, dist));
            op = _out - beg;                /* max distance in output */
            if (dist &gt; op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op &gt; whave) {
                if (state.sane) {
                  strm.msg = &#039;invalid distance too far back&#039;;
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don&#039;t enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len &lt;= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op &gt; whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op &lt; len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext &lt; op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op &lt; len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext &lt; len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op &lt; len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len &gt; 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len &gt; 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len &gt; 2);
              if (len) {
                output[_out++] = output[from++];
                if (len &gt; 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op &amp; 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here &amp; 0xffff)/*here.val*/ + (hold &amp; ((1 &lt;&lt; op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = &#039;invalid distance code&#039;;
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via &quot;continue&quot;
        }
      }
      else if ((op &amp; 64) === 0) {              /* 2nd level length code */
        here = lcode[(here &amp; 0xffff)/*here.val*/ + (hold &amp; ((1 &lt;&lt; op) - 1))];
        continue dolen;
      }
      else if (op &amp; 32) {                     /* end-of-block */
        //Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = &#039;invalid literal/length code&#039;;
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via &quot;continue&quot;
    }
  } while (_in &lt; last &amp;&amp; _out &lt; end);

  /* return unused bytes (on entry, bits &lt; 8, so in won&#039;t go too far back) */
  len = bits &gt;&gt; 3;
  _in -= len;
  bits -= len &lt;&lt; 3;
  hold &amp;= (1 &lt;&lt; bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in &lt; last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out &lt; end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
