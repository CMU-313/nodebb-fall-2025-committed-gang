<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/src/SignedData.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/src/SignedData.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1064</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">114.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.71</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import * as asn1js from &quot;asn1js&quot;;
import { getParametersValue, utilConcatBuf, isEqualBuffer, clearProps } from &quot;pvutils&quot;;
import { getCrypto, getEngine, getOIDByAlgorithm, getAlgorithmByOID } from &quot;./common.js&quot;;
import AlgorithmIdentifier from &quot;./AlgorithmIdentifier.js&quot;;
import EncapsulatedContentInfo from &quot;./EncapsulatedContentInfo.js&quot;;
import Certificate from &quot;./Certificate.js&quot;;
import CertificateRevocationList from &quot;./CertificateRevocationList.js&quot;;
import OtherRevocationInfoFormat from &quot;./OtherRevocationInfoFormat.js&quot;;
import SignerInfo from &quot;./SignerInfo.js&quot;;
import CertificateSet from &quot;./CertificateSet.js&quot;;
import RevocationInfoChoices from &quot;./RevocationInfoChoices.js&quot;;
import IssuerAndSerialNumber from &quot;./IssuerAndSerialNumber.js&quot;;
import TSTInfo from &quot;./TSTInfo.js&quot;;
import CertificateChainValidationEngine from &quot;./CertificateChainValidationEngine.js&quot;;
import BasicOCSPResponse from &quot;./BasicOCSPResponse.js&quot;;
//**************************************************************************************
/**
 * Class from RFC5652
 */
export default class SignedData 
{
	//**********************************************************************************
	/**
	 * Constructor for SignedData class
	 * @param {Object} [parameters={}]
	 * @property {Object} [schema] asn1js parsed value
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @description version
		 */
		this.version = getParametersValue(parameters, &quot;version&quot;, SignedData.defaultValues(&quot;version&quot;));
		/**
		 * @type {Array.&lt;AlgorithmIdentifier&gt;}
		 * @description digestAlgorithms
		 */
		this.digestAlgorithms = getParametersValue(parameters, &quot;digestAlgorithms&quot;, SignedData.defaultValues(&quot;digestAlgorithms&quot;));
		/**
		 * @type {EncapsulatedContentInfo}
		 * @description encapContentInfo
		 */
		this.encapContentInfo = getParametersValue(parameters, &quot;encapContentInfo&quot;, SignedData.defaultValues(&quot;encapContentInfo&quot;));
		
		if(&quot;certificates&quot; in parameters)
			/**
			 * @type {Array.&lt;Certificate|OtherCertificateFormat&gt;}
			 * @description certificates
			 */
			this.certificates = getParametersValue(parameters, &quot;certificates&quot;, SignedData.defaultValues(&quot;certificates&quot;));
		
		if(&quot;crls&quot; in parameters)
			/**
			 * @type {Array.&lt;CertificateRevocationList|OtherRevocationInfoFormat&gt;}
			 * @description crls
			 */
			this.crls = getParametersValue(parameters, &quot;crls&quot;, SignedData.defaultValues(&quot;crls&quot;));
		
		if(&quot;ocsps&quot; in parameters)
			/**
			 * @type {Array.&lt;BasicOCSPResponse&gt;}
			 * @description crls
			 */
			this.ocsps = getParametersValue(parameters, &quot;ocsps&quot;, SignedData.defaultValues(&quot;ocsps&quot;));

		/**
		 * @type {Array.&lt;SignerInfo&gt;}
		 * @description signerInfos
		 */
		this.signerInfos = getParametersValue(parameters, &quot;signerInfos&quot;, SignedData.defaultValues(&quot;signerInfos&quot;));
		//endregion
		
		//region If input argument array contains &quot;schema&quot; for this object
		if(&quot;schema&quot; in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case &quot;version&quot;:
				return 0;
			case &quot;digestAlgorithms&quot;:
				return [];
			case &quot;encapContentInfo&quot;:
				return new EncapsulatedContentInfo();
			case &quot;certificates&quot;:
				return [];
			case &quot;crls&quot;:
				return [];
			case &quot;ocsps&quot;:
				return [];
			case &quot;signerInfos&quot;:
				return [];
			default:
				throw new Error(`Invalid member name for SignedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case &quot;version&quot;:
				return (memberValue === SignedData.defaultValues(&quot;version&quot;));
			case &quot;encapContentInfo&quot;:
				return new EncapsulatedContentInfo();
			case &quot;digestAlgorithms&quot;:
			case &quot;certificates&quot;:
			case &quot;crls&quot;:
			case &quot;ocsps&quot;:
			case &quot;signerInfos&quot;:
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for SignedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of asn1js schema for current class
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		//SignedData ::= SEQUENCE {
		//    version CMSVersion,
		//    digestAlgorithms DigestAlgorithmIdentifiers,
		//    encapContentInfo EncapsulatedContentInfo,
		//    certificates [0] IMPLICIT CertificateSet OPTIONAL,
		//    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
		//    signerInfos SignerInfos }
		
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [optional]
		 * @property {string} [digestAlgorithms]
		 * @property {string} [encapContentInfo]
		 * @property {string} [certificates]
		 * @property {string} [crls]
		 * @property {string} [signerInfos]
		 */
		const names = getParametersValue(parameters, &quot;names&quot;, {});

		if((&quot;optional&quot; in names) === false)
			names.optional = false;
		
		return (new asn1js.Sequence({
			name: (names.blockName || &quot;SignedData&quot;),
			optional: names.optional,
			value: [
				new asn1js.Integer({ name: (names.version || &quot;SignedData.version&quot;) }),
				new asn1js.Set({
					value: [
						new asn1js.Repeated({
							name: (names.digestAlgorithms || &quot;SignedData.digestAlgorithms&quot;),
							value: AlgorithmIdentifier.schema()
						})
					]
				}),
				EncapsulatedContentInfo.schema(names.encapContentInfo || {
					names: {
						blockName: &quot;SignedData.encapContentInfo&quot;
					}
				}),
				new asn1js.Constructed({
					name: (names.certificates || &quot;SignedData.certificates&quot;),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: CertificateSet.schema().valueBlock.value
				}), // IMPLICIT CertificateSet
				new asn1js.Constructed({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: RevocationInfoChoices.schema(names.crls || {
						names: {
							crls: &quot;SignedData.crls&quot;
						}
					}).valueBlock.value
				}), // IMPLICIT RevocationInfoChoices
				new asn1js.Set({
					value: [
						new asn1js.Repeated({
							name: (names.signerInfos || &quot;SignedData.signerInfos&quot;),
							value: SignerInfo.schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		clearProps(schema, [
			&quot;SignedData.version&quot;,
			&quot;SignedData.digestAlgorithms&quot;,
			&quot;SignedData.encapContentInfo&quot;,
			&quot;SignedData.certificates&quot;,
			&quot;SignedData.crls&quot;,
			&quot;SignedData.signerInfos&quot;
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema,
			schema,
			SignedData.schema()
		);
		
		if(asn1.verified === false)
			throw new Error(&quot;Object&#039;s schema was not verified against input data for SignedData&quot;);
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result[&quot;SignedData.version&quot;].valueBlock.valueDec;
		
		if(&quot;SignedData.digestAlgorithms&quot; in asn1.result) // Could be empty SET of digest algorithms
			this.digestAlgorithms = Array.from(asn1.result[&quot;SignedData.digestAlgorithms&quot;], algorithm =&gt; new AlgorithmIdentifier({ schema: algorithm }));
		
		this.encapContentInfo = new EncapsulatedContentInfo({ schema: asn1.result[&quot;SignedData.encapContentInfo&quot;] });
		
		if(&quot;SignedData.certificates&quot; in asn1.result)
		{
			const certificateSet = new CertificateSet({
				schema: new asn1js.Set({
					value: asn1.result[&quot;SignedData.certificates&quot;].valueBlock.value
				})
			});
			this.certificates = certificateSet.certificates.slice(0); // Copy all just for making comfortable access
		}
		
		if(&quot;SignedData.crls&quot; in asn1.result)
		{
			this.crls = Array.from(asn1.result[&quot;SignedData.crls&quot;], crl =&gt;
			{
				if(crl.idBlock.tagClass === 1)
					return new CertificateRevocationList({ schema: crl });
				
				//region Create SEQUENCE from [1]
				crl.idBlock.tagClass = 1; // UNIVERSAL
				crl.idBlock.tagNumber = 16; // SEQUENCE
				//endregion
				
				return new OtherRevocationInfoFormat({ schema: crl });
			});
		}
		
		if(&quot;SignedData.signerInfos&quot; in asn1.result) // Could be empty SET SignerInfos
			this.signerInfos = Array.from(asn1.result[&quot;SignedData.signerInfos&quot;], signerInfoSchema =&gt; new SignerInfo({ schema: signerInfoSchema }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(new asn1js.Integer({ value: this.version }));
		
		//region Create array of digest algorithms
		outputArray.push(new asn1js.Set({
			value: Array.from(this.digestAlgorithms, algorithm =&gt; algorithm.toSchema(encodeFlag))
		}));
		//endregion
		
		outputArray.push(this.encapContentInfo.toSchema());
		
		if(&quot;certificates&quot; in this)
		{
			const certificateSet = new CertificateSet({ certificates: this.certificates });
			const certificateSetSchema = certificateSet.toSchema();
			
			outputArray.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 0
				},
				value: certificateSetSchema.valueBlock.value
			}));
		}
		
		if(&quot;crls&quot; in this)
		{
			outputArray.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.crls, crl =&gt;
				{
					if(crl instanceof OtherRevocationInfoFormat)
					{
						const crlSchema = crl.toSchema(encodeFlag);
						
						crlSchema.idBlock.tagClass = 3;
						crlSchema.idBlock.tagNumber = 1;
						
						return crlSchema;
					}
					
					return crl.toSchema(encodeFlag);
				})
			}));
		}
		
		//region Create array of signer infos
		outputArray.push(new asn1js.Set({
			value: Array.from(this.signerInfos, signerInfo =&gt; signerInfo.toSchema(encodeFlag))
		}));
		//endregion
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js.Sequence({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version,
			digestAlgorithms: Array.from(this.digestAlgorithms, algorithm =&gt; algorithm.toJSON()),
			encapContentInfo: this.encapContentInfo.toJSON()
		};
		
		if(&quot;certificates&quot; in this)
			_object.certificates = Array.from(this.certificates, certificate =&gt; certificate.toJSON());
		
		if(&quot;crls&quot; in this)
			_object.crls = Array.from(this.crls, crl =&gt; crl.toJSON());
		
		_object.signerInfos = Array.from(this.signerInfos, signerInfo =&gt; signerInfo.toJSON());
		
		return _object;
	}
	//**********************************************************************************
	/**
	 * Verify current SignedData value
	 * @param signer
	 * @param data
	 * @param trustedCerts
	 * @param checkDate
	 * @param checkChain
	 * @param includeSignerCertificate
	 * @param extendedMode
	 * @param findOrigin
	 * @param findIssuer
	 * @returns {*}
	 */
	verify({
		signer = (-1),
		data = (new ArrayBuffer(0)),
		trustedCerts = [],
		checkDate = (new Date()),
		checkChain = false,
		extendedMode = false,
		findOrigin = null,
		findIssuer = null
	} = {})
	{
		//region Global variables
		let sequence = Promise.resolve();
		
		let messageDigestValue = new ArrayBuffer(0);
		
		let shaAlgorithm = &quot;&quot;;
		
		let signerCertificate = {};
		
		let timestampSerial = null;
		
		let certificatePath = [];
		
		const engine = getEngine();
		//endregion
		
		//region Get a &quot;crypto&quot; extension
		const crypto = getCrypto();
		if(typeof crypto === &quot;undefined&quot;)
			return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion
		
		//region Get a signer number
		if(signer === (-1))
		{
			if(extendedMode)
			{
				return Promise.reject({
					date: checkDate,
					code: 1,
					message: &quot;Unable to get signer index from input parameters&quot;,
					signatureVerified: null,
					signerCertificate: null,
					signerCertificateVerified: null
				});
			}
			
			return Promise.reject(&quot;Unable to get signer index from input parameters&quot;);
		}
		//endregion
		
		//region Check that certificates field was included in signed data
		if((&quot;certificates&quot; in this) === false)
		{
			if(extendedMode)
			{
				return Promise.reject({
					date: checkDate,
					code: 2,
					message: &quot;No certificates attached to this signed data&quot;,
					signatureVerified: null,
					signerCertificate: null,
					signerCertificateVerified: null
				});
			}
			
			return Promise.reject(&quot;No certificates attached to this signed data&quot;);
		}
		//endregion
		
		//region Find a certificate for specified signer
		if(this.signerInfos[signer].sid instanceof IssuerAndSerialNumber)
		{
			sequence = sequence.then(() =&gt;
			{
				for(const certificate of this.certificates)
				{
					if((certificate instanceof Certificate) === false)
						continue;
					
					if((certificate.issuer.isEqual(this.signerInfos[signer].sid.issuer)) &amp;&amp;
						(certificate.serialNumber.isEqual(this.signerInfos[signer].sid.serialNumber)))
					{
						signerCertificate = certificate;
						return Promise.resolve();
					}
				}
				
				if(extendedMode)
				{
					return Promise.reject({
						date: checkDate,
						code: 3,
						message: &quot;Unable to find signer certificate&quot;,
						signatureVerified: null,
						signerCertificate: null,
						signerCertificateVerified: null
					});
				}
				
				return Promise.reject(&quot;Unable to find signer certificate&quot;);
			});
		}
		else // Find by SubjectKeyIdentifier
		{
			sequence = sequence.then(() =&gt;
				Promise.all(Array.from(this.certificates.filter(certificate =&gt; (certificate instanceof Certificate)), certificate =&gt;
					crypto.digest({ name: &quot;sha-1&quot; }, new Uint8Array(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))
				).then(results =&gt;
				{
					for(const [index, certificate] of this.certificates.entries())
					{
						if((certificate instanceof Certificate) === false)
							continue;
						
						if(isEqualBuffer(results[index], this.signerInfos[signer].sid.valueBlock.valueHex))
						{
							signerCertificate = certificate;
							return Promise.resolve();
						}
					}
					
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 3,
							message: &quot;Unable to find signer certificate&quot;,
							signatureVerified: null,
							signerCertificate: null,
							signerCertificateVerified: null
						});
					}
					
					return Promise.reject(&quot;Unable to find signer certificate&quot;);
				}, () =&gt;
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 3,
							message: &quot;Unable to find signer certificate&quot;,
							signatureVerified: null,
							signerCertificate: null,
							signerCertificateVerified: null
						});
					}
					
					return Promise.reject(&quot;Unable to find signer certificate&quot;);
				})
			);
		}
		//endregion
		
		//region Verify internal digest in case of &quot;tSTInfo&quot; content type
		sequence = sequence.then(() =&gt;
		{
			if(this.encapContentInfo.eContentType === &quot;1.2.840.113549.1.9.16.1.4&quot;)
			{
				//region Check &quot;eContent&quot; precense
				if((&quot;eContent&quot; in this.encapContentInfo) === false)
					return false;
				//endregion
				
				//region Initialize TST_INFO value
				const asn1 = asn1js.fromBER(this.encapContentInfo.eContent.valueBlock.valueHex);
				let tstInfo;
				
				try
				{
					tstInfo = new TSTInfo({ schema: asn1.result });
				}
				catch(ex)
				{
					return false;
				}
				//endregion
				
				//region Change &quot;checkDate&quot; and append &quot;timestampSerial&quot;
				checkDate = tstInfo.genTime;
				timestampSerial = tstInfo.serialNumber.valueBlock.valueHex;
				//endregion
				
				//region Check that we do have detached data content
				if(data.byteLength === 0)
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 4,
							message: &quot;Missed detached data input array&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: null
						});
					}
					
					return Promise.reject(&quot;Missed detached data input array&quot;);
				}
				//endregion
				
				return tstInfo.verify({ data });
			}
			
			return true;
		});
		//endregion
		
		//region Make additional verification for signer&#039;s certificate
		function checkCA(cert)
		{
			/// &lt;param name=&quot;cert&quot; type=&quot;in_window.org.pkijs.simpl.CERT&quot;&gt;Certificate to find CA flag for&lt;/param&gt;
			
			//region Do not include signer&#039;s certificate
			if((cert.issuer.isEqual(signerCertificate.issuer) === true) &amp;&amp; (cert.serialNumber.isEqual(signerCertificate.serialNumber) === true))
				return null;
			//endregion
			
			let isCA = false;
			
			if(&quot;extensions&quot; in cert)
			{
				for(const extension of cert.extensions)
				{
					if(extension.extnID === &quot;2.5.29.19&quot;) // BasicConstraints
					{
						if(&quot;cA&quot; in extension.parsedValue)
						{
							if(extension.parsedValue.cA === true)
								isCA = true;
						}
					}
				}
			}
			
			if(isCA)
				return cert;
			
			return null;
		}
		
		if(checkChain)
		{
			sequence = sequence.then(result =&gt;
			{
				//region Verify result of previous operation
				if(result === false)
					return false;
				//endregion
				
				const promiseResults = Array.from(this.certificates.filter(certificate =&gt; (certificate instanceof Certificate)), certificate =&gt; checkCA(certificate));
				
				const certificateChainValidationEngineParameters = {
					checkDate,
					certs: Array.from(promiseResults.filter(_result =&gt; (_result !== null))),
					trustedCerts
				};
				
				if(findIssuer !== null)
					certificateChainValidationEngineParameters.findIssuer = findIssuer;
				
				if(findOrigin !== null)
					certificateChainValidationEngineParameters.findOrigin = findOrigin;
				
				const certificateChainEngine = new CertificateChainValidationEngine(certificateChainValidationEngineParameters);
				
				certificateChainEngine.certs.push(signerCertificate);
				
				if(&quot;crls&quot; in this)
				{
					for(const crl of this.crls)
					{
						if(crl instanceof CertificateRevocationList)
							certificateChainEngine.crls.push(crl);
						else // Assumed &quot;revocation value&quot; has &quot;OtherRevocationInfoFormat&quot;
						{
							if(crl.otherRevInfoFormat === &quot;1.3.6.1.5.5.7.48.1.1&quot;) // Basic OCSP response
								certificateChainEngine.ocsps.push(new BasicOCSPResponse({ schema: crl.otherRevInfo }));
						}
					}
				}
				
				if(&quot;ocsps&quot; in this)
					certificateChainEngine.ocsps.push(...(this.ocsps));
				
				return certificateChainEngine.verify().then(verificationResult =&gt;
				{
					if(&quot;certificatePath&quot; in verificationResult)
						certificatePath = verificationResult.certificatePath;
					
					if(verificationResult.result === true)
						return Promise.resolve(true);
					
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 5,
							message: `Validation of signer&#039;s certificate failed: ${verificationResult.resultMessage}`,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: false
						});
					}
					
					return Promise.reject(&quot;Validation of signer&#039;s certificate failed&quot;);
				}, error =&gt;
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 5,
							message: `Validation of signer&#039;s certificate failed with error: ${((error instanceof Object) ? error.resultMessage : error)}`,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: false
						});
					}
					
					return Promise.reject(`Validation of signer&#039;s certificate failed with error: ${((error instanceof Object) ? error.resultMessage : error)}`);
				});
			});
		}
		//endregion
		
		//region Find signer&#039;s hashing algorithm
		sequence = sequence.then(result =&gt;
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			const signerInfoHashAlgorithm = getAlgorithmByOID(this.signerInfos[signer].digestAlgorithm.algorithmId);
			if((&quot;name&quot; in signerInfoHashAlgorithm) === false)
			{
				if(extendedMode)
				{
					return Promise.reject({
						date: checkDate,
						code: 7,
						message: `Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`,
						signatureVerified: null,
						signerCertificate,
						signerCertificateVerified: true
					});
				}
				
				return Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`);
			}
			
			shaAlgorithm = signerInfoHashAlgorithm.name;
			
			return true;
		});
		//endregion
		
		//region Create correct data block for verification
		sequence = sequence.then(result =&gt;
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			if(&quot;eContent&quot; in this.encapContentInfo) // Attached data
			{
				if((this.encapContentInfo.eContent.idBlock.tagClass === 1) &amp;&amp;
					(this.encapContentInfo.eContent.idBlock.tagNumber === 4))
				{
					if(this.encapContentInfo.eContent.idBlock.isConstructed === false)
						data = this.encapContentInfo.eContent.valueBlock.valueHex;
					else
					{
						for(const contentValue of this.encapContentInfo.eContent.valueBlock.value)
							data = utilConcatBuf(data, contentValue.valueBlock.valueHex);
					}
				}
				else
					data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
			}
			else // Detached data
			{
				if(data.byteLength === 0) // Check that &quot;data&quot; already provided by function parameter
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 8,
							message: &quot;Missed detached data input array&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}
					
					return Promise.reject(&quot;Missed detached data input array&quot;);
				}
			}
			
			if(&quot;signedAttrs&quot; in this.signerInfos[signer])
			{
				//region Check mandatory attributes
				let foundContentType = false;
				let foundMessageDigest = false;
				
				for(const attribute of this.signerInfos[signer].signedAttrs.attributes)
				{
					//region Check that &quot;content-type&quot; attribute exists
					if(attribute.type === &quot;1.2.840.113549.1.9.3&quot;)
						foundContentType = true;
					//endregion
					
					//region Check that &quot;message-digest&quot; attribute exists
					if(attribute.type === &quot;1.2.840.113549.1.9.4&quot;)
					{
						foundMessageDigest = true;
						messageDigestValue = attribute.values[0].valueBlock.valueHex;
					}
					//endregion
					
					//region Speed-up searching
					if(foundContentType &amp;&amp; foundMessageDigest)
						break;
					//endregion
				}
				
				if(foundContentType === false)
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 9,
							message: &quot;Attribute \&quot;content-type\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}
					
					return Promise.reject(&quot;Attribute \&quot;content-type\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;);
				}
				
				if(foundMessageDigest === false)
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 10,
							message: &quot;Attribute \&quot;message-digest\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}
					
					return Promise.reject(&quot;Attribute \&quot;message-digest\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;);
				}
				//endregion
			}
			
			return true;
		});
		//endregion
		
		//region Verify &quot;message-digest&quot; attribute in case of &quot;signedAttrs&quot;
		sequence = sequence.then(result =&gt;
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			if(&quot;signedAttrs&quot; in this.signerInfos[signer])
				return crypto.digest(shaAlgorithm, new Uint8Array(data));
			
			return true;
		}).then(
			/**
			 * @param {ArrayBuffer} result
			 */
			result =&gt;
			{
				//region Verify result of previous operation
				if(result === false)
					return false;
				//endregion
				
				if(&quot;signedAttrs&quot; in this.signerInfos[signer])
				{
					if(isEqualBuffer(result, messageDigestValue))
					{
						data = this.signerInfos[signer].signedAttrs.encodedValue;
						return true;
					}
					
					return false;
				}
				
				return true;
			});
		//endregion
		
		sequence = sequence.then(result =&gt;
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			return engine.subtle.verifyWithPublicKey(data, this.signerInfos[signer].signature, signerCertificate.subjectPublicKeyInfo, signerCertificate.signatureAlgorithm, shaAlgorithm);
		});
		
		//region Make a final result
		sequence = sequence.then(result =&gt;
		{
			if(extendedMode)
			{
				return {
					date: checkDate,
					code: 14,
					message: &quot;&quot;,
					signatureVerified: result,
					signerCertificate,
					timestampSerial,
					signerCertificateVerified: true,
					certificatePath
				};
			}
			
			return result;
		}, error =&gt;
		{
			if(extendedMode)
			{
				if(&quot;code&quot; in error)
					return Promise.reject(error);
				
				return Promise.reject({
					date: checkDate,
					code: 15,
					message: `Error during verification: ${error.message}`,
					signatureVerified: null,
					signerCertificate,
					timestampSerial,
					signerCertificateVerified: true
				});
			}
			
			return Promise.reject(error);
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Signing current SignedData
	 * @param {key} privateKey Private key for &quot;subjectPublicKeyInfo&quot; structure
	 * @param {number} signerIndex Index number (starting from 0) of signer index to make signature for
	 * @param {string} [hashAlgorithm=&quot;SHA-1&quot;] Hashing algorithm. Default SHA-1
	 * @param {ArrayBuffer} [data] Detached data
	 * @returns {*}
	 */
	sign(privateKey, signerIndex, hashAlgorithm = &quot;SHA-1&quot;, data = (new ArrayBuffer(0)))
	{
		//region Initial checking
		if(typeof privateKey === &quot;undefined&quot;)
			return Promise.reject(&quot;Need to provide a private key for signing&quot;);
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		const engine = getEngine();
		//endregion
		
		//region Simple check for supported algorithm
		const hashAlgorithmOID = getOIDByAlgorithm({ name: hashAlgorithm });
		if(hashAlgorithmOID === &quot;&quot;)
			return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
		//endregion
		
		//region Append information about hash algorithm
		if((this.digestAlgorithms.filter(algorithm =&gt; algorithm.algorithmId === hashAlgorithmOID)).length === 0)
		{
			this.digestAlgorithms.push(new AlgorithmIdentifier({
				algorithmId: hashAlgorithmOID,
				algorithmParams: new asn1js.Null()
			}));
		}
		
		this.signerInfos[signerIndex].digestAlgorithm = new AlgorithmIdentifier({
			algorithmId: hashAlgorithmOID,
			algorithmParams: new asn1js.Null()
		});
		//endregion
		
		//region Get a &quot;default parameters&quot; for current algorithm and set correct signature algorithm
		sequence = sequence.then(() =&gt; engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =&gt;
		{
			parameters = result.parameters;
			this.signerInfos[signerIndex].signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =&gt;
		{
			if(&quot;signedAttrs&quot; in this.signerInfos[signerIndex])
			{
				if(this.signerInfos[signerIndex].signedAttrs.encodedValue.byteLength !== 0)
					data = this.signerInfos[signerIndex].signedAttrs.encodedValue;
				else
				{
					data = this.signerInfos[signerIndex].signedAttrs.toSchema(true).toBER(false);
					
					//region Change type from &quot;[0]&quot; to &quot;SET&quot; acordingly to standard
					const view = new Uint8Array(data);
					view[0] = 0x31;
					//endregion
				}
			}
			else
			{
				if(&quot;eContent&quot; in this.encapContentInfo) // Attached data
				{
					if((this.encapContentInfo.eContent.idBlock.tagClass === 1) &amp;&amp;
						(this.encapContentInfo.eContent.idBlock.tagNumber === 4))
					{
						if(this.encapContentInfo.eContent.idBlock.isConstructed === false)
							data = this.encapContentInfo.eContent.valueBlock.valueHex;
						else
						{
							for(const content of this.encapContentInfo.eContent.valueBlock.value)
								data = utilConcatBuf(data, content.valueBlock.valueHex);
						}
					}
					else
						data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
				}
				else // Detached data
				{
					if(data.byteLength === 0) // Check that &quot;data&quot; already provided by function parameter
						return Promise.reject(&quot;Missed detached data input array&quot;);
				}
			}
			
			return Promise.resolve();
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() =&gt; engine.subtle.signWithPrivateKey(data, privateKey, parameters));
		
		sequence = sequence.then(result =&gt;
		{
			this.signerInfos[signerIndex].signature = new asn1js.OctetString({ valueHex: result });
			
			return result;
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
