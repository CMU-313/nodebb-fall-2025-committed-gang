<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/build/AttributeCertificateV2.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/build/AttributeCertificateV2.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1037</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">149.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
	value: true
});
exports.AttributeCertificateInfoV2 = exports.Holder = exports.V2Form = exports.ObjectDigestInfo = undefined;

var _asn1js = require(&quot;asn1js&quot;);

var asn1js = _interopRequireWildcard(_asn1js);

var _pvutils = require(&quot;pvutils&quot;);

var _GeneralNames = require(&quot;./GeneralNames.js&quot;);

var _GeneralNames2 = _interopRequireDefault(_GeneralNames);

var _AlgorithmIdentifier = require(&quot;./AlgorithmIdentifier.js&quot;);

var _AlgorithmIdentifier2 = _interopRequireDefault(_AlgorithmIdentifier);

var _Attribute = require(&quot;./Attribute.js&quot;);

var _Attribute2 = _interopRequireDefault(_Attribute);

var _Extensions = require(&quot;./Extensions.js&quot;);

var _Extensions2 = _interopRequireDefault(_Extensions);

var _AttributeCertificateV = require(&quot;./AttributeCertificateV1.js&quot;);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//**************************************************************************************
/**
 * Class from RFC5755
 */
class ObjectDigestInfo {
	//**********************************************************************************
	/**
  * Constructor for ObjectDigestInfo class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {Enumerated}
   * @description digestedObjectType
   */
		this.digestedObjectType = (0, _pvutils.getParametersValue)(parameters, &quot;digestedObjectType&quot;, ObjectDigestInfo.defaultValues(&quot;digestedObjectType&quot;));

		if (&quot;otherObjectTypeID&quot; in parameters)
			/**
    * @type {ObjectIdentifier}
    * @description otherObjectTypeID
    */
			this.otherObjectTypeID = (0, _pvutils.getParametersValue)(parameters, &quot;otherObjectTypeID&quot;, ObjectDigestInfo.defaultValues(&quot;otherObjectTypeID&quot;));

		/**
   * @type {AlgorithmIdentifier}
   * @description digestAlgorithm
   */
		this.digestAlgorithm = (0, _pvutils.getParametersValue)(parameters, &quot;digestAlgorithm&quot;, ObjectDigestInfo.defaultValues(&quot;digestAlgorithm&quot;));
		/**
   * @type {BitString}
   * @description objectDigest
   */
		this.objectDigest = (0, _pvutils.getParametersValue)(parameters, &quot;objectDigest&quot;, ObjectDigestInfo.defaultValues(&quot;objectDigest&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;digestedObjectType&quot;:
				return new asn1js.Enumerated();
			case &quot;otherObjectTypeID&quot;:
				return new asn1js.ObjectIdentifier();
			case &quot;digestAlgorithm&quot;:
				return new _AlgorithmIdentifier2.default();
			case &quot;objectDigest&quot;:
				return new asn1js.BitString();
			default:
				throw new Error(`Invalid member name for ObjectDigestInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		// ObjectDigestInfo ::= SEQUENCE {
		//   digestedObjectType  ENUMERATED {
		//     publicKey            (0),
		//     publicKeyCert        (1),
		//     otherObjectTypes     (2) },
		//   -- otherObjectTypes MUST NOT
		//   -- be used in this profile
		//   otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
		//   digestAlgorithm     AlgorithmIdentifier,
		//   objectDigest        BIT STRING
		// }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [digestedObjectType]
   * @property {string} [otherObjectTypeID]
   * @property {string} [digestAlgorithm]
   * @property {string} [objectDigest]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		return new asn1js.Sequence({
			name: names.blockName || &quot;&quot;,
			value: [new asn1js.Enumerated({ name: names.digestedObjectType || &quot;&quot; }), new asn1js.ObjectIdentifier({
				optional: true,
				name: names.otherObjectTypeID || &quot;&quot;
			}), _AlgorithmIdentifier2.default.schema(names.digestAlgorithm || {}), new asn1js.BitString({ name: names.objectDigest || &quot;&quot; })]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;digestedObjectType&quot;, &quot;otherObjectTypeID&quot;, &quot;digestAlgorithm&quot;, &quot;objectDigest&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, ObjectDigestInfo.schema({
			names: {
				digestedObjectType: &quot;digestedObjectType&quot;,
				otherObjectTypeID: &quot;otherObjectTypeID&quot;,
				digestAlgorithm: {
					names: {
						blockName: &quot;digestAlgorithm&quot;
					}
				},
				objectDigest: &quot;objectDigest&quot;
			}
		}));

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for ObjectDigestInfo&quot;);
		//endregion

		//region Get internal properties from parsed schema
		this.digestedObjectType = asn1.result.digestedObjectType;

		if (&quot;otherObjectTypeID&quot; in asn1.result) this.otherObjectTypeID = asn1.result.otherObjectTypeID;

		this.digestAlgorithm = new _AlgorithmIdentifier2.default({ schema: asn1.result.digestAlgorithm });
		this.objectDigest = asn1.result.objectDigest;
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		const result = new asn1js.Sequence({
			value: [this.digestedObjectType]
		});

		if (&quot;otherObjectTypeID&quot; in this) result.value.push(this.otherObjectTypeID);

		result.value.push(this.digestAlgorithm.toSchema());
		result.value.push(this.objectDigest);

		return result;
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		const result = {
			digestedObjectType: this.digestedObjectType.toJSON()
		};

		if (&quot;otherObjectTypeID&quot; in this) result.otherObjectTypeID = this.otherObjectTypeID.toJSON();

		result.digestAlgorithm = this.digestAlgorithm.toJSON();
		result.objectDigest = this.objectDigest.toJSON();

		return result;
	}
	//**********************************************************************************
}
exports.ObjectDigestInfo = ObjectDigestInfo; //**************************************************************************************
/**
 * Class from RFC5755
 */

class V2Form {
	//**********************************************************************************
	/**
  * Constructor for V2Form class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		if (&quot;issuerName&quot; in parameters)
			/**
    * @type {GeneralNames}
    * @description issuerName
    */
			this.issuerName = (0, _pvutils.getParametersValue)(parameters, &quot;issuerName&quot;, V2Form.defaultValues(&quot;issuerName&quot;));

		if (&quot;baseCertificateID&quot; in parameters)
			/**
    * @type {IssuerSerial}
    * @description baseCertificateID
    */
			this.baseCertificateID = (0, _pvutils.getParametersValue)(parameters, &quot;baseCertificateID&quot;, V2Form.defaultValues(&quot;baseCertificateID&quot;));

		if (&quot;objectDigestInfo&quot; in parameters)
			/**
    * @type {ObjectDigestInfo}
    * @description objectDigestInfo
    */
			this.objectDigestInfo = (0, _pvutils.getParametersValue)(parameters, &quot;objectDigestInfo&quot;, V2Form.defaultValues(&quot;objectDigestInfo&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;issuerName&quot;:
				return new _GeneralNames2.default();
			case &quot;baseCertificateID&quot;:
				return new _AttributeCertificateV.IssuerSerial();
			case &quot;objectDigestInfo&quot;:
				return new ObjectDigestInfo();
			default:
				throw new Error(`Invalid member name for V2Form class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		// V2Form ::= SEQUENCE {
		//   issuerName            GeneralNames  OPTIONAL,
		//   baseCertificateID     [0] IssuerSerial  OPTIONAL,
		//   objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
		//     -- issuerName MUST be present in this profile
		//     -- baseCertificateID and objectDigestInfo MUST NOT
		//     -- be present in this profile
		// }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [issuerName]
   * @property {string} [baseCertificateID]
   * @property {string} [objectDigestInfo]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		return new asn1js.Sequence({
			name: names.blockName || &quot;&quot;,
			value: [_GeneralNames2.default.schema({
				names: {
					blockName: names.issuerName
				}
			}, true), new asn1js.Constructed({
				optional: true,
				name: names.baseCertificateID || &quot;&quot;,
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: _AttributeCertificateV.IssuerSerial.schema().valueBlock.value
			}), new asn1js.Constructed({
				optional: true,
				name: names.objectDigestInfo || &quot;&quot;,
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [1]
				},
				value: ObjectDigestInfo.schema().valueBlock.value
			})]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;issuerName&quot;, &quot;baseCertificateID&quot;, &quot;objectDigestInfo&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, V2Form.schema({
			names: {
				issuerName: &quot;issuerName&quot;,
				baseCertificateID: &quot;baseCertificateID&quot;,
				objectDigestInfo: &quot;objectDigestInfo&quot;
			}
		}));

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for V2Form&quot;);
		//endregion

		//region Get internal properties from parsed schema
		if (&quot;issuerName&quot; in asn1.result) this.issuerName = new _GeneralNames2.default({ schema: asn1.result.issuerName });

		if (&quot;baseCertificateID&quot; in asn1.result) {
			this.baseCertificateID = new _AttributeCertificateV.IssuerSerial({
				schema: new asn1js.Sequence({
					value: asn1.result.baseCertificateID.valueBlock.value
				})
			});
		}

		if (&quot;objectDigestInfo&quot; in asn1.result) {
			this.objectDigestInfo = new ObjectDigestInfo({
				schema: new asn1js.Sequence({
					value: asn1.result.objectDigestInfo.valueBlock.value
				})
			});
		}
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		const result = new asn1js.Sequence();

		if (&quot;issuerName&quot; in this) result.valueBlock.value.push(this.issuerName.toSchema());

		if (&quot;baseCertificateID&quot; in this) {
			result.valueBlock.value.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: this.baseCertificateID.toSchema().valueBlock.value
			}));
		}

		if (&quot;objectDigestInfo&quot; in this) {
			result.valueBlock.value.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [1]
				},
				value: this.objectDigestInfo.toSchema().valueBlock.value
			}));
		}

		//region Construct and return new ASN.1 schema for this object
		return result;
		//endregion
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		const result = {};

		if (&quot;issuerName&quot; in this) result.issuerName = this.issuerName.toJSON();

		if (&quot;baseCertificateID&quot; in this) result.baseCertificateID = this.baseCertificateID.toJSON();

		if (&quot;objectDigestInfo&quot; in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();

		return result;
	}
	//**********************************************************************************
}
exports.V2Form = V2Form; //**************************************************************************************
/**
 * Class from RFC5755
 */

class Holder {
	//**********************************************************************************
	/**
  * Constructor for Holder class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		if (&quot;baseCertificateID&quot; in parameters)
			/**
    * @type {IssuerSerial}
    * @description baseCertificateID
    */
			this.baseCertificateID = (0, _pvutils.getParametersValue)(parameters, &quot;baseCertificateID&quot;, Holder.defaultValues(&quot;baseCertificateID&quot;));

		if (&quot;entityName&quot; in parameters)
			/**
    * @type {GeneralNames}
    * @description entityName
    */
			this.entityName = (0, _pvutils.getParametersValue)(parameters, &quot;entityName&quot;, Holder.defaultValues(&quot;entityName&quot;));

		if (&quot;objectDigestInfo&quot; in parameters)
			/**
    * @type {ObjectDigestInfo}
    * @description objectDigestInfo
    */
			this.objectDigestInfo = (0, _pvutils.getParametersValue)(parameters, &quot;objectDigestInfo&quot;, Holder.defaultValues(&quot;objectDigestInfo&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;baseCertificateID&quot;:
				return new _AttributeCertificateV.IssuerSerial();
			case &quot;entityName&quot;:
				return new _GeneralNames2.default();
			case &quot;objectDigestInfo&quot;:
				return new ObjectDigestInfo();
			default:
				throw new Error(`Invalid member name for Holder class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		// Holder ::= SEQUENCE {
		//   baseCertificateID   [0] IssuerSerial OPTIONAL,
		//       -- the issuer and serial number of
		//       -- the holder&#039;s Public Key Certificate
		//   entityName          [1] GeneralNames OPTIONAL,
		//       -- the name of the claimant or role
		//   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
		//       -- used to directly authenticate the holder,
		//       -- for example, an executable
		// }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [baseCertificateID]
   * @property {string} [entityName]
   * @property {string} [objectDigestInfo]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		return new asn1js.Sequence({
			name: names.blockName || &quot;&quot;,
			value: [new asn1js.Constructed({
				optional: true,
				name: names.baseCertificateID || &quot;&quot;,
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: _AttributeCertificateV.IssuerSerial.schema().valueBlock.value
			}), new asn1js.Constructed({
				optional: true,
				name: names.entityName || &quot;&quot;,
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [2]
				},
				value: _GeneralNames2.default.schema().valueBlock.value
			}), new asn1js.Constructed({
				optional: true,
				name: names.objectDigestInfo || &quot;&quot;,
				idBlock: {
					tagClass: 3,
					tagNumber: 2 // [2]
				},
				value: ObjectDigestInfo.schema().valueBlock.value
			})]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;baseCertificateID&quot;, &quot;entityName&quot;, &quot;objectDigestInfo&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, Holder.schema({
			names: {
				baseCertificateID: &quot;baseCertificateID&quot;,
				entityName: &quot;entityName&quot;,
				objectDigestInfo: &quot;objectDigestInfo&quot;
			}
		}));

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for Holder&quot;);
		//endregion

		//region Get internal properties from parsed schema
		if (&quot;baseCertificateID&quot; in asn1.result) {
			this.baseCertificateID = new _AttributeCertificateV.IssuerSerial({
				schema: new asn1js.Sequence({
					value: asn1.result.baseCertificateID.valueBlock.value
				})
			});
		}

		if (&quot;entityName&quot; in asn1.result) {
			this.entityName = new _GeneralNames2.default({
				schema: new asn1js.Sequence({
					value: asn1.result.entityName.valueBlock.value
				})
			});
		}

		if (&quot;objectDigestInfo&quot; in asn1.result) {
			this.objectDigestInfo = new ObjectDigestInfo({
				schema: new asn1js.Sequence({
					value: asn1.result.objectDigestInfo.valueBlock.value
				})
			});
		}
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		const result = new asn1js.Sequence();

		if (&quot;baseCertificateID&quot; in this) {
			result.valueBlock.value.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: this.baseCertificateID.toSchema().valueBlock.value
			}));
		}

		if (&quot;entityName&quot; in this) {
			result.valueBlock.value.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [1]
				},
				value: this.entityName.toSchema().valueBlock.value
			}));
		}

		if (&quot;objectDigestInfo&quot; in this) {
			result.valueBlock.value.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 2 // [2]
				},
				value: this.objectDigestInfo.toSchema().valueBlock.value
			}));
		}

		return result;
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		const result = {};

		if (&quot;baseCertificateID&quot; in this) result.baseCertificateID = this.baseCertificateID.toJSON();

		if (&quot;entityName&quot; in this) result.entityName = this.entityName.toJSON();

		if (&quot;objectDigestInfo&quot; in this) result.objectDigestInfo = this.objectDigestInfo.toJSON();

		return result;
	}
	//**********************************************************************************
}
exports.Holder = Holder; //**************************************************************************************
/**
 * Class from RFC5755
 */

class AttributeCertificateInfoV2 {
	//**********************************************************************************
	/**
  * Constructor for AttributeCertificateInfoV2 class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {Number}
   * @description version
   */
		this.version = (0, _pvutils.getParametersValue)(parameters, &quot;version&quot;, AttributeCertificateInfoV2.defaultValues(&quot;version&quot;));
		/**
   * @type {Holder}
   * @description holder
   */
		this.holder = (0, _pvutils.getParametersValue)(parameters, &quot;holder&quot;, AttributeCertificateInfoV2.defaultValues(&quot;holder&quot;));
		/**
   * @type {GeneralNames|V2Form}
   * @description issuer
   */
		this.issuer = (0, _pvutils.getParametersValue)(parameters, &quot;issuer&quot;, AttributeCertificateInfoV2.defaultValues(&quot;issuer&quot;));
		/**
   * @type {AlgorithmIdentifier}
   * @description signature
   */
		this.signature = (0, _pvutils.getParametersValue)(parameters, &quot;signature&quot;, AttributeCertificateInfoV2.defaultValues(&quot;signature&quot;));
		/**
   * @type {Integer}
   * @description serialNumber
   */
		this.serialNumber = (0, _pvutils.getParametersValue)(parameters, &quot;serialNumber&quot;, AttributeCertificateInfoV2.defaultValues(&quot;serialNumber&quot;));
		/**
   * @type {AttCertValidityPeriod}
   * @description attrCertValidityPeriod
   */
		this.attrCertValidityPeriod = (0, _pvutils.getParametersValue)(parameters, &quot;attrCertValidityPeriod&quot;, AttributeCertificateInfoV2.defaultValues(&quot;attrCertValidityPeriod&quot;));
		/**
   * @type {Array.&lt;Attribute&gt;}
   * @description attributes
   */
		this.attributes = (0, _pvutils.getParametersValue)(parameters, &quot;attributes&quot;, AttributeCertificateInfoV2.defaultValues(&quot;attributes&quot;));

		if (&quot;issuerUniqueID&quot; in parameters)
			/**
    * @type {BitString}
    * @description issuerUniqueID
    */
			this.issuerUniqueID = (0, _pvutils.getParametersValue)(parameters, &quot;issuerUniqueID&quot;, AttributeCertificateInfoV2.defaultValues(&quot;issuerUniqueID&quot;));

		if (&quot;extensions&quot; in parameters)
			/**
    * @type {Extensions}
    * @description extensions
    */
			this.extensions = (0, _pvutils.getParametersValue)(parameters, &quot;extensions&quot;, AttributeCertificateInfoV2.defaultValues(&quot;extensions&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;version&quot;:
				return 1;
			case &quot;holder&quot;:
				return new Holder();
			case &quot;issuer&quot;:
				return {};
			case &quot;signature&quot;:
				return new _AlgorithmIdentifier2.default();
			case &quot;serialNumber&quot;:
				return new asn1js.Integer();
			case &quot;attrCertValidityPeriod&quot;:
				return new _AttributeCertificateV.AttCertValidityPeriod();
			case &quot;attributes&quot;:
				return [];
			case &quot;issuerUniqueID&quot;:
				return new asn1js.BitString();
			case &quot;extensions&quot;:
				return new _Extensions2.default();
			default:
				throw new Error(`Invalid member name for AttributeCertificateInfoV2 class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		// AttributeCertificateInfoV2 ::= SEQUENCE {
		//   version                 AttCertVersion, -- version is v2
		//   holder                  Holder,
		//   issuer                  AttCertIssuer,
		//   signature               AlgorithmIdentifier,
		//   serialNumber            CertificateSerialNumber,
		//   attrCertValidityPeriod  AttCertValidityPeriod,
		//   attributes              SEQUENCE OF Attribute,
		//   issuerUniqueID          UniqueIdentifier OPTIONAL,
		//   extensions              Extensions OPTIONAL
		// }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [issuer]
   * @property {string} [serialNumber]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		return new asn1js.Sequence({
			name: names.blockName || &quot;&quot;,
			value: [new asn1js.Integer({ name: names.version || &quot;&quot; }), Holder.schema(names.holder || {}), new asn1js.Choice({
				value: [_GeneralNames2.default.schema({
					names: {
						blockName: names.issuer || &quot;&quot;
					}
				}), new asn1js.Constructed({
					name: names.issuer || &quot;&quot;,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: V2Form.schema().valueBlock.value
				})]
			}), _AlgorithmIdentifier2.default.schema(names.signature || {}), new asn1js.Integer({ name: names.serialNumber || &quot;&quot; }), _AttributeCertificateV.AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}), new asn1js.Sequence({
				name: names.attributes || &quot;&quot;,
				value: [new asn1js.Repeated({
					value: _Attribute2.default.schema()
				})]
			}), new asn1js.BitString({
				optional: true,
				name: names.issuerUniqueID || &quot;&quot;
			}), _Extensions2.default.schema(names.extensions || {}, true)]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;version&quot;, &quot;holder&quot;, &quot;issuer&quot;, &quot;signature&quot;, &quot;serialNumber&quot;, &quot;attrCertValidityPeriod&quot;, &quot;attributes&quot;, &quot;issuerUniqueID&quot;, &quot;extensions&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, AttributeCertificateInfoV2.schema({
			names: {
				version: &quot;version&quot;,
				holder: {
					names: {
						blockName: &quot;holder&quot;
					}
				},
				issuer: &quot;issuer&quot;,
				signature: {
					names: {
						blockName: &quot;signature&quot;
					}
				},
				serialNumber: &quot;serialNumber&quot;,
				attrCertValidityPeriod: {
					names: {
						blockName: &quot;attrCertValidityPeriod&quot;
					}
				},
				attributes: &quot;attributes&quot;,
				issuerUniqueID: &quot;issuerUniqueID&quot;,
				extensions: {
					names: {
						blockName: &quot;extensions&quot;
					}
				}
			}
		}));

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for AttributeCertificateInfoV2&quot;);
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.holder = new Holder({ schema: asn1.result.holder });

		switch (asn1.result.issuer.idBlock.tagClass) {
			case 3:
				// V2Form
				this.issuer = new V2Form({
					schema: new asn1js.Sequence({
						value: asn1.result.issuer.valueBlock.value
					})
				});
				break;
			case 1: // GeneralNames (should not be used)
			default:
				throw new Error(&quot;Incorect value for &#039;issuer&#039; in AttributeCertificateInfoV2&quot;);
		}

		this.signature = new _AlgorithmIdentifier2.default({ schema: asn1.result.signature });
		this.serialNumber = asn1.result.serialNumber;
		this.attrCertValidityPeriod = new _AttributeCertificateV.AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
		this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element =&gt; new _Attribute2.default({ schema: element }));

		if (&quot;issuerUniqueID&quot; in asn1.result) this.issuerUniqueID = asn1.result.issuerUniqueID;

		if (&quot;extensions&quot; in asn1.result) this.extensions = new _Extensions2.default({ schema: asn1.result.extensions });
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		const result = new asn1js.Sequence({
			value: [new asn1js.Integer({ value: this.version }), this.holder.toSchema(), new asn1js.Constructed({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: this.issuer.toSchema().valueBlock.value
			}), this.signature.toSchema(), this.serialNumber, this.attrCertValidityPeriod.toSchema(), new asn1js.Sequence({
				value: Array.from(this.attributes, element =&gt; element.toSchema())
			})]
		});

		if (&quot;issuerUniqueID&quot; in this) result.valueBlock.value.push(this.issuerUniqueID);

		if (&quot;extensions&quot; in this) result.valueBlock.value.push(this.extensions.toSchema());

		return result;
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		const result = {
			version: this.version,
			holder: this.holder.toJSON(),
			issuer: this.issuer.toJSON(),
			signature: this.signature.toJSON(),
			serialNumber: this.serialNumber.toJSON(),
			attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
			attributes: Array.from(this.attributes, element =&gt; element.toJSON())
		};

		if (&quot;issuerUniqueID&quot; in this) result.issuerUniqueID = this.issuerUniqueID.toJSON();

		if (&quot;extensions&quot; in this) result.extensions = this.extensions.toJSON();

		return result;
	}
	//**********************************************************************************
}
exports.AttributeCertificateInfoV2 = AttributeCertificateInfoV2; //**************************************************************************************
/**
 * Class from RFC5755
 */

class AttributeCertificateV2 {
	//**********************************************************************************
	/**
  * Constructor for AttributeCertificateV2 class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {AttributeCertificateInfoV2}
   * @description acinfo
   */
		this.acinfo = (0, _pvutils.getParametersValue)(parameters, &quot;acinfo&quot;, AttributeCertificateV2.defaultValues(&quot;acinfo&quot;));
		/**
   * @type {AlgorithmIdentifier}
   * @description signatureAlgorithm
   */
		this.signatureAlgorithm = (0, _pvutils.getParametersValue)(parameters, &quot;signatureAlgorithm&quot;, AttributeCertificateV2.defaultValues(&quot;signatureAlgorithm&quot;));
		/**
   * @type {BitString}
   * @description signatureValue
   */
		this.signatureValue = (0, _pvutils.getParametersValue)(parameters, &quot;signatureValue&quot;, AttributeCertificateV2.defaultValues(&quot;signatureValue&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;acinfo&quot;:
				return new AttributeCertificateInfoV2();
			case &quot;signatureAlgorithm&quot;:
				return new _AlgorithmIdentifier2.default();
			case &quot;signatureValue&quot;:
				return new asn1js.BitString();
			default:
				throw new Error(`Invalid member name for AttributeCertificateV2 class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		// AttributeCertificate ::= SEQUENCE {
		//   acinfo               AttributeCertificateInfoV2,
		//   signatureAlgorithm   AlgorithmIdentifier,
		//   signatureValue       BIT STRING
		// }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {Object} [acinfo]
   * @property {Object} [signatureAlgorithm]
   * @property {string} [signatureValue]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		return new asn1js.Sequence({
			name: names.blockName || &quot;&quot;,
			value: [AttributeCertificateInfoV2.schema(names.acinfo || {}), _AlgorithmIdentifier2.default.schema(names.signatureAlgorithm || {}), new asn1js.BitString({ name: names.signatureValue || &quot;&quot; })]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;acinfo&quot;, &quot;signatureAlgorithm&quot;, &quot;signatureValue&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, AttributeCertificateV2.schema({
			names: {
				acinfo: {
					names: {
						blockName: &quot;acinfo&quot;
					}
				},
				signatureAlgorithm: {
					names: {
						blockName: &quot;signatureAlgorithm&quot;
					}
				},
				signatureValue: &quot;signatureValue&quot;
			}
		}));

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for AttributeCertificateV2&quot;);
		//endregion

		//region Get internal properties from parsed schema
		this.acinfo = new AttributeCertificateInfoV2({ schema: asn1.result.acinfo });
		this.signatureAlgorithm = new _AlgorithmIdentifier2.default({ schema: asn1.result.signatureAlgorithm });
		this.signatureValue = asn1.result.signatureValue;
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		return new asn1js.Sequence({
			value: [this.acinfo.toSchema(), this.signatureAlgorithm.toSchema(), this.signatureValue]
		});
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		return {
			acinfo: this.acinfo.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signatureValue: this.signatureValue.toJSON()
		};
	}
	//**********************************************************************************
}
exports.default = AttributeCertificateV2; //**************************************************************************************
//# sourceMappingURL=AttributeCertificateV2.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
