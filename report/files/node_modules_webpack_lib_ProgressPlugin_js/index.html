<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/ProgressPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/ProgressPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">706</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">70.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.92</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const Compiler = require(&quot;./Compiler&quot;);
const MultiCompiler = require(&quot;./MultiCompiler&quot;);
const NormalModule = require(&quot;./NormalModule&quot;);
const createSchemaValidation = require(&quot;./util/create-schema-validation&quot;);
const { contextify } = require(&quot;./util/identifier&quot;);

/** @typedef {import(&quot;tapable&quot;).Tap} Tap */
/** @typedef {import(&quot;../declarations/plugins/ProgressPlugin&quot;).HandlerFunction} HandlerFunction */
/** @typedef {import(&quot;../declarations/plugins/ProgressPlugin&quot;).ProgressPluginArgument} ProgressPluginArgument */
/** @typedef {import(&quot;../declarations/plugins/ProgressPlugin&quot;).ProgressPluginOptions} ProgressPluginOptions */
/** @typedef {import(&quot;./Compilation&quot;).FactorizeModuleOptions} FactorizeModuleOptions */
/** @typedef {import(&quot;./Dependency&quot;)} Dependency */
/** @typedef {import(&quot;./Entrypoint&quot;).EntryOptions} EntryOptions */
/** @typedef {import(&quot;./Module&quot;)} Module */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import(&quot;./logging/Logger&quot;).Logger} Logger */

/**
 * @template T, K, R
 * @typedef {import(&quot;./util/AsyncQueue&quot;)&lt;T, K, R&gt;} AsyncQueue
 */

/**
 * @typedef {object} CountsData
 * @property {number} modulesCount modules count
 * @property {number} dependenciesCount dependencies count
 */

const validate = createSchemaValidation(
	require(&quot;../schemas/plugins/ProgressPlugin.check.js&quot;),
	() =&gt; require(&quot;../schemas/plugins/ProgressPlugin.json&quot;),
	{
		name: &quot;Progress Plugin&quot;,
		baseDataPath: &quot;options&quot;
	}
);

/**
 * @param {number} a a
 * @param {number} b b
 * @param {number} c c
 * @returns {number} median
 */
const median3 = (a, b, c) =&gt; a + b + c - Math.max(a, b, c) - Math.min(a, b, c);

/**
 * @param {boolean | null | undefined} profile need profile
 * @param {Logger} logger logger
 * @returns {defaultHandler} default handler
 */
const createDefaultHandler = (profile, logger) =&gt; {
	/** @type {{ value: string | undefined, time: number }[]} */
	const lastStateInfo = [];

	/**
	 * @param {number} percentage percentage
	 * @param {string} msg message
	 * @param {...string} args additional arguments
	 */
	const defaultHandler = (percentage, msg, ...args) =&gt; {
		if (profile) {
			if (percentage === 0) {
				lastStateInfo.length = 0;
			}
			const fullState = [msg, ...args];
			const state = fullState.map(s =&gt; s.replace(/\d+\/\d+ /g, &quot;&quot;));
			const now = Date.now();
			const len = Math.max(state.length, lastStateInfo.length);
			for (let i = len; i &gt;= 0; i--) {
				const stateItem = i &lt; state.length ? state[i] : undefined;
				const lastStateItem =
					i &lt; lastStateInfo.length ? lastStateInfo[i] : undefined;
				if (lastStateItem) {
					if (stateItem !== lastStateItem.value) {
						const diff = now - lastStateItem.time;
						if (lastStateItem.value) {
							let reportState = lastStateItem.value;
							if (i &gt; 0) {
								reportState = `${lastStateInfo[i - 1].value} &gt; ${reportState}`;
							}
							const stateMsg = `${&quot; | &quot;.repeat(i)}${diff} ms ${reportState}`;
							const d = diff;
							// This depends on timing so we ignore it for coverage
							/* eslint-disable no-lone-blocks */
							/* istanbul ignore next */
							{
								if (d &gt; 10000) {
									logger.error(stateMsg);
								} else if (d &gt; 1000) {
									logger.warn(stateMsg);
								} else if (d &gt; 10) {
									logger.info(stateMsg);
								} else if (d &gt; 5) {
									logger.log(stateMsg);
								} else {
									logger.debug(stateMsg);
								}
							}
							/* eslint-enable no-lone-blocks */
						}
						if (stateItem === undefined) {
							lastStateInfo.length = i;
						} else {
							lastStateItem.value = stateItem;
							lastStateItem.time = now;
							lastStateInfo.length = i + 1;
						}
					}
				} else {
					lastStateInfo[i] = {
						value: stateItem,
						time: now
					};
				}
			}
		}
		logger.status(`${Math.floor(percentage * 100)}%`, msg, ...args);
		if (percentage === 1 || (!msg &amp;&amp; args.length === 0)) logger.status();
	};

	return defaultHandler;
};

const SKIPPED_QUEUE_CONTEXTS = [&quot;import-module&quot;, &quot;load-module&quot;];

/**
 * @callback ReportProgress
 * @param {number} p percentage
 * @param {...string} args additional arguments
 * @returns {void}
 */

/** @type {WeakMap&lt;Compiler, ReportProgress | undefined&gt;} */
const progressReporters = new WeakMap();

const PLUGIN_NAME = &quot;ProgressPlugin&quot;;

class ProgressPlugin {
	/**
	 * @param {Compiler} compiler the current compiler
	 * @returns {ReportProgress | undefined} a progress reporter, if any
	 */
	static getReporter(compiler) {
		return progressReporters.get(compiler);
	}

	/**
	 * @param {ProgressPluginArgument} options options
	 */
	constructor(options = {}) {
		if (typeof options === &quot;function&quot;) {
			options = {
				handler: options
			};
		}

		validate(options);
		options = { ...ProgressPlugin.defaultOptions, ...options };

		this.profile = options.profile;
		this.handler = options.handler;
		this.modulesCount = options.modulesCount;
		this.dependenciesCount = options.dependenciesCount;
		this.showEntries = options.entries;
		this.showModules = options.modules;
		this.showDependencies = options.dependencies;
		this.showActiveModules = options.activeModules;
		this.percentBy = options.percentBy;
	}

	/**
	 * @param {Compiler | MultiCompiler} compiler webpack compiler
	 * @returns {void}
	 */
	apply(compiler) {
		const handler =
			this.handler ||
			createDefaultHandler(
				this.profile,
				compiler.getInfrastructureLogger(&quot;webpack.Progress&quot;)
			);
		if (compiler instanceof MultiCompiler) {
			this._applyOnMultiCompiler(compiler, handler);
		} else if (compiler instanceof Compiler) {
			this._applyOnCompiler(compiler, handler);
		}
	}

	/**
	 * @param {MultiCompiler} compiler webpack multi-compiler
	 * @param {HandlerFunction} handler function that executes for every progress step
	 * @returns {void}
	 */
	_applyOnMultiCompiler(compiler, handler) {
		const states = compiler.compilers.map(
			() =&gt; /** @type {[number, ...string[]]} */ ([0])
		);
		for (const [idx, item] of compiler.compilers.entries()) {
			new ProgressPlugin((p, msg, ...args) =&gt; {
				states[idx] = [p, msg, ...args];
				let sum = 0;
				for (const [p] of states) sum += p;
				handler(sum / states.length, `[${idx}] ${msg}`, ...args);
			}).apply(item);
		}
	}

	/**
	 * @param {Compiler} compiler webpack compiler
	 * @param {HandlerFunction} handler function that executes for every progress step
	 * @returns {void}
	 */
	_applyOnCompiler(compiler, handler) {
		const showEntries = this.showEntries;
		const showModules = this.showModules;
		const showDependencies = this.showDependencies;
		const showActiveModules = this.showActiveModules;
		let lastActiveModule = &quot;&quot;;
		let currentLoader = &quot;&quot;;
		let lastModulesCount = 0;
		let lastDependenciesCount = 0;
		let lastEntriesCount = 0;
		let modulesCount = 0;
		let skippedModulesCount = 0;
		let dependenciesCount = 0;
		let skippedDependenciesCount = 0;
		let entriesCount = 1;
		let doneModules = 0;
		let doneDependencies = 0;
		let doneEntries = 0;
		const activeModules = new Set();
		let lastUpdate = 0;

		const updateThrottled = () =&gt; {
			if (lastUpdate + 500 &lt; Date.now()) update();
		};

		const update = () =&gt; {
			/** @type {string[]} */
			const items = [];
			const percentByModules =
				doneModules /
				Math.max(lastModulesCount || this.modulesCount || 1, modulesCount);
			const percentByEntries =
				doneEntries /
				Math.max(lastEntriesCount || this.dependenciesCount || 1, entriesCount);
			const percentByDependencies =
				doneDependencies /
				Math.max(lastDependenciesCount || 1, dependenciesCount);
			let percentageFactor;

			switch (this.percentBy) {
				case &quot;entries&quot;:
					percentageFactor = percentByEntries;
					break;
				case &quot;dependencies&quot;:
					percentageFactor = percentByDependencies;
					break;
				case &quot;modules&quot;:
					percentageFactor = percentByModules;
					break;
				default:
					percentageFactor = median3(
						percentByModules,
						percentByEntries,
						percentByDependencies
					);
			}

			const percentage = 0.1 + percentageFactor * 0.55;

			if (currentLoader) {
				items.push(
					`import loader ${contextify(
						compiler.context,
						currentLoader,
						compiler.root
					)}`
				);
			} else {
				const statItems = [];
				if (showEntries) {
					statItems.push(`${doneEntries}/${entriesCount} entries`);
				}
				if (showDependencies) {
					statItems.push(
						`${doneDependencies}/${dependenciesCount} dependencies`
					);
				}
				if (showModules) {
					statItems.push(`${doneModules}/${modulesCount} modules`);
				}
				if (showActiveModules) {
					statItems.push(`${activeModules.size} active`);
				}
				if (statItems.length &gt; 0) {
					items.push(statItems.join(&quot; &quot;));
				}
				if (showActiveModules) {
					items.push(lastActiveModule);
				}
			}
			handler(percentage, &quot;building&quot;, ...items);
			lastUpdate = Date.now();
		};

		/**
		 * @template T
		 * @param {AsyncQueue&lt;FactorizeModuleOptions, string, Module | ModuleFactoryResult&gt;} factorizeQueue async queue
		 * @param {T} _item item
		 */
		const factorizeAdd = (factorizeQueue, _item) =&gt; {
			if (SKIPPED_QUEUE_CONTEXTS.includes(factorizeQueue.getContext())) {
				skippedDependenciesCount++;
			}
			dependenciesCount++;
			if (dependenciesCount &lt; 50 || dependenciesCount % 100 === 0)
				updateThrottled();
		};

		const factorizeDone = () =&gt; {
			doneDependencies++;
			if (doneDependencies &lt; 50 || doneDependencies % 100 === 0)
				updateThrottled();
		};

		/**
		 * @template T
		 * @param {AsyncQueue&lt;Module, string, Module&gt;} addModuleQueue async queue
		 * @param {T} _item item
		 */
		const moduleAdd = (addModuleQueue, _item) =&gt; {
			if (SKIPPED_QUEUE_CONTEXTS.includes(addModuleQueue.getContext())) {
				skippedModulesCount++;
			}
			modulesCount++;
			if (modulesCount &lt; 50 || modulesCount % 100 === 0) updateThrottled();
		};

		// only used when showActiveModules is set
		/**
		 * @param {Module} module the module
		 */
		const moduleBuild = module =&gt; {
			const ident = module.identifier();
			if (ident) {
				activeModules.add(ident);
				lastActiveModule = ident;
				update();
			}
		};

		/**
		 * @param {Dependency} entry entry dependency
		 * @param {EntryOptions} options options object
		 */
		const entryAdd = (entry, options) =&gt; {
			entriesCount++;
			if (entriesCount &lt; 5 || entriesCount % 10 === 0) updateThrottled();
		};

		/**
		 * @param {Module} module the module
		 */
		const moduleDone = module =&gt; {
			doneModules++;
			if (showActiveModules) {
				const ident = module.identifier();
				if (ident) {
					activeModules.delete(ident);
					if (lastActiveModule === ident) {
						lastActiveModule = &quot;&quot;;
						for (const m of activeModules) {
							lastActiveModule = m;
						}
						update();
						return;
					}
				}
			}
			if (doneModules &lt; 50 || doneModules % 100 === 0) updateThrottled();
		};

		/**
		 * @param {Dependency} entry entry dependency
		 * @param {EntryOptions} options options object
		 */
		const entryDone = (entry, options) =&gt; {
			doneEntries++;
			update();
		};

		const cache = compiler.getCache(PLUGIN_NAME).getItemCache(&quot;counts&quot;, null);

		/** @type {Promise&lt;CountsData&gt; | undefined} */
		let cacheGetPromise;

		compiler.hooks.beforeCompile.tap(PLUGIN_NAME, () =&gt; {
			if (!cacheGetPromise) {
				cacheGetPromise = cache.getPromise().then(
					data =&gt; {
						if (data) {
							lastModulesCount = lastModulesCount || data.modulesCount;
							lastDependenciesCount =
								lastDependenciesCount || data.dependenciesCount;
						}
						return data;
					},
					err =&gt; {
						// Ignore error
					}
				);
			}
		});

		compiler.hooks.afterCompile.tapPromise(PLUGIN_NAME, compilation =&gt; {
			if (compilation.compiler.isChild()) return Promise.resolve();
			return /** @type {Promise&lt;CountsData&gt;} */ (cacheGetPromise).then(
				async oldData =&gt; {
					const realModulesCount = modulesCount - skippedModulesCount;
					const realDependenciesCount =
						dependenciesCount - skippedDependenciesCount;

					if (
						!oldData ||
						oldData.modulesCount !== realModulesCount ||
						oldData.dependenciesCount !== realDependenciesCount
					) {
						await cache.storePromise({
							modulesCount: realModulesCount,
							dependenciesCount: realDependenciesCount
						});
					}
				}
			);
		});

		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation =&gt; {
			if (compilation.compiler.isChild()) return;
			lastModulesCount = modulesCount;
			lastEntriesCount = entriesCount;
			lastDependenciesCount = dependenciesCount;
			modulesCount =
				skippedModulesCount =
				dependenciesCount =
				skippedDependenciesCount =
				entriesCount =
					0;
			doneModules = doneDependencies = doneEntries = 0;

			compilation.factorizeQueue.hooks.added.tap(PLUGIN_NAME, item =&gt;
				factorizeAdd(compilation.factorizeQueue, item)
			);
			compilation.factorizeQueue.hooks.result.tap(PLUGIN_NAME, factorizeDone);

			compilation.addModuleQueue.hooks.added.tap(PLUGIN_NAME, item =&gt;
				moduleAdd(compilation.addModuleQueue, item)
			);
			compilation.processDependenciesQueue.hooks.result.tap(
				PLUGIN_NAME,
				moduleDone
			);

			if (showActiveModules) {
				compilation.hooks.buildModule.tap(PLUGIN_NAME, moduleBuild);
			}

			compilation.hooks.addEntry.tap(PLUGIN_NAME, entryAdd);
			compilation.hooks.failedEntry.tap(PLUGIN_NAME, entryDone);
			compilation.hooks.succeedEntry.tap(PLUGIN_NAME, entryDone);

			// @ts-expect-error avoid dynamic require if bundled with webpack
			if (typeof __webpack_require__ !== &quot;function&quot;) {
				const requiredLoaders = new Set();
				NormalModule.getCompilationHooks(compilation).beforeLoaders.tap(
					PLUGIN_NAME,
					loaders =&gt; {
						for (const loader of loaders) {
							if (
								loader.type !== &quot;module&quot; &amp;&amp;
								!requiredLoaders.has(loader.loader)
							) {
								requiredLoaders.add(loader.loader);
								currentLoader = loader.loader;
								update();
								require(loader.loader);
							}
						}
						if (currentLoader) {
							currentLoader = &quot;&quot;;
							update();
						}
					}
				);
			}

			const hooks = {
				finishModules: &quot;finish module graph&quot;,
				seal: &quot;plugins&quot;,
				optimizeDependencies: &quot;dependencies optimization&quot;,
				afterOptimizeDependencies: &quot;after dependencies optimization&quot;,
				beforeChunks: &quot;chunk graph&quot;,
				afterChunks: &quot;after chunk graph&quot;,
				optimize: &quot;optimizing&quot;,
				optimizeModules: &quot;module optimization&quot;,
				afterOptimizeModules: &quot;after module optimization&quot;,
				optimizeChunks: &quot;chunk optimization&quot;,
				afterOptimizeChunks: &quot;after chunk optimization&quot;,
				optimizeTree: &quot;module and chunk tree optimization&quot;,
				afterOptimizeTree: &quot;after module and chunk tree optimization&quot;,
				optimizeChunkModules: &quot;chunk modules optimization&quot;,
				afterOptimizeChunkModules: &quot;after chunk modules optimization&quot;,
				reviveModules: &quot;module reviving&quot;,
				beforeModuleIds: &quot;before module ids&quot;,
				moduleIds: &quot;module ids&quot;,
				optimizeModuleIds: &quot;module id optimization&quot;,
				afterOptimizeModuleIds: &quot;module id optimization&quot;,
				reviveChunks: &quot;chunk reviving&quot;,
				beforeChunkIds: &quot;before chunk ids&quot;,
				chunkIds: &quot;chunk ids&quot;,
				optimizeChunkIds: &quot;chunk id optimization&quot;,
				afterOptimizeChunkIds: &quot;after chunk id optimization&quot;,
				recordModules: &quot;record modules&quot;,
				recordChunks: &quot;record chunks&quot;,
				beforeModuleHash: &quot;module hashing&quot;,
				beforeCodeGeneration: &quot;code generation&quot;,
				beforeRuntimeRequirements: &quot;runtime requirements&quot;,
				beforeHash: &quot;hashing&quot;,
				afterHash: &quot;after hashing&quot;,
				recordHash: &quot;record hash&quot;,
				beforeModuleAssets: &quot;module assets processing&quot;,
				beforeChunkAssets: &quot;chunk assets processing&quot;,
				processAssets: &quot;asset processing&quot;,
				afterProcessAssets: &quot;after asset optimization&quot;,
				record: &quot;recording&quot;,
				afterSeal: &quot;after seal&quot;
			};
			const numberOfHooks = Object.keys(hooks).length;
			for (const [idx, name] of Object.keys(hooks).entries()) {
				const title = hooks[/** @type {keyof typeof hooks} */ (name)];
				const percentage = (idx / numberOfHooks) * 0.25 + 0.7;
				compilation.hooks[/** @type {keyof typeof hooks} */ (name)].intercept({
					name: PLUGIN_NAME,
					call() {
						handler(percentage, &quot;sealing&quot;, title);
					},
					done() {
						progressReporters.set(compiler, undefined);
						handler(percentage, &quot;sealing&quot;, title);
					},
					result() {
						handler(percentage, &quot;sealing&quot;, title);
					},
					error() {
						handler(percentage, &quot;sealing&quot;, title);
					},
					tap(tap) {
						// p is percentage from 0 to 1
						// args is any number of messages in a hierarchical matter
						progressReporters.set(compilation.compiler, (p, ...args) =&gt; {
							handler(percentage, &quot;sealing&quot;, title, tap.name, ...args);
						});
						handler(percentage, &quot;sealing&quot;, title, tap.name);
					}
				});
			}
		});
		compiler.hooks.make.intercept({
			name: PLUGIN_NAME,
			call() {
				handler(0.1, &quot;building&quot;);
			},
			done() {
				handler(0.65, &quot;building&quot;);
			}
		});
		/**
		 * @param {TODO} hook hook
		 * @param {number} progress progress from 0 to 1
		 * @param {string} category category
		 * @param {string} name name
		 */
		const interceptHook = (hook, progress, category, name) =&gt; {
			hook.intercept({
				name: PLUGIN_NAME,
				call() {
					handler(progress, category, name);
				},
				done() {
					progressReporters.set(compiler, undefined);
					handler(progress, category, name);
				},
				result() {
					handler(progress, category, name);
				},
				error() {
					handler(progress, category, name);
				},
				/**
				 * @param {Tap} tap tap
				 */
				tap(tap) {
					progressReporters.set(compiler, (p, ...args) =&gt; {
						handler(progress, category, name, tap.name, ...args);
					});
					handler(progress, category, name, tap.name);
				}
			});
		};
		compiler.cache.hooks.endIdle.intercept({
			name: PLUGIN_NAME,
			call() {
				handler(0, &quot;&quot;);
			}
		});
		interceptHook(compiler.cache.hooks.endIdle, 0.01, &quot;cache&quot;, &quot;end idle&quot;);
		compiler.hooks.beforeRun.intercept({
			name: PLUGIN_NAME,
			call() {
				handler(0, &quot;&quot;);
			}
		});
		interceptHook(compiler.hooks.beforeRun, 0.01, &quot;setup&quot;, &quot;before run&quot;);
		interceptHook(compiler.hooks.run, 0.02, &quot;setup&quot;, &quot;run&quot;);
		interceptHook(compiler.hooks.watchRun, 0.03, &quot;setup&quot;, &quot;watch run&quot;);
		interceptHook(
			compiler.hooks.normalModuleFactory,
			0.04,
			&quot;setup&quot;,
			&quot;normal module factory&quot;
		);
		interceptHook(
			compiler.hooks.contextModuleFactory,
			0.05,
			&quot;setup&quot;,
			&quot;context module factory&quot;
		);
		interceptHook(
			compiler.hooks.beforeCompile,
			0.06,
			&quot;setup&quot;,
			&quot;before compile&quot;
		);
		interceptHook(compiler.hooks.compile, 0.07, &quot;setup&quot;, &quot;compile&quot;);
		interceptHook(compiler.hooks.thisCompilation, 0.08, &quot;setup&quot;, &quot;compilation&quot;);
		interceptHook(compiler.hooks.compilation, 0.09, &quot;setup&quot;, &quot;compilation&quot;);
		interceptHook(compiler.hooks.finishMake, 0.69, &quot;building&quot;, &quot;finish&quot;);
		interceptHook(compiler.hooks.emit, 0.95, &quot;emitting&quot;, &quot;emit&quot;);
		interceptHook(compiler.hooks.afterEmit, 0.98, &quot;emitting&quot;, &quot;after emit&quot;);
		interceptHook(compiler.hooks.done, 0.99, &quot;done&quot;, &quot;plugins&quot;);
		compiler.hooks.done.intercept({
			name: PLUGIN_NAME,
			done() {
				handler(0.99, &quot;&quot;);
			}
		});
		interceptHook(
			compiler.cache.hooks.storeBuildDependencies,
			0.99,
			&quot;cache&quot;,
			&quot;store build dependencies&quot;
		);
		interceptHook(compiler.cache.hooks.shutdown, 0.99, &quot;cache&quot;, &quot;shutdown&quot;);
		interceptHook(compiler.cache.hooks.beginIdle, 0.99, &quot;cache&quot;, &quot;begin idle&quot;);
		interceptHook(
			compiler.hooks.watchClose,
			0.99,
			&quot;end&quot;,
			&quot;closing watch compilation&quot;
		);
		compiler.cache.hooks.beginIdle.intercept({
			name: PLUGIN_NAME,
			done() {
				handler(1, &quot;&quot;);
			}
		});
		compiler.cache.hooks.shutdown.intercept({
			name: PLUGIN_NAME,
			done() {
				handler(1, &quot;&quot;);
			}
		});
	}
}

ProgressPlugin.defaultOptions = {
	profile: false,
	modulesCount: 5000,
	dependenciesCount: 10000,
	modules: true,
	dependencies: true,
	activeModules: false,
	entries: true
};

ProgressPlugin.createDefaultHandler = createDefaultHandler;

module.exports = ProgressPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
