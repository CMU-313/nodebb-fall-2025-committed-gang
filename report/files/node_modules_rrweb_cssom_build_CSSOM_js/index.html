<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/rrweb-cssom/build/CSSOM.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/rrweb-cssom/build/CSSOM.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1996</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">165.76</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">16.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var CSSOM = {};


/**
 * @constructor
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
 */
CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration(){
	this.length = 0;
	this.parentRule = null;

	// NON-STANDARD
	this._importants = {};
};


CSSOM.CSSStyleDeclaration.prototype = {

	constructor: CSSOM.CSSStyleDeclaration,

	/**
	 *
	 * @param {string} name
	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-getPropertyValue
	 * @return {string} the value of the property if it has been explicitly set for this declaration block.
	 * Returns the empty string if the property has not been set.
	 */
	getPropertyValue: function(name) {
		return this[name] || &quot;&quot;;
	},

	/**
	 *
	 * @param {string} name
	 * @param {string} value
	 * @param {string} [priority=null] &quot;important&quot; or null
	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-setProperty
	 */
	setProperty: function(name, value, priority) {
		if (this[name]) {
			// Property already exist. Overwrite it.
			var index = Array.prototype.indexOf.call(this, name);
			if (index &lt; 0) {
				this[this.length] = name;
				this.length++;
			}
		} else {
			// New property.
			this[this.length] = name;
			this.length++;
		}
		this[name] = value + &quot;&quot;;
		this._importants[name] = priority;
	},

	/**
	 *
	 * @param {string} name
	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-removeProperty
	 * @return {string} the value of the property if it has been explicitly set for this declaration block.
	 * Returns the empty string if the property has not been set or the property name does not correspond to a known CSS property.
	 */
	removeProperty: function(name) {
		if (!(name in this)) {
			return &quot;&quot;;
		}
		var index = Array.prototype.indexOf.call(this, name);
		if (index &lt; 0) {
			return &quot;&quot;;
		}
		var prevValue = this[name];
		this[name] = &quot;&quot;;

		// That&#039;s what WebKit and Opera do
		Array.prototype.splice.call(this, index, 1);

		// That&#039;s what Firefox does
		//this[index] = &quot;&quot;

		return prevValue;
	},

	getPropertyCSSValue: function() {
		//FIXME
	},

	/**
	 *
	 * @param {String} name
	 */
	getPropertyPriority: function(name) {
		return this._importants[name] || &quot;&quot;;
	},


	/**
	 *   element.style.overflow = &quot;auto&quot;
	 *   element.style.getPropertyShorthand(&quot;overflow-x&quot;)
	 *   -&gt; &quot;overflow&quot;
	 */
	getPropertyShorthand: function() {
		//FIXME
	},

	isPropertyImplicit: function() {
		//FIXME
	},

	// Doesn&#039;t work in IE &lt; 9
	get cssText(){
		var properties = [];
		for (var i=0, length=this.length; i &lt; length; ++i) {
			var name = this[i];
			var value = this.getPropertyValue(name);
			var priority = this.getPropertyPriority(name);
			if (priority) {
				priority = &quot; !&quot; + priority;
			}
			properties[i] = name + &quot;: &quot; + value + priority + &quot;;&quot;;
		}
		return properties.join(&quot; &quot;);
	},

	set cssText(text){
		var i, name;
		for (i = this.length; i--;) {
			name = this[i];
			this[name] = &quot;&quot;;
		}
		Array.prototype.splice.call(this, 0, this.length);
		this._importants = {};

		var dummyRule = CSSOM.parse(&#039;#bogus{&#039; + text + &#039;}&#039;).cssRules[0].style;
		var length = dummyRule.length;
		for (i = 0; i &lt; length; ++i) {
			name = dummyRule[i];
			this.setProperty(dummyRule[i], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
		}
	}
};



/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#the-cssrule-interface
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSRule
 */
CSSOM.CSSRule = function CSSRule() {
  this.parentRule = null;
  this.parentStyleSheet = null;
};

CSSOM.CSSRule.UNKNOWN_RULE = 0; // obsolete
CSSOM.CSSRule.STYLE_RULE = 1;
CSSOM.CSSRule.CHARSET_RULE = 2; // obsolete
CSSOM.CSSRule.IMPORT_RULE = 3;
CSSOM.CSSRule.MEDIA_RULE = 4;
CSSOM.CSSRule.FONT_FACE_RULE = 5;
CSSOM.CSSRule.PAGE_RULE = 6;
CSSOM.CSSRule.KEYFRAMES_RULE = 7;
CSSOM.CSSRule.KEYFRAME_RULE = 8;
CSSOM.CSSRule.MARGIN_RULE = 9;
CSSOM.CSSRule.NAMESPACE_RULE = 10;
CSSOM.CSSRule.COUNTER_STYLE_RULE = 11;
CSSOM.CSSRule.SUPPORTS_RULE = 12;
CSSOM.CSSRule.DOCUMENT_RULE = 13;
CSSOM.CSSRule.FONT_FEATURE_VALUES_RULE = 14;
CSSOM.CSSRule.VIEWPORT_RULE = 15;
CSSOM.CSSRule.REGION_STYLE_RULE = 16;
CSSOM.CSSRule.CONTAINER_RULE = 17;
CSSOM.CSSRule.LAYER_BLOCK_RULE = 18;
CSSOM.CSSRule.STARTING_STYLE_RULE = 1002;

CSSOM.CSSRule.prototype = {
  constructor: CSSOM.CSSRule,
  //FIXME
};

exports.CSSRule = CSSOM.CSSRule;
///CommonJS
/**
 * @constructor
 * @see https://drafts.csswg.org/cssom/#the-cssgroupingrule-interface
 */
CSSOM.CSSGroupingRule = function CSSGroupingRule() {
	CSSOM.CSSRule.call(this);
	this.cssRules = [];
};

CSSOM.CSSGroupingRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSGroupingRule.prototype.constructor = CSSOM.CSSGroupingRule;


/**
 * Used to insert a new CSS rule to a list of CSS rules.
 *
 * @example
 *   cssGroupingRule.cssText
 *   -&gt; &quot;body{margin:0;}&quot;
 *   cssGroupingRule.insertRule(&quot;img{border:none;}&quot;, 1)
 *   -&gt; 1
 *   cssGroupingRule.cssText
 *   -&gt; &quot;body{margin:0;}img{border:none;}&quot;
 *
 * @param {string} rule
 * @param {number} [index]
 * @see https://www.w3.org/TR/cssom-1/#dom-cssgroupingrule-insertrule
 * @return {number} The index within the grouping rule&#039;s collection of the newly inserted rule.
 */
 CSSOM.CSSGroupingRule.prototype.insertRule = function insertRule(rule, index) {
	if (index &lt; 0 || index &gt; this.cssRules.length) {
		throw new RangeError(&quot;INDEX_SIZE_ERR&quot;);
	}
	var cssRule = CSSOM.parse(rule).cssRules[0];
	cssRule.parentRule = this;
	this.cssRules.splice(index, 0, cssRule);
	return index;
};

/**
 * Used to delete a rule from the grouping rule.
 *
 *   cssGroupingRule.cssText
 *   -&gt; &quot;img{border:none;}body{margin:0;}&quot;
 *   cssGroupingRule.deleteRule(0)
 *   cssGroupingRule.cssText
 *   -&gt; &quot;body{margin:0;}&quot;
 *
 * @param {number} index within the grouping rule&#039;s rule list of the rule to remove.
 * @see https://www.w3.org/TR/cssom-1/#dom-cssgroupingrule-deleterule
 */
 CSSOM.CSSGroupingRule.prototype.deleteRule = function deleteRule(index) {
	if (index &lt; 0 || index &gt;= this.cssRules.length) {
		throw new RangeError(&quot;INDEX_SIZE_ERR&quot;);
	}
	this.cssRules.splice(index, 1)[0].parentRule = null;
};


/**
 * @constructor
 * @see https://www.w3.org/TR/css-conditional-3/#the-cssconditionrule-interface
 */
CSSOM.CSSConditionRule = function CSSConditionRule() {
  CSSOM.CSSGroupingRule.call(this);
  this.cssRules = [];
};

CSSOM.CSSConditionRule.prototype = new CSSOM.CSSGroupingRule();
CSSOM.CSSConditionRule.prototype.constructor = CSSOM.CSSConditionRule;
CSSOM.CSSConditionRule.prototype.conditionText = &#039;&#039;
CSSOM.CSSConditionRule.prototype.cssText = &#039;&#039;


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#cssstylerule
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleRule
 */
CSSOM.CSSStyleRule = function CSSStyleRule() {
	CSSOM.CSSRule.call(this);
	this.selectorText = &quot;&quot;;
	this.style = new CSSOM.CSSStyleDeclaration();
	this.style.parentRule = this;
};

CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
CSSOM.CSSStyleRule.prototype.type = 1;

Object.defineProperty(CSSOM.CSSStyleRule.prototype, &quot;cssText&quot;, {
	get: function() {
		var text;
		if (this.selectorText) {
			text = this.selectorText + &quot; {&quot; + this.style.cssText + &quot;}&quot;;
		} else {
			text = &quot;&quot;;
		}
		return text;
	},
	set: function(cssText) {
		var rule = CSSOM.CSSStyleRule.parse(cssText);
		this.style = rule.style;
		this.selectorText = rule.selectorText;
	}
});


/**
 * NON-STANDARD
 * lightweight version of parse.js.
 * @param {string} ruleText
 * @return CSSStyleRule
 */
CSSOM.CSSStyleRule.parse = function(ruleText) {
	var i = 0;
	var state = &quot;selector&quot;;
	var index;
	var j = i;
	var buffer = &quot;&quot;;

	var SIGNIFICANT_WHITESPACE = {
		&quot;selector&quot;: true,
		&quot;value&quot;: true
	};

	var styleRule = new CSSOM.CSSStyleRule();
	var name, priority=&quot;&quot;;

	for (var character; (character = ruleText.charAt(i)); i++) {

		switch (character) {

		case &quot; &quot;:
		case &quot;\t&quot;:
		case &quot;\r&quot;:
		case &quot;\n&quot;:
		case &quot;\f&quot;:
			if (SIGNIFICANT_WHITESPACE[state]) {
				// Squash 2 or more white-spaces in the row into 1
				switch (ruleText.charAt(i - 1)) {
					case &quot; &quot;:
					case &quot;\t&quot;:
					case &quot;\r&quot;:
					case &quot;\n&quot;:
					case &quot;\f&quot;:
						break;
					default:
						buffer += &quot; &quot;;
						break;
				}
			}
			break;

		// String
		case &#039;&quot;&#039;:
			j = i + 1;
			index = ruleText.indexOf(&#039;&quot;&#039;, j) + 1;
			if (!index) {
				throw &#039;&quot; is missing&#039;;
			}
			buffer += ruleText.slice(i, index);
			i = index - 1;
			break;

		case &quot;&#039;&quot;:
			j = i + 1;
			index = ruleText.indexOf(&quot;&#039;&quot;, j) + 1;
			if (!index) {
				throw &quot;&#039; is missing&quot;;
			}
			buffer += ruleText.slice(i, index);
			i = index - 1;
			break;

		// Comment
		case &quot;/&quot;:
			if (ruleText.charAt(i + 1) === &quot;*&quot;) {
				i += 2;
				index = ruleText.indexOf(&quot;*/&quot;, i);
				if (index === -1) {
					throw new SyntaxError(&quot;Missing */&quot;);
				} else {
					i = index + 1;
				}
			} else {
				buffer += character;
			}
			break;

		case &quot;{&quot;:
			if (state === &quot;selector&quot;) {
				styleRule.selectorText = buffer.trim();
				buffer = &quot;&quot;;
				state = &quot;name&quot;;
			}
			break;

		case &quot;:&quot;:
			if (state === &quot;name&quot;) {
				name = buffer.trim();
				buffer = &quot;&quot;;
				state = &quot;value&quot;;
			} else {
				buffer += character;
			}
			break;

		case &quot;!&quot;:
			if (state === &quot;value&quot; &amp;&amp; ruleText.indexOf(&quot;!important&quot;, i) === i) {
				priority = &quot;important&quot;;
				i += &quot;important&quot;.length;
			} else {
				buffer += character;
			}
			break;

		case &quot;;&quot;:
			if (state === &quot;value&quot;) {
				styleRule.style.setProperty(name, buffer.trim(), priority);
				priority = &quot;&quot;;
				buffer = &quot;&quot;;
				state = &quot;name&quot;;
			} else {
				buffer += character;
			}
			break;

		case &quot;}&quot;:
			if (state === &quot;value&quot;) {
				styleRule.style.setProperty(name, buffer.trim(), priority);
				priority = &quot;&quot;;
				buffer = &quot;&quot;;
			} else if (state === &quot;name&quot;) {
				break;
			} else {
				buffer += character;
			}
			state = &quot;selector&quot;;
			break;

		default:
			buffer += character;
			break;

		}
	}

	return styleRule;

};



/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#the-medialist-interface
 */
CSSOM.MediaList = function MediaList(){
	this.length = 0;
};

CSSOM.MediaList.prototype = {

	constructor: CSSOM.MediaList,

	/**
	 * @return {string}
	 */
	get mediaText() {
		return Array.prototype.join.call(this, &quot;, &quot;);
	},

	/**
	 * @param {string} value
	 */
	set mediaText(value) {
		var values = value.split(&quot;,&quot;);
		var length = this.length = values.length;
		for (var i=0; i&lt;length; i++) {
			this[i] = values[i].trim();
		}
	},

	/**
	 * @param {string} medium
	 */
	appendMedium: function(medium) {
		if (Array.prototype.indexOf.call(this, medium) === -1) {
			this[this.length] = medium;
			this.length++;
		}
	},

	/**
	 * @param {string} medium
	 */
	deleteMedium: function(medium) {
		var index = Array.prototype.indexOf.call(this, medium);
		if (index !== -1) {
			Array.prototype.splice.call(this, index, 1);
		}
	}

};



/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#cssmediarule
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSMediaRule
 */
CSSOM.CSSMediaRule = function CSSMediaRule() {
	CSSOM.CSSConditionRule.call(this);
	this.media = new CSSOM.MediaList();
};

CSSOM.CSSMediaRule.prototype = new CSSOM.CSSConditionRule();
CSSOM.CSSMediaRule.prototype.constructor = CSSOM.CSSMediaRule;
CSSOM.CSSMediaRule.prototype.type = 4;

// https://opensource.apple.com/source/WebCore/WebCore-7611.1.21.161.3/css/CSSMediaRule.cpp
Object.defineProperties(CSSOM.CSSMediaRule.prototype, {
  &quot;conditionText&quot;: {
    get: function() {
      return this.media.mediaText;
    },
    set: function(value) {
      this.media.mediaText = value;
    },
    configurable: true,
    enumerable: true
  },
  &quot;cssText&quot;: {
    get: function() {
      var cssTexts = [];
      for (var i=0, length=this.cssRules.length; i &lt; length; i++) {
        cssTexts.push(this.cssRules[i].cssText);
      }
      return &quot;@media &quot; + this.media.mediaText + &quot; {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
    },
    configurable: true,
    enumerable: true
  }
});



/**
 * @constructor
 * @see https://drafts.csswg.org/css-contain-3/
 * @see https://www.w3.org/TR/css-contain-3/
 */
CSSOM.CSSContainerRule = function CSSContainerRule() {
	CSSOM.CSSConditionRule.call(this);
};

CSSOM.CSSContainerRule.prototype = new CSSOM.CSSConditionRule();
CSSOM.CSSContainerRule.prototype.constructor = CSSOM.CSSContainerRule;
CSSOM.CSSContainerRule.prototype.type = 17;

Object.defineProperties(CSSOM.CSSContainerRule.prototype, {
  &quot;conditionText&quot;: {
    get: function() {
      return this.containerText;
    },
    set: function(value) {
      this.containerText = value;
    },
    configurable: true,
    enumerable: true
  },
  &quot;cssText&quot;: {
    get: function() {
      var cssTexts = [];
      for (var i=0, length=this.cssRules.length; i &lt; length; i++) {
        cssTexts.push(this.cssRules[i].cssText);
      }
      return &quot;@container &quot; + this.containerText + &quot; {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
    },
    configurable: true,
    enumerable: true
  }
});



/**
 * @constructor
 * @see https://drafts.csswg.org/css-conditional-3/#the-csssupportsrule-interface
 */
CSSOM.CSSSupportsRule = function CSSSupportsRule() {
  CSSOM.CSSConditionRule.call(this);
};

CSSOM.CSSSupportsRule.prototype = new CSSOM.CSSConditionRule();
CSSOM.CSSSupportsRule.prototype.constructor = CSSOM.CSSSupportsRule;
CSSOM.CSSSupportsRule.prototype.type = 12;

Object.defineProperty(CSSOM.CSSSupportsRule.prototype, &quot;cssText&quot;, {
  get: function() {
    var cssTexts = [];

    for (var i = 0, length = this.cssRules.length; i &lt; length; i++) {
      cssTexts.push(this.cssRules[i].cssText);
    }

    return &quot;@supports &quot; + this.conditionText + &quot; {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
  }
});


/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#cssimportrule
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSImportRule
 */
CSSOM.CSSImportRule = function CSSImportRule() {
	CSSOM.CSSRule.call(this);
	this.href = &quot;&quot;;
	this.media = new CSSOM.MediaList();
	this.styleSheet = new CSSOM.CSSStyleSheet();
};

CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
CSSOM.CSSImportRule.prototype.type = 3;

Object.defineProperty(CSSOM.CSSImportRule.prototype, &quot;cssText&quot;, {
  get: function() {
    var mediaText = this.media.mediaText;
    return &quot;@import url(&quot; + this.href + &quot;)&quot; + (mediaText ? &quot; &quot; + mediaText : &quot;&quot;) + &quot;;&quot;;
  },
  set: function(cssText) {
    var i = 0;

    /**
     * @import url(partial.css) screen, handheld;
     *        ||               |
     *        after-import     media
     *         |
     *         url
     */
    var state = &#039;&#039;;

    var buffer = &#039;&#039;;
    var index;
    for (var character; (character = cssText.charAt(i)); i++) {

      switch (character) {
        case &#039; &#039;:
        case &#039;\t&#039;:
        case &#039;\r&#039;:
        case &#039;\n&#039;:
        case &#039;\f&#039;:
          if (state === &#039;after-import&#039;) {
            state = &#039;url&#039;;
          } else {
            buffer += character;
          }
          break;

        case &#039;@&#039;:
          if (!state &amp;&amp; cssText.indexOf(&#039;@import&#039;, i) === i) {
            state = &#039;after-import&#039;;
            i += &#039;import&#039;.length;
            buffer = &#039;&#039;;
          }
          break;

        case &#039;u&#039;:
          if (state === &#039;url&#039; &amp;&amp; cssText.indexOf(&#039;url(&#039;, i) === i) {
            index = cssText.indexOf(&#039;)&#039;, i + 1);
            if (index === -1) {
              throw i + &#039;: &quot;)&quot; not found&#039;;
            }
            i += &#039;url(&#039;.length;
            var url = cssText.slice(i, index);
            if (url[0] === url[url.length - 1]) {
              if (url[0] === &#039;&quot;&#039; || url[0] === &quot;&#039;&quot;) {
                url = url.slice(1, -1);
              }
            }
            this.href = url;
            i = index;
            state = &#039;media&#039;;
          }
          break;

        case &#039;&quot;&#039;:
          if (state === &#039;url&#039;) {
            index = cssText.indexOf(&#039;&quot;&#039;, i + 1);
            if (!index) {
              throw i + &quot;: &#039;\&quot;&#039; not found&quot;;
            }
            this.href = cssText.slice(i + 1, index);
            i = index;
            state = &#039;media&#039;;
          }
          break;

        case &quot;&#039;&quot;:
          if (state === &#039;url&#039;) {
            index = cssText.indexOf(&quot;&#039;&quot;, i + 1);
            if (!index) {
              throw i + &#039;: &quot;\&#039;&quot; not found&#039;;
            }
            this.href = cssText.slice(i + 1, index);
            i = index;
            state = &#039;media&#039;;
          }
          break;

        case &#039;;&#039;:
          if (state === &#039;media&#039;) {
            if (buffer) {
              this.media.mediaText = buffer.trim();
            }
          }
          break;

        default:
          if (state === &#039;media&#039;) {
            buffer += character;
          }
          break;
      }
    }
  }
});



/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#css-font-face-rule
 */
CSSOM.CSSFontFaceRule = function CSSFontFaceRule() {
	CSSOM.CSSRule.call(this);
	this.style = new CSSOM.CSSStyleDeclaration();
	this.style.parentRule = this;
};

CSSOM.CSSFontFaceRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSFontFaceRule.prototype.constructor = CSSOM.CSSFontFaceRule;
CSSOM.CSSFontFaceRule.prototype.type = 5;
//FIXME
//CSSOM.CSSFontFaceRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSFontFaceRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSFontFaceRule.cpp
Object.defineProperty(CSSOM.CSSFontFaceRule.prototype, &quot;cssText&quot;, {
  get: function() {
    return &quot;@font-face {&quot; + this.style.cssText + &quot;}&quot;;
  }
});



/**
 * @constructor
 * @see http://www.w3.org/TR/shadow-dom/#host-at-rule
 */
CSSOM.CSSHostRule = function CSSHostRule() {
	CSSOM.CSSRule.call(this);
	this.cssRules = [];
};

CSSOM.CSSHostRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSHostRule.prototype.constructor = CSSOM.CSSHostRule;
CSSOM.CSSHostRule.prototype.type = 1001;
//FIXME
//CSSOM.CSSHostRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSHostRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

Object.defineProperty(CSSOM.CSSHostRule.prototype, &quot;cssText&quot;, {
	get: function() {
		var cssTexts = [];
		for (var i=0, length=this.cssRules.length; i &lt; length; i++) {
			cssTexts.push(this.cssRules[i].cssText);
		}
		return &quot;@host {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
	}
});



/**
 * @constructor
 * @see http://www.w3.org/TR/shadow-dom/#host-at-rule
 */
CSSOM.CSSStartingStyleRule = function CSSStartingStyleRule() {
	CSSOM.CSSRule.call(this);
	this.cssRules = [];
};

CSSOM.CSSStartingStyleRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSStartingStyleRule.prototype.constructor = CSSOM.CSSStartingStyleRule;
CSSOM.CSSStartingStyleRule.prototype.type = 1002;
//FIXME
//CSSOM.CSSStartingStyleRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSStartingStyleRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

Object.defineProperty(CSSOM.CSSStartingStyleRule.prototype, &quot;cssText&quot;, {
	get: function() {
		var cssTexts = [];
		for (var i=0, length=this.cssRules.length; i &lt; length; i++) {
			cssTexts.push(this.cssRules[i].cssText);
		}
		return &quot;@starting-style {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
	}
});



/**
 * @constructor
 * @see http://dev.w3.org/csswg/cssom/#the-stylesheet-interface
 */
CSSOM.StyleSheet = function StyleSheet() {
	this.parentStyleSheet = null;
};



/**
 * @constructor
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet
 */
CSSOM.CSSStyleSheet = function CSSStyleSheet() {
	CSSOM.StyleSheet.call(this);
	this.cssRules = [];
};


CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet();
CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;


/**
 * Used to insert a new rule into the style sheet. The new rule now becomes part of the cascade.
 *
 *   sheet = new Sheet(&quot;body {margin: 0}&quot;)
 *   sheet.toString()
 *   -&gt; &quot;body{margin:0;}&quot;
 *   sheet.insertRule(&quot;img {border: none}&quot;, 0)
 *   -&gt; 0
 *   sheet.toString()
 *   -&gt; &quot;img{border:none;}body{margin:0;}&quot;
 *
 * @param {string} rule
 * @param {number} index
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-insertRule
 * @return {number} The index within the style sheet&#039;s rule collection of the newly inserted rule.
 */
CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
	if (index &lt; 0 || index &gt; this.cssRules.length) {
		throw new RangeError(&quot;INDEX_SIZE_ERR&quot;);
	}
	var cssRule = CSSOM.parse(rule).cssRules[0];
	cssRule.parentStyleSheet = this;
	this.cssRules.splice(index, 0, cssRule);
	return index;
};


/**
 * Used to delete a rule from the style sheet.
 *
 *   sheet = new Sheet(&quot;img{border:none} body{margin:0}&quot;)
 *   sheet.toString()
 *   -&gt; &quot;img{border:none;}body{margin:0;}&quot;
 *   sheet.deleteRule(0)
 *   sheet.toString()
 *   -&gt; &quot;body{margin:0;}&quot;
 *
 * @param {number} index within the style sheet&#039;s rule list of the rule to remove.
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-deleteRule
 */
CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
	if (index &lt; 0 || index &gt;= this.cssRules.length) {
		throw new RangeError(&quot;INDEX_SIZE_ERR&quot;);
	}
	this.cssRules.splice(index, 1);
};


/**
 * NON-STANDARD
 * @return {string} serialize stylesheet
 */
CSSOM.CSSStyleSheet.prototype.toString = function() {
	var result = &quot;&quot;;
	var rules = this.cssRules;
	for (var i=0; i&lt;rules.length; i++) {
		result += rules[i].cssText + &quot;\n&quot;;
	}
	return result;
};



/**
 * @constructor
 * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframesRule
 */
CSSOM.CSSKeyframesRule = function CSSKeyframesRule() {
	CSSOM.CSSRule.call(this);
	this.name = &#039;&#039;;
	this.cssRules = [];
};

CSSOM.CSSKeyframesRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSKeyframesRule.prototype.constructor = CSSOM.CSSKeyframesRule;
CSSOM.CSSKeyframesRule.prototype.type = 7;
//FIXME
//CSSOM.CSSKeyframesRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSKeyframesRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframesRule.cpp
Object.defineProperty(CSSOM.CSSKeyframesRule.prototype, &quot;cssText&quot;, {
  get: function() {
    var cssTexts = [];
    for (var i=0, length=this.cssRules.length; i &lt; length; i++) {
      cssTexts.push(&quot;  &quot; + this.cssRules[i].cssText);
    }
    return &quot;@&quot; + (this._vendorPrefix || &#039;&#039;) + &quot;keyframes &quot; + this.name + &quot; { \n&quot; + cssTexts.join(&quot;\n&quot;) + &quot;\n}&quot;;
  }
});



/**
 * @constructor
 * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframeRule
 */
CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
	CSSOM.CSSRule.call(this);
	this.keyText = &#039;&#039;;
	this.style = new CSSOM.CSSStyleDeclaration();
	this.style.parentRule = this;
};

CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
CSSOM.CSSKeyframeRule.prototype.type = 8;
//FIXME
//CSSOM.CSSKeyframeRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSKeyframeRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframeRule.cpp
Object.defineProperty(CSSOM.CSSKeyframeRule.prototype, &quot;cssText&quot;, {
  get: function() {
    return this.keyText + &quot; {&quot; + this.style.cssText + &quot;} &quot;;
  }
});



/**
 * @constructor
 * @see https://developer.mozilla.org/en/CSS/@-moz-document
 */
CSSOM.MatcherList = function MatcherList(){
    this.length = 0;
};

CSSOM.MatcherList.prototype = {

    constructor: CSSOM.MatcherList,

    /**
     * @return {string}
     */
    get matcherText() {
        return Array.prototype.join.call(this, &quot;, &quot;);
    },

    /**
     * @param {string} value
     */
    set matcherText(value) {
        // just a temporary solution, actually it may be wrong by just split the value with &#039;,&#039;, because a url can include &#039;,&#039;.
        var values = value.split(&quot;,&quot;);
        var length = this.length = values.length;
        for (var i=0; i&lt;length; i++) {
            this[i] = values[i].trim();
        }
    },

    /**
     * @param {string} matcher
     */
    appendMatcher: function(matcher) {
        if (Array.prototype.indexOf.call(this, matcher) === -1) {
            this[this.length] = matcher;
            this.length++;
        }
    },

    /**
     * @param {string} matcher
     */
    deleteMatcher: function(matcher) {
        var index = Array.prototype.indexOf.call(this, matcher);
        if (index !== -1) {
            Array.prototype.splice.call(this, index, 1);
        }
    }

};



/**
 * @constructor
 * @see https://developer.mozilla.org/en/CSS/@-moz-document
 */
CSSOM.CSSDocumentRule = function CSSDocumentRule() {
    CSSOM.CSSRule.call(this);
    this.matcher = new CSSOM.MatcherList();
    this.cssRules = [];
};

CSSOM.CSSDocumentRule.prototype = new CSSOM.CSSRule();
CSSOM.CSSDocumentRule.prototype.constructor = CSSOM.CSSDocumentRule;
CSSOM.CSSDocumentRule.prototype.type = 10;
//FIXME
//CSSOM.CSSDocumentRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
//CSSOM.CSSDocumentRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

Object.defineProperty(CSSOM.CSSDocumentRule.prototype, &quot;cssText&quot;, {
  get: function() {
    var cssTexts = [];
    for (var i=0, length=this.cssRules.length; i &lt; length; i++) {
        cssTexts.push(this.cssRules[i].cssText);
    }
    return &quot;@-moz-document &quot; + this.matcher.matcherText + &quot; {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
  }
});



/**
 * @constructor
 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
 *
 * TODO: add if needed
 */
CSSOM.CSSValue = function CSSValue() {
};

CSSOM.CSSValue.prototype = {
	constructor: CSSOM.CSSValue,

	// @see: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
	set cssText(text) {
		var name = this._getConstructorName();

		throw new Error(&#039;DOMException: property &quot;cssText&quot; of &quot;&#039; + name + &#039;&quot; is readonly and can not be replaced with &quot;&#039; + text + &#039;&quot;!&#039;);
	},

	get cssText() {
		var name = this._getConstructorName();

		throw new Error(&#039;getter &quot;cssText&quot; of &quot;&#039; + name + &#039;&quot; is not implemented!&#039;);
	},

	_getConstructorName: function() {
		var s = this.constructor.toString(),
				c = s.match(/function\s([^\(]+)/),
				name = c[1];

		return name;
	}
};



/**
 * @constructor
 * @see http://msdn.microsoft.com/en-us/library/ms537634(v=vs.85).aspx
 *
 */
CSSOM.CSSValueExpression = function CSSValueExpression(token, idx) {
	this._token = token;
	this._idx = idx;
};

CSSOM.CSSValueExpression.prototype = new CSSOM.CSSValue();
CSSOM.CSSValueExpression.prototype.constructor = CSSOM.CSSValueExpression;

/**
 * parse css expression() value
 *
 * @return {Object}
 *         - error:
 *         or
 *         - idx:
 *         - expression:
 *
 * Example:
 *
 * .selector {
 *		zoom: expression(documentElement.clientWidth &gt; 1000 ? &#039;1000px&#039; : &#039;auto&#039;);
 * }
 */
CSSOM.CSSValueExpression.prototype.parse = function() {
	var token = this._token,
			idx = this._idx;

	var character = &#039;&#039;,
			expression = &#039;&#039;,
			error = &#039;&#039;,
			info,
			paren = [];


	for (; ; ++idx) {
		character = token.charAt(idx);

		// end of token
		if (character === &#039;&#039;) {
			error = &#039;css expression error: unfinished expression!&#039;;
			break;
		}

		switch(character) {
			case &#039;(&#039;:
				paren.push(character);
				expression += character;
				break;

			case &#039;)&#039;:
				paren.pop(character);
				expression += character;
				break;

			case &#039;/&#039;:
				if ((info = this._parseJSComment(token, idx))) { // comment?
					if (info.error) {
						error = &#039;css expression error: unfinished comment in expression!&#039;;
					} else {
						idx = info.idx;
						// ignore the comment
					}
				} else if ((info = this._parseJSRexExp(token, idx))) { // regexp
					idx = info.idx;
					expression += info.text;
				} else { // other
					expression += character;
				}
				break;

			case &quot;&#039;&quot;:
			case &#039;&quot;&#039;:
				info = this._parseJSString(token, idx, character);
				if (info) { // string
					idx = info.idx;
					expression += info.text;
				} else {
					expression += character;
				}
				break;

			default:
				expression += character;
				break;
		}

		if (error) {
			break;
		}

		// end of expression
		if (paren.length === 0) {
			break;
		}
	}

	var ret;
	if (error) {
		ret = {
			error: error
		};
	} else {
		ret = {
			idx: idx,
			expression: expression
		};
	}

	return ret;
};


/**
 *
 * @return {Object|false}
 *          - idx:
 *          - text:
 *          or
 *          - error:
 *          or
 *          false
 *
 */
CSSOM.CSSValueExpression.prototype._parseJSComment = function(token, idx) {
	var nextChar = token.charAt(idx + 1),
			text;

	if (nextChar === &#039;/&#039; || nextChar === &#039;*&#039;) {
		var startIdx = idx,
				endIdx,
				commentEndChar;

		if (nextChar === &#039;/&#039;) { // line comment
			commentEndChar = &#039;\n&#039;;
		} else if (nextChar === &#039;*&#039;) { // block comment
			commentEndChar = &#039;*/&#039;;
		}

		endIdx = token.indexOf(commentEndChar, startIdx + 1 + 1);
		if (endIdx !== -1) {
			endIdx = endIdx + commentEndChar.length - 1;
			text = token.substring(idx, endIdx + 1);
			return {
				idx: endIdx,
				text: text
			};
		} else {
			var error = &#039;css expression error: unfinished comment in expression!&#039;;
			return {
				error: error
			};
		}
	} else {
		return false;
	}
};


/**
 *
 * @return {Object|false}
 *					- idx:
 *					- text:
 *					or 
 *					false
 *
 */
CSSOM.CSSValueExpression.prototype._parseJSString = function(token, idx, sep) {
	var endIdx = this._findMatchedIdx(token, idx, sep),
			text;

	if (endIdx === -1) {
		return false;
	} else {
		text = token.substring(idx, endIdx + sep.length);

		return {
			idx: endIdx,
			text: text
		};
	}
};


/**
 * parse regexp in css expression
 *
 * @return {Object|false}
 *				- idx:
 *				- regExp:
 *				or 
 *				false
 */

/*

all legal RegExp
 
/a/
(/a/)
[/a/]
[12, /a/]

!/a/

+/a/
-/a/
* /a/
/ /a/
%/a/

===/a/
!==/a/
==/a/
!=/a/
&gt;/a/
&gt;=/a/
&lt;/a/
&lt;=/a/

&amp;/a/
|/a/
^/a/
~/a/
&lt;&lt;/a/
&gt;&gt;/a/
&gt;&gt;&gt;/a/

&amp;&amp;/a/
||/a/
?/a/
=/a/
,/a/

		delete /a/
				in /a/
instanceof /a/
				new /a/
		typeof /a/
			void /a/

*/
CSSOM.CSSValueExpression.prototype._parseJSRexExp = function(token, idx) {
	var before = token.substring(0, idx).replace(/\s+$/, &quot;&quot;),
			legalRegx = [
				/^$/,
				/\($/,
				/\[$/,
				/\!$/,
				/\+$/,
				/\-$/,
				/\*$/,
				/\/\s+/,
				/\%$/,
				/\=$/,
				/\&gt;$/,
				/&lt;$/,
				/\&amp;$/,
				/\|$/,
				/\^$/,
				/\~$/,
				/\?$/,
				/\,$/,
				/delete$/,
				/in$/,
				/instanceof$/,
				/new$/,
				/typeof$/,
				/void$/
			];

	var isLegal = legalRegx.some(function(reg) {
		return reg.test(before);
	});

	if (!isLegal) {
		return false;
	} else {
		var sep = &#039;/&#039;;

		// same logic as string
		return this._parseJSString(token, idx, sep);
	}
};


/**
 *
 * find next sep(same line) index in `token`
 *
 * @return {Number}
 *
 */
CSSOM.CSSValueExpression.prototype._findMatchedIdx = function(token, idx, sep) {
	var startIdx = idx,
			endIdx;

	var NOT_FOUND = -1;

	while(true) {
		endIdx = token.indexOf(sep, startIdx + 1);

		if (endIdx === -1) { // not found
			endIdx = NOT_FOUND;
			break;
		} else {
			var text = token.substring(idx + 1, endIdx),
					matched = text.match(/\\+$/);
			if (!matched || matched[0] % 2 === 0) { // not escaped
				break;
			} else {
				startIdx = endIdx;
			}
		}
	}

	// boundary must be in the same line(js sting or regexp)
	var nextNewLineIdx = token.indexOf(&#039;\n&#039;, idx + 1);
	if (nextNewLineIdx &lt; endIdx) {
		endIdx = NOT_FOUND;
	}


	return endIdx;
};





/**
 * @constructor
 * @see https://drafts.csswg.org/css-cascade-5/#csslayerblockrule
 */
CSSOM.CSSLayerBlockRule = function CSSLayerBlockRule() {
  CSSOM.CSSGroupingRule.call(this);
  this.layerName = &quot;&quot;;
  this.cssRules = [];
};

CSSOM.CSSLayerBlockRule.prototype = new CSSOM.CSSGroupingRule();
CSSOM.CSSLayerBlockRule.prototype.constructor = CSSOM.CSSLayerBlockRule;
CSSOM.CSSLayerBlockRule.prototype.type = 18;

Object.defineProperties(CSSOM.CSSLayerBlockRule.prototype, {
  layerNameText: {
    get: function () {
      return this.layerName;
    },
    set: function (value) {
      this.layerName = value;
    },
    configurable: true,
    enumerable: true,
  },
  cssText: {
    get: function () {
      var cssTexts = [];
      for (var i = 0, length = this.cssRules.length; i &lt; length; i++) {
        cssTexts.push(this.cssRules[i].cssText);
      }
      return &quot;@layer &quot; + this.layerNameText + &quot; {&quot; + cssTexts.join(&quot;&quot;) + &quot;}&quot;;
    },
    configurable: true,
    enumerable: true,
  },
});


/**
 * @param {string} token
 */
CSSOM.parse = function parse(token) {

	var i = 0;

	/**
		&quot;before-selector&quot; or
		&quot;selector&quot; or
		&quot;atRule&quot; or
		&quot;atBlock&quot; or
		&quot;conditionBlock&quot; or
		&quot;before-name&quot; or
		&quot;name&quot; or
		&quot;before-value&quot; or
		&quot;value&quot;
	*/
	var state = &quot;before-selector&quot;;

	var index;
	var buffer = &quot;&quot;;
	var valueParenthesisDepth = 0;

	var SIGNIFICANT_WHITESPACE = {
		&quot;selector&quot;: true,
		&quot;value&quot;: true,
		&quot;value-parenthesis&quot;: true,
		&quot;atRule&quot;: true,
		&quot;importRule-begin&quot;: true,
		&quot;importRule&quot;: true,
		&quot;atBlock&quot;: true,
		&quot;containerBlock&quot;: true,
		&quot;conditionBlock&quot;: true,
		&#039;documentRule-begin&#039;: true,
		&quot;layerBlock&quot;: true
	};

	var styleSheet = new CSSOM.CSSStyleSheet();

	// @type CSSStyleSheet|CSSMediaRule|CSSContainerRule|CSSSupportsRule|CSSFontFaceRule|CSSKeyframesRule|CSSDocumentRule
	var currentScope = styleSheet;

	// @type CSSMediaRule|CSSContainerRule|CSSSupportsRule|CSSKeyframesRule|CSSDocumentRule
	var parentRule;

	var ancestorRules = [];
	var hasAncestors = false;
	var prevScope;

	var name, priority=&quot;&quot;, styleRule, mediaRule, containerRule, supportsRule, importRule, fontFaceRule, keyframesRule, documentRule, hostRule, startingStyleRule, layerBlockRule;

	var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;

	var parseError = function(message) {
		var lines = token.substring(0, i).split(&#039;\n&#039;);
		var lineCount = lines.length;
		var charCount = lines.pop().length + 1;
		var error = new Error(message + &#039; (line &#039; + lineCount + &#039;, char &#039; + charCount + &#039;)&#039;);
		error.line = lineCount;
		/* jshint sub : true */
		error[&#039;char&#039;] = charCount;
		error.styleSheet = styleSheet;
		throw error;
	};

	for (var character; (character = token.charAt(i)); i++) {

		switch (character) {

		case &quot; &quot;:
		case &quot;\t&quot;:
		case &quot;\r&quot;:
		case &quot;\n&quot;:
		case &quot;\f&quot;:
			if (SIGNIFICANT_WHITESPACE[state]) {
				buffer += character;
			}
			break;

		// String
		case &#039;&quot;&#039;:
			index = i + 1;
			do {
				index = token.indexOf(&#039;&quot;&#039;, index) + 1;
				if (!index) {
					parseError(&#039;Unmatched &quot;&#039;);
				}
			} while (token[index - 2] === &#039;\\&#039;);
			buffer += token.slice(i, index);
			i = index - 1;
			switch (state) {
				case &#039;before-value&#039;:
					state = &#039;value&#039;;
					break;
				case &#039;importRule-begin&#039;:
					state = &#039;importRule&#039;;
					break;
			}
			break;

		case &quot;&#039;&quot;:
			index = i + 1;
			do {
				index = token.indexOf(&quot;&#039;&quot;, index) + 1;
				if (!index) {
					parseError(&quot;Unmatched &#039;&quot;);
				}
			} while (token[index - 2] === &#039;\\&#039;);
			buffer += token.slice(i, index);
			i = index - 1;
			switch (state) {
				case &#039;before-value&#039;:
					state = &#039;value&#039;;
					break;
				case &#039;importRule-begin&#039;:
					state = &#039;importRule&#039;;
					break;
			}
			break;

		// Comment
		case &quot;/&quot;:
			if (token.charAt(i + 1) === &quot;*&quot;) {
				i += 2;
				index = token.indexOf(&quot;*/&quot;, i);
				if (index === -1) {
					parseError(&quot;Missing */&quot;);
				} else {
					i = index + 1;
				}
			} else {
				buffer += character;
			}
			if (state === &quot;importRule-begin&quot;) {
				buffer += &quot; &quot;;
				state = &quot;importRule&quot;;
			}
			break;

		// At-rule
		case &quot;@&quot;:
			if (token.indexOf(&quot;@-moz-document&quot;, i) === i) {
				state = &quot;documentRule-begin&quot;;
				documentRule = new CSSOM.CSSDocumentRule();
				documentRule.__starts = i;
				i += &quot;-moz-document&quot;.length;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@media&quot;, i) === i) {
				state = &quot;atBlock&quot;;
				mediaRule = new CSSOM.CSSMediaRule();
				mediaRule.__starts = i;
				i += &quot;media&quot;.length;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@container&quot;, i) === i) {
				state = &quot;containerBlock&quot;;
				containerRule = new CSSOM.CSSContainerRule();
				containerRule.__starts = i;
				i += &quot;container&quot;.length;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@layer&quot;, i) === i) {
				state = &quot;layerBlock&quot;
				layerBlockRule = new CSSOM.CSSLayerBlockRule();
				layerBlockRule.__starts = i;
				i += &quot;layer&quot;.length;
				buffer = &quot;&quot;;
				break;
			}  else if (token.indexOf(&quot;@supports&quot;, i) === i) {
				state = &quot;conditionBlock&quot;;
				supportsRule = new CSSOM.CSSSupportsRule();
				supportsRule.__starts = i;
				i += &quot;supports&quot;.length;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@host&quot;, i) === i) {
				state = &quot;hostRule-begin&quot;;
				i += &quot;host&quot;.length;
				hostRule = new CSSOM.CSSHostRule();
				hostRule.__starts = i;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@starting-style&quot;, i) === i) {
				state = &quot;startingStyleRule-begin&quot;;
				i += &quot;starting-style&quot;.length;
				startingStyleRule = new CSSOM.CSSStartingStyleRule();
				startingStyleRule.__starts = i;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@import&quot;, i) === i) {
				state = &quot;importRule-begin&quot;;
				i += &quot;import&quot;.length;
				buffer += &quot;@import&quot;;
				break;
			} else if (token.indexOf(&quot;@font-face&quot;, i) === i) {
				state = &quot;fontFaceRule-begin&quot;;
				i += &quot;font-face&quot;.length;
				fontFaceRule = new CSSOM.CSSFontFaceRule();
				fontFaceRule.__starts = i;
				buffer = &quot;&quot;;
				break;
			} else {
				atKeyframesRegExp.lastIndex = i;
				var matchKeyframes = atKeyframesRegExp.exec(token);
				if (matchKeyframes &amp;&amp; matchKeyframes.index === i) {
					state = &quot;keyframesRule-begin&quot;;
					keyframesRule = new CSSOM.CSSKeyframesRule();
					keyframesRule.__starts = i;
					keyframesRule._vendorPrefix = matchKeyframes[1]; // Will come out as undefined if no prefix was found
					i += matchKeyframes[0].length - 1;
					buffer = &quot;&quot;;
					break;
				} else if (state === &quot;selector&quot;) {
					state = &quot;atRule&quot;;
				}
			}
			buffer += character;
			break;

		case &quot;{&quot;:
			if (state === &quot;selector&quot; || state === &quot;atRule&quot;) {
				styleRule.selectorText = buffer.trim();
				styleRule.style.__starts = i;
				buffer = &quot;&quot;;
				state = &quot;before-name&quot;;
			} else if (state === &quot;atBlock&quot;) {
				mediaRule.media.mediaText = buffer.trim();

				if (parentRule) {
					ancestorRules.push(parentRule);
				}

				currentScope = parentRule = mediaRule;
				mediaRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			} else if (state === &quot;containerBlock&quot;) {
				containerRule.containerText = buffer.trim();

				if (parentRule) {
					ancestorRules.push(parentRule);
				}
				currentScope = parentRule = containerRule;
				containerRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			} else if (state === &quot;conditionBlock&quot;) {
				supportsRule.conditionText = buffer.trim();

				if (parentRule) {
					ancestorRules.push(parentRule);
				}

				currentScope = parentRule = supportsRule;
				supportsRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			} else if (state === &quot;layerBlock&quot;) {
				layerBlockRule.layerNameText = buffer.trim();

				if (parentRule) {
					ancestorRules.push(parentRule);
				}

				currentScope = parentRule = layerBlockRule;
				layerBlockRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			} else if (state === &quot;hostRule-begin&quot;) {
				if (parentRule) {
					ancestorRules.push(parentRule);
				}

				currentScope = parentRule = hostRule;
				hostRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			} else if (state === &quot;startingStyleRule-begin&quot;) {
				if (parentRule) {
					ancestorRules.push(parentRule);
				}

				currentScope = parentRule = startingStyleRule;
				startingStyleRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;

			} else if (state === &quot;fontFaceRule-begin&quot;) {
				if (parentRule) {
					fontFaceRule.parentRule = parentRule;
				}
				fontFaceRule.parentStyleSheet = styleSheet;
				styleRule = fontFaceRule;
				buffer = &quot;&quot;;
				state = &quot;before-name&quot;;
			} else if (state === &quot;keyframesRule-begin&quot;) {
				keyframesRule.name = buffer.trim();
				if (parentRule) {
					ancestorRules.push(parentRule);
					keyframesRule.parentRule = parentRule;
				}
				keyframesRule.parentStyleSheet = styleSheet;
				currentScope = parentRule = keyframesRule;
				buffer = &quot;&quot;;
				state = &quot;keyframeRule-begin&quot;;
			} else if (state === &quot;keyframeRule-begin&quot;) {
				styleRule = new CSSOM.CSSKeyframeRule();
				styleRule.keyText = buffer.trim();
				styleRule.__starts = i;
				buffer = &quot;&quot;;
				state = &quot;before-name&quot;;
			} else if (state === &quot;documentRule-begin&quot;) {
				// FIXME: what if this &#039;{&#039; is in the url text of the match function?
				documentRule.matcher.matcherText = buffer.trim();
				if (parentRule) {
					ancestorRules.push(parentRule);
					documentRule.parentRule = parentRule;
				}
				currentScope = parentRule = documentRule;
				documentRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			}
			break;

		case &quot;:&quot;:
			if (state === &quot;name&quot;) {
				name = buffer.trim();
				buffer = &quot;&quot;;
				state = &quot;before-value&quot;;
			} else {
				buffer += character;
			}
			break;

		case &quot;(&quot;:
			if (state === &#039;value&#039;) {
				// ie css expression mode
				if (buffer.trim() === &#039;expression&#039;) {
					var info = (new CSSOM.CSSValueExpression(token, i)).parse();

					if (info.error) {
						parseError(info.error);
					} else {
						buffer += info.expression;
						i = info.idx;
					}
				} else {
					state = &#039;value-parenthesis&#039;;
					//always ensure this is reset to 1 on transition
					//from value to value-parenthesis
					valueParenthesisDepth = 1;
					buffer += character;
				}
			} else if (state === &#039;value-parenthesis&#039;) {
				valueParenthesisDepth++;
				buffer += character;
			} else {
				buffer += character;
			}
			break;

		case &quot;)&quot;:
			if (state === &#039;value-parenthesis&#039;) {
				valueParenthesisDepth--;
				if (valueParenthesisDepth === 0) state = &#039;value&#039;;
			}
			buffer += character;
			break;

		case &quot;!&quot;:
			if (state === &quot;value&quot; &amp;&amp; token.indexOf(&quot;!important&quot;, i) === i) {
				priority = &quot;important&quot;;
				i += &quot;important&quot;.length;
			} else {
				buffer += character;
			}
			break;

		case &quot;;&quot;:
			switch (state) {
				case &quot;value&quot;:
					styleRule.style.setProperty(name, buffer.trim(), priority);
					priority = &quot;&quot;;
					buffer = &quot;&quot;;
					state = &quot;before-name&quot;;
					break;
				case &quot;atRule&quot;:
					buffer = &quot;&quot;;
					state = &quot;before-selector&quot;;
					break;
				case &quot;importRule&quot;:
					importRule = new CSSOM.CSSImportRule();
					importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
					importRule.cssText = buffer + character;
					styleSheet.cssRules.push(importRule);
					buffer = &quot;&quot;;
					state = &quot;before-selector&quot;;
					break;
				default:
					buffer += character;
					break;
			}
			break;

		case &quot;}&quot;:
			switch (state) {
				case &quot;value&quot;:
					styleRule.style.setProperty(name, buffer.trim(), priority);
					priority = &quot;&quot;;
					/* falls through */
				case &quot;before-name&quot;:
				case &quot;name&quot;:
					styleRule.__ends = i + 1;
					if (parentRule) {
						styleRule.parentRule = parentRule;
					}
					styleRule.parentStyleSheet = styleSheet;
					currentScope.cssRules.push(styleRule);
					buffer = &quot;&quot;;
					if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
						state = &quot;keyframeRule-begin&quot;;
					} else {
						state = &quot;before-selector&quot;;
					}
					break;
				case &quot;keyframeRule-begin&quot;:
				case &quot;before-selector&quot;:
				case &quot;selector&quot;:
					// End of media/supports/document rule.
					if (!parentRule) {
						parseError(&quot;Unexpected }&quot;);
					}

					// Handle rules nested in @media or @supports
					hasAncestors = ancestorRules.length &gt; 0;

					while (ancestorRules.length &gt; 0) {
						parentRule = ancestorRules.pop();

						if (
							parentRule.constructor.name === &quot;CSSMediaRule&quot;
							|| parentRule.constructor.name === &quot;CSSSupportsRule&quot;
							|| parentRule.constructor.name === &quot;CSSContainerRule&quot;
							|| parentRule.constructor.name === &quot;CSSLayerBlockRule&quot;
							|| parentRule.constructor.name === &quot;CSSStartingStyleRule&quot;
						) {
							prevScope = currentScope;
							currentScope = parentRule;
							currentScope.cssRules.push(prevScope);
							break;
						}

						if (ancestorRules.length === 0) {
							hasAncestors = false;
						}
					}
					
					if (!hasAncestors) {
						currentScope.__ends = i + 1;
						styleSheet.cssRules.push(currentScope);
						currentScope = styleSheet;
						parentRule = null;
					}

					buffer = &quot;&quot;;
					state = &quot;before-selector&quot;;
					break;
			}
			break;

		default:
			switch (state) {
				case &quot;before-selector&quot;:
					state = &quot;selector&quot;;
					styleRule = new CSSOM.CSSStyleRule();
					styleRule.__starts = i;
					break;
				case &quot;before-name&quot;:
					state = &quot;name&quot;;
					break;
				case &quot;before-value&quot;:
					state = &quot;value&quot;;
					break;
				case &quot;importRule-begin&quot;:
					state = &quot;importRule&quot;;
					break;
			}
			buffer += character;
			break;
		}
	}

	return styleSheet;
};



/**
 * Produces a deep copy of stylesheet — the instance variables of stylesheet are copied recursively.
 * @param {CSSStyleSheet|CSSOM.CSSStyleSheet} stylesheet
 * @nosideeffects
 * @return {CSSOM.CSSStyleSheet}
 */
CSSOM.clone = function clone(stylesheet) {

	var cloned = new CSSOM.CSSStyleSheet();

	var rules = stylesheet.cssRules;
	if (!rules) {
		return cloned;
	}

	for (var i = 0, rulesLength = rules.length; i &lt; rulesLength; i++) {
		var rule = rules[i];
		var ruleClone = cloned.cssRules[i] = new rule.constructor();

		var style = rule.style;
		if (style) {
			var styleClone = ruleClone.style = new CSSOM.CSSStyleDeclaration();
			for (var j = 0, styleLength = style.length; j &lt; styleLength; j++) {
				var name = styleClone[j] = style[j];
				styleClone[name] = style[name];
				styleClone._importants[name] = style.getPropertyPriority(name);
			}
			styleClone.length = style.length;
		}

		if (rule.hasOwnProperty(&#039;keyText&#039;)) {
			ruleClone.keyText = rule.keyText;
		}

		if (rule.hasOwnProperty(&#039;selectorText&#039;)) {
			ruleClone.selectorText = rule.selectorText;
		}

		if (rule.hasOwnProperty(&#039;mediaText&#039;)) {
			ruleClone.mediaText = rule.mediaText;
		}

		if (rule.hasOwnProperty(&#039;conditionText&#039;)) {
			ruleClone.conditionText = rule.conditionText;
		}

		if (rule.hasOwnProperty(&#039;layerName&#039;)) {
			ruleClone.layerName = rule.layerName;
		}

		if (rule.hasOwnProperty(&#039;cssRules&#039;)) {
			ruleClone.cssRules = clone(rule).cssRules;
		}
	}

	return cloned;

};


</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
