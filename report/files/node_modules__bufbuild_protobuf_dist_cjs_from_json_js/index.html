<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@bufbuild/protobuf/dist/cjs/from-json.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@bufbuild/protobuf/dist/cjs/from-json.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">623</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.99</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.fromJsonString = fromJsonString;
exports.mergeFromJsonString = mergeFromJsonString;
exports.fromJson = fromJson;
exports.mergeFromJson = mergeFromJson;
exports.enumFromJson = enumFromJson;
exports.isEnumJson = isEnumJson;
const descriptors_js_1 = require(&quot;./descriptors.js&quot;);
const proto_int64_js_1 = require(&quot;./proto-int64.js&quot;);
const create_js_1 = require(&quot;./create.js&quot;);
const reflect_js_1 = require(&quot;./reflect/reflect.js&quot;);
const error_js_1 = require(&quot;./reflect/error.js&quot;);
const reflect_check_js_1 = require(&quot;./reflect/reflect-check.js&quot;);
const scalar_js_1 = require(&quot;./reflect/scalar.js&quot;);
const base64_encoding_js_1 = require(&quot;./wire/base64-encoding.js&quot;);
const index_js_1 = require(&quot;./wkt/index.js&quot;);
const extensions_js_1 = require(&quot;./extensions.js&quot;);
// Default options for parsing JSON.
const jsonReadDefaults = {
    ignoreUnknownFields: false,
};
function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
/**
 * Parse a message from a JSON string.
 */
function fromJsonString(schema, json, options) {
    return fromJson(schema, parseJsonString(json, schema.typeName), options);
}
/**
 * Parse a message from a JSON string, merging fields.
 *
 * Repeated fields are appended. Map entries are added, overwriting
 * existing keys.
 *
 * If a message field is already present, it will be merged with the
 * new data.
 */
function mergeFromJsonString(schema, target, json, options) {
    return mergeFromJson(schema, target, parseJsonString(json, schema.typeName), options);
}
/**
 * Parse a message from a JSON value.
 */
function fromJson(schema, json, options) {
    const msg = (0, reflect_js_1.reflect)(schema);
    try {
        readMessage(msg, json, makeReadOptions(options));
    }
    catch (e) {
        if ((0, error_js_1.isFieldError)(e)) {
            // @ts-expect-error we use the ES2022 error CTOR option &quot;cause&quot; for better stack traces
            throw new Error(`cannot decode ${e.field()} from JSON: ${e.message}`, {
                cause: e,
            });
        }
        throw e;
    }
    return msg.message;
}
/**
 * Parse a message from a JSON value, merging fields.
 *
 * Repeated fields are appended. Map entries are added, overwriting
 * existing keys.
 *
 * If a message field is already present, it will be merged with the
 * new data.
 */
function mergeFromJson(schema, target, json, options) {
    try {
        readMessage((0, reflect_js_1.reflect)(schema, target), json, makeReadOptions(options));
    }
    catch (e) {
        if ((0, error_js_1.isFieldError)(e)) {
            // @ts-expect-error we use the ES2022 error CTOR option &quot;cause&quot; for better stack traces
            throw new Error(`cannot decode ${e.field()} from JSON: ${e.message}`, {
                cause: e,
            });
        }
        throw e;
    }
    return target;
}
/**
 * Parses an enum value from JSON.
 */
function enumFromJson(descEnum, json) {
    const val = readEnum(descEnum, json, false, false);
    if (val === tokenIgnoredUnknownEnum) {
        throw new Error(`cannot decode ${descEnum} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    return val;
}
/**
 * Is the given value a JSON enum value?
 */
function isEnumJson(descEnum, value) {
    return undefined !== descEnum.values.find((v) =&gt; v.name === value);
}
function readMessage(msg, json, opts) {
    var _a;
    if (tryWktFromJson(msg, json, opts)) {
        return;
    }
    if (json == null || Array.isArray(json) || typeof json != &quot;object&quot;) {
        throw new Error(`cannot decode ${msg.desc} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    const oneofSeen = new Map();
    const jsonNames = new Map();
    for (const field of msg.desc.fields) {
        jsonNames.set(field.name, field).set(field.jsonName, field);
    }
    for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field = jsonNames.get(jsonKey);
        if (field) {
            if (field.oneof) {
                if (jsonValue === null &amp;&amp; field.fieldKind == &quot;scalar&quot;) {
                    // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}
                    continue;
                }
                const seen = oneofSeen.get(field.oneof);
                if (seen !== undefined) {
                    throw new error_js_1.FieldError(field.oneof, `oneof set multiple times by ${seen.name} and ${field.name}`);
                }
                oneofSeen.set(field.oneof, field);
            }
            readField(msg, field, jsonValue, opts);
        }
        else {
            let extension = undefined;
            if (jsonKey.startsWith(&quot;[&quot;) &amp;&amp;
                jsonKey.endsWith(&quot;]&quot;) &amp;&amp;
                // biome-ignore lint/suspicious/noAssignInExpressions: no
                (extension = (_a = opts.registry) === null || _a === void 0 ? void 0 : _a.getExtension(jsonKey.substring(1, jsonKey.length - 1))) &amp;&amp;
                extension.extendee.typeName === msg.desc.typeName) {
                const [container, field, get] = (0, extensions_js_1.createExtensionContainer)(extension);
                readField(container, field, jsonValue, opts);
                (0, extensions_js_1.setExtension)(msg.message, extension, get());
            }
            if (!extension &amp;&amp; !opts.ignoreUnknownFields) {
                throw new Error(`cannot decode ${msg.desc} from JSON: key &quot;${jsonKey}&quot; is unknown`);
            }
        }
    }
}
function readField(msg, field, json, opts) {
    switch (field.fieldKind) {
        case &quot;scalar&quot;:
            readScalarField(msg, field, json);
            break;
        case &quot;enum&quot;:
            readEnumField(msg, field, json, opts);
            break;
        case &quot;message&quot;:
            readMessageField(msg, field, json, opts);
            break;
        case &quot;list&quot;:
            readListField(msg.get(field), json, opts);
            break;
        case &quot;map&quot;:
            readMapField(msg.get(field), json, opts);
            break;
    }
}
function readMapField(map, json, opts) {
    if (json === null) {
        return;
    }
    const field = map.field();
    if (typeof json != &quot;object&quot; || Array.isArray(json)) {
        throw new error_js_1.FieldError(field, &quot;expected object, got &quot; + (0, reflect_check_js_1.formatVal)(json));
    }
    for (const [jsonMapKey, jsonMapValue] of Object.entries(json)) {
        if (jsonMapValue === null) {
            throw new error_js_1.FieldError(field, &quot;map value must not be null&quot;);
        }
        let value;
        switch (field.mapKind) {
            case &quot;message&quot;:
                const msgValue = (0, reflect_js_1.reflect)(field.message);
                readMessage(msgValue, jsonMapValue, opts);
                value = msgValue;
                break;
            case &quot;enum&quot;:
                value = readEnum(field.enum, jsonMapValue, opts.ignoreUnknownFields, true);
                if (value === tokenIgnoredUnknownEnum) {
                    return;
                }
                break;
            case &quot;scalar&quot;:
                value = scalarFromJson(field, jsonMapValue, true);
                break;
        }
        const key = mapKeyFromJson(field.mapKey, jsonMapKey);
        map.set(key, value);
    }
}
function readListField(list, json, opts) {
    if (json === null) {
        return;
    }
    const field = list.field();
    if (!Array.isArray(json)) {
        throw new error_js_1.FieldError(field, &quot;expected Array, got &quot; + (0, reflect_check_js_1.formatVal)(json));
    }
    for (const jsonItem of json) {
        if (jsonItem === null) {
            throw new error_js_1.FieldError(field, &quot;list item must not be null&quot;);
        }
        switch (field.listKind) {
            case &quot;message&quot;:
                const msgValue = (0, reflect_js_1.reflect)(field.message);
                readMessage(msgValue, jsonItem, opts);
                list.add(msgValue);
                break;
            case &quot;enum&quot;:
                const enumValue = readEnum(field.enum, jsonItem, opts.ignoreUnknownFields, true);
                if (enumValue !== tokenIgnoredUnknownEnum) {
                    list.add(enumValue);
                }
                break;
            case &quot;scalar&quot;:
                list.add(scalarFromJson(field, jsonItem, true));
                break;
        }
    }
}
function readMessageField(msg, field, json, opts) {
    if (json === null &amp;&amp; field.message.typeName != &quot;google.protobuf.Value&quot;) {
        msg.clear(field);
        return;
    }
    const msgValue = msg.isSet(field) ? msg.get(field) : (0, reflect_js_1.reflect)(field.message);
    readMessage(msgValue, json, opts);
    msg.set(field, msgValue);
}
function readEnumField(msg, field, json, opts) {
    const enumValue = readEnum(field.enum, json, opts.ignoreUnknownFields, false);
    if (enumValue === tokenNull) {
        msg.clear(field);
    }
    else if (enumValue !== tokenIgnoredUnknownEnum) {
        msg.set(field, enumValue);
    }
}
function readScalarField(msg, field, json) {
    const scalarValue = scalarFromJson(field, json, false);
    if (scalarValue === tokenNull) {
        msg.clear(field);
    }
    else {
        msg.set(field, scalarValue);
    }
}
const tokenIgnoredUnknownEnum = Symbol();
function readEnum(desc, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
        if (desc.typeName == &quot;google.protobuf.NullValue&quot;) {
            return 0; // google.protobuf.NullValue.NULL_VALUE = 0
        }
        return nullAsZeroValue ? desc.values[0].number : tokenNull;
    }
    switch (typeof json) {
        case &quot;number&quot;:
            if (Number.isInteger(json)) {
                return json;
            }
            break;
        case &quot;string&quot;:
            const value = desc.values.find((ev) =&gt; ev.name === json);
            if (value !== undefined) {
                return value.number;
            }
            if (ignoreUnknownFields) {
                return tokenIgnoredUnknownEnum;
            }
            break;
    }
    throw new Error(`cannot decode ${desc} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
}
const tokenNull = Symbol();
function scalarFromJson(field, json, nullAsZeroValue) {
    if (json === null) {
        if (nullAsZeroValue) {
            return (0, scalar_js_1.scalarZeroValue)(field.scalar, false);
        }
        return tokenNull;
    }
    // int64, sfixed64, sint64, fixed64, uint64: Reflect supports string and number.
    // string, bool: Supported by reflect.
    switch (field.scalar) {
        // float, double: JSON value will be a number or one of the special string values &quot;NaN&quot;, &quot;Infinity&quot;, and &quot;-Infinity&quot;.
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
            if (json === &quot;NaN&quot;)
                return NaN;
            if (json === &quot;Infinity&quot;)
                return Number.POSITIVE_INFINITY;
            if (json === &quot;-Infinity&quot;)
                return Number.NEGATIVE_INFINITY;
            if (typeof json == &quot;number&quot;) {
                if (Number.isNaN(json)) {
                    // NaN must be encoded with string constants
                    throw new error_js_1.FieldError(field, &quot;unexpected NaN number&quot;);
                }
                if (!Number.isFinite(json)) {
                    // Infinity must be encoded with string constants
                    throw new error_js_1.FieldError(field, &quot;unexpected infinite number&quot;);
                }
                break;
            }
            if (typeof json == &quot;string&quot;) {
                if (json === &quot;&quot;) {
                    // empty string is not a number
                    break;
                }
                if (json.trim().length !== json.length) {
                    // extra whitespace
                    break;
                }
                const float = Number(json);
                if (!Number.isFinite(float)) {
                    // Infinity and NaN must be encoded with string constants
                    break;
                }
                return float;
            }
            break;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
        case descriptors_js_1.ScalarType.UINT32:
            return int32FromJson(json);
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case descriptors_js_1.ScalarType.BYTES:
            if (typeof json == &quot;string&quot;) {
                if (json === &quot;&quot;) {
                    return new Uint8Array(0);
                }
                try {
                    return (0, base64_encoding_js_1.base64Decode)(json);
                }
                catch (e) {
                    const message = e instanceof Error ? e.message : String(e);
                    throw new error_js_1.FieldError(field, message);
                }
            }
            break;
    }
    return json;
}
/**
 * Try to parse a JSON value to a map key for the reflect API.
 *
 * Returns the input if the JSON value cannot be converted.
 */
function mapKeyFromJson(type, json) {
    switch (type) {
        case descriptors_js_1.ScalarType.BOOL:
            switch (json) {
                case &quot;true&quot;:
                    return true;
                case &quot;false&quot;:
                    return false;
            }
            return json;
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
            return int32FromJson(json);
        default:
            return json;
    }
}
/**
 * Try to parse a JSON value to a 32-bit integer for the reflect API.
 *
 * Returns the input if the JSON value cannot be converted.
 */
function int32FromJson(json) {
    if (typeof json == &quot;string&quot;) {
        if (json === &quot;&quot;) {
            // empty string is not a number
            return json;
        }
        if (json.trim().length !== json.length) {
            // extra whitespace
            return json;
        }
        const num = Number(json);
        if (Number.isNaN(num)) {
            // not a number
            return json;
        }
        return num;
    }
    return json;
}
function parseJsonString(jsonString, typeName) {
    try {
        return JSON.parse(jsonString);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        throw new Error(`cannot decode message ${typeName} from JSON: ${message}`, 
        // @ts-expect-error we use the ES2022 error CTOR option &quot;cause&quot; for better stack traces
        { cause: e });
    }
}
function tryWktFromJson(msg, jsonValue, opts) {
    if (!msg.desc.typeName.startsWith(&quot;google.protobuf.&quot;)) {
        return false;
    }
    switch (msg.desc.typeName) {
        case &quot;google.protobuf.Any&quot;:
            anyFromJson(msg.message, jsonValue, opts);
            return true;
        case &quot;google.protobuf.Timestamp&quot;:
            timestampFromJson(msg.message, jsonValue);
            return true;
        case &quot;google.protobuf.Duration&quot;:
            durationFromJson(msg.message, jsonValue);
            return true;
        case &quot;google.protobuf.FieldMask&quot;:
            fieldMaskFromJson(msg.message, jsonValue);
            return true;
        case &quot;google.protobuf.Struct&quot;:
            structFromJson(msg.message, jsonValue);
            return true;
        case &quot;google.protobuf.Value&quot;:
            valueFromJson(msg.message, jsonValue);
            return true;
        case &quot;google.protobuf.ListValue&quot;:
            listValueFromJson(msg.message, jsonValue);
            return true;
        default:
            if ((0, index_js_1.isWrapperDesc)(msg.desc)) {
                const valueField = msg.desc.fields[0];
                if (jsonValue === null) {
                    msg.clear(valueField);
                }
                else {
                    msg.set(valueField, scalarFromJson(valueField, jsonValue, true));
                }
                return true;
            }
            return false;
    }
}
function anyFromJson(any, json, opts) {
    var _a;
    if (json === null || Array.isArray(json) || typeof json != &quot;object&quot;) {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: expected object but got ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    if (Object.keys(json).length == 0) {
        return;
    }
    const typeUrl = json[&quot;@type&quot;];
    if (typeof typeUrl != &quot;string&quot; || typeUrl == &quot;&quot;) {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: &quot;@type&quot; is empty`);
    }
    const typeName = typeUrl.includes(&quot;/&quot;)
        ? typeUrl.substring(typeUrl.lastIndexOf(&quot;/&quot;) + 1)
        : typeUrl;
    if (!typeName.length) {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: &quot;@type&quot; is invalid`);
    }
    const desc = (_a = opts.registry) === null || _a === void 0 ? void 0 : _a.getMessage(typeName);
    if (!desc) {
        throw new Error(`cannot decode message ${any.$typeName} from JSON: ${typeUrl} is not in the type registry`);
    }
    const msg = (0, reflect_js_1.reflect)(desc);
    if (typeName.startsWith(&quot;google.protobuf.&quot;) &amp;&amp;
        Object.prototype.hasOwnProperty.call(json, &quot;value&quot;)) {
        const value = json.value;
        readMessage(msg, value, opts);
    }
    else {
        const copy = Object.assign({}, json);
        // biome-ignore lint/performance/noDelete: &lt;explanation&gt;
        delete copy[&quot;@type&quot;];
        readMessage(msg, copy, opts);
    }
    (0, index_js_1.anyPack)(msg.desc, msg.message, any);
}
function timestampFromJson(timestamp, json) {
    if (typeof json !== &quot;string&quot;) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: invalid RFC 3339 string`);
    }
    const ms = Date.parse(
    // biome-ignore format: want this to read well
    matches[1] + &quot;-&quot; + matches[2] + &quot;-&quot; + matches[3] + &quot;T&quot; + matches[4] + &quot;:&quot; + matches[5] + &quot;:&quot; + matches[6] + (matches[8] ? matches[8] : &quot;Z&quot;));
    if (Number.isNaN(ms)) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: invalid RFC 3339 string`);
    }
    if (ms &lt; Date.parse(&quot;0001-01-01T00:00:00Z&quot;) ||
        ms &gt; Date.parse(&quot;9999-12-31T23:59:59Z&quot;)) {
        throw new Error(`cannot decode message ${timestamp.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    timestamp.seconds = proto_int64_js_1.protoInt64.parse(ms / 1000);
    timestamp.nanos = 0;
    if (matches[7]) {
        timestamp.nanos =
            parseInt(&quot;1&quot; + matches[7] + &quot;0&quot;.repeat(9 - matches[7].length)) -
                1000000000;
    }
}
function durationFromJson(duration, json) {
    if (typeof json !== &quot;string&quot;) {
        throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
    if (match === null) {
        throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    const longSeconds = Number(match[1]);
    if (longSeconds &gt; 315576000000 || longSeconds &lt; -315576000000) {
        throw new Error(`cannot decode message ${duration.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    duration.seconds = proto_int64_js_1.protoInt64.parse(longSeconds);
    if (typeof match[2] !== &quot;string&quot;) {
        return;
    }
    const nanosStr = match[2] + &quot;0&quot;.repeat(9 - match[2].length);
    duration.nanos = parseInt(nanosStr);
    if (longSeconds &lt; 0 || Object.is(longSeconds, -0)) {
        duration.nanos = -duration.nanos;
    }
}
function fieldMaskFromJson(fieldMask, json) {
    if (typeof json !== &quot;string&quot;) {
        throw new Error(`cannot decode message ${fieldMask.$typeName} from JSON: ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    if (json === &quot;&quot;) {
        return;
    }
    function camelToSnake(str) {
        if (str.includes(&quot;_&quot;)) {
            throw new Error(`cannot decode message ${fieldMask.$typeName} from JSON: path names must be lowerCamelCase`);
        }
        const sc = str.replace(/[A-Z]/g, (letter) =&gt; &quot;_&quot; + letter.toLowerCase());
        return sc[0] === &quot;_&quot; ? sc.substring(1) : sc;
    }
    fieldMask.paths = json.split(&quot;,&quot;).map(camelToSnake);
}
function structFromJson(struct, json) {
    if (typeof json != &quot;object&quot; || json == null || Array.isArray(json)) {
        throw new Error(`cannot decode message ${struct.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    for (const [k, v] of Object.entries(json)) {
        const parsedV = (0, create_js_1.create)(index_js_1.ValueSchema);
        valueFromJson(parsedV, v);
        struct.fields[k] = parsedV;
    }
}
function valueFromJson(value, json) {
    switch (typeof json) {
        case &quot;number&quot;:
            value.kind = { case: &quot;numberValue&quot;, value: json };
            break;
        case &quot;string&quot;:
            value.kind = { case: &quot;stringValue&quot;, value: json };
            break;
        case &quot;boolean&quot;:
            value.kind = { case: &quot;boolValue&quot;, value: json };
            break;
        case &quot;object&quot;:
            if (json === null) {
                value.kind = { case: &quot;nullValue&quot;, value: index_js_1.NullValue.NULL_VALUE };
            }
            else if (Array.isArray(json)) {
                const listValue = (0, create_js_1.create)(index_js_1.ListValueSchema);
                listValueFromJson(listValue, json);
                value.kind = { case: &quot;listValue&quot;, value: listValue };
            }
            else {
                const struct = (0, create_js_1.create)(index_js_1.StructSchema);
                structFromJson(struct, json);
                value.kind = { case: &quot;structValue&quot;, value: struct };
            }
            break;
        default:
            throw new Error(`cannot decode message ${value.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    return value;
}
function listValueFromJson(listValue, json) {
    if (!Array.isArray(json)) {
        throw new Error(`cannot decode message ${listValue.$typeName} from JSON ${(0, reflect_check_js_1.formatVal)(json)}`);
    }
    for (const e of json) {
        const value = (0, create_js_1.create)(index_js_1.ValueSchema);
        valueFromJson(value, e);
        listValue.values.push(value);
    }
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
