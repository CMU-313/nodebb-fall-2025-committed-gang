<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ioredis/built/Redis.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ioredis/built/Redis.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">698</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">87.73</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.85</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const commands_1 = require(&quot;@ioredis/commands&quot;);
const events_1 = require(&quot;events&quot;);
const standard_as_callback_1 = require(&quot;standard-as-callback&quot;);
const cluster_1 = require(&quot;./cluster&quot;);
const Command_1 = require(&quot;./Command&quot;);
const connectors_1 = require(&quot;./connectors&quot;);
const SentinelConnector_1 = require(&quot;./connectors/SentinelConnector&quot;);
const eventHandler = require(&quot;./redis/event_handler&quot;);
const RedisOptions_1 = require(&quot;./redis/RedisOptions&quot;);
const ScanStream_1 = require(&quot;./ScanStream&quot;);
const transaction_1 = require(&quot;./transaction&quot;);
const utils_1 = require(&quot;./utils&quot;);
const applyMixin_1 = require(&quot;./utils/applyMixin&quot;);
const Commander_1 = require(&quot;./utils/Commander&quot;);
const lodash_1 = require(&quot;./utils/lodash&quot;);
const Deque = require(&quot;denque&quot;);
const debug = (0, utils_1.Debug)(&quot;redis&quot;);
/**
 * This is the major component of ioredis.
 * Use it to connect to a standalone Redis server or Sentinels.
 *
 * ```typescript
 * const redis = new Redis(); // Default port is 6379
 * async function main() {
 *   redis.set(&quot;foo&quot;, &quot;bar&quot;);
 *   redis.get(&quot;foo&quot;, (err, result) =&gt; {
 *     // `result` should be &quot;bar&quot;
 *     console.log(err, result);
 *   });
 *   // Or use Promise
 *   const result = await redis.get(&quot;foo&quot;);
 * }
 * ```
 */
class Redis extends Commander_1.default {
    constructor(arg1, arg2, arg3) {
        super();
        this.status = &quot;wait&quot;;
        /**
         * @ignore
         */
        this.isCluster = false;
        this.reconnectTimeout = null;
        this.connectionEpoch = 0;
        this.retryAttempts = 0;
        this.manuallyClosing = false;
        // Prepare autopipelines structures
        this._autoPipelines = new Map();
        this._runningAutoPipelines = new Set();
        this.parseOptions(arg1, arg2, arg3);
        events_1.EventEmitter.call(this);
        this.resetCommandQueue();
        this.resetOfflineQueue();
        if (this.options.Connector) {
            this.connector = new this.options.Connector(this.options);
        }
        else if (this.options.sentinels) {
            const sentinelConnector = new SentinelConnector_1.default(this.options);
            sentinelConnector.emitter = this;
            this.connector = sentinelConnector;
        }
        else {
            this.connector = new connectors_1.StandaloneConnector(this.options);
        }
        if (this.options.scripts) {
            Object.entries(this.options.scripts).forEach(([name, definition]) =&gt; {
                this.defineCommand(name, definition);
            });
        }
        // end(or wait) -&gt; connecting -&gt; connect -&gt; ready -&gt; end
        if (this.options.lazyConnect) {
            this.setStatus(&quot;wait&quot;);
        }
        else {
            this.connect().catch(lodash_1.noop);
        }
    }
    /**
     * Create a Redis instance.
     * This is the same as `new Redis()` but is included for compatibility with node-redis.
     */
    static createClient(...args) {
        return new Redis(...args);
    }
    get autoPipelineQueueSize() {
        let queued = 0;
        for (const pipeline of this._autoPipelines.values()) {
            queued += pipeline.length;
        }
        return queued;
    }
    /**
     * Create a connection to Redis.
     * This method will be invoked automatically when creating a new Redis instance
     * unless `lazyConnect: true` is passed.
     *
     * When calling this method manually, a Promise is returned, which will
     * be resolved when the connection status is ready.
     */
    connect(callback) {
        const promise = new Promise((resolve, reject) =&gt; {
            if (this.status === &quot;connecting&quot; ||
                this.status === &quot;connect&quot; ||
                this.status === &quot;ready&quot;) {
                reject(new Error(&quot;Redis is already connecting/connected&quot;));
                return;
            }
            this.connectionEpoch += 1;
            this.setStatus(&quot;connecting&quot;);
            const { options } = this;
            this.condition = {
                select: options.db,
                auth: options.username
                    ? [options.username, options.password]
                    : options.password,
                subscriber: false,
            };
            const _this = this;
            (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {
                _this.silentEmit(type, err);
            }), function (err, stream) {
                if (err) {
                    _this.flushQueue(err);
                    _this.silentEmit(&quot;error&quot;, err);
                    reject(err);
                    _this.setStatus(&quot;end&quot;);
                    return;
                }
                let CONNECT_EVENT = options.tls ? &quot;secureConnect&quot; : &quot;connect&quot;;
                if (&quot;sentinels&quot; in options &amp;&amp;
                    options.sentinels &amp;&amp;
                    !options.enableTLSForSentinelMode) {
                    CONNECT_EVENT = &quot;connect&quot;;
                }
                _this.stream = stream;
                if (options.noDelay) {
                    stream.setNoDelay(true);
                }
                // Node ignores setKeepAlive before connect, therefore we wait for the event:
                // https://github.com/nodejs/node/issues/31663
                if (typeof options.keepAlive === &quot;number&quot;) {
                    if (stream.connecting) {
                        stream.once(CONNECT_EVENT, () =&gt; {
                            stream.setKeepAlive(true, options.keepAlive);
                        });
                    }
                    else {
                        stream.setKeepAlive(true, options.keepAlive);
                    }
                }
                if (stream.connecting) {
                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
                    if (options.connectTimeout) {
                        /*
                         * Typically, Socket#setTimeout(0) will clear the timer
                         * set before. However, in some platforms (Electron 3.x~4.x),
                         * the timer will not be cleared. So we introduce a variable here.
                         *
                         * See https://github.com/electron/electron/issues/14915
                         */
                        let connectTimeoutCleared = false;
                        stream.setTimeout(options.connectTimeout, function () {
                            if (connectTimeoutCleared) {
                                return;
                            }
                            stream.setTimeout(0);
                            stream.destroy();
                            const err = new Error(&quot;connect ETIMEDOUT&quot;);
                            // @ts-expect-error
                            err.errorno = &quot;ETIMEDOUT&quot;;
                            // @ts-expect-error
                            err.code = &quot;ETIMEDOUT&quot;;
                            // @ts-expect-error
                            err.syscall = &quot;connect&quot;;
                            eventHandler.errorHandler(_this)(err);
                        });
                        stream.once(CONNECT_EVENT, function () {
                            connectTimeoutCleared = true;
                            stream.setTimeout(0);
                        });
                    }
                }
                else if (stream.destroyed) {
                    const firstError = _this.connector.firstError;
                    if (firstError) {
                        process.nextTick(() =&gt; {
                            eventHandler.errorHandler(_this)(firstError);
                        });
                    }
                    process.nextTick(eventHandler.closeHandler(_this));
                }
                else {
                    process.nextTick(eventHandler.connectHandler(_this));
                }
                if (!stream.destroyed) {
                    stream.once(&quot;error&quot;, eventHandler.errorHandler(_this));
                    stream.once(&quot;close&quot;, eventHandler.closeHandler(_this));
                }
                const connectionReadyHandler = function () {
                    _this.removeListener(&quot;close&quot;, connectionCloseHandler);
                    resolve();
                };
                var connectionCloseHandler = function () {
                    _this.removeListener(&quot;ready&quot;, connectionReadyHandler);
                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
                };
                _this.once(&quot;ready&quot;, connectionReadyHandler);
                _this.once(&quot;close&quot;, connectionCloseHandler);
            });
        });
        return (0, standard_as_callback_1.default)(promise, callback);
    }
    /**
     * Disconnect from Redis.
     *
     * This method closes the connection immediately,
     * and may lose some pending replies that haven&#039;t written to client.
     * If you want to wait for the pending replies, use Redis#quit instead.
     */
    disconnect(reconnect = false) {
        if (!reconnect) {
            this.manuallyClosing = true;
        }
        if (this.reconnectTimeout &amp;&amp; !reconnect) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
        if (this.status === &quot;wait&quot;) {
            eventHandler.closeHandler(this)();
        }
        else {
            this.connector.disconnect();
        }
    }
    /**
     * Disconnect from Redis.
     *
     * @deprecated
     */
    end() {
        this.disconnect();
    }
    /**
     * Create a new instance with the same options as the current one.
     *
     * @example
     * ```js
     * var redis = new Redis(6380);
     * var anotherRedis = redis.duplicate();
     * ```
     */
    duplicate(override) {
        return new Redis({ ...this.options, ...override });
    }
    /**
     * Mode of the connection.
     *
     * One of `&quot;normal&quot;`, `&quot;subscriber&quot;`, or `&quot;monitor&quot;`. When the connection is
     * not in `&quot;normal&quot;` mode, certain commands are not allowed.
     */
    get mode() {
        var _a;
        return this.options.monitor
            ? &quot;monitor&quot;
            : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber)
                ? &quot;subscriber&quot;
                : &quot;normal&quot;;
    }
    /**
     * Listen for all requests received by the server in real time.
     *
     * This command will create a new connection to Redis and send a
     * MONITOR command via the new connection in order to avoid disturbing
     * the current connection.
     *
     * @param callback The callback function. If omit, a promise will be returned.
     * @example
     * ```js
     * var redis = new Redis();
     * redis.monitor(function (err, monitor) {
     *   // Entering monitoring mode.
     *   monitor.on(&#039;monitor&#039;, function (time, args, source, database) {
     *     console.log(time + &quot;: &quot; + util.inspect(args));
     *   });
     * });
     *
     * // supports promise as well as other commands
     * redis.monitor().then(function (monitor) {
     *   monitor.on(&#039;monitor&#039;, function (time, args, source, database) {
     *     console.log(time + &quot;: &quot; + util.inspect(args));
     *   });
     * });
     * ```
     */
    monitor(callback) {
        const monitorInstance = this.duplicate({
            monitor: true,
            lazyConnect: false,
        });
        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {
            monitorInstance.once(&quot;error&quot;, reject);
            monitorInstance.once(&quot;monitoring&quot;, function () {
                resolve(monitorInstance);
            });
        }), callback);
    }
    /**
     * Send a command to Redis
     *
     * This method is used internally and in most cases you should not
     * use it directly. If you need to send a command that is not supported
     * by the library, you can use the `call` method:
     *
     * ```js
     * const redis = new Redis();
     *
     * redis.call(&#039;set&#039;, &#039;foo&#039;, &#039;bar&#039;);
     * // or
     * redis.call([&#039;set&#039;, &#039;foo&#039;, &#039;bar&#039;]);
     * ```
     *
     * @ignore
     */
    sendCommand(command, stream) {
        var _a, _b;
        if (this.status === &quot;wait&quot;) {
            this.connect().catch(lodash_1.noop);
        }
        if (this.status === &quot;end&quot;) {
            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            return command.promise;
        }
        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) &amp;&amp;
            !Command_1.default.checkFlag(&quot;VALID_IN_SUBSCRIBER_MODE&quot;, command.name)) {
            command.reject(new Error(&quot;Connection in subscriber mode, only subscriber commands may be used&quot;));
            return command.promise;
        }
        if (typeof this.options.commandTimeout === &quot;number&quot;) {
            command.setTimeout(this.options.commandTimeout);
        }
        let writable = this.status === &quot;ready&quot; ||
            (!stream &amp;&amp;
                this.status === &quot;connect&quot; &amp;&amp;
                (0, commands_1.exists)(command.name) &amp;&amp;
                (0, commands_1.hasFlag)(command.name, &quot;loading&quot;));
        if (!this.stream) {
            writable = false;
        }
        else if (!this.stream.writable) {
            writable = false;
            // @ts-expect-error
        }
        else if (this.stream._writableState &amp;&amp; this.stream._writableState.ended) {
            // TODO: We should be able to remove this as the PR has already been merged.
            // https://github.com/iojs/io.js/pull/1217
            writable = false;
        }
        if (!writable) {
            if (!this.options.enableOfflineQueue) {
                command.reject(new Error(&quot;Stream isn&#039;t writeable and enableOfflineQueue options is false&quot;));
                return command.promise;
            }
            if (command.name === &quot;quit&quot; &amp;&amp; this.offlineQueue.length === 0) {
                this.disconnect();
                command.resolve(Buffer.from(&quot;OK&quot;));
                return command.promise;
            }
            // @ts-expect-error
            if (debug.enabled) {
                debug(&quot;queue command[%s]: %d -&gt; %s(%o)&quot;, this._getDescription(), this.condition.select, command.name, command.args);
            }
            this.offlineQueue.push({
                command: command,
                stream: stream,
                select: this.condition.select,
            });
        }
        else {
            // @ts-expect-error
            if (debug.enabled) {
                debug(&quot;write command[%s]: %d -&gt; %s(%o)&quot;, this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);
            }
            if (stream) {
                if (&quot;isPipeline&quot; in stream &amp;&amp; stream.isPipeline) {
                    stream.write(command.toWritable(stream.destination.redis.stream));
                }
                else {
                    stream.write(command.toWritable(stream));
                }
            }
            else {
                this.stream.write(command.toWritable(this.stream));
            }
            this.commandQueue.push({
                command: command,
                stream: stream,
                select: this.condition.select,
            });
            if (Command_1.default.checkFlag(&quot;WILL_DISCONNECT&quot;, command.name)) {
                this.manuallyClosing = true;
            }
            if (this.options.socketTimeout !== undefined &amp;&amp; this.socketTimeoutTimer === undefined) {
                this.setSocketTimeout();
            }
        }
        if (command.name === &quot;select&quot; &amp;&amp; (0, utils_1.isInt)(command.args[0])) {
            const db = parseInt(command.args[0], 10);
            if (this.condition.select !== db) {
                this.condition.select = db;
                this.emit(&quot;select&quot;, db);
                debug(&quot;switch to db [%d]&quot;, this.condition.select);
            }
        }
        return command.promise;
    }
    setSocketTimeout() {
        this.socketTimeoutTimer = setTimeout(() =&gt; {
            this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn&#039;t receive any in ${this.options.socketTimeout}ms.`));
            this.socketTimeoutTimer = undefined;
        }, this.options.socketTimeout);
        // this handler must run after the &quot;data&quot; handler in &quot;DataHandler&quot;
        // so that `this.commandQueue.length` will be updated
        this.stream.once(&quot;data&quot;, () =&gt; {
            clearTimeout(this.socketTimeoutTimer);
            this.socketTimeoutTimer = undefined;
            if (this.commandQueue.length === 0)
                return;
            this.setSocketTimeout();
        });
    }
    scanStream(options) {
        return this.createScanStream(&quot;scan&quot;, { options });
    }
    scanBufferStream(options) {
        return this.createScanStream(&quot;scanBuffer&quot;, { options });
    }
    sscanStream(key, options) {
        return this.createScanStream(&quot;sscan&quot;, { key, options });
    }
    sscanBufferStream(key, options) {
        return this.createScanStream(&quot;sscanBuffer&quot;, { key, options });
    }
    hscanStream(key, options) {
        return this.createScanStream(&quot;hscan&quot;, { key, options });
    }
    hscanBufferStream(key, options) {
        return this.createScanStream(&quot;hscanBuffer&quot;, { key, options });
    }
    zscanStream(key, options) {
        return this.createScanStream(&quot;zscan&quot;, { key, options });
    }
    zscanBufferStream(key, options) {
        return this.createScanStream(&quot;zscanBuffer&quot;, { key, options });
    }
    /**
     * Emit only when there&#039;s at least one listener.
     *
     * @ignore
     */
    silentEmit(eventName, arg) {
        let error;
        if (eventName === &quot;error&quot;) {
            error = arg;
            if (this.status === &quot;end&quot;) {
                return;
            }
            if (this.manuallyClosing) {
                // ignore connection related errors when manually disconnecting
                if (error instanceof Error &amp;&amp;
                    (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||
                        // @ts-expect-error
                        error.syscall === &quot;connect&quot; ||
                        // @ts-expect-error
                        error.syscall === &quot;read&quot;)) {
                    return;
                }
            }
        }
        if (this.listeners(eventName).length &gt; 0) {
            return this.emit.apply(this, arguments);
        }
        if (error &amp;&amp; error instanceof Error) {
            console.error(&quot;[ioredis] Unhandled error event:&quot;, error.stack);
        }
        return false;
    }
    /**
     * @ignore
     */
    recoverFromFatalError(_commandError, err, options) {
        this.flushQueue(err, options);
        this.silentEmit(&quot;error&quot;, err);
        this.disconnect(true);
    }
    /**
     * @ignore
     */
    handleReconnection(err, item) {
        var _a;
        let needReconnect = false;
        if (this.options.reconnectOnError) {
            needReconnect = this.options.reconnectOnError(err);
        }
        switch (needReconnect) {
            case 1:
            case true:
                if (this.status !== &quot;reconnecting&quot;) {
                    this.disconnect(true);
                }
                item.command.reject(err);
                break;
            case 2:
                if (this.status !== &quot;reconnecting&quot;) {
                    this.disconnect(true);
                }
                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select &amp;&amp;
                    item.command.name !== &quot;select&quot;) {
                    this.select(item.select);
                }
                // TODO
                // @ts-expect-error
                this.sendCommand(item.command);
                break;
            default:
                item.command.reject(err);
        }
    }
    /**
     * Get description of the connection. Used for debugging.
     */
    _getDescription() {
        let description;
        if (&quot;path&quot; in this.options &amp;&amp; this.options.path) {
            description = this.options.path;
        }
        else if (this.stream &amp;&amp;
            this.stream.remoteAddress &amp;&amp;
            this.stream.remotePort) {
            description = this.stream.remoteAddress + &quot;:&quot; + this.stream.remotePort;
        }
        else if (&quot;host&quot; in this.options &amp;&amp; this.options.host) {
            description = this.options.host + &quot;:&quot; + this.options.port;
        }
        else {
            // Unexpected
            description = &quot;&quot;;
        }
        if (this.options.connectionName) {
            description += ` (${this.options.connectionName})`;
        }
        return description;
    }
    resetCommandQueue() {
        this.commandQueue = new Deque();
    }
    resetOfflineQueue() {
        this.offlineQueue = new Deque();
    }
    parseOptions(...args) {
        const options = {};
        let isTls = false;
        for (let i = 0; i &lt; args.length; ++i) {
            const arg = args[i];
            if (arg === null || typeof arg === &quot;undefined&quot;) {
                continue;
            }
            if (typeof arg === &quot;object&quot;) {
                (0, lodash_1.defaults)(options, arg);
            }
            else if (typeof arg === &quot;string&quot;) {
                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));
                if (arg.startsWith(&quot;rediss://&quot;)) {
                    isTls = true;
                }
            }
            else if (typeof arg === &quot;number&quot;) {
                options.port = arg;
            }
            else {
                throw new Error(&quot;Invalid argument &quot; + arg);
            }
        }
        if (isTls) {
            (0, lodash_1.defaults)(options, { tls: true });
        }
        (0, lodash_1.defaults)(options, Redis.defaultOptions);
        if (typeof options.port === &quot;string&quot;) {
            options.port = parseInt(options.port, 10);
        }
        if (typeof options.db === &quot;string&quot;) {
            options.db = parseInt(options.db, 10);
        }
        // @ts-expect-error
        this.options = (0, utils_1.resolveTLSProfile)(options);
    }
    /**
     * Change instance&#039;s status
     */
    setStatus(status, arg) {
        // @ts-expect-error
        if (debug.enabled) {
            debug(&quot;status[%s]: %s -&gt; %s&quot;, this._getDescription(), this.status || &quot;[empty]&quot;, status);
        }
        this.status = status;
        process.nextTick(this.emit.bind(this, status, arg));
    }
    createScanStream(command, { key, options = {} }) {
        return new ScanStream_1.default({
            objectMode: true,
            key: key,
            redis: this,
            command: command,
            ...options,
        });
    }
    /**
     * Flush offline queue and command queue with error.
     *
     * @param error The error object to send to the commands
     * @param options options
     */
    flushQueue(error, options) {
        options = (0, lodash_1.defaults)({}, options, {
            offlineQueue: true,
            commandQueue: true,
        });
        let item;
        if (options.offlineQueue) {
            while ((item = this.offlineQueue.shift())) {
                item.command.reject(error);
            }
        }
        if (options.commandQueue) {
            if (this.commandQueue.length &gt; 0) {
                if (this.stream) {
                    this.stream.removeAllListeners(&quot;data&quot;);
                }
                while ((item = this.commandQueue.shift())) {
                    item.command.reject(error);
                }
            }
        }
    }
    /**
     * Check whether Redis has finished loading the persistent data and is able to
     * process commands.
     */
    _readyCheck(callback) {
        const _this = this;
        this.info(function (err, res) {
            if (err) {
                if (err.message &amp;&amp; err.message.includes(&quot;NOPERM&quot;)) {
                    console.warn(`Skipping the ready check because INFO command fails: &quot;${err.message}&quot;. You can disable ready check with &quot;enableReadyCheck&quot;. More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);
                    return callback(null, {});
                }
                return callback(err);
            }
            if (typeof res !== &quot;string&quot;) {
                return callback(null, res);
            }
            const info = {};
            const lines = res.split(&quot;\r\n&quot;);
            for (let i = 0; i &lt; lines.length; ++i) {
                const [fieldName, ...fieldValueParts] = lines[i].split(&quot;:&quot;);
                const fieldValue = fieldValueParts.join(&quot;:&quot;);
                if (fieldValue) {
                    info[fieldName] = fieldValue;
                }
            }
            if (!info.loading || info.loading === &quot;0&quot;) {
                callback(null, info);
            }
            else {
                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;
                const retryTime = _this.options.maxLoadingRetryTime &amp;&amp;
                    _this.options.maxLoadingRetryTime &lt; loadingEtaMs
                    ? _this.options.maxLoadingRetryTime
                    : loadingEtaMs;
                debug(&quot;Redis server still loading, trying again in &quot; + retryTime + &quot;ms&quot;);
                setTimeout(function () {
                    _this._readyCheck(callback);
                }, retryTime);
            }
        }).catch(lodash_1.noop);
    }
}
Redis.Cluster = cluster_1.default;
Redis.Command = Command_1.default;
/**
 * Default options
 */
Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
(0, applyMixin_1.default)(Redis, events_1.EventEmitter);
(0, transaction_1.addTransactionSupport)(Redis.prototype);
exports.default = Redis;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
