<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/messaging.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/messaging.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">834</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);

const nconf = require(&#039;nconf&#039;);
const util = require(&#039;util&#039;);

const sleep = util.promisify(setTimeout);

const db = require(&#039;./mocks/databasemock&#039;);
const meta = require(&#039;../src/meta&#039;);
const User = require(&#039;../src/user&#039;);
const Groups = require(&#039;../src/groups&#039;);
const Messaging = require(&#039;../src/messaging&#039;);
const api = require(&#039;../src/api&#039;);
const helpers = require(&#039;./helpers&#039;);
const request = require(&#039;../src/request&#039;);
const utils = require(&#039;../src/utils&#039;);
const translator = require(&#039;../src/translator&#039;);

describe(&#039;Messaging Library&#039;, () =&gt; {
	const mocks = {
		users: {
			foo: {}, // the admin
			bar: {},
			baz: {}, // the user with chat restriction enabled
			herp: {},
		},
	};
	let roomId;

	let chatMessageDelay;

	const callv3API = async (method, path, body, user) =&gt; {
		const options = {
			body,
			jar: mocks.users[user].jar,
		};

		if (method !== &#039;get&#039;) {
			options.headers = {
				&#039;x-csrf-token&#039;: mocks.users[user].csrf,
			};
		}

		return request[method](`${nconf.get(&#039;url&#039;)}/api/v3${path}`, options);
	};

	before(async () =&gt; {
		// Create 3 users: 1 admin, 2 regular
		({
			foo: mocks.users.foo.uid,
			bar: mocks.users.bar.uid,
			baz: mocks.users.baz.uid,
			herp: mocks.users.herp.uid,
		} = await utils.promiseParallel({
			foo: User.create({ username: &#039;foo&#039;, password: &#039;barbar&#039; }), // admin
			bar: User.create({ username: &#039;bar&#039;, password: &#039;bazbaz&#039; }), // admin
			baz: User.create({ username: &#039;baz&#039;, password: &#039;quuxquux&#039; }), // restricted user
			herp: User.create({ username: &#039;herp&#039;, password: &#039;derpderp&#039; }), // a regular user
		}));

		await Groups.join(&#039;administrators&#039;, mocks.users.foo.uid);
		await User.setSetting(mocks.users.baz.uid, &#039;disableIncomingChats&#039;, &#039;1&#039;);

		({ jar: mocks.users.foo.jar, csrf_token: mocks.users.foo.csrf } = await helpers.loginUser(&#039;foo&#039;, &#039;barbar&#039;));
		({ jar: mocks.users.bar.jar, csrf_token: mocks.users.bar.csrf } = await helpers.loginUser(&#039;bar&#039;, &#039;bazbaz&#039;));
		({ jar: mocks.users.baz.jar, csrf_token: mocks.users.baz.csrf } = await helpers.loginUser(&#039;baz&#039;, &#039;quuxquux&#039;));
		({ jar: mocks.users.herp.jar, csrf_token: mocks.users.herp.csrf } = await helpers.loginUser(&#039;herp&#039;, &#039;derpderp&#039;));

		chatMessageDelay = meta.config.chatMessageDelay;
		meta.config.chatMessageDelay = 0;
	});

	after(() =&gt; {
		meta.configs.chatMessageDelay = chatMessageDelay;
	});

	describe(&#039;.canMessageUser()&#039;, () =&gt; {
		it(&#039;should allow messages to be sent to an unrestricted user&#039;, (done) =&gt; {
			Messaging.canMessageUser(mocks.users.baz.uid, mocks.users.herp.uid, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should NOT allow messages to be sent to a restricted user&#039;, async () =&gt; {
			await User.setSetting(mocks.users.baz.uid, &#039;disableIncomingMessages&#039;, &#039;1&#039;);
			try {
				await Messaging.canMessageUser(mocks.users.herp.uid, mocks.users.baz.uid);
			} catch (err) {
				assert.strictEqual(err.message, &#039;[[error:chat-restricted]]&#039;);
			}
		});

		it(&#039;should always allow admins through&#039;, (done) =&gt; {
			Messaging.canMessageUser(mocks.users.foo.uid, mocks.users.baz.uid, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should respect allow/deny list when sending chat messages&#039;, async () =&gt; {
			const uid1 = await User.create({ username: &#039;allowdeny1&#039;, password: &#039;barbar&#039; });
			const uid2 = await User.create({ username: &#039;allowdeny2&#039;, password: &#039;bazbaz&#039; });
			const uid3 = await User.create({ username: &#039;allowdeny3&#039;, password: &#039;bazbaz&#039; });
			await Messaging.canMessageUser(uid1, uid2);

			// rejects uid1 only allows uid3 to chat
			await User.setSetting(uid1, &#039;chatAllowList&#039;, JSON.stringify([uid3]));
			await assert.rejects(
				Messaging.canMessageUser(uid2, uid1),
				{ message: &#039;[[error:chat-restricted]]&#039; },
			);

			// rejects uid2 denies chat from uid1
			await User.setSetting(uid2, &#039;chatDenyList&#039;, JSON.stringify([uid1]));
			await assert.rejects(
				Messaging.canMessageUser(uid1, uid2),
				{ message: &#039;[[error:chat-restricted]]&#039; },
			);
		});

		it(&#039;should not allow messaging room if user is muted&#039;, async () =&gt; {
			const twoMinutesFromNow = Date.now() + (2 * 60 * 1000);
			const twoHoursFromNow = Date.now() + (2 * 60 * 60 * 1000);
			const roomId = 0;

			await User.setUserField(mocks.users.herp.uid, &#039;mutedUntil&#039;, twoMinutesFromNow);
			await assert.rejects(Messaging.canMessageRoom(mocks.users.herp.uid, roomId), (err) =&gt; {
				assert(err.message.startsWith(&#039;[[error:user-muted-for-minutes,&#039;));
				return true;
			});

			await User.setUserField(mocks.users.herp.uid, &#039;mutedUntil&#039;, twoHoursFromNow);
			await assert.rejects(Messaging.canMessageRoom(mocks.users.herp.uid, roomId), (err) =&gt; {
				assert(err.message.startsWith(&#039;[[error:user-muted-for-hours,&#039;));
				return true;
			});
			await db.deleteObjectField(`user:${mocks.users.herp.uid}`, &#039;mutedUntil&#039;);
			await assert.rejects(Messaging.canMessageRoom(mocks.users.herp.uid, roomId), {
				message: &#039;[[error:no-room]]&#039;,
			});
		});
	});

	describe(&#039;rooms&#039;, () =&gt; {
		const _delay1 = meta.config.chatMessageDelay;
		const _delay2 = meta.config.newbieChatMessageDelay;
		before(async () =&gt; {
			meta.config.chatMessageDelay = 0;
			meta.config.newbieChatMessageDelay = 0;
		});

		after(async () =&gt; {
			meta.config.chatMessageDelay = _delay1;
			meta.config.newbieChatMessageDelay = _delay2;
		});

		it(&#039;should fail to create a new chat room with invalid data&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, {}, &#039;foo&#039;);
			assert.equal(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));
		});

		it(&#039;should return rate limit error on second try&#039;, async () =&gt; {
			const oldValue = meta.config.chatMessageDelay;
			meta.config.chatMessageDelay = 1000;

			await callv3API(&#039;post&#039;, &#039;/chats&#039;, {
				uids: [mocks.users.baz.uid],
			}, &#039;foo&#039;);

			const { response, body } = await callv3API(&#039;post&#039;, `/chats`, {
				uids: [mocks.users.baz.uid],
			}, &#039;foo&#039;);

			assert.equal(response.statusCode, 400);
			assert.equal(body.status.code, &#039;bad-request&#039;);
			assert.equal(body.status.message, await translator.translate(&#039;[[error:too-many-messages]]&#039;));
			meta.config.chatMessageDelay = oldValue;
		});

		it(&#039;should create a new chat room&#039;, async () =&gt; {
			await User.setSetting(mocks.users.baz.uid, &#039;disableIncomingMessages&#039;, &#039;0&#039;);
			const { body } = await callv3API(&#039;post&#039;, `/chats`, {
				uids: [mocks.users.baz.uid],
			}, &#039;foo&#039;);
			await User.setSetting(mocks.users.baz.uid, &#039;disableIncomingMessages&#039;, &#039;1&#039;);

			roomId = body.response.roomId;
			assert(roomId);
		});

		it(&#039;should send a user-join system message when a chat room is created&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			const { messages } = body.response;
			assert.equal(messages.length, 2);
			assert.strictEqual(messages[0].system, 1);
			assert.strictEqual(messages[0].content, &#039;user-join&#039;);

			const { response, body: body2 } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${messages[0].messageId}`, {
				message: &#039;test&#039;,
			}, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.equal(body2.status.message, await translator.translate(&#039;[[error:cant-edit-chat-message]]&#039;));
		});

		it(&#039;should fail to add user to room with invalid data&#039;, async () =&gt; {
			let { response, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));

			({ response, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [null] }, &#039;foo&#039;));
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
		});

		it(&#039;should add a user to room&#039;, async () =&gt; {
			await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
			const isInRoom = await Messaging.isUserInRoom(mocks.users.herp.uid, roomId);
			assert(isInRoom);
		});

		it(&#039;should get users in room&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
			assert(Array.isArray(body.response.users));
			assert.strictEqual(body.response.users.length, 3);
		});

		it(&#039;should throw error if user is not in room&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/users`, {}, &#039;bar&#039;);
			assert.strictEqual(response.statusCode, 403);
			assert.equal(body.status.message, await translator.translate(&#039;[[error:no-privileges]]&#039;));
		});

		it(&#039;should fail to add users to room if max is reached&#039;, async () =&gt; {
			meta.config.maximumUsersInChatRoom = 2;
			const { response, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.bar.uid] }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.equal(body.status.message, await translator.translate(&#039;[[error:cant-add-more-users-to-chat-room]]&#039;));
			meta.config.maximumUsersInChatRoom = 0;
		});

		it(&#039;should fail to add users to room if user does not exist&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [98237498234] }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
		});

		it(&#039;should fail to add self to room&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.foo.uid] }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:cant-chat-with-yourself]]&#039;));
		});

		it(&#039;should fail to leave room with invalid data&#039;, async () =&gt; {
			let { response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));

			({ response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [98237423] }, &#039;foo&#039;));
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
		});

		it(&#039;should leave the chat room&#039;, async () =&gt; {
			await callv3API(&#039;delete&#039;, `/chats/${roomId}/users/${mocks.users.baz.uid}`, {}, &#039;baz&#039;);
			const isUserInRoom = await Messaging.isUserInRoom(mocks.users.baz.uid, roomId);
			assert.equal(isUserInRoom, false);
			assert(await Messaging.isRoomOwner(mocks.users.foo.uid, roomId));
		});

		it(&#039;should send a user-leave system message when a user leaves the chat room&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			const { messages } = body.response;
			const message = messages.pop();
			assert.strictEqual(message.system, 1);
			assert.strictEqual(message.content, &#039;user-leave&#039;);
		});

		it(&#039;should not send a user-leave system message when a user tries to leave a room they are not in&#039;, async () =&gt; {
			await callv3API(&#039;delete&#039;, `/chats/${roomId}/users/${mocks.users.baz.uid}`, {}, &#039;baz&#039;);
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			const { messages } = body.response;

			assert.equal(messages.length, 4);
			let message = messages.pop();
			assert.strictEqual(message.system, 1);
			assert.strictEqual(message.content, &#039;user-leave&#039;);

			// The message before should still be a user-join
			message = messages.pop();
			assert.strictEqual(message.system, 1);
			assert.strictEqual(message.content, &#039;user-join&#039;);
		});

		it(&#039;should change owner when owner leaves room&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, {
				uids: [mocks.users.foo.uid],
			}, &#039;herp&#039;);

			await callv3API(&#039;post&#039;, `/chats/${body.response.roomId}/users`, { uids: [mocks.users.baz.uid] }, &#039;herp&#039;);

			await callv3API(&#039;delete&#039;, `/chats/${body.response.roomId}/users/${mocks.users.herp.uid}`, {}, &#039;herp&#039;);

			assert(await Messaging.isRoomOwner(mocks.users.foo.uid, roomId));
		});

		it(&#039;should change owner if owner is deleted&#039;, async () =&gt; {
			const sender = await User.create({ username: &#039;deleted_chat_user&#039;, password: &#039;barbar&#039; });
			const { jar: senderJar, csrf_token: senderCsrf } = await helpers.loginUser(&#039;deleted_chat_user&#039;, &#039;barbar&#039;);

			const receiver = await User.create({ username: &#039;receiver&#039; });
			const { body } = await request.post(`${nconf.get(&#039;url&#039;)}/api/v3/chats`, {
				jar: senderJar,
				body: {
					uids: [receiver],
				},
				headers: {
					&#039;x-csrf-token&#039;: senderCsrf,
				},
			});
			await User.deleteAccount(sender);
			assert(await Messaging.isRoomOwner(receiver, body.response.roomId));
		});

		it(&#039;should fail to remove user from room&#039;, async () =&gt; {
			let { response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));

			({ response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [null] }, &#039;foo&#039;));
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
		});

		it(&#039;should fail to remove user from room if user does not exist&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [99] }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
		});

		it(&#039;should remove user from room&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;post&#039;, `/chats`, {
				uids: [mocks.users.herp.uid],
			}, &#039;foo&#039;);
			const { roomId } = body.response;
			assert.strictEqual(response.statusCode, 200);

			let isInRoom = await Messaging.isUserInRoom(mocks.users.herp.uid, roomId);
			assert(isInRoom);

			await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
			isInRoom = await Messaging.isUserInRoom(mocks.users.herp.uid, roomId);
			assert(!isInRoom);
		});

		it(&#039;should fail to send a message to room with invalid data&#039;, async () =&gt; {
			let { body } = await callv3API(&#039;post&#039;, `/chats/abc`, { message: &#039;test&#039; }, &#039;foo&#039;);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-data]]&#039;));

			({ body } = await callv3API(&#039;post&#039;, `/chats/1`, {}, &#039;foo&#039;));
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, message]]&#039;));
		});

		it(&#039;should fail to send chat if content is empty&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, {
				message: &#039; &#039;,
			}, &#039;foo&#039;);
			const { status, response } = body;

			assert.deepStrictEqual(response, {});
			assert.equal(status.message, await translator.translate(&#039;[[error:invalid-chat-message]]&#039;));
		});

		it(&#039;should send a message to a room&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
			const messageData = body.response;
			assert(messageData);
			assert.equal(messageData.content, &#039;first chat message&#039;);
			assert(messageData.fromUser);
			assert(messageData.roomId, roomId);
			const { content: raw } = await api.chats.getRawMessage(
				{ uid: mocks.users.foo.uid }, { mid: messageData.messageId, roomId }
			);
			assert.equal(raw, &#039;first chat message&#039;);
		});

		it(&#039;should fail to send second message due to rate limit&#039;, async () =&gt; {
			const oldValue = meta.config.chatMessageDelay;
			meta.config.chatMessageDelay = 1000;

			await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
			const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
			const { status } = body;
			assert.equal(status.message, await translator.translate(&#039;[[error:too-many-messages]]&#039;));
			meta.config.chatMessageDelay = oldValue;
		});

		it(&#039;should return invalid-data error&#039;, async () =&gt; {
			await assert.rejects(
				api.chats.getRawMessage({ uid: mocks.users.foo.uid }, undefined),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);


			await assert.rejects(
				api.chats.getRawMessage({ uid: mocks.users.foo.uid }, {}),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);
		});

		it(&#039;should return not allowed error if user is not in room&#039;, async () =&gt; {
			const uids = await User.create({ username: &#039;dummy&#039; });
			let { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, { uids: [uids] }, &#039;baz&#039;);
			const myRoomId = body.response.roomId;
			assert(myRoomId);

			try {
				await api.chats.getRawMessage({ uid: mocks.users.baz.uid }, { mid: 200 });
			} catch (err) {
				assert(err);
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
			}

			({ body } = await callv3API(&#039;post&#039;, `/chats/${myRoomId}`, { roomId: myRoomId, message: &#039;admin will see this&#039; }, &#039;baz&#039;));
			const message = body.response;
			const { content } = await api.chats.getRawMessage(
				{ uid: mocks.users.foo.uid }, { mid: message.messageId, roomId: myRoomId }
			);
			assert.equal(content, &#039;admin will see this&#039;);
		});


		it(&#039;should notify offline users of message&#039;, async () =&gt; {
			meta.config.notificationSendDelay = 0.1;

			const { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, { uids: [mocks.users.baz.uid] }, &#039;foo&#039;);
			const { roomId } = body.response;
			assert(roomId);

			await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
			await db.sortedSetAdd(&#039;users:online&#039;, Date.now() - ((meta.config.onlineCutoff * 60000) + 50000), mocks.users.herp.uid);

			await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;second chat message **bold** text&#039; }, &#039;foo&#039;);
			await sleep(3000);
			const data = await User.notifications.get(mocks.users.herp.uid);
			assert(data.unread[0]);
			const notification = data.unread[0];
			assert.strictEqual(notification.bodyShort, `New message in &lt;strong&gt;Room ${roomId}&lt;/strong&gt;`);
			assert(notification.nid.startsWith(`chat_${roomId}_${mocks.users.foo.uid}_`));
			assert.strictEqual(notification.path, `${nconf.get(&#039;relative_path&#039;)}/chats/${roomId}`);
		});

		it(&#039;should get messages from room&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			const { messages } = body.response;
			assert(Array.isArray(messages));

			// Filter out system messages
			const normalMessages = messages.filter(message =&gt; !message.system);
			assert.equal(normalMessages[0].roomId, roomId);
			assert.equal(normalMessages[0].fromuid, mocks.users.foo.uid);
		});

		it(&#039;should fail to mark read with invalid data&#039;, async () =&gt; {
			let _err;
			try {
				await api.chats.mark({ uid: null }, { state: 0, roomId });
			} catch (err) {
				_err = err;
			}
			assert.strictEqual(_err.message, &#039;[[error:invalid-data]]&#039;);

			try {
				await api.chats.mark({ uid: mocks.users.foo.uid }, null);
			} catch (err) {
				_err = err;
			}
			assert.strictEqual(_err.message, &#039;[[error:invalid-data]]&#039;);
		});

		it(&#039;should not error if user is not in room&#039;, async () =&gt; {
			await api.chats.mark({ uid: mocks.users.herp.uid }, { state: 0, roomId: 10 });
		});

		it(&#039;should mark room read&#039;, async () =&gt; {
			await api.chats.mark({ uid: mocks.users.foo.uid }, { state: 0, roomId: roomId });
		});

		it(&#039;should fail to rename room with invalid data&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;put&#039;, `/chats/${roomId}`, { name: null }, &#039;foo&#039;);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-data]]&#039;));
		});

		it(&#039;should rename room&#039;, async () =&gt; {
			const { response } = await callv3API(&#039;put&#039;, `/chats/${roomId}`, { name: &#039;new room name&#039; }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 200);
		});

		it(&#039;should send a room-rename system message when a room is renamed&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			const { messages } = body.response;

			const message = messages.pop();
			assert.strictEqual(message.system, 1);
			assert.strictEqual(message.content, &#039;room-rename, new room name&#039;);
		});

		it(&#039;should fail to load room with invalid-data&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/abc`, {}, &#039;foo&#039;);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-data]]&#039;));
		});

		it(&#039;should fail to load room if user is not in&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;baz&#039;);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-privileges]]&#039;));
		});

		it(&#039;should load chat room&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			assert.strictEqual(body.response.roomName, &#039;new room name&#039;);
		});

		it(&#039;should return true if user is dnd&#039;, async () =&gt; {
			await db.setObjectField(`user:${mocks.users.herp.uid}`, &#039;status&#039;, &#039;dnd&#039;);
			const { status } = await api.users.getStatus({ uid: mocks.users.foo.uid }, { uid: mocks.users.herp.uid });
			assert.strictEqual(status, &#039;dnd&#039;);
		});

		it(&#039;should fail to load recent chats with invalid data&#039;, async () =&gt; {
			await assert.rejects(
				api.chats.list({ uid: mocks.users.foo.uid }, undefined),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);

			await assert.rejects(
				api.chats.list({ uid: mocks.users.foo.uid }, { start: null }),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);

			await assert.rejects(
				api.chats.list({ uid: mocks.users.foo.uid }, { start: 0, uid: null }),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);
		});

		it(&#039;should load recent chats of user&#039;, async () =&gt; {
			const { rooms } = await api.chats.list(
				{ uid: mocks.users.foo.uid }, { start: 0, stop: 9, uid: mocks.users.foo.uid }
			);
			assert(Array.isArray(rooms));
		});

		it(&#039;should escape teaser&#039;, async () =&gt; {
			await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;&lt;svg/onload=alert(document.location);&#039; }, &#039;foo&#039;);
			const { rooms } = await api.chats.list(
				{ uid: mocks.users.foo.uid }, { start: 0, stop: 9, uid: mocks.users.foo.uid }
			);
			assert.equal(rooms[0].teaser.content, &#039;&amp;lt;svg&amp;#x2F;onload=alert(document.location);&#039;);
		});

		it(&#039;should fail to check if user has private chat with invalid data&#039;, async () =&gt; {
			await assert.rejects(
				api.users.getPrivateRoomId({ uid: null }, undefined),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);

			await assert.rejects(
				api.users.getPrivateRoomId({ uid: mocks.users.foo.uid }, undefined),
				{ message: &#039;[[error:invalid-data]]&#039; }
			);
		});

		it(&#039;should check if user has private chat with another uid&#039;, async () =&gt; {
			const { roomId } = await api.users.getPrivateRoomId({ uid: mocks.users.foo.uid }, { uid: mocks.users.herp.uid });
			assert(roomId);
		});
	});

	describe(&#039;toMid&#039;, () =&gt; {
		let roomId;
		let firstMid;
		before(async () =&gt; {
			// create room
			const { body } = await callv3API(&#039;post&#039;, `/chats`, {
				uids: [mocks.users.bar.uid],
			}, &#039;foo&#039;);
			roomId = body.response.roomId;
			// send message
			const result = await callv3API(&#039;post&#039;, `/chats/${roomId}`, {
				roomId: roomId,
				message: &#039;first chat message&#039;,
			}, &#039;foo&#039;);

			firstMid = result.body.response.mid;
		});

		it(&#039;should fail if toMid is not a number&#039;, async () =&gt; {
			const result = await callv3API(&#039;post&#039;, `/chats/${roomId}`, {
				roomId: roomId,
				message: &#039;invalid&#039;,
				toMid: &#039;osmaosd&#039;,
			}, &#039;foo&#039;);
			assert.strictEqual(result.body.status.message, &#039;Invalid Chat Message ID&#039;);
		});

		it(&#039;should reply to firstMid using toMid&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, {
				roomId: roomId,
				message: &#039;invalid&#039;,
				toMid: firstMid,
			}, &#039;bar&#039;);
			assert(body.response.mid);
		});

		it(&#039;should fail if user can not view toMid&#039;, async () =&gt; {
			// add new user
			await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
			// try to reply to firstMid that this user cant see
			const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, {
				roomId: roomId,
				message: &#039;invalid&#039;,
				toMid: firstMid,
			}, &#039;herp&#039;);
			assert.strictEqual(body.status.message, &#039;You do not have enough privileges for this action.&#039;);
		});
	});

	describe(&#039;edit/delete&#039;, () =&gt; {
		const socketModules = require(&#039;../src/socket.io/modules&#039;);
		let mid;
		let mid2;
		before(async () =&gt; {
			await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.baz.uid] }, &#039;foo&#039;);
			let { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
			mid = body.response.messageId;
			({ body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;second chat message&#039; }, &#039;baz&#039;));
			mid2 = body.response.messageId;
		});

		after(async () =&gt; {
			await callv3API(&#039;delete&#039;, `/chats/${roomId}/users/${mocks.users.baz.uid}`, {}, &#039;baz&#039;);
		});

		it(&#039;should fail to edit message with invalid data&#039;, async () =&gt; {
			let { response, body } = await callv3API(&#039;put&#039;, `/chats/1/messages/10000`, { message: &#039;foo&#039; }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-mid]]&#039;));

			({ response, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;));
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-chat-message]]&#039;));
		});

		it(&#039;should fail to edit message if new content is empty string&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, { message: &#039; &#039; }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-chat-message]]&#039;));
		});

		it(&#039;should fail to edit message if not own message&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, { message: &#039;message edited&#039; }, &#039;herp&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:cant-edit-chat-message]]&#039;));
		});

		it(&#039;should fail to edit message if message not in room&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/1014`, { message: &#039;message edited&#039; }, &#039;herp&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-mid]]&#039;));
		});

		it(&#039;should edit message&#039;, async () =&gt; {
			let { response, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, { message: &#039;message edited&#039; }, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 200);
			assert.strictEqual(body.response.content, &#039;message edited&#039;);

			({ response, body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;));
			assert.strictEqual(response.statusCode, 200);
			assert.strictEqual(body.response.content, &#039;message edited&#039;);
		});

		it(&#039;should fail to delete message if not owner&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;herp&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, &#039;You are not allowed to delete this message&#039;);
		});

		it(&#039;should mark the message as deleted&#039;, async () =&gt; {
			await callv3API(&#039;delete&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;);
			const value = await db.getObjectField(`message:${mid}`, &#039;deleted&#039;);
			assert.strictEqual(1, parseInt(value, 10));
		});

		it(&#039;should show deleted message to original users&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
			const { messages } = body.response;

			// Reduce messages to their mids
			const mids = messages.reduce((mids, cur) =&gt; {
				mids.push(cur.messageId);
				return mids;
			}, []);

			assert(mids.includes(mid));
		});

		it(&#039;should not show deleted message to other users&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;herp&#039;);
			const { messages } = body.response;
			messages.forEach((msg) =&gt; {
				assert(!msg.deleted || msg.content === &#039;&lt;p&gt;[[modules:chat.message-deleted]]&lt;/p&gt;&#039;, msg.content);
			});
		});

		it(&#039;should not show deleted message to other users&#039;, async () =&gt; {
			const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;herp&#039;);
			const message = body.response;
			assert.strictEqual(message.deleted, 1);
			assert.strictEqual(message.content, &#039;&lt;p&gt;[[modules:chat.message-deleted]]&lt;/p&gt;&#039;);
		});

		it(&#039;should error out if a message is deleted again&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, &#039;This chat message has already been deleted.&#039;);
		});

		it(&#039;should restore the message&#039;, async () =&gt; {
			await callv3API(&#039;post&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;);
			const value = await db.getObjectField(`message:${mid}`, &#039;deleted&#039;);
			assert.strictEqual(0, parseInt(value, 10));
		});

		it(&#039;should error out if a message is restored again&#039;, async () =&gt; {
			const { response, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;);
			assert.strictEqual(response.statusCode, 400);
			assert.strictEqual(body.status.message, &#039;This chat message has already been restored.&#039;);
		});

		describe(&#039;disabled via ACP&#039;, () =&gt; {
			before(async () =&gt; {
				meta.config.disableChatMessageEditing = true;
			});

			after(async () =&gt; {
				meta.config.disableChatMessageEditing = false;
			});

			it(&#039;should error out for regular users&#039;, async () =&gt; {
				const { response, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/messages/${mid2}`, {}, &#039;baz&#039;);
				assert.strictEqual(response.statusCode, 400);
				assert.strictEqual(body.status.message, &#039;chat-message-editing-disabled&#039;);
			});

			it(&#039;should succeed for administrators&#039;, async () =&gt; {
				await callv3API(&#039;delete&#039;, `/chats/${roomId}/messages/${mid2}`, {}, &#039;foo&#039;);
				await callv3API(&#039;post&#039;, `/chats/${roomId}/messages/${mid2}`, {}, &#039;foo&#039;);
			});

			it(&#039;should succeed for global moderators&#039;, async () =&gt; {
				await Groups.join([&#039;Global Moderators&#039;], mocks.users.baz.uid);

				await callv3API(&#039;delete&#039;, `/chats/${roomId}/messages/${mid2}`, {}, &#039;baz&#039;);
				await callv3API(&#039;post&#039;, `/chats/${roomId}/messages/${mid2}`, {}, &#039;baz&#039;);

				await Groups.leave([&#039;Global Moderators&#039;], mocks.users.baz.uid);
			});
		});
	});

	describe(&#039;controller&#039;, () =&gt; {
		it(&#039;should 404 if chat is disabled&#039;, async () =&gt; {
			meta.config.disableChat = 1;
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/user/baz/chats`);

			assert.equal(response.statusCode, 404);
		});

		it(&#039;should 401 for guest with not-authorised status code&#039;, async () =&gt; {
			meta.config.disableChat = 0;
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/user/baz/chats`);

			assert.equal(response.statusCode, 401);
			assert.equal(body.status.code, &#039;not-authorised&#039;);
		});

		it(&#039;should 404 for non-existent user&#039;, async () =&gt; {
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/user/doesntexist/chats`);
			assert.equal(response.statusCode, 404);
		});
	});

	describe(&#039;logged in chat controller&#039;, () =&gt; {
		let jar;
		before(async () =&gt; {
			({ jar } = await helpers.loginUser(&#039;herp&#039;, &#039;derpderp&#039;));
		});

		it(&#039;should return chats page data&#039;, async () =&gt; {
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/user/herp/chats`, { jar });

			assert.equal(response.statusCode, 200);
			assert(Array.isArray(body.rooms));
			assert.equal(body.rooms.length, 3);
			assert.equal(body.title, &#039;[[pages:chats]]&#039;);
		});

		it(&#039;should return room data&#039;, async () =&gt; {
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/user/herp/chats/${roomId}`, { jar });

			assert.equal(response.statusCode, 200);
			assert.equal(body.roomId, roomId);
			assert.equal(body.isOwner, false);
		});

		it(&#039;should redirect to chats page&#039;, async () =&gt; {
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/chats`, { jar });

			assert.equal(response.statusCode, 200);
			assert.equal(response.headers[&#039;x-redirect&#039;], encodeURIComponent(&#039;/user/herp/chats&#039;));
			assert.equal(body, &#039;/user/herp/chats&#039;);
		});

		it(&#039;should return 404 if user is not in room&#039;, async () =&gt; {
			const data = await helpers.loginUser(&#039;baz&#039;, &#039;quuxquux&#039;);
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/user/baz/chats/${roomId}`, { jar: data.jar });

			assert.equal(response.statusCode, 404);
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
