<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/lib/attestations/tpm.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/lib/attestations/tpm.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">580</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint-disable no-invalid-this */
// validators are a mixin, so it&#039;s okay that we&#039;re using &#039;this&#039; all over the place

&quot;use strict&quot;;

const {
	printHex,
	coerceToArrayBuffer,
	coerceToBase64,
	abEqual,
	abToBuf,
	abToPem,
	abToInt,
} = require(&quot;../utils&quot;);

const {
	Certificate,
	CertManager,
} = require(&quot;../certUtils&quot;);

const crypto = require(&quot;crypto&quot;);

const coseToJwk = require(&quot;cose-to-jwk&quot;);

function tpmParseFn(attStmt) {
	var ret = new Map();

	if (attStmt.ecdaaKeyId !== undefined) {
		throw new Error(&quot;TPM ECDAA attesation is not currently supported.&quot;);
	}

	// x5c
	var x5c = attStmt.x5c;

	if (!Array.isArray(x5c)) {
		throw new TypeError(&quot;expected TPM attestation x5c field to be of type Array&quot;);
	}

	if (x5c.length &lt; 1) {
		throw new TypeError(&quot;no certificates in TPM x5c field&quot;);
	}

	var newX5c = [];
	for (let cert of x5c) {
		cert = coerceToArrayBuffer(cert, &quot;TPM x5c cert&quot;);
		newX5c.push(cert);
	}
	// first certificate MUST be the attestation cert
	ret.set(&quot;attCert&quot;, newX5c.shift());
	// the rest of the certificates (if any) are the certificate chain
	ret.set(&quot;x5c&quot;, newX5c);

	// ecdaa
	if (attStmt.ecdaaKeyId) ret.set(&quot;ecdaaKeyId&quot;, attStmt.ecdaaKeyId);

	// sig
	ret.set(&quot;sig&quot;, coerceToArrayBuffer(attStmt.sig, &quot;tpm signature&quot;));

	// sig
	ret.set(&quot;ver&quot;, attStmt.ver);

	// alg
	var alg = {
		algName: coseToJwk.algToStr(attStmt.alg),
		hashAlg: coseToJwk.algToHashStr(attStmt.alg),
	};
	ret.set(&quot;alg&quot;, alg);

	// certInfo
	var certInfo = parseCertInfo(coerceToArrayBuffer(attStmt.certInfo, &quot;certInfo&quot;));
	ret.set(&quot;certInfo&quot;, certInfo);

	// pubArea
	var pubArea = parsePubArea(coerceToArrayBuffer(attStmt.pubArea, &quot;pubArea&quot;));
	ret.set(&quot;pubArea&quot;, pubArea);

	return ret;
}

function parseCertInfo(certInfo) {
	if (!(certInfo instanceof ArrayBuffer)) {
		throw new Error(&quot;tpm attestation: expected certInfo to be ArrayBuffer&quot;);
	}

	var dv = new DataView(certInfo);
	var offset = 0;
	var ret;
	var ci = new Map();
	ci.set(&quot;rawCertInfo&quot;, certInfo);

	// TPM_GENERATED_VALUE magic number
	var magic = dv.getUint32(offset);
	// if this isn&#039;t the magic number, the rest of the parsing is going to fail
	if (magic !== 0xff544347) { // 0xFF + &#039;TCG&#039;
		throw new Error(&quot;tpm attestation: certInfo had bad magic number: &quot; + magic.toString(16));
	}
	ci.set(&quot;magic&quot;, magic);
	offset += 4;


	// TPMI_ST_ATTEST type
	var type = decodeStructureTag(dv.getUint16(offset));
	// if this isn&#039;t the right type, the rest of the parsing is going to fail
	if (type !== &quot;TPM_ST_ATTEST_CERTIFY&quot;) {
		throw new Error(&quot;tpm attestation: got wrong type. expected &#039;TPM_ST_ATTEST_CERTIFY&#039; got: &quot; + type);
	}
	ci.set(&quot;type&quot;, type);
	offset += 2;

	// TPM2B_NAME qualifiedSigner
	ret = getTpm2bName(dv, offset);
	ci.set(&quot;qualifiedSignerHashType&quot;, ret.hashType);
	ci.set(&quot;qualifiedSigner&quot;, ret.nameHash);
	offset = ret.offset;

	// TPM2B_DATA extraData
	ret = getSizedElement(dv, offset);
	ci.set(&quot;extraData&quot;, ret.buf);
	offset = ret.offset;

	// TPMS_CLOCK_INFO clockInfo
	// UINT64 clock
	ci.set(&quot;clock&quot;, dv.buffer.slice(offset, offset + 8));
	offset += 8;
	// UINT32 resetCount
	ci.set(&quot;resetCount&quot;, dv.getUint32(offset));
	offset += 4;
	// UINT32 restartCount
	ci.set(&quot;restartCount&quot;, dv.getUint32(offset));
	offset += 4;
	// boolean safe
	ci.set(&quot;safe&quot;, !!dv.getUint8(offset));
	offset++;

	// UINT64 firmwareVersion
	ci.set(&quot;firmwareVersion&quot;, dv.buffer.slice(offset, offset + 8));
	offset += 8;

	// TPMU_ATTEST attested
	// TPM2B_NAME name
	ret = getTpm2bName(dv, offset);
	ci.set(&quot;nameHashType&quot;, ret.hashType);
	ci.set(&quot;name&quot;, ret.nameHash);
	offset = ret.offset;

	// TPM2B_NAME qualifiedName
	ret = getTpm2bName(dv, offset);
	ci.set(&quot;qualifiedNameHashType&quot;, ret.hashType);
	ci.set(&quot;qualifiedName&quot;, ret.nameHash);
	offset = ret.offset;

	if (offset !== certInfo.byteLength) {
		throw new Error(&quot;tpm attestation: left over bytes when parsing cert info&quot;);
	}

	return ci;
}

function parsePubArea(pubArea) {
	if (!(pubArea instanceof ArrayBuffer)) {
		throw new Error(&quot;tpm attestation: expected pubArea to be ArrayBuffer&quot;);
	}

	var dv = new DataView(pubArea);
	var offset = 0;
	var ret;
	var pa = new Map();
	pa.set(&quot;rawPubArea&quot;, pubArea);

	// TPMI_ALG_PUBLIC type
	var type = algIdToStr(dv.getUint16(offset));
	pa.set(&quot;type&quot;, type);
	offset += 2;

	// TPMI_ALG_HASH nameAlg
	pa.set(&quot;nameAlg&quot;, algIdToStr(dv.getUint16(offset)));
	offset += 2;

	// TPMA_OBJECT objectAttributes
	pa.set(&quot;objectAttributes&quot;, decodeObjectAttributes(dv.getUint32(offset)));
	offset += 4;

	// TPM2B_DIGEST authPolicy
	ret = getSizedElement(dv, offset);
	pa.set(&quot;authPolicy&quot;, ret.buf);
	offset = ret.offset;

	// TPMU_PUBLIC_PARMS parameters
	if (type !== &quot;TPM_ALG_RSA&quot;) {
		throw new Error(&quot;tpm attestation: only TPM_ALG_RSA supported&quot;);
	}
	// TODO: support other types
	pa.set(&quot;symmetric&quot;, algIdToStr(dv.getUint16(offset)));
	offset += 2;
	pa.set(&quot;scheme&quot;, algIdToStr(dv.getUint16(offset)));
	offset += 2;
	pa.set(&quot;keyBits&quot;, dv.getUint16(offset));
	offset += 2;
	var exponent = dv.getUint32(offset);
	if (exponent === 0) exponent = 65537;
	pa.set(&quot;exponent&quot;, exponent);
	offset += 4;

	// TPMU_PUBLIC_ID unique
	ret = getSizedElement(dv, offset);
	pa.set(&quot;unique&quot;, ret.buf);
	offset = ret.offset;

	if (offset !== pubArea.byteLength) {
		throw new Error(&quot;tpm attestation: left over bytes when parsing public area&quot;);
	}

	return pa;
}

// eslint-disable complexity
function decodeStructureTag(t) {
	/* eslint complexity: [&quot;off&quot;] */
	switch (t) {
		case 0x00C4: return &quot;TPM_ST_RSP_COMMAND&quot;;
		case 0x8000: return &quot;TPM_ST_NULL&quot;;
		case 0x8001: return &quot;TPM_ST_NO_SESSIONS&quot;;
		case 0x8002: return &quot;TPM_ST_SESSIONS&quot;;
		case 0x8003: return &quot;TPM_RESERVED_0x8003&quot;;
		case 0x8004: return &quot;TPM_RESERVED_0x8004&quot;;
		case 0x8014: return &quot;TPM_ST_ATTEST_NV&quot;;
		case 0x8015: return &quot;TPM_ST_ATTEST_COMMAND_AUDIT&quot;;
		case 0x8016: return &quot;TPM_ST_ATTEST_SESSION_AUDIT&quot;;
		case 0x8017: return &quot;TPM_ST_ATTEST_CERTIFY&quot;;
		case 0x8018: return &quot;TPM_ST_ATTEST_QUOTE&quot;;
		case 0x8019: return &quot;TPM_ST_ATTEST_TIME&quot;;
		case 0x801A: return &quot;TPM_ST_ATTEST_CREATION&quot;;
		case 0x801B: return &quot;TPM_RESERVED_0x801B&quot;;
		case 0x8021: return &quot;TPM_ST_CREATION&quot;;
		case 0x8022: return &quot;TPM_ST_VERIFIED&quot;;
		case 0x8023: return &quot;TPM_ST_AUTH_SECRET&quot;;
		case 0x8024: return &quot;TPM_ST_HASHCHECK&quot;;
		case 0x8025: return &quot;TPM_ST_AUTH_SIGNED&quot;;
		case 0x8029: return &quot;TPM_ST_FU_MANIFEST&quot;;
		default:
			throw new Error(&quot;tpm attestation: unknown structure tag: &quot; + t.toString(16));
	}
}

function decodeObjectAttributes(oa) {
	var attrList = [
		&quot;RESERVED_0&quot;,
		&quot;FIXED_TPM&quot;,
		&quot;ST_CLEAR&quot;,
		&quot;RESERVED_3&quot;,
		&quot;FIXED_PARENT&quot;,
		&quot;SENSITIVE_DATA_ORIGIN&quot;,
		&quot;USER_WITH_AUTH&quot;,
		&quot;ADMIN_WITH_POLICY&quot;,
		&quot;RESERVED_8&quot;,
		&quot;RESERVED_9&quot;,
		&quot;NO_DA&quot;,
		&quot;ENCRYPTED_DUPLICATION&quot;,
		&quot;RESERVED_12&quot;,
		&quot;RESERVED_13&quot;,
		&quot;RESERVED_14&quot;,
		&quot;RESERVED_15&quot;,
		&quot;RESTRICTED&quot;,
		&quot;DECRYPT&quot;,
		&quot;SIGN_ENCRYPT&quot;,
		&quot;RESERVED_19&quot;,
		&quot;RESERVED_20&quot;,
		&quot;RESERVED_21&quot;,
		&quot;RESERVED_22&quot;,
		&quot;RESERVED_23&quot;,
		&quot;RESERVED_24&quot;,
		&quot;RESERVED_25&quot;,
		&quot;RESERVED_26&quot;,
		&quot;RESERVED_27&quot;,
		&quot;RESERVED_28&quot;,
		&quot;RESERVED_29&quot;,
		&quot;RESERVED_30&quot;,
		&quot;RESERVED_31&quot;,
	];

	var ret = new Set();

	for (let i = 0; i &lt; 32; i++) {
		let bit = 1 &lt;&lt; i;
		if (oa &amp; bit) {
			ret.add(attrList[i]);
		}
	}

	return ret;
}

function getSizedElement(dv, offset) {
	var size = dv.getUint16(offset);
	offset += 2;
	var buf = dv.buffer.slice(offset, offset + size);
	dv = new DataView(buf);
	offset += size;

	return {
		size,
		dv,
		buf,
		offset,
	};
}

function getTpm2bName(dvIn, oIn) {
	var {
		offset,
		dv,
	} = getSizedElement(dvIn, oIn);

	var hashType = algIdToStr(dv.getUint16(0));
	var nameHash = dv.buffer.slice(2);

	return {
		hashType,
		nameHash,
		offset,
	};
}

function algIdToStr(hashType) {
	var hashList = [
		&quot;TPM_ALG_ERROR&quot;, // 0
		&quot;TPM_ALG_RSA&quot;, // 1
		null,
		null,
		&quot;TPM_ALG_SHA1&quot;, // 4
		&quot;TPM_ALG_HMAC&quot;, // 5
		&quot;TPM_ALG_AES&quot;, // 6
		&quot;TPM_ALG_MGF1&quot;, // 7
		null,
		&quot;TPM_ALG_KEYEDHASH&quot;, // 8
		&quot;TPM_ALG_XOR&quot;, // A
		&quot;TPM_ALG_SHA256&quot;, // B
		&quot;TPM_ALG_SHA384&quot;, // C
		&quot;TPM_ALG_SHA512&quot;, // D
		null,
		null,
		&quot;TPM_ALG_NULL&quot;, // 10
		null,
		&quot;TPM_ALG_SM3_256&quot;, // 12
		&quot;TPM_ALG_SM4&quot;, // 13
		&quot;TPM_ALG_RSASSA&quot;, // 14
		&quot;TPM_ALG_RSAES&quot;, // 15
		&quot;TPM_ALG_RSAPSS&quot;, // 16
		&quot;TPM_ALG_OAEP&quot;, // 17
		&quot;TPM_ALG_ECDSA&quot;, // 18
	];

	return hashList[hashType];
}

async function tpmValidateFn() {
	var parsedAttCert = this.authnrData.get(&quot;attCert&quot;);
	var certInfo = this.authnrData.get(&quot;certInfo&quot;);
	var pubArea = this.authnrData.get(&quot;pubArea&quot;);

	var ver = this.authnrData.get(&quot;ver&quot;);
	if (ver != &quot;2.0&quot;) {
		throw new Error(&quot;tpm attestation: expected TPM version 2.0&quot;);
	}
	this.audit.journal.add(&quot;ver&quot;);

	// https://www.w3.org/TR/webauthn/#tpm-attestation
	// Verify that the public key specified by the parameters and unique fields of pubArea is identical to the credentialPublicKey in the attestedCredentialData in authenticatorData.
	var pubAreaPkN = pubArea.get(&quot;unique&quot;);
	var pubAreaPkExp = pubArea.get(&quot;exponent&quot;);
	var credentialPublicKeyJwk = this.authnrData.get(&quot;credentialPublicKeyJwk&quot;);
	var credentialPublicKeyJwkN = coerceToArrayBuffer(credentialPublicKeyJwk.n, &quot;credentialPublicKeyJwk.n&quot;);
	var credentialPublicKeyJwkExpBuf = coerceToArrayBuffer(credentialPublicKeyJwk.e, &quot;credentialPublicKeyJwk.e&quot;);
	var credentialPublicKeyJwkExp = abToInt(credentialPublicKeyJwkExpBuf);

	if (credentialPublicKeyJwk.kty !== &quot;RSA&quot; ||
        pubArea.get(&quot;type&quot;) !== &quot;TPM_ALG_RSA&quot;) {
		throw new Error(&quot;tpm attestation: only RSA keys are currently supported&quot;);
	}

	if (pubAreaPkExp !== credentialPublicKeyJwkExp) {
		throw new Error(&quot;tpm attestation: RSA exponents of WebAuthn credentialPublicKey and TPM publicArea did not match&quot;);
	}

	if (!abEqual(credentialPublicKeyJwkN, pubAreaPkN)) {
		throw new Error(&quot;tpm attestation: RSA &#039;n&#039; of WebAuthn credentialPublicKey and TPM publicArea did not match&quot;);
	}

	// Validate that certInfo is valid:
	//     Verify that magic is set to TPM_GENERATED_VALUE.
	var magic = certInfo.get(&quot;magic&quot;);
	if (magic !== 0xff544347) { // 0xFF + &#039;TCG&#039;
		throw new Error(&quot;tpm attestation: certInfo had bad magic number: &quot; + magic.toString(16));
	}

	//     Verify that type is set to TPM_ST_ATTEST_CERTIFY.
	var type = certInfo.get(&quot;type&quot;);
	if (type !== &quot;TPM_ST_ATTEST_CERTIFY&quot;) {
		throw new Error(&quot;tpm attestation: got wrong type. expected &#039;TPM_ST_ATTEST_CERTIFY&#039; got: &quot; + type);
	}

	//     Verify that extraData is set to the hash of attToBeSigned using the hash algorithm employed in &quot;alg&quot;.
	var rawAuthnrData = this.authnrData.get(&quot;rawAuthnrData&quot;);
	var rawClientData = this.clientData.get(&quot;rawClientDataJson&quot;);
	const cdHash = crypto.createHash(&quot;sha256&quot;);
	cdHash.update(abToBuf(rawClientData));
	var clientDataHashBuf = cdHash.digest();

	var alg = this.authnrData.get(&quot;alg&quot;);
	if (alg.hashAlg === undefined) {
		throw new Error(&quot;tpm attestation: unknown algorithm: &quot; + alg);
	}
	this.audit.journal.add(&quot;alg&quot;);

	const attHash = crypto.createHash(alg.hashAlg);
	attHash.update(abToBuf(rawAuthnrData));
	attHash.update(clientDataHashBuf);
	var extraDataHashBuf = attHash.digest();
	var generatedExtraDataHash = new Uint8Array(extraDataHashBuf).buffer;
	var extraData = certInfo.get(&quot;extraData&quot;);
	if (!abEqual(generatedExtraDataHash, extraData)) {
		throw new Error(&quot;extraData hash did not match authnrData + clientDataHash hashed&quot;);
	}

	//     Verify that attested contains a TPMS_CERTIFY_INFO structure as specified in [TPMv2-Part2] section 10.12.3,
	//     [see parser]
	//     whose name field contains a valid Name for pubArea, as computed using the algorithm in the nameAlg field of pubArea using the procedure specified in [TPMv2-Part1] section 16.
	var pubAreaName = certInfo.get(&quot;name&quot;);
	var pubAreaNameHashAlg = tpmHashToNpmHash(certInfo.get(&quot;nameHashType&quot;));
	const pubAreaNameHash = crypto.createHash(pubAreaNameHashAlg);
	pubAreaNameHash.update(abToBuf(pubArea.get(&quot;rawPubArea&quot;)));
	var pubAreaNameHashBuf = pubAreaNameHash.digest();
	var generatedPubAreaNameHash = new Uint8Array(pubAreaNameHashBuf).buffer;
	if (!abEqual(generatedPubAreaNameHash, pubAreaName)) {
		throw new Error(&quot;pubAreaName hash did not match hash of publicArea&quot;);
	}
	this.audit.journal.add(&quot;pubArea&quot;);

	//     Note that the remaining fields in the &quot;Standard Attestation Structure&quot; [TPMv2-Part1] section 31.2, i.e., qualifiedSigner, clockInfo and firmwareVersion are ignored.
	//     These fields MAY be used as an input to risk engines.

	// If x5c is present, this indicates that the attestation type is not ECDAA. In this case:
	//     Verify the sig is a valid signature over certInfo using the attestation public key in x5c with the algorithm specified in alg.
	var sig = this.authnrData.get(&quot;sig&quot;);
	var rawCertInfo = certInfo.get(&quot;rawCertInfo&quot;);
	var attCertPem = abToPem(&quot;CERTIFICATE&quot;, parsedAttCert);
	const verifySig = crypto.createVerify(alg.hashAlg);
	verifySig.write(abToBuf(rawCertInfo));
	verifySig.end();
	var res = verifySig.verify(attCertPem, abToBuf(sig));
	if (!res) {
		throw new Error(&quot;TPM attestation signature verification failed&quot;);
	}
	this.audit.journal.add(&quot;sig&quot;);
	this.audit.journal.add(&quot;certInfo&quot;);

	//     Verify that x5c meets the requirements in §8.3.1 TPM attestation statement certificate requirements.
	// https://www.w3.org/TR/webauthn/#tpm-cert-requirements
	// decode attestation cert
	var attCert = new Certificate(coerceToBase64(parsedAttCert, &quot;parsedAttCert&quot;));
	try {
		await attCert.verify();
	} catch (e) {
		let err = e;
		if (err.message === &quot;Please provide issuer certificate as a parameter&quot;) {
			// err = new Error(&quot;Root attestation certificate for this token could not be found. Please contact your security key vendor.&quot;);
			this.audit.warning.set(&quot;attesation-not-validated&quot;, &quot;could not validate attestation because the root attestation certification could not be found&quot;);
		} else {
			throw err;
		}
	}

	// Version MUST be set to 3.
	if (attCert.getVersion() !== 3) {
		throw new Error(&quot;expected TPM attestation certificate to be x.509v3&quot;);
	}

	// Subject field MUST be set to empty.
	var attCertSubject = attCert.getSubject();
	if (attCertSubject.size !== 0) {
		throw new Error(&quot;tpm attestation: attestation certificate MUST have empty subject&quot;);
	}

	// The Subject Alternative Name extension MUST be set as defined in [TPMv2-EK-Profile] section 3.2.9.
	// [save certificate warnings, info, and extensions in our audit information]
	var attCertExt = attCert.getExtensions();
	attCertExt.forEach((v, k) =&gt; this.audit.info.set(k, v));
	attCert.info.forEach((v, k) =&gt; this.audit.info.set(k, v));
	attCert.warning.forEach((v, k) =&gt; this.audit.warning.set(k, v));

	var altName = attCertExt.get(&quot;subject-alt-name&quot;);
	if (altName === undefined ||
        !Array.isArray(altName) ||
        altName.length &lt; 1) {
		throw new Error(&quot;tpm attestation: Subject Alternative Name extension MUST be set as defined in [TPMv2-EK-Profile] section 3.2.9&quot;);
	}

	// TCG EK Credential Profile For TPM Family 2.0; Level 0 Specification Version 2.0 Revision 14 4 November 2014
	// The issuer MUST include TPM manufacturer, TPM part number and TPM firmware version, using the directoryNameform within the GeneralName structure.
	var directoryName;
	altName.forEach((name) =&gt; {
		if (name.directoryName !== undefined) {
			directoryName = name.directoryName;
		}
	});

	if (directoryName === undefined) {
		throw new Error(&quot;tpm attestation: subject alternative name did not contain directory name&quot;);
	}

	// The TPM manufacturer identifies the manufacturer of the TPM. This value MUST be the vendor ID defined in the TCG Vendor ID Registry
	if (!directoryName.has(&quot;tcg-at-tpm-manufacturer&quot;)) {
		throw new Error(&quot;tpm attestation: subject alternative name did not list manufacturer&quot;);
	}
	// TODO: lookup manufacturer in registry

	// The TPM part number is encoded as a string and is manufacturer-specific. A manufacturer MUST provide a way to the user to retrieve the part number physically or logically. This information could be e.g. provided as part of the vendor string in the command TPM2_GetCapability(property = TPM_PT_VENDOR_STRING_x; x=1…4).
	if (!directoryName.has(&quot;tcg-at-tpm-model&quot;)) {
		throw new Error(&quot;tpm attestation: subject alternative name did not list model number&quot;);
	}

	// The TPM firmware version is a manufacturer-specific implementation version of the TPM. This value SHOULD match the version reported by the command TPM2_GetCapability (property = TPM_PT_FIRMWARE_VERSION_1).
	if (!directoryName.has(&quot;tcg-at-tpm-version&quot;)) {
		throw new Error(&quot;tpm attestation: subject alternative name did not list firmware version&quot;);
	}

	// The Extended Key Usage extension MUST contain the &quot;joint-iso-itu-t(2) internationalorganizations(23) 133 tcg-kp(8) tcg-kp-AIKCertificate(3)&quot; OID.
	var extKeyUsage = attCertExt.get(&quot;ext-key-usage&quot;);
	if (!Array.isArray(extKeyUsage) || !extKeyUsage.includes(&quot;tcg-kp-aik-certificate&quot;)) {
		throw new Error(&quot;tpm attestation: the Extended Key Usage extension MUST contain &#039;tcg-kp-aik-certificate&#039;&quot;);
	}

	// The Basic Constraints extension MUST have the CA component set to false.
	var basicConstraints = attCertExt.get(&quot;basic-constraints&quot;);
	if (typeof basicConstraints !== &quot;object&quot; || basicConstraints.cA !== false) {
		throw new Error(&quot;tpm attestation: the Basic Constraints extension MUST have the CA component set to false&quot;);
	}
	// An Authority Information Access (AIA) extension with entry id-ad-ocsp and a CRL Distribution Point extension [RFC5280]
	// are both OPTIONAL as the status of many attestation certificates is available through metadata services. See, for example, the FIDO Metadata Service [FIDOMetadataService].
	// [will use MDS]

	//     If x5c contains an extension with OID 1 3 6 1 4 1 45724 1 1 4 (id-fido-gen-ce-aaguid) verify that the value of this extension matches the aaguid in authenticatorData.
	var certAaguid = attCertExt.get(&quot;fido-aaguid&quot;);
	var aaguid = this.authnrData.get(&quot;aaguid&quot;);
	if (certAaguid !== undefined &amp;&amp; !abEqual(aaguid, certAaguid)) {
		throw new Error(&quot;tpm attestation: authnrData AAGUID did not match AAGUID in attestation certificate&quot;);
	}
	this.audit.journal.add(&quot;x5c&quot;);
	this.audit.journal.add(&quot;attCert&quot;);

	//     If successful, return attestation type AttCA and attestation trust path x5c.
	this.audit.info.set(&quot;attestation-type&quot;, &quot;AttCA&quot;);

	this.audit.journal.add(&quot;fmt&quot;);

	return true;

	// If ecdaaKeyId is present, then the attestation type is ECDAA.
	//     Perform ECDAA-Verify on sig to verify that it is a valid signature over certInfo (see [FIDOEcdaaAlgorithm]).
	//     If successful, return attestation type ECDAA and the identifier of the ECDAA-Issuer public key ecdaaKeyId.
	// [not currently supported, error would have been thrown in parser]
}

function tpmHashToNpmHash(tpmHash) {
	switch (tpmHash) {
		case &quot;TPM_ALG_SHA1&quot;: return &quot;SHA1&quot;;
		case &quot;TPM_ALG_SHA256&quot;: return &quot;SHA256&quot;;
		case &quot;TPM_ALG_SHA384&quot;: return &quot;SHA384&quot;;
		case &quot;TPM_ALG_SHA512&quot;: return &quot;SHA512&quot;;
		default:
			throw new TypeError(&quot;Unsupported hash type: &quot; + tpmHash);
	}
}

module.exports = {
	name: &quot;tpm&quot;,
	parseFn: tpmParseFn,
	validateFn: tpmValidateFn,
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
