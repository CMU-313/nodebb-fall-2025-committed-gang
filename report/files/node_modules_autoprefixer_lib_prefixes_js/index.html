<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/autoprefixer/lib/prefixes.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/autoprefixer/lib/prefixes.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">429</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">let AtRule = require(&#039;./at-rule&#039;)
let Browsers = require(&#039;./browsers&#039;)
let Declaration = require(&#039;./declaration&#039;)
let hackAlignContent = require(&#039;./hacks/align-content&#039;)
let hackAlignItems = require(&#039;./hacks/align-items&#039;)
let hackAlignSelf = require(&#039;./hacks/align-self&#039;)
let hackAnimation = require(&#039;./hacks/animation&#039;)
let hackAppearance = require(&#039;./hacks/appearance&#039;)
let hackAutofill = require(&#039;./hacks/autofill&#039;)
let hackBackdropFilter = require(&#039;./hacks/backdrop-filter&#039;)
let hackBackgroundClip = require(&#039;./hacks/background-clip&#039;)
let hackBackgroundSize = require(&#039;./hacks/background-size&#039;)
let hackBlockLogical = require(&#039;./hacks/block-logical&#039;)
let hackBorderImage = require(&#039;./hacks/border-image&#039;)
let hackBorderRadius = require(&#039;./hacks/border-radius&#039;)
let hackBreakProps = require(&#039;./hacks/break-props&#039;)
let hackCrossFade = require(&#039;./hacks/cross-fade&#039;)
let hackDisplayFlex = require(&#039;./hacks/display-flex&#039;)
let hackDisplayGrid = require(&#039;./hacks/display-grid&#039;)
let hackFileSelectorButton = require(&#039;./hacks/file-selector-button&#039;)
let hackFilter = require(&#039;./hacks/filter&#039;)
let hackFilterValue = require(&#039;./hacks/filter-value&#039;)
let hackFlex = require(&#039;./hacks/flex&#039;)
let hackFlexBasis = require(&#039;./hacks/flex-basis&#039;)
let hackFlexDirection = require(&#039;./hacks/flex-direction&#039;)
let hackFlexFlow = require(&#039;./hacks/flex-flow&#039;)
let hackFlexGrow = require(&#039;./hacks/flex-grow&#039;)
let hackFlexShrink = require(&#039;./hacks/flex-shrink&#039;)
let hackFlexWrap = require(&#039;./hacks/flex-wrap&#039;)
let hackFullscreen = require(&#039;./hacks/fullscreen&#039;)
let hackGradient = require(&#039;./hacks/gradient&#039;)
let hackGridArea = require(&#039;./hacks/grid-area&#039;)
let hackGridColumnAlign = require(&#039;./hacks/grid-column-align&#039;)
let hackGridEnd = require(&#039;./hacks/grid-end&#039;)
let hackGridRowAlign = require(&#039;./hacks/grid-row-align&#039;)
let hackGridRowColumn = require(&#039;./hacks/grid-row-column&#039;)
let hackGridRowsColumns = require(&#039;./hacks/grid-rows-columns&#039;)
let hackGridStart = require(&#039;./hacks/grid-start&#039;)
let hackGridTemplate = require(&#039;./hacks/grid-template&#039;)
let hackGridTemplateAreas = require(&#039;./hacks/grid-template-areas&#039;)
let hackImageRendering = require(&#039;./hacks/image-rendering&#039;)
let hackImageSet = require(&#039;./hacks/image-set&#039;)
let hackInlineLogical = require(&#039;./hacks/inline-logical&#039;)
let hackIntrinsic = require(&#039;./hacks/intrinsic&#039;)
let hackJustifyContent = require(&#039;./hacks/justify-content&#039;)
let hackMaskBorder = require(&#039;./hacks/mask-border&#039;)
let hackMaskComposite = require(&#039;./hacks/mask-composite&#039;)
let hackOrder = require(&#039;./hacks/order&#039;)
let hackOverscrollBehavior = require(&#039;./hacks/overscroll-behavior&#039;)
let hackPixelated = require(&#039;./hacks/pixelated&#039;)
let hackPlaceSelf = require(&#039;./hacks/place-self&#039;)
let hackPlaceholder = require(&#039;./hacks/placeholder&#039;)
let hackPlaceholderShown = require(&#039;./hacks/placeholder-shown&#039;)
let hackPrintColorAdjust = require(&#039;./hacks/print-color-adjust&#039;)
let hackTextDecoration = require(&#039;./hacks/text-decoration&#039;)
let hackTextDecorationSkipInk = require(&#039;./hacks/text-decoration-skip-ink&#039;)
let hackTextEmphasisPosition = require(&#039;./hacks/text-emphasis-position&#039;)
let hackTransformDecl = require(&#039;./hacks/transform-decl&#039;)
let hackUserSelect = require(&#039;./hacks/user-select&#039;)
let hackWritingMode = require(&#039;./hacks/writing-mode&#039;)
let Processor = require(&#039;./processor&#039;)
let Resolution = require(&#039;./resolution&#039;)
let Selector = require(&#039;./selector&#039;)
let Supports = require(&#039;./supports&#039;)
let Transition = require(&#039;./transition&#039;)
let utils = require(&#039;./utils&#039;)
let Value = require(&#039;./value&#039;)
let vendor = require(&#039;./vendor&#039;)

Selector.hack(hackAutofill)
Selector.hack(hackFullscreen)
Selector.hack(hackPlaceholder)
Selector.hack(hackPlaceholderShown)
Selector.hack(hackFileSelectorButton)
Declaration.hack(hackFlex)
Declaration.hack(hackOrder)
Declaration.hack(hackFilter)
Declaration.hack(hackGridEnd)
Declaration.hack(hackAnimation)
Declaration.hack(hackFlexFlow)
Declaration.hack(hackFlexGrow)
Declaration.hack(hackFlexWrap)
Declaration.hack(hackGridArea)
Declaration.hack(hackPlaceSelf)
Declaration.hack(hackGridStart)
Declaration.hack(hackAlignSelf)
Declaration.hack(hackAppearance)
Declaration.hack(hackFlexBasis)
Declaration.hack(hackMaskBorder)
Declaration.hack(hackMaskComposite)
Declaration.hack(hackAlignItems)
Declaration.hack(hackUserSelect)
Declaration.hack(hackFlexShrink)
Declaration.hack(hackBreakProps)
Declaration.hack(hackWritingMode)
Declaration.hack(hackBorderImage)
Declaration.hack(hackAlignContent)
Declaration.hack(hackBorderRadius)
Declaration.hack(hackBlockLogical)
Declaration.hack(hackGridTemplate)
Declaration.hack(hackInlineLogical)
Declaration.hack(hackGridRowAlign)
Declaration.hack(hackTransformDecl)
Declaration.hack(hackFlexDirection)
Declaration.hack(hackImageRendering)
Declaration.hack(hackBackdropFilter)
Declaration.hack(hackBackgroundClip)
Declaration.hack(hackTextDecoration)
Declaration.hack(hackJustifyContent)
Declaration.hack(hackBackgroundSize)
Declaration.hack(hackGridRowColumn)
Declaration.hack(hackGridRowsColumns)
Declaration.hack(hackGridColumnAlign)
Declaration.hack(hackOverscrollBehavior)
Declaration.hack(hackGridTemplateAreas)
Declaration.hack(hackPrintColorAdjust)
Declaration.hack(hackTextEmphasisPosition)
Declaration.hack(hackTextDecorationSkipInk)
Value.hack(hackGradient)
Value.hack(hackIntrinsic)
Value.hack(hackPixelated)
Value.hack(hackImageSet)
Value.hack(hackCrossFade)
Value.hack(hackDisplayFlex)
Value.hack(hackDisplayGrid)
Value.hack(hackFilterValue)

let declsCache = new Map()

class Prefixes {
  constructor(data, browsers, options = {}) {
    this.data = data
    this.browsers = browsers
    this.options = options
    ;[this.add, this.remove] = this.preprocess(this.select(this.data))
    this.transition = new Transition(this)
    this.processor = new Processor(this)
  }

  /**
   * Return clone instance to remove all prefixes
   */
  cleaner() {
    if (this.cleanerCache) {
      return this.cleanerCache
    }

    if (this.browsers.selected.length) {
      let empty = new Browsers(this.browsers.data, [])
      this.cleanerCache = new Prefixes(this.data, empty, this.options)
    } else {
      return this
    }

    return this.cleanerCache
  }

  /**
   * Declaration loader with caching
   */
  decl(prop) {
    if (!declsCache.has(prop)) {
      declsCache.set(prop, Declaration.load(prop))
    }

    return declsCache.get(prop)
  }

  /**
   * Group declaration by unprefixed property to check them
   */
  group(decl) {
    let rule = decl.parent
    let index = rule.index(decl)
    let { length } = rule.nodes
    let unprefixed = this.unprefixed(decl.prop)

    let checker = (step, callback) =&gt; {
      index += step
      while (index &gt;= 0 &amp;&amp; index &lt; length) {
        let other = rule.nodes[index]
        if (other.type === &#039;decl&#039;) {
          if (step === -1 &amp;&amp; other.prop === unprefixed) {
            if (!Browsers.withPrefix(other.value)) {
              break
            }
          }

          if (this.unprefixed(other.prop) !== unprefixed) {
            break
          } else if (callback(other) === true) {
            return true
          }

          if (step === +1 &amp;&amp; other.prop === unprefixed) {
            if (!Browsers.withPrefix(other.value)) {
              break
            }
          }
        }

        index += step
      }
      return false
    }

    return {
      down(callback) {
        return checker(+1, callback)
      },
      up(callback) {
        return checker(-1, callback)
      }
    }
  }

  /**
   * Normalize prefix for remover
   */
  normalize(prop) {
    return this.decl(prop).normalize(prop)
  }

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) {
    prop = vendor.unprefixed(prop)
    return this.decl(prop).prefixed(prop, prefix)
  }

  /**
   * Cache prefixes data to fast CSS processing
   */
  preprocess(selected) {
    let add = {
      &#039;@supports&#039;: new Supports(Prefixes, this),
      &#039;selectors&#039;: []
    }
    for (let name in selected.add) {
      let prefixes = selected.add[name]
      if (name === &#039;@keyframes&#039; || name === &#039;@viewport&#039;) {
        add[name] = new AtRule(name, prefixes, this)
      } else if (name === &#039;@resolution&#039;) {
        add[name] = new Resolution(name, prefixes, this)
      } else if (this.data[name].selector) {
        add.selectors.push(Selector.load(name, prefixes, this))
      } else {
        let props = this.data[name].props

        if (props) {
          let value = Value.load(name, prefixes, this)
          for (let prop of props) {
            if (!add[prop]) {
              add[prop] = { values: [] }
            }
            add[prop].values.push(value)
          }
        } else {
          let values = (add[name] &amp;&amp; add[name].values) || []
          add[name] = Declaration.load(name, prefixes, this)
          add[name].values = values
        }
      }
    }

    let remove = { selectors: [] }
    for (let name in selected.remove) {
      let prefixes = selected.remove[name]
      if (this.data[name].selector) {
        let selector = Selector.load(name, prefixes)
        for (let prefix of prefixes) {
          remove.selectors.push(selector.old(prefix))
        }
      } else if (name === &#039;@keyframes&#039; || name === &#039;@viewport&#039;) {
        for (let prefix of prefixes) {
          let prefixed = `@${prefix}${name.slice(1)}`
          remove[prefixed] = { remove: true }
        }
      } else if (name === &#039;@resolution&#039;) {
        remove[name] = new Resolution(name, prefixes, this)
      } else {
        let props = this.data[name].props
        if (props) {
          let value = Value.load(name, [], this)
          for (let prefix of prefixes) {
            let old = value.old(prefix)
            if (old) {
              for (let prop of props) {
                if (!remove[prop]) {
                  remove[prop] = {}
                }
                if (!remove[prop].values) {
                  remove[prop].values = []
                }
                remove[prop].values.push(old)
              }
            }
          }
        } else {
          for (let p of prefixes) {
            let olds = this.decl(name).old(name, p)
            if (name === &#039;align-self&#039;) {
              let a = add[name] &amp;&amp; add[name].prefixes
              if (a) {
                if (p === &#039;-webkit- 2009&#039; &amp;&amp; a.includes(&#039;-webkit-&#039;)) {
                  continue
                } else if (p === &#039;-webkit-&#039; &amp;&amp; a.includes(&#039;-webkit- 2009&#039;)) {
                  continue
                }
              }
            }
            for (let prefixed of olds) {
              if (!remove[prefixed]) {
                remove[prefixed] = {}
              }
              remove[prefixed].remove = true
            }
          }
        }
      }
    }

    return [add, remove]
  }

  /**
   * Select prefixes from data, which is necessary for selected browsers
   */
  select(list) {
    let selected = { add: {}, remove: {} }

    for (let name in list) {
      let data = list[name]
      let add = data.browsers.map(i =&gt; {
        let params = i.split(&#039; &#039;)
        return {
          browser: `${params[0]} ${params[1]}`,
          note: params[2]
        }
      })

      let notes = add
        .filter(i =&gt; i.note)
        .map(i =&gt; `${this.browsers.prefix(i.browser)} ${i.note}`)
      notes = utils.uniq(notes)

      add = add
        .filter(i =&gt; this.browsers.isSelected(i.browser))
        .map(i =&gt; {
          let prefix = this.browsers.prefix(i.browser)
          if (i.note) {
            return `${prefix} ${i.note}`
          } else {
            return prefix
          }
        })
      add = this.sort(utils.uniq(add))

      if (this.options.flexbox === &#039;no-2009&#039;) {
        add = add.filter(i =&gt; !i.includes(&#039;2009&#039;))
      }

      let all = data.browsers.map(i =&gt; this.browsers.prefix(i))
      if (data.mistakes) {
        all = all.concat(data.mistakes)
      }
      all = all.concat(notes)
      all = utils.uniq(all)

      if (add.length) {
        selected.add[name] = add
        if (add.length &lt; all.length) {
          selected.remove[name] = all.filter(i =&gt; !add.includes(i))
        }
      } else {
        selected.remove[name] = all
      }
    }

    return selected
  }

  /**
   * Sort vendor prefixes
   */
  sort(prefixes) {
    return prefixes.sort((a, b) =&gt; {
      let aLength = utils.removeNote(a).length
      let bLength = utils.removeNote(b).length

      if (aLength === bLength) {
        return b.length - a.length
      } else {
        return bLength - aLength
      }
    })
  }

  /**
   * Return unprefixed version of property
   */
  unprefixed(prop) {
    let value = this.normalize(vendor.unprefixed(prop))
    if (value === &#039;flex-direction&#039;) {
      value = &#039;flex-flow&#039;
    }
    return value
  }

  /**
   * Return values, which must be prefixed in selected property
   */
  values(type, prop) {
    let data = this[type]

    let global = data[&#039;*&#039;] &amp;&amp; data[&#039;*&#039;].values
    let values = data[prop] &amp;&amp; data[prop].values

    if (global &amp;&amp; values) {
      return utils.uniq(global.concat(values))
    } else {
      return global || values || []
    }
  }
}

module.exports = Prefixes
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
