<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/prompt/node_modules/winston/lib/winston/common.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/prompt/node_modules/winston/lib/winston/common.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">505</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">79.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.23</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * common.js: Internal helper and utility functions for winston
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 *
 */

var util = require(&#039;util&#039;),
    crypto = require(&#039;crypto&#039;),
    cycle = require(&#039;cycle&#039;),
    fs = require(&#039;fs&#039;),
    StringDecoder = require(&#039;string_decoder&#039;).StringDecoder,
    Stream = require(&#039;stream&#039;).Stream,
    config = require(&#039;./config&#039;);

//
// ### function setLevels (target, past, current)
// #### @target {Object} Object on which to set levels.
// #### @past {Object} Previous levels set on target.
// #### @current {Object} Current levels to set on target.
// Create functions on the target objects for each level
// in current.levels. If past is defined, remove functions
// for each of those levels.
//
exports.setLevels = function (target, past, current, isDefault) {
  var self = this;
  if (past) {
    Object.keys(past).forEach(function (level) {
      delete target[level];
    });
  }

  target.levels = current || config.npm.levels;
  if (target.padLevels) {
    target.levelLength = exports.longestElement(Object.keys(target.levels));
  }

  //
  //  Define prototype methods for each log level
  //  e.g. target.log(&#039;info&#039;, msg) &lt;=&gt; target.info(msg)
  //
  Object.keys(target.levels).forEach(function (level) {

    // TODO Refactor logging methods into a different object to avoid name clashes
    if (level === &#039;log&#039;) {
      console.warn(&#039;Log level named &quot;log&quot; will clash with the method &quot;log&quot;. Consider using a different name.&#039;);
      return;
    }

    target[level] = function (msg) {
      // build argument list (level, msg, ... [string interpolate], [{metadata}], [callback])
      var args = [level].concat(Array.prototype.slice.call(arguments));
      target.log.apply(target, args);
    };
  });

  return target;
};

//
// ### function longestElement
// #### @xs {Array} Array to calculate against
// Returns the longest element in the `xs` array.
//
exports.longestElement = function (xs) {
  return Math.max.apply(
    null,
    xs.map(function (x) { return x.length; })
  );
};

//
// ### function clone (obj)
// #### @obj {Object} Object to clone.
// Helper method for deep cloning pure JSON objects
// i.e. JSON objects that are either literals or objects (no Arrays, etc)
//
exports.clone = function (obj) {
  if (obj instanceof Error) {
    // With potential custom Error objects, this might not be exactly correct,
    // but probably close-enough for purposes of this lib.
    var copy = { message: obj.message };
    Object.getOwnPropertyNames(obj).forEach(function (key) {
      copy[key] = obj[key];
    });

    return cycle.decycle(copy);
  }
  else if (!(obj instanceof Object)) {
    return obj;
  }
  else if (obj instanceof Date) {
    return new Date(obj.getTime());
  }

  return clone(cycle.decycle(obj));
};

function clone(obj) {
  //
  // We only need to clone reference types (Object)
  //
  var copy = Array.isArray(obj) ? [] : {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (Array.isArray(obj[i])) {
        copy[i] = obj[i].slice(0);
      }
      else if (obj[i] instanceof Buffer) {
        copy[i] = obj[i].slice(0);
      }
      else if (typeof obj[i] != &#039;function&#039;) {
        copy[i] = obj[i] instanceof Object ? exports.clone(obj[i]) : obj[i];
      }
      else if (typeof obj[i] === &#039;function&#039;) {
        copy[i] = obj[i];
      }
    }
  }

  return copy;
}

//
// ### function log (options)
// #### @options {Object} All information about the log serialization.
// Generic logging function for returning timestamped strings
// with the following options:
//
//    {
//      level:     &#039;level to add to serialized message&#039;,
//      message:   &#039;message to serialize&#039;,
//      meta:      &#039;additional logging metadata to serialize&#039;,
//      colorize:  false, // Colorizes output (only if `.json` is false)
//      align:     false  // Align message level.
//      timestamp: true   // Adds a timestamp to the serialized message
//      label:     &#039;label to prepend the message&#039;
//    }
//
exports.log = function (options) {
  var timestampFn = typeof options.timestamp === &#039;function&#039;
        ? options.timestamp
        : exports.timestamp,
      timestamp   = options.timestamp ? timestampFn() : null,
      showLevel   = options.showLevel === undefined ? true : options.showLevel,
      meta        = options.meta !== null &amp;&amp; options.meta !== undefined
        ? exports.clone(options.meta)
        : options.meta || null,
      output;

  //
  // raw mode is intended for outputing winston as streaming JSON to STDOUT
  //
  if (options.raw) {
    if (typeof meta !== &#039;object&#039; &amp;&amp; meta != null) {
      meta = { meta: meta };
    }
    output         = exports.clone(meta) || {};
    output.level   = options.level;
    //
    // Remark (jcrugzz): This used to be output.message = options.message.stripColors.
    // I do not know why this is, it does not make sense but im handling that
    // case here as well as handling the case that does make sense which is to
    // make the `output.message = options.message`
    //
    output.message = options.message.stripColors
      ? options.message.stripColors
      : options.message;

    return JSON.stringify(output);
  }

  //
  // json mode is intended for pretty printing multi-line json to the terminal
  //
  if (options.json || true === options.logstash) {
    if (typeof meta !== &#039;object&#039; &amp;&amp; meta != null) {
      meta = { meta: meta };
    }

    output         = exports.clone(meta) || {};
    output.level   = options.level;
    output.message = output.message || &#039;&#039;;

    if (options.label) { output.label = options.label; }
    if (options.message) { output.message = options.message; }
    if (timestamp) { output.timestamp = timestamp; }

    if (options.logstash === true) {
      // use logstash format
      var logstashOutput = {};
      if (output.message !== undefined) {
        logstashOutput[&#039;@message&#039;] = output.message;
        delete output.message;
      }

      if (output.timestamp !== undefined) {
        logstashOutput[&#039;@timestamp&#039;] = output.timestamp;
        delete output.timestamp;
      }

      logstashOutput[&#039;@fields&#039;] = exports.clone(output);
      output = logstashOutput;
    }

    if (typeof options.stringify === &#039;function&#039;) {
      return options.stringify(output);
    }

    return JSON.stringify(output, function (key, value) {
      return value instanceof Buffer
        ? value.toString(&#039;base64&#039;)
        : value;
    });
  }

  //
  // Remark: this should really be a call to `util.format`.
  //
  if (typeof options.formatter == &#039;function&#039;) {
    options.meta = meta || options.meta;
    if (options.meta instanceof Error) {
      // Force converting the Error to an plain object now so it
      // will not be messed up by decycle() when cloning options
      options.meta = exports.clone(options.meta);
    }
    return String(options.formatter(exports.clone(options)));
  }

  output = timestamp ? timestamp + &#039; - &#039; : &#039;&#039;;
  if (showLevel) {
    output += options.colorize === &#039;all&#039; || options.colorize === &#039;level&#039; || options.colorize === true
      ? config.colorize(options.level)
      : options.level;
  }

  output += (options.align) ? &#039;\t&#039; : &#039;&#039;;
  output += (timestamp || showLevel) ? &#039;: &#039; : &#039;&#039;;
  output += options.label ? (&#039;[&#039; + options.label + &#039;] &#039;) : &#039;&#039;;
  output += options.colorize === &#039;all&#039; || options.colorize === &#039;message&#039;
    ? config.colorize(options.level, options.message)
    : options.message;

  if (meta !== null &amp;&amp; meta !== undefined) {
    if (typeof meta !== &#039;object&#039;) {
      output += &#039; &#039; + meta;
    }
    else if (Object.keys(meta).length &gt; 0) {
      if (typeof options.prettyPrint === &#039;function&#039;) {
        output += &#039; &#039; + options.prettyPrint(meta);
      } else if (options.prettyPrint) {
        output += &#039; &#039; + &#039;\n&#039; + util.inspect(meta, false, options.depth || null, options.colorize);
      } else if (
        options.humanReadableUnhandledException
          &amp;&amp; Object.keys(meta).length &gt;= 5
          &amp;&amp; meta.hasOwnProperty(&#039;date&#039;)
          &amp;&amp; meta.hasOwnProperty(&#039;process&#039;)
          &amp;&amp; meta.hasOwnProperty(&#039;os&#039;)
          &amp;&amp; meta.hasOwnProperty(&#039;trace&#039;)
          &amp;&amp; meta.hasOwnProperty(&#039;stack&#039;)) {

        //
        // If meta carries unhandled exception data serialize the stack nicely
        //
        var stack = meta.stack;
        delete meta.stack;
        delete meta.trace;
        output += &#039; &#039; + exports.serialize(meta);

        if (stack) {
          output += &#039;\n&#039; + stack.join(&#039;\n&#039;);
        }
      } else {
        output += &#039; &#039; + exports.serialize(meta);
      }
    }
  }

  return output;
};

exports.capitalize = function (str) {
  return str &amp;&amp; str[0].toUpperCase() + str.slice(1);
};

//
// ### function hash (str)
// #### @str {string} String to hash.
// Utility function for creating unique ids
// e.g. Profiling incoming HTTP requests on the same tick
//
exports.hash = function (str) {
  return crypto.createHash(&#039;sha1&#039;).update(str).digest(&#039;hex&#039;);
};

//
// ### function pad (n)
// Returns a padded string if `n &lt; 10`.
//
exports.pad = function (n) {
  return n &lt; 10 ? &#039;0&#039; + n.toString(10) : n.toString(10);
};

//
// ### function timestamp ()
// Returns a timestamp string for the current time.
//
exports.timestamp = function () {
  return new Date().toISOString();
};

//
// ### function serialize (obj, key)
// #### @obj {Object|literal} Object to serialize
// #### @key {string} **Optional** Optional key represented by obj in a larger object
// Performs simple comma-separated, `key=value` serialization for Loggly when
// logging to non-JSON inputs.
//
exports.serialize = function (obj, key) {
  // symbols cannot be directly casted to strings
  if (typeof key === &#039;symbol&#039;) {
    key = key.toString()
  }
  if (typeof obj === &#039;symbol&#039;) {
    obj = obj.toString()
  }

  if (obj === null) {
    obj = &#039;null&#039;;
  }
  else if (obj === undefined) {
    obj = &#039;undefined&#039;;
  }
  else if (obj === false) {
    obj = &#039;false&#039;;
  }

  if (typeof obj !== &#039;object&#039;) {
    return key ? key + &#039;=&#039; + obj : obj;
  }

  if (obj instanceof Buffer) {
    return key ? key + &#039;=&#039; + obj.toString(&#039;base64&#039;) : obj.toString(&#039;base64&#039;);
  }

  var msg = &#039;&#039;,
      keys = Object.keys(obj),
      length = keys.length;

  for (var i = 0; i &lt; length; i++) {
    if (Array.isArray(obj[keys[i]])) {
      msg += keys[i] + &#039;=[&#039;;

      for (var j = 0, l = obj[keys[i]].length; j &lt; l; j++) {
        msg += exports.serialize(obj[keys[i]][j]);
        if (j &lt; l - 1) {
          msg += &#039;, &#039;;
        }
      }

      msg += &#039;]&#039;;
    }
    else if (obj[keys[i]] instanceof Date) {
      msg += keys[i] + &#039;=&#039; + obj[keys[i]];
    }
    else {
      msg += exports.serialize(obj[keys[i]], keys[i]);
    }

    if (i &lt; length - 1) {
      msg += &#039;, &#039;;
    }
  }

  return msg;
};

//
// ### function tailFile (options, callback)
// #### @options {Object} Options for tail.
// #### @callback {function} Callback to execute on every line.
// `tail -f` a file. Options must include file.
//
exports.tailFile = function(options, callback) {
  var buffer = Buffer.alloc(64 * 1024)
    , decode = new StringDecoder(&#039;utf8&#039;)
    , stream = new Stream
    , buff = &#039;&#039;
    , pos = 0
    , row = 0;

  if (options.start === -1) {
    delete options.start;
  }

  stream.readable = true;
  stream.destroy = function() {
    stream.destroyed = true;
    stream.emit(&#039;end&#039;);
    stream.emit(&#039;close&#039;);
  };

  fs.open(options.file, &#039;a+&#039;, &#039;0644&#039;, function(err, fd) {
    if (err) {
      if (!callback) {
        stream.emit(&#039;error&#039;, err);
      } else {
        callback(err);
      }
      stream.destroy();
      return;
    }

    (function read() {
      if (stream.destroyed) {
        fs.close(fd, nop);
        return;
      }

      return fs.read(fd, buffer, 0, buffer.length, pos, function(err, bytes) {
        if (err) {
          if (!callback) {
            stream.emit(&#039;error&#039;, err);
          } else {
            callback(err);
          }
          stream.destroy();
          return;
        }

        if (!bytes) {
          if (buff) {
            if (options.start == null || row &gt; options.start) {
              if (!callback) {
                stream.emit(&#039;line&#039;, buff);
              } else {
                callback(null, buff);
              }
            }
            row++;
            buff = &#039;&#039;;
          }
          return setTimeout(read, 1000);
        }

        var data = decode.write(buffer.slice(0, bytes));

        if (!callback) {
          stream.emit(&#039;data&#039;, data);
        }

        var data = (buff + data).split(/\n+/)
          , l = data.length - 1
          , i = 0;

        for (; i &lt; l; i++) {
          if (options.start == null || row &gt; options.start) {
            if (!callback) {
              stream.emit(&#039;line&#039;, data[i]);
            } else {
              callback(null, data[i]);
            }
          }
          row++;
        }

        buff = data[l];

        pos += bytes;

        return read();
      });
    })();
  });

  if (!callback) {
    return stream;
  }

  return stream.destroy;
};

//
// ### function stringArrayToSet (array)
// #### @strArray {Array} Array of Set-elements as strings.
// #### @errMsg {string} **Optional** Custom error message thrown on invalid input.
// Returns a Set-like object with strArray&#039;s elements as keys (each with the value true).
//
exports.stringArrayToSet = function (strArray, errMsg) {
  if (typeof errMsg === &#039;undefined&#039;) {
    errMsg = &#039;Cannot make set from Array with non-string elements&#039;;
  }
  return strArray.reduce(function (set, el) {
    if (!(typeof el === &#039;string&#039; || el instanceof String)) {
      throw new Error(errMsg);
    }
    set[el] = true;
    return set;
  }, Object.create(null));
};

function nop () {}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
