<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/smtp-server/lib/smtp-connection.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/smtp-server/lib/smtp-connection.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1705</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">105.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">18.23</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const SMTPStream = require(&#039;./smtp-stream&#039;).SMTPStream;
const dns = require(&#039;dns&#039;);
const tls = require(&#039;tls&#039;);
const net = require(&#039;net&#039;);
const ipv6normalize = require(&#039;ipv6-normalize&#039;);
const sasl = require(&#039;./sasl&#039;);
const crypto = require(&#039;crypto&#039;);
const os = require(&#039;os&#039;);
const punycode = require(&#039;punycode.js&#039;);
const EventEmitter = require(&#039;events&#039;);
const base32 = require(&#039;base32.js&#039;);

const SOCKET_TIMEOUT = 60 * 1000;

// Enhanced Status Code mappings based on RFC 3463
const ENHANCED_STATUS_CODES = {
    // Success codes (2xx)
    200: &#039;2.0.0&#039;, // System status, or system help reply
    211: &#039;2.0.0&#039;, // System status, or system help reply
    214: &#039;2.0.0&#039;, // Help message
    220: &#039;2.0.0&#039;, // Service ready
    221: &#039;2.0.0&#039;, // Service closing transmission channel
    235: &#039;2.7.0&#039;, // Authentication successful
    250: &#039;2.0.0&#039;, // Requested mail action okay, completed
    251: &#039;2.1.5&#039;, // User not local; will forward
    252: &#039;2.1.5&#039;, // Cannot VRFY user, but will accept message
    334: &#039;3.7.0&#039;, // Server challenge for authentication
    354: &#039;2.0.0&#039;, // Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;

    // Temporary failure codes (4xx)
    420: &#039;4.4.2&#039;, // Timeout or connection lost (non-standard, used by some servers)
    421: &#039;4.4.2&#039;, // Service not available, closing transmission channel
    450: &#039;4.2.1&#039;, // Requested mail action not taken: mailbox unavailable
    451: &#039;4.3.0&#039;, // Requested action aborted: local error in processing
    452: &#039;4.2.2&#039;, // Requested action not taken: insufficient system storage
    454: &#039;4.7.0&#039;, // Temporary authentication failure

    // Permanent failure codes (5xx)
    500: &#039;5.5.2&#039;, // Syntax error, command unrecognized
    501: &#039;5.5.4&#039;, // Syntax error in parameters or arguments
    502: &#039;5.5.1&#039;, // Command not implemented
    503: &#039;5.5.1&#039;, // Bad sequence of commands
    504: &#039;5.5.4&#039;, // Command parameter not implemented
    521: &#039;5.3.2&#039;, // Machine does not accept mail
    523: &#039;5.3.4&#039;, // Message size exceeds server limit (non-standard, used by some servers)
    530: &#039;5.7.0&#039;, // Authentication required
    535: &#039;5.7.8&#039;, // Authentication credentials invalid
    538: &#039;5.7.0&#039;, // Must issue a STARTTLS command first (non-standard)
    550: &#039;5.1.1&#039;, // Requested action not taken: mailbox unavailable
    551: &#039;5.1.6&#039;, // User not local; please try forwarding
    552: &#039;5.2.2&#039;, // Requested mail action aborted: exceeded storage allocation
    553: &#039;5.1.3&#039;, // Requested action not taken: mailbox name not allowed
    554: &#039;5.6.0&#039;, // Transaction failed
    555: &#039;5.5.4&#039;, // MAIL FROM/RCPT TO parameters not recognized or not implemented
    556: &#039;5.1.10&#039;, // RCPT TO syntax error (non-standard)
    557: &#039;5.7.1&#039;, // Delivery not authorized (non-standard, used by some servers)
    558: &#039;5.2.3&#039; // Message too large for recipient (non-standard, used by some servers)
};

// Skip enhanced status codes for initial greeting and HELO/EHLO responses
const SKIPPED_COMMANDS_FOR_ENHANCED_STATUS_CODES = new Set([
  &#039;HELO&#039;,
  &#039;EHLO&#039;,
  &#039;LHLO&#039;
]);

// Context-specific enhanced status code mappings
const CONTEXTUAL_STATUS_CODES = {
    // Mail transaction specific codes
    MAIL_FROM_OK: &#039;2.1.0&#039;,           // Originator address valid
    RCPT_TO_OK: &#039;2.1.5&#039;,             // Destination address valid
    DATA_OK: &#039;2.6.0&#039;,                // Message accepted for delivery

    // Authentication specific codes
    AUTH_SUCCESS: &#039;2.7.0&#039;,           // Authentication successful
    AUTH_REQUIRED: &#039;5.7.0&#039;,          // Authentication required
    AUTH_INVALID: &#039;5.7.8&#039;,           // Authentication credentials invalid

    // Policy specific codes
    POLICY_VIOLATION: &#039;5.7.1&#039;,       // Delivery not authorized
    SPAM_REJECTED: &#039;5.7.1&#039;,          // Message refused

    // Mailbox specific codes
    MAILBOX_FULL: &#039;4.2.2&#039;,           // Mailbox full
    MAILBOX_NOT_FOUND: &#039;5.1.1&#039;,      // Mailbox does not exist
    MAILBOX_SYNTAX_ERROR: &#039;5.1.3&#039;,   // Invalid mailbox syntax

    // System specific codes
    SYSTEM_ERROR: &#039;4.3.0&#039;,           // System error
    SYSTEM_FULL: &#039;4.3.1&#039;,            // System storage exceeded

    // Network specific codes
    NETWORK_ERROR: &#039;4.4.0&#039;,          // Network routing error
    CONNECTION_TIMEOUT: &#039;4.4.2&#039;      // Connection timeout
};

/**
 * Creates a handler for new socket
 *
 * @constructor
 * @param {Object} server Server instance
 * @param {Object} socket Socket instance
 */
class SMTPConnection extends EventEmitter {
    constructor(server, socket, options) {
        super();

        options = options || {};
        // Random session ID, used for logging
        this.id = options.id || base32.encode(crypto.randomBytes(10)).toLowerCase();

        this.ignore = options.ignore;

        this._server = server;
        this._socket = socket;

        // session data (envelope, user etc.)
        this.session = this.session = {
            id: this.id
        };

        // how many messages have been processed
        this._transactionCounter = 0;

        // Do not allow input from client until initial greeting has been sent
        this._ready = false;

        // If true then the connection is currently being upgraded to TLS
        this._upgrading = false;

        // Set handler for incoming command and handler bypass detection by command name
        this._nextHandler = false;

        // Parser instance for the incoming stream
        this._parser = new SMTPStream();

        // Set handler for incoming commands
        this._parser.oncommand = (...args) =&gt; this._onCommand(...args);

        // if currently in data mode, this stream gets the content of incoming message
        this._dataStream = false;

        // If true, then the connection is using TLS
        this.session.secure = this.secure = !!this._server.options.secure;

        this.needsUpgrade = !!this._server.options.needsUpgrade;

        this.tlsOptions = this.secure &amp;&amp; !this.needsUpgrade &amp;&amp; this._socket.getCipher ? this._socket.getCipher() : false;

        // Store local and remote addresses for later usage
        this.localAddress = (options.localAddress || this._socket.localAddress || &#039;&#039;).replace(/^::ffff:/, &#039;&#039;);
        this.localPort = Number(options.localPort || this._socket.localPort) || 0;
        this.remoteAddress = (options.remoteAddress || this._socket.remoteAddress || &#039;&#039;).replace(/^::ffff:/, &#039;&#039;);
        this.remotePort = Number(options.remotePort || this._socket.remotePort) || 0;

        // normalize IPv6 addresses
        if (this.localAddress &amp;&amp; net.isIPv6(this.localAddress)) {
            this.localAddress = ipv6normalize(this.localAddress);
        }
        if (this.remoteAddress &amp;&amp; net.isIPv6(this.remoteAddress)) {
            this.remoteAddress = ipv6normalize(this.remoteAddress);
        }

        // Error counter - if too many commands in non-authenticated state are used, then disconnect
        this._unauthenticatedCommands = 0;

        // Max allowed unauthenticated commands
        this._maxAllowedUnauthenticatedCommands = this._server.options.maxAllowedUnauthenticatedCommands || 10;

        // Error counter - if too many invalid commands are used, then disconnect
        this._unrecognizedCommands = 0;

        // Server hostname for the greegins
        this.name = this._server.options.name || os.hostname();

        // Resolved hostname for remote IP address
        this.clientHostname = false;

        // The opening SMTP command (HELO, EHLO or LHLO)
        this.openingCommand = false;

        // The hostname client identifies itself with
        this.hostNameAppearsAs = false;

        // data passed from XCLIENT command
        this._xClient = new Map();

        // data passed from XFORWARD command
        this._xForward = new Map();

        // if true then can emit connection info
        this._canEmitConnection = true;

        // increment connection count
        this._closing = false;
        this._closed = false;
    }

    /**
     * Initiates the connection. Checks connection limits and reverse resolves client hostname. The client
     * is not allowed to send anything before init has finished otherwise &#039;You talk too soon&#039; error is returned
     */
    init() {
        // Setup event handlers for the socket
        this._setListeners(() =&gt; {
            // Check that connection limit is not exceeded
            if (this._server.options.maxClients &amp;&amp; this._server.connections.size &gt; this._server.options.maxClients) {
                return this.send(421, this.name + &#039; Too many connected clients, try again in a moment&#039;, false);
            }

            // Keep a small delay for detecting early talkers
            setTimeout(() =&gt; this.connectionReady(), 100);
        });
    }

    connectionReady(next) {
        // Resolve hostname for the remote IP
        let reverseCb = (err, hostnames) =&gt; {
            if (err) {
                this._server.logger.error(
                    {
                        tnx: &#039;connection&#039;,
                        cid: this.id,
                        host: this.remoteAddress,
                        hostname: this.clientHostname,
                        err
                    },
                    &#039;Reverse resolve for %s: %s&#039;,
                    this.remoteAddress,
                    err.message
                );
                // ignore resolve error
            }

            if (this._closing || this._closed) {
                return;
            }

            this.clientHostname = (hostnames &amp;&amp; hostnames.shift()) || &#039;[&#039; + this.remoteAddress + &#039;]&#039;;

            this._resetSession();

            let onSecureIfNeeded = next =&gt; {
                if (!this.session.secure) {
                    // no TLS
                    return next();
                }

                this.session.servername = this._socket.servername;
                this._server.onSecure(this._socket, this.session, err =&gt; {
                    if (err) {
                        return this._onError(err);
                    }
                    next();
                });
            };

            this._server.onConnect(this.session, err =&gt; {
                this._server.logger.info(
                    {
                        tnx: &#039;connection&#039;,
                        cid: this.id,
                        host: this.remoteAddress,
                        hostname: this.clientHostname
                    },
                    &#039;Connection from %s&#039;,
                    this.clientHostname
                );

                if (err) {
                    this.send(err.responseCode || 554, err.message, false);
                    return this.close();
                }

                onSecureIfNeeded(() =&gt; {
                    this._ready = true; // Start accepting data from input

                    if (!this._server.options.useXClient &amp;&amp; !this._server.options.useXForward) {
                        this.emitConnection();
                    }

                    this.send(
                        220,
                        this.name +
                            &#039; &#039; +
                            (this._server.options.lmtp ? &#039;LMTP&#039; : &#039;ESMTP&#039;) +
                            (this._server.options.banner ? &#039; &#039; + this._server.options.banner : &#039;&#039;),
                        false
                    );

                    if (typeof next === &#039;function&#039;) {
                        next();
                    }
                });
            });
        };

        // Skip reverse name resolution if disabled.
        if (this._server.options.disableReverseLookup) {
            return reverseCb(null, false);
        }

        // also make sure that we do not wait too long over the reverse resolve call
        let greetingSent = false;
        let reverseTimer = setTimeout(() =&gt; {
            clearTimeout(reverseTimer);
            if (greetingSent) {
                return;
            }
            greetingSent = true;
            reverseCb(new Error(&#039;Timeout&#039;));
        }, 1500);

        // Helper function to handle resolver results consistently
        const handleResolverResult = (...args) =&gt; {
            clearTimeout(reverseTimer);
            if (greetingSent) {
                return;
            }
            greetingSent = true;
            reverseCb(...args);
        };

        try {
            // Use custom resolver if provided, otherwise use default dns.reverse
            if (this._server.options.resolver &amp;&amp; typeof this._server.options.resolver.reverse === &#039;function&#039;) {
                this._server.options.resolver.reverse(this.remoteAddress.toString(), handleResolverResult);
            } else {
                // dns.reverse throws on invalid input, see https://github.com/nodejs/node/issues/3112
                dns.reverse(this.remoteAddress.toString(), handleResolverResult);
            }
        } catch (E) {
            clearTimeout(reverseTimer);
            if (greetingSent) {
                return;
            }
            greetingSent = true;
            reverseCb(E);
        }
    }

    /**
     * Send data to socket
     *
     * @param {Number} code Response code
     * @param {String|Array} data If data is Array, send a multi-line response
     * @param {String|Boolean} context Optional context for enhanced status codes
     */
    send(code, data, context) {
        let payload;
        let enhancedCode = this._getEnhancedStatusCode(code, context);

        if (Array.isArray(data)) {
            // Multi-line response - enhanced status code must appear on each line
            payload = data.map((line, i, arr) =&gt; {
                let prefix = code + (i &lt; arr.length - 1 ? &#039;-&#039; : &#039; &#039;);
                if (enhancedCode) {
                    prefix += enhancedCode + &#039; &#039;;
                }
                return prefix + line;
            }).join(&#039;\r\n&#039;);
        } else {
            // Single line response
            let parts = [code];
            if (enhancedCode) {
                parts.push(enhancedCode);
            }
            if (data) {
                parts.push(data);
            }
            payload = parts.join(&#039; &#039;);
        }

        if (code &gt;= 400) {
            this.session.error = payload;
        }

        // Ref. https://datatracker.ietf.org/doc/html/rfc4954#section-4
        if (code === 334 &amp;&amp; payload === &#039;334&#039;) {
            payload += &#039; &#039;;
        }

        if (this._socket &amp;&amp; !this._socket.destroyed &amp;&amp; this._socket.readyState === &#039;open&#039;) {
            this._socket.write(payload + &#039;\r\n&#039;);
            this._server.logger.debug(
                {
                    tnx: &#039;send&#039;,
                    cid: this.id,
                    user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                },
                &#039;S:&#039;,
                payload
            );
        }

        if (code === 421) {
            this.close();
        }
    }

    /**
     * Close socket
     */
    close() {
        if (!this._socket.destroyed &amp;&amp; this._socket.writable) {
            this._socket.end();
        }

        this._server.connections.delete(this);

        this._closing = true;
    }

    // PRIVATE METHODS

    /**
     * Setup socket event handlers
     */
    _setListeners(callback) {
        this._socket.on(&#039;close&#039;, hadError =&gt; this._onCloseEvent(hadError));
        this._socket.on(&#039;error&#039;, err =&gt; this._onError(err));
        this._socket.setTimeout(this._server.options.socketTimeout || SOCKET_TIMEOUT, () =&gt; this._onTimeout());
        this._socket.pipe(this._parser);
        if (!this.needsUpgrade) {
            return callback();
        }
        this.upgrade(() =&gt; false, callback);
    }

    _onCloseEvent(hadError) {
        this._server.logger.info(
            {
                tnx: &#039;close&#039;,
                cid: this.id,
                host: this.remoteAddress,
                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user,
                hadError
            },
            &#039;%s received &quot;close&quot; event from %s&#039; + (hadError ? &#039; after error&#039; : &#039;&#039;),
            this.id,
            this.remoteAddress
        );

        this._onClose();
    }

    /**
     * Fired when the socket is closed
     * @event
     */
    _onClose(/* hadError */) {
        if (this._parser) {
            this._parser.isClosed = true;
            this._socket.unpipe(this._parser);
            this._parser = false;
        }

        if (this._dataStream) {
            this._dataStream.unpipe();
            this._dataStream = null;
        }

        this._server.connections.delete(this);

        if (this._closed) {
            return;
        }

        this._closed = true;
        this._closing = false;

        this._server.logger.info(
            {
                tnx: &#039;close&#039;,
                cid: this.id,
                host: this.remoteAddress,
                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
            },
            &#039;Connection closed to %s&#039;,
            this.clientHostname || this.remoteAddress
        );
        setImmediate(() =&gt; this._server.onClose(this.session));
    }

    /**
     * Fired when an error occurs with the socket
     *
     * @event
     * @param {Error} err Error object
     */
    _onError(err) {
        err.remote = this.remoteAddress;
        this._server.logger.error(
            {
                err,
                tnx: &#039;error&#039;,
                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
            },
            &#039;%s %s %s&#039;,
            this.id,
            this.remoteAddress,
            err.message
        );

        if ((err.code === &#039;ECONNRESET&#039; || err.code === &#039;EPIPE&#039;) &amp;&amp; (!this.session.envelope || !this.session.envelope.mailFrom)) {
            // We got a connection error outside transaction. In most cases it means dirty
            // connection ending by the other party, so we can just ignore it
            this.close(); // mark connection as &#039;closing&#039;
            return;
        }

        this.emit(&#039;error&#039;, err);
    }

    /**
     * Fired when socket timeouts. Closes connection
     *
     * @event
     */
    _onTimeout() {
        this.send(421, &#039;Timeout - closing connection&#039;);
    }

    /**
     * Checks if a selected command is available and invokes it
     *
     * @param {Buffer} command Single line of data from the client
     * @param {Function} callback Callback to run once the command is processed
     */
    _onCommand(command, callback) {
        let commandName = (command || &#039;&#039;).toString().split(&#039; &#039;).shift().toUpperCase();
        this._server.logger.debug(
            {
                tnx: &#039;command&#039;,
                cid: this.id,
                command: commandName,
                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
            },
            &#039;C:&#039;,
            (command || &#039;&#039;).toString()
        );

        let handler;
        callback = callback || (() =&gt; false);

        // If server already closing then ignore commands
        if (this._server._closeTimeout) {
            return this.send(421, &#039;Server shutting down&#039;, commandName);
        }

        if (!this._ready) {
            // block spammers that send payloads before server greeting
            return this.send(421, this.name + &#039; You talk too soon&#039;, commandName);
        }

        // block malicious web pages that try to make SMTP calls from an AJAX request
        if (/^(OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT) \/.* HTTP\/\d\.\d$/i.test(command)) {
            return this.send(421, &#039;HTTP requests not allowed&#039;, commandName);
        }

        if (this._upgrading) {
            // ignore any commands before TLS upgrade is finished
            return callback();
        }

        if (this._nextHandler) {
            // If we already have a handler method queued up then use this
            handler = this._nextHandler;
            this._nextHandler = false;
        } else {
            // detect handler from the command name
            switch (commandName) {
                case &#039;HELO&#039;:
                case &#039;EHLO&#039;:
                case &#039;LHLO&#039;:
                    this.openingCommand = commandName;
                    break;
            }
            if (this._server.options.lmtp) {
                switch (commandName) {
                    case &#039;HELO&#039;:
                    case &#039;EHLO&#039;:
                        this.send(500, &#039;Error: &#039; + commandName + &#039; not allowed in LMTP server&#039;, false);
                        return setImmediate(callback);
                    case &#039;LHLO&#039;:
                        commandName = &#039;EHLO&#039;;
                        break;
                }
            }
            if (this._isSupported(commandName)) {
                handler = this[&#039;handler_&#039; + commandName];
            }
        }

        if (!handler) {
            // if the user makes more
            this._unrecognizedCommands++;
            if (this._unrecognizedCommands &gt;= 10) {
                return this.send(421, &#039;Error: too many unrecognized commands&#039;, commandName);
            }

            this.send(500, &#039;Error: command not recognized&#039;, commandName);
            return setImmediate(callback);
        }

        // block users that try to fiddle around without logging in
        if (
            !this.session.user &amp;&amp;
            this._isSupported(&#039;AUTH&#039;) &amp;&amp;
            !this._server.options.authOptional &amp;&amp;
            commandName !== &#039;AUTH&#039; &amp;&amp;
            this._maxAllowedUnauthenticatedCommands !== false
        ) {
            this._unauthenticatedCommands++;
            if (this._unauthenticatedCommands &gt;= this._maxAllowedUnauthenticatedCommands) {
                return this.send(421, &#039;Error: too many unauthenticated commands&#039;, commandName);
            }
        }

        if (!this.hostNameAppearsAs &amp;&amp; commandName &amp;&amp; [&#039;MAIL&#039;, &#039;RCPT&#039;, &#039;DATA&#039;, &#039;AUTH&#039;].includes(commandName)) {
            this.send(503, &#039;Error: send &#039; + (this._server.options.lmtp ? &#039;LHLO&#039; : &#039;HELO/EHLO&#039;) + &#039; first&#039;);
            return setImmediate(callback);
        }

        // Check if authentication is required
        if (!this.session.user &amp;&amp; this._isSupported(&#039;AUTH&#039;) &amp;&amp; [&#039;MAIL&#039;, &#039;RCPT&#039;, &#039;DATA&#039;].includes(commandName) &amp;&amp; !this._server.options.authOptional) {
            this.send(
                530,
                typeof this._server.options.authRequiredMessage === &#039;string&#039; ? this._server.options.authRequiredMessage : &#039;Error: authentication Required&#039;
            );
            return setImmediate(callback);
        }

        handler.call(this, command, callback);
    }

    /**
     * Checks that a command is available and is not listed in the disabled commands array
     *
     * @param {String} command Command name
     * @returns {Boolean} Returns true if the command can be used
     */
    _isSupported(command) {
        command = (command || &#039;&#039;).toString().trim().toUpperCase();
        return !this._server.options.disabledCommands.includes(command) &amp;&amp; typeof this[&#039;handler_&#039; + command] === &#039;function&#039;;
    }

    /**
     * Determines if enhanced status codes should be used
     * @returns {Boolean} True if enhanced status codes should be included in responses
     */
    _useEnhancedStatusCodes() {
        return !this._server.options.hideENHANCEDSTATUSCODES;
    }

    /**
     * Gets the appropriate enhanced status code for a given SMTP response code and context
     * @param {Number} code SMTP response code
     * @param {String|Boolean} context Optional context for more specific status codes
     * @returns {String} Enhanced status code or empty string if not applicable
     */
    _getEnhancedStatusCode(code, context) {
        if (context === false || !this._useEnhancedStatusCodes()) {
            return &#039;&#039;;
        }

        // Skip 3xx responses as per RFC 2034
        if (code &gt;= 300 &amp;&amp; code &lt; 400) {
            return &#039;&#039;;
        }

        // Skip enhanced status codes for initial greeting and HELO/EHLO responses
        if (context &amp;&amp; SKIPPED_COMMANDS_FOR_ENHANCED_STATUS_CODES.has(context)) {
            return &#039;&#039;;
        }

        // Use contextual codes if available
        if (context &amp;&amp; CONTEXTUAL_STATUS_CODES[context]) {
            return CONTEXTUAL_STATUS_CODES[context];
        }

        // Use default mapping
        if (ENHANCED_STATUS_CODES[code]) {
            return ENHANCED_STATUS_CODES[code];
        }

        // 2xx fallback
        if (code &gt;= 200 &amp;&amp; code &lt; 300) {
            return &#039;2.0.0&#039;;
        }

        // 4xx (transient failure)
        if (code &gt;= 400 &amp;&amp; code &lt; 500) {
            return &#039;4.0.0&#039;;
        }

        // 5xx (permanent failure)
        if (code &gt;= 500) {
            return &#039;5.0.0&#039;;
        }

        // safeguard (non-spec; but should never occur)
        return &#039;&#039;;
    }

    /**
     * Parses commands like MAIL FROM and RCPT TO. Returns an object with the address and optional arguments.
     *
     * @param {[type]} name Address type, eg &#039;mail from&#039; or &#039;rcpt to&#039;
     * @param {[type]} command Data payload to parse
     * @returns {Object|Boolean} Parsed address in the form of {address:, args: {}} or false if parsing failed
     */
    _parseAddressCommand(name, command) {
        command = (command || &#039;&#039;).toString();
        name = (name || &#039;&#039;).toString().trim().toUpperCase();

        let parts = command.split(&#039;:&#039;);
        command = parts.shift().trim().toUpperCase();
        parts = parts.join(&#039;:&#039;).trim().split(/\s+/);

        let address = parts.shift();
        let args = false;
        let invalid = false;

        if (name !== command) {
            return false;
        }

        if (!/^&lt;[^&lt;&gt;]*&gt;$/.test(address)) {
            invalid = true;
        } else {
            address = address.substr(1, address.length - 2);
        }

        parts.forEach(part =&gt; {
            part = part.split(&#039;=&#039;);
            let key = part.shift().toUpperCase();
            let value = part.join(&#039;=&#039;) || true;

            if (typeof value === &#039;string&#039;) {
                // decode &#039;xtext&#039;
                value = value.replace(/\+([0-9A-F]{2})/g, (match, hex) =&gt; unescape(&#039;%&#039; + hex));
            }

            if (!args) {
                args = {};
            }

            args[key] = value;
        });

        if (address) {
            // enforce unycode
            address = address.split(&#039;@&#039;);
            if (address.length !== 2 || !address[0] || !address[1]) {
                // really bad e-mail address validation. was not able to use joi because of the missing unicode support
                invalid = true;
            } else {
                try {
                    address = [address[0] || &#039;&#039;, &#039;@&#039;, punycode.toUnicode(address[1] || &#039;&#039;)].join(&#039;&#039;);
                } catch (E) {
                    this._server.logger.error(
                        {
                            tnx: &#039;punycode&#039;,
                            cid: this.id,
                            user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                        },
                        &#039;Failed to process punycode domain &quot;%s&quot;. error=%s&#039;,
                        address[1],
                        E.message
                    );
                    address = [address[0] || &#039;&#039;, &#039;@&#039;, address[1] || &#039;&#039;].join(&#039;&#039;);
                }
            }
        }

        return invalid
            ? false
            : {
                  address,
                  args
              };
    }

    /**
     * Resets or sets up a new session. We reuse existing session object to keep
     * application specific data.
     */
    _resetSession() {
        let session = this.session;

        // reset data that might be overwritten
        session.localAddress = this.localAddress;
        session.localPort = this.localPort;
        session.remoteAddress = this.remoteAddress;
        session.remotePort = this.remotePort;
        session.clientHostname = this.clientHostname;
        session.openingCommand = this.openingCommand;
        session.hostNameAppearsAs = this.hostNameAppearsAs;
        session.xClient = this._xClient;
        session.xForward = this._xForward;
        session.transmissionType = this._transmissionType();

        session.tlsOptions = this.tlsOptions;

        // reset transaction properties
        session.envelope = {
            mailFrom: false,
            rcptTo: []
        };

        if (!this._server.options.hideDSN)
            session.envelope.dsn = {
                ret: null,  // RET parameter from MAIL FROM (FULL or HDRS)
                envid: null // ENVID parameter from MAIL FROM
            };

        session.transaction = this._transactionCounter + 1;
    }

    /**
     * Returns current transmission type
     *
     * @return {String} Transmission type
     */
    _transmissionType() {
        let type = this._server.options.lmtp ? &#039;LMTP&#039; : &#039;SMTP&#039;;

        if (this.openingCommand === &#039;EHLO&#039;) {
            type = &#039;E&#039; + type;
        }

        if (this.secure) {
            type += &#039;S&#039;;
        }

        if (this.session.user) {
            type += &#039;A&#039;;
        }

        return type;
    }

    emitConnection() {
        if (!this._canEmitConnection) {
            return;
        }
        this._canEmitConnection = false;
        this.emit(&#039;connect&#039;, {
            id: this.id,
            localAddress: this.localAddress,
            localPort: this.localPort,
            remoteAddress: this.remoteAddress,
            remotePort: this.remotePort,
            hostNameAppearsAs: this.hostNameAppearsAs,
            clientHostname: this.clientHostname
        });
    }

    // COMMAND HANDLERS

    /**
     * Processes EHLO. Requires valid hostname as the single argument.
     */
    handler_EHLO(command, callback) {
        let parts = command.toString().trim().split(/\s+/);
        let hostname = parts[1] || &#039;&#039;;

        if (parts.length !== 2) {
            this.send(501, &#039;Error: syntax: &#039; + (this._server.options.lmtp ? &#039;LHLO&#039; : &#039;EHLO&#039;) + &#039; hostname&#039;, false);
            return callback();
        }

        this.hostNameAppearsAs = hostname.toLowerCase();

        let features = [&#039;PIPELINING&#039;, &#039;8BITMIME&#039;, &#039;SMTPUTF8&#039;, &#039;ENHANCEDSTATUSCODES&#039;, &#039;DSN&#039;].filter(feature =&gt; !this._server.options[&#039;hide&#039; + feature]);

        if (this._server.options.authMethods.length &amp;&amp; this._isSupported(&#039;AUTH&#039;) &amp;&amp; !this.session.user) {
            features.push([&#039;AUTH&#039;].concat(this._server.options.authMethods).join(&#039; &#039;));
        }

        if (!this.secure &amp;&amp; this._isSupported(&#039;STARTTLS&#039;) &amp;&amp; !this._server.options.hideSTARTTLS) {
            features.push(&#039;STARTTLS&#039;);
        }

        if (this._server.options.size) {
            features.push(&#039;SIZE&#039; + (this._server.options.hideSize ? &#039;&#039; : &#039; &#039; + this._server.options.size));
        }

        // XCLIENT ADDR removes any special privileges for the client
        if (!this._xClient.has(&#039;ADDR&#039;) &amp;&amp; this._server.options.useXClient &amp;&amp; this._isSupported(&#039;XCLIENT&#039;)) {
            features.push(&#039;XCLIENT NAME ADDR PORT PROTO HELO LOGIN&#039;);
        }

        // If client has already issued XCLIENT ADDR then it does not have privileges for XFORWARD anymore
        if (!this._xClient.has(&#039;ADDR&#039;) &amp;&amp; this._server.options.useXForward &amp;&amp; this._isSupported(&#039;XFORWARD&#039;)) {
            features.push(&#039;XFORWARD NAME ADDR PORT PROTO HELO IDENT SOURCE&#039;);
        }

        this._resetSession(); // EHLO is effectively the same as RSET
        this.send(250, [this.name + &#039; Nice to meet you, &#039; + this.clientHostname].concat(features || []), false);

        callback();
    }

    /**
     * Processes HELO. Requires valid hostname as the single argument.
     */
    handler_HELO(command, callback) {
        let parts = command.toString().trim().split(/\s+/);
        let hostname = parts[1] || &#039;&#039;;

        if (parts.length !== 2) {
            this.send(501, &#039;Error: Syntax: HELO hostname&#039;, false);
            return callback();
        }

        this.hostNameAppearsAs = hostname.toLowerCase();

        this._resetSession(); // HELO is effectively the same as RSET
        this.send(250, this.name + &#039; Nice to meet you, &#039; + this.clientHostname, false);

        callback();
    }

    /**
     * Processes QUIT. Closes the connection
     */
    handler_QUIT(command, callback) {
        this.send(221, &#039;Bye&#039;);
        this.close();
        callback();
    }

    /**
     * Processes NOOP. Does nothing but keeps the connection alive
     */
    handler_NOOP(command, callback) {
        this.send(250, &#039;OK&#039;);
        callback();
    }

    /**
     * Processes RSET. Resets user and session info
     */
    handler_RSET(command, callback) {
        this._resetSession();

        this.send(250, &#039;Flushed&#039;);
        callback();
    }

    /**
     * Processes HELP. Responds with url to RFC
     */
    handler_HELP(command, callback) {
        this.send(214, &#039;See https://tools.ietf.org/html/rfc5321 for details&#039;);
        callback();
    }

    /**
     * Processes VRFY. Does not verify anything
     */
    handler_VRFY(command, callback) {
        this.send(252, &#039;Try to send something. No promises though&#039;);
        callback();
    }

    /**
     * Overrides connection info
     * http://www.postfix.org/XCLIENT_README.html
     *
     * TODO: add unit tests
     */
    handler_XCLIENT(command, callback) {
        // check if user is authorized to perform this command
        if (this._xClient.has(&#039;ADDR&#039;) || !this._server.options.useXClient) {
            this.send(550, &#039;Error: Not allowed&#039;);
            return callback();
        }

        // not allowed to change properties if already processing mail
        if (this.session.envelope.mailFrom) {
            this.send(503, &#039;Error: Mail transaction in progress&#039;);
            return callback();
        }

        let allowedKeys = [&#039;NAME&#039;, &#039;ADDR&#039;, &#039;PORT&#039;, &#039;PROTO&#039;, &#039;HELO&#039;, &#039;LOGIN&#039;];
        let parts = command.toString().trim().split(/\s+/);
        let key, value;
        let data = new Map();
        parts.shift(); // remove XCLIENT prefix

        if (!parts.length) {
            this.send(501, &#039;Error: Bad command parameter syntax&#039;);
            return callback();
        }

        let loginValue = false;

        // parse and validate arguments
        for (let i = 0, len = parts.length; i &lt; len; i++) {
            value = parts[i].split(&#039;=&#039;);
            key = value.shift();
            if (value.length !== 1 || !allowedKeys.includes(key.toUpperCase())) {
                this.send(501, &#039;Error: Bad command parameter syntax&#039;);
                return callback();
            }
            key = key.toUpperCase();

            // value is xtext
            value = (value[0] || &#039;&#039;).replace(/\+([0-9A-F]{2})/g, (match, hex) =&gt; unescape(&#039;%&#039; + hex));

            if ([&#039;[UNAVAILABLE]&#039;, &#039;[TEMPUNAVAIL]&#039;].includes(value.toUpperCase())) {
                value = false;
            }

            if (data.has(key)) {
                // ignore duplicate keys
                continue;
            }

            data.set(key, value);

            switch (key) {
                // handled outside the switch
                case &#039;LOGIN&#039;:
                    loginValue = value;
                    break;
                case &#039;ADDR&#039;:
                    if (value) {
                        value = value.replace(/^IPV6:/i, &#039;&#039;); // IPv6 addresses are prefixed with &quot;IPv6:&quot;

                        if (!net.isIP(value)) {
                            this.send(501, &#039;Error: Bad command parameter syntax. Invalid address&#039;);
                            return callback();
                        }

                        if (net.isIPv6(value)) {
                            value = ipv6normalize(value);
                        }

                        this._server.logger.info(
                            {
                                tnx: &#039;xclient&#039;,
                                cid: this.id,
                                xclientKey: &#039;ADDR&#039;,
                                xclient: value,
                                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                            },
                            &#039;XCLIENT from %s through %s&#039;,
                            value,
                            this.remoteAddress
                        );

                        // store original value for reference as ADDR:DEFAULT
                        if (!this._xClient.has(&#039;ADDR:DEFAULT&#039;)) {
                            this._xClient.set(&#039;ADDR:DEFAULT&#039;, this.remoteAddress);
                        }

                        this.remoteAddress = value;
                        this.hostNameAppearsAs = false; // reset client provided hostname, require HELO/EHLO
                    }
                    break;
                case &#039;NAME&#039;:
                    value = value || &#039;&#039;;
                    this._server.logger.info(
                        {
                            tnx: &#039;xclient&#039;,
                            cid: this.id,
                            xclientKey: &#039;NAME&#039;,
                            xclient: value,
                            user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                        },
                        &#039;XCLIENT hostname resolved as &quot;%s&quot;&#039;,
                        value
                    );

                    // store original value for reference as NAME:DEFAULT
                    if (!this._xClient.has(&#039;NAME:DEFAULT&#039;)) {
                        this._xClient.set(&#039;NAME:DEFAULT&#039;, this.clientHostname || &#039;&#039;);
                    }

                    this.clientHostname = value.toLowerCase();
                    break;
                case &#039;PORT&#039;:
                    value = Number(value) || &#039;&#039;;
                    this._server.logger.info(
                        {
                            tnx: &#039;xclient&#039;,
                            cid: this.id,
                            xclientKey: &#039;PORT&#039;,
                            xclient: value,
                            user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                        },
                        &#039;XCLIENT remote port resolved as &quot;%s&quot;&#039;,
                        value
                    );

                    // store original value for reference as NAME:DEFAULT
                    if (!this._xClient.has(&#039;PORT:DEFAULT&#039;)) {
                        this._xClient.set(&#039;PORT:DEFAULT&#039;, this.remotePort || &#039;&#039;);
                    }

                    this.remotePort = value;
                    break;
                default:
                // other values are not relevant
            }
            this._xClient.set(key, value);
        }

        let checkLogin = done =&gt; {
            if (typeof loginValue !== &#039;string&#039;) {
                return done();
            }
            if (!loginValue) {
                // clear authentication session?
                this._server.logger.info(
                    {
                        tnx: &#039;deauth&#039;,
                        cid: this.id,
                        user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                    },
                    &#039;User deauthenticated using %s&#039;,
                    &#039;XCLIENT&#039;
                );
                this.session.user = false;
                return done();
            }
            let method = &#039;SASL_XCLIENT&#039;;
            sasl[method].call(this, [loginValue], err =&gt; {
                if (err) {
                    this.send(550, err.message);
                    this.close();
                    return;
                }
                done();
            });
        };

        // Use [ADDR] if NAME was empty
        if (this.remoteAddress &amp;&amp; !this.clientHostname) {
            this.clientHostname = &#039;[&#039; + this.remoteAddress + &#039;]&#039;;
        }

        if (data.has(&#039;ADDR&#039;)) {
            this.emitConnection();
        }

        checkLogin(() =&gt; {
            // success
            this.send(
                220,
                this.name + &#039; &#039; + (this._server.options.lmtp ? &#039;LMTP&#039; : &#039;ESMTP&#039;) + (this._server.options.banner ? &#039; &#039; + this._server.options.banner : &#039;&#039;)
            );
            callback();
        });
    }

    /**
     * Processes XFORWARD data
     * http://www.postfix.org/XFORWARD_README.html
     *
     * TODO: add unit tests
     */
    handler_XFORWARD(command, callback) {
        // check if user is authorized to perform this command
        if (!this._server.options.useXForward) {
            this.send(550, &#039;Error: Not allowed&#039;);
            return callback();
        }

        // not allowed to change properties if already processing mail
        if (this.session.envelope.mailFrom) {
            this.send(503, &#039;Error: Mail transaction in progress&#039;);
            return callback();
        }

        let allowedKeys = [&#039;NAME&#039;, &#039;ADDR&#039;, &#039;PORT&#039;, &#039;PROTO&#039;, &#039;HELO&#039;, &#039;IDENT&#039;, &#039;SOURCE&#039;];
        let parts = command.toString().trim().split(/\s+/);
        let key, value;
        let data = new Map();
        let hasAddr = false;
        parts.shift(); // remove XFORWARD prefix

        if (!parts.length) {
            this.send(501, &#039;Error: Bad command parameter syntax&#039;);
            return callback();
        }

        // parse and validate arguments
        for (let i = 0, len = parts.length; i &lt; len; i++) {
            value = parts[i].split(&#039;=&#039;);
            key = value.shift();
            if (value.length !== 1 || !allowedKeys.includes(key.toUpperCase())) {
                this.send(501, &#039;Error: Bad command parameter syntax&#039;);
                return callback();
            }
            key = key.toUpperCase();
            if (data.has(key)) {
                // ignore duplicate keys
                continue;
            }

            // value is xtext
            value = (value[0] || &#039;&#039;).replace(/\+([0-9A-F]{2})/g, (match, hex) =&gt; unescape(&#039;%&#039; + hex));

            if (value.toUpperCase() === &#039;[UNAVAILABLE]&#039;) {
                value = false;
            }

            data.set(key, value);

            switch (key) {
                case &#039;ADDR&#039;:
                    if (value) {
                        value = value.replace(/^IPV6:/i, &#039;&#039;); // IPv6 addresses are prefixed with &quot;IPv6:&quot;

                        if (!net.isIP(value)) {
                            this.send(501, &#039;Error: Bad command parameter syntax. Invalid address&#039;);
                            return callback();
                        }

                        if (net.isIPv6(value)) {
                            value = ipv6normalize(value);
                        }

                        this._server.logger.info(
                            {
                                tnx: &#039;xforward&#039;,
                                cid: this.id,
                                xforwardKey: &#039;ADDR&#039;,
                                xforward: value,
                                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                            },
                            &#039;XFORWARD from %s through %s&#039;,
                            value,
                            this.remoteAddress
                        );

                        // store original value for reference as ADDR:DEFAULT
                        if (!this._xClient.has(&#039;ADDR:DEFAULT&#039;)) {
                            this._xClient.set(&#039;ADDR:DEFAULT&#039;, this.remoteAddress);
                        }

                        hasAddr = true;
                        this.remoteAddress = value;
                    }
                    break;
                case &#039;NAME&#039;:
                    value = value || &#039;&#039;;
                    this._server.logger.info(
                        {
                            tnx: &#039;xforward&#039;,
                            cid: this.id,
                            xforwardKey: &#039;NAME&#039;,
                            xforward: value,
                            user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                        },
                        &#039;XFORWARD hostname resolved as &quot;%s&quot;&#039;,
                        value
                    );
                    this.clientHostname = value.toLowerCase();
                    break;
                case &#039;PORT&#039;:
                    value = Number(value) || 0;
                    this._server.logger.info(
                        {
                            tnx: &#039;xforward&#039;,
                            cid: this.id,
                            xforwardKey: &#039;PORT&#039;,
                            xforward: value,
                            user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                        },
                        &#039;XFORWARD port resolved as &quot;%s&quot;&#039;,
                        value
                    );
                    this.remotePort = value;
                    break;
                case &#039;HELO&#039;:
                    value = (value || &#039;&#039;).toString().toLowerCase();
                    this._server.logger.info(
                        {
                            tnx: &#039;xforward&#039;,
                            cid: this.id,
                            xforwardKey: &#039;HELO&#039;,
                            xforward: value,
                            user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                        },
                        &#039;XFORWARD HELO name resolved as &quot;%s&quot;&#039;,
                        value
                    );
                    this.hostNameAppearsAs = value;
                    break;
                default:
                // other values are not relevant
            }
            this._xForward.set(key, value);
        }

        if (hasAddr) {
            this._canEmitConnection = true;
            this.emitConnection();
        }

        // success
        this.send(250, &#039;OK&#039;);
        callback();
    }

    /**
     * Upgrades connection to TLS if possible
     */
    handler_STARTTLS(command, callback) {
        if (this.secure) {
            this.send(503, &#039;Error: TLS already active&#039;);
            return callback();
        }

        this.send(220, &#039;Ready to start TLS&#039;);

        this.upgrade(callback);
    }

    /**
     * Check if selected authentication is available and delegate auth data to SASL
     */
    handler_AUTH(command, callback) {
        let args = command.toString().trim().split(/\s+/);
        let method;
        let handler;

        args.shift(); // remove AUTH
        method = (args.shift() || &#039;&#039;).toString().toUpperCase(); // get METHOD and keep additional arguments in the array
        handler = sasl[&#039;SASL_&#039; + method];
        handler = handler ? handler.bind(this) : handler;

        if (!this.secure &amp;&amp; this._isSupported(&#039;STARTTLS&#039;) &amp;&amp; !this._server.options.hideSTARTTLS &amp;&amp; !this._server.options.allowInsecureAuth) {
            this.send(538, &#039;Error: Must issue a STARTTLS command first&#039;);
            return callback();
        }

        if (this.session.user) {
            this.send(503, &#039;Error: No identity changes permitted&#039;);
            return callback();
        }

        if (!this._server.options.authMethods.includes(method) || typeof handler !== &#039;function&#039;) {
            this.send(504, &#039;Error: Unrecognized authentication type&#039;);
            return callback();
        }

        handler(args, callback);
    }

    /**
     * Processes MAIL FROM command, parses address and extra arguments
     */
    handler_MAIL(command, callback) {
        let parsed = this._parseAddressCommand(&#039;mail from&#039;, command);

        // in case we still haven&#039;t informed about the new connection emit it
        this.emitConnection();

        // sender address can be empty, so we only check if parsing failed or not
        if (!parsed) {
            this.send(501, &#039;Error: Bad sender address syntax&#039;, &#039;MAILBOX_SYNTAX_ERROR&#039;);
            return callback();
        }

        if (this.session.envelope.mailFrom) {
            this.send(503, &#039;Error: nested MAIL command&#039;);
            return callback();
        }

        if (!this._server.options.hideSize &amp;&amp; this._server.options.size &amp;&amp; parsed.args.SIZE &amp;&amp; Number(parsed.args.SIZE) &gt; this._server.options.size) {
            this.send(552, &#039;Error: message exceeds fixed maximum message size &#039; + this._server.options.size, &#039;SYSTEM_FULL&#039;);
            return callback();
        }

        // Process DSN parameters if DSN is supported
        if (!this._server.options.hideDSN) {
            // Validate RET parameter
            if (parsed.args.RET) {
                const ret = parsed.args.RET.toUpperCase();
                if (ret !== &#039;FULL&#039; &amp;&amp; ret !== &#039;HDRS&#039;) {
                    this.send(501, &#039;Error: RET parameter must be FULL or HDRS&#039;);
                    return callback();
                }
                this.session.envelope.dsn.ret = ret;
            }

            // Store ENVID parameter
            if (parsed.args.ENVID) {
                this.session.envelope.dsn.envid = parsed.args.ENVID;
            }
        }

        this._server.onMailFrom(parsed, this.session, err =&gt; {
            if (err) {
                this.send(err.responseCode || 550, err.message);
                return callback();
            }

            this.session.envelope.mailFrom = parsed;

            this.send(250, &#039;Accepted&#039;, &#039;MAIL_FROM_OK&#039;);
            callback();
        });
    }

    /**
     * Processes RCPT TO command, parses address and extra arguments
     */
    handler_RCPT(command, callback) {
        let parsed = this._parseAddressCommand(&#039;rcpt to&#039;, command);

        // recipient address can not be empty
        if (!parsed || !parsed.address) {
            this.send(501, &#039;Error: Bad recipient address syntax&#039;, &#039;MAILBOX_SYNTAX_ERROR&#039;);
            return callback();
        }

        if (!this.session.envelope.mailFrom) {
            this.send(503, &#039;Error: need MAIL command&#039;);
            return callback();
        }

        // Process DSN parameters if DSN is supported
        if (!this._server.options.hideDSN) {
            // Validate NOTIFY parameter
            if (parsed.args.NOTIFY) {
                const notify = parsed.args.NOTIFY.toUpperCase();
                const validNotifyValues = [&#039;NEVER&#039;, &#039;SUCCESS&#039;, &#039;FAILURE&#039;, &#039;DELAY&#039;];
                const notifyValues = notify.split(&#039;,&#039;);

                for (let value of notifyValues) {
                    if (!validNotifyValues.includes(value)) {
                        this.send(501, &#039;Error: NOTIFY parameter must be NEVER, SUCCESS, FAILURE, or DELAY&#039;);
                        return callback();
                    }
                }

                // NEVER cannot be combined with other values
                if (notifyValues.includes(&#039;NEVER&#039;) &amp;&amp; notifyValues.length &gt; 1) {
                    this.send(501, &#039;Error: NOTIFY=NEVER cannot be combined with other values&#039;);
                    return callback();
                }

                parsed.dsn = parsed.dsn || {};
                parsed.dsn.notify = notifyValues;
            }

            // Store ORCPT parameter
            if (parsed.args.ORCPT) {
                parsed.dsn = parsed.dsn || {};
                parsed.dsn.orcpt = parsed.args.ORCPT;
            }
        }

        this._server.onRcptTo(parsed, this.session, err =&gt; {
            if (err) {
                this.send(err.responseCode || 550, err.message);
                return callback();
            }

            // check if the address is already used, if so then overwrite
            for (let i = 0, len = this.session.envelope.rcptTo.length; i &lt; len; i++) {
                if (this.session.envelope.rcptTo[i].address.toLowerCase() === parsed.address.toLowerCase()) {
                    this.session.envelope.rcptTo[i] = parsed;
                    parsed = false;
                    break;
                }
            }

            if (parsed) {
                this.session.envelope.rcptTo.push(parsed);
            }

            this.send(250, &#039;Accepted&#039;, &#039;RCPT_TO_OK&#039;);
            callback();
        });
    }

    /**
     * Processes DATA by forwarding incoming stream to the onData handler
     */
    handler_DATA(command, callback) {
        if (!this.session.envelope.rcptTo.length) {
            this.send(503, &#039;Error: need RCPT command&#039;);
            return callback();
        }

        if (!this._parser) {
            return callback();
        }

        this._dataStream = this._parser.startDataMode(this._server.options.size);

        let close = (err, message) =&gt; {
            let i, len;

            this._server.logger.debug(
                {
                    tnx: &#039;data&#039;,
                    cid: this.id,
                    bytes: this._parser.dataBytes,
                    user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
                },
                &#039;C: &lt;%s bytes of DATA&gt;&#039;,
                this._parser.dataBytes
            );

            if (typeof this._dataStream === &#039;object&#039; &amp;&amp; this._dataStream &amp;&amp; this._dataStream.readable) {
                this._dataStream.removeAllListeners();
            }

            if (err) {
                if (this._server.options.lmtp) {
                    // separate error response for every recipient when using LMTP
                    for (i = 0, len = this.session.envelope.rcptTo.length; i &lt; len; i++) {
                        this.send(err.responseCode || 450, err.message);
                    }
                } else {
                    // single error response when using SMTP
                    this.send(err.responseCode || 450, err.message);
                }
            } else if (Array.isArray(message)) {
                // separate responses for every recipient when using LMTP
                message.forEach(response =&gt; {
                    if (/Error\]$/i.test(Object.prototype.toString.call(response))) {
                        this.send(response.responseCode || 450, response.message);
                    } else {
                        this.send(250, typeof response === &#039;string&#039; ? response : &#039;OK: message accepted&#039;, &#039;DATA_OK&#039;);
                    }
                });
            } else if (this._server.options.lmtp) {
                // separate success response for every recipient when using LMTP
                for (i = 0, len = this.session.envelope.rcptTo.length; i &lt; len; i++) {
                    this.send(250, typeof message === &#039;string&#039; ? message : &#039;OK: message accepted&#039;, &#039;DATA_OK&#039;);
                }
            } else {
                // single success response when using SMTP
                this.send(250, typeof message === &#039;string&#039; ? message : &#039;OK: message queued&#039;, &#039;DATA_OK&#039;);
            }

            this._transactionCounter++;

            this._unrecognizedCommands = 0; // reset unrecognized commands counter
            this._resetSession(); // reset session state

            if (typeof this._parser === &#039;object&#039; &amp;&amp; this._parser) {
                this._parser.continue();
            }
        };

        this._server.onData(this._dataStream, this.session, (err, message) =&gt; {
            // ensure _dataStream is an object and not set to null by premature closing
            // do not continue until the stream has actually ended
            if (typeof this._dataStream === &#039;object&#039; &amp;&amp; this._dataStream &amp;&amp; this._dataStream.readable) {
                this._dataStream.on(&#039;end&#039;, () =&gt; close(err, message));
                return;
            }
            close(err, message);
        });

        this.send(354, &#039;End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;&#039;);
        callback();
    }

    // Dummy handlers for some old sendmail specific commands

    /**
     * Processes sendmail WIZ command, upgrades to &quot;wizard mode&quot;
     */
    handler_WIZ(command, callback) {
        let args = command.toString().trim().split(/\s+/);
        let password;

        args.shift(); // remove WIZ
        password = (args.shift() || &#039;&#039;).toString();

        // require password argument
        if (!password) {
            this.send(500, &#039;You are no wizard!&#039;);
            return callback();
        }

        // all passwords pass validation, so everyone is a wizard!
        this.session.isWizard = true;
        this.send(200, &#039;Please pass, oh mighty wizard&#039;);
        callback();
    }

    /**
     * Processes sendmail SHELL command, should return interactive shell but this is a dummy function
     * so no actual shell is provided to the client
     */
    handler_SHELL(command, callback) {
        this._server.logger.info(
            {
                tnx: &#039;shell&#039;,
                cid: this.id,
                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
            },
            &#039;Client tried to invoke SHELL&#039;
        );

        if (!this.session.isWizard) {
            this.send(500, &#039;Mere mortals must not mutter that mantra&#039;);
            return callback();
        }

        this.send(500, &#039;Error: Invoking shell is not allowed. This incident will be reported.&#039;);
        callback();
    }

    /**
     * Processes sendmail KILL command
     */
    handler_KILL(command, callback) {
        this._server.logger.info(
            {
                tnx: &#039;kill&#039;,
                cid: this.id,
                user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user
            },
            &#039;Client tried to invoke KILL&#039;
        );

        this.send(500, &#039;Can not kill Mom&#039;);
        callback();
    }

    upgrade(callback, secureCallback) {
        this._socket.unpipe(this._parser);
        this._upgrading = true;
        setImmediate(callback); // resume input stream

        let secureContext = this._server.secureContext.get(&#039;*&#039;);
        let socketOptions = {
            secureContext,
            isServer: true,
            server: this._server.server,

            SNICallback: this._server.options.SNICallback
        };

        // Apply additional socket options if these are set in the server options
        [&#039;requestCert&#039;, &#039;rejectUnauthorized&#039;, &#039;NPNProtocols&#039;, &#039;SNICallback&#039;, &#039;session&#039;, &#039;requestOCSP&#039;].forEach(key =&gt; {
            if (key in this._server.options) {
                socketOptions[key] = this._server.options[key];
            }
        });

        // remove all listeners from the original socket besides the error handler
        this._socket.removeAllListeners();
        this._socket.on(&#039;error&#039;, err =&gt; this._onError(err));

        // upgrade connection
        let secureSocket = new tls.TLSSocket(this._socket, socketOptions);

        secureSocket.once(&#039;close&#039;, hadError =&gt; this._onCloseEvent(hadError));
        secureSocket.once(&#039;error&#039;, err =&gt; this._onError(err));
        secureSocket.once(&#039;_tlsError&#039;, err =&gt; this._onError(err));
        secureSocket.once(&#039;clientError&#039;, err =&gt; this._onError(err));

        secureSocket.setTimeout(this._server.options.socketTimeout || SOCKET_TIMEOUT, () =&gt; this._onTimeout());

        secureSocket.on(&#039;secure&#039;, () =&gt; {
            this.session.secure = this.secure = true;
            this._socket = secureSocket;
            this._upgrading = false;

            this.session.tlsOptions = this.tlsOptions = this._socket.getCipher();
            this.session.servername = this._socket.servername;
            let cipher = this.session.tlsOptions &amp;&amp; this.session.tlsOptions.name;
            this._server.logger.info(
                {
                    tnx: &#039;starttls&#039;,
                    cid: this.id,
                    user: (this.session.user &amp;&amp; this.session.user.username) || this.session.user,
                    cipher
                },
                &#039;Connection upgraded to TLS using&#039;,
                cipher || &#039;N/A&#039;
            );
            this._server.onSecure(this._socket, this.session, err =&gt; {
                if (err) {
                    return this._onError(err);
                }
                this._socket.pipe(this._parser);
                if (typeof secureCallback === &#039;function&#039;) {
                    secureCallback();
                }
            });
        });
    }
}
// Expose to the world
module.exports.SMTPConnection = SMTPConnection;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
