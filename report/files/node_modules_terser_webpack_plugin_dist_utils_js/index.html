<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/terser-webpack-plugin/dist/utils.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/terser-webpack-plugin/dist/utils.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">657</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.68</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

/** @typedef {import(&quot;@jridgewell/trace-mapping&quot;).SourceMapInput} SourceMapInput */
/** @typedef {import(&quot;./index.js&quot;).ExtractCommentsOptions} ExtractCommentsOptions */
/** @typedef {import(&quot;./index.js&quot;).ExtractCommentsFunction} ExtractCommentsFunction */
/** @typedef {import(&quot;./index.js&quot;).ExtractCommentsCondition} ExtractCommentsCondition */
/** @typedef {import(&quot;./index.js&quot;).Input} Input */
/** @typedef {import(&quot;./index.js&quot;).MinimizedResult} MinimizedResult */
/** @typedef {import(&quot;./index.js&quot;).CustomOptions} CustomOptions */

/**
 * @template T
 * @typedef {import(&quot;./index.js&quot;).PredefinedOptions&lt;T&gt;} PredefinedOptions
 */

/**
 * @typedef {Array&lt;string&gt;} ExtractedComments
 */

const notSettled = Symbol(`not-settled`);

/**
 * @template T
 * @typedef {() =&gt; Promise&lt;T&gt;} Task
 */

/**
 * Run tasks with limited concurrency.
 * @template T
 * @param {number} limit - Limit of tasks that run at once.
 * @param {Task&lt;T&gt;[]} tasks - List of tasks to run.
 * @returns {Promise&lt;T[]&gt;} A promise that fulfills to an array of the results
 */
function throttleAll(limit, tasks) {
  if (!Number.isInteger(limit) || limit &lt; 1) {
    throw new TypeError(`Expected \`limit\` to be a finite number &gt; 0, got \`${limit}\` (${typeof limit})`);
  }
  if (!Array.isArray(tasks) || !tasks.every(task =&gt; typeof task === `function`)) {
    throw new TypeError(`Expected \`tasks\` to be a list of functions returning a promise`);
  }
  return new Promise((resolve, reject) =&gt; {
    const result = Array(tasks.length).fill(notSettled);
    const entries = tasks.entries();
    const next = () =&gt; {
      const {
        done,
        value
      } = entries.next();
      if (done) {
        const isLast = !result.includes(notSettled);
        if (isLast) resolve( /** @type{T[]} **/result);
        return;
      }
      const [index, task] = value;

      /**
       * @param {T} x
       */
      const onFulfilled = x =&gt; {
        result[index] = x;
        next();
      };
      task().then(onFulfilled, reject);
    };
    Array(limit).fill(0).forEach(next);
  });
}

/* istanbul ignore next */
/**
 * @param {Input} input
 * @param {SourceMapInput | undefined} sourceMap
 * @param {CustomOptions} minimizerOptions
 * @param {ExtractCommentsOptions | undefined} extractComments
 * @return {Promise&lt;MinimizedResult&gt;}
 */
async function terserMinify(input, sourceMap, minimizerOptions, extractComments) {
  /**
   * @param {any} value
   * @returns {boolean}
   */
  const isObject = value =&gt; {
    const type = typeof value;
    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);
  };

  /**
   * @param {import(&quot;terser&quot;).MinifyOptions &amp; { sourceMap: undefined } &amp; ({ output: import(&quot;terser&quot;).FormatOptions &amp; { beautify: boolean } } | { format: import(&quot;terser&quot;).FormatOptions &amp; { beautify: boolean } })} terserOptions
   * @param {ExtractedComments} extractedComments
   * @returns {ExtractCommentsFunction}
   */
  const buildComments = (terserOptions, extractedComments) =&gt; {
    /** @type {{ [index: string]: ExtractCommentsCondition }} */
    const condition = {};
    let comments;
    if (terserOptions.format) {
      ({
        comments
      } = terserOptions.format);
    } else if (terserOptions.output) {
      ({
        comments
      } = terserOptions.output);
    }
    condition.preserve = typeof comments !== &quot;undefined&quot; ? comments : false;
    if (typeof extractComments === &quot;boolean&quot; &amp;&amp; extractComments) {
      condition.extract = &quot;some&quot;;
    } else if (typeof extractComments === &quot;string&quot; || extractComments instanceof RegExp) {
      condition.extract = extractComments;
    } else if (typeof extractComments === &quot;function&quot;) {
      condition.extract = extractComments;
    } else if (extractComments &amp;&amp; isObject(extractComments)) {
      condition.extract = typeof extractComments.condition === &quot;boolean&quot; &amp;&amp; extractComments.condition ? &quot;some&quot; : typeof extractComments.condition !== &quot;undefined&quot; ? extractComments.condition : &quot;some&quot;;
    } else {
      // No extract
      // Preserve using &quot;commentsOpts&quot; or &quot;some&quot;
      condition.preserve = typeof comments !== &quot;undefined&quot; ? comments : &quot;some&quot;;
      condition.extract = false;
    }

    // Ensure that both conditions are functions
    [&quot;preserve&quot;, &quot;extract&quot;].forEach(key =&gt; {
      /** @type {undefined | string} */
      let regexStr;
      /** @type {undefined | RegExp} */
      let regex;
      switch (typeof condition[key]) {
        case &quot;boolean&quot;:
          condition[key] = condition[key] ? () =&gt; true : () =&gt; false;
          break;
        case &quot;function&quot;:
          break;
        case &quot;string&quot;:
          if (condition[key] === &quot;all&quot;) {
            condition[key] = () =&gt; true;
            break;
          }
          if (condition[key] === &quot;some&quot;) {
            condition[key] = /** @type {ExtractCommentsFunction} */
            (astNode, comment) =&gt; (comment.type === &quot;comment2&quot; || comment.type === &quot;comment1&quot;) &amp;&amp; /@preserve|@lic|@cc_on|^\**!/i.test(comment.value);
            break;
          }
          regexStr = /** @type {string} */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction} */
          (astNode, comment) =&gt; new RegExp( /** @type {string} */regexStr).test(comment.value);
          break;
        default:
          regex = /** @type {RegExp} */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction} */
          (astNode, comment) =&gt; /** @type {RegExp} */regex.test(comment.value);
      }
    });

    // Redefine the comments function to extract and preserve
    // comments according to the two conditions
    return (astNode, comment) =&gt; {
      if ( /** @type {{ extract: ExtractCommentsFunction }} */
      condition.extract(astNode, comment)) {
        const commentText = comment.type === &quot;comment2&quot; ? `/*${comment.value}*/` : `//${comment.value}`;

        // Don&#039;t include duplicate comments
        if (!extractedComments.includes(commentText)) {
          extractedComments.push(commentText);
        }
      }
      return /** @type {{ preserve: ExtractCommentsFunction }} */condition.preserve(astNode, comment);
    };
  };

  /**
   * @param {PredefinedOptions&lt;import(&quot;terser&quot;).MinifyOptions&gt; &amp; import(&quot;terser&quot;).MinifyOptions} [terserOptions={}]
   * @returns {import(&quot;terser&quot;).MinifyOptions &amp; { sourceMap: undefined } &amp; { compress: import(&quot;terser&quot;).CompressOptions } &amp; ({ output: import(&quot;terser&quot;).FormatOptions &amp; { beautify: boolean } } | { format: import(&quot;terser&quot;).FormatOptions &amp; { beautify: boolean } })}
   */
  const buildTerserOptions = (terserOptions = {}) =&gt; {
    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      ...terserOptions,
      compress: typeof terserOptions.compress === &quot;boolean&quot; ? terserOptions.compress ? {} : false : {
        ...terserOptions.compress
      },
      // ecma: terserOptions.ecma,
      // ie8: terserOptions.ie8,
      // keep_classnames: terserOptions.keep_classnames,
      // keep_fnames: terserOptions.keep_fnames,
      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === &quot;boolean&quot; ? terserOptions.mangle : {
        ...terserOptions.mangle
      },
      // module: terserOptions.module,
      // nameCache: { ...terserOptions.toplevel },
      // the `output` option is deprecated
      ...(terserOptions.format ? {
        format: {
          beautify: false,
          ...terserOptions.format
        }
      } : {
        output: {
          beautify: false,
          ...terserOptions.output
        }
      }),
      parse: {
        ...terserOptions.parse
      },
      // safari10: terserOptions.safari10,
      // Ignoring sourceMap from options
      // eslint-disable-next-line no-undefined
      sourceMap: undefined
      // toplevel: terserOptions.toplevel
    };
  };

  // eslint-disable-next-line global-require
  const {
    minify
  } = require(&quot;terser&quot;);
  // Copy `terser` options
  const terserOptions = buildTerserOptions(minimizerOptions);

  // Let terser generate a SourceMap
  if (sourceMap) {
    // @ts-ignore
    terserOptions.sourceMap = {
      asObject: true
    };
  }

  /** @type {ExtractedComments} */
  const extractedComments = [];
  if (terserOptions.output) {
    terserOptions.output.comments = buildComments(terserOptions, extractedComments);
  } else if (terserOptions.format) {
    terserOptions.format.comments = buildComments(terserOptions, extractedComments);
  }
  if (terserOptions.compress) {
    // More optimizations
    if (typeof terserOptions.compress.ecma === &quot;undefined&quot;) {
      terserOptions.compress.ecma = terserOptions.ecma;
    }

    // https://github.com/webpack/webpack/issues/16135
    if (terserOptions.ecma === 5 &amp;&amp; typeof terserOptions.compress.arrows === &quot;undefined&quot;) {
      terserOptions.compress.arrows = false;
    }
  }
  const [[filename, code]] = Object.entries(input);
  const result = await minify({
    [filename]: code
  }, terserOptions);
  return {
    code: ( /** @type {string} **/result.code),
    // @ts-ignore
    // eslint-disable-next-line no-undefined
    map: result.map ? ( /** @type {SourceMapInput} **/result.map) : undefined,
    extractedComments
  };
}

/**
 * @returns {string | undefined}
 */
terserMinify.getMinimizerVersion = () =&gt; {
  let packageJson;
  try {
    // eslint-disable-next-line global-require
    packageJson = require(&quot;terser/package.json&quot;);
  } catch (error) {
    // Ignore
  }
  return packageJson &amp;&amp; packageJson.version;
};

/**
 * @returns {boolean | undefined}
 */
terserMinify.supportsWorkerThreads = () =&gt; true;

/* istanbul ignore next */
/**
 * @param {Input} input
 * @param {SourceMapInput | undefined} sourceMap
 * @param {CustomOptions} minimizerOptions
 * @param {ExtractCommentsOptions | undefined} extractComments
 * @return {Promise&lt;MinimizedResult&gt;}
 */
async function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {
  /**
   * @param {any} value
   * @returns {boolean}
   */
  const isObject = value =&gt; {
    const type = typeof value;
    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);
  };

  /**
   * @param {import(&quot;uglify-js&quot;).MinifyOptions &amp; { sourceMap: undefined } &amp; { output: import(&quot;uglify-js&quot;).OutputOptions &amp; { beautify: boolean }}} uglifyJsOptions
   * @param {ExtractedComments} extractedComments
   * @returns {ExtractCommentsFunction}
   */
  const buildComments = (uglifyJsOptions, extractedComments) =&gt; {
    /** @type {{ [index: string]: ExtractCommentsCondition }} */
    const condition = {};
    const {
      comments
    } = uglifyJsOptions.output;
    condition.preserve = typeof comments !== &quot;undefined&quot; ? comments : false;
    if (typeof extractComments === &quot;boolean&quot; &amp;&amp; extractComments) {
      condition.extract = &quot;some&quot;;
    } else if (typeof extractComments === &quot;string&quot; || extractComments instanceof RegExp) {
      condition.extract = extractComments;
    } else if (typeof extractComments === &quot;function&quot;) {
      condition.extract = extractComments;
    } else if (extractComments &amp;&amp; isObject(extractComments)) {
      condition.extract = typeof extractComments.condition === &quot;boolean&quot; &amp;&amp; extractComments.condition ? &quot;some&quot; : typeof extractComments.condition !== &quot;undefined&quot; ? extractComments.condition : &quot;some&quot;;
    } else {
      // No extract
      // Preserve using &quot;commentsOpts&quot; or &quot;some&quot;
      condition.preserve = typeof comments !== &quot;undefined&quot; ? comments : &quot;some&quot;;
      condition.extract = false;
    }

    // Ensure that both conditions are functions
    [&quot;preserve&quot;, &quot;extract&quot;].forEach(key =&gt; {
      /** @type {undefined | string} */
      let regexStr;
      /** @type {undefined | RegExp} */
      let regex;
      switch (typeof condition[key]) {
        case &quot;boolean&quot;:
          condition[key] = condition[key] ? () =&gt; true : () =&gt; false;
          break;
        case &quot;function&quot;:
          break;
        case &quot;string&quot;:
          if (condition[key] === &quot;all&quot;) {
            condition[key] = () =&gt; true;
            break;
          }
          if (condition[key] === &quot;some&quot;) {
            condition[key] = /** @type {ExtractCommentsFunction} */
            (astNode, comment) =&gt; (comment.type === &quot;comment2&quot; || comment.type === &quot;comment1&quot;) &amp;&amp; /@preserve|@lic|@cc_on|^\**!/i.test(comment.value);
            break;
          }
          regexStr = /** @type {string} */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction} */
          (astNode, comment) =&gt; new RegExp( /** @type {string} */regexStr).test(comment.value);
          break;
        default:
          regex = /** @type {RegExp} */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction} */
          (astNode, comment) =&gt; /** @type {RegExp} */regex.test(comment.value);
      }
    });

    // Redefine the comments function to extract and preserve
    // comments according to the two conditions
    return (astNode, comment) =&gt; {
      if ( /** @type {{ extract: ExtractCommentsFunction }} */
      condition.extract(astNode, comment)) {
        const commentText = comment.type === &quot;comment2&quot; ? `/*${comment.value}*/` : `//${comment.value}`;

        // Don&#039;t include duplicate comments
        if (!extractedComments.includes(commentText)) {
          extractedComments.push(commentText);
        }
      }
      return /** @type {{ preserve: ExtractCommentsFunction }} */condition.preserve(astNode, comment);
    };
  };

  /**
   * @param {PredefinedOptions&lt;import(&quot;uglify-js&quot;).MinifyOptions&gt; &amp; import(&quot;uglify-js&quot;).MinifyOptions} [uglifyJsOptions={}]
   * @returns {import(&quot;uglify-js&quot;).MinifyOptions &amp; { sourceMap: undefined } &amp; { output: import(&quot;uglify-js&quot;).OutputOptions &amp; { beautify: boolean }}}
   */
  const buildUglifyJsOptions = (uglifyJsOptions = {}) =&gt; {
    // eslint-disable-next-line no-param-reassign
    delete minimizerOptions.ecma;
    // eslint-disable-next-line no-param-reassign
    delete minimizerOptions.module;

    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      ...uglifyJsOptions,
      // warnings: uglifyJsOptions.warnings,
      parse: {
        ...uglifyJsOptions.parse
      },
      compress: typeof uglifyJsOptions.compress === &quot;boolean&quot; ? uglifyJsOptions.compress : {
        ...uglifyJsOptions.compress
      },
      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === &quot;boolean&quot; ? uglifyJsOptions.mangle : {
        ...uglifyJsOptions.mangle
      },
      output: {
        beautify: false,
        ...uglifyJsOptions.output
      },
      // Ignoring sourceMap from options
      // eslint-disable-next-line no-undefined
      sourceMap: undefined
      // toplevel: uglifyJsOptions.toplevel
      // nameCache: { ...uglifyJsOptions.toplevel },
      // ie8: uglifyJsOptions.ie8,
      // keep_fnames: uglifyJsOptions.keep_fnames,
    };
  };

  // eslint-disable-next-line global-require, import/no-extraneous-dependencies
  const {
    minify
  } = require(&quot;uglify-js&quot;);

  // Copy `uglify-js` options
  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions);

  // Let terser generate a SourceMap
  if (sourceMap) {
    // @ts-ignore
    uglifyJsOptions.sourceMap = true;
  }

  /** @type {ExtractedComments} */
  const extractedComments = [];

  // @ts-ignore
  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);
  const [[filename, code]] = Object.entries(input);
  const result = await minify({
    [filename]: code
  }, uglifyJsOptions);
  return {
    code: result.code,
    // eslint-disable-next-line no-undefined
    map: result.map ? JSON.parse(result.map) : undefined,
    errors: result.error ? [result.error] : [],
    warnings: result.warnings || [],
    extractedComments
  };
}

/**
 * @returns {string | undefined}
 */
uglifyJsMinify.getMinimizerVersion = () =&gt; {
  let packageJson;
  try {
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    packageJson = require(&quot;uglify-js/package.json&quot;);
  } catch (error) {
    // Ignore
  }
  return packageJson &amp;&amp; packageJson.version;
};

/**
 * @returns {boolean | undefined}
 */
uglifyJsMinify.supportsWorkerThreads = () =&gt; true;

/* istanbul ignore next */
/**
 * @param {Input} input
 * @param {SourceMapInput | undefined} sourceMap
 * @param {CustomOptions} minimizerOptions
 * @return {Promise&lt;MinimizedResult&gt;}
 */
async function swcMinify(input, sourceMap, minimizerOptions) {
  /**
   * @param {PredefinedOptions&lt;import(&quot;@swc/core&quot;).JsMinifyOptions&gt; &amp; import(&quot;@swc/core&quot;).JsMinifyOptions} [swcOptions={}]
   * @returns {import(&quot;@swc/core&quot;).JsMinifyOptions &amp; { sourceMap: undefined } &amp; { compress: import(&quot;@swc/core&quot;).TerserCompressOptions }}
   */
  const buildSwcOptions = (swcOptions = {}) =&gt; {
    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      ...swcOptions,
      compress: typeof swcOptions.compress === &quot;boolean&quot; ? swcOptions.compress ? {} : false : {
        ...swcOptions.compress
      },
      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === &quot;boolean&quot; ? swcOptions.mangle : {
        ...swcOptions.mangle
      },
      // ecma: swcOptions.ecma,
      // keep_classnames: swcOptions.keep_classnames,
      // keep_fnames: swcOptions.keep_fnames,
      // module: swcOptions.module,
      // safari10: swcOptions.safari10,
      // toplevel: swcOptions.toplevel
      // eslint-disable-next-line no-undefined
      sourceMap: undefined
    };
  };

  // eslint-disable-next-line import/no-extraneous-dependencies, global-require
  const swc = require(&quot;@swc/core&quot;);
  // Copy `swc` options
  const swcOptions = buildSwcOptions(minimizerOptions);

  // Let `swc` generate a SourceMap
  if (sourceMap) {
    // @ts-ignore
    swcOptions.sourceMap = true;
  }
  if (swcOptions.compress) {
    // More optimizations
    if (typeof swcOptions.compress.ecma === &quot;undefined&quot;) {
      swcOptions.compress.ecma = swcOptions.ecma;
    }

    // https://github.com/webpack/webpack/issues/16135
    if (swcOptions.ecma === 5 &amp;&amp; typeof swcOptions.compress.arrows === &quot;undefined&quot;) {
      swcOptions.compress.arrows = false;
    }
  }
  const [[filename, code]] = Object.entries(input);
  const result = await swc.minify(code, swcOptions);
  let map;
  if (result.map) {
    map = JSON.parse(result.map);

    // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`
    map.sources = [filename];
    delete map.sourcesContent;
  }
  return {
    code: result.code,
    map
  };
}

/**
 * @returns {string | undefined}
 */
swcMinify.getMinimizerVersion = () =&gt; {
  let packageJson;
  try {
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    packageJson = require(&quot;@swc/core/package.json&quot;);
  } catch (error) {
    // Ignore
  }
  return packageJson &amp;&amp; packageJson.version;
};

/**
 * @returns {boolean | undefined}
 */
swcMinify.supportsWorkerThreads = () =&gt; false;

/* istanbul ignore next */
/**
 * @param {Input} input
 * @param {SourceMapInput | undefined} sourceMap
 * @param {CustomOptions} minimizerOptions
 * @return {Promise&lt;MinimizedResult&gt;}
 */
async function esbuildMinify(input, sourceMap, minimizerOptions) {
  /**
   * @param {PredefinedOptions&lt;import(&quot;esbuild&quot;).TransformOptions&gt; &amp; import(&quot;esbuild&quot;).TransformOptions} [esbuildOptions={}]
   * @returns {import(&quot;esbuild&quot;).TransformOptions}
   */
  const buildEsbuildOptions = (esbuildOptions = {}) =&gt; {
    // eslint-disable-next-line no-param-reassign
    delete esbuildOptions.ecma;
    if (esbuildOptions.module) {
      // eslint-disable-next-line no-param-reassign
      esbuildOptions.format = &quot;esm&quot;;
    }

    // eslint-disable-next-line no-param-reassign
    delete esbuildOptions.module;

    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      minify: true,
      legalComments: &quot;inline&quot;,
      ...esbuildOptions,
      sourcemap: false
    };
  };

  // eslint-disable-next-line import/no-extraneous-dependencies, global-require
  const esbuild = require(&quot;esbuild&quot;);

  // Copy `esbuild` options
  const esbuildOptions = buildEsbuildOptions(minimizerOptions);

  // Let `esbuild` generate a SourceMap
  if (sourceMap) {
    esbuildOptions.sourcemap = true;
    esbuildOptions.sourcesContent = false;
  }
  const [[filename, code]] = Object.entries(input);
  esbuildOptions.sourcefile = filename;
  const result = await esbuild.transform(code, esbuildOptions);
  return {
    code: result.code,
    // eslint-disable-next-line no-undefined
    map: result.map ? JSON.parse(result.map) : undefined,
    warnings: result.warnings.length &gt; 0 ? result.warnings.map(item =&gt; {
      const plugin = item.pluginName ? `\nPlugin Name: ${item.pluginName}` : &quot;&quot;;
      const location = item.location ? `\n\n${item.location.file}:${item.location.line}:${item.location.column}:\n  ${item.location.line} | ${item.location.lineText}\n\nSuggestion: ${item.location.suggestion}` : &quot;&quot;;
      const notes = item.notes.length &gt; 0 ? `\n\nNotes:\n${item.notes.map(note =&gt; `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : &quot;&quot;}${note.text}${note.location ? `\nSuggestion: ${note.location.suggestion}` : &quot;&quot;}${note.location ? `\nLine text:\n${note.location.lineText}\n` : &quot;&quot;}`).join(&quot;\n&quot;)}` : &quot;&quot;;
      return `${item.text} [${item.id}]${plugin}${location}${item.detail ? `\nDetails:\n${item.detail}` : &quot;&quot;}${notes}`;
    }) : []
  };
}

/**
 * @returns {string | undefined}
 */
esbuildMinify.getMinimizerVersion = () =&gt; {
  let packageJson;
  try {
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    packageJson = require(&quot;esbuild/package.json&quot;);
  } catch (error) {
    // Ignore
  }
  return packageJson &amp;&amp; packageJson.version;
};

/**
 * @returns {boolean | undefined}
 */
esbuildMinify.supportsWorkerThreads = () =&gt; false;

/**
 * @template T
 * @param fn {(function(): any) | undefined}
 * @returns {function(): T}
 */
function memoize(fn) {
  let cache = false;
  /** @type {T} */
  let result;
  return () =&gt; {
    if (cache) {
      return result;
    }
    result = /** @type {function(): any} */fn();
    cache = true;
    // Allow to clean up memory for fn
    // and all dependent resources
    // eslint-disable-next-line no-undefined, no-param-reassign
    fn = undefined;
    return result;
  };
}
module.exports = {
  throttleAll,
  memoize,
  terserMinify,
  uglifyJsMinify,
  swcMinify,
  esbuildMinify
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
