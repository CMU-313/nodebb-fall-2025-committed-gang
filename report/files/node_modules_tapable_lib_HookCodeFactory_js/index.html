<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/tapable/lib/HookCodeFactory.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/tapable/lib/HookCodeFactory.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">455</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">84.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
&quot;use strict&quot;;

class HookCodeFactory {
	constructor(config) {
		this.config = config;
		this.options = undefined;
		this._args = undefined;
	}

	create(options) {
		this.init(options);
		let fn;
		switch (this.options.type) {
			case &quot;sync&quot;:
				fn = new Function(
					this.args(),
					`&quot;use strict&quot;;\n${this.header()}${this.contentWithInterceptors({
						onError: (err) =&gt; `throw ${err};\n`,
						onResult: (result) =&gt; `return ${result};\n`,
						resultReturns: true,
						onDone: () =&gt; &quot;&quot;,
						rethrowIfPossible: true
					})}`
				);
				break;
			case &quot;async&quot;:
				fn = new Function(
					this.args({
						after: &quot;_callback&quot;
					}),
					`&quot;use strict&quot;;\n${this.header()}${this.contentWithInterceptors({
						onError: (err) =&gt; `_callback(${err});\n`,
						onResult: (result) =&gt; `_callback(null, ${result});\n`,
						onDone: () =&gt; &quot;_callback();\n&quot;
					})}`
				);
				break;
			case &quot;promise&quot;: {
				let errorHelperUsed = false;
				const content = this.contentWithInterceptors({
					onError: (err) =&gt; {
						errorHelperUsed = true;
						return `_error(${err});\n`;
					},
					onResult: (result) =&gt; `_resolve(${result});\n`,
					onDone: () =&gt; &quot;_resolve();\n&quot;
				});
				let code = &quot;&quot;;
				code += &#039;&quot;use strict&quot;;\n&#039;;
				code += this.header();
				code += &quot;return new Promise((function(_resolve, _reject) {\n&quot;;
				if (errorHelperUsed) {
					code += &quot;var _sync = true;\n&quot;;
					code += &quot;function _error(_err) {\n&quot;;
					code += &quot;if(_sync)\n&quot;;
					code +=
						&quot;_resolve(Promise.resolve().then((function() { throw _err; })));\n&quot;;
					code += &quot;else\n&quot;;
					code += &quot;_reject(_err);\n&quot;;
					code += &quot;};\n&quot;;
				}
				code += content;
				if (errorHelperUsed) {
					code += &quot;_sync = false;\n&quot;;
				}
				code += &quot;}));\n&quot;;
				fn = new Function(this.args(), code);
				break;
			}
		}
		this.deinit();
		return fn;
	}

	setup(instance, options) {
		instance._x = options.taps.map((t) =&gt; t.fn);
	}

	/**
	 * @param {{ type: &quot;sync&quot; | &quot;promise&quot; | &quot;async&quot;, taps: Array&lt;Tap&gt;, interceptors: Array&lt;Interceptor&gt; }} options
	 */
	init(options) {
		this.options = options;
		this._args = [...options.args];
	}

	deinit() {
		this.options = undefined;
		this._args = undefined;
	}

	contentWithInterceptors(options) {
		if (this.options.interceptors.length &gt; 0) {
			const { onError, onResult, onDone } = options;
			let code = &quot;&quot;;
			for (let i = 0; i &lt; this.options.interceptors.length; i++) {
				const interceptor = this.options.interceptors[i];
				if (interceptor.call) {
					code += `${this.getInterceptor(i)}.call(${this.args({
						before: interceptor.context ? &quot;_context&quot; : undefined
					})});\n`;
				}
			}
			code += this.content(
				Object.assign(options, {
					onError:
						onError &amp;&amp;
						((err) =&gt; {
							let code = &quot;&quot;;
							for (let i = 0; i &lt; this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.error) {
									code += `${this.getInterceptor(i)}.error(${err});\n`;
								}
							}
							code += onError(err);
							return code;
						}),
					onResult:
						onResult &amp;&amp;
						((result) =&gt; {
							let code = &quot;&quot;;
							for (let i = 0; i &lt; this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.result) {
									code += `${this.getInterceptor(i)}.result(${result});\n`;
								}
							}
							code += onResult(result);
							return code;
						}),
					onDone:
						onDone &amp;&amp;
						(() =&gt; {
							let code = &quot;&quot;;
							for (let i = 0; i &lt; this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.done) {
									code += `${this.getInterceptor(i)}.done();\n`;
								}
							}
							code += onDone();
							return code;
						})
				})
			);
			return code;
		}
		return this.content(options);
	}

	header() {
		let code = &quot;&quot;;
		code += this.needContext() ? &quot;var _context = {};\n&quot; : &quot;var _context;\n&quot;;
		code += &quot;var _x = this._x;\n&quot;;
		if (this.options.interceptors.length &gt; 0) {
			code += &quot;var _taps = this.taps;\n&quot;;
			code += &quot;var _interceptors = this.interceptors;\n&quot;;
		}
		return code;
	}

	needContext() {
		for (const tap of this.options.taps) if (tap.context) return true;
		return false;
	}

	callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
		let code = &quot;&quot;;
		let hasTapCached = false;
		for (let i = 0; i &lt; this.options.interceptors.length; i++) {
			const interceptor = this.options.interceptors[i];
			if (interceptor.tap) {
				if (!hasTapCached) {
					code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
					hasTapCached = true;
				}
				code += `${this.getInterceptor(i)}.tap(${
					interceptor.context ? &quot;_context, &quot; : &quot;&quot;
				}_tap${tapIndex});\n`;
			}
		}
		code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
		const tap = this.options.taps[tapIndex];
		switch (tap.type) {
			case &quot;sync&quot;:
				if (!rethrowIfPossible) {
					code += `var _hasError${tapIndex} = false;\n`;
					code += &quot;try {\n&quot;;
				}
				if (onResult) {
					code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
						before: tap.context ? &quot;_context&quot; : undefined
					})});\n`;
				} else {
					code += `_fn${tapIndex}(${this.args({
						before: tap.context ? &quot;_context&quot; : undefined
					})});\n`;
				}
				if (!rethrowIfPossible) {
					code += &quot;} catch(_err) {\n&quot;;
					code += `_hasError${tapIndex} = true;\n`;
					code += onError(&quot;_err&quot;);
					code += &quot;}\n&quot;;
					code += `if(!_hasError${tapIndex}) {\n`;
				}
				if (onResult) {
					code += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					code += onDone();
				}
				if (!rethrowIfPossible) {
					code += &quot;}\n&quot;;
				}
				break;
			case &quot;async&quot;: {
				let cbCode = &quot;&quot;;
				cbCode += onResult
					? `(function(_err${tapIndex}, _result${tapIndex}) {\n`
					: `(function(_err${tapIndex}) {\n`;
				cbCode += `if(_err${tapIndex}) {\n`;
				cbCode += onError(`_err${tapIndex}`);
				cbCode += &quot;} else {\n&quot;;
				if (onResult) {
					cbCode += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					cbCode += onDone();
				}
				cbCode += &quot;}\n&quot;;
				cbCode += &quot;})&quot;;
				code += `_fn${tapIndex}(${this.args({
					before: tap.context ? &quot;_context&quot; : undefined,
					after: cbCode
				})});\n`;
				break;
			}
			case &quot;promise&quot;:
				code += `var _hasResult${tapIndex} = false;\n`;
				code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
					before: tap.context ? &quot;_context&quot; : undefined
				})});\n`;
				code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
				code += `  throw new Error(&#039;Tap function (tapPromise) did not return promise (returned &#039; + _promise${tapIndex} + &#039;)&#039;);\n`;
				code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
				code += `_hasResult${tapIndex} = true;\n`;
				if (onResult) {
					code += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					code += onDone();
				}
				code += `}), function(_err${tapIndex}) {\n`;
				code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
				code += onError(
					`!_err${tapIndex} ? new Error(&#039;Tap function (tapPromise) rejects &quot;&#039; + _err${tapIndex} + &#039;&quot; value&#039;) : _err${tapIndex}`
				);
				code += &quot;});\n&quot;;
				break;
		}
		return code;
	}

	callTapsSeries({
		onError,
		onResult,
		resultReturns,
		onDone,
		doneReturns,
		rethrowIfPossible
	}) {
		if (this.options.taps.length === 0) return onDone();
		const firstAsync = this.options.taps.findIndex((t) =&gt; t.type !== &quot;sync&quot;);
		const somethingReturns = resultReturns || doneReturns;
		let code = &quot;&quot;;
		let current = onDone;
		let unrollCounter = 0;
		for (let j = this.options.taps.length - 1; j &gt;= 0; j--) {
			const i = j;
			const unroll =
				current !== onDone &amp;&amp;
				(this.options.taps[i].type !== &quot;sync&quot; || unrollCounter++ &gt; 20);
			if (unroll) {
				unrollCounter = 0;
				code += `function _next${i}() {\n`;
				code += current();
				code += &quot;}\n&quot;;
				current = () =&gt; `${somethingReturns ? &quot;return &quot; : &quot;&quot;}_next${i}();\n`;
			}
			const done = current;
			const doneBreak = (skipDone) =&gt; {
				if (skipDone) return &quot;&quot;;
				return onDone();
			};
			const content = this.callTap(i, {
				onError: (error) =&gt; onError(i, error, done, doneBreak),
				onResult:
					onResult &amp;&amp; ((result) =&gt; onResult(i, result, done, doneBreak)),
				onDone: !onResult &amp;&amp; done,
				rethrowIfPossible:
					rethrowIfPossible &amp;&amp; (firstAsync &lt; 0 || i &lt; firstAsync)
			});
			current = () =&gt; content;
		}
		code += current();
		return code;
	}

	callTapsLooping({ onError, onDone, rethrowIfPossible }) {
		if (this.options.taps.length === 0) return onDone();
		const syncOnly = this.options.taps.every((t) =&gt; t.type === &quot;sync&quot;);
		let code = &quot;&quot;;
		if (!syncOnly) {
			code += &quot;var _looper = (function() {\n&quot;;
			code += &quot;var _loopAsync = false;\n&quot;;
		}
		code += &quot;var _loop;\n&quot;;
		code += &quot;do {\n&quot;;
		code += &quot;_loop = false;\n&quot;;
		for (let i = 0; i &lt; this.options.interceptors.length; i++) {
			const interceptor = this.options.interceptors[i];
			if (interceptor.loop) {
				code += `${this.getInterceptor(i)}.loop(${this.args({
					before: interceptor.context ? &quot;_context&quot; : undefined
				})});\n`;
			}
		}
		code += this.callTapsSeries({
			onError,
			onResult: (i, result, next, doneBreak) =&gt; {
				let code = &quot;&quot;;
				code += `if(${result} !== undefined) {\n`;
				code += &quot;_loop = true;\n&quot;;
				if (!syncOnly) code += &quot;if(_loopAsync) _looper();\n&quot;;
				code += doneBreak(true);
				code += &quot;} else {\n&quot;;
				code += next();
				code += &quot;}\n&quot;;
				return code;
			},
			onDone:
				onDone &amp;&amp;
				(() =&gt; {
					let code = &quot;&quot;;
					code += &quot;if(!_loop) {\n&quot;;
					code += onDone();
					code += &quot;}\n&quot;;
					return code;
				}),
			rethrowIfPossible: rethrowIfPossible &amp;&amp; syncOnly
		});
		code += &quot;} while(_loop);\n&quot;;
		if (!syncOnly) {
			code += &quot;_loopAsync = true;\n&quot;;
			code += &quot;});\n&quot;;
			code += &quot;_looper();\n&quot;;
		}
		return code;
	}

	callTapsParallel({
		onError,
		onResult,
		onDone,
		rethrowIfPossible,
		onTap = (i, run) =&gt; run()
	}) {
		if (this.options.taps.length &lt;= 1) {
			return this.callTapsSeries({
				onError,
				onResult,
				onDone,
				rethrowIfPossible
			});
		}
		let code = &quot;&quot;;
		code += &quot;do {\n&quot;;
		code += `var _counter = ${this.options.taps.length};\n`;
		if (onDone) {
			code += &quot;var _done = (function() {\n&quot;;
			code += onDone();
			code += &quot;});\n&quot;;
		}
		for (let i = 0; i &lt; this.options.taps.length; i++) {
			const done = () =&gt; {
				if (onDone) return &quot;if(--_counter === 0) _done();\n&quot;;
				return &quot;--_counter;&quot;;
			};
			const doneBreak = (skipDone) =&gt; {
				if (skipDone || !onDone) return &quot;_counter = 0;\n&quot;;
				return &quot;_counter = 0;\n_done();\n&quot;;
			};
			code += &quot;if(_counter &lt;= 0) break;\n&quot;;
			code += onTap(
				i,
				() =&gt;
					this.callTap(i, {
						onError: (error) =&gt; {
							let code = &quot;&quot;;
							code += &quot;if(_counter &gt; 0) {\n&quot;;
							code += onError(i, error, done, doneBreak);
							code += &quot;}\n&quot;;
							return code;
						},
						onResult:
							onResult &amp;&amp;
							((result) =&gt; {
								let code = &quot;&quot;;
								code += &quot;if(_counter &gt; 0) {\n&quot;;
								code += onResult(i, result, done, doneBreak);
								code += &quot;}\n&quot;;
								return code;
							}),
						onDone: !onResult &amp;&amp; (() =&gt; done()),
						rethrowIfPossible
					}),
				done,
				doneBreak
			);
		}
		code += &quot;} while(false);\n&quot;;
		return code;
	}

	args({ before, after } = {}) {
		let allArgs = this._args;
		if (before) allArgs = [before, ...allArgs];
		if (after) allArgs = [...allArgs, after];
		if (allArgs.length === 0) {
			return &quot;&quot;;
		}

		return allArgs.join(&quot;, &quot;);
	}

	getTapFn(idx) {
		return `_x[${idx}]`;
	}

	getTap(idx) {
		return `_taps[${idx}]`;
	}

	getInterceptor(idx) {
		return `_interceptors[${idx}]`;
	}
}

module.exports = HookCodeFactory;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
