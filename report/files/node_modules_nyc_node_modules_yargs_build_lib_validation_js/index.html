<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nyc/node_modules/yargs/build/lib/validation.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nyc/node_modules/yargs/build/lib/validation.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">331</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">88.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.12</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.validation = void 0;
const argsert_1 = require(&quot;./argsert&quot;);
const common_types_1 = require(&quot;./common-types&quot;);
const levenshtein_1 = require(&quot;./levenshtein&quot;);
const obj_filter_1 = require(&quot;./obj-filter&quot;);
const specialKeys = [&#039;$0&#039;, &#039;--&#039;, &#039;_&#039;];
// validation-type-stuff, missing params,
// bad implications, custom checks.
function validation(yargs, usage, y18n) {
    const __ = y18n.__;
    const __n = y18n.__n;
    const self = {};
    // validate appropriate # of non-option
    // arguments were provided, i.e., &#039;_&#039;.
    self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        // don&#039;t count currently executing commands
        const _s = argv._.length - yargs.getContext().commands.length;
        if (demandedCommands._ &amp;&amp; (_s &lt; demandedCommands._.min || _s &gt; demandedCommands._.max)) {
            if (_s &lt; demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(
                    // replace $0 with observed, $1 with expected.
                    demandedCommands._.minMsg
                        ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString())
                        : null);
                }
                else {
                    usage.fail(__n(&#039;Not enough non-option arguments: got %s, need at least %s&#039;, &#039;Not enough non-option arguments: got %s, need at least %s&#039;, _s, _s, demandedCommands._.min));
                }
            }
            else if (_s &gt; demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(
                    // replace $0 with observed, $1 with expected.
                    demandedCommands._.maxMsg
                        ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString())
                        : null);
                }
                else {
                    usage.fail(__n(&#039;Too many non-option arguments: got %s, maximum of %s&#039;, &#039;Too many non-option arguments: got %s, maximum of %s&#039;, _s, _s, demandedCommands._.max));
                }
            }
        }
    };
    // validate the appropriate # of &lt;required&gt;
    // positional arguments were provided:
    self.positionalCount = function positionalCount(required, observed) {
        if (observed &lt; required) {
            usage.fail(__n(&#039;Not enough non-option arguments: got %s, need at least %s&#039;, &#039;Not enough non-option arguments: got %s, need at least %s&#039;, observed, observed, required));
        }
    };
    // make sure all the required arguments are present.
    self.requiredArguments = function requiredArguments(argv) {
        const demandedOptions = yargs.getDemandedOptions();
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === &#039;undefined&#039;) {
                missing = missing || {};
                missing[key] = demandedOptions[key];
            }
        }
        if (missing) {
            const customMsgs = [];
            for (const key of Object.keys(missing)) {
                const msg = missing[key];
                if (msg &amp;&amp; customMsgs.indexOf(msg) &lt; 0) {
                    customMsgs.push(msg);
                }
            }
            const customMsg = customMsgs.length ? `\n${customMsgs.join(&#039;\n&#039;)}` : &#039;&#039;;
            usage.fail(__n(&#039;Missing required argument: %s&#039;, &#039;Missing required arguments: %s&#039;, Object.keys(missing).length, Object.keys(missing).join(&#039;, &#039;) + customMsg));
        }
    };
    // check for unknown arguments (strict-mode).
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        Object.keys(argv).forEach((key) =&gt; {
            if (specialKeys.indexOf(key) === -1 &amp;&amp;
                !Object.prototype.hasOwnProperty.call(positionalMap, key) &amp;&amp;
                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &amp;&amp;
                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if ((currentContext.commands.length &gt; 0) || (commandKeys.length &gt; 0) || isDefaultCommand) {
            argv._.slice(currentContext.commands.length).forEach((key) =&gt; {
                if (commandKeys.indexOf(key) === -1) {
                    unknown.push(key);
                }
            });
        }
        if (unknown.length &gt; 0) {
            usage.fail(__n(&#039;Unknown argument: %s&#039;, &#039;Unknown arguments: %s&#039;, unknown.length, unknown.join(&#039;, &#039;)));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        if ((currentContext.commands.length &gt; 0) || (commandKeys.length &gt; 0)) {
            argv._.slice(currentContext.commands.length).forEach((key) =&gt; {
                if (commandKeys.indexOf(key) === -1) {
                    unknown.push(key);
                }
            });
        }
        if (unknown.length &gt; 0) {
            usage.fail(__n(&#039;Unknown command: %s&#039;, &#039;Unknown commands: %s&#039;, unknown.length, unknown.join(&#039;, &#039;)));
            return true;
        }
        else {
            return false;
        }
    };
    // check for a key that is not an alias, or for which every alias is new,
    // implying that it was invented by the parser, e.g., during camelization
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        const newAliases = yargs.parsed.newAliases;
        for (const a of [key, ...aliases[key]]) {
            if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
                return true;
            }
        }
        return false;
    };
    // validate arguments limited to enumerated choices
    self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
            return;
        Object.keys(argv).forEach((key) =&gt; {
            if (specialKeys.indexOf(key) === -1 &amp;&amp;
                Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach((value) =&gt; {
                    // TODO case-insensitive configurability
                    if (options.choices[key].indexOf(value) === -1 &amp;&amp;
                        value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
            return;
        let msg = __(&#039;Invalid values:&#039;);
        invalidKeys.forEach((key) =&gt; {
            msg += `\n  ${__(&#039;Argument: %s, Given: %s, Choices: %s&#039;, key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
    };
    // custom checks, added using the `check` option on yargs.
    let checks = [];
    self.check = function check(f, global) {
        checks.push({
            func: f,
            global
        });
    };
    self.customChecks = function customChecks(argv, aliases) {
        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {
            const func = f.func;
            let result = null;
            try {
                result = func(argv, aliases);
            }
            catch (err) {
                usage.fail(err.message ? err.message : err, err);
                continue;
            }
            if (!result) {
                usage.fail(__(&#039;Argument check failed: %s&#039;, func.toString()));
            }
            else if (typeof result === &#039;string&#039; || result instanceof Error) {
                usage.fail(result.toString(), result);
            }
        }
    };
    // check implications, argument foo implies =&gt; argument bar.
    let implied = {};
    self.implies = function implies(key, value) {
        argsert_1.argsert(&#039;&lt;string|object&gt; [array|number|string]&#039;, [key, value], arguments.length);
        if (typeof key === &#039;object&#039;) {
            Object.keys(key).forEach((k) =&gt; {
                self.implies(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach((i) =&gt; self.implies(key, i));
            }
            else {
                common_types_1.assertNotStrictEqual(value, undefined);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        // convert string &#039;1&#039; to number 1
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === &#039;number&#039;) {
            // check length of argv._
            val = argv._.length &gt;= val;
        }
        else if (val.match(/^--no-.+/)) {
            // check if key/value doesn&#039;t exist
            val = val.match(/^--no-(.+)/)[1];
            val = !argv[val];
        }
        else {
            // check if key/value exists
            val = argv[val];
        }
        return val;
    }
    self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach((key) =&gt; {
            const origKey = key;
            (implied[key] || []).forEach((value) =&gt; {
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key &amp;&amp; !value) {
                    implyFail.push(` ${origKey} -&gt; ${origValue}`);
                }
            });
        });
        if (implyFail.length) {
            let msg = `${__(&#039;Implications failed:&#039;)}\n`;
            implyFail.forEach((value) =&gt; {
                msg += (value);
            });
            usage.fail(msg);
        }
    };
    let conflicting = {};
    self.conflicts = function conflicts(key, value) {
        argsert_1.argsert(&#039;&lt;string|object&gt; [array|string]&#039;, [key, value], arguments.length);
        if (typeof key === &#039;object&#039;) {
            Object.keys(key).forEach((k) =&gt; {
                self.conflicts(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach((i) =&gt; self.conflicts(key, i));
            }
            else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = () =&gt; conflicting;
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach((key) =&gt; {
            if (conflicting[key]) {
                conflicting[key].forEach((value) =&gt; {
                    // we default keys to &#039;undefined&#039; that have been configured, we should not
                    // apply conflicting check unless they are a value other than &#039;undefined&#039;.
                    if (value &amp;&amp; argv[key] !== undefined &amp;&amp; argv[value] !== undefined) {
                        usage.fail(__(&#039;Arguments %s and %s are mutually exclusive&#039;, key, value));
                    }
                });
            }
        });
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3; // if it takes more than three edits, let&#039;s move on.
        potentialCommands = potentialCommands.sort((a, b) =&gt; b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
            const d = levenshtein_1.levenshtein(cmd, candidate);
            if (d &lt;= threshold &amp;&amp; d &lt; bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended)
            usage.fail(__(&#039;Did you mean %s?&#039;, recommended));
    };
    self.reset = function reset(localLookup) {
        implied = obj_filter_1.objFilter(implied, k =&gt; !localLookup[k]);
        conflicting = obj_filter_1.objFilter(conflicting, k =&gt; !localLookup[k]);
        checks = checks.filter(c =&gt; c.global);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied,
            checks,
            conflicting
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, undefined);
        ({
            implied,
            checks,
            conflicting
        } = frozen);
    };
    return self;
}
exports.validation = validation;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
