<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/lib/validator.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/lib/validator.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">746</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.66</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint-disable no-invalid-this */
// validators are a mixin, so it&#039;s okay that we&#039;re using &#039;this&#039; all over the place

&quot;use strict&quot;;

var crypto = require(&quot;crypto&quot;);
var { URL } = require(&quot;url&quot;);
var {
	isBase64Url,
	checkOrigin,
	checkRpId,
	abEqual,
	isPem,
	isPositiveInteger,
	coerceToBase64Url,
	coerceToArrayBuffer,
} = require(&quot;./utils&quot;);
var Fido2Lib;

async function validateExpectations() {
	/* eslint complexity: [&quot;off&quot;] */
	var req = this.requiredExpectations;
	var opt = this.optionalExpectations;
	var exp = this.expectations;

	if (!(exp instanceof Map)) {
		throw new Error(&quot;expectations should be of type Map&quot;);
	}

	if (Array.isArray(req)) {
		req = new Set([req]);
	}

	if (!(req instanceof Set)) {
		throw new Error(&quot;requiredExpectaions should be of type Set&quot;);
	}

	if (Array.isArray(opt)) {
		opt = new Set([opt]);
	}

	if (!(opt instanceof Set)) {
		throw new Error(&quot;optionalExpectations should be of type Set&quot;);
	}

	for (let field of req) {
		if (!exp.has(field)) {
			throw new Error(`expectation did not contain value for &#039;${field}&#039;`);
		}
	}

	let optCount = 0;
	for (const [field] of exp) {
		if (opt.has(field)) {
			optCount++;
		}
	}

	if (req.size !== exp.size - optCount) {
		throw new Error(`wrong number of expectations: should have ${req.size} but got ${exp.size - optCount}`);
	}

	// origin - isValid
	if (req.has(&quot;origin&quot;)) {
		var expectedOrigin = exp.get(&quot;origin&quot;);

		checkOrigin(expectedOrigin);
	}

	// rpId - optional, isValid
	if (exp.has(&quot;rpId&quot;)) {
		var expectedRpId = exp.get(&quot;rpId&quot;);

		checkRpId(expectedRpId);
	}

	// challenge - is valid base64url string
	if (exp.has(&quot;challenge&quot;)) {
		var challenge = exp.get(&quot;challenge&quot;);
		if (typeof challenge !== &quot;string&quot;) {
			throw new Error(&quot;expected challenge should be of type String, got: &quot; + typeof challenge);
		}

		if (!isBase64Url(challenge)) {
			throw new Error(&quot;expected challenge should be properly encoded base64url String&quot;);
		}
	}

	// flags - is Array or Set
	if (req.has(&quot;flags&quot;)) {
		var validFlags = new Set([&quot;UP&quot;, &quot;UV&quot;, &quot;UP-or-UV&quot;, &quot;AT&quot;, &quot;ED&quot;]);
		var flags = exp.get(&quot;flags&quot;);

		for (let flag of flags) {
			if (!validFlags.has(flag)) {
				throw new Error(`expected flag unknown: ${flag}`);
			}
		}
	}

	// prevCounter
	if (req.has(&quot;prevCounter&quot;)) {
		var prevCounter = exp.get(&quot;prevCounter&quot;);

		if (!isPositiveInteger(prevCounter)) {
			throw new Error(&quot;expected counter to be positive integer&quot;);
		}
	}

	// publicKey
	if (req.has(&quot;publicKey&quot;)) {
		var publicKey = exp.get(&quot;publicKey&quot;);
		if (!isPem(publicKey)) {
			throw new Error(&quot;expected publicKey to be in PEM format&quot;);
		}
	}

	// userHandle
	if (req.has(&quot;userHandle&quot;)) {
		var userHandle = exp.get(&quot;userHandle&quot;);
		if (userHandle !== null &amp;&amp;
			typeof userHandle !== &quot;string&quot;) {
			throw new Error(&quot;expected userHandle to be null or string&quot;);
		}
	}


	// allowCredentials
	if (exp.has(&quot;allowCredentials&quot;)) {
		var allowCredentials = exp.get(&quot;allowCredentials&quot;);
		if (allowCredentials != null) {
			if (!Array.isArray(allowCredentials)) {
				throw new Error(&quot;expected allowCredentials to be null or array&quot;);
			} else {
				for (const index in allowCredentials) {
					if (typeof allowCredentials[index].id === &quot;string&quot;) {
						allowCredentials[index].id = coerceToArrayBuffer(allowCredentials[index].id, &quot;allowCredentials[&quot; + index + &quot;].id&quot;);
					}
					if (allowCredentials[index].id == null || !(allowCredentials[index].id instanceof ArrayBuffer)) {
						throw new Error(&quot;expected id of allowCredentials[&quot; + index + &quot;] to be ArrayBuffer&quot;);
					}
					if (allowCredentials[index].type == null || allowCredentials[index].type !== &quot;public-key&quot;) {
						throw new Error(&quot;expected type of allowCredentials[&quot; + index + &quot;] to be string with value &#039;public-key&#039;&quot;);
					}
					if (allowCredentials[index].transports != null &amp;&amp; !Array.isArray(allowCredentials[index].transports)) {
						throw new Error(&quot;expected transports of allowCredentials[&quot; + index + &quot;] to be array or null&quot;);
					} else if (allowCredentials[index].transports != null &amp;&amp; !allowCredentials[index].transports.every(el =&gt; [&quot;usb&quot;, &quot;nfc&quot;, &quot;ble&quot;, &quot;internal&quot;].includes(el))) {
						throw new Error(&quot;expected transports of allowCredentials[&quot; + index + &quot;] to be string with value &#039;usb&#039;, &#039;nfc&#039;, &#039;ble&#039;, &#039;internal&#039; or null&quot;);
					}
				}
			}
		}

	}

	this.audit.validExpectations = true;

	return true;
}

function validateCreateRequest() {
	var req = this.request;

	if (typeof req !== &quot;object&quot;) {
		throw new TypeError(&quot;expected request to be Object, got &quot; + typeof req);
	}

	if (!(req.rawId instanceof ArrayBuffer) &amp;&amp;
		!(req.id instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;id&#039; or &#039;rawId&#039; field of request to be ArrayBuffer, got rawId &quot; + typeof req.rawId + &quot; and id &quot; + typeof req.id);
	}

	if (typeof req.response !== &quot;object&quot;) {
		throw new TypeError(&quot;expected &#039;response&#039; field of request to be Object, got &quot; + typeof req.response);
	}

	if (typeof req.response.attestationObject !== &quot;string&quot; &amp;&amp;
		!(req.response.attestationObject instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;response.attestationObject&#039; to be base64 String or ArrayBuffer&quot;);
	}

	if (typeof req.response.clientDataJSON !== &quot;string&quot; &amp;&amp;
		!(req.response.clientDataJSON instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;response.clientDataJSON&#039; to be base64 String or ArrayBuffer&quot;);
	}

	this.audit.validRequest = true;

	return true;
}

function validateAssertionResponse() {
	var req = this.request;

	if (typeof req !== &quot;object&quot;) {
		throw new TypeError(&quot;expected request to be Object, got &quot; + typeof req);
	}

	if (!(req.rawId instanceof ArrayBuffer) &amp;&amp;
		!(req.id instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;id&#039; or &#039;rawId&#039; field of request to be ArrayBuffer, got rawId &quot; + typeof req.rawId + &quot; and id &quot; + typeof req.id);
	}

	if (typeof req.response !== &quot;object&quot;) {
		throw new TypeError(&quot;expected &#039;response&#039; field of request to be Object, got &quot; + typeof req.response);
	}

	if (typeof req.response.clientDataJSON !== &quot;string&quot; &amp;&amp;
		!(req.response.clientDataJSON instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;response.clientDataJSON&#039; to be base64 String or ArrayBuffer&quot;);
	}

	if (typeof req.response.authenticatorData !== &quot;string&quot; &amp;&amp;
		!(req.response.authenticatorData instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;response.authenticatorData&#039; to be base64 String or ArrayBuffer&quot;);
	}

	if (typeof req.response.signature !== &quot;string&quot; &amp;&amp;
		!(req.response.signature instanceof ArrayBuffer)) {
		throw new TypeError(&quot;expected &#039;response.signature&#039; to be base64 String or ArrayBuffer&quot;);
	}

	if (typeof req.response.userHandle !== &quot;string&quot; &amp;&amp;
		!(req.response.userHandle instanceof ArrayBuffer) &amp;&amp;
		req.response.userHandle !== undefined) {
		throw new TypeError(&quot;expected &#039;response.userHandle&#039; to be base64 String, ArrayBuffer, or undefined&quot;);
	}

	this.audit.validRequest = true;

	return true;
}

async function validateRawClientDataJson() {
	// XXX: this isn&#039;t very useful, since this has already been parsed...
	var rawClientDataJson = this.clientData.get(&quot;rawClientDataJson&quot;);

	if (!(rawClientDataJson instanceof ArrayBuffer)) {
		throw new Error(&quot;clientData clientDataJson should be ArrayBuffer&quot;);
	}

	this.audit.journal.add(&quot;rawClientDataJson&quot;);

	return true;
}

async function validateTransports() {
	var transports = this.authnrData.get(&quot;transports&quot;);

	if (transports != null &amp;&amp; !Array.isArray(transports)) {
		throw new Error(&quot;expected transports to be &#039;null&#039; or &#039;array&lt;string&gt;&#039;&quot;);
	}

	for (const index in transports) {
		if (typeof transports[index] !== &quot;string&quot;) {
			throw new Error(&quot;expected transports[&quot; + index + &quot;] to be &#039;string&#039;&quot;);
		}
	}

	this.audit.journal.add(&quot;transports&quot;);

	return true;
}

async function validateId() {
	var rawId = this.clientData.get(&quot;rawId&quot;);

	if (!(rawId instanceof ArrayBuffer)) {
		throw new Error(&quot;expected id to be of type ArrayBuffer&quot;);
	}

	var credId = this.authnrData.get(&quot;credId&quot;);
	if (credId !== undefined &amp;&amp; !abEqual(rawId, credId)) {
		throw new Error(&quot;id and credId were not the same&quot;);
	}
	
	var allowCredentials = this.expectations.get(&quot;allowCredentials&quot;);

	if (allowCredentials != undefined) {
		if (!allowCredentials.some(cred =&gt; {
			var result = abEqual(rawId, cred.id);
			return result;
		}
		)) {
			throw new Error(&quot;Credential ID does not match any value in allowCredentials&quot;);
		}
	}

	this.audit.journal.add(&quot;rawId&quot;);

	return true;
}


async function validateOrigin() {
	var expectedOrigin = this.expectations.get(&quot;origin&quot;);
	var clientDataOrigin = this.clientData.get(&quot;origin&quot;);

	var origin = checkOrigin(clientDataOrigin);

	if (origin !== expectedOrigin) {
		throw new Error(&quot;clientData origin did not match expected origin&quot;);
	}

	this.audit.journal.add(&quot;origin&quot;);

	return true;
}

async function validateCreateType() {
	var type = this.clientData.get(&quot;type&quot;);

	if (type !== &quot;webauthn.create&quot;) {
		throw new Error(&quot;clientData type should be &#039;webauthn.create&#039;, got: &quot; + type);
	}

	this.audit.journal.add(&quot;type&quot;);

	return true;
}

async function validateGetType() {
	var type = this.clientData.get(&quot;type&quot;);

	if (type !== &quot;webauthn.get&quot;) {
		throw new Error(&quot;clientData type should be &#039;webauthn.get&#039;&quot;);
	}

	this.audit.journal.add(&quot;type&quot;);

	return true;
}

async function validateChallenge() {
	var expectedChallenge = this.expectations.get(&quot;challenge&quot;);
	var challenge = this.clientData.get(&quot;challenge&quot;);

	if (typeof challenge !== &quot;string&quot;) {
		throw new Error(&quot;clientData challenge was not a string&quot;);
	}

	if (!isBase64Url(challenge)) {
		throw new TypeError(&quot;clientData challenge was not properly encoded base64url&quot;);
	}

	challenge = challenge.replace(/={1,2}$/, &quot;&quot;);

	// console.log(&quot;challenge&quot;, challenge);
	// console.log(&quot;expectedChallenge&quot;, expectedChallenge);
	if (challenge !== expectedChallenge) {
		throw new Error(&quot;clientData challenge mismatch&quot;);
	}

	this.audit.journal.add(&quot;challenge&quot;);

	return true;
}

async function validateTokenBinding() {
	// TODO: node.js can&#039;t support token binding right now :(
	var tokenBinding = this.clientData.get(&quot;tokenBinding&quot;);

	if (typeof tokenBinding === &quot;object&quot;) {
		if (tokenBinding.status !== &quot;not-supported&quot; &amp;&amp;
			tokenBinding.status !== &quot;supported&quot;) {
			throw new Error(&quot;tokenBinding status should be &#039;not-supported&#039; or &#039;supported&#039;, got: &quot; + tokenBinding.status);
		}

		if (Object.keys(tokenBinding).length != 1) {
			throw new Error(&quot;tokenBinding had too many keys&quot;);
		}
	} else if (tokenBinding !== undefined) {
		throw new Error(&quot;Token binding field malformed: &quot; + tokenBinding);
	}

	// TODO: add audit.info for token binding status so that it can be used for policies, risk, etc.
	this.audit.journal.add(&quot;tokenBinding&quot;);

	return true;
}

async function validateRawAuthnrData() {
	// XXX: this isn&#039;t very useful, since this has already been parsed...
	var rawAuthnrData = this.authnrData.get(&quot;rawAuthnrData&quot;);

	if (!(rawAuthnrData instanceof ArrayBuffer)) {
		throw new Error(&quot;authnrData rawAuthnrData should be ArrayBuffer&quot;);
	}

	this.audit.journal.add(&quot;rawAuthnrData&quot;);

	return true;
}

async function validateAttestation() {
	// have to require here to prevent circular dependency
	if (!Fido2Lib) Fido2Lib = require(&quot;../index&quot;).Fido2Lib; // eslint-disable-line global-require

	return Fido2Lib.validateAttestation.call(this);
}

async function validateAssertionSignature() {
	var expectedSignature = this.authnrData.get(&quot;sig&quot;);
	var publicKey = this.expectations.get(&quot;publicKey&quot;);
	var rawAuthnrData = this.authnrData.get(&quot;rawAuthnrData&quot;);
	var rawClientData = this.clientData.get(&quot;rawClientDataJson&quot;);

	// console.log(&quot;publicKey&quot;, publicKey);
	// printHex(&quot;expectedSignature&quot;, expectedSignature);
	// printHex(&quot;rawAuthnrData&quot;, rawAuthnrData);
	// printHex(&quot;rawClientData&quot;, rawClientData);

	const hash = crypto.createHash(&quot;SHA256&quot;);
	hash.update(abToBuf(rawClientData));
	var clientDataHashBuf = hash.digest();
	var clientDataHash = new Uint8Array(clientDataHashBuf).buffer;

	// printHex(&quot;clientDataHash&quot;, clientDataHash);

	const verify = crypto.createVerify(&quot;SHA256&quot;);
	verify.write(abToBuf(rawAuthnrData));
	verify.write(abToBuf(clientDataHash));
	verify.end();
	var res = verify.verify(publicKey, abToBuf(expectedSignature));
	if (!res) {
		throw new Error(&quot;signature validation failed&quot;);
	}

	this.audit.journal.add(&quot;sig&quot;);

	return true;
}

function abToBuf(ab) {
	return Buffer.from(new Uint8Array(ab));
}

async function validateRpIdHash() {
	var rpIdHash = this.authnrData.get(&quot;rpIdHash&quot;);

	if (rpIdHash instanceof Buffer) {
		rpIdHash = new Uint8Array(rpIdHash).buffer;
	}

	if (!(rpIdHash instanceof ArrayBuffer)) {
		throw new Error(&quot;couldn&#039;t coerce clientData rpIdHash to ArrayBuffer&quot;);
	}

	var domain = this.expectations.has(&quot;rpId&quot;)
		? this.expectations.get(&quot;rpId&quot;)
		: new URL(this.expectations.get(&quot;origin&quot;)).hostname;
	var createdHash = new Uint8Array(crypto.createHash(&quot;sha256&quot;).update(domain).digest()).buffer;

	// wouldn&#039;t it be weird if two SHA256 hashes were different lengths...?
	if (rpIdHash.byteLength !== createdHash.byteLength) {
		throw new Error(&quot;authnrData rpIdHash length mismatch&quot;);
	}

	rpIdHash = new Uint8Array(rpIdHash);
	createdHash = new Uint8Array(createdHash);
	for (let i = 0; i &lt; rpIdHash.byteLength; i++) {
		if (rpIdHash[i] !== createdHash[i]) {
			throw new TypeError(&quot;authnrData rpIdHash mismatch&quot;);
		}
	}

	this.audit.journal.add(&quot;rpIdHash&quot;);

	return true;
}

async function validateFlags() {
	var expectedFlags = this.expectations.get(&quot;flags&quot;);
	var flags = this.authnrData.get(&quot;flags&quot;);

	for (let expFlag of expectedFlags) {
		if (expFlag === &quot;UP-or-UV&quot;) {
			if (flags.has(&quot;UV&quot;)) {
				if (flags.has(&quot;UP&quot;)) {
					continue;
				} else {
					throw new Error(&quot;expected User Presence (UP) flag to be set if User Verification (UV) is set&quot;);
				}
			} else if (flags.has(&quot;UP&quot;)) {
				continue;
			} else {
				throw new Error(&quot;expected User Presence (UP) or User Verification (UV) flag to be set and neither was&quot;);
			}
		}

		if (expFlag === &quot;UV&quot;) {
			if (flags.has(&quot;UV&quot;)) {
				if (flags.has(&quot;UP&quot;)) {
					continue;
				} else {
					throw new Error(&quot;expected User Presence (UP) flag to be set if User Verification (UV) is set&quot;);
				}
			} else {
				throw new Error(`expected flag was not set: ${expFlag}`);
			}
		}

		if (!flags.has(expFlag)) {
			throw new Error(`expected flag was not set: ${expFlag}`);
		}
	}

	this.audit.journal.add(&quot;flags&quot;);

	return true;
}

async function validateInitialCounter() {
	var counter = this.authnrData.get(&quot;counter&quot;);

	// TODO: does counter need to be zero initially? probably not... I guess..
	if (typeof counter !== &quot;number&quot;) {
		throw new Error(&quot;authnrData counter wasn&#039;t a number&quot;);
	}

	this.audit.journal.add(&quot;counter&quot;);

	return true;
}

async function validateAaguid() {
	var aaguid = this.authnrData.get(&quot;aaguid&quot;);

	if (!(aaguid instanceof ArrayBuffer)) {
		throw new Error(&quot;authnrData AAGUID is not ArrayBuffer&quot;);
	}

	if (aaguid.byteLength !== 16) {
		throw new Error(&quot;authnrData AAGUID was wrong length&quot;);
	}

	this.audit.journal.add(&quot;aaguid&quot;);

	return true;
}

async function validateCredId() {
	var credId = this.authnrData.get(&quot;credId&quot;);
	var credIdLen = this.authnrData.get(&quot;credIdLen&quot;);

	if (!(credId instanceof ArrayBuffer)) {
		throw new Error(&quot;authnrData credId should be ArrayBuffer&quot;);
	}

	if (typeof credIdLen !== &quot;number&quot;) {
		throw new Error(&quot;authnrData credIdLen should be number, got &quot; + typeof credIdLen);
	}

	if (credId.byteLength !== credIdLen) {
		throw new Error(&quot;authnrData credId was wrong length&quot;);
	}

	this.audit.journal.add(&quot;credId&quot;);
	this.audit.journal.add(&quot;credIdLen&quot;);

	return true;
}

async function validatePublicKey() {
	// XXX: the parser has already turned this into PEM at this point
	// if something were malformatted or wrong, we probably would have
	// thrown an error well before this.
	// Maybe we parse the ASN.1 and make sure attributes are correct?
	// Doesn&#039;t seem very worthwhile...

	var cbor = this.authnrData.get(&quot;credentialPublicKeyCose&quot;);
	var jwk = this.authnrData.get(&quot;credentialPublicKeyJwk&quot;);
	var pem = this.authnrData.get(&quot;credentialPublicKeyPem&quot;);

	// cbor
	if (!(cbor instanceof ArrayBuffer)) {
		throw new Error(&quot;authnrData credentialPublicKeyCose isn&#039;t of type ArrayBuffer&quot;);
	}
	this.audit.journal.add(&quot;credentialPublicKeyCose&quot;);

	// jwk
	if (typeof jwk !== &quot;object&quot;) {
		throw new Error(&quot;authnrData credentialPublicKeyJwk isn&#039;t of type Object&quot;);
	}

	if (typeof jwk.kty !== &quot;string&quot;) {
		throw new Error(&quot;authnrData credentialPublicKeyJwk.kty isn&#039;t of type String&quot;);
	}

	if (typeof jwk.alg !== &quot;string&quot;) {
		throw new Error(&quot;authnrData credentialPublicKeyJwk.alg isn&#039;t of type String&quot;);
	}

	switch (jwk.kty) {
		case &quot;EC&quot;:
			if (typeof jwk.crv !== &quot;string&quot;) {
				throw new Error(&quot;authnrData credentialPublicKeyJwk.crv isn&#039;t of type String&quot;);
			}
			break;
		case &quot;RSA&quot;:
			if (typeof jwk.n !== &quot;string&quot;) {
				throw new Error(&quot;authnrData credentialPublicKeyJwk.n isn&#039;t of type String&quot;);
			}

			if (typeof jwk.e !== &quot;string&quot;) {
				throw new Error(&quot;authnrData credentialPublicKeyJwk.e isn&#039;t of type String&quot;);
			}
			break;
		default:
			throw new Error(&quot;authnrData unknown JWK key type: &quot; + jwk.kty);
	}

	this.audit.journal.add(&quot;credentialPublicKeyJwk&quot;);

	// pem
	if (typeof pem !== &quot;string&quot;) {
		throw new Error(&quot;authnrData credentialPublicKeyPem isn&#039;t of type String&quot;);
	}

	if (!isPem(pem)) {
		throw new Error(&quot;authnrData credentialPublicKeyPem was malformatted&quot;);
	}
	this.audit.journal.add(&quot;credentialPublicKeyPem&quot;);

	return true;
}

async function validateUserHandle() {
	var userHandle = this.authnrData.get(&quot;userHandle&quot;);

	if (userHandle === undefined ||
		userHandle === null ||
		userHandle === &quot;&quot;) {
		this.audit.journal.add(&quot;userHandle&quot;);
		return true;
	}

	userHandle = coerceToBase64Url(userHandle, &quot;userHandle&quot;);
	var expUserHandle = this.expectations.get(&quot;userHandle&quot;);
	if (typeof userHandle === &quot;string&quot; &amp;&amp;
		userHandle === expUserHandle) {
		this.audit.journal.add(&quot;userHandle&quot;);
		return true;
	}

	throw new Error(&quot;unable to validate userHandle&quot;);
}

async function validateCounter() {
	var prevCounter = this.expectations.get(&quot;prevCounter&quot;);
	var counter = this.authnrData.get(&quot;counter&quot;);
	var counterSupported = !(counter === 0 &amp;&amp; prevCounter === 0);

	if (counter &lt;= prevCounter &amp;&amp; counterSupported) {
		throw new Error(&quot;counter rollback detected&quot;);
	}

	this.audit.journal.add(&quot;counter&quot;);
	this.audit.info.set(&quot;counter-supported&quot;, &quot;&quot; + counterSupported);

	return true;
}

async function validateAudit() {
	var journal = this.audit.journal;
	var clientData = this.clientData;
	var authnrData = this.authnrData;

	for (let kv of clientData) {
		let val = kv[0];
		if (!journal.has(val)) {
			throw new Error(`internal audit failed: ${val} was not validated`);
		}
	}

	for (let kv of authnrData) {
		let val = kv[0];
		if (!journal.has(val)) {
			throw new Error(`internal audit failed: ${val} was not validated`);
		}
	}

	if (journal.size !== (clientData.size + authnrData.size)) {
		throw new Error(`internal audit failed: ${journal.size} fields checked; expected ${clientData.size + authnrData.size}`);
	}

	if (!this.audit.validExpectations) {
		throw new Error(&quot;internal audit failed: expectations not validated&quot;);
	}

	if (!this.audit.validRequest) {
		throw new Error(&quot;internal audit failed: request not validated&quot;);
	}

	this.audit.complete = true;

	return true;
}

function attach(o) {
	var mixins = {
		validateExpectations,
		validateCreateRequest,
		// clientData validators
		validateRawClientDataJson,
		validateOrigin,
		validateId,
		validateCreateType,
		validateGetType,
		validateChallenge,
		validateTokenBinding,
		validateTransports,
		// authnrData validators		
		validateRawAuthnrData,
		validateAttestation,
		validateAssertionSignature,
		validateRpIdHash,
		validateAaguid,
		validateCredId,
		validatePublicKey,
		validateFlags,
		validateUserHandle,
		validateCounter,
		validateInitialCounter,
		validateAssertionResponse,
		// audit structures
		audit: {
			validExpectations: false,
			validRequest: false,
			complete: false,
			journal: new Set(),
			warning: new Map(),
			info: new Map(),
		},
		validateAudit,
	};

	for (let key of Object.keys(mixins)) {
		o[key] = mixins[key];
	}
}

module.exports = {
	attach,
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
