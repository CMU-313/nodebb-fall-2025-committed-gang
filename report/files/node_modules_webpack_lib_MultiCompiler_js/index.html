<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/MultiCompiler.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/MultiCompiler.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">662</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">74.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const asyncLib = require(&quot;neo-async&quot;);
const { SyncHook, MultiHook } = require(&quot;tapable&quot;);

const ConcurrentCompilationError = require(&quot;./ConcurrentCompilationError&quot;);
const MultiStats = require(&quot;./MultiStats&quot;);
const MultiWatching = require(&quot;./MultiWatching&quot;);
const WebpackError = require(&quot;./WebpackError&quot;);
const ArrayQueue = require(&quot;./util/ArrayQueue&quot;);

/** @template T @typedef {import(&quot;tapable&quot;).AsyncSeriesHook&lt;T&gt;} AsyncSeriesHook&lt;T&gt; */
/** @template T @template R @typedef {import(&quot;tapable&quot;).SyncBailHook&lt;T, R&gt;} SyncBailHook&lt;T, R&gt; */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WatchOptions} WatchOptions */
/** @typedef {import(&quot;./Compiler&quot;)} Compiler */
/** @typedef {import(&quot;./Stats&quot;)} Stats */
/** @typedef {import(&quot;./Watching&quot;)} Watching */
/** @typedef {import(&quot;./logging/Logger&quot;).Logger} Logger */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/** @typedef {import(&quot;./util/fs&quot;).IntermediateFileSystem} IntermediateFileSystem */
/** @typedef {import(&quot;./util/fs&quot;).OutputFileSystem} OutputFileSystem */
/** @typedef {import(&quot;./util/fs&quot;).WatchFileSystem} WatchFileSystem */

/**
 * @template T
 * @callback Callback
 * @param {Error | null} err
 * @param {T=} result
 */

/**
 * @callback RunWithDependenciesHandler
 * @param {Compiler} compiler
 * @param {Callback&lt;MultiStats&gt;} callback
 */

/**
 * @typedef {object} MultiCompilerOptions
 * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel
 */

const CLASS_NAME = &quot;MultiCompiler&quot;;

module.exports = class MultiCompiler {
	/**
	 * @param {Compiler[] | Record&lt;string, Compiler&gt;} compilers child compilers
	 * @param {MultiCompilerOptions} options options
	 */
	constructor(compilers, options) {
		if (!Array.isArray(compilers)) {
			/** @type {Compiler[]} */
			compilers = Object.keys(compilers).map(name =&gt; {
				/** @type {Record&lt;string, Compiler&gt;} */
				(compilers)[name].name = name;
				return /** @type {Record&lt;string, Compiler&gt;} */ (compilers)[name];
			});
		}

		this.hooks = Object.freeze({
			/** @type {SyncHook&lt;[MultiStats]&gt;} */
			done: new SyncHook([&quot;stats&quot;]),
			/** @type {MultiHook&lt;SyncHook&lt;[string | null, number]&gt;&gt;} */
			invalid: new MultiHook(compilers.map(c =&gt; c.hooks.invalid)),
			/** @type {MultiHook&lt;AsyncSeriesHook&lt;[Compiler]&gt;&gt;} */
			run: new MultiHook(compilers.map(c =&gt; c.hooks.run)),
			/** @type {SyncHook&lt;[]&gt;} */
			watchClose: new SyncHook([]),
			/** @type {MultiHook&lt;AsyncSeriesHook&lt;[Compiler]&gt;&gt;} */
			watchRun: new MultiHook(compilers.map(c =&gt; c.hooks.watchRun)),
			/** @type {MultiHook&lt;SyncBailHook&lt;[string, string, EXPECTED_ANY[] | undefined], true | void&gt;&gt;} */
			infrastructureLog: new MultiHook(
				compilers.map(c =&gt; c.hooks.infrastructureLog)
			)
		});
		this.compilers = compilers;
		/** @type {MultiCompilerOptions} */
		this._options = {
			parallelism: options.parallelism || Infinity
		};
		/** @type {WeakMap&lt;Compiler, string[]&gt;} */
		this.dependencies = new WeakMap();
		this.running = false;

		/** @type {(Stats | null)[]} */
		const compilerStats = this.compilers.map(() =&gt; null);
		let doneCompilers = 0;
		for (let index = 0; index &lt; this.compilers.length; index++) {
			const compiler = this.compilers[index];
			const compilerIndex = index;
			let compilerDone = false;
			// eslint-disable-next-line no-loop-func
			compiler.hooks.done.tap(CLASS_NAME, stats =&gt; {
				if (!compilerDone) {
					compilerDone = true;
					doneCompilers++;
				}
				compilerStats[compilerIndex] = stats;
				if (doneCompilers === this.compilers.length) {
					this.hooks.done.call(
						new MultiStats(/** @type {Stats[]} */ (compilerStats))
					);
				}
			});
			// eslint-disable-next-line no-loop-func
			compiler.hooks.invalid.tap(CLASS_NAME, () =&gt; {
				if (compilerDone) {
					compilerDone = false;
					doneCompilers--;
				}
			});
		}
		this._validateCompilersOptions();
	}

	_validateCompilersOptions() {
		if (this.compilers.length &lt; 2) return;
		/**
		 * @param {Compiler} compiler compiler
		 * @param {WebpackError} warning warning
		 */
		const addWarning = (compiler, warning) =&gt; {
			compiler.hooks.thisCompilation.tap(CLASS_NAME, compilation =&gt; {
				compilation.warnings.push(warning);
			});
		};
		const cacheNames = new Set();
		for (const compiler of this.compilers) {
			if (compiler.options.cache &amp;&amp; &quot;name&quot; in compiler.options.cache) {
				const name = compiler.options.cache.name;
				if (cacheNames.has(name)) {
					addWarning(
						compiler,
						new WebpackError(
							`${
								compiler.name
									? `Compiler with name &quot;${compiler.name}&quot; doesn&#039;t use unique cache name. `
									: &quot;&quot;
							}Please set unique &quot;cache.name&quot; option. Name &quot;${name}&quot; already used.`
						)
					);
				} else {
					cacheNames.add(name);
				}
			}
		}
	}

	get options() {
		return Object.assign(
			this.compilers.map(c =&gt; c.options),
			this._options
		);
	}

	get outputPath() {
		let commonPath = this.compilers[0].outputPath;
		for (const compiler of this.compilers) {
			while (
				compiler.outputPath.indexOf(commonPath) !== 0 &amp;&amp;
				/[/\\]/.test(commonPath)
			) {
				commonPath = commonPath.replace(/[/\\][^/\\]*$/, &quot;&quot;);
			}
		}

		if (!commonPath &amp;&amp; this.compilers[0].outputPath[0] === &quot;/&quot;) return &quot;/&quot;;
		return commonPath;
	}

	get inputFileSystem() {
		throw new Error(&quot;Cannot read inputFileSystem of a MultiCompiler&quot;);
	}

	/**
	 * @param {InputFileSystem} value the new input file system
	 */
	set inputFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.inputFileSystem = value;
		}
	}

	get outputFileSystem() {
		throw new Error(&quot;Cannot read outputFileSystem of a MultiCompiler&quot;);
	}

	/**
	 * @param {OutputFileSystem} value the new output file system
	 */
	set outputFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.outputFileSystem = value;
		}
	}

	get watchFileSystem() {
		throw new Error(&quot;Cannot read watchFileSystem of a MultiCompiler&quot;);
	}

	/**
	 * @param {WatchFileSystem} value the new watch file system
	 */
	set watchFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.watchFileSystem = value;
		}
	}

	/**
	 * @param {IntermediateFileSystem} value the new intermediate file system
	 */
	set intermediateFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.intermediateFileSystem = value;
		}
	}

	get intermediateFileSystem() {
		throw new Error(&quot;Cannot read outputFileSystem of a MultiCompiler&quot;);
	}

	/**
	 * @param {string | (() =&gt; string)} name name of the logger, or function called once to get the logger name
	 * @returns {Logger} a logger with that name
	 */
	getInfrastructureLogger(name) {
		return this.compilers[0].getInfrastructureLogger(name);
	}

	/**
	 * @param {Compiler} compiler the child compiler
	 * @param {string[]} dependencies its dependencies
	 * @returns {void}
	 */
	setDependencies(compiler, dependencies) {
		this.dependencies.set(compiler, dependencies);
	}

	/**
	 * @param {Callback&lt;MultiStats&gt;} callback signals when the validation is complete
	 * @returns {boolean} true if the dependencies are valid
	 */
	validateDependencies(callback) {
		/** @type {Set&lt;{source: Compiler, target: Compiler}&gt;} */
		const edges = new Set();
		/** @type {string[]} */
		const missing = [];
		/**
		 * @param {Compiler} compiler compiler
		 * @returns {boolean} target was found
		 */
		const targetFound = compiler =&gt; {
			for (const edge of edges) {
				if (edge.target === compiler) {
					return true;
				}
			}
			return false;
		};
		/**
		 * @param {{source: Compiler, target: Compiler}} e1 edge 1
		 * @param {{source: Compiler, target: Compiler}} e2 edge 2
		 * @returns {number} result
		 */
		const sortEdges = (e1, e2) =&gt;
			/** @type {string} */
			(e1.source.name).localeCompare(/** @type {string} */ (e2.source.name)) ||
			/** @type {string} */
			(e1.target.name).localeCompare(/** @type {string} */ (e2.target.name));
		for (const source of this.compilers) {
			const dependencies = this.dependencies.get(source);
			if (dependencies) {
				for (const dep of dependencies) {
					const target = this.compilers.find(c =&gt; c.name === dep);
					if (!target) {
						missing.push(dep);
					} else {
						edges.add({
							source,
							target
						});
					}
				}
			}
		}
		/** @type {string[]} */
		const errors = missing.map(m =&gt; `Compiler dependency \`${m}\` not found.`);
		const stack = this.compilers.filter(c =&gt; !targetFound(c));
		while (stack.length &gt; 0) {
			const current = stack.pop();
			for (const edge of edges) {
				if (edge.source === current) {
					edges.delete(edge);
					const target = edge.target;
					if (!targetFound(target)) {
						stack.push(target);
					}
				}
			}
		}
		if (edges.size &gt; 0) {
			/** @type {string[]} */
			const lines = Array.from(edges)
				.sort(sortEdges)
				.map(edge =&gt; `${edge.source.name} -&gt; ${edge.target.name}`);
			lines.unshift(&quot;Circular dependency found in compiler dependencies.&quot;);
			errors.unshift(lines.join(&quot;\n&quot;));
		}
		if (errors.length &gt; 0) {
			const message = errors.join(&quot;\n&quot;);
			callback(new Error(message));
			return false;
		}
		return true;
	}

	// TODO webpack 6 remove
	/**
	 * @deprecated This method should have been private
	 * @param {Compiler[]} compilers the child compilers
	 * @param {RunWithDependenciesHandler} fn a handler to run for each compiler
	 * @param {Callback&lt;MultiStats&gt;} callback the compiler&#039;s handler
	 * @returns {void}
	 */
	runWithDependencies(compilers, fn, callback) {
		const fulfilledNames = new Set();
		let remainingCompilers = compilers;
		/**
		 * @param {string} d dependency
		 * @returns {boolean} when dependency was fulfilled
		 */
		const isDependencyFulfilled = d =&gt; fulfilledNames.has(d);
		/**
		 * @returns {Compiler[]} compilers
		 */
		const getReadyCompilers = () =&gt; {
			const readyCompilers = [];
			const list = remainingCompilers;
			remainingCompilers = [];
			for (const c of list) {
				const dependencies = this.dependencies.get(c);
				const ready =
					!dependencies || dependencies.every(isDependencyFulfilled);
				if (ready) {
					readyCompilers.push(c);
				} else {
					remainingCompilers.push(c);
				}
			}
			return readyCompilers;
		};
		/**
		 * @param {Callback&lt;MultiStats&gt;} callback callback
		 * @returns {void}
		 */
		const runCompilers = callback =&gt; {
			if (remainingCompilers.length === 0) return callback(null);
			asyncLib.map(
				getReadyCompilers(),
				(compiler, callback) =&gt; {
					fn(compiler, err =&gt; {
						if (err) return callback(err);
						fulfilledNames.add(compiler.name);
						runCompilers(callback);
					});
				},
				(err, results) =&gt; {
					callback(err, /** @type {TODO} */ (results));
				}
			);
		};
		runCompilers(callback);
	}

	/**
	 * @template SetupResult
	 * @param {(compiler: Compiler, index: number, doneCallback: Callback&lt;Stats&gt;, isBlocked: () =&gt; boolean, setChanged: () =&gt; void, setInvalid: () =&gt; void) =&gt; SetupResult} setup setup a single compiler
	 * @param {(compiler: Compiler, setupResult: SetupResult, callback: Callback&lt;Stats&gt;) =&gt; void} run run/continue a single compiler
	 * @param {Callback&lt;MultiStats&gt;} callback callback when all compilers are done, result includes Stats of all changed compilers
	 * @returns {SetupResult[]} result of setup
	 */
	_runGraph(setup, run, callback) {
		/** @typedef {{ compiler: Compiler, setupResult: undefined | SetupResult, result: undefined | Stats, state: &quot;pending&quot; | &quot;blocked&quot; | &quot;queued&quot; | &quot;starting&quot; | &quot;running&quot; | &quot;running-outdated&quot; | &quot;done&quot;, children: Node[], parents: Node[] }} Node */

		// State transitions for nodes:
		// -&gt; blocked (initial)
		// blocked -&gt; starting [running++] (when all parents done)
		// queued -&gt; starting [running++] (when processing the queue)
		// starting -&gt; running (when run has been called)
		// running -&gt; done [running--] (when compilation is done)
		// done -&gt; pending (when invalidated from file change)
		// pending -&gt; blocked [add to queue] (when invalidated from aggregated changes)
		// done -&gt; blocked [add to queue] (when invalidated, from parent invalidation)
		// running -&gt; running-outdated (when invalidated, either from change or parent invalidation)
		// running-outdated -&gt; blocked [running--] (when compilation is done)

		/** @type {Node[]} */
		const nodes = this.compilers.map(compiler =&gt; ({
			compiler,
			setupResult: undefined,
			result: undefined,
			state: &quot;blocked&quot;,
			children: [],
			parents: []
		}));
		/** @type {Map&lt;string, Node&gt;} */
		const compilerToNode = new Map();
		for (const node of nodes) {
			compilerToNode.set(/** @type {string} */ (node.compiler.name), node);
		}
		for (const node of nodes) {
			const dependencies = this.dependencies.get(node.compiler);
			if (!dependencies) continue;
			for (const dep of dependencies) {
				const parent = /** @type {Node} */ (compilerToNode.get(dep));
				node.parents.push(parent);
				parent.children.push(node);
			}
		}
		/** @type {ArrayQueue&lt;Node&gt;} */
		const queue = new ArrayQueue();
		for (const node of nodes) {
			if (node.parents.length === 0) {
				node.state = &quot;queued&quot;;
				queue.enqueue(node);
			}
		}
		let errored = false;
		let running = 0;
		const parallelism = /** @type {number} */ (this._options.parallelism);
		/**
		 * @param {Node} node node
		 * @param {(Error | null)=} err error
		 * @param {Stats=} stats result
		 * @returns {void}
		 */
		const nodeDone = (node, err, stats) =&gt; {
			if (errored) return;
			if (err) {
				errored = true;
				return asyncLib.each(
					nodes,
					(node, callback) =&gt; {
						if (node.compiler.watching) {
							node.compiler.watching.close(callback);
						} else {
							callback();
						}
					},
					() =&gt; callback(err)
				);
			}
			node.result = stats;
			running--;
			if (node.state === &quot;running&quot;) {
				node.state = &quot;done&quot;;
				for (const child of node.children) {
					if (child.state === &quot;blocked&quot;) queue.enqueue(child);
				}
			} else if (node.state === &quot;running-outdated&quot;) {
				node.state = &quot;blocked&quot;;
				queue.enqueue(node);
			}
			processQueue();
		};
		/**
		 * @param {Node} node node
		 * @returns {void}
		 */
		const nodeInvalidFromParent = node =&gt; {
			if (node.state === &quot;done&quot;) {
				node.state = &quot;blocked&quot;;
			} else if (node.state === &quot;running&quot;) {
				node.state = &quot;running-outdated&quot;;
			}
			for (const child of node.children) {
				nodeInvalidFromParent(child);
			}
		};
		/**
		 * @param {Node} node node
		 * @returns {void}
		 */
		const nodeInvalid = node =&gt; {
			if (node.state === &quot;done&quot;) {
				node.state = &quot;pending&quot;;
			} else if (node.state === &quot;running&quot;) {
				node.state = &quot;running-outdated&quot;;
			}
			for (const child of node.children) {
				nodeInvalidFromParent(child);
			}
		};
		/**
		 * @param {Node} node node
		 * @returns {void}
		 */
		const nodeChange = node =&gt; {
			nodeInvalid(node);
			if (node.state === &quot;pending&quot;) {
				node.state = &quot;blocked&quot;;
			}
			if (node.state === &quot;blocked&quot;) {
				queue.enqueue(node);
				processQueue();
			}
		};

		/** @type {SetupResult[]} */
		const setupResults = [];
		for (const [i, node] of nodes.entries()) {
			setupResults.push(
				(node.setupResult = setup(
					node.compiler,
					i,
					nodeDone.bind(null, node),
					() =&gt; node.state !== &quot;starting&quot; &amp;&amp; node.state !== &quot;running&quot;,
					() =&gt; nodeChange(node),
					() =&gt; nodeInvalid(node)
				))
			);
		}
		let processing = true;
		const processQueue = () =&gt; {
			if (processing) return;
			processing = true;
			process.nextTick(processQueueWorker);
		};
		const processQueueWorker = () =&gt; {
			// eslint-disable-next-line no-unmodified-loop-condition
			while (running &lt; parallelism &amp;&amp; queue.length &gt; 0 &amp;&amp; !errored) {
				const node = /** @type {Node} */ (queue.dequeue());
				if (
					node.state === &quot;queued&quot; ||
					(node.state === &quot;blocked&quot; &amp;&amp;
						node.parents.every(p =&gt; p.state === &quot;done&quot;))
				) {
					running++;
					node.state = &quot;starting&quot;;
					run(
						node.compiler,
						/** @type {SetupResult} */ (node.setupResult),
						nodeDone.bind(null, node)
					);
					node.state = &quot;running&quot;;
				}
			}
			processing = false;
			if (
				!errored &amp;&amp;
				running === 0 &amp;&amp;
				nodes.every(node =&gt; node.state === &quot;done&quot;)
			) {
				const stats = [];
				for (const node of nodes) {
					const result = node.result;
					if (result) {
						node.result = undefined;
						stats.push(result);
					}
				}
				if (stats.length &gt; 0) {
					callback(null, new MultiStats(stats));
				}
			}
		};
		processQueueWorker();
		return setupResults;
	}

	/**
	 * @param {WatchOptions|WatchOptions[]} watchOptions the watcher&#039;s options
	 * @param {Callback&lt;MultiStats&gt;} handler signals when the call finishes
	 * @returns {MultiWatching} a compiler watcher
	 */
	watch(watchOptions, handler) {
		if (this.running) {
			return handler(new ConcurrentCompilationError());
		}
		this.running = true;

		if (this.validateDependencies(handler)) {
			const watchings = this._runGraph(
				(compiler, idx, callback, isBlocked, setChanged, setInvalid) =&gt; {
					const watching = compiler.watch(
						Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions,
						callback
					);
					if (watching) {
						watching._onInvalid = setInvalid;
						watching._onChange = setChanged;
						watching._isBlocked = isBlocked;
					}
					return watching;
				},
				(compiler, watching, callback) =&gt; {
					if (compiler.watching !== watching) return;
					if (!watching.running) watching.invalidate();
				},
				handler
			);
			return new MultiWatching(watchings, this);
		}

		return new MultiWatching([], this);
	}

	/**
	 * @param {Callback&lt;MultiStats&gt;} callback signals when the call finishes
	 * @returns {void}
	 */
	run(callback) {
		if (this.running) {
			return callback(new ConcurrentCompilationError());
		}
		this.running = true;

		if (this.validateDependencies(callback)) {
			this._runGraph(
				() =&gt; {},
				(compiler, setupResult, callback) =&gt; compiler.run(callback),
				(err, stats) =&gt; {
					this.running = false;

					if (callback !== undefined) {
						return callback(err, stats);
					}
				}
			);
		}
	}

	purgeInputFileSystem() {
		for (const compiler of this.compilers) {
			if (compiler.inputFileSystem &amp;&amp; compiler.inputFileSystem.purge) {
				compiler.inputFileSystem.purge();
			}
		}
	}

	/**
	 * @param {Callback&lt;void&gt;} callback signals when the compiler closes
	 * @returns {void}
	 */
	close(callback) {
		asyncLib.each(
			this.compilers,
			(compiler, callback) =&gt; {
				compiler.close(callback);
			},
			error =&gt; {
				callback(error);
			}
		);
	}
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
