<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/core-js-pure/modules/web.url.constructor.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/core-js-pure/modules/web.url.constructor.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1052</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">150.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;
// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
require(&#039;../modules/es.string.iterator&#039;);
var $ = require(&#039;../internals/export&#039;);
var DESCRIPTORS = require(&#039;../internals/descriptors&#039;);
var USE_NATIVE_URL = require(&#039;../internals/url-constructor-detection&#039;);
var globalThis = require(&#039;../internals/global-this&#039;);
var bind = require(&#039;../internals/function-bind-context&#039;);
var uncurryThis = require(&#039;../internals/function-uncurry-this&#039;);
var defineBuiltIn = require(&#039;../internals/define-built-in&#039;);
var defineBuiltInAccessor = require(&#039;../internals/define-built-in-accessor&#039;);
var anInstance = require(&#039;../internals/an-instance&#039;);
var hasOwn = require(&#039;../internals/has-own-property&#039;);
var assign = require(&#039;../internals/object-assign&#039;);
var arrayFrom = require(&#039;../internals/array-from&#039;);
var arraySlice = require(&#039;../internals/array-slice&#039;);
var codeAt = require(&#039;../internals/string-multibyte&#039;).codeAt;
var toASCII = require(&#039;../internals/string-punycode-to-ascii&#039;);
var $toString = require(&#039;../internals/to-string&#039;);
var setToStringTag = require(&#039;../internals/set-to-string-tag&#039;);
var validateArgumentsLength = require(&#039;../internals/validate-arguments-length&#039;);
var URLSearchParamsModule = require(&#039;../modules/web.url-search-params.constructor&#039;);
var InternalStateModule = require(&#039;../internals/internal-state&#039;);

var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor(&#039;URL&#039;);
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;

var NativeURL = globalThis.URL;
var TypeError = globalThis.TypeError;
var parseInt = globalThis.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis(&#039;&#039;.charAt);
var exec = uncurryThis(/./.exec);
var join = uncurryThis([].join);
var numberToString = uncurryThis(1.1.toString);
var pop = uncurryThis([].pop);
var push = uncurryThis([].push);
var replace = uncurryThis(&#039;&#039;.replace);
var shift = uncurryThis([].shift);
var split = uncurryThis(&#039;&#039;.split);
var stringSlice = uncurryThis(&#039;&#039;.slice);
var toLowerCase = uncurryThis(&#039;&#039;.toLowerCase);
var unshift = uncurryThis([].unshift);

var INVALID_AUTHORITY = &#039;Invalid authority&#039;;
var INVALID_SCHEME = &#039;Invalid scheme&#039;;
var INVALID_HOST = &#039;Invalid host&#039;;
var INVALID_PORT = &#039;Invalid port&#039;;

var ALPHA = /[a-z]/i;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
/* eslint-disable regexp/no-control-character -- safe */
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:&lt;&gt;?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:&lt;&gt;?@[\\\]^|]/;
var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable regexp/no-control-character -- safe */
// eslint-disable-next-line no-unassigned-vars -- expected `undefined` value
var EOF;

// https://url.spec.whatwg.org/#ipv4-number-parser
var parseIPv4 = function (input) {
  var parts = split(input, &#039;.&#039;);
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length &amp;&amp; parts[parts.length - 1] === &#039;&#039;) {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength &gt; 4) return input;
  numbers = [];
  for (index = 0; index &lt; partsLength; index++) {
    part = parts[index];
    if (part === &#039;&#039;) return input;
    radix = 10;
    if (part.length &gt; 1 &amp;&amp; charAt(part, 0) === &#039;0&#039;) {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix === 8 ? 1 : 2);
    }
    if (part === &#039;&#039;) {
      number = 0;
    } else {
      if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
      number = parseInt(part, radix);
    }
    push(numbers, number);
  }
  for (index = 0; index &lt; partsLength; index++) {
    number = numbers[index];
    if (index === partsLength - 1) {
      if (number &gt;= pow(256, 5 - partsLength)) return null;
    } else if (number &gt; 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index &lt; numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// https://url.spec.whatwg.org/#concept-ipv6-parser
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var chr = function () {
    return charAt(input, pointer);
  };

  if (chr() === &#039;:&#039;) {
    if (charAt(input, 1) !== &#039;:&#039;) return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex === 8) return;
    if (chr() === &#039;:&#039;) {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length &lt; 4 &amp;&amp; exec(HEX, chr())) {
      value = value * 16 + parseInt(chr(), 16);
      pointer++;
      length++;
    }
    if (chr() === &#039;.&#039;) {
      if (length === 0) return;
      pointer -= length;
      if (pieceIndex &gt; 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen &gt; 0) {
          if (chr() === &#039;.&#039; &amp;&amp; numbersSeen &lt; 4) pointer++;
          else return;
        }
        if (!exec(DIGIT, chr())) return;
        while (exec(DIGIT, chr())) {
          number = parseInt(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece === 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece &gt; 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
      }
      if (numbersSeen !== 4) return;
      break;
    } else if (chr() === &#039;:&#039;) {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 &amp;&amp; swaps &gt; 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex !== 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index &lt; 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength &gt; maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  return currLength &gt; maxLength ? currStart : maxIndex;
};

// https://url.spec.whatwg.org/#host-serializing
var serializeHost = function (host) {
  var result, index, compress, ignore0;

  // ipv4
  if (typeof host == &#039;number&#039;) {
    result = [];
    for (index = 0; index &lt; 4; index++) {
      unshift(result, host % 256);
      host = floor(host / 256);
    }
    return join(result, &#039;.&#039;);
  }

  // ipv6
  if (typeof host == &#039;object&#039;) {
    result = &#039;&#039;;
    compress = findLongestZeroSequence(host);
    for (index = 0; index &lt; 8; index++) {
      if (ignore0 &amp;&amp; host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? &#039;:&#039; : &#039;::&#039;;
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index &lt; 7) result += &#039;:&#039;;
      }
    }
    return &#039;[&#039; + result + &#039;]&#039;;
  }

  return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  &#039; &#039;: 1, &#039;&quot;&#039;: 1, &#039;&lt;&#039;: 1, &#039;&gt;&#039;: 1, &#039;`&#039;: 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  &#039;#&#039;: 1, &#039;?&#039;: 1, &#039;{&#039;: 1, &#039;}&#039;: 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  &#039;/&#039;: 1, &#039;:&#039;: 1, &#039;;&#039;: 1, &#039;=&#039;: 1, &#039;@&#039;: 1, &#039;[&#039;: 1, &#039;\\&#039;: 1, &#039;]&#039;: 1, &#039;^&#039;: 1, &#039;|&#039;: 1
});

var percentEncode = function (chr, set) {
  var code = codeAt(chr, 0);
  return code &gt; 0x20 &amp;&amp; code &lt; 0x7F &amp;&amp; !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
};

// https://url.spec.whatwg.org/#special-scheme
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

// https://url.spec.whatwg.org/#windows-drive-letter
var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length === 2 &amp;&amp; exec(ALPHA, charAt(string, 0))
    &amp;&amp; ((second = charAt(string, 1)) === &#039;:&#039; || (!normalized &amp;&amp; second === &#039;|&#039;));
};

// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length &gt; 1 &amp;&amp; isWindowsDriveLetter(stringSlice(string, 0, 2)) &amp;&amp; (
    string.length === 2 ||
    ((third = charAt(string, 2)) === &#039;/&#039; || third === &#039;\\&#039; || third === &#039;?&#039; || third === &#039;#&#039;)
  );
};

// https://url.spec.whatwg.org/#single-dot-path-segment
var isSingleDot = function (segment) {
  return segment === &#039;.&#039; || toLowerCase(segment) === &#039;%2e&#039;;
};

// https://url.spec.whatwg.org/#double-dot-path-segment
var isDoubleDot = function (segment) {
  segment = toLowerCase(segment);
  return segment === &#039;..&#039; || segment === &#039;%2e.&#039; || segment === &#039;.%2e&#039; || segment === &#039;%2e%2e&#039;;
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

var URLState = function (url, isBase, base) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw new TypeError(failure);
    this.searchParams = null;
  } else {
    if (base !== undefined) baseState = new URLState(base, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw new TypeError(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};

URLState.prototype = {
  type: &#039;URL&#039;,
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function (input, stateOverride, base) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = &#039;&#039;;
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, chr, bufferCodePoints, failure;

    input = $toString(input);

    if (!stateOverride) {
      url.scheme = &#039;&#039;;
      url.username = &#039;&#039;;
      url.password = &#039;&#039;;
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace(input, LEADING_C0_CONTROL_OR_SPACE, &#039;&#039;);
      input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, &#039;$1&#039;);
    }

    input = replace(input, TAB_AND_NEW_LINE, &#039;&#039;);

    codePoints = arrayFrom(input);

    while (pointer &lt;= codePoints.length) {
      chr = codePoints[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr &amp;&amp; exec(ALPHA, chr)) {
            buffer += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;

        case SCHEME:
          if (chr &amp;&amp; (exec(ALPHANUMERIC, chr) || chr === &#039;+&#039; || chr === &#039;-&#039; || chr === &#039;.&#039;)) {
            buffer += toLowerCase(chr);
          } else if (chr === &#039;:&#039;) {
            if (stateOverride &amp;&amp; (
              (url.isSpecial() !== hasOwn(specialSchemes, buffer)) ||
              (buffer === &#039;file&#039; &amp;&amp; (url.includesCredentials() || url.port !== null)) ||
              (url.scheme === &#039;file&#039; &amp;&amp; !url.host)
            )) return;
            url.scheme = buffer;
            if (stateOverride) {
              if (url.isSpecial() &amp;&amp; specialSchemes[url.scheme] === url.port) url.port = null;
              return;
            }
            buffer = &#039;&#039;;
            if (url.scheme === &#039;file&#039;) {
              state = FILE;
            } else if (url.isSpecial() &amp;&amp; base &amp;&amp; base.scheme === url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] === &#039;/&#039;) {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push(url.path, &#039;&#039;);
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = &#039;&#039;;
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;

        case NO_SCHEME:
          if (!base || (base.cannotBeABaseURL &amp;&amp; chr !== &#039;#&#039;)) return INVALID_SCHEME;
          if (base.cannotBeABaseURL &amp;&amp; chr === &#039;#&#039;) {
            url.scheme = base.scheme;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = &#039;&#039;;
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base.scheme === &#039;file&#039; ? FILE : RELATIVE;
          continue;

        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr === &#039;/&#039; &amp;&amp; codePoints[pointer + 1] === &#039;/&#039;) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          } break;

        case PATH_OR_AUTHORITY:
          if (chr === &#039;/&#039;) {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }

        case RELATIVE:
          url.scheme = base.scheme;
          if (chr === EOF) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
          } else if (chr === &#039;/&#039; || (chr === &#039;\\&#039; &amp;&amp; url.isSpecial())) {
            state = RELATIVE_SLASH;
          } else if (chr === &#039;?&#039;) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = &#039;&#039;;
            state = QUERY;
          } else if (chr === &#039;#&#039;) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = &#039;&#039;;
            state = FRAGMENT;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.path.length--;
            state = PATH;
            continue;
          } break;

        case RELATIVE_SLASH:
          if (url.isSpecial() &amp;&amp; (chr === &#039;/&#039; || chr === &#039;\\&#039;)) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr === &#039;/&#039;) {
            state = AUTHORITY;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            state = PATH;
            continue;
          } break;

        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr !== &#039;/&#039; || charAt(buffer, pointer + 1) !== &#039;/&#039;) continue;
          pointer++;
          break;

        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr !== &#039;/&#039; &amp;&amp; chr !== &#039;\\&#039;) {
            state = AUTHORITY;
            continue;
          } break;

        case AUTHORITY:
          if (chr === &#039;@&#039;) {
            if (seenAt) buffer = &#039;%40&#039; + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);
            for (var i = 0; i &lt; bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint === &#039;:&#039; &amp;&amp; !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer = &#039;&#039;;
          } else if (
            chr === EOF || chr === &#039;/&#039; || chr === &#039;?&#039; || chr === &#039;#&#039; ||
            (chr === &#039;\\&#039; &amp;&amp; url.isSpecial())
          ) {
            if (seenAt &amp;&amp; buffer === &#039;&#039;) return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = &#039;&#039;;
            state = HOST;
          } else buffer += chr;
          break;

        case HOST:
        case HOSTNAME:
          if (stateOverride &amp;&amp; url.scheme === &#039;file&#039;) {
            state = FILE_HOST;
            continue;
          } else if (chr === &#039;:&#039; &amp;&amp; !seenBracket) {
            if (buffer === &#039;&#039;) return INVALID_HOST;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = &#039;&#039;;
            state = PORT;
            if (stateOverride === HOSTNAME) return;
          } else if (
            chr === EOF || chr === &#039;/&#039; || chr === &#039;?&#039; || chr === &#039;#&#039; ||
            (chr === &#039;\\&#039; &amp;&amp; url.isSpecial())
          ) {
            if (url.isSpecial() &amp;&amp; buffer === &#039;&#039;) return INVALID_HOST;
            if (stateOverride &amp;&amp; buffer === &#039;&#039; &amp;&amp; (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = &#039;&#039;;
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr === &#039;[&#039;) seenBracket = true;
            else if (chr === &#039;]&#039;) seenBracket = false;
            buffer += chr;
          } break;

        case PORT:
          if (exec(DIGIT, chr)) {
            buffer += chr;
          } else if (
            chr === EOF || chr === &#039;/&#039; || chr === &#039;?&#039; || chr === &#039;#&#039; ||
            (chr === &#039;\\&#039; &amp;&amp; url.isSpecial()) ||
            stateOverride
          ) {
            if (buffer !== &#039;&#039;) {
              var port = parseInt(buffer, 10);
              if (port &gt; 0xFFFF) return INVALID_PORT;
              url.port = (url.isSpecial() &amp;&amp; port === specialSchemes[url.scheme]) ? null : port;
              buffer = &#039;&#039;;
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;

        case FILE:
          url.scheme = &#039;file&#039;;
          if (chr === &#039;/&#039; || chr === &#039;\\&#039;) state = FILE_SLASH;
          else if (base &amp;&amp; base.scheme === &#039;file&#039;) {
            switch (chr) {
              case EOF:
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.query = base.query;
                break;
              case &#039;?&#039;:
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.query = &#039;&#039;;
                state = QUERY;
                break;
              case &#039;#&#039;:
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = &#039;&#039;;
                state = FRAGMENT;
                break;
              default:
                if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), &#039;&#039;))) {
                  url.host = base.host;
                  url.path = arraySlice(base.path);
                  url.shortenPath();
                }
                state = PATH;
                continue;
            }
          } else {
            state = PATH;
            continue;
          } break;

        case FILE_SLASH:
          if (chr === &#039;/&#039; || chr === &#039;\\&#039;) {
            state = FILE_HOST;
            break;
          }
          if (base &amp;&amp; base.scheme === &#039;file&#039; &amp;&amp; !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), &#039;&#039;))) {
            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
            else url.host = base.host;
          }
          state = PATH;
          continue;

        case FILE_HOST:
          if (chr === EOF || chr === &#039;/&#039; || chr === &#039;\\&#039; || chr === &#039;?&#039; || chr === &#039;#&#039;) {
            if (!stateOverride &amp;&amp; isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer === &#039;&#039;) {
              url.host = &#039;&#039;;
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer);
              if (failure) return failure;
              if (url.host === &#039;localhost&#039;) url.host = &#039;&#039;;
              if (stateOverride) return;
              buffer = &#039;&#039;;
              state = PATH_START;
            } continue;
          } else buffer += chr;
          break;

        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr !== &#039;/&#039; &amp;&amp; chr !== &#039;\\&#039;) continue;
          } else if (!stateOverride &amp;&amp; chr === &#039;?&#039;) {
            url.query = &#039;&#039;;
            state = QUERY;
          } else if (!stateOverride &amp;&amp; chr === &#039;#&#039;) {
            url.fragment = &#039;&#039;;
            state = FRAGMENT;
          } else if (chr !== EOF) {
            state = PATH;
            if (chr !== &#039;/&#039;) continue;
          } break;

        case PATH:
          if (
            chr === EOF || chr === &#039;/&#039; ||
            (chr === &#039;\\&#039; &amp;&amp; url.isSpecial()) ||
            (!stateOverride &amp;&amp; (chr === &#039;?&#039; || chr === &#039;#&#039;))
          ) {
            if (isDoubleDot(buffer)) {
              url.shortenPath();
              if (chr !== &#039;/&#039; &amp;&amp; !(chr === &#039;\\&#039; &amp;&amp; url.isSpecial())) {
                push(url.path, &#039;&#039;);
              }
            } else if (isSingleDot(buffer)) {
              if (chr !== &#039;/&#039; &amp;&amp; !(chr === &#039;\\&#039; &amp;&amp; url.isSpecial())) {
                push(url.path, &#039;&#039;);
              }
            } else {
              if (url.scheme === &#039;file&#039; &amp;&amp; !url.path.length &amp;&amp; isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = &#039;&#039;;
                buffer = charAt(buffer, 0) + &#039;:&#039;; // normalize windows drive letter
              }
              push(url.path, buffer);
            }
            buffer = &#039;&#039;;
            if (url.scheme === &#039;file&#039; &amp;&amp; (chr === EOF || chr === &#039;?&#039; || chr === &#039;#&#039;)) {
              while (url.path.length &gt; 1 &amp;&amp; url.path[0] === &#039;&#039;) {
                shift(url.path);
              }
            }
            if (chr === &#039;?&#039;) {
              url.query = &#039;&#039;;
              state = QUERY;
            } else if (chr === &#039;#&#039;) {
              url.fragment = &#039;&#039;;
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(chr, pathPercentEncodeSet);
          } break;

        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr === &#039;?&#039;) {
            url.query = &#039;&#039;;
            state = QUERY;
          } else if (chr === &#039;#&#039;) {
            url.fragment = &#039;&#039;;
            state = FRAGMENT;
          } else if (chr !== EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case QUERY:
          if (!stateOverride &amp;&amp; chr === &#039;#&#039;) {
            url.fragment = &#039;&#039;;
            state = FRAGMENT;
          } else if (chr !== EOF) {
            if (chr === &quot;&#039;&quot; &amp;&amp; url.isSpecial()) url.query += &#039;%27&#039;;
            else if (chr === &#039;#&#039;) url.query += &#039;%23&#039;;
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case FRAGMENT:
          if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }

      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function (input) {
    var result, codePoints, index;
    if (charAt(input, 0) === &#039;[&#039;) {
      if (charAt(input, input.length - 1) !== &#039;]&#039;) return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    // opaque host
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = &#039;&#039;;
      codePoints = arrayFrom(input);
      for (index = 0; index &lt; codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function () {
    return !this.host || this.cannotBeABaseURL || this.scheme === &#039;file&#039;;
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function () {
    return this.username !== &#039;&#039; || this.password !== &#039;&#039;;
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function () {
    return hasOwn(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function () {
    var path = this.path;
    var pathSize = path.length;
    if (pathSize &amp;&amp; (this.scheme !== &#039;file&#039; || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
      path.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function () {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + &#039;:&#039;;
    if (host !== null) {
      output += &#039;//&#039;;
      if (url.includesCredentials()) {
        output += username + (password ? &#039;:&#039; + password : &#039;&#039;) + &#039;@&#039;;
      }
      output += serializeHost(host);
      if (port !== null) output += &#039;:&#039; + port;
    } else if (scheme === &#039;file&#039;) output += &#039;//&#039;;
    output += url.cannotBeABaseURL ? path[0] : path.length ? &#039;/&#039; + join(path, &#039;/&#039;) : &#039;&#039;;
    if (query !== null) output += &#039;?&#039; + query;
    if (fragment !== null) output += &#039;#&#039; + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function (href) {
    var failure = this.parse(href);
    if (failure) throw new TypeError(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function () {
    var scheme = this.scheme;
    var port = this.port;
    if (scheme === &#039;blob&#039;) try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error) {
      return &#039;null&#039;;
    }
    if (scheme === &#039;file&#039; || !this.isSpecial()) return &#039;null&#039;;
    return scheme + &#039;://&#039; + serializeHost(this.host) + (port !== null ? &#039;:&#039; + port : &#039;&#039;);
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function () {
    return this.scheme + &#039;:&#039;;
  },
  setProtocol: function (protocol) {
    this.parse($toString(protocol) + &#039;:&#039;, SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function () {
    return this.username;
  },
  setUsername: function (username) {
    var codePoints = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = &#039;&#039;;
    for (var i = 0; i &lt; codePoints.length; i++) {
      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function () {
    return this.password;
  },
  setPassword: function (password) {
    var codePoints = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = &#039;&#039;;
    for (var i = 0; i &lt; codePoints.length; i++) {
      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function () {
    var host = this.host;
    var port = this.port;
    return host === null ? &#039;&#039;
      : port === null ? serializeHost(host)
      : serializeHost(host) + &#039;:&#039; + port;
  },
  setHost: function (host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function () {
    var host = this.host;
    return host === null ? &#039;&#039; : serializeHost(host);
  },
  setHostname: function (hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function () {
    var port = this.port;
    return port === null ? &#039;&#039; : $toString(port);
  },
  setPort: function (port) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port = $toString(port);
    if (port === &#039;&#039;) this.port = null;
    else this.parse(port, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function () {
    var path = this.path;
    return this.cannotBeABaseURL ? path[0] : path.length ? &#039;/&#039; + join(path, &#039;/&#039;) : &#039;&#039;;
  },
  setPathname: function (pathname) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function () {
    var query = this.query;
    return query ? &#039;?&#039; + query : &#039;&#039;;
  },
  setSearch: function (search) {
    search = $toString(search);
    if (search === &#039;&#039;) {
      this.query = null;
    } else {
      if (charAt(search, 0) === &#039;?&#039;) search = stringSlice(search, 1);
      this.query = &#039;&#039;;
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function () {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function () {
    var fragment = this.fragment;
    return fragment ? &#039;#&#039; + fragment : &#039;&#039;;
  },
  setHash: function (hash) {
    hash = $toString(hash);
    if (hash === &#039;&#039;) {
      this.fragment = null;
      return;
    }
    if (charAt(hash, 0) === &#039;#&#039;) hash = stringSlice(hash, 1);
    this.fragment = &#039;&#039;;
    this.parse(hash, FRAGMENT);
  },
  update: function () {
    this.query = this.searchParams.serialize() || null;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLPrototype);
  var base = validateArgumentsLength(arguments.length, 1) &gt; 1 ? arguments[1] : undefined;
  var state = setInternalState(that, new URLState(url, false, base));
  if (!DESCRIPTORS) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};

var URLPrototype = URLConstructor.prototype;

var accessorDescriptor = function (getter, setter) {
  return {
    get: function () {
      return getInternalURLState(this)[getter]();
    },
    set: setter &amp;&amp; function (value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};

if (DESCRIPTORS) {
  // `URL.prototype.href` accessors pair
  // https://url.spec.whatwg.org/#dom-url-href
  defineBuiltInAccessor(URLPrototype, &#039;href&#039;, accessorDescriptor(&#039;serialize&#039;, &#039;setHref&#039;));
  // `URL.prototype.origin` getter
  // https://url.spec.whatwg.org/#dom-url-origin
  defineBuiltInAccessor(URLPrototype, &#039;origin&#039;, accessorDescriptor(&#039;getOrigin&#039;));
  // `URL.prototype.protocol` accessors pair
  // https://url.spec.whatwg.org/#dom-url-protocol
  defineBuiltInAccessor(URLPrototype, &#039;protocol&#039;, accessorDescriptor(&#039;getProtocol&#039;, &#039;setProtocol&#039;));
  // `URL.prototype.username` accessors pair
  // https://url.spec.whatwg.org/#dom-url-username
  defineBuiltInAccessor(URLPrototype, &#039;username&#039;, accessorDescriptor(&#039;getUsername&#039;, &#039;setUsername&#039;));
  // `URL.prototype.password` accessors pair
  // https://url.spec.whatwg.org/#dom-url-password
  defineBuiltInAccessor(URLPrototype, &#039;password&#039;, accessorDescriptor(&#039;getPassword&#039;, &#039;setPassword&#039;));
  // `URL.prototype.host` accessors pair
  // https://url.spec.whatwg.org/#dom-url-host
  defineBuiltInAccessor(URLPrototype, &#039;host&#039;, accessorDescriptor(&#039;getHost&#039;, &#039;setHost&#039;));
  // `URL.prototype.hostname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hostname
  defineBuiltInAccessor(URLPrototype, &#039;hostname&#039;, accessorDescriptor(&#039;getHostname&#039;, &#039;setHostname&#039;));
  // `URL.prototype.port` accessors pair
  // https://url.spec.whatwg.org/#dom-url-port
  defineBuiltInAccessor(URLPrototype, &#039;port&#039;, accessorDescriptor(&#039;getPort&#039;, &#039;setPort&#039;));
  // `URL.prototype.pathname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-pathname
  defineBuiltInAccessor(URLPrototype, &#039;pathname&#039;, accessorDescriptor(&#039;getPathname&#039;, &#039;setPathname&#039;));
  // `URL.prototype.search` accessors pair
  // https://url.spec.whatwg.org/#dom-url-search
  defineBuiltInAccessor(URLPrototype, &#039;search&#039;, accessorDescriptor(&#039;getSearch&#039;, &#039;setSearch&#039;));
  // `URL.prototype.searchParams` getter
  // https://url.spec.whatwg.org/#dom-url-searchparams
  defineBuiltInAccessor(URLPrototype, &#039;searchParams&#039;, accessorDescriptor(&#039;getSearchParams&#039;));
  // `URL.prototype.hash` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hash
  defineBuiltInAccessor(URLPrototype, &#039;hash&#039;, accessorDescriptor(&#039;getHash&#039;, &#039;setHash&#039;));
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
defineBuiltIn(URLPrototype, &#039;toJSON&#039;, function toJSON() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
defineBuiltIn(URLPrototype, &#039;toString&#039;, function toString() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, &#039;createObjectURL&#039;, bind(nativeCreateObjectURL, NativeURL));
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, &#039;revokeObjectURL&#039;, bind(nativeRevokeObjectURL, NativeURL));
}

setToStringTag(URLConstructor, &#039;URL&#039;);

$({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
