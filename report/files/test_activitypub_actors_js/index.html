<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/activitypub/actors.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/activitypub/actors.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">909</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.73</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const nconf = require(&#039;nconf&#039;);

const db = require(&#039;../mocks/databasemock&#039;);
const meta = require(&#039;../../src/meta&#039;);
const install = require(&#039;../../src/install&#039;);
const categories = require(&#039;../../src/categories&#039;);
const user = require(&#039;../../src/user&#039;);
const topics = require(&#039;../../src/topics&#039;);
const activitypub = require(&#039;../../src/activitypub&#039;);
const utils = require(&#039;../../src/utils&#039;);
const request = require(&#039;../../src/request&#039;);
const slugify = require(&#039;../../src/slugify&#039;);

const helpers = require(&#039;./helpers&#039;);

describe.skip(&#039;Actor asserton&#039;, () =&gt; {
	before(async () =&gt; {
		meta.config.activitypubEnabled = 1;
		await install.giveWorldPrivileges();
	});

	describe(&#039;happy path&#039;, () =&gt; {
		let uid;
		let actorUri;

		before(async () =&gt; {
			uid = utils.generateUUID().slice(0, 8);
			actorUri = `https://example.org/user/${uid}`;
			activitypub._cache.set(`0;${actorUri}`, {
				&#039;@context&#039;: &#039;https://www.w3.org/ns/activitystreams&#039;,
				id: actorUri,
				url: actorUri,

				type: &#039;Person&#039;,
				name: &#039;example&#039;,
				preferredUsername: &#039;example&#039;,
				inbox: `https://example.org/user/${uid}/inbox`,
				outbox: `https://example.org/user/${uid}/outbox`,

				publicKey: {
					id: `${actorUri}#key`,
					owner: actorUri,
					publicKeyPem: &#039;somekey&#039;,
				},
			});
			activitypub.helpers._webfingerCache.set(&#039;example@example.org&#039;, { actorUri });
		});

		it(&#039;should return true if successfully asserted&#039;, async () =&gt; {
			const result = await activitypub.actors.assert([actorUri]);
			assert(result &amp;&amp; result.length);
		});

		it(&#039;should contain a representation of that remote user in the database&#039;, async () =&gt; {
			const exists = await db.exists(`userRemote:${actorUri}`);
			assert(exists);

			const userData = await user.getUserData(actorUri);
			assert(userData);
			assert.strictEqual(userData.uid, actorUri);
		});

		it(&#039;should save the actor\&#039;s publicly accessible URL in the hash as well&#039;, async () =&gt; {
			const url = await user.getUserField(actorUri, &#039;url&#039;);
			assert.strictEqual(url, actorUri);
		});

		it(&#039;should assert group actors by calling actors.assertGroup&#039;, async () =&gt; {
			const { id, actor } = helpers.mocks.group();
			const assertion = await activitypub.actors.assert([id]);

			assert(assertion);
			assert.strictEqual(assertion.length, 1);
			assert.strictEqual(assertion[0].cid, actor.id);
		});

		describe(&#039;remote user to remote category migration&#039;, () =&gt; {
			it(&#039;should not migrate a user to a category if .assert is called&#039;, async () =&gt; {
				// ... because the user isn&#039;t due for an update and so is filtered out during qualification
				const { id } = helpers.mocks.person();
				await activitypub.actors.assert([id]);

				const { actor } = helpers.mocks.group({ id });
				const assertion = await activitypub.actors.assertGroup([id]);

				assert(assertion.length, 0);

				const exists = await user.exists(id);
				assert.strictEqual(exists, false);
			});

			it(&#039;should migrate a user to a category if on re-assertion it identifies as an as:Group&#039;, async () =&gt; {
				// This is to handle previous behaviour that saved all as:Group actors as NodeBB users.
				const { id } = helpers.mocks.person();
				await activitypub.actors.assert([id]);

				helpers.mocks.group({ id });
				const assertion = await activitypub.actors.assertGroup([id]);

				assert(assertion &amp;&amp; Array.isArray(assertion) &amp;&amp; assertion.length === 1);

				const exists = await user.exists(id);
				assert.strictEqual(exists, false);
			});

			it(&#039;should migrate any shares by that user, into topics in the category&#039;, async () =&gt; {
				const { id } = helpers.mocks.person();
				await activitypub.actors.assert([id]);

				// Two shares
				for (let x = 0; x &lt; 2; x++) {
					const { id: pid } = helpers.mocks.note();
					// eslint-disable-next-line no-await-in-loop
					const { tid } = await activitypub.notes.assert(0, pid, { skipChecks: 1 });
					// eslint-disable-next-line no-await-in-loop
					await db.sortedSetAdd(`uid:${id}:shares`, Date.now(), tid);
				}

				helpers.mocks.group({ id });
				await activitypub.actors.assertGroup([id]);

				const { topic_count, post_count } = await categories.getCategoryData(id);
				assert.strictEqual(topic_count, 2);
				assert.strictEqual(post_count, 2);
			});

			it(&#039;should not migrate shares by that user that already belong to a local category&#039;, async () =&gt; {
				const { id } = helpers.mocks.person();
				await activitypub.actors.assert([id]);

				const { cid } = await categories.create({ name: utils.generateUUID() });

				// Two shares, one moved to local cid
				for (let x = 0; x &lt; 2; x++) {
					const { id: pid } = helpers.mocks.note();
					// eslint-disable-next-line no-await-in-loop
					const { tid } = await activitypub.notes.assert(0, pid, { skipChecks: 1 });
					// eslint-disable-next-line no-await-in-loop
					await db.sortedSetAdd(`uid:${id}:shares`, Date.now(), tid);

					if (!x) {
						// eslint-disable-next-line no-await-in-loop
						await topics.tools.move(tid, {
							cid,
							uid: &#039;system&#039;,
						});
					}
				}

				helpers.mocks.group({ id });
				await activitypub.actors.assertGroup([id]);

				const { topic_count, post_count } = await categories.getCategoryData(id);
				assert.strictEqual(topic_count, 1);
				assert.strictEqual(post_count, 1);
			});

			it(&#039;should migrate any local followers into category watches&#039;, async () =&gt; {
				const { id } = helpers.mocks.person();
				await activitypub.actors.assert([id]);

				const followerUid = await user.create({ username: utils.generateUUID() });
				await Promise.all([
					db.sortedSetAdd(`followingRemote:${followerUid}`, Date.now(), id),
					db.sortedSetAdd(`followersRemote:${id}`, Date.now(), followerUid),
				]);

				helpers.mocks.group({ id });
				await activitypub.actors.assertGroup([id]);

				const states = await categories.getWatchState([id], followerUid);
				assert.strictEqual(states[0], categories.watchStates.tracking);
			});
		});
	});

	describe(&#039;less happy paths&#039;, () =&gt; {
		describe(&#039;actor with `preferredUsername` that is not all lowercase&#039;, () =&gt; {
			it(&#039;should save a handle-to-uid association&#039;, async () =&gt; {
				const preferredUsername = &#039;nameWITHCAPS&#039;;
				const { id } = helpers.mocks.person({ preferredUsername });
				await activitypub.actors.assert([id]);

				const uid = await db.getObjectField(&#039;handle:uid&#039;, `${preferredUsername.toLowerCase()}@example.org`);
				assert.strictEqual(uid, id);
			});

			it(&#039;should preserve that association when re-asserted&#039;, async () =&gt; {
				const preferredUsername = &#039;nameWITHCAPS&#039;;
				const { id } = helpers.mocks.person({ preferredUsername });
				await activitypub.actors.assert([id]);
				await activitypub.actors.assert([id], { update: true });

				const uid = await db.getObjectField(&#039;handle:uid&#039;, `${preferredUsername.toLowerCase()}@example.org`);
				assert.strictEqual(uid, id);
			});

			it(&#039;should fail to assert if a passed-in ID\&#039;s webfinger query does not respond with the same ID (gh#13352)&#039;, async () =&gt; {
				const { id } = helpers.mocks.person({
					preferredUsername: &#039;foobar&#039;,
				});

				const actorUri = `https://example.org/${utils.generateUUID()}`;
				activitypub.helpers._webfingerCache.set(&#039;foobar@example.org&#039;, {
					username: &#039;foobar&#039;,
					hostname: &#039;example.org&#039;,
					actorUri,
				});

				const { actorUri: confirm } = await activitypub.helpers.query(&#039;foobar@example.org&#039;);
				assert.strictEqual(confirm, actorUri);

				const response = await activitypub.actors.assert([id]);
				assert.deepStrictEqual(response, []);
			});
		});
	});

	describe(&#039;edge cases: loopback handles and uris&#039;, () =&gt; {
		let uid;
		const userslug = utils.generateUUID().slice(0, 8);
		before(async () =&gt; {
			uid = await user.create({ username: userslug });
		});

		it(&#039;should return true but not actually assert the handle into the database&#039;, async () =&gt; {
			const handle = `${userslug}@${nconf.get(&#039;url_parsed&#039;).host}`;
			const result = await activitypub.actors.assert([handle]);
			assert(result);

			const handleExists = await db.isObjectField(&#039;handle:uid&#039;, handle);
			assert.strictEqual(handleExists, false);

			const userRemoteHashExists = await db.exists(`userRemote:${nconf.get(&#039;url&#039;)}/uid/${uid}`);
			assert.strictEqual(userRemoteHashExists, false);
		});

		it(&#039;should return true but not actually assert the uri into the database&#039;, async () =&gt; {
			const uri = `${nconf.get(&#039;url&#039;)}/uid/${uid}`;
			const result = await activitypub.actors.assert([uri]);
			assert(result);

			const userRemoteHashExists = await db.exists(`userRemote:${uri}`);
			assert.strictEqual(userRemoteHashExists, false);
		});
	});
});

describe.skip(&#039;as:Group&#039;, () =&gt; {
	describe(&#039;assertion&#039;, () =&gt; {
		let actorUri;
		let actorData;

		before(async () =&gt; {
			const { id, actor } = helpers.mocks.group();
			actorUri = id;
			actorData = actor;
		});

		it(&#039;should assert a uri identifying as &quot;Group&quot; into a remote category&#039;, async () =&gt; {
			const assertion = await activitypub.actors.assertGroup([actorUri]);

			assert(assertion, Array.isArray(assertion));
			assert.strictEqual(assertion.length, 1);

			const category = assertion.pop();
			assert.strictEqual(category.cid, actorUri);
		});

		it(&#039;should be considered existing when checked&#039;, async () =&gt; {
			const exists = await categories.exists(actorUri);

			assert(exists);
		});

		it(&#039;should contain an entry in categories search zset&#039;, async () =&gt; {
			const exists = await db.isSortedSetMember(&#039;categories:name&#039;, `${actorData.name.toLowerCase()}:${actorUri}`);

			assert(exists);
		});

		it(&#039;should return category data when getter methods are called&#039;, async () =&gt; {
			const category = await categories.getCategoryData(actorUri);
			assert(category);
			assert.strictEqual(category.cid, actorUri);
		});

		it(&#039;should not assert non-group users when called&#039;, async () =&gt; {
			const { id } = helpers.mocks.person();
			const assertion = await activitypub.actors.assertGroup([id]);

			assert(Array.isArray(assertion) &amp;&amp; !assertion.length);
		});

		describe(&#039;deletion&#039;, () =&gt; {
			it(&#039;should delete a remote category when Categories.purge is called&#039;, async () =&gt; {
				const { id } = helpers.mocks.group();
				await activitypub.actors.assertGroup([id]);

				let exists = await categories.exists(id);
				assert(exists);

				await categories.purge(id, 0);

				exists = await categories.exists(id);
				assert(!exists);

				exists = await db.exists(`categoryRemote:${id}`);
				assert(!exists);
			});

			it(&#039;should also delete AP-specific keys that were added by assertGroup&#039;, async () =&gt; {
				const { id } = helpers.mocks.group();
				const assertion = await activitypub.actors.assertGroup([id]);
				const [{ handle, slug }] = assertion;

				await categories.purge(id, 0);

				const isMember = await db.isObjectField(&#039;handle:cid&#039;, handle);
				const inSearch = await db.isSortedSetMember(&#039;categories:name&#039;, `${slug}:${id}`);
				assert(!isMember);
				assert(!inSearch);
			});
		});
	});

	describe(&#039;following&#039;, () =&gt; {
		let uid;
		let cid;

		beforeEach(async () =&gt; {
			uid = await user.create({ username: utils.generateUUID() });
			({ id: cid } = helpers.mocks.group());
			await activitypub.actors.assertGroup([cid]);
		});

		afterEach(async () =&gt; {
			activitypub._sent.clear();
		});

		describe(&#039;user not already following&#039;, () =&gt; {
			it(&#039;should report a watch state consistent with not following&#039;, async () =&gt; {
				const states = await categories.getWatchState([cid], uid);
				assert(states[0] &lt;= categories.watchStates.notwatching);
			});

			it(&#039;should do nothing when category is a local category&#039;, async () =&gt; {
				const { cid } = await categories.create({ name: utils.generateUUID() });
				await user.setCategoryWatchState(uid, cid, categories.watchStates.tracking);
				assert.strictEqual(activitypub._sent.size, 0);
			});

			it(&#039;should do nothing when watch state changes to &quot;ignoring&quot;&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.ignoring);
				assert.strictEqual(activitypub._sent.size, 0);
			});

			it(&#039;should send out a Follow activity when watch state changes to &quot;tracking&quot;&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.tracking);

				assert.strictEqual(activitypub._sent.size, 1);

				const activity = Array.from(activitypub._sent.values()).pop();
				assert.strictEqual(activity.type, &#039;Follow&#039;);
				assert.strictEqual(activity.object, cid);
			});

			it(&#039;should send out a Follow activity when the watch state changes to &quot;watching&quot;&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.watching);

				assert.strictEqual(activitypub._sent.size, 1);

				const activity = Array.from(activitypub._sent.values()).pop();
				assert(activity &amp;&amp; activity.object &amp;&amp; typeof activity.object === &#039;string&#039;);
				assert.strictEqual(activity.type, &#039;Follow&#039;);
				assert.strictEqual(activity.object, cid);
			});

			it(&#039;should not show up in the user\&#039;s following list&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.watching);

				// Trigger inbox accept
				const { activity: body } = helpers.mocks.accept(cid, {
					type: &#039;Follow&#039;,
					actor: `${nconf.get(&#039;url&#039;)}/uid/${uid}`,
				});
				await activitypub.inbox.accept({ body });

				const following = await user.getFollowing(uid, 0, 1);
				assert(Array.isArray(following));
				assert.strictEqual(following.length, 0);
			});
		});

		describe(&#039;user already following&#039;, () =&gt; {
			beforeEach(async () =&gt; {
				await Promise.all([
					user.setCategoryWatchState(uid, cid, categories.watchStates.tracking),
					db.sortedSetAdd(`followingRemote:${uid}`, Date.now(), cid),
				]);

				activitypub._sent.clear();
			});

			it(&#039;should report a watch state consistent with following&#039;, async () =&gt; {
				const states = await categories.getWatchState([cid], uid);
				assert(states[0] &gt;= categories.watchStates.tracking);
			});

			it(&#039;should do nothing when category is a local category&#039;, async () =&gt; {
				const { cid } = await categories.create({ name: utils.generateUUID() });
				await user.setCategoryWatchState(uid, cid, categories.watchStates.ignoring);
				assert.strictEqual(activitypub._sent.size, 0);
			});

			it(&#039;should do nothing when watch state changes to &quot;tracking&quot;&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.tracking);
				assert.strictEqual(activitypub._sent.size, 0);
			});

			it(&#039;should do nothing when watch state changes to &quot;watching&quot;&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.watching);
				assert.strictEqual(activitypub._sent.size, 0);
			});

			it(&#039;should send out an Undo(Follow) activity when watch state changes to &quot;ignoring&quot;&#039;, async () =&gt; {
				await user.setCategoryWatchState(uid, cid, categories.watchStates.ignoring);

				assert.strictEqual(activitypub._sent.size, 1);

				const activity = Array.from(activitypub._sent.values()).pop();
				assert(activity &amp;&amp; activity.object &amp;&amp; typeof activity.object === &#039;object&#039;);
				assert.strictEqual(activity.type, &#039;Undo&#039;);
				assert.strictEqual(activity.object.type, &#039;Follow&#039;);
				assert.strictEqual(activity.object.actor, `${nconf.get(&#039;url&#039;)}/uid/${uid}`);
				assert.strictEqual(activity.object.object, cid);
			});
		});
	});
});

describe.skip(&#039;Inbox resolution&#039;, () =&gt; {
	describe(&#039;remote users&#039;, () =&gt; {
		it(&#039;should return an inbox if present&#039;, async () =&gt; {
			const { id, actor } = helpers.mocks.person();
			await activitypub.actors.assert(id);

			const inboxes = await activitypub.resolveInboxes([id]);

			assert(inboxes &amp;&amp; Array.isArray(inboxes));
			assert.strictEqual(inboxes.length, 1);
			assert.strictEqual(inboxes[0], actor.inbox);
		});

		it(&#039;should return a shared inbox if present&#039;, async () =&gt; {
			const { id, actor } = helpers.mocks.person({
				endpoints: {
					sharedInbox: &#039;https://example.org/inbox&#039;,
				},
			});
			await activitypub.actors.assert(id);

			const inboxes = await activitypub.resolveInboxes([id]);

			assert(inboxes &amp;&amp; Array.isArray(inboxes));
			assert.strictEqual(inboxes.length, 1);
			assert.strictEqual(inboxes[0], &#039;https://example.org/inbox&#039;);
		});
	});

	describe(&#039;remote categories&#039;, () =&gt; {
		it(&#039;should return an inbox if present&#039;, async () =&gt; {
			const { id, actor } = helpers.mocks.group();
			await activitypub.actors.assertGroup(id);

			const inboxes = await activitypub.resolveInboxes([id]);

			assert(inboxes &amp;&amp; Array.isArray(inboxes));
			assert.strictEqual(inboxes.length, 1);
			assert.strictEqual(inboxes[0], actor.inbox);
		});

		it(&#039;should return a shared inbox if present&#039;, async () =&gt; {
			const { id, actor } = helpers.mocks.group({
				endpoints: {
					sharedInbox: &#039;https://example.org/inbox&#039;,
				},
			});
			await activitypub.actors.assertGroup(id);

			const inboxes = await activitypub.resolveInboxes([id]);

			assert(inboxes &amp;&amp; Array.isArray(inboxes));
			assert.strictEqual(inboxes.length, 1);
			assert.strictEqual(inboxes[0], &#039;https://example.org/inbox&#039;);
		});
	});
});

describe.skip(&#039;Controllers&#039;, () =&gt; {
	describe(&#039;User Actor endpoint&#039;, () =&gt; {
		let uid;
		let slug;

		beforeEach(async () =&gt; {
			slug = slugify(utils.generateUUID().slice(0, 8));
			uid = await user.create({ username: slug });
		});

		it(&#039;should return a valid ActivityPub Actor JSON-LD payload&#039;, async () =&gt; {
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/uid/${uid}`, {
				headers: {
					Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
				},
			});

			assert(response);
			assert.strictEqual(response.statusCode, 200);
			assert(body.hasOwnProperty(&#039;@context&#039;));
			assert(body[&#039;@context&#039;].includes(&#039;https://www.w3.org/ns/activitystreams&#039;));

			[&#039;id&#039;, &#039;url&#039;, &#039;followers&#039;, &#039;following&#039;, &#039;inbox&#039;, &#039;outbox&#039;].forEach((prop) =&gt; {
				assert(body.hasOwnProperty(prop));
				assert(body[prop]);
			});

			assert.strictEqual(body.id, `${nconf.get(&#039;url&#039;)}/uid/${uid}`);
			assert.strictEqual(body.type, &#039;Person&#039;);
		});

		it(&#039;should contain a `publicKey` property with a public key&#039;, async () =&gt; {
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/uid/${uid}`, {
				headers: {
					Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
				},
			});

			assert(body.hasOwnProperty(&#039;publicKey&#039;));
			assert([&#039;id&#039;, &#039;owner&#039;, &#039;publicKeyPem&#039;].every(prop =&gt; body.publicKey.hasOwnProperty(prop)));
		});
	});

	describe(&#039;Category Actor endpoint&#039;, () =&gt; {
		let cid;
		let slug;
		let description;

		beforeEach(async () =&gt; {
			slug = slugify(utils.generateUUID().slice(0, 8));
			description = utils.generateUUID();
			({ cid } = await categories.create({
				name: slug,
				description,
			}));
		});

		it(&#039;should return a valid ActivityPub Actor JSON-LD payload&#039;, async () =&gt; {
			const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/category/${cid}`, {
				headers: {
					Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
				},
			});

			assert(response);
			assert.strictEqual(response.statusCode, 200);
			assert(body.hasOwnProperty(&#039;@context&#039;));
			assert(body[&#039;@context&#039;].includes(&#039;https://www.w3.org/ns/activitystreams&#039;));

			[&#039;id&#039;, &#039;url&#039;, /* &#039;followers&#039;, &#039;following&#039;, */ &#039;inbox&#039;, &#039;outbox&#039;].forEach((prop) =&gt; {
				assert(body.hasOwnProperty(prop));
				assert(body[prop]);
			});

			assert.strictEqual(body.id, `${nconf.get(&#039;url&#039;)}/category/${cid}`);
			assert.strictEqual(body.type, &#039;Group&#039;);
			assert(body.summary.startsWith(description));
			assert.deepStrictEqual(body.icon, {
				type: &#039;Image&#039;,
				mediaType: &#039;image/png&#039;,
				url: `${nconf.get(&#039;url&#039;)}/assets/uploads/category/category-${cid}-icon.png`,
			});
		});

		it(&#039;should contain a `publicKey` property with a public key&#039;, async () =&gt; {
			const { body } = await request.get(`${nconf.get(&#039;url&#039;)}/category/${cid}`, {
				headers: {
					Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
				},
			});

			assert(body.hasOwnProperty(&#039;publicKey&#039;));
			assert([&#039;id&#039;, &#039;owner&#039;, &#039;publicKeyPem&#039;].every(prop =&gt; body.publicKey.hasOwnProperty(prop)));
		});

		it(&#039;should serve the the backgroundImage in `icon` if set&#039;, async () =&gt; {
			const payload = {};
			payload[cid] = {
				backgroundImage: `/assets/uploads/files/test.png`,
			};
			await categories.update(payload);

			const { body } = await request.get(`${nconf.get(&#039;url&#039;)}/category/${cid}`, {
				headers: {
					Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
				},
			});

			assert.deepStrictEqual(body.icon, {
				type: &#039;Image&#039;,
				mediaType: &#039;image/png&#039;,
				url: `${nconf.get(&#039;url&#039;)}/assets/uploads/files/test.png`,
			});
		});
	});

	describe(&#039;Instance Actor endpoint&#039;, () =&gt; {
		let response;
		let body;

		before(async () =&gt; {
			({ response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/actor`, {
				headers: {
					Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
				},
			}));
		});

		it(&#039;should respond properly&#039;, async () =&gt; {
			assert(response);
			assert.strictEqual(response.statusCode, 200);
		});

		it(&#039;should return a valid ActivityPub Actor JSON-LD payload&#039;, async () =&gt; {
			assert(body.hasOwnProperty(&#039;@context&#039;));
			assert(body[&#039;@context&#039;].includes(&#039;https://www.w3.org/ns/activitystreams&#039;));

			[&#039;id&#039;, &#039;url&#039;, &#039;inbox&#039;, &#039;outbox&#039;, &#039;name&#039;, &#039;preferredUsername&#039;].forEach((prop) =&gt; {
				assert(body.hasOwnProperty(prop));
				assert(body[prop]);
			});

			assert.strictEqual(body.id, body.url);
			assert.strictEqual(body.type, &#039;Application&#039;);
			assert.strictEqual(body.name, meta.config.site_title || &#039;NodeBB&#039;);
			assert.strictEqual(body.preferredUsername, nconf.get(&#039;url_parsed&#039;).hostname);
		});

		it(&#039;should contain a `publicKey` property with a public key&#039;, async () =&gt; {
			assert(body.hasOwnProperty(&#039;publicKey&#039;));
			assert([&#039;id&#039;, &#039;owner&#039;, &#039;publicKeyPem&#039;].every(prop =&gt; body.publicKey.hasOwnProperty(prop)));
		});

		it(&#039;should also have a valid WebFinger response tied to `preferredUsername`&#039;, async () =&gt; {
			const { response, body: body2 } = await request.get(`${nconf.get(&#039;url&#039;)}/.well-known/webfinger?resource=acct%3a${body.preferredUsername}@${nconf.get(&#039;url_parsed&#039;).host}`);

			assert.strictEqual(response.statusCode, 200);
			assert(body2 &amp;&amp; body2.aliases &amp;&amp; body2.links);
			assert(body2.aliases.includes(nconf.get(&#039;url&#039;)));
			assert(body2.links.some(item =&gt; item.rel === &#039;self&#039; &amp;&amp; item.type === &#039;application/activity+json&#039; &amp;&amp; item.href === `${nconf.get(&#039;url&#039;)}/actor`));
		});
	});

	describe(&#039;Topic Collection endpoint&#039;, () =&gt; {
		let cid;
		let uid;

		before(async () =&gt; {
			({ cid } = await categories.create({ name: utils.generateUUID().slice(0, 8) }));
			const slug = slugify(utils.generateUUID().slice(0, 8));
			uid = await user.create({ username: slug });
		});

		describe(&#039;Live&#039;, () =&gt; {
			let topicData;
			let response;
			let body;

			before(async () =&gt; {
				({ topicData } = await topics.post({
					uid,
					cid,
					title: &#039;Lorem &quot;Lipsum&quot; Ipsum&#039;,
					content: &#039;Lorem ipsum dolor sit amet&#039;,
				}));

				({ response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/topic/${topicData.slug}`, {
					headers: {
						Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
					},
				}));
			});

			it(&#039;should respond properly&#039;, async () =&gt; {
				assert(response);
				assert.strictEqual(response.statusCode, 200);
			});

			it(&#039;should return an OrderedCollection with one item&#039;, () =&gt; {
				assert.strictEqual(body.type, &#039;OrderedCollection&#039;);
				assert.strictEqual(body.totalItems, 1);
				assert(Array.isArray(body.orderedItems));
				assert.strictEqual(body.orderedItems[0], `${nconf.get(&#039;url&#039;)}/post/${topicData.mainPid}`);
			});
		});

		describe(&#039;Scheduled&#039;, () =&gt; {
			let topicData;
			let response;
			let body;

			before(async () =&gt; {
				({ topicData } = await topics.post({
					uid,
					cid,
					title: &#039;Lorem &quot;Lipsum&quot; Ipsum&#039;,
					content: &#039;Lorem ipsum dolor sit amet&#039;,
					timestamp: Date.now() + (1000 * 60 * 60), // 1 hour in the future
				}));

				({ response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/topic/${topicData.slug}`, {
					headers: {
						Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
					},
				}));
			});

			it(&#039;should respond with a 404 Not Found&#039;, async () =&gt; {
				assert(response);
				assert.strictEqual(response.statusCode, 404);
			});
		});
	});

	describe(&#039;Post Object endpoint&#039;, () =&gt; {
		let cid;
		let uid;

		before(async () =&gt; {
			({ cid } = await categories.create({ name: utils.generateUUID().slice(0, 8) }));
			const slug = slugify(utils.generateUUID().slice(0, 8));
			uid = await user.create({ username: slug });
		});

		describe(&#039;Live&#039;, () =&gt; {
			let postData;
			let response;
			let body;

			before(async () =&gt; {
				({ postData } = await topics.post({
					uid,
					cid,
					title: &#039;Lorem &quot;Lipsum&quot; Ipsum&#039;,
					content: &#039;Lorem ipsum dolor sit amet&#039;,
				}));

				({ response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/post/${postData.pid}`, {
					headers: {
						Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
					},
				}));
			});

			it(&#039;should respond properly&#039;, async () =&gt; {
				assert(response);
				assert.strictEqual(response.statusCode, 200);
			});

			it(&#039;should return a Article type object&#039;, () =&gt; {
				assert.strictEqual(body.type, &#039;Article&#039;);
			});
		});

		describe(&#039;Scheduled&#039;, () =&gt; {
			let topicData;
			let postData;
			let response;
			let body;

			before(async () =&gt; {
				({ topicData, postData } = await topics.post({
					uid,
					cid,
					title: &#039;Lorem &quot;Lipsum&quot; Ipsum&#039;,
					content: &#039;Lorem ipsum dolor sit amet&#039;,
					timestamp: Date.now() + (1000 * 60 * 60), // 1 hour in the future
				}));

				({ response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/post/${postData.pid}`, {
					headers: {
						Accept: &#039;application/ld+json; profile=&quot;https://www.w3.org/ns/activitystreams&quot;&#039;,
					},
				}));
			});

			it(&#039;should respond with a 404 Not Found&#039;, async () =&gt; {
				assert(response);
				assert.strictEqual(response.statusCode, 404);
			});
		});
	});
});

describe.skip(&#039;Pruning&#039;, () =&gt; {
	before(async () =&gt; {
		meta.config.activitypubEnabled = 1;
		await install.giveWorldPrivileges();

		meta.config.activitypubUserPruneDays = 0; // trigger immediate pruning
	});

	after(() =&gt; {
		meta.config.activitypubUserPruneDays = 7;
	});

	describe.skip(&#039;Users&#039;, () =&gt; {
		it(&#039;should do nothing if the user is newer than the prune cutoff&#039;, async () =&gt; {
			const { id: uid } = helpers.mocks.person();
			await activitypub.actors.assert([uid]);

			meta.config.activitypubUserPruneDays = 1;
			const result = await activitypub.actors.prune();

			assert.strictEqual(result.counts.deleted, 0);
			assert.strictEqual(result.counts.preserved, 0);
			assert.strictEqual(result.counts.missing, 0);

			meta.config.activitypubUserPruneDays = 0;
			user.deleteAccount(uid);
		});

		it(&#039;should purge the user if they have no content (posts, likes, etc.)&#039;, async () =&gt; {
			const { id: uid } = helpers.mocks.person();
			await activitypub.actors.assert([uid]);

			const total = await db.sortedSetCard(&#039;usersRemote:lastCrawled&#039;);
			const result = await activitypub.actors.prune();

			assert(result.counts.deleted &gt;= 1);
		});

		it(&#039;should do nothing if the user has some content (e.g. a topic)&#039;, async () =&gt; {
			const { cid } = await categories.create({ name: utils.generateUUID() });
			const { id: uid } = helpers.mocks.person();
			const { id, note } = helpers.mocks.note({
				attributedTo: uid,
				cc: [`${nconf.get(&#039;url&#039;)}/category/${cid}`],
			});

			const assertion = await activitypub.notes.assert(0, id);
			assert(assertion);

			const result = await activitypub.actors.prune();

			assert.strictEqual(result.counts.deleted, 0);
			assert.strictEqual(result.counts.preserved, 1);
			assert.strictEqual(result.counts.missing, 0);
		});
	});

	describe(&#039;Categories&#039;, () =&gt; {
		it(&#039;should do nothing if the category is newer than the prune cutoff&#039;, async () =&gt; {
			const { id: cid } = helpers.mocks.group();
			await activitypub.actors.assertGroup([cid]);

			meta.config.activitypubUserPruneDays = 1;
			const result = await activitypub.actors.prune();

			assert.strictEqual(result.counts.deleted, 0);
			assert.strictEqual(result.counts.preserved, 0);
			assert.strictEqual(result.counts.missing, 0);

			meta.config.activitypubUserPruneDays = 0;
			await categories.purge(cid, 0);
		});

		it(&#039;should purge the category if it has no topics in it&#039;, async () =&gt; {
			const { id: cid } = helpers.mocks.group();
			await activitypub.actors.assertGroup([cid]);

			const total = await db.sortedSetCard(&#039;usersRemote:lastCrawled&#039;);
			const result = await activitypub.actors.prune();

			assert.strictEqual(result.counts.deleted, 1);
			assert.strictEqual(result.counts.preserved, total - 1);
		});

		it(&#039;should do nothing if the category has topics in it&#039;, async () =&gt; {
			const { id: cid } = helpers.mocks.group();
			await activitypub.actors.assertGroup([cid]);

			const { id } = helpers.mocks.note({
				cc: [cid],
			});
			await activitypub.notes.assert(0, id, { cid });

			const total = await db.sortedSetCard(&#039;usersRemote:lastCrawled&#039;);
			const result = await activitypub.actors.prune();

			assert.strictEqual(result.counts.deleted, 0);
			assert.strictEqual(result.counts.preserved, total);
			assert(result.preserved.has(cid));
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
