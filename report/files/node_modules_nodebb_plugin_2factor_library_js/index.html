<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-plugin-2factor/library.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-plugin-2factor/library.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">472</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">54.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const passport = require.main.require(&#039;passport&#039;);
const passportTotp = require(&#039;passport-totp&#039;).Strategy;
const notp = require(&#039;notp&#039;);
const { Fido2Lib } = require(&#039;fido2-lib&#039;);
const base64url = require(&#039;base64url&#039;);

const db = require.main.require(&#039;./src/database&#039;);
const nconf = require.main.require(&#039;nconf&#039;);
const async = require.main.require(&#039;async&#039;);
const winston = require.main.require(&#039;winston&#039;);
const user = require.main.require(&#039;./src/user&#039;);
const meta = require.main.require(&#039;./src/meta&#039;);
const groups = require.main.require(&#039;./src/groups&#039;);
const plugins = require.main.require(&#039;./src/plugins&#039;);
const notifications = require.main.require(&#039;./src/notifications&#039;);
const utils = require.main.require(&#039;./src/utils&#039;);
const routeHelpers = require.main.require(&#039;./src/routes/helpers&#039;);
const controllerHelpers = require.main.require(&#039;./src/controllers/helpers&#039;);
const SocketPlugins = require.main.require(&#039;./src/socket.io/plugins&#039;);

const atob = base64str =&gt; Buffer.from(base64str, &#039;base64&#039;).toString(&#039;binary&#039;);

const plugin = {
	_f2l: undefined,
};

plugin.init = async (params) =&gt; {
	const { router } = params;
	const hostMiddleware = params.middleware;
	const accountMiddlewares = [
		hostMiddleware.exposeUid,
		hostMiddleware.ensureLoggedIn,
		hostMiddleware.canViewUsers,
		hostMiddleware.checkAccountPermissions,
		hostMiddleware.buildAccountData,
	];
	const hostHelpers = require.main.require(&#039;./src/routes/helpers&#039;);
	const controllers = require(&#039;./lib/controllers&#039;);
	const middlewares = require(&#039;./lib/middlewares&#039;);

	// Public-facing pages
	hostHelpers.setupPageRoute(router, &#039;/2factor/access-notification&#039;, controllers.renderAccessNotificationHelp);

	// ACP
	hostHelpers.setupAdminPageRoute(router, &#039;/admin/plugins/2factor&#039;, [hostMiddleware.pluginHooks], controllers.renderAdminPage);

	// UCP
	hostHelpers.setupPageRoute(router, &#039;/user/:userslug/2factor&#039;, accountMiddlewares, controllers.renderSettings);

	// 2fa Login
	hostHelpers.setupPageRoute(router, &#039;/login/2fa&#039;, [hostMiddleware.ensureLoggedIn], controllers.renderChoices);
	hostHelpers.setupPageRoute(router, &#039;/login/2fa/totp&#039;, [hostMiddleware.ensureLoggedIn], controllers.renderTotpChallenge);
	router.post(&#039;/login/2fa/totp&#039;, hostMiddleware.ensureLoggedIn, controllers.processTotpLogin, (req, res) =&gt; {
		req.session.tfa = true;
		delete req.session.tfaForce;
		req.session.meta.datetime = Date.now();
		user.auth.addSession(req.uid, req.sessionID, req.session.meta.uuid);
		res.redirect(nconf.get(&#039;relative_path&#039;) + (req.query.next || &#039;/&#039;));
	});
	hostHelpers.setupPageRoute(router, &#039;/login/2fa/authn&#039;, [hostMiddleware.ensureLoggedIn], controllers.renderAuthnChallenge);

	// 2fa backups codes
	hostHelpers.setupPageRoute(router, &#039;/login/2fa/backup&#039;, [hostMiddleware.ensureLoggedIn], controllers.renderBackup);
	router.post(&#039;/login/2fa/backup&#039;, hostMiddleware.ensureLoggedIn, controllers.processBackup, (req, res) =&gt; {
		req.session.tfa = true;
		res.redirect(nconf.get(&#039;relative_path&#039;) + (req.query.next || &#039;/&#039;));
	});
	router.put(&#039;/login/2fa/backup&#039;, hostMiddleware.requireUser, middlewares.requireSecondFactor, hostMiddleware.applyCSRF, controllers.generateBackupCodes);

	// Websockets
	SocketPlugins[&#039;2factor&#039;] = require(&#039;./websockets&#039;);

	// Login Strategy
	passport.use(new passportTotp(
		async (user, done) =&gt; {
			try {
				const key = await plugin.get(user.uid);
				return done(null, key, 30);
			} catch (e) {
				return done(e);
			}
		}
	));

	// Fido2Lib instantiation
	plugin._f2l = new Fido2Lib({
		timeout: 60 * 1000, // 60 seconds
		rpId: nconf.get(&#039;url_parsed&#039;).hostname,
		rpName: meta.config.title || &#039;NodeBB&#039;,
	});

	// Configure 2FA path exemptions
	let prefixes = [&#039;/reset&#039;, &#039;/confirm&#039;];
	let pages = [&#039;/login/2fa&#039;, &#039;/login/2fa/authn&#039;, &#039;/login/2fa/totp&#039;, &#039;/login/2fa/backup&#039;, &#039;/2factor/authn/verify&#039;, &#039;/register/complete&#039;];
	let paths = [&#039;/api/v3/plugins/2factor/authn/verify&#039;];
	({ prefixes, pages, paths } = await plugins.hooks.fire(&#039;filter:2factor.exemptions&#039;, { prefixes, pages, paths }));
	pages = pages.reduce((memo, cur) =&gt; {
		memo.push(nconf.get(&#039;relative_path&#039;) + cur);
		memo.push(`${nconf.get(&#039;relative_path&#039;)}/api${cur}`);
		return memo;
	}, []);
	plugin.exemptions = {
		prefixes,
		paths: new Set(pages.concat(paths)),
	};
};

plugin.addRoutes = async ({ router, middleware, helpers }) =&gt; {
	const middlewares = [
		middleware.ensureLoggedIn,
	];

	routeHelpers.setupApiRoute(router, &#039;get&#039;, &#039;/2factor/authn/register&#039;, middlewares, async (req, res) =&gt; {
		const registrationRequest = await plugin._f2l.attestationOptions();
		const userData = await user.getUserFields(req.uid, [&#039;username&#039;, &#039;displayname&#039;]);
		registrationRequest.user = {
			id: base64url(String(req.uid)),
			name: userData.username,
			displayName: userData.displayname,
		};
		registrationRequest.challenge = base64url(registrationRequest.challenge);
		req.session.registrationRequest = registrationRequest;
		helpers.formatApiResponse(200, res, registrationRequest);
	});

	routeHelpers.setupApiRoute(router, &#039;post&#039;, &#039;/2factor/authn/register&#039;, middlewares, async (req, res) =&gt; {
		const attestationExpectations = {
			challenge: req.session.registrationRequest.challenge,
			origin: `${nconf.get(&#039;url_parsed&#039;).protocol}//${nconf.get(&#039;url_parsed&#039;).host}`,
			factor: &#039;second&#039;,
		};
		req.body.rawId = Uint8Array.from(atob(base64url.toBase64(req.body.rawId)), c =&gt; c.charCodeAt(0)).buffer;
		const regResult = await plugin._f2l.attestationResult(req.body, attestationExpectations);
		plugin.saveAuthn(req.uid, regResult.authnrData);
		delete req.session.registrationRequest;
		req.session.tfa = true; // eliminate re-challenge on registration

		helpers.formatApiResponse(200, res);
	});

	// Note: auth request generated in Controllers.renderLogin
	routeHelpers.setupApiRoute(router, &#039;post&#039;, &#039;/2factor/authn/verify&#039;, middlewares, async (req, res) =&gt; {
		const prevCounter = await plugin.getAuthnCount(req.body.authResponse.id);
		const publicKey = await plugin.getAuthnPublicKey(req.uid, req.body.authResponse.id);
		const expectations = {
			challenge: req.session.authRequest,
			origin: `${nconf.get(&#039;url_parsed&#039;).protocol}//${nconf.get(&#039;url_parsed&#039;).host}`,
			factor: &#039;second&#039;,
			publicKey,
			prevCounter,
			userHandle: null,
		};

		req.body.authResponse.rawId =
			Uint8Array.from(atob(base64url.toBase64(req.body.authResponse.rawId)), c =&gt; c.charCodeAt(0)).buffer;
		req.body.authResponse.response.userHandle = undefined;

		const authnResult = await plugin._f2l.assertionResult(req.body.authResponse, expectations);
		const count = authnResult.authnrData.get(&#039;counter&#039;);
		await plugin.updateAuthnCount(req.body.authResponse.id, count);

		req.session.tfa = true;
		delete req.session.authRequest;
		delete req.session.tfaForce;
		req.session.meta.datetime = Date.now();

		helpers.formatApiResponse(200, res, {
			next: req.query.next || &#039;/&#039;,
		});
	});

	routeHelpers.setupApiRoute(router, &#039;delete&#039;, &#039;/2factor/authn&#039;, middlewares, async (req, res) =&gt; {
		const { uid } = req;
		const keyIds = await db.getObjectKeys(`2factor:webauthn:${uid}`);
		await db.sortedSetRemove(&#039;2factor:webauthn:counters&#039;, keyIds);
		await db.delete(`2factor:webauthn:${uid}`);

		helpers.formatApiResponse(200, res);
	});

	routeHelpers.setupApiRoute(router, &#039;delete&#039;, &#039;/2factor/totp&#039;, middlewares, async (req, res) =&gt; {
		await db.deleteObjectField(&#039;2factor:uid:key&#039;, req.uid);

		helpers.formatApiResponse(200, res);
	});
};

plugin.appendConfig = async (config) =&gt; {
	const hasKey = await plugin.hasKey(config.uid);
	config[&#039;2factor&#039;] = { hasKey };
	return config;
};

plugin.addAdminNavigation = function (header, callback) {
	header.plugins.push({
		route: &#039;/plugins/2factor&#039;,
		icon: &#039;fa-lock&#039;,
		name: &#039;[[2factor:title]]&#039;,
	});

	callback(null, header);
};

plugin.addProfileItem = function (data, callback) {
	data.links.push({
		id: &#039;2factor&#039;,
		route: &#039;2factor&#039;,
		icon: &#039;fa-lock&#039;,
		name: &#039;[[2factor:title]]&#039;,
		visibility: {
			self: true,
			other: false,
			moderator: false,
			globalMod: false,
			admin: false,
			canViewInfo: false,
		},
	});

	callback(null, data);
};

plugin.get = async uid =&gt; db.getObjectField(&#039;2factor:uid:key&#039;, uid);

plugin.getAuthnKeyIds = async (uid) =&gt; {
	const keys = await db.getObject(`2factor:webauthn:${uid}`);
	return Object.keys(keys);
};

plugin.getAuthnPublicKey = async (uid, id) =&gt; db.getObjectField(`2factor:webauthn:${uid}`, id);

plugin.getAuthnCount = async id =&gt; db.sortedSetScore(`2factor:webauthn:counters`, id);

plugin.updateAuthnCount = async (id, count) =&gt; db.sortedSetAdd(`2factor:webauthn:counters`, count, id);

plugin.save = function (uid, key, callback) {
	db.setObjectField(&#039;2factor:uid:key&#039;, uid, key, callback);
};

plugin.saveAuthn = (uid, authnrData) =&gt; {
	const counter = authnrData.get(&#039;counter&#039;);
	const publicKey = authnrData.get(&#039;credentialPublicKeyPem&#039;);
	const id = base64url(authnrData.get(&#039;credId&#039;));
	db.setObjectField(`2factor:webauthn:${uid}`, id, publicKey);
	db.sortedSetAdd(`2factor:webauthn:counters`, counter, id);
};

plugin.hasAuthn = async (uid) =&gt; {
	if (!(parseInt(uid, 10) &gt; 0)) {
		return false;
	}
	return await db.exists(`2factor:webauthn:${uid}`);
};

plugin.hasTotp = async (uid) =&gt; {
	if (!(parseInt(uid, 10) &gt; 0)) {
		return false;
	}
	return await db.isObjectField(&#039;2factor:uid:key&#039;, uid);
};

// hmm... remove?
plugin.hasKey = async (uid) =&gt; {
	const [hasTotp, hasAuthn] = await Promise.all([
		plugin.hasTotp(uid),
		plugin.hasAuthn(uid),
	]);

	return hasTotp || hasAuthn;
};

plugin.hasBackupCodes = async uid =&gt; db.exists(`2factor:uid:${uid}:backupCodes`);

plugin.countBackupCodes = async uid =&gt; db.setCount(`2factor:uid:${uid}:backupCodes`);

plugin.generateBackupCodes = function (uid, callback) {
	const set = `2factor:uid:${uid}:backupCodes`;
	const codes = [];
	let code;

	for (let x = 0; x &lt; 5; x++) {
		code = utils.generateUUID().replace(&#039;-&#039;, &#039;&#039;).slice(0, 10);
		codes.push(code);
	}

	async.series([
		async.apply(db.delete, set), // Invalidate all old codes
		async.apply(db.setAdd, set, codes), // Save new codes
		function (next) {
			notifications.create({
				bodyShort: &#039;[[2factor:notification.backupCode.generated]]&#039;,
				bodyLong: &#039;&#039;,
				nid: `2factor.backupCode.generated-${uid}-${Date.now()}`,
				from: uid,
				path: &#039;/&#039;,
			}, (err, notification) =&gt; {
				if (!err &amp;&amp; notification) {
					notifications.push(notification, [uid], next);
				}
			});
		},
	], (err) =&gt; {
		callback(err, codes);
	});
};

plugin.useBackupCode = function (code, uid, callback) {
	const set = `2factor:uid:${uid}:backupCodes`;

	async.waterfall([
		async.apply(db.isSetMember, set, code),
		function (valid, next) {
			if (valid) {
				// Invalidate this backup code
				db.setRemove(set, code, (err) =&gt; {
					next(err, valid);
				});

				notifications.create({
					bodyShort: &#039;[[2factor:notification.backupCode.used]]&#039;,
					bodyLong: &#039;&#039;,
					nid: `2factor.backupCode.used-${uid}-${Date.now()}`,
					from: uid,
					path: &#039;/&#039;,
				}, (err, notification) =&gt; {
					if (!err &amp;&amp; notification) {
						notifications.push(notification, [uid]);
					}
				});
			} else {
				next(null, valid);
			}
		},
	], callback);
};

plugin.disassociate = async (uid) =&gt; {
	await Promise.all([
		db.deleteObjectField(&#039;2factor:uid:key&#039;, uid),
		db.delete(`2factor:uid:${uid}:backupCodes`),
	]);

	// Clear U2F keys
	const keyIds = await db.getObjectKeys(`2factor:webauthn:${uid}`);
	await db.sortedSetRemove(&#039;2factor:webauthn:counters&#039;, keyIds);
	await db.delete(`2factor:webauthn:${uid}`);
};

plugin.overrideUid = async ({ req, locals }) =&gt; {
	if (req.uid &amp;&amp; await plugin.hasKey(req.uid) &amp;&amp; req.session.tfa !== true) {
		locals[&#039;2factor&#039;] = req.uid;
		req.uid = 0;
		delete req.user;
		delete req.loggedIn;
	}

	return { req, locals };
};

plugin.check = async ({ req, res }) =&gt; {
	if (!req.user || req.session.tfa === true) {
		return;
	}

	const requestPath = req.baseUrl + req.path;
	if (plugin.exemptions.paths.has(requestPath) || plugin.exemptions.prefixes.some(prefix =&gt; requestPath.startsWith(nconf.get(&#039;relative_path&#039;) + prefix))) {
		return;
	}

	let { tfaEnforcedGroups } = await meta.settings.get(&#039;2factor&#039;);
	tfaEnforcedGroups = JSON.parse(tfaEnforcedGroups || &#039;[]&#039;);

	const redirect = requestPath
		.replace(&#039;/api&#039;, &#039;&#039;)
		.replace(nconf.get(&#039;relative_path&#039;), &#039;&#039;);

	if (await plugin.hasKey(req.user.uid)) {
		if (!res.locals.isAPI) {
			// Account has TFA, redirect to login
			controllerHelpers.redirect(res, `/login/2fa?next=${redirect}`);
		} else {
			await controllerHelpers.formatApiResponse(401, res, new Error(&#039;[[2factor:second-factor-required]]&#039;));
		}
	} else if (tfaEnforcedGroups.length &amp;&amp; (await groups.isMemberOfGroups(req.uid, tfaEnforcedGroups)).includes(true)) {
		if (req.url.startsWith(&#039;/admin&#039;) || (!req.url.startsWith(&#039;/admin&#039;) &amp;&amp; !req.url.match(&#039;2factor&#039;))) {
			controllerHelpers.redirect(res, `/me/2factor?next=${redirect}`);
		}
	}

	// No TFA setup
};

plugin.checkSocket = async (data) =&gt; {
	if (!data.socket.uid || data.req.session.tfa === true) {
		return;
	}

	if (await plugin.hasKey(data.socket.uid)) {
		winston.info(`[plugin/2factor] Denying socket access for uid ${data.socket.uid} pending second factor.`);
		throw new Error(&#039;[[2factor:second-factor-required]]&#039;);
	}
};

plugin.clearSession = function (data, callback) {
	if (data.req.session) {
		delete data.req.session.tfa;
	}

	setImmediate(callback);
};

plugin.getUsers = function (callback) {
	async.waterfall([
		async.apply(db.getObjectKeys, &#039;2factor:uid:key&#039;),
		function (uids, next) {
			user.getUsersFields(uids, [&#039;username&#039;, &#039;userslug&#039;, &#039;picture&#039;], next);
		},
	], callback);
};

plugin.adjustRelogin = async ({ req, res }) =&gt; {
	if (await plugin.hasKey(req.uid)) {
		req.session.forceLogin = 0;
		req.session.tfaForce = 1;

		if (!res.locals.isAPI) {
			controllerHelpers.redirect(res, `/login/2fa?next=${req.session.returnTo}`);
		}
	}
};

plugin.handle2faFailure = async (uid) =&gt; {
	const notification = await notifications.create({
		bodyShort: &#039;[[2factor:notification.failure]]&#039;,
		bodyLong: &#039;&#039;,
		nid: `2factor.failure.${uid}-${Date.now()}`,
		from: uid,
		path: `/2factor/access-notification?when=${Date.now()}`,
	});

	await notifications.push(notification, [uid]);
};

plugin.integrations = {};

plugin.integrations.writeApi = async (data) =&gt; {
	const routeTest = /^\/api\/v\d\/users\/\d+\/tokens\/?/;
	const uidMatch = data.route.match(/(\d+)\/tokens$/);
	const uid = uidMatch ? parseInt(uidMatch[1], 10) : 0;

	// Enforce 2FA on token generation route
	if (data.method === &#039;POST&#039; &amp;&amp; routeTest.test(data.route) &amp;&amp; await plugin.hasTotp(uid)) {
		if (!data.req.headers.hasOwnProperty(&#039;x-two-factor-authentication&#039;)) {
			// No 2FA received
			return data.res.status(400).json(data.errorHandler.generate(
				400, &#039;2fa-enabled&#039;, &#039;Two Factor Authentication is enabled for this route, please send in the appropriate additional header for authorization&#039;, [&#039;x-two-factor-authentication&#039;]
			));
		}

		const skew = notp.totp.verify(data.req.headers[&#039;x-two-factor-authentication&#039;], await plugin.get(uid));
		if (!skew || Math.abs(skew.delta) &gt; 2) {
			return data.res.status(400).json(data.errorHandler.generate(
				401, &#039;2fa-failed&#039;, &#039;The Two-Factor Authentication code provided is not correct or has expired&#039;
			));
		}
	}
};

module.exports = plugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
