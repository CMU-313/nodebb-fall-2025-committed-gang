<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/meta.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/meta.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">77.08</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">582</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">39.84</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.49</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const async = require(&#039;async&#039;);

const nconf = require(&#039;nconf&#039;);

const db = require(&#039;./mocks/databasemock&#039;);
const meta = require(&#039;../src/meta&#039;);
const User = require(&#039;../src/user&#039;);
const Groups = require(&#039;../src/groups&#039;);
const request = require(&#039;../src/request&#039;);

describe(&#039;meta&#039;, () =&gt; {
	let fooUid;
	let bazUid;
	let herpUid;

	before((done) =&gt; {
		Groups.cache.reset();
		// Create 3 users: 1 admin, 2 regular
		async.series([
			async.apply(User.create, { username: &#039;foo&#039;, password: &#039;barbar&#039; }), // admin
			async.apply(User.create, { username: &#039;baz&#039;, password: &#039;quuxquux&#039; }), // restricted user
			async.apply(User.create, { username: &#039;herp&#039;, password: &#039;derpderp&#039; }), // regular user
		], (err, uids) =&gt; {
			if (err) {
				return done(err);
			}

			fooUid = uids[0];
			bazUid = uids[1];
			herpUid = uids[2];

			Groups.join(&#039;administrators&#039;, fooUid, done);
		});
	});

	describe(&#039;settings&#039;, () =&gt; {
		const socketAdmin = require(&#039;../src/socket.io/admin&#039;);
		it(&#039;it should set setting&#039;, (done) =&gt; {
			socketAdmin.settings.set({ uid: fooUid }, { hash: &#039;some:hash&#039;, values: { foo: &#039;1&#039;, derp: &#039;value&#039; } }, (err) =&gt; {
				assert.ifError(err);
				db.getObject(&#039;settings:some:hash&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					done();
				});
			});
		});

		it(&#039;it should get setting&#039;, (done) =&gt; {
			socketAdmin.settings.get({ uid: fooUid }, { hash: &#039;some:hash&#039; }, (err, data) =&gt; {
				assert.ifError(err);
				assert.equal(data.foo, &#039;1&#039;);
				assert.equal(data.derp, &#039;value&#039;);
				done();
			});
		});

		it(&#039;should not set setting if not empty&#039;, (done) =&gt; {
			meta.settings.setOnEmpty(&#039;some:hash&#039;, { foo: 2 }, (err) =&gt; {
				assert.ifError(err);
				db.getObject(&#039;settings:some:hash&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					done();
				});
			});
		});

		it(&#039;should set setting if empty&#039;, (done) =&gt; {
			meta.settings.setOnEmpty(&#039;some:hash&#039;, { empty: &#039;2&#039; }, (err) =&gt; {
				assert.ifError(err);
				db.getObject(&#039;settings:some:hash&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					assert.equal(data.empty, &#039;2&#039;);
					done();
				});
			});
		});

		it(&#039;should set one and get one&#039;, (done) =&gt; {
			meta.settings.setOne(&#039;some:hash&#039;, &#039;myField&#039;, &#039;myValue&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.settings.getOne(&#039;some:hash&#039;, &#039;myField&#039;, (err, myValue) =&gt; {
					assert.ifError(err);
					assert.equal(myValue, &#039;myValue&#039;);
					done();
				});
			});
		});

		it(&#039;should return null if setting field does not exist&#039;, async () =&gt; {
			const val = await meta.settings.getOne(&#039;some:hash&#039;, &#039;does not exist&#039;);
			assert.strictEqual(val, null);
		});

		const someList = [
			{ name: &#039;andrew&#039;, status: &#039;best&#039; },
			{ name: &#039;baris&#039;, status: &#039;wurst&#039; },
		];
		const anotherList = [];

		it(&#039;should set setting with sorted list&#039;, (done) =&gt; {
			socketAdmin.settings.set({ uid: fooUid }, { hash: &#039;another:hash&#039;, values: { foo: &#039;1&#039;, derp: &#039;value&#039;, someList: someList, anotherList: anotherList } }, (err) =&gt; {
				if (err) {
					return done(err);
				}

				db.getObject(&#039;settings:another:hash&#039;, (err, data) =&gt; {
					if (err) {
						return done(err);
					}

					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					assert.equal(data.someList, undefined);
					assert.equal(data.anotherList, undefined);
					done();
				});
			});
		});

		it(&#039;should get setting with sorted list&#039;, (done) =&gt; {
			socketAdmin.settings.get({ uid: fooUid }, { hash: &#039;another:hash&#039; }, (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(data.foo, &#039;1&#039;);
				assert.strictEqual(data.derp, &#039;value&#039;);
				assert.deepStrictEqual(data.someList, someList);
				assert.deepStrictEqual(data.anotherList, anotherList);
				done();
			});
		});

		it(&#039;should not set setting if not empty&#039;, (done) =&gt; {
			meta.settings.setOnEmpty(&#039;some:hash&#039;, { foo: 2 }, (err) =&gt; {
				assert.ifError(err);
				db.getObject(&#039;settings:some:hash&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					done();
				});
			});
		});

		it(&#039;should not set setting with sorted list if not empty&#039;, (done) =&gt; {
			meta.settings.setOnEmpty(&#039;another:hash&#039;, { foo: anotherList }, (err) =&gt; {
				assert.ifError(err);
				socketAdmin.settings.get({ uid: fooUid }, { hash: &#039;another:hash&#039; }, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					done();
				});
			});
		});

		it(&#039;should set setting with sorted list if empty&#039;, (done) =&gt; {
			meta.settings.setOnEmpty(&#039;another:hash&#039;, { empty: someList }, (err) =&gt; {
				assert.ifError(err);
				socketAdmin.settings.get({ uid: fooUid }, { hash: &#039;another:hash&#039; }, (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.foo, &#039;1&#039;);
					assert.equal(data.derp, &#039;value&#039;);
					assert.deepEqual(data.empty, someList);
					done();
				});
			});
		});

		it(&#039;should set one and get one sorted list&#039;, (done) =&gt; {
			meta.settings.setOne(&#039;another:hash&#039;, &#039;someList&#039;, someList, (err) =&gt; {
				assert.ifError(err);
				meta.settings.getOne(&#039;another:hash&#039;, &#039;someList&#039;, (err, _someList) =&gt; {
					assert.ifError(err);
					assert.deepEqual(_someList, someList);
					done();
				});
			});
		});
	});


	describe(&#039;config&#039;, () =&gt; {
		const socketAdmin = require(&#039;../src/socket.io/admin&#039;);
		before((done) =&gt; {
			db.setObject(&#039;config&#039;, { minimumTagLength: 3, maximumTagLength: 15 }, done);
		});

		it(&#039;should get config fields&#039;, (done) =&gt; {
			meta.configs.getFields([&#039;minimumTagLength&#039;, &#039;maximumTagLength&#039;], (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(data.minimumTagLength, 3);
				assert.strictEqual(data.maximumTagLength, 15);
				done();
			});
		});

		it(&#039;should get the correct type and default value&#039;, (done) =&gt; {
			meta.configs.set(&#039;loginAttempts&#039;, &#039;&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;loginAttempts&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.strictEqual(value, 5);
					done();
				});
			});
		});

		it(&#039;should get the correct type and correct value&#039;, (done) =&gt; {
			meta.configs.set(&#039;loginAttempts&#039;, &#039;0&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;loginAttempts&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.strictEqual(value, 0);
					done();
				});
			});
		});

		it(&#039;should get the correct value&#039;, (done) =&gt; {
			meta.configs.set(&#039;title&#039;, 123, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;title&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.strictEqual(value, &#039;123&#039;);
					done();
				});
			});
		});

		it(&#039;should get the correct value&#039;, (done) =&gt; {
			meta.configs.set(&#039;title&#039;, 0, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;title&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.strictEqual(value, &#039;0&#039;);
					done();
				});
			});
		});

		it(&#039;should get the correct value&#039;, (done) =&gt; {
			meta.configs.set(&#039;title&#039;, &#039;&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;title&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.strictEqual(value, &#039;&#039;);
					done();
				});
			});
		});

		it(&#039;should use default value if value is null&#039;, (done) =&gt; {
			meta.configs.set(&#039;teaserPost&#039;, null, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;teaserPost&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.strictEqual(value, &#039;last-reply&#039;);
					done();
				});
			});
		});

		it(&#039;should fail if field is invalid&#039;, (done) =&gt; {
			meta.configs.set(&#039;&#039;, &#039;someValue&#039;, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should fail if data is invalid&#039;, (done) =&gt; {
			socketAdmin.config.set({ uid: fooUid }, null, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should set multiple config values&#039;, (done) =&gt; {
			socketAdmin.config.set({ uid: fooUid }, { key: &#039;someKey&#039;, value: &#039;someValue&#039; }, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;someKey&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.someKey, &#039;someValue&#039;);
					done();
				});
			});
		});

		it(&#039;should set config value&#039;, (done) =&gt; {
			meta.configs.set(&#039;someField&#039;, &#039;someValue&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;someField&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.strictEqual(data.someField, &#039;someValue&#039;);
					done();
				});
			});
		});

		it(&#039;should get back string if field is not in defaults&#039;, (done) =&gt; {
			meta.configs.set(&#039;numericField&#039;, 123, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;numericField&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.strictEqual(data.numericField, 123);
					done();
				});
			});
		});

		it(&#039;should set boolean config value&#039;, (done) =&gt; {
			meta.configs.set(&#039;booleanField&#039;, true, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;booleanField&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.strictEqual(data.booleanField, true);
					done();
				});
			});
		});

		it(&#039;should set boolean config value&#039;, (done) =&gt; {
			meta.configs.set(&#039;booleanField&#039;, &#039;false&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;booleanField&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.strictEqual(data.booleanField, false);
					done();
				});
			});
		});

		it(&#039;should set string config value&#039;, (done) =&gt; {
			meta.configs.set(&#039;stringField&#039;, &#039;123&#039;, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;stringField&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.strictEqual(data.stringField, 123);
					done();
				});
			});
		});

		it(&#039;should fail if data is invalid&#039;, (done) =&gt; {
			socketAdmin.config.setMultiple({ uid: fooUid }, null, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should set multiple values&#039;, (done) =&gt; {
			socketAdmin.config.setMultiple({ uid: fooUid }, {
				someField1: &#039;someValue1&#039;,
				someField2: &#039;someValue2&#039;,
				customCSS: &#039;.derp{color:#00ff00;}&#039;,
			}, (err) =&gt; {
				assert.ifError(err);
				meta.configs.getFields([&#039;someField1&#039;, &#039;someField2&#039;], (err, data) =&gt; {
					assert.ifError(err);
					assert.equal(data.someField1, &#039;someValue1&#039;);
					assert.equal(data.someField2, &#039;someValue2&#039;);
					done();
				});
			});
		});

		it(&#039;should not set config if not empty&#039;, (done) =&gt; {
			meta.configs.setOnEmpty({ someField1: &#039;foo&#039; }, (err) =&gt; {
				assert.ifError(err);
				meta.configs.get(&#039;someField1&#039;, (err, value) =&gt; {
					assert.ifError(err);
					assert.equal(value, &#039;someValue1&#039;);
					done();
				});
			});
		});

		it(&#039;should remove config field&#039;, (done) =&gt; {
			socketAdmin.config.remove({ uid: fooUid }, &#039;someField1&#039;, (err) =&gt; {
				assert.ifError(err);
				db.isObjectField(&#039;config&#039;, &#039;someField1&#039;, (err, isObjectField) =&gt; {
					assert.ifError(err);
					assert(!isObjectField);
					done();
				});
			});
		});
	});


	describe(&#039;session TTL&#039;, () =&gt; {
		it(&#039;should return 14 days in seconds&#039;, (done) =&gt; {
			assert(meta.getSessionTTLSeconds(), 1209600);
			done();
		});

		it(&#039;should return 7 days in seconds&#039;, (done) =&gt; {
			meta.config.loginDays = 7;
			assert(meta.getSessionTTLSeconds(), 604800);
			done();
		});

		it(&#039;should return 2 days in seconds&#039;, (done) =&gt; {
			meta.config.loginSeconds = 172800;
			assert(meta.getSessionTTLSeconds(), 172800);
			done();
		});
	});

	describe(&#039;dependencies&#039;, () =&gt; {
		it(&#039;should return ENOENT if module is not found&#039;, (done) =&gt; {
			meta.dependencies.checkModule(&#039;some-module-that-does-not-exist&#039;, (err) =&gt; {
				assert.equal(err.code, &#039;ENOENT&#039;);
				done();
			});
		});

		it(&#039;should not error if module is a nodebb-plugin-*&#039;, (done) =&gt; {
			meta.dependencies.checkModule(&#039;nodebb-plugin-somePlugin&#039;, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should not error if module is nodebb-theme-*&#039;, (done) =&gt; {
			meta.dependencies.checkModule(&#039;nodebb-theme-someTheme&#039;, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should parse json package data&#039;, (done) =&gt; {
			const pkgData = meta.dependencies.parseModuleData(&#039;nodebb-plugin-test&#039;, &#039;{&quot;a&quot;: 1}&#039;);
			assert.equal(pkgData.a, 1);
			done();
		});

		it(&#039;should return null data with invalid json&#039;, (done) =&gt; {
			const pkgData = meta.dependencies.parseModuleData(&#039;nodebb-plugin-test&#039;, &#039;asdasd&#039;);
			assert.strictEqual(pkgData, null);
			done();
		});

		it(&#039;should return false if moduleData is falsy&#039;, (done) =&gt; {
			assert(!meta.dependencies.doesSatisfy(null, &#039;1.0.0&#039;));
			done();
		});

		it(&#039;should return false if moduleData doesnt not satisfy package.json&#039;, (done) =&gt; {
			assert(!meta.dependencies.doesSatisfy({ name: &#039;nodebb-plugin-test&#039;, version: &#039;0.9.0&#039; }, &#039;1.0.0&#039;));
			done();
		});

		it(&#039;should return true if _resolved is from github&#039;, (done) =&gt; {
			assert(meta.dependencies.doesSatisfy({ name: &#039;nodebb-plugin-test&#039;, _resolved: &#039;https://github.com/some/repo&#039;, version: &#039;0.9.0&#039; }, &#039;1.0.0&#039;));
			done();
		});
	});

	describe(&#039;debugFork&#039;, () =&gt; {
		let oldArgv;
		before(() =&gt; {
			oldArgv = process.execArgv;
			process.execArgv = [&#039;--debug=5858&#039;, &#039;--foo=1&#039;];
		});

		it(&#039;should detect debugging&#039;, (done) =&gt; {
			let debugFork = require(&#039;../src/meta/debugFork&#039;);
			assert(!debugFork.debugging);

			const debugForkPath = require.resolve(&#039;../src/meta/debugFork&#039;);
			delete require.cache[debugForkPath];

			debugFork = require(&#039;../src/meta/debugFork&#039;);
			assert(debugFork.debugging);

			done();
		});

		after(() =&gt; {
			process.execArgv = oldArgv;
		});
	});

	describe(&#039;Access-Control-Allow-Origin&#039;, () =&gt; {
		it(&#039;Access-Control-Allow-Origin header should be empty&#039;, async () =&gt; {
			const jar = request.jar();
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/search?term=bug`, {
				jar: jar,
			});

			assert.equal(response.headers[&#039;access-control-allow-origin&#039;], undefined);
		});

		it(&#039;should set proper Access-Control-Allow-Origin header&#039;, async () =&gt; {
			const jar = request.jar();
			const oldValue = meta.config[&#039;access-control-allow-origin&#039;];
			meta.config[&#039;access-control-allow-origin&#039;] = &#039;test.com, mydomain.com&#039;;
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/search?term=bug`, {
				jar: jar,
				headers: {
					origin: &#039;mydomain.com&#039;,
				},
			});

			assert.equal(response.headers[&#039;access-control-allow-origin&#039;], &#039;mydomain.com&#039;);
			meta.config[&#039;access-control-allow-origin&#039;] = oldValue;
		});

		it(&#039;Access-Control-Allow-Origin header should be empty if origin does not match&#039;, async () =&gt; {
			const jar = request.jar();
			const oldValue = meta.config[&#039;access-control-allow-origin&#039;];
			meta.config[&#039;access-control-allow-origin&#039;] = &#039;test.com, mydomain.com&#039;;
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/search?term=bug`, {
				data: {},
				jar: jar,
				headers: {
					origin: &#039;notallowed.com&#039;,
				},
			});
			assert.equal(response.headers[&#039;access-control-allow-origin&#039;], undefined);
			meta.config[&#039;access-control-allow-origin&#039;] = oldValue;
		});

		it(&#039;should set proper Access-Control-Allow-Origin header&#039;, async () =&gt; {
			const jar = request.jar();
			const oldValue = meta.config[&#039;access-control-allow-origin-regex&#039;];
			meta.config[&#039;access-control-allow-origin-regex&#039;] = &#039;match\\.this\\..+\\.domain.com, mydomain\\.com&#039;;
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/search?term=bug`, {
				jar: jar,
				headers: {
					origin: &#039;match.this.anything123.domain.com&#039;,
				},
			});

			assert.equal(response.headers[&#039;access-control-allow-origin&#039;], &#039;match.this.anything123.domain.com&#039;);
			meta.config[&#039;access-control-allow-origin-regex&#039;] = oldValue;
		});

		it(&#039;Access-Control-Allow-Origin header should be empty if origin does not match&#039;, async () =&gt; {
			const jar = request.jar();
			const oldValue = meta.config[&#039;access-control-allow-origin-regex&#039;];
			meta.config[&#039;access-control-allow-origin-regex&#039;] = &#039;match\\.this\\..+\\.domain.com, mydomain\\.com&#039;;
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/search?term=bug`, {
				jar: jar,
				headers: {
					origin: &#039;notallowed.com&#039;,
				},
			});
			assert.equal(response.headers[&#039;access-control-allow-origin&#039;], undefined);
			meta.config[&#039;access-control-allow-origin-regex&#039;] = oldValue;
		});

		it(&#039;should not error with invalid regexp&#039;, async () =&gt; {
			const jar = request.jar();
			const oldValue = meta.config[&#039;access-control-allow-origin-regex&#039;];
			meta.config[&#039;access-control-allow-origin-regex&#039;] = &#039;[match\\.this\\..+\\.domain.com, mydomain\\.com&#039;;
			const { response } = await request.get(`${nconf.get(&#039;url&#039;)}/api/search?term=bug`, {
				jar: jar,
				headers: {
					origin: &#039;mydomain.com&#039;,
				},
			});
			assert.equal(response.headers[&#039;access-control-allow-origin&#039;], &#039;mydomain.com&#039;);
			meta.config[&#039;access-control-allow-origin-regex&#039;] = oldValue;
		});
	});

	it(&#039;should log targets&#039;, (done) =&gt; {
		const aliases = require(&#039;../src/meta/aliases&#039;);
		aliases.buildTargets();
		done();
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
