<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/engine.io-client/build/cjs/socket.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/engine.io-client/build/cjs/socket.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">766</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">77.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.Socket = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = void 0;
const index_js_1 = require(&quot;./transports/index.js&quot;);
const util_js_1 = require(&quot;./util.js&quot;);
const parseqs_js_1 = require(&quot;./contrib/parseqs.js&quot;);
const parseuri_js_1 = require(&quot;./contrib/parseuri.js&quot;);
const component_emitter_1 = require(&quot;@socket.io/component-emitter&quot;);
const engine_io_parser_1 = require(&quot;engine.io-parser&quot;);
const globals_node_js_1 = require(&quot;./globals.node.js&quot;);
const debug_1 = __importDefault(require(&quot;debug&quot;)); // debug()
const debug = (0, debug_1.default)(&quot;engine.io-client:socket&quot;); // debug()
const withEventListeners = typeof addEventListener === &quot;function&quot; &amp;&amp;
    typeof removeEventListener === &quot;function&quot;;
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
    // within a ServiceWorker, any event handler for the &#039;offline&#039; event must be added on the initial evaluation of the
    // script, so we create one single event listener here which will forward the event to the socket instances
    addEventListener(&quot;offline&quot;, () =&gt; {
        debug(&quot;closing %d connection(s) because the network was lost&quot;, OFFLINE_EVENT_LISTENERS.length);
        OFFLINE_EVENT_LISTENERS.forEach((listener) =&gt; listener());
    }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that&#039;s why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from &quot;engine.io-client&quot;;
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on(&quot;open&quot;, () =&gt; {
 *   socket.send(&quot;hello&quot;);
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
class SocketWithoutUpgrade extends component_emitter_1.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts) {
        super();
        this.binaryType = globals_node_js_1.defaultBinaryType;
        this.writeBuffer = [];
        this._prevBufferLen = 0;
        this._pingInterval = -1;
        this._pingTimeout = -1;
        this._maxPayload = -1;
        /**
         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
         */
        this._pingTimeoutTime = Infinity;
        if (uri &amp;&amp; &quot;object&quot; === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            const parsedUri = (0, parseuri_js_1.parse)(uri);
            opts.hostname = parsedUri.host;
            opts.secure =
                parsedUri.protocol === &quot;https&quot; || parsedUri.protocol === &quot;wss&quot;;
            opts.port = parsedUri.port;
            if (parsedUri.query)
                opts.query = parsedUri.query;
        }
        else if (opts.host) {
            opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== &quot;undefined&quot; &amp;&amp; &quot;https:&quot; === location.protocol;
        if (opts.hostname &amp;&amp; !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? &quot;443&quot; : &quot;80&quot;;
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== &quot;undefined&quot; ? location.hostname : &quot;localhost&quot;);
        this.port =
            opts.port ||
                (typeof location !== &quot;undefined&quot; &amp;&amp; location.port
                    ? location.port
                    : this.secure
                        ? &quot;443&quot;
                        : &quot;80&quot;);
        this.transports = [];
        this._transportsByName = {};
        opts.transports.forEach((t) =&gt; {
            const transportName = t.prototype.name;
            this.transports.push(transportName);
            this._transportsByName[transportName] = t;
        });
        this.opts = Object.assign({
            path: &quot;/engine.io&quot;,
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: &quot;t&quot;,
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024,
            },
            transportOptions: {},
            closeOnBeforeunload: false,
        }, opts);
        this.opts.path =
            this.opts.path.replace(/\/$/, &quot;&quot;) +
                (this.opts.addTrailingSlash ? &quot;/&quot; : &quot;&quot;);
        if (typeof this.opts.query === &quot;string&quot;) {
            this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
        }
        if (withEventListeners) {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the &quot;beforeunload&quot; event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no &quot;disconnect&quot; event at the Socket.IO level when the page is
                // closed/reloaded)
                this._beforeunloadEventListener = () =&gt; {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener(&quot;beforeunload&quot;, this._beforeunloadEventListener, false);
            }
            if (this.hostname !== &quot;localhost&quot;) {
                debug(&quot;adding listener for the &#039;offline&#039; event&quot;);
                this._offlineEventListener = () =&gt; {
                    this._onClose(&quot;transport close&quot;, {
                        description: &quot;network connection lost&quot;,
                    });
                };
                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
            }
        }
        if (this.opts.withCredentials) {
            this._cookieJar = (0, globals_node_js_1.createCookieJar)();
        }
        this._open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
        debug(&#039;creating transport &quot;%s&quot;&#039;, name);
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser_1.protocol;
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port,
        }, this.opts.transportOptions[name]);
        debug(&quot;options: %j&quot;, opts);
        return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    _open() {
        if (this.transports.length === 0) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() =&gt; {
                this.emitReserved(&quot;error&quot;, &quot;No transports available&quot;);
            }, 0);
            return;
        }
        const transportName = this.opts.rememberUpgrade &amp;&amp;
            SocketWithoutUpgrade.priorWebsocketSuccess &amp;&amp;
            this.transports.indexOf(&quot;websocket&quot;) !== -1
            ? &quot;websocket&quot;
            : this.transports[0];
        this.readyState = &quot;opening&quot;;
        const transport = this.createTransport(transportName);
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
        debug(&quot;setting transport %s&quot;, transport.name);
        if (this.transport) {
            debug(&quot;clearing existing transport %s&quot;, this.transport.name);
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on(&quot;drain&quot;, this._onDrain.bind(this))
            .on(&quot;packet&quot;, this._onPacket.bind(this))
            .on(&quot;error&quot;, this._onError.bind(this))
            .on(&quot;close&quot;, (reason) =&gt; this._onClose(&quot;transport close&quot;, reason));
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
        debug(&quot;socket open&quot;);
        this.readyState = &quot;open&quot;;
        SocketWithoutUpgrade.priorWebsocketSuccess =
            &quot;websocket&quot; === this.transport.name;
        this.emitReserved(&quot;open&quot;);
        this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    _onPacket(packet) {
        if (&quot;opening&quot; === this.readyState ||
            &quot;open&quot; === this.readyState ||
            &quot;closing&quot; === this.readyState) {
            debug(&#039;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&#039;, packet.type, packet.data);
            this.emitReserved(&quot;packet&quot;, packet);
            // Socket is live - any packet counts
            this.emitReserved(&quot;heartbeat&quot;);
            switch (packet.type) {
                case &quot;open&quot;:
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case &quot;ping&quot;:
                    this._sendPacket(&quot;pong&quot;);
                    this.emitReserved(&quot;ping&quot;);
                    this.emitReserved(&quot;pong&quot;);
                    this._resetPingTimeout();
                    break;
                case &quot;error&quot;:
                    const err = new Error(&quot;server error&quot;);
                    // @ts-ignore
                    err.code = packet.data;
                    this._onError(err);
                    break;
                case &quot;message&quot;:
                    this.emitReserved(&quot;data&quot;, packet.data);
                    this.emitReserved(&quot;message&quot;, packet.data);
                    break;
            }
        }
        else {
            debug(&#039;packet received with socket readyState &quot;%s&quot;&#039;, this.readyState);
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
        this.emitReserved(&quot;handshake&quot;, data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this._pingInterval = data.pingInterval;
        this._pingTimeout = data.pingTimeout;
        this._maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if (&quot;closed&quot; === this.readyState)
            return;
        this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const delay = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + delay;
        this._pingTimeoutTimer = this.setTimeoutFn(() =&gt; {
            this._onClose(&quot;ping timeout&quot;);
        }, delay);
        if (this.opts.autoUnref) {
            this._pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this._prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved(&quot;drain&quot;);
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
        if (&quot;closed&quot; !== this.readyState &amp;&amp;
            this.transport.writable &amp;&amp;
            !this.upgrading &amp;&amp;
            this.writeBuffer.length) {
            const packets = this._getWritablePackets();
            debug(&quot;flushing %d packets in socket&quot;, packets.length);
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this._prevBufferLen = packets.length;
            this.emitReserved(&quot;flush&quot;);
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    _getWritablePackets() {
        const shouldCheckPayloadSize = this._maxPayload &amp;&amp;
            this.transport.name === &quot;polling&quot; &amp;&amp;
            this.writeBuffer.length &gt; 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for (let i = 0; i &lt; this.writeBuffer.length; i++) {
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += (0, util_js_1.byteLength)(data);
            }
            if (i &gt; 0 &amp;&amp; payloadSize &gt; this._maxPayload) {
                debug(&quot;only send %d out of %d packets&quot;, i, this.writeBuffer.length);
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        debug(&quot;payload size is %d (max: %d)&quot;, payloadSize, this._maxPayload);
        return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */ _hasPingExpired() {
        if (!this._pingTimeoutTime)
            return true;
        const hasExpired = Date.now() &gt; this._pingTimeoutTime;
        if (hasExpired) {
            debug(&quot;throttled timer detected, scheduling connection close&quot;);
            this._pingTimeoutTime = 0;
            (0, globals_node_js_1.nextTick)(() =&gt; {
                this._onClose(&quot;ping timeout&quot;);
            }, this.setTimeoutFn);
        }
        return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
        this._sendPacket(&quot;message&quot;, msg, options, fn);
        return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    send(msg, options, fn) {
        this._sendPacket(&quot;message&quot;, msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    _sendPacket(type, data, options, fn) {
        if (&quot;function&quot; === typeof data) {
            fn = data;
            data = undefined;
        }
        if (&quot;function&quot; === typeof options) {
            fn = options;
            options = null;
        }
        if (&quot;closing&quot; === this.readyState || &quot;closed&quot; === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options,
        };
        this.emitReserved(&quot;packetCreate&quot;, packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once(&quot;flush&quot;, fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
        const close = () =&gt; {
            this._onClose(&quot;forced close&quot;);
            debug(&quot;socket closing - telling transport to close&quot;);
            this.transport.close();
        };
        const cleanupAndClose = () =&gt; {
            this.off(&quot;upgrade&quot;, cleanupAndClose);
            this.off(&quot;upgradeError&quot;, cleanupAndClose);
            close();
        };
        const waitForUpgrade = () =&gt; {
            // wait for upgrade to finish since we can&#039;t send packets while pausing a transport
            this.once(&quot;upgrade&quot;, cleanupAndClose);
            this.once(&quot;upgradeError&quot;, cleanupAndClose);
        };
        if (&quot;opening&quot; === this.readyState || &quot;open&quot; === this.readyState) {
            this.readyState = &quot;closing&quot;;
            if (this.writeBuffer.length) {
                this.once(&quot;drain&quot;, () =&gt; {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    _onError(err) {
        debug(&quot;socket error %j&quot;, err);
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        if (this.opts.tryAllTransports &amp;&amp;
            this.transports.length &gt; 1 &amp;&amp;
            this.readyState === &quot;opening&quot;) {
            debug(&quot;trying next transport&quot;);
            this.transports.shift();
            return this._open();
        }
        this.emitReserved(&quot;error&quot;, err);
        this._onClose(&quot;transport error&quot;, err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    _onClose(reason, description) {
        if (&quot;opening&quot; === this.readyState ||
            &quot;open&quot; === this.readyState ||
            &quot;closing&quot; === this.readyState) {
            debug(&#039;socket close with reason: &quot;%s&quot;&#039;, reason);
            // clear timers
            this.clearTimeoutFn(this._pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners(&quot;close&quot;);
            // ensure transport won&#039;t stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (withEventListeners) {
                if (this._beforeunloadEventListener) {
                    removeEventListener(&quot;beforeunload&quot;, this._beforeunloadEventListener, false);
                }
                if (this._offlineEventListener) {
                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
                    if (i !== -1) {
                        debug(&quot;removing listener for the &#039;offline&#039; event&quot;);
                        OFFLINE_EVENT_LISTENERS.splice(i, 1);
                    }
                }
            }
            // set ready state
            this.readyState = &quot;closed&quot;;
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved(&quot;close&quot;, reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this._prevBufferLen = 0;
        }
    }
}
exports.SocketWithoutUpgrade = SocketWithoutUpgrade;
SocketWithoutUpgrade.protocol = engine_io_parser_1.protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that&#039;s why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from &quot;engine.io-client&quot;;
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on(&quot;open&quot;, () =&gt; {
 *   socket.send(&quot;hello&quot;);
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
class SocketWithUpgrade extends SocketWithoutUpgrade {
    constructor() {
        super(...arguments);
        this._upgrades = [];
    }
    onOpen() {
        super.onOpen();
        if (&quot;open&quot; === this.readyState &amp;&amp; this.opts.upgrade) {
            debug(&quot;starting upgrade probes&quot;);
            for (let i = 0; i &lt; this._upgrades.length; i++) {
                this._probe(this._upgrades[i]);
            }
        }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    _probe(name) {
        debug(&#039;probing transport &quot;%s&quot;&#039;, name);
        let transport = this.createTransport(name);
        let failed = false;
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        const onTransportOpen = () =&gt; {
            if (failed)
                return;
            debug(&#039;probe transport &quot;%s&quot; opened&#039;, name);
            transport.send([{ type: &quot;ping&quot;, data: &quot;probe&quot; }]);
            transport.once(&quot;packet&quot;, (msg) =&gt; {
                if (failed)
                    return;
                if (&quot;pong&quot; === msg.type &amp;&amp; &quot;probe&quot; === msg.data) {
                    debug(&#039;probe transport &quot;%s&quot; pong&#039;, name);
                    this.upgrading = true;
                    this.emitReserved(&quot;upgrading&quot;, transport);
                    if (!transport)
                        return;
                    SocketWithoutUpgrade.priorWebsocketSuccess =
                        &quot;websocket&quot; === transport.name;
                    debug(&#039;pausing current transport &quot;%s&quot;&#039;, this.transport.name);
                    this.transport.pause(() =&gt; {
                        if (failed)
                            return;
                        if (&quot;closed&quot; === this.readyState)
                            return;
                        debug(&quot;changing transport and sending upgrade packet&quot;);
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: &quot;upgrade&quot; }]);
                        this.emitReserved(&quot;upgrade&quot;, transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    debug(&#039;probe transport &quot;%s&quot; failed&#039;, name);
                    const err = new Error(&quot;probe error&quot;);
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved(&quot;upgradeError&quot;, err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err) =&gt; {
            const error = new Error(&quot;probe error: &quot; + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            debug(&#039;probe transport &quot;%s&quot; failed because of error: %s&#039;, name, err);
            this.emitReserved(&quot;upgradeError&quot;, error);
        };
        function onTransportClose() {
            onerror(&quot;transport closed&quot;);
        }
        // When the socket is closed while we&#039;re probing
        function onclose() {
            onerror(&quot;socket closed&quot;);
        }
        // When the socket is upgraded while we&#039;re probing
        function onupgrade(to) {
            if (transport &amp;&amp; to.name !== transport.name) {
                debug(&#039;&quot;%s&quot; works - aborting &quot;%s&quot;&#039;, to.name, transport.name);
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () =&gt; {
            transport.removeListener(&quot;open&quot;, onTransportOpen);
            transport.removeListener(&quot;error&quot;, onerror);
            transport.removeListener(&quot;close&quot;, onTransportClose);
            this.off(&quot;close&quot;, onclose);
            this.off(&quot;upgrading&quot;, onupgrade);
        };
        transport.once(&quot;open&quot;, onTransportOpen);
        transport.once(&quot;error&quot;, onerror);
        transport.once(&quot;close&quot;, onTransportClose);
        this.once(&quot;close&quot;, onclose);
        this.once(&quot;upgrading&quot;, onupgrade);
        if (this._upgrades.indexOf(&quot;webtransport&quot;) !== -1 &amp;&amp;
            name !== &quot;webtransport&quot;) {
            // favor WebTransport
            this.setTimeoutFn(() =&gt; {
                if (!failed) {
                    transport.open();
                }
            }, 200);
        }
        else {
            transport.open();
        }
    }
    onHandshake(data) {
        this._upgrades = this._filterUpgrades(data.upgrades);
        super.onHandshake(data);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    _filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        for (let i = 0; i &lt; upgrades.length; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
exports.SocketWithUpgrade = SocketWithUpgrade;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from &quot;engine.io-client&quot;;
 *
 * const socket = new Socket();
 *
 * socket.on(&quot;open&quot;, () =&gt; {
 *   socket.send(&quot;hello&quot;);
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
class Socket extends SocketWithUpgrade {
    constructor(uri, opts = {}) {
        const o = typeof uri === &quot;object&quot; ? uri : opts;
        if (!o.transports ||
            (o.transports &amp;&amp; typeof o.transports[0] === &quot;string&quot;)) {
            o.transports = (o.transports || [&quot;polling&quot;, &quot;websocket&quot;, &quot;webtransport&quot;])
                .map((transportName) =&gt; index_js_1.transports[transportName])
                .filter((t) =&gt; !!t);
        }
        super(uri, o);
    }
}
exports.Socket = Socket;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
