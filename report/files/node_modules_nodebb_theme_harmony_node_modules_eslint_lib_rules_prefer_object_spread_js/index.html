<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/prefer-object-spread.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/prefer-object-spread.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">320</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">47.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.85</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead
 * @author Sharmila Jesupaul
 */

&quot;use strict&quot;;

const { CALL, ReferenceTracker } = require(&quot;@eslint-community/eslint-utils&quot;);
const {
	isCommaToken,
	isOpeningParenToken,
	isClosingParenToken,
	isParenthesised,
} = require(&quot;./utils/ast-utils&quot;);

const ANY_SPACE = /\s/u;

/**
 * Helper that checks if the Object.assign call has array spread
 * @param {ASTNode} node The node that the rule warns on
 * @returns {boolean} - Returns true if the Object.assign call has array spread
 */
function hasArraySpread(node) {
	return node.arguments.some(arg =&gt; arg.type === &quot;SpreadElement&quot;);
}

/**
 * Determines whether the given node is an accessor property (getter/setter).
 * @param {ASTNode} node Node to check.
 * @returns {boolean} `true` if the node is a getter or a setter.
 */
function isAccessorProperty(node) {
	return (
		node.type === &quot;Property&quot; &amp;&amp; (node.kind === &quot;get&quot; || node.kind === &quot;set&quot;)
	);
}

/**
 * Determines whether the given object expression node has accessor properties (getters/setters).
 * @param {ASTNode} node `ObjectExpression` node to check.
 * @returns {boolean} `true` if the node has at least one getter/setter.
 */
function hasAccessors(node) {
	return node.properties.some(isAccessorProperty);
}

/**
 * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).
 * @param {ASTNode} node `CallExpression` node to check.
 * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.
 */
function hasArgumentsWithAccessors(node) {
	return node.arguments
		.filter(arg =&gt; arg.type === &quot;ObjectExpression&quot;)
		.some(hasAccessors);
}

/**
 * Helper that checks if the node needs parentheses to be valid JS.
 * The default is to wrap the node in parentheses to avoid parsing errors.
 * @param {ASTNode} node The node that the rule warns on
 * @param {Object} sourceCode in context sourcecode object
 * @returns {boolean} - Returns true if the node needs parentheses
 */
function needsParens(node, sourceCode) {
	const parent = node.parent;

	switch (parent.type) {
		case &quot;VariableDeclarator&quot;:
		case &quot;ArrayExpression&quot;:
		case &quot;ReturnStatement&quot;:
		case &quot;CallExpression&quot;:
		case &quot;Property&quot;:
			return false;
		case &quot;AssignmentExpression&quot;:
			return parent.left === node &amp;&amp; !isParenthesised(sourceCode, node);
		default:
			return !isParenthesised(sourceCode, node);
	}
}

/**
 * Determines if an argument needs parentheses. The default is to not add parens.
 * @param {ASTNode} node The node to be checked.
 * @param {Object} sourceCode in context sourcecode object
 * @returns {boolean} True if the node needs parentheses
 */
function argNeedsParens(node, sourceCode) {
	switch (node.type) {
		case &quot;AssignmentExpression&quot;:
		case &quot;ArrowFunctionExpression&quot;:
		case &quot;ConditionalExpression&quot;:
			return !isParenthesised(sourceCode, node);
		default:
			return false;
	}
}

/**
 * Get the parenthesis tokens of a given ObjectExpression node.
 * This includes the braces of the object literal and enclosing parentheses.
 * @param {ASTNode} node The node to get.
 * @param {Token} leftArgumentListParen The opening paren token of the argument list.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.
 */
function getParenTokens(node, leftArgumentListParen, sourceCode) {
	const parens = [
		sourceCode.getFirstToken(node),
		sourceCode.getLastToken(node),
	];
	let leftNext = sourceCode.getTokenBefore(node);
	let rightNext = sourceCode.getTokenAfter(node);

	// Note: don&#039;t include the parens of the argument list.
	while (
		leftNext &amp;&amp;
		rightNext &amp;&amp;
		leftNext.range[0] &gt; leftArgumentListParen.range[0] &amp;&amp;
		isOpeningParenToken(leftNext) &amp;&amp;
		isClosingParenToken(rightNext)
	) {
		parens.push(leftNext, rightNext);
		leftNext = sourceCode.getTokenBefore(leftNext);
		rightNext = sourceCode.getTokenAfter(rightNext);
	}

	return parens.sort((a, b) =&gt; a.range[0] - b.range[0]);
}

/**
 * Get the range of a given token and around whitespaces.
 * @param {Token} token The token to get range.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {number} The end of the range of the token and around whitespaces.
 */
function getStartWithSpaces(token, sourceCode) {
	const text = sourceCode.text;
	let start = token.range[0];

	// If the previous token is a line comment then skip this step to avoid commenting this token out.
	{
		const prevToken = sourceCode.getTokenBefore(token, {
			includeComments: true,
		});

		if (prevToken &amp;&amp; prevToken.type === &quot;Line&quot;) {
			return start;
		}
	}

	// Detect spaces before the token.
	while (ANY_SPACE.test(text[start - 1] || &quot;&quot;)) {
		start -= 1;
	}

	return start;
}

/**
 * Get the range of a given token and around whitespaces.
 * @param {Token} token The token to get range.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {number} The start of the range of the token and around whitespaces.
 */
function getEndWithSpaces(token, sourceCode) {
	const text = sourceCode.text;
	let end = token.range[1];

	// Detect spaces after the token.
	while (ANY_SPACE.test(text[end] || &quot;&quot;)) {
		end += 1;
	}

	return end;
}

/**
 * Autofixes the Object.assign call to use an object spread instead.
 * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call
 * @param {string} sourceCode sourceCode of the Object.assign call
 * @returns {Function} autofixer - replaces the Object.assign with a spread object.
 */
function defineFixer(node, sourceCode) {
	return function* (fixer) {
		const leftParen = sourceCode.getTokenAfter(
			node.callee,
			isOpeningParenToken,
		);
		const rightParen = sourceCode.getLastToken(node);

		// Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.
		yield fixer.removeRange([node.range[0], leftParen.range[0]]);

		// Replace the parens of argument list to braces.
		if (needsParens(node, sourceCode)) {
			yield fixer.replaceText(leftParen, &quot;({&quot;);
			yield fixer.replaceText(rightParen, &quot;})&quot;);
		} else {
			yield fixer.replaceText(leftParen, &quot;{&quot;);
			yield fixer.replaceText(rightParen, &quot;}&quot;);
		}

		// Process arguments.
		for (const argNode of node.arguments) {
			const innerParens = getParenTokens(argNode, leftParen, sourceCode);
			const left = innerParens.shift();
			const right = innerParens.pop();

			if (argNode.type === &quot;ObjectExpression&quot;) {
				const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
				const maybeArgumentComma = sourceCode.getTokenAfter(right);

				/*
				 * Make bare this object literal.
				 * And remove spaces inside of the braces for better formatting.
				 */
				for (const innerParen of innerParens) {
					yield fixer.remove(innerParen);
				}
				const leftRange = [
					left.range[0],
					getEndWithSpaces(left, sourceCode),
				];
				const rightRange = [
					Math.max(
						getStartWithSpaces(right, sourceCode),
						leftRange[1],
					), // Ensure ranges don&#039;t overlap
					right.range[1],
				];

				yield fixer.removeRange(leftRange);
				yield fixer.removeRange(rightRange);

				// Remove the comma of this argument if it&#039;s duplication.
				if (
					(argNode.properties.length === 0 ||
						isCommaToken(maybeTrailingComma)) &amp;&amp;
					isCommaToken(maybeArgumentComma)
				) {
					yield fixer.remove(maybeArgumentComma);
				}
			} else {
				// Make spread.
				if (argNeedsParens(argNode, sourceCode)) {
					yield fixer.insertTextBefore(left, &quot;...(&quot;);
					yield fixer.insertTextAfter(right, &quot;)&quot;);
				} else {
					yield fixer.insertTextBefore(left, &quot;...&quot;);
				}
			}
		}
	};
}

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		docs: {
			description:
				&quot;Disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/prefer-object-spread&quot;,
		},

		schema: [],
		fixable: &quot;code&quot;,

		messages: {
			useSpreadMessage:
				&quot;Use an object spread instead of `Object.assign` eg: `{ ...foo }`.&quot;,
			useLiteralMessage:
				&quot;Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		return {
			Program(node) {
				const scope = sourceCode.getScope(node);
				const tracker = new ReferenceTracker(scope);
				const trackMap = {
					Object: {
						assign: { [CALL]: true },
					},
				};

				// Iterate all calls of `Object.assign` (only of the global variable `Object`).
				for (const { node: refNode } of tracker.iterateGlobalReferences(
					trackMap,
				)) {
					if (
						refNode.arguments.length &gt;= 1 &amp;&amp;
						refNode.arguments[0].type === &quot;ObjectExpression&quot; &amp;&amp;
						!hasArraySpread(refNode) &amp;&amp;
						!(
							refNode.arguments.length &gt; 1 &amp;&amp;
							hasArgumentsWithAccessors(refNode)
						)
					) {
						const messageId =
							refNode.arguments.length === 1
								? &quot;useLiteralMessage&quot;
								: &quot;useSpreadMessage&quot;;
						const fix = defineFixer(refNode, sourceCode);

						context.report({ node: refNode, messageId, fix });
					}
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
