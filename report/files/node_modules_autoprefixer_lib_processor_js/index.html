<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/autoprefixer/lib/processor.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/autoprefixer/lib/processor.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">710</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">let parser = require(&#039;postcss-value-parser&#039;)

let Value = require(&#039;./value&#039;)
let insertAreas = require(&#039;./hacks/grid-utils&#039;).insertAreas

const OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i
const OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i
const IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i
const GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i

const SIZES = [
  &#039;width&#039;,
  &#039;height&#039;,
  &#039;min-width&#039;,
  &#039;max-width&#039;,
  &#039;min-height&#039;,
  &#039;max-height&#039;,
  &#039;inline-size&#039;,
  &#039;min-inline-size&#039;,
  &#039;max-inline-size&#039;,
  &#039;block-size&#039;,
  &#039;min-block-size&#039;,
  &#039;max-block-size&#039;
]

function hasGridTemplate(decl) {
  return decl.parent.some(
    i =&gt; i.prop === &#039;grid-template&#039; || i.prop === &#039;grid-template-areas&#039;
  )
}

function hasRowsAndColumns(decl) {
  let hasRows = decl.parent.some(i =&gt; i.prop === &#039;grid-template-rows&#039;)
  let hasColumns = decl.parent.some(i =&gt; i.prop === &#039;grid-template-columns&#039;)
  return hasRows &amp;&amp; hasColumns
}

class Processor {
  constructor(prefixes) {
    this.prefixes = prefixes
  }

  /**
   * Add necessary prefixes
   */
  add(css, result) {
    // At-rules
    let resolution = this.prefixes.add[&#039;@resolution&#039;]
    let keyframes = this.prefixes.add[&#039;@keyframes&#039;]
    let viewport = this.prefixes.add[&#039;@viewport&#039;]
    let supports = this.prefixes.add[&#039;@supports&#039;]

    css.walkAtRules(rule =&gt; {
      if (rule.name === &#039;keyframes&#039;) {
        if (!this.disabled(rule, result)) {
          return keyframes &amp;&amp; keyframes.process(rule)
        }
      } else if (rule.name === &#039;viewport&#039;) {
        if (!this.disabled(rule, result)) {
          return viewport &amp;&amp; viewport.process(rule)
        }
      } else if (rule.name === &#039;supports&#039;) {
        if (
          this.prefixes.options.supports !== false &amp;&amp;
          !this.disabled(rule, result)
        ) {
          return supports.process(rule)
        }
      } else if (rule.name === &#039;media&#039; &amp;&amp; rule.params.includes(&#039;-resolution&#039;)) {
        if (!this.disabled(rule, result)) {
          return resolution &amp;&amp; resolution.process(rule)
        }
      }

      return undefined
    })

    // Selectors
    css.walkRules(rule =&gt; {
      if (this.disabled(rule, result)) return undefined

      return this.prefixes.add.selectors.map(selector =&gt; {
        return selector.process(rule, result)
      })
    })

    function insideGrid(decl) {
      return decl.parent.nodes.some(node =&gt; {
        if (node.type !== &#039;decl&#039;) return false
        let displayGrid =
          node.prop === &#039;display&#039; &amp;&amp; /(inline-)?grid/.test(node.value)
        let gridTemplate = node.prop.startsWith(&#039;grid-template&#039;)
        let gridGap = /^grid-([A-z]+-)?gap/.test(node.prop)
        return displayGrid || gridTemplate || gridGap
      })
    }

    let gridPrefixes =
      this.gridStatus(css, result) &amp;&amp;
      this.prefixes.add[&#039;grid-area&#039;] &amp;&amp;
      this.prefixes.add[&#039;grid-area&#039;].prefixes

    css.walkDecls(decl =&gt; {
      if (this.disabledDecl(decl, result)) return undefined

      let parent = decl.parent
      let prop = decl.prop
      let value = decl.value

      if (prop === &#039;color-adjust&#039;) {
        if (parent.every(i =&gt; i.prop !== &#039;print-color-adjust&#039;)) {
          result.warn(
            &#039;Replace color-adjust to print-color-adjust. &#039; +
              &#039;The color-adjust shorthand is currently deprecated.&#039;,
            { node: decl }
          )
        }
      } else if (prop === &#039;grid-row-span&#039;) {
        result.warn(
          &#039;grid-row-span is not part of final Grid Layout. Use grid-row.&#039;,
          { node: decl }
        )
        return undefined
      } else if (prop === &#039;grid-column-span&#039;) {
        result.warn(
          &#039;grid-column-span is not part of final Grid Layout. Use grid-column.&#039;,
          { node: decl }
        )
        return undefined
      } else if (prop === &#039;display&#039; &amp;&amp; value === &#039;box&#039;) {
        result.warn(
          &#039;You should write display: flex by final spec &#039; +
            &#039;instead of display: box&#039;,
          { node: decl }
        )
        return undefined
      } else if (prop === &#039;text-emphasis-position&#039;) {
        if (value === &#039;under&#039; || value === &#039;over&#039;) {
          result.warn(
            &#039;You should use 2 values for text-emphasis-position &#039; +
              &#039;For example, `under left` instead of just `under`.&#039;,
            { node: decl }
          )
        }
      } else if (prop === &#039;text-decoration-skip&#039; &amp;&amp; value === &#039;ink&#039;) {
        result.warn(
          &#039;Replace text-decoration-skip: ink to &#039; +
            &#039;text-decoration-skip-ink: auto, because spec had been changed&#039;,
          { node: decl }
        )
      } else {
        if (gridPrefixes &amp;&amp; this.gridStatus(decl, result)) {
          if (decl.value === &#039;subgrid&#039;) {
            result.warn(&#039;IE does not support subgrid&#039;, { node: decl })
          }
          if (/^(align|justify|place)-items$/.test(prop) &amp;&amp; insideGrid(decl)) {
            let fixed = prop.replace(&#039;-items&#039;, &#039;-self&#039;)
            result.warn(
              `IE does not support ${prop} on grid containers. ` +
                `Try using ${fixed} on child elements instead: ` +
                `${decl.parent.selector} &gt; * { ${fixed}: ${decl.value} }`,
              { node: decl }
            )
          } else if (
            /^(align|justify|place)-content$/.test(prop) &amp;&amp;
            insideGrid(decl)
          ) {
            result.warn(`IE does not support ${decl.prop} on grid containers`, {
              node: decl
            })
          } else if (prop === &#039;display&#039; &amp;&amp; decl.value === &#039;contents&#039;) {
            result.warn(
              &#039;Please do not use display: contents; &#039; +
                &#039;if you have grid setting enabled&#039;,
              { node: decl }
            )
            return undefined
          } else if (decl.prop === &#039;grid-gap&#039;) {
            let status = this.gridStatus(decl, result)
            if (
              status === &#039;autoplace&#039; &amp;&amp;
              !hasRowsAndColumns(decl) &amp;&amp;
              !hasGridTemplate(decl)
            ) {
              result.warn(
                &#039;grid-gap only works if grid-template(-areas) is being &#039; +
                  &#039;used or both rows and columns have been declared &#039; +
                  &#039;and cells have not been manually &#039; +
                  &#039;placed inside the explicit grid&#039;,
                { node: decl }
              )
            } else if (
              (status === true || status === &#039;no-autoplace&#039;) &amp;&amp;
              !hasGridTemplate(decl)
            ) {
              result.warn(
                &#039;grid-gap only works if grid-template(-areas) is being used&#039;,
                { node: decl }
              )
            }
          } else if (prop === &#039;grid-auto-columns&#039;) {
            result.warn(&#039;grid-auto-columns is not supported by IE&#039;, {
              node: decl
            })
            return undefined
          } else if (prop === &#039;grid-auto-rows&#039;) {
            result.warn(&#039;grid-auto-rows is not supported by IE&#039;, { node: decl })
            return undefined
          } else if (prop === &#039;grid-auto-flow&#039;) {
            let hasRows = parent.some(i =&gt; i.prop === &#039;grid-template-rows&#039;)
            let hasCols = parent.some(i =&gt; i.prop === &#039;grid-template-columns&#039;)

            if (hasGridTemplate(decl)) {
              result.warn(&#039;grid-auto-flow is not supported by IE&#039;, {
                node: decl
              })
            } else if (value.includes(&#039;dense&#039;)) {
              result.warn(&#039;grid-auto-flow: dense is not supported by IE&#039;, {
                node: decl
              })
            } else if (!hasRows &amp;&amp; !hasCols) {
              result.warn(
                &#039;grid-auto-flow works only if grid-template-rows and &#039; +
                  &#039;grid-template-columns are present in the same rule&#039;,
                { node: decl }
              )
            }
            return undefined
          } else if (value.includes(&#039;auto-fit&#039;)) {
            result.warn(&#039;auto-fit value is not supported by IE&#039;, {
              node: decl,
              word: &#039;auto-fit&#039;
            })
            return undefined
          } else if (value.includes(&#039;auto-fill&#039;)) {
            result.warn(&#039;auto-fill value is not supported by IE&#039;, {
              node: decl,
              word: &#039;auto-fill&#039;
            })
            return undefined
          } else if (prop.startsWith(&#039;grid-template&#039;) &amp;&amp; value.includes(&#039;[&#039;)) {
            result.warn(
              &#039;Autoprefixer currently does not support line names. &#039; +
                &#039;Try using grid-template-areas instead.&#039;,
              { node: decl, word: &#039;[&#039; }
            )
          }
        }
        if (value.includes(&#039;radial-gradient&#039;)) {
          if (OLD_RADIAL.test(decl.value)) {
            result.warn(
              &#039;Gradient has outdated direction syntax. &#039; +
                &#039;New syntax is like `closest-side at 0 0` &#039; +
                &#039;instead of `0 0, closest-side`.&#039;,
              { node: decl }
            )
          } else {
            let ast = parser(value)

            for (let i of ast.nodes) {
              if (i.type === &#039;function&#039; &amp;&amp; i.value === &#039;radial-gradient&#039;) {
                for (let word of i.nodes) {
                  if (word.type === &#039;word&#039;) {
                    if (word.value === &#039;cover&#039;) {
                      result.warn(
                        &#039;Gradient has outdated direction syntax. &#039; +
                          &#039;Replace `cover` to `farthest-corner`.&#039;,
                        { node: decl }
                      )
                    } else if (word.value === &#039;contain&#039;) {
                      result.warn(
                        &#039;Gradient has outdated direction syntax. &#039; +
                          &#039;Replace `contain` to `closest-side`.&#039;,
                        { node: decl }
                      )
                    }
                  }
                }
              }
            }
          }
        }
        if (value.includes(&#039;linear-gradient&#039;)) {
          if (OLD_LINEAR.test(value)) {
            result.warn(
              &#039;Gradient has outdated direction syntax. &#039; +
                &#039;New syntax is like `to left` instead of `right`.&#039;,
              { node: decl }
            )
          }
        }
      }

      if (SIZES.includes(decl.prop)) {
        if (!decl.value.includes(&#039;-fill-available&#039;)) {
          if (decl.value.includes(&#039;fill-available&#039;)) {
            result.warn(
              &#039;Replace fill-available to stretch, &#039; +
                &#039;because spec had been changed&#039;,
              { node: decl }
            )
          } else if (decl.value.includes(&#039;fill&#039;)) {
            let ast = parser(value)
            if (ast.nodes.some(i =&gt; i.type === &#039;word&#039; &amp;&amp; i.value === &#039;fill&#039;)) {
              result.warn(
                &#039;Replace fill to stretch, because spec had been changed&#039;,
                { node: decl }
              )
            }
          }
        }
      }

      let prefixer

      if (decl.prop === &#039;transition&#039; || decl.prop === &#039;transition-property&#039;) {
        // Transition
        return this.prefixes.transition.add(decl, result)
      } else if (decl.prop === &#039;align-self&#039;) {
        // align-self flexbox or grid
        let display = this.displayType(decl)
        if (display !== &#039;grid&#039; &amp;&amp; this.prefixes.options.flexbox !== false) {
          prefixer = this.prefixes.add[&#039;align-self&#039;]
          if (prefixer &amp;&amp; prefixer.prefixes) {
            prefixer.process(decl)
          }
        }
        if (this.gridStatus(decl, result) !== false) {
          prefixer = this.prefixes.add[&#039;grid-row-align&#039;]
          if (prefixer &amp;&amp; prefixer.prefixes) {
            return prefixer.process(decl, result)
          }
        }
      } else if (decl.prop === &#039;justify-self&#039;) {
        // justify-self flexbox or grid
        if (this.gridStatus(decl, result) !== false) {
          prefixer = this.prefixes.add[&#039;grid-column-align&#039;]
          if (prefixer &amp;&amp; prefixer.prefixes) {
            return prefixer.process(decl, result)
          }
        }
      } else if (decl.prop === &#039;place-self&#039;) {
        prefixer = this.prefixes.add[&#039;place-self&#039;]
        if (
          prefixer &amp;&amp;
          prefixer.prefixes &amp;&amp;
          this.gridStatus(decl, result) !== false
        ) {
          return prefixer.process(decl, result)
        }
      } else {
        // Properties
        prefixer = this.prefixes.add[decl.prop]
        if (prefixer &amp;&amp; prefixer.prefixes) {
          return prefixer.process(decl, result)
        }
      }

      return undefined
    })

    // Insert grid-area prefixes. We need to be able to store the different
    // rules as a data and hack API is not enough for this
    if (this.gridStatus(css, result)) {
      insertAreas(css, this.disabled)
    }

    // Values
    return css.walkDecls(decl =&gt; {
      if (this.disabledValue(decl, result)) return

      let unprefixed = this.prefixes.unprefixed(decl.prop)
      let list = this.prefixes.values(&#039;add&#039;, unprefixed)
      if (Array.isArray(list)) {
        for (let value of list) {
          if (value.process) value.process(decl, result)
        }
      }
      Value.save(this.prefixes, decl)
    })
  }

  /**
   * Check for control comment and global options
   */
  disabled(node, result) {
    if (!node) return false

    if (node._autoprefixerDisabled !== undefined) {
      return node._autoprefixerDisabled
    }

    if (node.parent) {
      let p = node.prev()
      if (p &amp;&amp; p.type === &#039;comment&#039; &amp;&amp; IGNORE_NEXT.test(p.text)) {
        node._autoprefixerDisabled = true
        node._autoprefixerSelfDisabled = true
        return true
      }
    }

    let value = null
    if (node.nodes) {
      let status
      node.each(i =&gt; {
        if (i.type !== &#039;comment&#039;) return
        if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i.text)) {
          if (typeof status !== &#039;undefined&#039;) {
            result.warn(
              &#039;Second Autoprefixer control comment &#039; +
                &#039;was ignored. Autoprefixer applies control &#039; +
                &#039;comment to whole block, not to next rules.&#039;,
              { node: i }
            )
          } else {
            status = /on/i.test(i.text)
          }
        }
      })

      if (status !== undefined) {
        value = !status
      }
    }
    if (!node.nodes || value === null) {
      if (node.parent) {
        let isParentDisabled = this.disabled(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) {
          value = false
        } else {
          value = isParentDisabled
        }
      } else {
        value = false
      }
    }
    node._autoprefixerDisabled = value
    return value
  }

  /**
   * Check for grid/flexbox options.
   */
  disabledDecl(node, result) {
    if (node.type === &#039;decl&#039; &amp;&amp; this.gridStatus(node, result) === false) {
      if (node.prop.includes(&#039;grid&#039;) || node.prop === &#039;justify-items&#039;) {
        return true
      }
    }
    if (node.type === &#039;decl&#039; &amp;&amp; this.prefixes.options.flexbox === false) {
      let other = [&#039;order&#039;, &#039;justify-content&#039;, &#039;align-items&#039;, &#039;align-content&#039;]
      if (node.prop.includes(&#039;flex&#039;) || other.includes(node.prop)) {
        return true
      }
    }

    return this.disabled(node, result)
  }

  /**
   * Check for grid/flexbox options.
   */
  disabledValue(node, result) {
    if (this.gridStatus(node, result) === false &amp;&amp; node.type === &#039;decl&#039;) {
      if (node.prop === &#039;display&#039; &amp;&amp; node.value.includes(&#039;grid&#039;)) {
        return true
      }
    }
    if (this.prefixes.options.flexbox === false &amp;&amp; node.type === &#039;decl&#039;) {
      if (node.prop === &#039;display&#039; &amp;&amp; node.value.includes(&#039;flex&#039;)) {
        return true
      }
    }
    if (node.type === &#039;decl&#039; &amp;&amp; node.prop === &#039;content&#039;) {
      return true
    }

    return this.disabled(node, result)
  }

  /**
   * Is it flebox or grid rule
   */
  displayType(decl) {
    for (let i of decl.parent.nodes) {
      if (i.prop !== &#039;display&#039;) {
        continue
      }

      if (i.value.includes(&#039;flex&#039;)) {
        return &#039;flex&#039;
      }

      if (i.value.includes(&#039;grid&#039;)) {
        return &#039;grid&#039;
      }
    }

    return false
  }

  /**
   * Set grid option via control comment
   */
  gridStatus(node, result) {
    if (!node) return false

    if (node._autoprefixerGridStatus !== undefined) {
      return node._autoprefixerGridStatus
    }

    let value = null
    if (node.nodes) {
      let status
      node.each(i =&gt; {
        if (i.type !== &#039;comment&#039;) return
        if (GRID_REGEX.test(i.text)) {
          let hasAutoplace = /:\s*autoplace/i.test(i.text)
          let noAutoplace = /no-autoplace/i.test(i.text)
          if (typeof status !== &#039;undefined&#039;) {
            result.warn(
              &#039;Second Autoprefixer grid control comment was &#039; +
                &#039;ignored. Autoprefixer applies control comments to the whole &#039; +
                &#039;block, not to the next rules.&#039;,
              { node: i }
            )
          } else if (hasAutoplace) {
            status = &#039;autoplace&#039;
          } else if (noAutoplace) {
            status = true
          } else {
            status = /on/i.test(i.text)
          }
        }
      })

      if (status !== undefined) {
        value = status
      }
    }

    if (node.type === &#039;atrule&#039; &amp;&amp; node.name === &#039;supports&#039;) {
      let params = node.params
      if (params.includes(&#039;grid&#039;) &amp;&amp; params.includes(&#039;auto&#039;)) {
        value = false
      }
    }

    if (!node.nodes || value === null) {
      if (node.parent) {
        let isParentGrid = this.gridStatus(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) {
          value = false
        } else {
          value = isParentGrid
        }
      } else if (typeof this.prefixes.options.grid !== &#039;undefined&#039;) {
        value = this.prefixes.options.grid
      } else if (typeof process.env.AUTOPREFIXER_GRID !== &#039;undefined&#039;) {
        if (process.env.AUTOPREFIXER_GRID === &#039;autoplace&#039;) {
          value = &#039;autoplace&#039;
        } else {
          value = true
        }
      } else {
        value = false
      }
    }

    node._autoprefixerGridStatus = value
    return value
  }

  /**
   * Normalize spaces in cascade declaration group
   */
  reduceSpaces(decl) {
    let stop = false
    this.prefixes.group(decl).up(() =&gt; {
      stop = true
      return true
    })
    if (stop) {
      return
    }

    let parts = decl.raw(&#039;before&#039;).split(&#039;\n&#039;)
    let prevMin = parts[parts.length - 1].length
    let diff = false

    this.prefixes.group(decl).down(other =&gt; {
      parts = other.raw(&#039;before&#039;).split(&#039;\n&#039;)
      let last = parts.length - 1

      if (parts[last].length &gt; prevMin) {
        if (diff === false) {
          diff = parts[last].length - prevMin
        }

        parts[last] = parts[last].slice(0, -diff)
        other.raws.before = parts.join(&#039;\n&#039;)
      }
    })
  }

  /**
   * Remove unnecessary pefixes
   */
  remove(css, result) {
    // At-rules
    let resolution = this.prefixes.remove[&#039;@resolution&#039;]

    css.walkAtRules((rule, i) =&gt; {
      if (this.prefixes.remove[`@${rule.name}`]) {
        if (!this.disabled(rule, result)) {
          rule.parent.removeChild(i)
        }
      } else if (
        rule.name === &#039;media&#039; &amp;&amp;
        rule.params.includes(&#039;-resolution&#039;) &amp;&amp;
        resolution
      ) {
        resolution.clean(rule)
      }
    })

    // Selectors
    css.walkRules((rule, i) =&gt; {
      if (this.disabled(rule, result)) return

      for (let checker of this.prefixes.remove.selectors) {
        if (checker.check(rule)) {
          rule.parent.removeChild(i)
          return
        }
      }
    })

    return css.walkDecls((decl, i) =&gt; {
      if (this.disabled(decl, result)) return

      let rule = decl.parent
      let unprefixed = this.prefixes.unprefixed(decl.prop)

      // Transition
      if (decl.prop === &#039;transition&#039; || decl.prop === &#039;transition-property&#039;) {
        this.prefixes.transition.remove(decl)
      }

      // Properties
      if (
        this.prefixes.remove[decl.prop] &amp;&amp;
        this.prefixes.remove[decl.prop].remove
      ) {
        let notHack = this.prefixes.group(decl).down(other =&gt; {
          return this.prefixes.normalize(other.prop) === unprefixed
        })

        if (unprefixed === &#039;flex-flow&#039;) {
          notHack = true
        }

        if (decl.prop === &#039;-webkit-box-orient&#039;) {
          let hacks = { &#039;flex-direction&#039;: true, &#039;flex-flow&#039;: true }
          if (!decl.parent.some(j =&gt; hacks[j.prop])) return
        }

        if (notHack &amp;&amp; !this.withHackValue(decl)) {
          if (decl.raw(&#039;before&#039;).includes(&#039;\n&#039;)) {
            this.reduceSpaces(decl)
          }
          rule.removeChild(i)
          return
        }
      }

      // Values
      for (let checker of this.prefixes.values(&#039;remove&#039;, unprefixed)) {
        if (!checker.check) continue
        if (!checker.check(decl.value)) continue

        unprefixed = checker.unprefixed
        let notHack = this.prefixes.group(decl).down(other =&gt; {
          return other.value.includes(unprefixed)
        })

        if (notHack) {
          rule.removeChild(i)
          return
        }
      }
    })
  }

  /**
   * Some rare old values, which is not in standard
   */
  withHackValue(decl) {
    return (
      (decl.prop === &#039;-webkit-background-clip&#039; &amp;&amp; decl.value === &#039;text&#039;) ||
      // Do not remove -webkit-box-orient when -webkit-line-clamp is present.
      // https://github.com/postcss/autoprefixer/issues/1510
      (decl.prop === &#039;-webkit-box-orient&#039; &amp;&amp;
        decl.parent.some(d =&gt; d.prop === &#039;-webkit-line-clamp&#039;))
    )
  }
}

module.exports = Processor
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
