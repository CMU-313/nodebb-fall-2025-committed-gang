<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nyc/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nyc/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">542</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.17</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

/* global __coverage__ */

const cachingTransform = require(&#039;caching-transform&#039;)
const findCacheDir = require(&#039;find-cache-dir&#039;)
const fs = require(&#039;./lib/fs-promises&#039;)
const os = require(&#039;os&#039;)
const { debuglog, promisify } = require(&#039;util&#039;)
const glob = promisify(require(&#039;glob&#039;))
const Hash = require(&#039;./lib/hash&#039;)
const libCoverage = require(&#039;istanbul-lib-coverage&#039;)
const libHook = require(&#039;istanbul-lib-hook&#039;)
const { ProcessInfo, ProcessDB } = require(&#039;istanbul-lib-processinfo&#039;)
const mkdirp = require(&#039;make-dir&#039;)
const Module = require(&#039;module&#039;)
const onExit = require(&#039;signal-exit&#039;)
const path = require(&#039;path&#039;)
const rimraf = promisify(require(&#039;rimraf&#039;))
const SourceMaps = require(&#039;./lib/source-maps&#039;)
const TestExclude = require(&#039;test-exclude&#039;)
const pMap = require(&#039;p-map&#039;)
const getPackageType = require(&#039;get-package-type&#039;)

const debugLog = debuglog(&#039;nyc&#039;)

const nycSelfCoverageHelper = Symbol.for(&#039;nyc self-test coverage helper&#039;)
/* istanbul ignore next */
const selfCoverageHelper = global[nycSelfCoverageHelper] || {
  // Avoid additional conditional code
  onExit () {}
}

function coverageFinder () {
  var coverage = global.__coverage__
  if (typeof __coverage__ === &#039;object&#039;) coverage = __coverage__
  if (!coverage) coverage = global.__coverage__ = {}
  return coverage
}

class NYC {
  constructor (config) {
    this.config = { ...config }

    this.subprocessBin = config.subprocessBin || path.resolve(__dirname, &#039;./bin/nyc.js&#039;)
    this._tempDirectory = config.tempDirectory || config.tempDir || &#039;./.nyc_output&#039;
    this._instrumenterLib = require(config.instrumenter || &#039;./lib/instrumenters/istanbul&#039;)
    this._reportDir = config.reportDir || &#039;coverage&#039;
    this._sourceMap = typeof config.sourceMap === &#039;boolean&#039; ? config.sourceMap : true
    this._showProcessTree = config.showProcessTree || false
    this._eagerInstantiation = config.eager || false
    this.cwd = config.cwd || process.cwd()
    this.reporter = [].concat(config.reporter || &#039;text&#039;)

    this.cacheDirectory = (config.cacheDir &amp;&amp; path.resolve(config.cacheDir)) || findCacheDir({ name: &#039;nyc&#039;, cwd: this.cwd })
    this.cache = Boolean(this.cacheDirectory &amp;&amp; config.cache)

    this.extensions = [].concat(config.extension || [])
      .concat(&#039;.js&#039;)
      .map(ext =&gt; ext.toLowerCase())
      .filter((item, pos, arr) =&gt; arr.indexOf(item) === pos)

    this.exclude = new TestExclude({
      cwd: this.cwd,
      include: config.include,
      exclude: config.exclude,
      excludeNodeModules: config.excludeNodeModules !== false,
      extension: this.extensions
    })

    this.sourceMaps = new SourceMaps({
      cache: this.cache,
      cacheDirectory: this.cacheDirectory
    })

    // require extensions can be provided as config in package.json.
    this.require = [].concat(config.require || [])

    this.transforms = this.extensions.reduce((transforms, ext) =&gt; {
      transforms[ext] = this._createTransform(ext)
      return transforms
    }, {})

    this.hookRequire = config.hookRequire
    this.hookRunInContext = config.hookRunInContext
    this.hookRunInThisContext = config.hookRunInThisContext
    this.fakeRequire = null

    this.processInfo = new ProcessInfo(Object.assign({}, config._processInfo, {
      directory: path.resolve(this.tempDirectory(), &#039;processinfo&#039;)
    }))

    this.hashCache = {}
  }

  _createTransform (ext) {
    const opts = {
      salt: Hash.salt(this.config),
      hashData: (input, metadata) =&gt; [metadata.filename],
      filenamePrefix: metadata =&gt; path.parse(metadata.filename).name + &#039;-&#039;,
      onHash: (input, metadata, hash) =&gt; {
        this.hashCache[metadata.filename] = hash
      },
      cacheDir: this.cacheDirectory,
      // when running --all we should not load source-file from
      // cache, we want to instead return the fake source.
      disableCache: this._disableCachingTransform(),
      ext: ext
    }
    if (this._eagerInstantiation) {
      opts.transform = this._transformFactory(this.cacheDirectory)
    } else {
      opts.factory = this._transformFactory.bind(this)
    }
    return cachingTransform(opts)
  }

  _disableCachingTransform () {
    return !(this.cache &amp;&amp; this.config.isChildProcess)
  }

  _loadAdditionalModules () {
    if (!this.config.useSpawnWrap || this.require.length === 0) {
      return
    }

    const resolveFrom = require(&#039;resolve-from&#039;)
    this.require.forEach(requireModule =&gt; {
      // Attempt to require the module relative to the directory being instrumented.
      // Then try other locations, e.g. the nyc node_modules folder.
      require(resolveFrom.silent(this.cwd, requireModule) || requireModule)
    })
  }

  instrumenter () {
    return this._instrumenter || (this._instrumenter = this._createInstrumenter())
  }

  _createInstrumenter () {
    return this._instrumenterLib({
      ignoreClassMethods: [].concat(this.config.ignoreClassMethod).filter(a =&gt; a),
      produceSourceMap: this.config.produceSourceMap,
      compact: this.config.compact,
      preserveComments: this.config.preserveComments,
      esModules: this.config.esModules,
      parserPlugins: this.config.parserPlugins
    })
  }

  addFile (filename) {
    const source = this._readTranspiledSource(filename)
    this._maybeInstrumentSource(source, filename)
  }

  _readTranspiledSource (filePath) {
    var source = null
    var ext = path.extname(filePath)
    if (typeof Module._extensions[ext] === &#039;undefined&#039;) {
      ext = &#039;.js&#039;
    }
    Module._extensions[ext]({
      _compile: function (content, filename) {
        source = content
      }
    }, filePath)
    return source
  }

  _getSourceMap (code, filename, hash) {
    const sourceMap = {}
    if (this._sourceMap) {
      sourceMap.sourceMap = this.sourceMaps.extract(code, filename)
      sourceMap.registerMap = () =&gt; this.sourceMaps.registerMap(filename, hash, sourceMap.sourceMap)
    } else {
      sourceMap.registerMap = () =&gt; {}
    }

    return sourceMap
  }

  async addAllFiles () {
    this._loadAdditionalModules()

    this.fakeRequire = true
    const files = await this.exclude.glob(this.cwd)
    for (const relFile of files) {
      const filename = path.resolve(this.cwd, relFile)
      const ext = path.extname(filename)
      if (ext === &#039;.mjs&#039; || (ext === &#039;.js&#039; &amp;&amp; await getPackageType(filename) === &#039;module&#039;)) {
        const source = await fs.readFile(filename, &#039;utf8&#039;)
        this.instrumenter().instrumentSync(
          source,
          filename,
          this._getSourceMap(source, filename)
        )
      } else {
        this.addFile(filename)
      }
      const coverage = coverageFinder()
      const lastCoverage = this.instrumenter().lastFileCoverage()
      if (lastCoverage) {
        coverage[lastCoverage.path] = {
          ...lastCoverage,
          // Only use this data if we don&#039;t have it without `all: true`
          all: true
        }
      }
    }
    this.fakeRequire = false

    this.writeCoverageFile()
  }

  async instrumentAllFiles (input, output) {
    let inputDir = &#039;.&#039; + path.sep
    const visitor = async relFile =&gt; {
      const inFile = path.resolve(inputDir, relFile)
      const inCode = await fs.readFile(inFile, &#039;utf-8&#039;)
      const outCode = this._transform(inCode, inFile) || inCode

      if (output) {
        const { mode } = await fs.stat(inFile)
        const outFile = path.resolve(output, relFile)

        await mkdirp(path.dirname(outFile))
        await fs.writeFile(outFile, outCode)
        await fs.chmod(outFile, mode)
      } else {
        console.log(outCode)
      }
    }

    this._loadAdditionalModules()

    const stats = await fs.lstat(input)
    if (stats.isDirectory()) {
      inputDir = input

      const filesToInstrument = await this.exclude.glob(input)

      const concurrency = output ? os.cpus().length : 1
      if (this.config.completeCopy &amp;&amp; output) {
        const files = await glob(path.resolve(input, &#039;**&#039;), {
          dot: true,
          nodir: true,
          ignore: [&#039;**/.git&#039;, &#039;**/.git/**&#039;, path.join(output, &#039;**&#039;)]
        })
        const destDirs = new Set(
          files.map(src =&gt; path.dirname(path.join(output, path.relative(input, src))))
        )

        await pMap(
          destDirs,
          dir =&gt; mkdirp(dir),
          { concurrency }
        )
        await pMap(
          files,
          src =&gt; fs.copyFile(src, path.join(output, path.relative(input, src))),
          { concurrency }
        )
      }

      await pMap(filesToInstrument, visitor, { concurrency })
    } else {
      await visitor(input)
    }
  }

  _transform (code, filename) {
    const extname = path.extname(filename).toLowerCase()
    const transform = this.transforms[extname] || (() =&gt; null)

    return transform(code, { filename })
  }

  _maybeInstrumentSource (code, filename) {
    if (!this.exclude.shouldInstrument(filename)) {
      return null
    }

    return this._transform(code, filename)
  }

  maybePurgeSourceMapCache () {
    if (!this.cache) {
      this.sourceMaps.purgeCache()
    }
  }

  _transformFactory (cacheDir) {
    const instrumenter = this.instrumenter()
    let instrumented

    return (code, metadata, hash) =&gt; {
      const filename = metadata.filename
      const sourceMap = this._getSourceMap(code, filename, hash)

      try {
        instrumented = instrumenter.instrumentSync(code, filename, sourceMap)
      } catch (e) {
        debugLog(&#039;failed to instrument &#039; + filename + &#039; with error: &#039; + e.stack)
        if (this.config.exitOnError) {
          console.error(&#039;Failed to instrument &#039; + filename)
          process.exit(1)
        } else {
          instrumented = code
        }
      }

      if (this.fakeRequire) {
        return &#039;function x () {}&#039;
      } else {
        return instrumented
      }
    }
  }

  _handleJs (code, options) {
    // ensure the path has correct casing (see istanbuljs/nyc#269 and nodejs/node#6624)
    const filename = path.resolve(this.cwd, options.filename)
    return this._maybeInstrumentSource(code, filename) || code
  }

  _addHook (type) {
    const handleJs = this._handleJs.bind(this)
    const dummyMatcher = () =&gt; true // we do all processing in transformer
    libHook[&#039;hook&#039; + type](dummyMatcher, handleJs, { extensions: this.extensions })
  }

  _addRequireHooks () {
    if (this.hookRequire) {
      this._addHook(&#039;Require&#039;)
    }
    if (this.hookRunInContext) {
      this._addHook(&#039;RunInContext&#039;)
    }
    if (this.hookRunInThisContext) {
      this._addHook(&#039;RunInThisContext&#039;)
    }
  }

  async createTempDirectory () {
    await mkdirp(this.tempDirectory())
    if (this.cache) {
      await mkdirp(this.cacheDirectory)
    }

    await mkdirp(this.processInfo.directory)
  }

  async reset () {
    if (!process.env.NYC_CWD) {
      await rimraf(this.tempDirectory())
    }

    await this.createTempDirectory()
  }

  _wrapExit () {
    selfCoverageHelper.registered = true

    // we always want to write coverage
    // regardless of how the process exits.
    onExit(
      () =&gt; {
        this.writeCoverageFile()
        selfCoverageHelper.onExit()
      },
      { alwaysLast: true }
    )
  }

  wrap (bin) {
    process.env.NYC_PROCESS_ID = this.processInfo.uuid
    // This is a bug with the spawn-wrap method where
    // we cannot force propagation of NYC_PROCESS_ID.
    if (!this.config.useSpawnWrap) {
      const updateVariable = require(&#039;./lib/register-env.js&#039;)
      updateVariable(&#039;NYC_PROCESS_ID&#039;)
    }
    this._addRequireHooks()
    this._wrapExit()
    this._loadAdditionalModules()
    return this
  }

  writeCoverageFile () {
    var coverage = coverageFinder()

    // Remove any files that should be excluded but snuck into the coverage
    Object.keys(coverage).forEach(function (absFile) {
      if (!this.exclude.shouldInstrument(absFile)) {
        delete coverage[absFile]
      }
    }, this)

    if (this.cache) {
      Object.keys(coverage).forEach(function (absFile) {
        if (this.hashCache[absFile] &amp;&amp; coverage[absFile]) {
          coverage[absFile].contentHash = this.hashCache[absFile]
        }
      }, this)
    }

    var id = this.processInfo.uuid
    var coverageFilename = path.resolve(this.tempDirectory(), id + &#039;.json&#039;)

    fs.writeFileSync(
      coverageFilename,
      JSON.stringify(coverage),
      &#039;utf-8&#039;
    )

    this.processInfo.coverageFilename = coverageFilename
    this.processInfo.files = Object.keys(coverage)
    this.processInfo.saveSync()
  }

  async getCoverageMapFromAllCoverageFiles (baseDirectory) {
    const map = libCoverage.createCoverageMap({})
    const files = await this.coverageFiles(baseDirectory)

    await pMap(
      files,
      async f =&gt; {
        const report = await this.coverageFileLoad(f, baseDirectory)
        map.merge(report)
      },
      { concurrency: os.cpus().length }
    )

    map.data = await this.sourceMaps.remapCoverage(map.data)

    // depending on whether source-code is pre-instrumented
    // or instrumented using a JIT plugin like @babel/require
    // you may opt to exclude files after applying
    // source-map remapping logic.
    if (this.config.excludeAfterRemap) {
      map.filter(filename =&gt; this.exclude.shouldInstrument(filename))
    }

    return map
  }

  async report () {
    const libReport = require(&#039;istanbul-lib-report&#039;)
    const reports = require(&#039;istanbul-reports&#039;)

    const context = libReport.createContext({
      dir: this.reportDirectory(),
      watermarks: this.config.watermarks,
      coverageMap: await this.getCoverageMapFromAllCoverageFiles()
    })

    this.reporter.forEach((_reporter) =&gt; {
      reports.create(_reporter, {
        skipEmpty: this.config.skipEmpty,
        skipFull: this.config.skipFull,
        projectRoot: this.cwd,
        maxCols: process.stdout.columns || 100
      }).execute(context)
    })

    if (this._showProcessTree) {
      await this.showProcessTree()
    }
  }

  async writeProcessIndex () {
    const db = new ProcessDB(this.processInfo.directory)
    await db.writeIndex()
  }

  async showProcessTree () {
    const db = new ProcessDB(this.processInfo.directory)
    console.log(await db.renderTree(this))
  }

  async checkCoverage (thresholds, perFile) {
    const map = await this.getCoverageMapFromAllCoverageFiles()

    if (perFile) {
      map.files().forEach(file =&gt; {
        // ERROR: Coverage for lines (90.12%) does not meet threshold (120%) for index.js
        this._checkCoverage(map.fileCoverageFor(file).toSummary(), thresholds, file)
      })
    } else {
      // ERROR: Coverage for lines (90.12%) does not meet global threshold (120%)
      this._checkCoverage(map.getCoverageSummary(), thresholds)
    }
  }

  _checkCoverage (summary, thresholds, file) {
    Object.keys(thresholds).forEach(function (key) {
      var coverage = summary[key].pct
      if (coverage &lt; thresholds[key]) {
        process.exitCode = 1
        if (file) {
          console.error(&#039;ERROR: Coverage for &#039; + key + &#039; (&#039; + coverage + &#039;%) does not meet threshold (&#039; + thresholds[key] + &#039;%) for &#039; + file)
        } else {
          console.error(&#039;ERROR: Coverage for &#039; + key + &#039; (&#039; + coverage + &#039;%) does not meet global threshold (&#039; + thresholds[key] + &#039;%)&#039;)
        }
      }
    })
  }

  coverageFiles (baseDirectory = this.tempDirectory()) {
    return fs.readdir(baseDirectory)
  }

  async coverageFileLoad (filename, baseDirectory = this.tempDirectory()) {
    try {
      const report = JSON.parse(await fs.readFile(path.resolve(baseDirectory, filename)), &#039;utf8&#039;)
      await this.sourceMaps.reloadCachedSourceMaps(report)
      return report
    } catch (error) {
      return {}
    }
  }

  // TODO: Remove from nyc v16
  async coverageData (baseDirectory) {
    const files = await this.coverageFiles(baseDirectory)
    return pMap(
      files,
      f =&gt; this.coverageFileLoad(f, baseDirectory),
      { concurrency: os.cpus().length }
    )
  }

  tempDirectory () {
    return path.resolve(this.cwd, this._tempDirectory)
  }

  reportDirectory () {
    return path.resolve(this.cwd, this._reportDir)
  }
}

module.exports = NYC
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
