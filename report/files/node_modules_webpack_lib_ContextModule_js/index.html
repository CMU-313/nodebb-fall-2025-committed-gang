<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/ContextModule.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/ContextModule.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1257</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { OriginalSource, RawSource } = require(&quot;webpack-sources&quot;);
const AsyncDependenciesBlock = require(&quot;./AsyncDependenciesBlock&quot;);
const { makeWebpackError } = require(&quot;./HookWebpackError&quot;);
const Module = require(&quot;./Module&quot;);
const { JS_TYPES } = require(&quot;./ModuleSourceTypesConstants&quot;);
const { JAVASCRIPT_MODULE_TYPE_DYNAMIC } = require(&quot;./ModuleTypeConstants&quot;);
const RuntimeGlobals = require(&quot;./RuntimeGlobals&quot;);
const Template = require(&quot;./Template&quot;);
const WebpackError = require(&quot;./WebpackError&quot;);
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder,
	compareModulesById
} = require(&quot;./util/comparators&quot;);
const {
	contextify,
	parseResource,
	makePathsRelative
} = require(&quot;./util/identifier&quot;);
const makeSerializable = require(&quot;./util/makeSerializable&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).ResolveOptions} ResolveOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import(&quot;./Chunk&quot;)} Chunk */
/** @typedef {import(&quot;./Chunk&quot;).ChunkId} ChunkId */
/** @typedef {import(&quot;./ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;./ChunkGraph&quot;).ModuleId} ModuleId */
/** @typedef {import(&quot;./ChunkGroup&quot;).RawChunkGroupOptions} RawChunkGroupOptions */
/** @typedef {import(&quot;./Compilation&quot;)} Compilation */
/** @typedef {import(&quot;./Dependency&quot;)} Dependency */
/** @typedef {import(&quot;./DependencyTemplates&quot;)} DependencyTemplates */
/** @typedef {import(&quot;./Generator&quot;).SourceTypes} SourceTypes */
/** @typedef {import(&quot;./Module&quot;).BuildCallback} BuildCallback */
/** @typedef {import(&quot;./Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;./Module&quot;).BuildMeta} BuildMeta */
/** @typedef {import(&quot;./Module&quot;).CodeGenerationContext} CodeGenerationContext */
/** @typedef {import(&quot;./Module&quot;).CodeGenerationResult} CodeGenerationResult */
/** @typedef {import(&quot;./Module&quot;).LibIdentOptions} LibIdentOptions */
/** @typedef {import(&quot;./Module&quot;).NeedBuildCallback} NeedBuildCallback */
/** @typedef {import(&quot;./Module&quot;).NeedBuildContext} NeedBuildContext */
/** @typedef {import(&quot;./ModuleGraph&quot;)} ModuleGraph */
/** @typedef {import(&quot;./RequestShortener&quot;)} RequestShortener */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolverWithOptions} ResolverWithOptions */
/** @typedef {import(&quot;./RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {import(&quot;./dependencies/ContextElementDependency&quot;)} ContextElementDependency */
/** @typedef {import(&quot;./javascript/JavascriptParser&quot;).ImportAttributes} ImportAttributes */
/** @typedef {import(&quot;./serialization/ObjectMiddleware&quot;).ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import(&quot;./serialization/ObjectMiddleware&quot;).ObjectSerializerContext} ObjectSerializerContext */
/** @template T @typedef {import(&quot;./util/LazySet&quot;)&lt;T&gt;} LazySet&lt;T&gt; */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */

/** @typedef {&quot;sync&quot; | &quot;eager&quot; | &quot;weak&quot; | &quot;async-weak&quot; | &quot;lazy&quot; | &quot;lazy-once&quot;} ContextMode Context mode */

/**
 * @typedef {object} ContextOptions
 * @property {ContextMode} mode
 * @property {boolean} recursive
 * @property {RegExp} regExp
 * @property {(&quot;strict&quot; | boolean)=} namespaceObject
 * @property {string=} addon
 * @property {(string | null)=} chunkName
 * @property {(RegExp | null)=} include
 * @property {(RegExp | null)=} exclude
 * @property {RawChunkGroupOptions=} groupOptions
 * @property {string=} typePrefix
 * @property {string=} category
 * @property {(string[][] | null)=} referencedExports exports referenced from modules (won&#039;t be mangled)
 * @property {string=} layer
 * @property {ImportAttributes=} attributes
 */

/**
 * @typedef {object} ContextModuleOptionsExtras
 * @property {false | string | string[]} resource
 * @property {string=} resourceQuery
 * @property {string=} resourceFragment
 * @property {ResolveOptions=} resolveOptions
 */

/** @typedef {ContextOptions &amp; ContextModuleOptionsExtras} ContextModuleOptions */

/**
 * @callback ResolveDependenciesCallback
 * @param {Error | null} err
 * @param {ContextElementDependency[]=} dependencies
 */

/**
 * @callback ResolveDependencies
 * @param {InputFileSystem} fs
 * @param {ContextModuleOptions} options
 * @param {ResolveDependenciesCallback} callback
 */

/** @typedef {1 | 3 | 7 | 9} FakeMapType */

/** @typedef {Record&lt;ModuleId, FakeMapType&gt;} FakeMap */

const SNAPSHOT_OPTIONS = { timestamp: true };

class ContextModule extends Module {
	/**
	 * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context
	 * @param {ContextModuleOptions} options options object
	 */
	constructor(resolveDependencies, options) {
		if (!options || typeof options.resource === &quot;string&quot;) {
			const parsed = parseResource(
				options ? /** @type {string} */ (options.resource) : &quot;&quot;
			);
			const resource = parsed.path;
			const resourceQuery = (options &amp;&amp; options.resourceQuery) || parsed.query;
			const resourceFragment =
				(options &amp;&amp; options.resourceFragment) || parsed.fragment;
			const layer = options &amp;&amp; options.layer;

			super(JAVASCRIPT_MODULE_TYPE_DYNAMIC, resource, layer);
			/** @type {ContextModuleOptions} */
			this.options = {
				...options,
				resource,
				resourceQuery,
				resourceFragment
			};
		} else {
			super(JAVASCRIPT_MODULE_TYPE_DYNAMIC, undefined, options.layer);
			/** @type {ContextModuleOptions} */
			this.options = {
				...options,
				resource: options.resource,
				resourceQuery: options.resourceQuery || &quot;&quot;,
				resourceFragment: options.resourceFragment || &quot;&quot;
			};
		}

		// Info from Factory
		/** @type {ResolveDependencies | undefined} */
		this.resolveDependencies = resolveDependencies;
		if (options &amp;&amp; options.resolveOptions !== undefined) {
			this.resolveOptions = options.resolveOptions;
		}

		if (options &amp;&amp; typeof options.mode !== &quot;string&quot;) {
			throw new Error(&quot;options.mode is a required option&quot;);
		}

		this._identifier = this._createIdentifier();
		this._forceBuild = true;
	}

	/**
	 * @returns {SourceTypes} types available (do not mutate)
	 */
	getSourceTypes() {
		return JS_TYPES;
	}

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 * @param {Module} module fresh module
	 * @returns {void}
	 */
	updateCacheModule(module) {
		const m = /** @type {ContextModule} */ (module);
		this.resolveDependencies = m.resolveDependencies;
		this.options = m.options;
	}

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache() {
		super.cleanupForCache();
		this.resolveDependencies = undefined;
	}

	/**
	 * @private
	 * @param {RegExp} regexString RegExp as a string
	 * @param {boolean=} stripSlash do we need to strip a slsh
	 * @returns {string} pretty RegExp
	 */
	_prettyRegExp(regexString, stripSlash = true) {
		const str = stripSlash
			? regexString.source + regexString.flags
			: `${regexString}`;
		return str.replace(/!/g, &quot;%21&quot;).replace(/\|/g, &quot;%7C&quot;);
	}

	_createIdentifier() {
		let identifier =
			this.context ||
			(typeof this.options.resource === &quot;string&quot; ||
			this.options.resource === false
				? `${this.options.resource}`
				: this.options.resource.join(&quot;|&quot;));
		if (this.options.resourceQuery) {
			identifier += `|${this.options.resourceQuery}`;
		}
		if (this.options.resourceFragment) {
			identifier += `|${this.options.resourceFragment}`;
		}
		if (this.options.mode) {
			identifier += `|${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += &quot;|nonrecursive&quot;;
		}
		if (this.options.addon) {
			identifier += `|${this.options.addon}`;
		}
		if (this.options.regExp) {
			identifier += `|${this._prettyRegExp(this.options.regExp, false)}`;
		}
		if (this.options.include) {
			identifier += `|include: ${this._prettyRegExp(
				this.options.include,
				false
			)}`;
		}
		if (this.options.exclude) {
			identifier += `|exclude: ${this._prettyRegExp(
				this.options.exclude,
				false
			)}`;
		}
		if (this.options.referencedExports) {
			identifier += `|referencedExports: ${JSON.stringify(
				this.options.referencedExports
			)}`;
		}
		if (this.options.chunkName) {
			identifier += `|chunkName: ${this.options.chunkName}`;
		}
		if (this.options.groupOptions) {
			identifier += `|groupOptions: ${JSON.stringify(
				this.options.groupOptions
			)}`;
		}
		if (this.options.namespaceObject === &quot;strict&quot;) {
			identifier += &quot;|strict namespace object&quot;;
		} else if (this.options.namespaceObject) {
			identifier += &quot;|namespace object&quot;;
		}
		if (this.layer) {
			identifier += `|layer: ${this.layer}`;
		}

		return identifier;
	}

	/**
	 * @returns {string} a unique identifier of the module
	 */
	identifier() {
		return this._identifier;
	}

	/**
	 * @param {RequestShortener} requestShortener the request shortener
	 * @returns {string} a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		let identifier;
		if (this.context) {
			identifier = `${requestShortener.shorten(this.context)}/`;
		} else if (
			typeof this.options.resource === &quot;string&quot; ||
			this.options.resource === false
		) {
			identifier = `${requestShortener.shorten(`${this.options.resource}`)}/`;
		} else {
			identifier = this.options.resource
				.map(r =&gt; `${requestShortener.shorten(r)}/`)
				.join(&quot; &quot;);
		}
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += &quot; nonrecursive&quot;;
		}
		if (this.options.addon) {
			identifier += ` ${requestShortener.shorten(this.options.addon)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this._prettyRegExp(this.options.regExp)}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this._prettyRegExp(this.options.include)}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)}`;
		}
		if (this.options.referencedExports) {
			identifier += ` referencedExports: ${this.options.referencedExports
				.map(e =&gt; e.join(&quot;.&quot;))
				.join(&quot;, &quot;)}`;
		}
		if (this.options.chunkName) {
			identifier += ` chunkName: ${this.options.chunkName}`;
		}
		if (this.options.groupOptions) {
			const groupOptions = this.options.groupOptions;
			for (const key of Object.keys(groupOptions)) {
				identifier += ` ${key}: ${
					groupOptions[/** @type {keyof RawChunkGroupOptions} */ (key)]
				}`;
			}
		}
		if (this.options.namespaceObject === &quot;strict&quot;) {
			identifier += &quot; strict namespace object&quot;;
		} else if (this.options.namespaceObject) {
			identifier += &quot; namespace object&quot;;
		}

		return identifier;
	}

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let identifier;

		if (this.context) {
			identifier = contextify(
				options.context,
				this.context,
				options.associatedObjectForCache
			);
		} else if (typeof this.options.resource === &quot;string&quot;) {
			identifier = contextify(
				options.context,
				this.options.resource,
				options.associatedObjectForCache
			);
		} else if (this.options.resource === false) {
			identifier = &quot;false&quot;;
		} else {
			identifier = this.options.resource
				.map(res =&gt;
					contextify(options.context, res, options.associatedObjectForCache)
				)
				.join(&quot; &quot;);
		}

		if (this.layer) identifier = `(${this.layer})/${identifier}`;
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (this.options.recursive) {
			identifier += &quot; recursive&quot;;
		}
		if (this.options.addon) {
			identifier += ` ${contextify(
				options.context,
				this.options.addon,
				options.associatedObjectForCache
			)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this._prettyRegExp(this.options.regExp)}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this._prettyRegExp(this.options.include)}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)}`;
		}
		if (this.options.referencedExports) {
			identifier += ` referencedExports: ${this.options.referencedExports
				.map(e =&gt; e.join(&quot;.&quot;))
				.join(&quot;, &quot;)}`;
		}

		return identifier;
	}

	/**
	 * @returns {void}
	 */
	invalidateBuild() {
		this._forceBuild = true;
	}

	/**
	 * @param {NeedBuildContext} context context info
	 * @param {NeedBuildCallback} callback callback function, returns true, if the module needs a rebuild
	 * @returns {void}
	 */
	needBuild({ fileSystemInfo }, callback) {
		// build if enforced
		if (this._forceBuild) return callback(null, true);

		const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);

		// always build when we have no snapshot and context
		if (!buildInfo.snapshot)
			return callback(null, Boolean(this.context || this.options.resource));

		fileSystemInfo.checkSnapshotValid(buildInfo.snapshot, (err, valid) =&gt; {
			callback(err, !valid);
		});
	}

	/**
	 * @param {WebpackOptions} options webpack options
	 * @param {Compilation} compilation the compilation
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {BuildCallback} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		/** @type {BuildMeta} */
		this.buildMeta = {
			exportsType: &quot;default&quot;,
			defaultObject: &quot;redirect-warn&quot;
		};
		this.buildInfo = {
			snapshot: undefined
		};
		this.dependencies.length = 0;
		this.blocks.length = 0;
		const startTime = Date.now();
		/** @type {ResolveDependencies} */
		(this.resolveDependencies)(fs, this.options, (err, dependencies) =&gt; {
			if (err) {
				return callback(
					makeWebpackError(err, &quot;ContextModule.resolveDependencies&quot;)
				);
			}

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			}

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}
			dependencies.sort(
				concatComparators(
					compareSelect(a =&gt; a.loc, compareLocations),
					keepOriginalOrder(this.dependencies)
				)
			);

			if (this.options.mode === &quot;sync&quot; || this.options.mode === &quot;eager&quot;) {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			} else if (this.options.mode === &quot;lazy-once&quot;) {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length &gt; 0) {
					const block = new AsyncDependenciesBlock({
						...this.options.groupOptions,
						name: this.options.chunkName
					});
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === &quot;weak&quot; ||
				this.options.mode === &quot;async-weak&quot;
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === &quot;lazy&quot;) {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += &quot;[index]&quot;;
						}
						chunkName = chunkName.replace(/\[index\]/g, `${index++}`);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						{
							...this.options.groupOptions,
							name: chunkName
						},
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new WebpackError(`Unsupported mode &quot;${this.options.mode}&quot; in context`)
				);
				return;
			}
			if (!this.context &amp;&amp; !this.options.resource) return callback();

			compilation.fileSystemInfo.createSnapshot(
				startTime,
				null,
				this.context
					? [this.context]
					: typeof this.options.resource === &quot;string&quot;
						? [this.options.resource]
						: /** @type {string[]} */ (this.options.resource),
				null,
				SNAPSHOT_OPTIONS,
				(err, snapshot) =&gt; {
					if (err) return callback(err);
					/** @type {BuildInfo} */
					(this.buildInfo).snapshot = snapshot;
					callback();
				}
			);
		});
	}

	/**
	 * @param {LazySet&lt;string&gt;} fileDependencies set where file dependencies are added to
	 * @param {LazySet&lt;string&gt;} contextDependencies set where context dependencies are added to
	 * @param {LazySet&lt;string&gt;} missingDependencies set where missing dependencies are added to
	 * @param {LazySet&lt;string&gt;} buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {
		if (this.context) {
			contextDependencies.add(this.context);
		} else if (typeof this.options.resource === &quot;string&quot;) {
			contextDependencies.add(this.options.resource);
		} else if (this.options.resource === false) {
			// Do nothing
		} else {
			for (const res of this.options.resource) contextDependencies.add(res);
		}
	}

	/**
	 * @param {Dependency[]} dependencies all dependencies
	 * @param {ChunkGraph} chunkGraph chunk graph
	 * @returns {Map&lt;string, string | number&gt;} map with user requests
	 */
	getUserRequestMap(dependencies, chunkGraph) {
		const moduleGraph = chunkGraph.moduleGraph;
		// if we filter first we get a new array
		// therefore we don&#039;t need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		const sortedDependencies =
			/** @type {ContextElementDependency[]} */
			(dependencies)
				.filter(dependency =&gt; moduleGraph.getModule(dependency))
				.sort((a, b) =&gt; {
					if (a.userRequest === b.userRequest) {
						return 0;
					}
					return a.userRequest &lt; b.userRequest ? -1 : 1;
				});
		const map = Object.create(null);
		for (const dep of sortedDependencies) {
			const module = /** @type {Module} */ (moduleGraph.getModule(dep));
			map[dep.userRequest] = chunkGraph.getModuleId(module);
		}
		return map;
	}

	/**
	 * @param {Dependency[]} dependencies all dependencies
	 * @param {ChunkGraph} chunkGraph chunk graph
	 * @returns {FakeMap | FakeMapType} fake map
	 */
	getFakeMap(dependencies, chunkGraph) {
		if (!this.options.namespaceObject) {
			return 9;
		}
		const moduleGraph = chunkGraph.moduleGraph;
		// bitfield
		let hasType = 0;
		const comparator = compareModulesById(chunkGraph);
		// if we filter first we get a new array
		// therefore we don&#039;t need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		const sortedModules = dependencies
			.map(
				dependency =&gt; /** @type {Module} */ (moduleGraph.getModule(dependency))
			)
			.filter(Boolean)
			.sort(comparator);
		/** @type {FakeMap} */
		const fakeMap = Object.create(null);
		for (const module of sortedModules) {
			const exportsType = module.getExportsType(
				moduleGraph,
				this.options.namespaceObject === &quot;strict&quot;
			);
			const id = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));
			switch (exportsType) {
				case &quot;namespace&quot;:
					fakeMap[id] = 9;
					hasType |= 1;
					break;
				case &quot;dynamic&quot;:
					fakeMap[id] = 7;
					hasType |= 2;
					break;
				case &quot;default-only&quot;:
					fakeMap[id] = 1;
					hasType |= 4;
					break;
				case &quot;default-with-named&quot;:
					fakeMap[id] = 3;
					hasType |= 8;
					break;
				default:
					throw new Error(`Unexpected exports type ${exportsType}`);
			}
		}
		if (hasType === 1) {
			return 9;
		}
		if (hasType === 2) {
			return 7;
		}
		if (hasType === 4) {
			return 1;
		}
		if (hasType === 8) {
			return 3;
		}
		if (hasType === 0) {
			return 9;
		}
		return fakeMap;
	}

	/**
	 * @param {FakeMap | FakeMapType} fakeMap fake map
	 * @returns {string} fake map init statement
	 */
	getFakeMapInitStatement(fakeMap) {
		return typeof fakeMap === &quot;object&quot;
			? `var fakeMap = ${JSON.stringify(fakeMap, null, &quot;\t&quot;)};`
			: &quot;&quot;;
	}

	/**
	 * @param {FakeMapType} type type
	 * @param {boolean=} asyncModule is async module
	 * @returns {string} return result
	 */
	getReturn(type, asyncModule) {
		if (type === 9) {
			return `${RuntimeGlobals.require}(id)`;
		}
		return `${RuntimeGlobals.createFakeNamespaceObject}(id, ${type}${
			asyncModule ? &quot; | 16&quot; : &quot;&quot;
		})`;
	}

	/**
	 * @param {FakeMap | FakeMapType} fakeMap fake map
	 * @param {boolean=} asyncModule us async module
	 * @param {string=} fakeMapDataExpression fake map data expression
	 * @returns {string} module object source
	 */
	getReturnModuleObjectSource(
		fakeMap,
		asyncModule,
		fakeMapDataExpression = &quot;fakeMap[id]&quot;
	) {
		if (typeof fakeMap === &quot;number&quot;) {
			return `return ${this.getReturn(fakeMap, asyncModule)};`;
		}
		return `return ${
			RuntimeGlobals.createFakeNamespaceObject
		}(id, ${fakeMapDataExpression}${asyncModule ? &quot; | 16&quot; : &quot;&quot;})`;
	}

	/**
	 * @param {Dependency[]} dependencies dependencies
	 * @param {ModuleId} id module id
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @returns {string} source code
	 */
	getSyncSource(dependencies, id, chunkGraph) {
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, &quot;\t&quot;)};
${this.getFakeMapInitStatement(fakeMap)}

function webpackContext(req) {
	var id = webpackContextResolve(req);
	${returnModuleObject}
}
function webpackContextResolve(req) {
	if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
		var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
		e.code = &#039;MODULE_NOT_FOUND&#039;;
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = ${JSON.stringify(id)};`;
	}

	/**
	 * @param {Dependency[]} dependencies dependencies
	 * @param {ModuleId} id module id
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @returns {string} source code
	 */
	getWeakSyncSource(dependencies, id, chunkGraph) {
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, &quot;\t&quot;)};
${this.getFakeMapInitStatement(fakeMap)}

function webpackContext(req) {
	var id = webpackContextResolve(req);
	if(!${RuntimeGlobals.moduleFactories}[id]) {
		var e = new Error(&quot;Module &#039;&quot; + req + &quot;&#039; (&#039;&quot; + id + &quot;&#039;) is not available (weak dependency)&quot;);
		e.code = &#039;MODULE_NOT_FOUND&#039;;
		throw e;
	}
	${returnModuleObject}
}
function webpackContextResolve(req) {
	if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
		var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
		e.code = &#039;MODULE_NOT_FOUND&#039;;
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
webpackContext.id = ${JSON.stringify(id)};
module.exports = webpackContext;`;
	}

	/**
	 * @param {Dependency[]} dependencies dependencies
	 * @param {ModuleId} id module id
	 * @param {object} context context
	 * @param {ChunkGraph} context.chunkGraph the chunk graph
	 * @param {RuntimeTemplate} context.runtimeTemplate the chunk graph
	 * @returns {string} source code
	 */
	getAsyncWeakSource(dependencies, id, { chunkGraph, runtimeTemplate }) {
		const arrow = runtimeTemplate.supportsArrowFunction();
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap, true);

		return `var map = ${JSON.stringify(map, null, &quot;\t&quot;)};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${
		arrow ? &quot;id =&gt;&quot; : &quot;function(id)&quot;
	} {
		if(!${RuntimeGlobals.moduleFactories}[id]) {
			var e = new Error(&quot;Module &#039;&quot; + req + &quot;&#039; (&#039;&quot; + id + &quot;&#039;) is not available (weak dependency)&quot;);
			e.code = &#039;MODULE_NOT_FOUND&#039;;
			throw e;
		}
		${returnModuleObject}
	});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
		if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
			var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
			e.code = &#039;MODULE_NOT_FOUND&#039;;
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			&quot;Object.keys(map)&quot;
		)};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	/**
	 * @param {Dependency[]} dependencies dependencies
	 * @param {ModuleId} id module id
	 * @param {object} context context
	 * @param {ChunkGraph} context.chunkGraph the chunk graph
	 * @param {RuntimeTemplate} context.runtimeTemplate the chunk graph
	 * @returns {string} source code
	 */
	getEagerSource(dependencies, id, { chunkGraph, runtimeTemplate }) {
		const arrow = runtimeTemplate.supportsArrowFunction();
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const thenFunction =
			fakeMap !== 9
				? `${arrow ? &quot;id =&gt;&quot; : &quot;function(id)&quot;} {
		${this.getReturnModuleObjectSource(fakeMap, true)}
	}`
				: RuntimeGlobals.require;
		return `var map = ${JSON.stringify(map, null, &quot;\t&quot;)};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
		if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
			var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
			e.code = &#039;MODULE_NOT_FOUND&#039;;
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			&quot;Object.keys(map)&quot;
		)};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	/**
	 * @param {AsyncDependenciesBlock} block block
	 * @param {Dependency[]} dependencies dependencies
	 * @param {ModuleId} id module id
	 * @param {object} options options object
	 * @param {RuntimeTemplate} options.runtimeTemplate the runtime template
	 * @param {ChunkGraph} options.chunkGraph the chunk graph
	 * @returns {string} source code
	 */
	getLazyOnceSource(block, dependencies, id, { runtimeTemplate, chunkGraph }) {
		const promise = runtimeTemplate.blockPromise({
			chunkGraph,
			block,
			message: &quot;lazy-once context&quot;,
			runtimeRequirements: new Set()
		});
		const arrow = runtimeTemplate.supportsArrowFunction();
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const thenFunction =
			fakeMap !== 9
				? `${arrow ? &quot;id =&gt;&quot; : &quot;function(id)&quot;} {
		${this.getReturnModuleObjectSource(fakeMap, true)};
	}`
				: RuntimeGlobals.require;

		return `var map = ${JSON.stringify(map, null, &quot;\t&quot;)};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction});
}
function webpackAsyncContextResolve(req) {
	return ${promise}.then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
		if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
			var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
			e.code = &#039;MODULE_NOT_FOUND&#039;;
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			&quot;Object.keys(map)&quot;
		)};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	/**
	 * @param {AsyncDependenciesBlock[]} blocks blocks
	 * @param {ModuleId} id module id
	 * @param {object} context context
	 * @param {ChunkGraph} context.chunkGraph the chunk graph
	 * @param {RuntimeTemplate} context.runtimeTemplate the chunk graph
	 * @returns {string} source code
	 */
	getLazySource(blocks, id, { chunkGraph, runtimeTemplate }) {
		const moduleGraph = chunkGraph.moduleGraph;
		const arrow = runtimeTemplate.supportsArrowFunction();
		let hasMultipleOrNoChunks = false;
		let hasNoChunk = true;
		const fakeMap = this.getFakeMap(
			blocks.map(b =&gt; b.dependencies[0]),
			chunkGraph
		);
		const hasFakeMap = typeof fakeMap === &quot;object&quot;;
		/** @typedef {{userRequest: string, dependency: ContextElementDependency, chunks: undefined | Chunk[], module: Module, block: AsyncDependenciesBlock}} Item */
		/**
		 * @type {Item[]}
		 */
		const items = blocks
			.map(block =&gt; {
				const dependency =
					/** @type {ContextElementDependency} */
					(block.dependencies[0]);
				return {
					dependency,
					module: /** @type {Module} */ (moduleGraph.getModule(dependency)),
					block,
					userRequest: dependency.userRequest,
					chunks: undefined
				};
			})
			.filter(item =&gt; item.module);
		for (const item of items) {
			const chunkGroup = chunkGraph.getBlockChunkGroup(item.block);
			const chunks = (chunkGroup &amp;&amp; chunkGroup.chunks) || [];
			item.chunks = chunks;
			if (chunks.length &gt; 0) {
				hasNoChunk = false;
			}
			if (chunks.length !== 1) {
				hasMultipleOrNoChunks = true;
			}
		}
		const shortMode = hasNoChunk &amp;&amp; !hasFakeMap;
		const sortedItems = items.sort((a, b) =&gt; {
			if (a.userRequest === b.userRequest) return 0;
			return a.userRequest &lt; b.userRequest ? -1 : 1;
		});
		/** @type {Record&lt;string, ModuleId | (ModuleId[] | ChunkId[])&gt;} */
		const map = Object.create(null);
		for (const item of sortedItems) {
			const moduleId =
				/** @type {ModuleId} */
				(chunkGraph.getModuleId(item.module));
			if (shortMode) {
				map[item.userRequest] = moduleId;
			} else {
				/** @type {(ModuleId | ChunkId)[]} */
				const arrayStart = [moduleId];
				if (hasFakeMap) {
					arrayStart.push(fakeMap[moduleId]);
				}
				map[item.userRequest] = arrayStart.concat(
					/** @type {Chunk[]} */
					(item.chunks).map(chunk =&gt; /** @type {ChunkId} */ (chunk.id))
				);
			}
		}

		const chunksStartPosition = hasFakeMap ? 2 : 1;
		const requestPrefix = hasNoChunk
			? &quot;Promise.resolve()&quot;
			: hasMultipleOrNoChunks
				? `Promise.all(ids.slice(${chunksStartPosition}).map(${RuntimeGlobals.ensureChunk}))`
				: `${RuntimeGlobals.ensureChunk}(ids[${chunksStartPosition}])`;
		const returnModuleObject = this.getReturnModuleObjectSource(
			fakeMap,
			true,
			shortMode ? &quot;invalid&quot; : &quot;ids[1]&quot;
		);

		const webpackAsyncContext =
			requestPrefix === &quot;Promise.resolve()&quot;
				? `
function webpackAsyncContext(req) {
	return Promise.resolve().then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
		if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
			var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
			e.code = &#039;MODULE_NOT_FOUND&#039;;
			throw e;
		}

		${shortMode ? &quot;var id = map[req];&quot; : &quot;var ids = map[req], id = ids[0];&quot;}
		${returnModuleObject}
	});
}`
				: `function webpackAsyncContext(req) {
	if(!${RuntimeGlobals.hasOwnProperty}(map, req)) {
		return Promise.resolve().then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
			var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
			e.code = &#039;MODULE_NOT_FOUND&#039;;
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return ${requestPrefix}.then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
		${returnModuleObject}
	});
}`;

		return `var map = ${JSON.stringify(map, null, &quot;\t&quot;)};
${webpackAsyncContext}
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			&quot;Object.keys(map)&quot;
		)};
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	/**
	 * @param {ModuleId} id module id
	 * @param {RuntimeTemplate} runtimeTemplate runtime template
	 * @returns {string} source for empty async context
	 */
	getSourceForEmptyContext(id, runtimeTemplate) {
		return `function webpackEmptyContext(req) {
	var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
	e.code = &#039;MODULE_NOT_FOUND&#039;;
	throw e;
}
webpackEmptyContext.keys = ${runtimeTemplate.returningFunction(&quot;[]&quot;)};
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = ${JSON.stringify(id)};
module.exports = webpackEmptyContext;`;
	}

	/**
	 * @param {ModuleId} id module id
	 * @param {RuntimeTemplate} runtimeTemplate runtime template
	 * @returns {string} source for empty async context
	 */
	getSourceForEmptyAsyncContext(id, runtimeTemplate) {
		const arrow = runtimeTemplate.supportsArrowFunction();
		return `function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(${arrow ? &quot;() =&gt;&quot; : &quot;function()&quot;} {
		var e = new Error(&quot;Cannot find module &#039;&quot; + req + &quot;&#039;&quot;);
		e.code = &#039;MODULE_NOT_FOUND&#039;;
		throw e;
	});
}
webpackEmptyAsyncContext.keys = ${runtimeTemplate.returningFunction(&quot;[]&quot;)};
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackEmptyAsyncContext;`;
	}

	/**
	 * @param {string} asyncMode module mode
	 * @param {CodeGenerationContext} context context info
	 * @returns {string} the source code
	 */
	getSourceString(asyncMode, { runtimeTemplate, chunkGraph }) {
		const id = /** @type {ModuleId} */ (chunkGraph.getModuleId(this));
		if (asyncMode === &quot;lazy&quot;) {
			if (this.blocks &amp;&amp; this.blocks.length &gt; 0) {
				return this.getLazySource(this.blocks, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === &quot;eager&quot;) {
			if (this.dependencies &amp;&amp; this.dependencies.length &gt; 0) {
				return this.getEagerSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === &quot;lazy-once&quot;) {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(block, block.dependencies, id, {
					runtimeTemplate,
					chunkGraph
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (asyncMode === &quot;async-weak&quot;) {
			if (this.dependencies &amp;&amp; this.dependencies.length &gt; 0) {
				return this.getAsyncWeakSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				});
			}
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		}
		if (
			asyncMode === &quot;weak&quot; &amp;&amp;
			this.dependencies &amp;&amp;
			this.dependencies.length &gt; 0
		) {
			return this.getWeakSyncSource(this.dependencies, id, chunkGraph);
		}
		if (this.dependencies &amp;&amp; this.dependencies.length &gt; 0) {
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		}
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	}

	/**
	 * @param {string} sourceString source content
	 * @param {Compilation=} compilation the compilation
	 * @returns {Source} generated source
	 */
	getSource(sourceString, compilation) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(
				sourceString,
				`webpack://${makePathsRelative(
					(compilation &amp;&amp; compilation.compiler.context) || &quot;&quot;,
					this.identifier(),
					compilation &amp;&amp; compilation.compiler.root
				)}`
			);
		}
		return new RawSource(sourceString);
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration(context) {
		const { chunkGraph, compilation } = context;
		const sources = new Map();
		sources.set(
			&quot;javascript&quot;,
			this.getSource(
				this.getSourceString(this.options.mode, context),
				compilation
			)
		);
		const set = new Set();
		const allDeps =
			this.dependencies.length &gt; 0
				? /** @type {ContextElementDependency[]} */ (this.dependencies).slice()
				: [];
		for (const block of this.blocks)
			for (const dep of block.dependencies)
				allDeps.push(/** @type {ContextElementDependency} */ (dep));
		set.add(RuntimeGlobals.module);
		set.add(RuntimeGlobals.hasOwnProperty);
		if (allDeps.length &gt; 0) {
			const asyncMode = this.options.mode;
			set.add(RuntimeGlobals.require);
			if (asyncMode === &quot;weak&quot;) {
				set.add(RuntimeGlobals.moduleFactories);
			} else if (asyncMode === &quot;async-weak&quot;) {
				set.add(RuntimeGlobals.moduleFactories);
				set.add(RuntimeGlobals.ensureChunk);
			} else if (asyncMode === &quot;lazy&quot; || asyncMode === &quot;lazy-once&quot;) {
				set.add(RuntimeGlobals.ensureChunk);
			}
			if (this.getFakeMap(allDeps, chunkGraph) !== 9) {
				set.add(RuntimeGlobals.createFakeNamespaceObject);
			}
		}
		return {
			sources,
			runtimeRequirements: set
		};
	}

	/**
	 * @param {string=} type the source type for which the size should be estimated
	 * @returns {number} the estimated size of the module (must be non-zero)
	 */
	size(type) {
		// base penalty
		let size = 160;

		// if we don&#039;t have dependencies we stop here.
		for (const dependency of this.dependencies) {
			const element = /** @type {ContextElementDependency} */ (dependency);
			size += 5 + element.userRequest.length;
		}
		return size;
	}

	/**
	 * @param {ObjectSerializerContext} context context
	 */
	serialize(context) {
		const { write } = context;
		write(this._identifier);
		write(this._forceBuild);
		super.serialize(context);
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 */
	deserialize(context) {
		const { read } = context;
		this._identifier = read();
		this._forceBuild = read();
		super.deserialize(context);
	}
}

makeSerializable(ContextModule, &quot;webpack/lib/ContextModule&quot;);

module.exports = ContextModule;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
