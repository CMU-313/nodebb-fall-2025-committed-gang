<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/lint-staged/lib/gitWorkflow.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/lint-staged/lib/gitWorkflow.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">360</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">40.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.73</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import path from &#039;node:path&#039;

import debug from &#039;debug&#039;

import { execGit } from &#039;./execGit.js&#039;
import { readFile, unlink, writeFile } from &#039;./file.js&#039;
import { getDiffCommand } from &#039;./getDiffCommand.js&#039;
import {
  ApplyEmptyCommitError,
  GetBackupStashError,
  GitError,
  HideUnstagedChangesError,
  RestoreMergeStatusError,
  RestoreOriginalStateError,
  RestoreUnstagedChangesError,
} from &#039;./symbols.js&#039;

const debugLog = debug(&#039;lint-staged:GitWorkflow&#039;)

const MERGE_HEAD = &#039;MERGE_HEAD&#039;
const MERGE_MODE = &#039;MERGE_MODE&#039;
const MERGE_MSG = &#039;MERGE_MSG&#039;

// In git status machine output, renames are presented as `to`NUL`from`
// When diffing, both need to be taken into account, but in some cases on the `to`.
// eslint-disable-next-line no-control-regex
const RENAME = /\x00/

/**
 * From list of files, split renames and flatten into two files `to`NUL`from`.
 * @param {string[]} files
 * @param {Boolean} [includeRenameFrom=true] Whether or not to include the `from` renamed file, which is no longer on disk
 */
const processRenames = (files, includeRenameFrom = true) =&gt;
  files.reduce((flattened, file) =&gt; {
    if (RENAME.test(file)) {
      const [to, from] = file.split(RENAME)
      if (includeRenameFrom) flattened.push(from)
      flattened.push(to)
    } else {
      flattened.push(file)
    }
    return flattened
  }, [])

export const STASH = &#039;lint-staged automatic backup&#039;

const PATCH_UNSTAGED = &#039;lint-staged_unstaged.patch&#039;

const GIT_DIFF_ARGS = [
  &#039;--binary&#039;, // support binary files
  &#039;--unified=0&#039;, // do not add lines around diff for consistent behaviour
  &#039;--no-color&#039;, // disable colors for consistent behaviour
  &#039;--no-ext-diff&#039;, // disable external diff tools for consistent behaviour
  &#039;--src-prefix=a/&#039;, // force prefix for consistent behaviour
  &#039;--dst-prefix=b/&#039;, // force prefix for consistent behaviour
  &#039;--patch&#039;, // output a patch that can be applied
  &#039;--submodule=short&#039;, // always use the default short format for submodules
]
const GIT_APPLY_ARGS = [&#039;-v&#039;, &#039;--whitespace=nowarn&#039;, &#039;--recount&#039;, &#039;--unidiff-zero&#039;]

const handleError = (error, ctx, symbol) =&gt; {
  ctx.errors.add(GitError)
  if (symbol) ctx.errors.add(symbol)
  throw error
}

export class GitWorkflow {
  constructor({ allowEmpty, gitConfigDir, topLevelDir, matchedFileChunks, diff, diffFilter }) {
    this.execGit = (args, options = {}) =&gt; execGit(args, { ...options, cwd: topLevelDir })
    this.deletedFiles = []
    this.gitConfigDir = gitConfigDir
    this.topLevelDir = topLevelDir
    this.diff = diff
    this.diffFilter = diffFilter
    this.allowEmpty = allowEmpty
    this.matchedFileChunks = matchedFileChunks

    /**
     * These three files hold state about an ongoing git merge
     * Resolve paths during constructor
     */
    this.mergeHeadFilename = path.resolve(gitConfigDir, MERGE_HEAD)
    this.mergeModeFilename = path.resolve(gitConfigDir, MERGE_MODE)
    this.mergeMsgFilename = path.resolve(gitConfigDir, MERGE_MSG)
  }

  /**
   * Get absolute path to file hidden inside .git
   * @param {string} filename
   */
  getHiddenFilepath(filename) {
    return path.resolve(this.gitConfigDir, `./${filename}`)
  }

  /**
   * Get name of backup stash
   */
  async getBackupStash(ctx) {
    const stashes = await this.execGit([&#039;stash&#039;, &#039;list&#039;])

    const index = stashes
      .split(&#039;\n&#039;)
      .findIndex((line) =&gt; line.includes(STASH) &amp;&amp; line.includes(ctx.backupHash))

    if (index === -1) {
      ctx.errors.add(GetBackupStashError)
      throw new Error(&#039;lint-staged automatic backup is missing!&#039;)
    }

    return String(index)
  }

  /**
   * Get a list of unstaged deleted files
   */
  async getDeletedFiles() {
    debugLog(&#039;Getting deleted files...&#039;)
    const lsFiles = await this.execGit([&#039;ls-files&#039;, &#039;--deleted&#039;])
    const deletedFiles = lsFiles
      .split(&#039;\n&#039;)
      .filter(Boolean)
      .map((file) =&gt; path.resolve(this.topLevelDir, file))
    debugLog(&#039;Found deleted files:&#039;, deletedFiles)
    return deletedFiles
  }

  /**
   * Save meta information about ongoing git merge
   */
  async backupMergeStatus() {
    debugLog(&#039;Backing up merge state...&#039;)
    await Promise.all([
      readFile(this.mergeHeadFilename).then((buffer) =&gt; (this.mergeHeadBuffer = buffer)),
      readFile(this.mergeModeFilename).then((buffer) =&gt; (this.mergeModeBuffer = buffer)),
      readFile(this.mergeMsgFilename).then((buffer) =&gt; (this.mergeMsgBuffer = buffer)),
    ])
    debugLog(&#039;Done backing up merge state!&#039;)
  }

  /**
   * Restore meta information about ongoing git merge
   */
  async restoreMergeStatus(ctx) {
    debugLog(&#039;Restoring merge state...&#039;)
    try {
      await Promise.all([
        this.mergeHeadBuffer &amp;&amp; writeFile(this.mergeHeadFilename, this.mergeHeadBuffer),
        this.mergeModeBuffer &amp;&amp; writeFile(this.mergeModeFilename, this.mergeModeBuffer),
        this.mergeMsgBuffer &amp;&amp; writeFile(this.mergeMsgFilename, this.mergeMsgBuffer),
      ])
      debugLog(&#039;Done restoring merge state!&#039;)
    } catch (error) {
      debugLog(&#039;Failed restoring merge state with error:&#039;)
      debugLog(error)
      handleError(
        new Error(&#039;Merge state could not be restored due to an error!&#039;),
        ctx,
        RestoreMergeStatusError
      )
    }
  }

  /**
   * Get a list of all files with both staged and unstaged modifications.
   * Renames have special treatment, since the single status line includes
   * both the &quot;from&quot; and &quot;to&quot; filenames, where &quot;from&quot; is no longer on disk.
   */
  async getPartiallyStagedFiles() {
    debugLog(&#039;Getting partially staged files...&#039;)
    const status = await this.execGit([&#039;status&#039;, &#039;-z&#039;])
    /**
     * See https://git-scm.com/docs/git-status#_short_format
     * Entries returned in machine format are separated by a NUL character.
     * The first letter of each entry represents current index status,
     * and second the working tree. Index and working tree status codes are
     * separated from the file name by a space. If an entry includes a
     * renamed file, the file names are separated by a NUL character
     * (e.g. `to`\0`from`)
     */
    const partiallyStaged = status
      // eslint-disable-next-line no-control-regex
      .split(/\x00(?=[ AMDRCU?!]{2} |$)/)
      .filter((line) =&gt; {
        const [index, workingTree] = line
        return index !== &#039; &#039; &amp;&amp; workingTree !== &#039; &#039; &amp;&amp; index !== &#039;?&#039; &amp;&amp; workingTree !== &#039;?&#039;
      })
      .map((line) =&gt; line.substr(3)) // Remove first three letters (index, workingTree, and a whitespace)
      .filter(Boolean) // Filter empty string
    debugLog(&#039;Found partially staged files:&#039;, partiallyStaged)
    return partiallyStaged.length ? partiallyStaged : null
  }

  /**
   * Create a diff of partially staged files and backup stash if enabled.
   */
  async prepare(ctx, task) {
    try {
      debugLog(task.title)

      // Get a list of files with bot staged and unstaged changes.
      // Unstaged changes to these files should be hidden before the tasks run.
      this.partiallyStagedFiles = await this.getPartiallyStagedFiles()

      if (this.partiallyStagedFiles) {
        ctx.hasPartiallyStagedFiles = true
        const unstagedPatch = this.getHiddenFilepath(PATCH_UNSTAGED)
        const files = processRenames(this.partiallyStagedFiles)
        await this.execGit([&#039;diff&#039;, ...GIT_DIFF_ARGS, &#039;--output&#039;, unstagedPatch, &#039;--&#039;, ...files])
      } else {
        ctx.hasPartiallyStagedFiles = false
      }

      /**
       * If backup stash should be skipped, no need to continue
       */
      if (!ctx.shouldBackup) return

      // When backup is enabled, the revert will clear ongoing merge status.
      await this.backupMergeStatus()

      // Get a list of unstaged deleted files, because certain bugs might cause them to reappear:
      // - in git versions =&lt; 2.13.0 the `git stash --keep-index` option resurrects deleted files
      // - git stash can&#039;t infer RD or MD states correctly, and will lose the deletion
      this.deletedFiles = await this.getDeletedFiles()

      // Save stash of all staged files.
      // The `stash create` command creates a dangling commit without removing any files,
      // and `stash store` saves it as an actual stash.
      const stashHash = await this.execGit([&#039;stash&#039;, &#039;create&#039;])
      ctx.backupHash = await this.execGit([&#039;rev-parse&#039;, &#039;--short&#039;, stashHash])
      await this.execGit([
        &#039;stash&#039;,
        &#039;store&#039;,
        &#039;--quiet&#039;,
        &#039;--message&#039;,
        `${STASH} (${ctx.backupHash})`,
        ctx.backupHash,
      ])

      task.title = `Backed up original state in git stash (${ctx.backupHash})`
      debugLog(task.title)
    } catch (error) {
      handleError(error, ctx)
    }
  }

  /**
   * Remove unstaged changes to all partially staged files, to avoid tasks from seeing them
   */
  async hideUnstagedChanges(ctx) {
    try {
      const files = processRenames(this.partiallyStagedFiles, false)
      await this.execGit([&#039;checkout&#039;, &#039;--force&#039;, &#039;--&#039;, ...files])
    } catch (error) {
      /**
       * `git checkout --force` doesn&#039;t throw errors, so it shouldn&#039;t be possible to get here.
       * If this does fail, the handleError method will set ctx.gitError and lint-staged will fail.
       */
      handleError(error, ctx, HideUnstagedChangesError)
    }
  }

  /**
   * Applies back task modifications, and unstaged changes hidden in the stash.
   * In case of a merge-conflict retry with 3-way merge.
   */
  async applyModifications(ctx) {
    debugLog(&#039;Adding task modifications to index...&#039;)

    // `matchedFileChunks` includes staged files that lint-staged originally detected and matched against a task.
    // Add only these files so any 3rd-party edits to other files won&#039;t be included in the commit.
    // These additions per chunk are run &quot;serially&quot; to prevent race conditions.
    // Git add creates a lockfile in the repo causing concurrent operations to fail.
    for (const files of this.matchedFileChunks) {
      await this.execGit([&#039;add&#039;, &#039;--&#039;, ...files])
    }

    debugLog(&#039;Done adding task modifications to index!&#039;)

    const stagedFilesAfterAdd = await this.execGit([
      ...getDiffCommand(this.diff, this.diffFilter),
      &#039;--name-only&#039;,
      &#039;-z&#039;,
    ])

    if (!stagedFilesAfterAdd &amp;&amp; !this.allowEmpty) {
      // Tasks reverted all staged changes and the commit would be empty
      // Throw error to stop commit unless `--allow-empty` was used
      handleError(new Error(&#039;Prevented an empty git commit!&#039;), ctx, ApplyEmptyCommitError)
    }
  }

  /**
   * Restore unstaged changes to partially changed files. If it at first fails,
   * this is probably because of conflicts between new task modifications.
   * 3-way merge usually fixes this, and in case it doesn&#039;t we should just give up and throw.
   */
  async restoreUnstagedChanges(ctx) {
    debugLog(&#039;Restoring unstaged changes...&#039;)
    const unstagedPatch = this.getHiddenFilepath(PATCH_UNSTAGED)
    try {
      await this.execGit([&#039;apply&#039;, ...GIT_APPLY_ARGS, unstagedPatch])
    } catch (applyError) {
      debugLog(&#039;Error while restoring changes:&#039;)
      debugLog(applyError)
      debugLog(&#039;Retrying with 3-way merge&#039;)
      try {
        // Retry with a 3-way merge if normal apply fails
        await this.execGit([&#039;apply&#039;, ...GIT_APPLY_ARGS, &#039;--3way&#039;, unstagedPatch])
      } catch (threeWayApplyError) {
        debugLog(&#039;Error while restoring unstaged changes using 3-way merge:&#039;)
        debugLog(threeWayApplyError)
        handleError(
          new Error(&#039;Unstaged changes could not be restored due to a merge conflict!&#039;),
          ctx,
          RestoreUnstagedChangesError
        )
      }
    }
  }

  /**
   * Restore original HEAD state in case of errors
   */
  async restoreOriginalState(ctx) {
    try {
      debugLog(&#039;Restoring original state...&#039;)
      await this.execGit([&#039;reset&#039;, &#039;--hard&#039;, &#039;HEAD&#039;])
      await this.execGit([&#039;stash&#039;, &#039;apply&#039;, &#039;--quiet&#039;, &#039;--index&#039;, await this.getBackupStash(ctx)])

      // Restore meta information about ongoing git merge
      await this.restoreMergeStatus(ctx)

      // If stashing resurrected deleted files, clean them out
      await Promise.all(this.deletedFiles.map((file) =&gt; unlink(file)))

      // Clean out patch
      await unlink(this.getHiddenFilepath(PATCH_UNSTAGED))

      debugLog(&#039;Done restoring original state!&#039;)
    } catch (error) {
      handleError(error, ctx, RestoreOriginalStateError)
    }
  }

  /**
   * Drop the created stashes after everything has run
   */
  async cleanup(ctx) {
    try {
      debugLog(&#039;Dropping backup stash...&#039;)
      await this.execGit([&#039;stash&#039;, &#039;drop&#039;, &#039;--quiet&#039;, await this.getBackupStash(ctx)])
      debugLog(&#039;Done dropping backup stash!&#039;)
    } catch (error) {
      handleError(error, ctx)
    }
  }
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
