<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nwsapi/src/nwsapi.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nwsapi/src/nwsapi.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2019</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">125.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">25.25</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Copyright (C) 2007-2025 Diego Perini
 * All rights reserved.
 *
 * nwsapi.js - Fast CSS Selectors API Engine
 *
 * Author: Diego Perini &lt;diego.perini at gmail com&gt;
 * Version: 2.2.22
 * Created: 20070722
 * Release: 20250901
 *
 * License:
 *  https://javascript.nwbox.com/nwsapi/MIT-LICENSE
 * Download:
 *  https://javascript.nwbox.com/nwsapi/nwsapi.js
 */

(function Export(global, factory) {

  &#039;use strict&#039;;

  if (typeof module == &#039;object&#039; &amp;&amp; typeof exports == &#039;object&#039;) {
    module.exports = factory;
  } else if (typeof define == &#039;function&#039; &amp;&amp; define[&#039;amd&#039;]) {
    define(factory);
  } else {
    global.NW || (global.NW = { });
    global.NW.Dom = factory(global, Export);
  }

})(this, function Factory(global, Export) {

  var version = &#039;nwsapi-2.2.22&#039;,

  doc = global.document,
  root = doc.documentElement,
  slice = Array.prototype.slice,

  HSP = &#039;[\\x20\\t]&#039;,
  VSP = &#039;[\\r\\n\\f]&#039;,
  WSP = &#039;[\\x20\\t\\r\\n\\f]&#039;,

  CFG = {
    // extensions
    operators: &#039;[~*^$|]=|=&#039;,
    combinators: &#039;[\\x20\\t&gt;+~](?=[^&gt;+~])&#039;
  },

  HAS = {
    nestedself: &#039;:has\\x28(?::has\\x28|.*)\\x29)\\x29&#039;,
  },

  NOT = {
    // not enclosed in double/single/parens/square
    double_enc: &#039;(?=(?:[^&quot;]*[&quot;][^&quot;]*[&quot;])*[^&quot;]*$)&#039;,
    single_enc: &quot;(?=(?:[^&#039;]*[&#039;][^&#039;]*[&#039;])*[^&#039;]*$)&quot;,
    parens_enc: &#039;(?![^\\x28]*\\x29)&#039;,
    square_enc: &#039;(?![^\\x5b]*\\x5d)&#039;
  },

  REX = {
    // regular expressions
    HasEscapes: RegExp(&#039;\\\\&#039;),
    HexNumbers: RegExp(&#039;^[0-9a-fA-F]&#039;),
    EscOrQuote: RegExp(&#039;^\\\\|[\\x22\\x27]&#039;),
    RegExpChar: RegExp(&#039;(?!\\\\)[\\\\^$.,*+?()[\\]{}|\\/]&#039;, &#039;g&#039;),
    TrimSpaces: RegExp(&#039;^&#039; + WSP + &#039;+|&#039; + WSP + &#039;+$|&#039; + VSP, &#039;g&#039;),
    SplitGroup: RegExp(&#039;(\\([^)]*\\)|\\[[^[]*\\]|\\\\.|[^,])+&#039;, &#039;g&#039;),
    CommaGroup: RegExp(&#039;(\\s*,\\s*)&#039; + NOT.square_enc + NOT.parens_enc, &#039;g&#039;),
    FixEscapes: RegExp(&#039;\\\\([0-9a-fA-F]{1,6}&#039; + WSP + &#039;?|.)|([\\x22\\x27])&#039;, &#039;g&#039;),
    CombineWSP: RegExp(&#039;[\\n\\r\\f\\x20]+&#039; + NOT.single_enc + NOT.double_enc, &#039;g&#039;),
    TabCharWSP: RegExp(&#039;(\\x20?\\t+\\x20?)&#039; + NOT.single_enc + NOT.double_enc, &#039;g&#039;),
    PseudosWSP: RegExp(&#039;\\s+([-+])\\s+&#039; + NOT.square_enc, &#039;g&#039;)
  },

  STD = {
    combinator: RegExp(&#039;\\s?([&gt;+~])\\s?&#039;, &#039;g&#039;),
    apimethods: RegExp(&#039;^(?:\\w+|\\*)\\|&#039;),
    namespaces: RegExp(&#039;(\\*|\\w+)\\|[\\w-]+&#039;)
  },

  GROUPS = {
    // pseudo-classes requiring parameters
    linguistic: &#039;(dir|lang)(?:\\x28\\s?([-\\w]{2,})\\s?\\x29)&#039;,
    logicalsel: &#039;(is|where|matches|not|has)(?:\\x28\\s?(&#039; + &#039;[^()]*|.*&#039; + &#039;)\\s?\\x29)&#039;,
    treestruct: &#039;(nth(?:-last)?(?:-child|-of\\-type))(?:\\x28\\s?(even|odd|(?:[-+]?\\d*)(?:n\\s?[-+]?\\s?\\d*)?)\\s?\\x29)&#039;,
    // pseudo-classes not requiring parameters
    locationpc: &#039;(any\\-link|link|visited|target|defined)\\b&#039;,
    useraction: &#039;(hover|active|focus\\-within|focus\\-visible|focus)\\b&#039;,
    structural: &#039;(scope|root|empty|(?:(?:first|last|only)(?:-child|\\-of\\-type)))\\b&#039;,
    inputstate: &#039;(enabled|disabled|read\\-only|read\\-write|placeholder\\-shown|default)\\b&#039;,
    inputvalue: &#039;(checked|indeterminate|required|optional|valid|invalid|in\\-range|out\\-of\\-range)\\b&#039;,
    // pseudo-classes not requiring parameters and describing functional state
    rsrc_state: &#039;(playing|paused|seeking|buffering|stalled|muted|volume-locked)\\b&#039;,
    disp_state: &#039;(open|closed|modal|fullscreen|picture-in-picture)\\b&#039;,
    time_state: &#039;(current|past|future)\\b&#039;,
    // pseudo-classes for parsing only selectors
    pseudo_nop: &#039;(autofill|-webkit\\-autofill)\\b&#039;,
    // pseudo-elements starting with single colon (:)
    pseudo_sng: &#039;(after|before|first\\-letter|first\\-line)\\b&#039;,
    // pseudo-elements starting with double colon (::)
    pseudo_dbl: &#039;:(after|before|first\\-letter|first\\-line|selection|placeholder|-webkit-[-a-zA-Z0-9]{2,})\\b&#039;
  },

  Patterns = {
    // pseudo-classes
    treestruct: RegExp(&#039;^:(?:&#039; + GROUPS.treestruct + &#039;)(.*)&#039;, &#039;i&#039;),
    structural: RegExp(&#039;^:(?:&#039; + GROUPS.structural + &#039;)(.*)&#039;, &#039;i&#039;),
    linguistic: RegExp(&#039;^:(?:&#039; + GROUPS.linguistic + &#039;)(.*)&#039;, &#039;i&#039;),
    useraction: RegExp(&#039;^:(?:&#039; + GROUPS.useraction + &#039;)(.*)&#039;, &#039;i&#039;),
    inputstate: RegExp(&#039;^:(?:&#039; + GROUPS.inputstate + &#039;)(.*)&#039;, &#039;i&#039;),
    inputvalue: RegExp(&#039;^:(?:&#039; + GROUPS.inputvalue + &#039;)(.*)&#039;, &#039;i&#039;),
    rsrc_state: RegExp(&#039;^:(?:&#039; + GROUPS.rsrc_state + &#039;)(.*)&#039;, &#039;i&#039;),
    disp_state: RegExp(&#039;^:(?:&#039; + GROUPS.disp_state + &#039;)(.*)&#039;, &#039;i&#039;),
    time_state: RegExp(&#039;^:(?:&#039; + GROUPS.time_state + &#039;)(.*)&#039;, &#039;i&#039;),
    locationpc: RegExp(&#039;^:(?:&#039; + GROUPS.locationpc + &#039;)(.*)&#039;, &#039;i&#039;),
    logicalsel: RegExp(&#039;^:(?:&#039; + GROUPS.logicalsel + &#039;)(.*)&#039;, &#039;i&#039;),
    pseudo_nop: RegExp(&#039;^:(?:&#039; + GROUPS.pseudo_nop + &#039;)(.*)&#039;, &#039;i&#039;),
    pseudo_sng: RegExp(&#039;^:(?:&#039; + GROUPS.pseudo_sng + &#039;)(.*)&#039;, &#039;i&#039;),
    pseudo_dbl: RegExp(&#039;^:(?:&#039; + GROUPS.pseudo_dbl + &#039;)(.*)&#039;, &#039;i&#039;),
    // combinator symbols
    children: RegExp(&#039;^&#039; + WSP + &#039;?\\&gt;&#039; + WSP + &#039;?(.*)&#039;),
    adjacent: RegExp(&#039;^&#039; + WSP + &#039;?\\+&#039; + WSP + &#039;?(.*)&#039;),
    relative: RegExp(&#039;^&#039; + WSP + &#039;?\\~&#039; + WSP + &#039;?(.*)&#039;),
    ancestor: RegExp(&#039;^&#039; + WSP + &#039;+(.*)&#039;),
   // universal &amp; namespace
   universal: RegExp(&#039;^(\\*)(.*)&#039;),
   namespace: RegExp(&#039;^(\\*|[\\w-]+)?\\|(.*)&#039;)
  },

  // regexp to better aproximate detection of RTL languages (Arabic)
  RTL = RegExp(&#039;^(?:[\\u0627-\\u064a]|[\\u0591-\\u08ff]|[\\ufb1d-\\ufdfd]|[\\ufe70-\\ufefc])+$&#039;),

  // emulate firefox error strings
  qsNotArgs = &#039;Not enough arguments&#039;,
  qsInvalid = &#039; is not a valid selector&#039;,

  // detect structural pseudo-classes in selectors
  reNthElem = RegExp(&#039;(:nth(?:-last)?-child)&#039;, &#039;i&#039;),
  reNthType = RegExp(&#039;(:nth(?:-last)?-of-type)&#039;, &#039;i&#039;),

  // placeholder for global regexp
  reOptimizer,
  reValidator,

  // special handling configuration flags
  Config = {
    IDS_DUPES: true,
    FORGIVING: true,
    NODE_LIST: false,
    LOGERRORS: true,
    USR_EVENT: true,
    VERBOSITY: true
  },

  NAMESPACE,
  QUIRKS_MODE,
  HTML_DOCUMENT,

  ATTR_STD_OPS = {
    &#039;=&#039;: 1, &#039;^=&#039;: 1, &#039;$=&#039;: 1, &#039;|=&#039;: 1, &#039;*=&#039;: 1, &#039;~=&#039;: 1
  },

  HTML_TABLE = {
    &#039;accept&#039;: 1, &#039;accept-charset&#039;: 1, &#039;align&#039;: 1, &#039;alink&#039;: 1, &#039;axis&#039;: 1,
    &#039;bgcolor&#039;: 1, &#039;charset&#039;: 1, &#039;checked&#039;: 1, &#039;clear&#039;: 1, &#039;codetype&#039;: 1, &#039;color&#039;: 1,
    &#039;compact&#039;: 1, &#039;declare&#039;: 1, &#039;defer&#039;: 1, &#039;dir&#039;: 1, &#039;direction&#039;: 1, &#039;disabled&#039;: 1,
    &#039;enctype&#039;: 1, &#039;face&#039;: 1, &#039;frame&#039;: 1, &#039;hreflang&#039;: 1, &#039;http-equiv&#039;: 1, &#039;lang&#039;: 1,
    &#039;language&#039;: 1, &#039;link&#039;: 1, &#039;media&#039;: 1, &#039;method&#039;: 1, &#039;multiple&#039;: 1, &#039;nohref&#039;: 1,
    &#039;noresize&#039;: 1, &#039;noshade&#039;: 1, &#039;nowrap&#039;: 1, &#039;readonly&#039;: 1, &#039;rel&#039;: 1, &#039;rev&#039;: 1,
    &#039;rules&#039;: 1, &#039;scope&#039;: 1, &#039;scrolling&#039;: 1, &#039;selected&#039;: 1, &#039;shape&#039;: 1, &#039;target&#039;: 1,
    &#039;text&#039;: 1, &#039;type&#039;: 1, &#039;valign&#039;: 1, &#039;valuetype&#039;: 1, &#039;vlink&#039;: 1
  },

  Combinators = { },

  Selectors = { },

  Operators = {
     &#039;=&#039;: { p1: &#039;^&#039;,
            p2: &#039;$&#039;,
            p3: &#039;true&#039; },
    &#039;^=&#039;: { p1: &#039;^&#039;,
            p2: &#039;&#039;,
            p3: &#039;true&#039; },
    &#039;$=&#039;: { p1: &#039;&#039;,
            p2: &#039;$&#039;,
            p3: &#039;true&#039; },
    &#039;*=&#039;: { p1: &#039;&#039;,
            p2: &#039;&#039;,
            p3: &#039;true&#039; },
    &#039;|=&#039;: { p1: &#039;^&#039;,
            p2: &#039;(-|$)&#039;,
            p3: &#039;true&#039; },
    &#039;~=&#039;: { p1: &#039;(^|\\s)&#039;,
            p2: &#039;(\\s|$)&#039;,
            p3: &#039;true&#039; }
  },

  concatCall =
    function(nodes, callback) {
      var i = 0, l = nodes.length, list = Array(l);
      while (l &gt; i) {
        if (false === callback(list[i] = nodes[i])) break;
        ++i;
      }
      return list;
    },

  concatList =
    function(list, nodes) {
      var i = -1, l = nodes.length;
      while (l--) { list[list.length] = nodes[++i]; }
      return list;
    },

  // only define the toNodeList helper if explicitly enabled in Config,
  // a safety measure for headless hosts missing feature/implementation
  toNodeList =
    Config.NODE_LIST == false ?
    function(x) { return x; } :
    function() {
      // create a DocumentFragment
      var emptyNL = doc.createDocumentFragment().childNodes;

      // this is returned from a self-executing function so that
      // the DocumentFragment isn&#039;t repeatedly created
      return function(nodeArray) {
        // check if it is already a nodelist
        if (isInstanceOf(nodeArray)) return nodeArray;

        // if it&#039;s a single element, wrap it in a classic array
        if (!Array.isArray(nodeArray)) nodeArray = [nodeArray];

        // base an object on emptyNL
        var fakeNL = Object.create(emptyNL, {
          &#039;length&#039;: {
            value: nodeArray.length, enumerable: false
          },
          &#039;item&#039;: {
            &#039;value&#039;: function(i) {
              return this[+i || 0];
            },
            enumerable: false
          }
        });

        // copy the array elemnts
        nodeArray.forEach(function (v, i) { fakeNL[i] = v; });

        // return an object pretending to be a NodeList.
        return fakeNL;
      };
    }(),

  isInstanceOf =
    function(nodes) {
      return nodes instanceof global.NodeList;
    },

  documentOrder =
    function(a, b) {
      if (!hasDupes &amp;&amp; a === b) {
        hasDupes = true;
        return 0;
      }
      return a.compareDocumentPosition(b) &amp; 4 ? -1 : 1;
    },

  hasDupes = false,

  unique =
    function(nodes) {
      var i = 0, j = -1, l = nodes.length + 1, list = [ ];
      while (--l) {
        if (nodes[i++] === nodes[i]) continue;
        list[++j] = nodes[i - 1];
      }
      hasDupes = false;
      return list;
    },

  switchContext =
    function(context, force) {
      var oldDoc = doc;
      doc = context.ownerDocument || context;
      if (force || oldDoc !== doc) {
        // force a new check for each document change
        // performed before the next select operation
        root = doc.documentElement;
        HTML_DOCUMENT = isHTML(doc);
        QUIRKS_MODE = HTML_DOCUMENT &amp;&amp;
          doc.compatMode.indexOf(&#039;CSS&#039;) &lt; 0;
        NAMESPACE = root &amp;&amp; root.namespaceURI;
        Snapshot.doc = doc;
        Snapshot.root = root;
      }
      return (Snapshot.from = context);
    },

  // convert single codepoint to UTF-16 encoding
  codePointToUTF16 =
    function(codePoint) {
      // out of range, use replacement character
      if (codePoint &lt; 1 || codePoint &gt; 0x10ffff ||
        (codePoint &gt; 0xd7ff &amp;&amp; codePoint &lt; 0xe000)) {
        return &#039;\\ufffd&#039;;
      }
      // javascript strings are UTF-16 encoded
      if (codePoint &lt; 0x10000) {
        var lowHex = &#039;000&#039; + codePoint.toString(16);
        return &#039;\\u&#039; + lowHex.substr(lowHex.length - 4);
      }
      // supplementary high + low surrogates
      return &#039;\\u&#039; + (((codePoint - 0x10000) &gt;&gt; 0x0a) + 0xd800).toString(16) +
             &#039;\\u&#039; + (((codePoint - 0x10000) % 0x400) + 0xdc00).toString(16);
    },

  // convert single codepoint to string
  stringFromCodePoint =
    function(codePoint) {
      // out of range, use replacement character
      if (codePoint &lt; 1 || codePoint &gt; 0x10ffff ||
        (codePoint &gt; 0xd7ff &amp;&amp; codePoint &lt; 0xe000)) {
        return &#039;\ufffd&#039;;
      }
      if (codePoint &lt; 0x10000) {
        return String.fromCharCode(codePoint);
      }
      return String.fromCodePoint ?
        String.fromCodePoint(codePoint) :
        String.fromCharCode(
          ((codePoint - 0x10000) &gt;&gt; 0x0a) + 0xd800,
          ((codePoint - 0x10000) % 0x400) + 0xdc00);
    },

  // convert escape sequence in a CSS string or identifier
  // to javascript string with javascript escape sequences
  convertEscapes =
    function(str) {
      return REX.HasEscapes.test(str) ?
        str.replace(REX.FixEscapes,
          function(substring, p1, p2) {
            // unescaped &quot; or &#039;
            return p2 ? &#039;\\&#039; + p2 :
              // javascript strings are UTF-16 encoded
              REX.HexNumbers.test(p1) ? codePointToUTF16(parseInt(p1, 16)) :
              // \&#039; \&quot;
              REX.EscOrQuote.test(p1) ? substring :
              // \g \h \. \# etc
              p1;
          }
        ) : str;
    },

  // convert escape sequence in a CSS string or identifier
  // to javascript string with characters representations
  unescapeIdentifier =
    function(str) {
      return REX.HasEscapes.test(str) ?
        str.replace(REX.FixEscapes,
          function(substring, p1, p2) {
            // unescaped &quot; or &#039;
            return p2 ? p2 :
              // javascript strings are UTF-16 encoded
              REX.HexNumbers.test(p1) ? stringFromCodePoint(parseInt(p1, 16)) :
              // \&#039; \&quot;
              REX.EscOrQuote.test(p1) ? substring :
              // \g \h \. \# etc
              p1;
          }
        ) : str;
    },

  method = {
    &#039;#&#039;: &#039;getElementById&#039;,
    &#039;*&#039;: &#039;getElementsByTagName&#039;,
    &#039;|&#039;: &#039;getElementsByTagNameNS&#039;,
    &#039;.&#039;: &#039;getElementsByClassName&#039;
    },

  compat = {
    &#039;#&#039;: (c, n) =&gt; (e, f) =&gt; byId(n, c),
    &#039;*&#039;: (c, n) =&gt; (e, f) =&gt; byTag(n, c),
    &#039;|&#039;: (c, n) =&gt; (e, f) =&gt; byTagNS(n, c),
    &#039;.&#039;: (c, n) =&gt; (e, f) =&gt; byClass(n, c),
    },

  // find duplicate ids using iterative walk
  byIdRaw =
    function(id, context) {
      var node = context, nodes = [ ], next = node.firstElementChild;
      while ((node = next)) {
        node.id == id &amp;&amp; (nodes[nodes.length] = node);
        if ((next = node.firstElementChild || node.nextElementSibling)) continue;
        while (!next &amp;&amp; (node = node.parentElement) &amp;&amp; node !== context) {
          next = node.nextElementSibling;
        }
      }
      return nodes;
    },

  // context agnostic getElementById
  byId =
    function(id, context) {
      var e, i, l, nodes, api = method[&#039;#&#039;];

      // duplicates id allowed
      if (Config.IDS_DUPES === false) {
        if (api in context) {
          return (e = context[api](id)) ? [ e ] : none;
        }
      } else {
        if (&#039;all&#039; in context) {
          if ((e = context.all[id])) {
            if (e.nodeType == 1) return e.getAttribute(&#039;id&#039;) != id ? [ ] : [ e ];
            else if (id == &#039;length&#039;) return (e = context[api](id)) ? [ e ] : none;
            for (i = 0, l = e.length, nodes = [ ]; l &gt; i; ++i) {
              if (e[i].id == id) nodes[nodes.length] = e[i];
            }
            return nodes &amp;&amp; nodes.length ? nodes : [ nodes ];
          } else return none;
        }
      }

      return byIdRaw(id, context);
    },

  // wrapped up namespaced TagName api calls
  byTagNS =
    function(context, tag) {
      return byTag(tag, context);
  },

  // context agnostic getElementsByTagName
  byTag =
    function(tag, context) {
      var e, nodes, api = method[&#039;*&#039;];
      // DOCUMENT_NODE (9) &amp; ELEMENT_NODE (1)
      if (api in context) {
        return slice.call(context[api](tag));
      } else {
        tag = tag.toLowerCase();
        // DOCUMENT_FRAGMENT_NODE (11)
        if ((e = context.firstElementChild)) {
          if (!(e.nextElementSibling || tag == &#039;*&#039; || e.localName == tag)) {
            return slice.call(e[api](tag));
          } else {
            nodes = [ ];
            do {
              if (tag == &#039;*&#039; || e.localName == tag) nodes[nodes.length] = e;
              concatList(nodes, e[api](tag));
            } while ((e = e.nextElementSibling));
          }
        } else nodes = none;
      }
      return !Config.NODE_LIST ?
        nodes : isInstanceOf(nodes) ?
        nodes : toNodeList(nodes);
    },

  // context agnostic getElementsByClassName
  byClass =
    function(cls, context) {
      var e, nodes, api = method[&#039;.&#039;], reCls;
      // DOCUMENT_NODE (9) &amp; ELEMENT_NODE (1)
      if (api in context) {
        return slice.call(context[api](cls));
      } else {
        // DOCUMENT_FRAGMENT_NODE (11)
        if ((e = context.firstElementChild)) {
          reCls = RegExp(&#039;(^|\\s)&#039; + cls + &#039;(\\s|$)&#039;, QUIRKS_MODE ? &#039;i&#039; : &#039;&#039;);
          if (!(e.nextElementSibling || reCls.test(e.className))) {
            return slice.call(e[api](cls));
          } else {
            nodes = [ ];
            do {
              if (reCls.test(e.className)) nodes[nodes.length] = e;
              concatList(nodes, e[api](cls));
            } while ((e = e.nextElementSibling));
          }
        } else nodes = none;
      }
      return !Config.NODE_LIST ?
        nodes : isInstanceof(nodes) ?
        nodes : toNodeList(nodes);
    },

  // namespace aware hasAttribute
  // helper for XML/XHTML documents
  hasAttributeNS =
    function(e, name) {
      var i, l, attr = e.getAttributeNames();
      name = RegExp(&#039;:?&#039; + name + &#039;$&#039;, HTML_DOCUMENT ? &#039;i&#039; : &#039;&#039;);
      for (i = 0, l = attr.length; l &gt; i; ++i) {
        if (name.test(attr[i])) return true;
      }
      return false;
    },

  // fast resolver for the :nth-child() and :nth-last-child() pseudo-classes
  nthElement = (function() {
    var idx = 0, len = 0, set = 0, parent = undefined, parents = Array(), nodes = Array();
    return function(element, dir) {
      // ensure caches are emptied after each run, invoking with dir = 2
      if (dir == 2) {
        idx = 0; len = 0; set = 0; nodes.length = 0;
        parents.length = 0; parent = undefined;
        return -1;
      }
      var e, i, j, k, l;
      if (parent === element.parentElement) {
        i = set; j = idx; l = len;
      } else {
        l = parents.length;
        parent = element.parentElement;
        for (i = -1, j = 0, k = l - 1; l &gt; j; ++j, --k) {
          if (parents[j] === parent) { i = j; break; }
          if (parents[k] === parent) { i = k; break; }
        }
        if (i &lt; 0) {
          parents[i = l] = parent;
          l = 0; nodes[i] = Array();
          e = parent &amp;&amp; parent.firstElementChild || element;
          while (e) { nodes[i][l] = e; if (e === element) j = l; e = e.nextElementSibling; ++l; }
          set = i; idx = 0; len = l;
          if (l &lt; 2) return l;
        } else {
          l = nodes[i].length;
          set = i;
        }
      }
      if (element !== nodes[i][j] &amp;&amp; element !== nodes[i][j = 0]) {
        for (j = 0, e = nodes[i], k = l - 1; l &gt; j; ++j, --k) {
          if (e[j] === element) { break; }
          if (e[k] === element) { j = k; break; }
        }
      }
      idx = j + 1; len = l;
      return dir ? l - j : idx;
    };
  })(),

  // fast resolver for the :nth-of-type() and :nth-last-of-type() pseudo-classes
  nthOfType = (function() {
    var idx = 0, len = 0, set = 0, parent = undefined, parents = Array(), nodes = Array();
    return function(element, dir) {
      // ensure caches are emptied after each run, invoking with dir = 2
      if (dir == 2) {
        idx = 0; len = 0; set = 0; nodes.length = 0;
        parents.length = 0; parent = undefined;
        return -1;
      }
      var e, i, j, k, l, name = element.localName;
      if (nodes[set] &amp;&amp; nodes[set][name] &amp;&amp; parent === element.parentElement) {
        i = set; j = idx; l = len;
      } else {
        l = parents.length;
        parent = element.parentElement;
        for (i = -1, j = 0, k = l - 1; l &gt; j; ++j, --k) {
          if (parents[j] === parent) { i = j; break; }
          if (parents[k] === parent) { i = k; break; }
        }
        if (i &lt; 0 || !nodes[i][name]) {
          parents[i = l] = parent;
          nodes[i] || (nodes[i] = Object());
          l = 0; nodes[i][name] = Array();
          e = parent &amp;&amp; parent.firstElementChild || element;
          while (e) { if (e === element) j = l; if (e.localName == name) { nodes[i][name][l] = e; ++l; } e = e.nextElementSibling; }
          set = i; idx = j; len = l;
          if (l &lt; 2) return l;
        } else {
          l = nodes[i][name].length;
          set = i;
        }
      }
      if (element !== nodes[i][name][j] &amp;&amp; element !== nodes[i][name][j = 0]) {
        for (j = 0, e = nodes[i][name], k = l - 1; l &gt; j; ++j, --k) {
          if (e[j] === element) { break; }
          if (e[k] === element) { j = k; break; }
        }
      }
      idx = j + 1; len = l;
      return dir ? l - j : idx;
    };
  })(),

  // check if the document type is HTML
  isHTML =
    function(node) {
      var doc = node.ownerDocument || node;
      return doc.nodeType == 9 &amp;&amp;
        // contentType not in IE &lt;= 11
        &#039;contentType&#039; in doc ?
          doc.contentType.indexOf(&#039;/html&#039;) &gt; 0 :
          doc.createElement(&#039;DiV&#039;).localName == &#039;div&#039;;
    },

  // return node if node is focusable
  // or false if node isn&#039;t focusable
  isFocusable =
    function(node) {
      var doc = node.ownerDocument;
       if (node.contentDocument&amp;&amp;node.localName== &#039;iframe&#039;) { return false; }
       if (doc.hasFocus() &amp;&amp; node === doc.activeElement) {
        if (node.type || node.href || typeof node.tabIndex == &#039;number&#039;) {
          return node;
        }
      }
      return false;
    },

  // check if node content is editable
  isContentEditable =
    function(node) {
      var attrValue = &#039;inherit&#039;;
      if (node.hasAttribute(&#039;contenteditable&#039;)) {
        attrValue = node.getAttribute(&#039;contenteditable&#039;);
      }
      switch (attrValue) {
        case &#039;&#039;:
        case &#039;plaintext-only&#039;:
        case &#039;true&#039;:
          return true;
        case &#039;false&#039;:
          return false;
        default:
          if (node.parentNode &amp;&amp; node.parentNode.nodeType === 1) {
            return isContentEditable(node.parentNode);
          }
          return false;
      }
    },

  // check media resources is playing
  isPlaying =
    function(media) {
      // for &lt;audio&gt;, &lt;video&gt;, &lt;source&gt; and &lt;track&gt; elements
      var parent = media instanceof HTMLMediaElement ? null : media.parentElement;
      return (
        !!( media &amp;&amp;  media.currentTime &gt; 0 &amp;&amp;  !media.paused &amp;&amp;  !media.ended &amp;&amp;  media.readyState &gt; 2) ||
        !!(parent &amp;&amp; parent.currentTime &gt; 0 &amp;&amp; !parent.paused &amp;&amp; !parent.ended &amp;&amp; parent.readyState &gt; 2));
    },

  // configure the engine to use special handling
  configure =
    function(option, clear) {
      if (typeof option == &#039;string&#039;) { return !!Config[option]; }
      if (typeof option != &#039;object&#039;) { return Config; }
      for (var i in option) {
        Config[i] = !!option[i];
      }
      // clear lambda cache
      if (clear) {
        matchResolvers = { };
        selectResolvers = { };
      }
      setIdentifierSyntax();
      return true;
    },

  // centralized error and exceptions handling
  emit =
    function(message, proto) {
      var err;
      if (Config.VERBOSITY) {
        if (proto) {
          err = new proto(message);
        } else {
          err = new global.DOMException(message, &#039;SyntaxError&#039;);
        }
        throw err;
      }
      if (Config.LOGERRORS &amp;&amp; console &amp;&amp; console.log) {
        console.log(message);
      }
    },

  // execute the engine initialization code
  initialize =
    function(doc) {
      setIdentifierSyntax();
      lastContext = switchContext(doc, true);
    },

  // build validation regexps used by the engine
  setIdentifierSyntax =
    function() {

      //
      // NOTE: SPECIAL CASES IN CSS SYNTAX PARSING RULES
      //
      // The &lt;EOF-token&gt; https://drafts.csswg.org/css-syntax/#typedef-eof-token
      // allow mangled|unclosed selector syntax at the end of selectors strings
      //
      // Literal equivalent hex representations of the characters: &quot; &#039; ` ] )
      //
      //     \\x22 = &quot; - double quotes    \\x5b = [ - open square bracket
      //     \\x27 = &#039; - single quote     \\x5d = ] - closed square bracket
      //     \\x60 = ` - back tick        \\x28 = ( - open round parens
      //     \\x5c = \ - back slash       \\x29 = ) - closed round parens
      //
      // using hex format prevents false matches of opened/closed instances
      // pairs, coloring breakage and other editors highlightning problems.
      //

      var

      // non-ascii chars
      noascii = &#039;[^\\x00-\\x9f]&#039;,
      // escaped chars
      escaped = &#039;\\\\[^\\r\\n\\f0-9a-fA-F]&#039;,
      // unicode chars
      unicode = &#039;\\\\[0-9a-fA-F]{1,6}(?:\\r\\n|\\s)?&#039;,

      // can start with single/double dash
      // but it can not start with a digit
      identifier = &#039;-?(?:[a-zA-Z_-]|&#039; + noascii + &#039;|&#039; + escaped + &#039;|&#039; + unicode + &#039;)&#039; +
          &#039;(?:-{2}|[0-9]|[a-zA-Z_-]|&#039; + noascii + &#039;|&#039; + escaped + &#039;|&#039; + unicode + &#039;)*&#039;,

      pseudonames = &#039;[-\\w]+&#039;,
      pseudoparms = &#039;(?:[-+]?\\d*)(?:n\\s?[-+]?\\s?\\d*)&#039;,
      doublequote = &#039;&quot;[^&quot;\\\\]*(?:\\\\.[^&quot;\\\\]*)*(?:&quot;|$)&#039;,
      singlequote = &quot;&#039;[^&#039;\\\\]*(?:\\\\.[^&#039;\\\\]*)*(?:&#039;|$)&quot;,

      attrparser = identifier + &#039;|&#039; + doublequote + &#039;|&#039; + singlequote,

      attrvalues = &#039;([\\x22\\x27]?)((?!\\3)*|(?:\\\\?.)*?)(?:\\3|$)&#039;,

      attributes =
        &#039;\\[&#039; +
          // attribute presence
          &#039;(?:\\*\\|)?&#039; +
          WSP + &#039;?&#039; +
          &#039;(&#039; + identifier + &#039;(?::&#039; + identifier + &#039;)?)&#039; +
          WSP + &#039;?&#039; +
          &#039;(?:&#039; +
            &#039;(&#039; + CFG.operators + &#039;)&#039; + WSP + &#039;?&#039; +
            &#039;(?:&#039; + attrparser + &#039;)&#039; +
          &#039;)?&#039; +
          // attribute case sensitivity
          &#039;(?:&#039; + WSP + &#039;?\\b(i))?&#039; + WSP + &#039;?&#039; +
        &#039;(?:\\]|$)&#039;,

      attrmatcher = attributes.replace(attrparser, attrvalues),

      pseudoclass =
        &#039;(?:\\x28&#039; + WSP + &#039;*&#039; +
          &#039;(?:&#039; + pseudoparms + &#039;?)?|&#039; +
          // universal * &amp;
          // namespace *|*
          &#039;(?:\\*|\\*\\|)|&#039; +
          &#039;(?:&#039; +
            &#039;(?::&#039; + pseudonames +
              &#039;(?:\\x28&#039; + pseudoparms + &#039;?(?:\\x29|$))?|&#039; +
            &#039;)|&#039; +
            &#039;(?:[.#]?&#039; + identifier + &#039;)|&#039; +
            &#039;(?:&#039; + attributes + &#039;)&#039; +
          &#039;)+|&#039; +
          &#039;(?:&#039; + WSP + &#039;?[&gt;+~][^&gt;+~]&#039; + WSP + &#039;?)|&#039; +
          &#039;(?:&#039; + WSP + &#039;?,&#039; + WSP + &#039;?)|&#039; +
          &#039;(?:&#039; + WSP + &#039;?)|&#039; +
          &#039;(?:\\x29|$)&#039; +
        &#039;)*&#039;,

      standardValidator =
        &#039;(?=&#039; + WSP + &#039;?[^&gt;+~(){}&lt;&gt;])&#039; +
        &#039;(?:&#039; +
          // universal * &amp;
          // namespace *|*
          &#039;(?:\\*|\\*\\|)|&#039; +
          &#039;(?:[.#]?&#039; + identifier + &#039;)+|&#039; +
          &#039;(?:&#039; + attributes + &#039;)+|&#039; +
          &#039;(?:::?&#039; + pseudonames + pseudoclass + &#039;)|&#039; +
          &#039;(?:&#039; + WSP + &#039;?&#039; + CFG.combinators + WSP + &#039;?)|&#039; +
          &#039;(?:&#039; + WSP + &#039;?,&#039; + WSP + &#039;?)|&#039; +
          &#039;(?:&#039; + WSP + &#039;?)&#039; +
        &#039;)+&#039;;

      // the following global RE is used to return the
      // deepest localName in selector strings and then
      // use it to retrieve all possible matching nodes
      // that will be filtered by compiled resolvers
      reOptimizer = RegExp(
        &#039;(?:([.:#*]?)&#039; +
        &#039;(&#039; + identifier + &#039;)&#039; +
        &#039;(?:&#039; +
          &#039;:[-\\w]+|&#039; +
          &#039;\\[[^\\]]+(?:\\]|$)|&#039; +
          &#039;\\x28[^\\x29]+(?:\\x29|$)&#039; +
        &#039;)*)$&#039;);

      // global
      reValidator = RegExp(standardValidator, &#039;g&#039;);

      Patterns.id = RegExp(&#039;^#(&#039; + identifier + &#039;)(.*)&#039;);
      Patterns.tagName = RegExp(&#039;^(&#039; + identifier + &#039;)(.*)&#039;);
      Patterns.className = RegExp(&#039;^\\.(&#039; + identifier + &#039;)(.*)&#039;);
      Patterns.attribute = RegExp(&#039;^(?:&#039; + attrmatcher + &#039;)(.*)&#039;);
    },

  F_INIT = &#039;&quot;use strict&quot;;return function Resolver(c,f,x,r)&#039;,

  /*
  // S - M - N
  //
  // SELECT
  // MATCH
  // NONE
  //
  */

  S_HEAD = &#039;var e,n,o,j=r.length-1,k=-1&#039;,
  M_HEAD = &#039;var e,n,o&#039;,
  N_HEAD = &#039;var e,n,o&#039;,

  S_LOOP = &#039;main:while((e=c[++k]))&#039;,
  M_LOOP = &#039;e=c;&#039;,
  N_LOOP = &#039;main:while((e=c.item(++k)))&#039;,

  S_BODY = &#039;r[++j]=c[k];&#039;,
  M_BODY = &#039;&#039;,
  N_BODY = &#039;r[++j]=c.item(k);&#039;,

  S_TAIL = &#039;continue main;&#039;,
  M_TAIL = &#039;r=true;&#039;,
  N_TAIL = &#039;r=true;&#039;,

  S_TEST = &#039;if(f(c[k])){break main;}&#039;,
  M_TEST = &#039;f(c);&#039;,
  N_TEST = &#039;if(f(c.item(k))){break main;}&#039;,

  S_VARS = [ ],
  M_VARS = [ ],
  N_VARS = [ ],

  // compile groups or single selector strings into
  // executable functions for matching or selecting

  S_TEST = &#039;if(f(c[k])){break main;}&#039;,
  M_TEST = &#039;f(c);&#039;,
  N_TEST = &#039;if(f(c.item(k))){break main;}&#039;,

  S_VARS = [ ],
  M_VARS = [ ],
  N_VARS = [ ],

  // compile groups or single selector strings into
  // executable functions for matching or selecting
  compile =
    function(selector, mode, callback) {
      var factory, token, head = &#039;&#039;, loop = &#039;&#039;, macro = &#039;&#039;, source = &#039;&#039;, vars = &#039;&#039;;

      // &#039;mode&#039; can be boolean or null
      // true = select / false = match
      // null to use collection.item()
      switch (mode) {
        case true:
          if (selectLambdas[selector]) { return selectLambdas[selector]; }
          macro = S_BODY + (callback ? S_TEST : &#039;&#039;) + S_TAIL;
          head = S_HEAD;
          loop = S_LOOP;
          break;
        case false:
          if (matchLambdas[selector]) { return matchLambdas[selector]; }
          macro = M_BODY + (callback ? M_TEST : &#039;&#039;) + M_TAIL;
          head = M_HEAD;
          loop = M_LOOP;
          break;
        case null:
          if (selectLambdas[selector]) { return selectLambdas[selector]; }
          macro = N_BODY + (callback ? N_TEST : &#039;&#039;) + N_TAIL;
          head = N_HEAD;
          loop = N_LOOP;
          break;
        default:
          break;
      }

      source = compileSelector(selector, macro, mode, callback);

      loop += mode || mode === null ? &#039;{&#039; + source + &#039;}&#039; : source;

      if (mode || mode === null &amp;&amp; selector.includes(&#039;:nth&#039;)) {
        loop += reNthElem.test(selector) ? &#039;s.nthElement(null, 2);&#039; : &#039;&#039;;
        loop += reNthType.test(selector) ? &#039;s.nthOfType(null, 2);&#039; : &#039;&#039;;
      }

      if (S_VARS[0] || M_VARS[0] || N_VARS[0]) {
        vars = &#039;,&#039; + (S_VARS.join(&#039;,&#039;) || M_VARS.join(&#039;,&#039;) || N_VARS[0]);
        S_VARS.length = 0;
        M_VARS.length = 0;
        N_VARS.length = 0;
      }

      factory = Function(&#039;s&#039;, F_INIT + &#039;{&#039; + head + vars + &#039;;&#039; + loop + &#039;return r;}&#039;)(Snapshot);

      return mode || mode === null ? (selectLambdas[selector] = factory) : (matchLambdas[selector] = factory);
    },

  // build conditional code to check components of selector strings
  compileSelector =
    function(expression, source, mode, callback) {

      var a, b, n, f, name, NS, referenceElement,
      compat, expr, match, result, status, symbol, test,
      type, selector = expression, vars;

      // isolate selector combinators
      selector = selector.replace(STD.combinator, &#039;$1&#039;);

      // javascript needs a label to break
      // out of the while loops processing
      selector_recursion_label:

      while (selector) {

        // get namespace prefix if present or get first char of selector
        symbol = STD.apimethods.test(selector) ? &#039;|&#039; : selector[0];

        switch (symbol) {

          // universal resolver
          case &#039;*&#039;:
            match = selector.match(Patterns.universal);
            break;

          // id resolver
          case &#039;#&#039;:
            match = selector.match(Patterns.id);
            source = &#039;if((/^&#039; + match[1] + &#039;$/.test(e.getAttribute(&quot;id&quot;)))){&#039; + source + &#039;}&#039;;
            break;

          // class name resolver
          case &#039;.&#039;:
            match = selector.match(Patterns.className);
            compat = (QUIRKS_MODE ? &#039;i&#039; : &#039;&#039;) + &#039;.test(e.getAttribute(&quot;class&quot;))&#039;;
            source = &#039;if((/(^|\\s)&#039; + match[1] + &#039;(\\s|$)/&#039; + compat + &#039;)){&#039; + source + &#039;}&#039;;
            break;

          // tag name resolver
          case (/[_a-z]/i.test(symbol) ? symbol : undefined):
            match = selector.match(Patterns.tagName);
            source = &#039;if((e.localName==&quot;&#039; + match[1] + &#039;&quot;)){&#039; + source + &#039;}&#039;;
            break;

          // namespace resolver
          case &#039;|&#039;:
            match = selector.match(Patterns.namespace);
            if (match[1] == &#039;*&#039;) {
              source = &#039;if(true){&#039; + source + &#039;}&#039;;
            } else if (!match[1]) {
              source = &#039;if((!e.namespaceURI)){&#039; + source + &#039;}&#039;;
            } else if (typeof match[1] == &#039;string&#039; &amp;&amp; root.prefix == match[1]) {
              source = &#039;if((e.namespaceURI==&quot;&#039; + NAMESPACE + &#039;&quot;)){&#039; + source + &#039;}&#039;;
            } else {
              emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
            }
            break;

          // attributes resolver
          case &#039;[&#039;:
            match = selector.match(Patterns.attribute);
            NS = match[0].match(STD.namespaces);
            name = match[1];
            expr = name.split(&#039;:&#039;);
            expr = expr.length == 2 ? expr[1] : expr[0];
            if (match[2] &amp;&amp; !(test = Operators[match[2]])) {
              emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
              return &#039;&#039;;
            }
            if (match[4] === &#039;&#039;) {
              test = match[2] == &#039;~=&#039; ?
                { p1: &#039;^\\s&#039;, p2: &#039;+$&#039;, p3: &#039;true&#039; } :
                  match[2] in ATTR_STD_OPS &amp;&amp; match[2] != &#039;~=&#039; ?
                { p1: &#039;^&#039;,    p2: &#039;$&#039;,  p3: &#039;true&#039; } : test;
            } else if (match[2] == &#039;~=&#039; &amp;&amp; match[4].includes(&#039; &#039;)) {
              // whitespace separated list but value contains space
              break;
            } else if (match[4]) {
              match[4] = convertEscapes(match[4]).replace(REX.RegExpChar, &#039;\\$&amp;&#039;);
            }
            type = match[5] == &#039;i&#039; || (HTML_DOCUMENT &amp;&amp; HTML_TABLE[expr.toLowerCase()]) ? &#039;i&#039; : &#039;&#039;;
            source = &#039;if((&#039; +
              (!match[2] ? (NS ? &#039;s.hasAttributeNS(e,&quot;&#039; + name + &#039;&quot;)&#039; : &#039;e.hasAttribute&amp;&amp;e.hasAttribute(&quot;&#039; + name + &#039;&quot;)&#039;) :
              !match[4] &amp;&amp; ATTR_STD_OPS[match[2]] &amp;&amp; match[2] != &#039;~=&#039; ? &#039;e.getAttribute&amp;&amp;e.getAttribute(&quot;&#039; + name + &#039;&quot;)==&quot;&quot;&#039; :
              &#039;(/&#039; + test.p1 + match[4] + test.p2 + &#039;/&#039; + type + &#039;).test(e.getAttribute&amp;&amp;e.getAttribute(&quot;&#039; + name + &#039;&quot;))==&#039; + test.p3) +
              &#039;)){&#039; + source + &#039;}&#039;;
            break;

          // *** General sibling combinator
          // E ~ F (F relative sibling of E)
          case &#039;~&#039;:
            match = selector.match(Patterns.relative);
            source = &#039;while(e&amp;&amp;(e=e.previousElementSibling)){&#039; + source + &#039;}&#039;;
            break;

          // *** Adjacent sibling combinator
          // E + F (F adiacent sibling of E)
          case &#039;+&#039;:
            match = selector.match(Patterns.adjacent);
            source = &#039;if(e&amp;&amp;(e=e.previousElementSibling)){&#039; + source + &#039;}&#039;;
            break;

          // *** Descendant combinator
          // E F (E ancestor of F)
          case &#039;\x09&#039;:
          case &#039;\x20&#039;:
            match = selector.match(Patterns.ancestor);
            source = &#039;while(e&amp;&amp;(e=e.parentElement)){&#039; + source + &#039;}&#039;;
            break;

          // *** Child combinator
          // E &gt; F (F children of E)
          case &#039;&gt;&#039;:
            match = selector.match(Patterns.children);
            source = &#039;if(e&amp;&amp;(e=e.parentElement)){&#039; + source + &#039;}&#039;;
            break;

          // *** user supplied combinators extensions
          case (symbol in Combinators ? symbol : undefined):
            // for other registered combinators extensions
            match[match.length - 1] = &#039;*&#039;;
            source = Combinators[symbol](match) + source;
            break;

          // *** tree-structural pseudo-classes
          // :root, :empty, :first-child, :last-child, :only-child, :first-of-type, :last-of-type, :only-of-type
          case &#039;:&#039;:
            if ((match = selector.match(Patterns.structural))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;scope&#039;:
                  // use the root (documentElement) when comparing against a document
                  source = &#039;if(e===(s.from.nodeType===9?s.root:s.from)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;root&#039;:
                  // there can only be one :root element, so exit the loop once found
                  source = &#039;if((e===s.root)){&#039; + source + (mode ? &#039;break main;&#039; : &#039;&#039;) + &#039;}&#039;;
                  break;
                case &#039;empty&#039;:
                  // matches elements that don&#039;t contain elements or text nodes
                  source = &#039;n=e.firstChild;while(n&amp;&amp;!(/1|3/).test(n.nodeType)){n=n.nextSibling}if(!n){&#039; + source + &#039;}&#039;;
                  break;

                // *** child-indexed pseudo-classes
                // :first-child, :last-child, :only-child
                case &#039;only-child&#039;:
                  source = &#039;if((!e.nextElementSibling&amp;&amp;!e.previousElementSibling)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;last-child&#039;:
                  source = &#039;if((!e.nextElementSibling)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;first-child&#039;:
                  source = &#039;if((!e.previousElementSibling)){&#039; + source + &#039;}&#039;;
                  break;

                // *** typed child-indexed pseudo-classes
                // :only-of-type, :last-of-type, :first-of-type
                case &#039;only-of-type&#039;:
                  source = &#039;o=e.localName;&#039; +
                    &#039;n=e;while((n=n.nextElementSibling)&amp;&amp;n.localName!=o);if(!n){&#039; +
                    &#039;n=e;while((n=n.previousElementSibling)&amp;&amp;n.localName!=o);}if(!n){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;last-of-type&#039;:
                  source = &#039;n=e;o=e.localName;while((n=n.nextElementSibling)&amp;&amp;n.localName!=o);if(!n){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;first-of-type&#039;:
                  source = &#039;n=e;o=e.localName;while((n=n.previousElementSibling)&amp;&amp;n.localName!=o);if(!n){&#039; + source + &#039;}&#039;;
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** child-indexed &amp; typed child-indexed pseudo-classes
            // :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type
            else if ((match = selector.match(Patterns.treestruct))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;nth-child&#039;:
                case &#039;nth-of-type&#039;:
                case &#039;nth-last-child&#039;:
                case &#039;nth-last-of-type&#039;:
                  expr = /-of-type/i.test(match[1]);
                  if (match[1] &amp;&amp; match[2]) {
                    type = /last/i.test(match[1]);
                    if (match[2] == &#039;n&#039;) {
                      source = &#039;if(true){&#039; + source + &#039;}&#039;;
                      break;
                    } else if (match[2] == &#039;1&#039;) {
                      test = type ? &#039;next&#039; : &#039;previous&#039;;
                      source = expr ? &#039;n=e;o=e.localName;&#039; +
                        &#039;while((n=n.&#039; + test + &#039;ElementSibling)&amp;&amp;n.localName!=o);if(!n){&#039; + source + &#039;}&#039; :
                        &#039;if(!e.&#039; + test + &#039;ElementSibling){&#039; + source + &#039;}&#039;;
                      break;
                    } else if (match[2] == &#039;even&#039; || match[2] == &#039;2n0&#039; || match[2] == &#039;2n+0&#039; || match[2] == &#039;2n&#039;) {
                      test = &#039;n%2==0&#039;;
                    } else if (match[2] == &#039;odd&#039;  || match[2] == &#039;2n1&#039; || match[2] == &#039;2n+1&#039;) {
                      test = &#039;n%2==1&#039;;
                    } else {
                      f = /n/i.test(match[2]);
                      n = match[2].split(&#039;n&#039;);
                      a = parseInt(n[0], 10) || 0;
                      b = parseInt(n[1], 10) || 0;
                      if (n[0] == &#039;-&#039;) { a = -1; }
                      if (n[0] == &#039;+&#039;) { a = +1; }
                      test = (b ? &#039;(n&#039; + (b &gt; 0 ? &#039;-&#039; : &#039;+&#039;) + Math.abs(b) + &#039;)&#039; : &#039;n&#039;) + &#039;%&#039; + a + &#039;==0&#039; ;
                      test =
                        a &gt;= +1 ? (f ? &#039;n&gt;&#039; + (b - 1) + (Math.abs(a) != 1 ? &#039;&amp;&amp;&#039; + test : &#039;&#039;) : &#039;n==&#039; + a) :
                        a &lt;= -1 ? (f ? &#039;n&lt;&#039; + (b + 1) + (Math.abs(a) != 1 ? &#039;&amp;&amp;&#039; + test : &#039;&#039;) : &#039;n==&#039; + a) :
                        a === 0 ? (n[0] ? &#039;n==&#039; + b : &#039;n&gt;&#039; + (b - 1)) : &#039;false&#039;;
                    }
                    expr = expr ? &#039;OfType&#039; : &#039;Element&#039;;
                    type = type ? &#039;true&#039; : &#039;false&#039;;
                    source = &#039;n=s.nth&#039; + expr + &#039;(e,&#039; + type + &#039;);if((&#039; + test + &#039;)){&#039; + source + &#039;}&#039;;
                  } else {
                    emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  }
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** logical combination pseudo-classes
            // :is( s1, [ s2, ... ]), :not( s1, [ s2, ... ]),
            // :has( s1, [ s2, ... ]) no nesting is allowed for
            // :where( s1, [ s2, ... ]), :matches( s1, [ s2, ... ]),
            else if ((match = selector.match(Patterns.logicalsel))) {
              match[1] = match[1].toLowerCase();
              expr = match[2]
                .replace(REX.CommaGroup, &#039;,&#039;)
                .replace(REX.TrimSpaces, &#039;&#039;)
                .replace(/\x22/g, &#039;\\&quot;&#039;);
              switch (match[1]) {
                case &#039;is&#039;:
                case &#039;where&#039;:
                  if (Config.FORGIVING) {
                    source =
                      &#039;try{&#039; +
                        &#039;if(s.match(&quot;&#039; + expr + &#039;&quot;,e)){&#039; + source + &#039;}&#039; +
                      &#039;}catch(E){}&#039;;
                  } else {
                    source = &#039;if(s.match(&quot;&#039; + expr + &#039;&quot;,e)){&#039; + source + &#039;}&#039;;
                  }
                  break;
                case &#039;matches&#039;:
                  source = &#039;if(s.match(&quot;&#039; + expr + &#039;&quot;,e)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;not&#039;:
                  source = &#039;if(!s.match(&quot;&#039; + expr + &#039;&quot;,e)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;has&#039;:
                  if (/^\s*(\+|\~)/.test(match[2])) {
                    source = &#039;if(e.parentElement&amp;&amp;Array.from(e.parentElement&#039; +
                      (/^\s*[+]/.test(match[2]) ?
                        &#039;.querySelectorAll(&quot;*&#039; + expr + &#039;&quot;)&#039; : &#039;.children&#039;) +
                        &#039;).includes(e.nextElementSibling)){&#039; + source + &#039;}&#039;;
                  } else {
                    source = &#039;if(e.querySelector(&quot;:scope &#039; + expr + &#039;&quot;))&#039; +
                      &#039;{&#039; + source + &#039;}&#039;;
                  }
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** linguistic pseudo-classes
            // :dir( ltr / rtl ), :lang( en )
            else if ((match = selector.match(Patterns.linguistic))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;dir&#039;:
                  source = &#039;var p;if((&#039; +
                    &#039;(/&#039; + match[2] + &#039;/i.test(e.dir))||(p=s.ancestor(&quot;[dir]&quot;, e))&amp;&amp;&#039; +
                    &#039;(/&#039; + match[2] + &#039;/i.test(p.dir))||(e.dir==&quot;&quot;||e.dir==&quot;auto&quot;)&amp;&amp;&#039; +
                    &#039;(&#039; + (match[2] == &#039;ltr&#039; ? &#039;!&#039;:&#039;&#039;)+ RTL +&#039;.test(e.textContent)))&#039; +
                    &#039;){&#039; + source + &#039;};&#039;;
                  break;
                case &#039;lang&#039;:
                  expr = &#039;(?:^|-)&#039; + match[2] + &#039;(?:-|$)&#039;;
                  source = &#039;var p;if((&#039; +
                    &#039;(e.isConnected&amp;&amp;(e.lang==&quot;&quot;&amp;&amp;(p=s.ancestor(&quot;[lang]&quot;,e)))&amp;&amp;&#039; +
                    &#039;(p.lang==&quot;&#039; + match[2] + &#039;&quot;)||/&#039;+ expr +&#039;/i.test(e.lang)))&#039; +
                    &#039;){&#039; + source + &#039;};&#039;;
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** location pseudo-classes
            // :any-link, :link, :visited, :target, :defined
            else if ((match = selector.match(Patterns.locationpc))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;any-link&#039;:
                  source = &#039;if((/^a|area$/i.test(e.localName)&amp;&amp;e.hasAttribute(&quot;href&quot;)||e.visited)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;link&#039;:
                  source = &#039;if((/^a|area$/i.test(e.localName)&amp;&amp;e.hasAttribute(&quot;href&quot;))){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;visited&#039;:
                  source = &#039;if((/^a|area$/i.test(e.localName)&amp;&amp;e.hasAttribute(&quot;href&quot;)&amp;&amp;e.visited)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;target&#039;:
                  source = &#039;if(((s.doc.compareDocumentPosition(e)&amp;16)&amp;&amp;s.doc.location.hash&amp;&amp;e.id==s.doc.location.hash.slice(1))){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;defined&#039;:
                  source = &#039;n=s.doc.defaultView.customElements.get(e.localName);if(n&amp;&amp;e instanceof n){&#039; + source + &#039;}&#039;;
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** user actions pseudo-classes
            // :hover, :active, :focus, :focus-visible, :focus-within
            else if ((match = selector.match(Patterns.useraction))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;hover&#039;:
                  source = &#039;if(e===s.HOVER){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;active&#039;:
                  source = &#039;if(e===s.doc.activeElement){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;focus&#039;:
                  source = &#039;if(s.isFocusable(e)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;focus-visible&#039;:
                  source = &#039;if(n=s.isFocusable(e)){&#039; +
                    &#039;if(e!==n){while(e){e=e.parentElement;if(e===n)break;}}}&#039; +
                    &#039;if((e===n||e.autofocus)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;focus-within&#039;:
                  source = &#039;if(n=s.isFocusable(e)){&#039; +
                    &#039;if(n!==e){while(n){n=n.parentElement;if(n===e)break;}}}&#039; +
                    &#039;if((n===e||n.autofocus)){&#039; + source + &#039;}&#039;;
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** user interface and form pseudo-classes
            // :enabled, :disabled, :read-only, :read-write, :placeholder-shown, :default
            else if ((match = selector.match(Patterns.inputstate))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;enabled&#039;:
                  source = &#039;if(((&quot;form&quot; in e||/^optgroup$/i.test(e.localName))&amp;&amp;&quot;disabled&quot; in e &amp;&amp;e.disabled===false&#039; +
                    &#039;)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;disabled&#039;:
                  // https://html.spec.whatwg.org/#enabling-and-disabling-form-controls:-the-disabled-attribute
                  source = &#039;if(((&quot;form&quot; in e||/^optgroup$/i.test(e.localName))&amp;&amp;&quot;disabled&quot; in e)){&#039; +
                    // F is true if any of the fieldset elements in the ancestry chain has the disabled attribute specified
                    // L is true if the first legend element of the fieldset contains the element
                    &#039;var x=0,N=[],F=false,L=false;&#039; +
                    &#039;if(!(/^(optgroup|option)$/i.test(e.localName))){&#039; +
                      &#039;n=e.parentElement;&#039; +
                      &#039;while(n){&#039; +
                        &#039;if(n.localName==&quot;fieldset&quot;){&#039; +
                          &#039;N[x++]=n;&#039; +
                          &#039;if(n.disabled===true){&#039; +
                            &#039;F=true;&#039; +
                            &#039;break;&#039; +
                          &#039;}&#039; +
                        &#039;}&#039; +
                        &#039;n=n.parentElement;&#039; +
                      &#039;}&#039; +
                      &#039;for(var x=0;x&lt;N.length;x++){&#039; +
                        &#039;if((n=s.first(&quot;legend&quot;,N[x]))&amp;&amp;n.contains(e)){&#039; +
                          &#039;L=true;&#039; +
                          &#039;break;&#039; +
                        &#039;}&#039; +
                      &#039;}&#039; +
                    &#039;}&#039; +
                    &#039;if(e.disabled===true||(F&amp;&amp;!L)){&#039; + source + &#039;}}&#039;;
                  break;
                case &#039;read-only&#039;:
                  source =
                    &#039;if(&#039; +
                      &#039;(/^textarea$/i.test(e.localName)&amp;&amp;(e.readOnly||e.disabled))||&#039; +
                      &#039;(/^input$/i.test(e.localName)&amp;&amp;(&quot;|date|datetime-local|email|month|number|password|search|tel|text|time|url|week|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;)?(e.readOnly||e.disabled):true))||&#039; +
                      &#039;(!/^(?:input|textarea)$/i.test(e.localName) &amp;&amp; !s.isContentEditable(e))&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;read-write&#039;:
                  source =
                    &#039;if(&#039; +
                      &#039;(/^textarea$/i.test(e.localName)&amp;&amp;!e.readOnly&amp;&amp;!e.disabled)||&#039; +
                      &#039;(/^input$/i.test(e.localName)&amp;&amp;&quot;|date|datetime-local|email|month|number|password|search|tel|text|time|url|week|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;)&amp;&amp;!e.readOnly&amp;&amp;!e.disabled)||&#039; +
                      &#039;(!/^(?:input|textarea)$/i.test(e.localName) &amp;&amp; s.isContentEditable(e))&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;placeholder-shown&#039;:
                  source =
                    &#039;if((&#039; +
                      &#039;(/^input|textarea$/i.test(e.localName))&amp;&amp;e.hasAttribute(&quot;placeholder&quot;)&amp;&amp;&#039; +
                      &#039;(&quot;|textarea|password|number|search|email|text|tel|url|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;))&amp;&amp;&#039; +
                      &#039;(!s.match(&quot;:focus&quot;,e))&#039; +
                    &#039;)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;default&#039;:
                  source =
                    &#039;if((&quot;form&quot; in e &amp;&amp; e.form)){&#039; +
                      &#039;var x=0;n=[];&#039; +
                      &#039;if(e.type==&quot;image&quot;)n=e.form.getElementsByTagName(&quot;input&quot;);&#039; +
                      &#039;if(e.type==&quot;submit&quot;)n=e.form.elements;&#039; +
                      &#039;while(n[x]&amp;&amp;e!==n[x]){&#039; +
                        &#039;if(n[x].type==&quot;image&quot;)break;&#039; +
                        &#039;if(n[x].type==&quot;submit&quot;)break;&#039; +
                        &#039;x++;&#039; +
                      &#039;}&#039; +
                    &#039;}&#039; +
                    &#039;if((e.form&amp;&amp;(e===n[x]&amp;&amp;&quot;|image|submit|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;))||&#039; +
                      &#039;((/^option$/i.test(e.localName))&amp;&amp;e.defaultSelected)||&#039; +
                      &#039;((&quot;|radio|checkbox|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;))&amp;&amp;e.defaultChecked)&#039; +
                    &#039;)){&#039; + source + &#039;}&#039;;
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // *** input pseudo-classes (for form validation)
            // :checked, :indeterminate, :valid, :invalid, :in-range, :out-of-range, :required, :optional
            else if ((match = selector.match(Patterns.inputvalue))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;checked&#039;:
                  source = &#039;if((/^input$/i.test(e.localName)&amp;&amp;&#039; +
                    &#039;(&quot;|radio|checkbox|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;)&amp;&amp;e.checked)||&#039; +
                    &#039;(/^option$/i.test(e.localName)&amp;&amp;(e.selected||e.checked))&#039; +
                    &#039;)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;indeterminate&#039;:
                  source =
                    &#039;if((/^progress$/i.test(e.localName)&amp;&amp;!e.hasAttribute(&quot;value&quot;))||&#039; +
                      &#039;(/^input$/i.test(e.localName)&amp;&amp;(&quot;checkbox&quot;==e.type&amp;&amp;e.indeterminate)||&#039; +
                      &#039;(&quot;radio&quot;==e.type&amp;&amp;e.name&amp;&amp;!s.first(&quot;input[name=&quot;+e.name+&quot;]:checked&quot;,e.form))&#039; +
                    &#039;)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;required&#039;:
                  source =
                    &#039;if((/^input|select|textarea$/i.test(e.localName)&amp;&amp;e.required)&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;optional&#039;:
                  source =
                    &#039;if((/^input|select|textarea$/i.test(e.localName)&amp;&amp;!e.required)&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;invalid&#039;:
                  source =
                    &#039;if(((&#039; +
                      &#039;(/^form$/i.test(e.localName)&amp;&amp;!e.noValidate)||&#039; +
                      &#039;(e.willValidate&amp;&amp;!e.formNoValidate))&amp;&amp;!e.checkValidity())||&#039; +
                      &#039;(/^fieldset$/i.test(e.localName)&amp;&amp;s.first(&quot;:invalid&quot;,e))&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;valid&#039;:
                  source =
                    &#039;if(((&#039; +
                      &#039;(/^form$/i.test(e.localName)&amp;&amp;!e.noValidate)||&#039; +
                      &#039;(e.willValidate&amp;&amp;!e.formNoValidate))&amp;&amp;e.checkValidity())||&#039; +
                      &#039;(/^fieldset$/i.test(e.localName)&amp;&amp;s.first(&quot;:valid&quot;,e))&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;in-range&#039;:
                  source =
                    &#039;if((/^input$/i.test(e.localName))&amp;&amp;&#039; +
                      &#039;(e.willValidate&amp;&amp;!e.formNoValidate)&amp;&amp;&#039; +
                      &#039;(!e.validity.rangeUnderflow&amp;&amp;!e.validity.rangeOverflow)&amp;&amp;&#039; +
                      &#039;(&quot;|date|datetime-local|month|number|range|time|week|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;))&amp;&amp;&#039; +
                      &#039;(&quot;range&quot;==e.type||e.getAttribute(&quot;min&quot;)||e.getAttribute(&quot;max&quot;))&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;out-of-range&#039;:
                  source =
                    &#039;if((/^input$/i.test(e.localName))&amp;&amp;&#039; +
                      &#039;(e.willValidate&amp;&amp;!e.formNoValidate)&amp;&amp;&#039; +
                      &#039;(e.validity.rangeUnderflow||e.validity.rangeOverflow)&amp;&amp;&#039; +
                      &#039;(&quot;|date|datetime-local|month|number|range|time|week|&quot;.includes(&quot;|&quot;+e.type+&quot;|&quot;))&amp;&amp;&#039; +
                      &#039;(&quot;range&quot;==e.type||e.getAttribute(&quot;min&quot;)||e.getAttribute(&quot;max&quot;))&#039; +
                    &#039;){&#039; + source + &#039;}&#039;;
                  break;
                default:
                  emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
                  break;
              }
            }

            // resources state pseudo-classes (multimedia state)
            // :playing, :paused, :seeking, :buffering, :stalled, :muted, :volume-locked
            else if ((match = selector.match(Patterns.rsrc_state))) {
              match[1] = match[1].toLowerCase();
              switch (match[1]) {
                case &#039;playing&#039;:
                  source = &#039;if(s.isPlaying(e)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;paused&#039;:
                  source = &#039;if(!s.isPlaying(e)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;seeking&#039;:
                  source = &#039;if(!s.isPlaying(e)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;buffering&#039;:
                  break;
                case &#039;stalled&#039;:
                  break;
                case &#039;muted&#039;:
                  source = &#039;if(e.localName==&quot;audio&quot;&amp;&amp;e.getAttribute(&quot;muted&quot;)){&#039; + source + &#039;}&#039;;
                  break;
                case &#039;volume-locked&#039;:
                  break;
                default:
                  break;
              }
            }

            // placeholder for parse only no-op selectors
            else if ((match = selector.match(Patterns.pseudo_nop))) {
              break;
            }

            // allow pseudo-elements starting with single colon (:)
            // :after, :before, :first-letter, :first-line
            // assert: e.type is in double-colon format, like ::after
            else if ((match = selector.match(Patterns.pseudo_sng))) {
              source = &#039;if(e.element&amp;&amp;e.type.toLowerCase()==&quot;&#039; +
                &#039;:&#039; + match[0].toLowerCase() + &#039;&quot;){e=e.element;&#039; + source + &#039;}&#039;;
            }

            // allow pseudo-elements starting with double colon (::)
            // ::after, ::before, ::marker, ::placeholder, ::inactive-selection, ::selection, ::-webkit-&lt;foo-bar&gt;
            // assert: e.type is in double-colon format, like ::after
            else if ((match = selector.match(Patterns.pseudo_dbl))) {
              source = &#039;if(e.element&amp;&amp;e.type.toLowerCase()==&quot;&#039; +
                match[0].toLowerCase() + &#039;&quot;){e=e.element;&#039; + source + &#039;}&#039;;
            }

            else {

              // reset
              expr = false;
              status = false;

              // process registered selector extensions
              for (expr in Selectors) {
                if ((match = selector.match(Selectors[expr].Expression))) {
                  result = Selectors[expr].Callback(match, source, mode, callback);
                  if (&#039;match&#039; in result) { match = result.match; }
                  vars = result.modvar;
                  if (mode) {
                     // add extra select() vars
                     vars &amp;&amp; S_VARS.indexOf(vars) &lt; 0 &amp;&amp; (S_VARS[S_VARS.length] = vars);
                  } else {
                     // add extra match() vars
                     vars &amp;&amp; M_VARS.indexOf(vars) &lt; 0 &amp;&amp; (M_VARS[M_VARS.length] = vars);
                  }
                  // extension source code
                  source = result.source;
                  // extension status code
                  status = result.status;
                  // break on status error
                  if (status) { break; }
                }
              }

              if (!status) {
                if (Config.FORGIVING &amp;&amp;
                  selector.match(/(:(?:is|where)\x28)/)) {
                  return &#039;&#039;;
                }
                emit(&#039;unknown pseudo-class selector \&#039;&#039; + selector + &#039;\&#039;&#039;);
                return &#039;&#039;;
              }

              if (!expr) {
                if (Config.FORGIVING &amp;&amp;
                  selector.match(/(:(?:is|where)\x28)/)) {
                  return &#039;&#039;;
                }
                emit(&#039;unknown token in selector \&#039;&#039; + selector + &#039;\&#039;&#039;);
                return &#039;&#039;;
              }

            }
            break;

        default:
          emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
          break selector_recursion_label;

        }
        // end of switch symbol

        if (!match) {
          if (Config.FORGIVING &amp;&amp;
            selector.match(/(:(?:is|where)\x28)/)) {
            return &#039;&#039;;
          }
          emit(&#039;\&#039;&#039; + expression + &#039;\&#039;&#039; + qsInvalid);
          return &#039;&#039;;
        }

        // pop last component
        selector = match.pop();
      }
      // end of while selector

      return source;
    },

  // replace :scope context element as a
  // a reference in the selector string
  makeref =
    function(selectors, element) {
      // replace DOCUMENT with first element (root)
      if (element.nodeType === 9) {
        element = element.documentElement;
      }
      return selectors.replace(/:scope/i,
        (element.localName) +
        (element.id ? &#039;#&#039; + escape(element.id) : &#039;&#039;) +
        (element.className ? &#039;.&#039; + escape(element.classList[0]) : &#039;&#039;));
    },

  // equivalent of w3c &#039;closest&#039; method
  ancestor =
    function _closest(selectors, element, callback) {
      parse(selectors, true);
      selectors = makeref(selectors, element);
      while (element) {
        if (match(selectors, element, callback)) break;
        element = element.parentElement;
      }
      return element;
    },

  match_assert =
    function(f, element, callback) {
      for (var i = 0, l = f.length, r = false; l &gt; i; ++i)
        f[i](element, callback, null, false) &amp;&amp; (r = true);
      return r;
    },

  match_collect =
    function(selectors, callback) {
      for (var i = 0, l = selectors.length, f = [ ]; l &gt; i; ++i)
        f[i] = compile(selectors[i], false, callback);
      return { factory: f };
    },

  // unique parser entry point for all
  // methods (type matching/selecting)
  parse =
    function(selectors, type) {

      var parsed;

      // arguments validation
      if (arguments.length === 0) {
        emit(qsNotArgs, TypeError);
        return Config.VERBOSITY ? undefined : (type ? none : false);
      } else if (arguments[0] === &#039;&#039;) {
        emit(&#039;\&#039;\&#039;&#039; + qsInvalid);
        return Config.VERBOSITY ? undefined : (type ? none : false);
      }

      // input NULL or UNDEFINED
      if (typeof selectors != &#039;string&#039;) {
        selectors = &#039;&#039; + selectors;
      }

      if ((/:scope/i).test(selectors)) {
        selectors = makeref(selectors, Snapshot.from);
      }

      // normalize input string
      parsed = selectors.
        replace(/\x00|\\$/g, &#039;\ufffd&#039;).
        replace(REX.CombineWSP, &#039;\x20&#039;).
        replace(REX.PseudosWSP, &#039;$1&#039;).
        replace(REX.TabCharWSP, &#039;\t&#039;).
        replace(REX.CommaGroup, &#039;,&#039;).
        replace(REX.TrimSpaces, &#039;&#039;);

      // parse, validate and split possible compound selectors
      if ((selectors = parsed.match(reValidator)) &amp;&amp; selectors.join(&#039;&#039;) == parsed) {
        selectors = parsed.match(REX.SplitGroup);
        if (parsed[parsed.length - 1] == &#039;,&#039;) {
          emit(qsInvalid);
          return Config.VERBOSITY ? undefined : (type ? none : false);
        }
      } else {
        if (Config.FORGIVING) {
          // forgiving pseudos allow to continue even after parse errors
          if (!(parsed.includes(&#039;:is(&#039;) || parsed.includes(&#039;:where(&#039;))) {
            emit(&#039;\&#039;&#039; + selectors + &#039;\&#039;&#039; + qsInvalid);
            return Config.VERBOSITY ? undefined : (type ? none : false);
          }
        }
      }

      return selectors;
    },

  // equivalent of w3c &#039;matches&#039; method
  match =
    function _matches(selectors, element, callback) {

      if (element &amp;&amp; matchResolvers[selectors]) {
        return match_assert(matchResolvers[selectors].factory, element, callback);
      }

      matchResolvers[selectors] = match_collect(parse(selectors, false), callback);

      return match_assert(matchResolvers[selectors].factory, element, callback);
    },

  // equivalent of w3c &#039;querySelector&#039; method
  first =
    function _querySelector(selectors, context, callback) {
      return select(selectors, context,
        typeof callback == &#039;function&#039; ?
        function firstMatch(element) {
          callback(element);
          return false;
        } :
        function firstMatch() {
          return false;
        }
      )[0] || null;
    },

  // equivalent of w3c &#039;querySelectorAll&#039; method
  select =
    function _querySelectorAll(selectors, context, callback) {

      var nodes = [ ], resolver;

      arguments.length == 0 &amp;&amp;
        emit(qsNotArgs, TypeError);

      context || (context = doc);
        lastContext !== context &amp;&amp;
          (lastContext = switchContext(context));

      if (selectors) {
        if ((resolver = selectResolvers[selectors])) {
          if (resolver.context === context &amp;&amp;
            resolver.callback === callback) {
            var i, l, list,
              f = resolver.factory,
              h = resolver.htmlset,
              n = resolver.nodeset;
            if (n.length &gt; 1) {
              for (i = 0, l = n.length; l &gt; i; ++i) {
                list = compat[n[i][0]](context, n[i].slice(1))();
                if (f[i] !== null) {
                  f[i](list, callback, context, nodes);
                } else {
                  nodes = nodes.concat(list);
                }
              }
              if (l &gt; 1 &amp;&amp; nodes.length &gt; 1) {
                nodes.sort(documentOrder);
                hasDupes &amp;&amp; (nodes = unique(nodes));
              }
            } else {
              if (f[0]) {
                nodes = f[0](h[0](), callback, context, nodes);
              } else {
                nodes = h[0]();
              }
            }
            if (typeof callback == &#039;function&#039;) {
              nodes = concatCall(nodes, callback);
            }
            return !Config.NODE_LIST ?
              nodes : isInstanceOf(nodes) ?
              nodes : toNodeList(nodes);
          }
        }
      }

      // save/reuse factory and closure collection
      selectResolvers[selectors] = collect(parse(selectors, true), context, callback);

      nodes = selectResolvers[selectors].results;

      if (typeof callback == &#039;function&#039;) {
        nodes = concatCall(nodes, callback);
      }
      return !Config.NODE_LIST ?
        nodes : isInstanceOf(nodes) ?
        nodes : toNodeList(nodes);
    },

  // optimize selectors avoiding duplicated checks
  optimize =
    function(selector, token) {
      var index = token.index,
      length = token[1].length + token[2].length;
      return selector.slice(0, index) +
        (&#039; &gt;+~&#039;.indexOf(selector.charAt(index - 1)) &gt; -1 ?
          (&#039;:[&#039;.indexOf(selector.charAt(index + length + 1)) &gt; -1 ?
          &#039;*&#039; : &#039;&#039;) : &#039;&#039;) + selector.slice(index + length - (token[1] == &#039;*&#039; ? 1 : 0));
    },

  // prepare factory resolvers and closure collections
  collect =
    function(selectors, context, callback) {

      var i, l, seen = { }, token = [&#039;&#039;, &#039;*&#039;, &#039;*&#039;], optimized = selectors,
      factory = [ ], htmlset = [ ], nodeset = [ ], results = [ ], type;

      for (i = 0, l = selectors.length; l &gt; i; ++i) {

        if (!seen[selectors[i]] &amp;&amp; (seen[selectors[i]] = true)) {
          type = selectors[i].match(reOptimizer);
          if (type &amp;&amp; type[1] != &#039;:&#039; &amp;&amp; (token = type)) {
            token[1] || (token[1] = &#039;*&#039;);
            optimized[i] = optimize(optimized[i], token);
          } else {
            token = [&#039;&#039;, &#039;*&#039;, &#039;*&#039;];
          }
        }

        nodeset[i] = token[1] + token[2];
        token[2] = unescapeIdentifier(token[2]);
        htmlset[i] = compat[token[1]](context, token[2]);
        factory[i] = compile(optimized[i], true, null);

        factory[i] ?
          factory[i](htmlset[i](), callback, context, results) :
          results.concat(htmlset[i]());
      }

      if (l &gt; 1) {
        results.sort(documentOrder);
        hasDupes &amp;&amp; (results = unique(results));
      }

      return {
        callback: callback,
        context: context,
        factory: factory,
        htmlset: htmlset,
        nodeset: nodeset,
        results: results
      };

    },

  // handlers needed for the :hover pseudo-class
  // track state change in browsers and headless
  initEnv =
    (function() {
      doc.addEventListener(&#039;mouseover&#039;, function(e) { Snapshot.HOVER = e.target; }, true);
      doc.addEventListener(&#039;mouseout&#039;, function(e) { Snapshot.HOVER = null; }, true);
    })(),

  // QSA placeholders to native references
  _closest, _matches,
  _querySelector, _querySelectorAll,
  _querySelectorDoc, _querySelectorAllDoc,

  // overrides QSA methods (only for browsers)
  install =
    function(all) {
      // save references
      _closest = Element.prototype.closest;
      _matches = Element.prototype.matches;

      _querySelector = Element.prototype.querySelector;
      _querySelectorAll = Element.prototype.querySelectorAll;

      _querySelectorDoc = Document.prototype.querySelector;
      _querySelectorAllDoc = Document.prototype.querySelectorAll;

      function parseQSArgs() {
        var method = arguments[arguments.length - 1];
        return (
          arguments.length &lt; 2 ?
            method.apply(this, [ ]) :
          arguments.length &lt; 3 ?
            method.apply(this, [ arguments[0], this ]) :
            method.apply(this, [ arguments[0], this,
              typeof arguments[1] == &#039;function&#039; ? arguments[1] : undefined ]));
      }

      Element.prototype.closest =
      HTMLElement.prototype.closest =
        function closest() {
          return parseQSArgs.apply(this, [].slice.call(arguments).concat(ancestor));
        };

      Element.prototype.matches =
      HTMLElement.prototype.matches =
        function matches() {
          return parseQSArgs.apply(this, [].slice.call(arguments).concat(match));
        };

      Element.prototype.querySelector =
      HTMLElement.prototype.querySelector =
        function querySelector() {
          return parseQSArgs.apply(this, [].slice.call(arguments).concat(first));
        };

      Element.prototype.querySelectorAll =
      HTMLElement.prototype.querySelectorAll =
        function querySelectorAll() {
          return parseQSArgs.apply(this, [].slice.call(arguments).concat(select));
        };

      Document.prototype.querySelector =
      DocumentFragment.prototype.querySelector =
        function querySelector() {
          return parseQSArgs.apply(this, [].slice.call(arguments).concat(first));
        };

      Document.prototype.querySelectorAll =
      DocumentFragment.prototype.querySelectorAll =
        function querySelectorAll() {
          return parseQSArgs.apply(this, [].slice.call(arguments).concat(select));
      };

      if (all) {
        doc.addEventListener(&#039;load&#039;, function(e) {
          var c, d, r, s, t = e.target;
          if (/iframe/i.test(t.localName)) {
            c = &#039;(&#039; + Export + &#039;)(this, &#039; + Factory + &#039;);&#039;; d = t.ownerDocument;
            s = d.createElement(&#039;script&#039;); s.textContent = c + &#039;NW.Dom.install(true)&#039;;
            r = d.documentElement; r.removeChild(r.insertBefore(s, r.firstChild));
          }
        }, true);
      }

    },

  // restore QSA methods (only for browsers)
  uninstall =
    function() {
      // restore references
      if (_closest) {
        Element.prototype.closest = _closest;
        HTMLElement.prototype.closest = _closest;
      }
      if (_matches) {
        Element.prototype.matches = _matches;
        HTMLElement.prototype.matches = _matches;
      }
      if (_querySelector) {
        Element.prototype.querySelector =
        HTMLElement.prototype.querySelector = _querySelector;
        Element.prototype.querySelectorAll =
        HTMLElement.prototype.querySelectorAll = _querySelector;
      }
      if (_querySelectorAllDoc) {
        Document.prototype.querySelector =
        DocumentFragment.prototype.querySelector = _querySelectorDoc;
        Document.prototype.querySelectorAll =
        DocumentFragment.prototype.querySelectorAll = _querySelectorAllDoc;
      }
    },

  // empty set
  none = Array(),

  // context
  lastContext,

  // cached lambdas
  matchLambdas = { },
  selectLambdas = { },

  // cached resolvers
  matchResolvers = { },
  selectResolvers = { },

  // passed to resolvers
  Snapshot = {

    doc: doc,
    from: doc,
    root: root,

    byTag: byTag,

    first: first,
    match: match,

    ancestor: ancestor,

    nthOfType: nthOfType,
    nthElement: nthElement,

    isFocusable: isFocusable,
    isContentEditable: isContentEditable,
    hasAttributeNS: hasAttributeNS
  },

  // public exported methods/objects
  Dom = {

    // exported cache objects

    matchLambdas: matchLambdas,
    selectLambdas: selectLambdas,

    matchResolvers: matchResolvers,
    selectResolvers: selectResolvers,

    // exported compiler macros

    CFG: CFG,

    S_BODY: S_BODY,
    M_BODY: M_BODY,
    N_BODY: M_BODY,

    S_TEST: S_TEST,
    M_TEST: M_TEST,
    N_TEST: N_TEST,

    // exported engine methods

    byId: byId,
    byTag: byTag,
    byClass: byClass,

    match: match,
    first: first,
    select: select,
    closest: ancestor,

    compile: compile,
    configure: configure,

    emit: emit,
    Config: Config,
    Snapshot: Snapshot,

    Version: version,

    install: install,
    uninstall: uninstall,

    Operators: Operators,
    Selectors: Selectors,

    // register a new selector combinator symbol and its related function resolver
    registerCombinator:
      function(combinator, resolver) {
        var i = 0, l = combinator.length, symbol;
        for (; l &gt; i; ++i) {
          if (combinator[i] != &#039;=&#039;) {
            symbol = combinator[i];
            break;
          }
        }
        if (CFG.combinators.indexOf(symbol) &lt; 0) {
          CFG.combinators = CFG.combinators.replace(&#039;](&#039;, symbol + &#039;](&#039;);
          CFG.combinators = CFG.combinators.replace(&#039;])&#039;, symbol + &#039;])&#039;);
          Combinators[combinator] = resolver;
          setIdentifierSyntax();
        } else {
          console.warn(&#039;Warning: the \&#039;&#039; + combinator + &#039;\&#039; combinator is already registered.&#039;);
        }
      },

    // register a new attribute operator symbol and its related function resolver
    registerOperator:
      function(operator, resolver) {
        var i = 0, l = operator.length, symbol;
        for (; l &gt; i; ++i) {
          if (operator[i] != &#039;=&#039;) {
            symbol = operator[i];
            break;
          }
        }
        if (CFG.operators.indexOf(symbol) &lt; 0 &amp;&amp; !Operators[operator]) {
          CFG.operators = CFG.operators.replace(&#039;]=&#039;, symbol + &#039;]=&#039;);
          Operators[operator] = resolver;
          setIdentifierSyntax();
        } else {
          console.warn(&#039;Warning: the \&#039;&#039; + operator + &#039;\&#039; operator is already registered.&#039;);
        }
      },

    // register a new selector symbol and its related function resolver
    registerSelector:
      function(name, rexp, func) {
        Selectors[name] || (Selectors[name] = {
          Expression: rexp,
          Callback: func
        });
      }
  };

  initialize(doc);

  return Dom;
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
