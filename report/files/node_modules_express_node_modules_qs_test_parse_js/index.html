<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/express/node_modules/qs/test/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/express/node_modules/qs/test/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1171</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">87.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.76</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var test = require(&#039;tape&#039;);
var hasPropertyDescriptors = require(&#039;has-property-descriptors&#039;)();
var iconv = require(&#039;iconv-lite&#039;);
var mockProperty = require(&#039;mock-property&#039;);
var hasOverrideMistake = require(&#039;has-override-mistake&#039;)();
var SaferBuffer = require(&#039;safer-buffer&#039;).Buffer;
var v = require(&#039;es-value-fixtures&#039;);
var inspect = require(&#039;object-inspect&#039;);
var emptyTestCases = require(&#039;./empty-keys-cases&#039;).emptyTestCases;

var qs = require(&#039;../&#039;);
var utils = require(&#039;../lib/utils&#039;);

test(&#039;parse()&#039;, function (t) {
    t.test(&#039;parses a simple string&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;0=foo&#039;), { 0: &#039;foo&#039; });
        st.deepEqual(qs.parse(&#039;foo=c++&#039;), { foo: &#039;c  &#039; });
        st.deepEqual(qs.parse(&#039;a[&gt;=]=23&#039;), { a: { &#039;&gt;=&#039;: &#039;23&#039; } });
        st.deepEqual(qs.parse(&#039;a[&lt;=&gt;]==23&#039;), { a: { &#039;&lt;=&gt;&#039;: &#039;=23&#039; } });
        st.deepEqual(qs.parse(&#039;a[==]=23&#039;), { a: { &#039;==&#039;: &#039;23&#039; } });
        st.deepEqual(qs.parse(&#039;foo&#039;, { strictNullHandling: true }), { foo: null });
        st.deepEqual(qs.parse(&#039;foo&#039;), { foo: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=&#039;), { foo: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&#039;), { foo: &#039;bar&#039; });
        st.deepEqual(qs.parse(&#039; foo = bar = baz &#039;), { &#039; foo &#039;: &#039; bar = baz &#039; });
        st.deepEqual(qs.parse(&#039;foo=bar=baz&#039;), { foo: &#039;bar=baz&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&amp;bar=baz&#039;), { foo: &#039;bar&#039;, bar: &#039;baz&#039; });
        st.deepEqual(qs.parse(&#039;foo2=bar2&amp;baz2=&#039;), { foo2: &#039;bar2&#039;, baz2: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&amp;baz&#039;, { strictNullHandling: true }), { foo: &#039;bar&#039;, baz: null });
        st.deepEqual(qs.parse(&#039;foo=bar&amp;baz&#039;), { foo: &#039;bar&#039;, baz: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;cht=p3&amp;chd=t:60,40&amp;chs=250x100&amp;chl=Hello|World&#039;), {
            cht: &#039;p3&#039;,
            chd: &#039;t:60,40&#039;,
            chs: &#039;250x100&#039;,
            chl: &#039;Hello|World&#039;
        });
        st.end();
    });

    t.test(&#039;comma: false&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b,c&#039;), { a: &#039;b,c&#039; });
        st.deepEqual(qs.parse(&#039;a=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.end();
    });

    t.test(&#039;comma: true&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=c&#039;, { comma: true }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { comma: true }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b,c&#039;, { comma: true }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a=c&#039;, { comma: true }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.end();
    });

    t.test(&#039;allows enabling dot notation&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a.b=c&#039;), { &#039;a.b&#039;: &#039;c&#039; });
        st.deepEqual(qs.parse(&#039;a.b=c&#039;, { allowDots: true }), { a: { b: &#039;c&#039; } });

        st.end();
    });

    t.test(&#039;decode dot keys correctly&#039;, function (st) {
        st.deepEqual(
            qs.parse(&#039;name%252Eobj.first=John&amp;name%252Eobj.last=Doe&#039;, { allowDots: false, decodeDotInKeys: false }),
            { &#039;name%2Eobj.first&#039;: &#039;John&#039;, &#039;name%2Eobj.last&#039;: &#039;Doe&#039; },
            &#039;with allowDots false and decodeDotInKeys false&#039;
        );
        st.deepEqual(
            qs.parse(&#039;name.obj.first=John&amp;name.obj.last=Doe&#039;, { allowDots: true, decodeDotInKeys: false }),
            { name: { obj: { first: &#039;John&#039;, last: &#039;Doe&#039; } } },
            &#039;with allowDots false and decodeDotInKeys false&#039;
        );
        st.deepEqual(
            qs.parse(&#039;name%252Eobj.first=John&amp;name%252Eobj.last=Doe&#039;, { allowDots: true, decodeDotInKeys: false }),
            { &#039;name%2Eobj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } },
            &#039;with allowDots true and decodeDotInKeys false&#039;
        );
        st.deepEqual(
            qs.parse(&#039;name%252Eobj.first=John&amp;name%252Eobj.last=Doe&#039;, { allowDots: true, decodeDotInKeys: true }),
            { &#039;name.obj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } },
            &#039;with allowDots true and decodeDotInKeys true&#039;
        );

        st.deepEqual(
            qs.parse(
                &#039;name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&amp;name%252Eobj%252Esubobject.last=Doe&#039;,
                { allowDots: false, decodeDotInKeys: false }
            ),
            { &#039;name%2Eobj%2Esubobject.first%2Egodly%2Ename&#039;: &#039;John&#039;, &#039;name%2Eobj%2Esubobject.last&#039;: &#039;Doe&#039; },
            &#039;with allowDots false and decodeDotInKeys false&#039;
        );
        st.deepEqual(
            qs.parse(
                &#039;name.obj.subobject.first.godly.name=John&amp;name.obj.subobject.last=Doe&#039;,
                { allowDots: true, decodeDotInKeys: false }
            ),
            { name: { obj: { subobject: { first: { godly: { name: &#039;John&#039; } }, last: &#039;Doe&#039; } } } },
            &#039;with allowDots true and decodeDotInKeys false&#039;
        );
        st.deepEqual(
            qs.parse(
                &#039;name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&amp;name%252Eobj%252Esubobject.last=Doe&#039;,
                { allowDots: true, decodeDotInKeys: true }
            ),
            { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
            &#039;with allowDots true and decodeDotInKeys true&#039;
        );
        st.deepEqual(
            qs.parse(&#039;name%252Eobj.first=John&amp;name%252Eobj.last=Doe&#039;),
            { &#039;name%2Eobj.first&#039;: &#039;John&#039;, &#039;name%2Eobj.last&#039;: &#039;Doe&#039; },
            &#039;with allowDots and decodeDotInKeys undefined&#039;
        );

        st.end();
    });

    t.test(&#039;should decode dot in key of object, and allow enabling dot notation when decodeDotInKeys is set to true and allowDots is undefined&#039;, function (st) {
        st.deepEqual(
            qs.parse(
                &#039;name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&amp;name%252Eobj%252Esubobject.last=Doe&#039;,
                { decodeDotInKeys: true }
            ),
            { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
            &#039;with allowDots undefined and decodeDotInKeys true&#039;
        );

        st.end();
    });

    t.test(&#039;should throw when decodeDotInKeys is not of type boolean&#039;, function (st) {
        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { decodeDotInKeys: &#039;foobar&#039; }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { decodeDotInKeys: 0 }); },
            TypeError
        );
        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { decodeDotInKeys: NaN }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { decodeDotInKeys: null }); },
            TypeError
        );

        st.end();
    });

    t.test(&#039;allows empty arrays in obj values&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo[]&amp;bar=baz&#039;, { allowEmptyArrays: true }), { foo: [], bar: &#039;baz&#039; });
        st.deepEqual(qs.parse(&#039;foo[]&amp;bar=baz&#039;, { allowEmptyArrays: false }), { foo: [&#039;&#039;], bar: &#039;baz&#039; });

        st.end();
    });

    t.test(&#039;should throw when allowEmptyArrays is not of type boolean&#039;, function (st) {
        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { allowEmptyArrays: &#039;foobar&#039; }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { allowEmptyArrays: 0 }); },
            TypeError
        );
        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { allowEmptyArrays: NaN }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.parse(&#039;foo[]&amp;bar=baz&#039;, { allowEmptyArrays: null }); },
            TypeError
        );

        st.end();
    });

    t.test(&#039;allowEmptyArrays + strictNullHandling&#039;, function (st) {
        st.deepEqual(
            qs.parse(&#039;testEmptyArray[]&#039;, { strictNullHandling: true, allowEmptyArrays: true }),
            { testEmptyArray: [] }
        );

        st.end();
    });

    t.deepEqual(qs.parse(&#039;a[b]=c&#039;), { a: { b: &#039;c&#039; } }, &#039;parses a single nested string&#039;);
    t.deepEqual(qs.parse(&#039;a[b][c]=d&#039;), { a: { b: { c: &#039;d&#039; } } }, &#039;parses a double nested string&#039;);
    t.deepEqual(
        qs.parse(&#039;a[b][c][d][e][f][g][h]=i&#039;),
        { a: { b: { c: { d: { e: { f: { &#039;[g][h]&#039;: &#039;i&#039; } } } } } } },
        &#039;defaults to a depth of 5&#039;
    );

    t.test(&#039;only parses one level when depth = 1&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[b][c]=d&#039;, { depth: 1 }), { a: { b: { &#039;[c]&#039;: &#039;d&#039; } } });
        st.deepEqual(qs.parse(&#039;a[b][c][d]=e&#039;, { depth: 1 }), { a: { b: { &#039;[c][d]&#039;: &#039;e&#039; } } });
        st.end();
    });

    t.test(&#039;uses original key when depth = 0&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { depth: 0 }), { &#039;a[0]&#039;: &#039;b&#039;, &#039;a[1]&#039;: &#039;c&#039; });
        st.deepEqual(qs.parse(&#039;a[0][0]=b&amp;a[0][1]=c&amp;a[1]=d&amp;e=2&#039;, { depth: 0 }), { &#039;a[0][0]&#039;: &#039;b&#039;, &#039;a[0][1]&#039;: &#039;c&#039;, &#039;a[1]&#039;: &#039;d&#039;, e: &#039;2&#039; });
        st.end();
    });

    t.test(&#039;uses original key when depth = false&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { depth: false }), { &#039;a[0]&#039;: &#039;b&#039;, &#039;a[1]&#039;: &#039;c&#039; });
        st.deepEqual(qs.parse(&#039;a[0][0]=b&amp;a[0][1]=c&amp;a[1]=d&amp;e=2&#039;, { depth: false }), { &#039;a[0][0]&#039;: &#039;b&#039;, &#039;a[0][1]&#039;: &#039;c&#039;, &#039;a[1]&#039;: &#039;d&#039;, e: &#039;2&#039; });
        st.end();
    });

    t.deepEqual(qs.parse(&#039;a=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] }, &#039;parses a simple array&#039;);

    t.test(&#039;parses an explicit array&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[]=b&#039;), { a: [&#039;b&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=c&amp;a[]=d&#039;), { a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] });
        st.end();
    });

    t.test(&#039;parses a mix of simple and explicit arrays&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a[0]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });

        st.deepEqual(qs.parse(&#039;a[1]=b&amp;a=c&#039;, { arrayLimit: 20 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a=c&#039;, { arrayLimit: 0 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });

        st.deepEqual(qs.parse(&#039;a=b&amp;a[1]=c&#039;, { arrayLimit: 20 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a[]=c&#039;, { arrayLimit: 0 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });

        st.end();
    });

    t.test(&#039;parses a nested array&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[b][]=c&amp;a[b][]=d&#039;), { a: { b: [&#039;c&#039;, &#039;d&#039;] } });
        st.deepEqual(qs.parse(&#039;a[&gt;=]=25&#039;), { a: { &#039;&gt;=&#039;: &#039;25&#039; } });
        st.end();
    });

    t.test(&#039;allows to specify array indices&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[1]=c&amp;a[0]=b&amp;a[2]=d&#039;), { a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] });
        st.deepEqual(qs.parse(&#039;a[1]=c&amp;a[0]=b&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[1]=c&#039;, { arrayLimit: 20 }), { a: [&#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[1]=c&#039;, { arrayLimit: 0 }), { a: { 1: &#039;c&#039; } });
        st.deepEqual(qs.parse(&#039;a[1]=c&#039;), { a: [&#039;c&#039;] });
        st.end();
    });

    t.test(&#039;limits specific array indices to arrayLimit&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[20]=a&#039;, { arrayLimit: 20 }), { a: [&#039;a&#039;] });
        st.deepEqual(qs.parse(&#039;a[21]=a&#039;, { arrayLimit: 20 }), { a: { 21: &#039;a&#039; } });

        st.deepEqual(qs.parse(&#039;a[20]=a&#039;), { a: [&#039;a&#039;] });
        st.deepEqual(qs.parse(&#039;a[21]=a&#039;), { a: { 21: &#039;a&#039; } });
        st.end();
    });

    t.deepEqual(qs.parse(&#039;a[12b]=c&#039;), { a: { &#039;12b&#039;: &#039;c&#039; } }, &#039;supports keys that begin with a number&#039;);

    t.test(&#039;supports encoded = signs&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;he%3Dllo=th%3Dere&#039;), { &#039;he=llo&#039;: &#039;th=ere&#039; });
        st.end();
    });

    t.test(&#039;is ok with url encoded strings&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[b%20c]=d&#039;), { a: { &#039;b c&#039;: &#039;d&#039; } });
        st.deepEqual(qs.parse(&#039;a[b]=c%20d&#039;), { a: { b: &#039;c d&#039; } });
        st.end();
    });

    t.test(&#039;allows brackets in the value&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;pets=[&quot;tobi&quot;]&#039;), { pets: &#039;[&quot;tobi&quot;]&#039; });
        st.deepEqual(qs.parse(&#039;operators=[&quot;&gt;=&quot;, &quot;&lt;=&quot;]&#039;), { operators: &#039;[&quot;&gt;=&quot;, &quot;&lt;=&quot;]&#039; });
        st.end();
    });

    t.test(&#039;allows empty values&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;&#039;), {});
        st.deepEqual(qs.parse(null), {});
        st.deepEqual(qs.parse(undefined), {});
        st.end();
    });

    t.test(&#039;transforms arrays to objects&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo[0]=bar&amp;foo[bad]=baz&#039;), { foo: { 0: &#039;bar&#039;, bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[bad]=baz&amp;foo[0]=bar&#039;), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo[bad]=baz&amp;foo[]=bar&#039;), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo[]=bar&amp;foo[bad]=baz&#039;), { foo: { 0: &#039;bar&#039;, bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[bad]=baz&amp;foo[]=bar&amp;foo[]=foo&#039;), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039;, 1: &#039;foo&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0][a]=a&amp;foo[0][b]=b&amp;foo[1][a]=aa&amp;foo[1][b]=bb&#039;), { foo: [{ a: &#039;a&#039;, b: &#039;b&#039; }, { a: &#039;aa&#039;, b: &#039;bb&#039; }] });

        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[t]=u&amp;a[hasOwnProperty]=c&#039;, { allowPrototypes: false }), { a: { 0: &#039;b&#039;, t: &#039;u&#039; } });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[t]=u&amp;a[hasOwnProperty]=c&#039;, { allowPrototypes: true }), { a: { 0: &#039;b&#039;, t: &#039;u&#039;, hasOwnProperty: &#039;c&#039; } });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[hasOwnProperty]=c&amp;a[x]=y&#039;, { allowPrototypes: false }), { a: { 0: &#039;b&#039;, x: &#039;y&#039; } });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[hasOwnProperty]=c&amp;a[x]=y&#039;, { allowPrototypes: true }), { a: { 0: &#039;b&#039;, hasOwnProperty: &#039;c&#039;, x: &#039;y&#039; } });
        st.end();
    });

    t.test(&#039;transforms arrays to objects (dot notation)&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo[0].baz=bar&amp;fool.bad=baz&#039;, { allowDots: true }), { foo: [{ baz: &#039;bar&#039; }], fool: { bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0].baz=bar&amp;fool.bad.boo=baz&#039;, { allowDots: true }), { foo: [{ baz: &#039;bar&#039; }], fool: { bad: { boo: &#039;baz&#039; } } });
        st.deepEqual(qs.parse(&#039;foo[0][0].baz=bar&amp;fool.bad=baz&#039;, { allowDots: true }), { foo: [[{ baz: &#039;bar&#039; }]], fool: { bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0].baz[0]=15&amp;foo[0].bar=2&#039;, { allowDots: true }), { foo: [{ baz: [&#039;15&#039;], bar: &#039;2&#039; }] });
        st.deepEqual(qs.parse(&#039;foo[0].baz[0]=15&amp;foo[0].baz[1]=16&amp;foo[0].bar=2&#039;, { allowDots: true }), { foo: [{ baz: [&#039;15&#039;, &#039;16&#039;], bar: &#039;2&#039; }] });
        st.deepEqual(qs.parse(&#039;foo.bad=baz&amp;foo[0]=bar&#039;, { allowDots: true }), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo.bad=baz&amp;foo[]=bar&#039;, { allowDots: true }), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo[]=bar&amp;foo.bad=baz&#039;, { allowDots: true }), { foo: { 0: &#039;bar&#039;, bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo.bad=baz&amp;foo[]=bar&amp;foo[]=foo&#039;, { allowDots: true }), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039;, 1: &#039;foo&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0].a=a&amp;foo[0].b=b&amp;foo[1].a=aa&amp;foo[1].b=bb&#039;, { allowDots: true }), { foo: [{ a: &#039;a&#039;, b: &#039;b&#039; }, { a: &#039;aa&#039;, b: &#039;bb&#039; }] });
        st.end();
    });

    t.test(&#039;correctly prunes undefined values when converting an array to an object&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[2]=b&amp;a[99999999]=c&#039;), { a: { 2: &#039;b&#039;, 99999999: &#039;c&#039; } });
        st.end();
    });

    t.test(&#039;supports malformed uri characters&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;{%:%}&#039;, { strictNullHandling: true }), { &#039;{%:%}&#039;: null });
        st.deepEqual(qs.parse(&#039;{%:%}=&#039;), { &#039;{%:%}&#039;: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=%:%}&#039;), { foo: &#039;%:%}&#039; });
        st.end();
    });

    t.test(&#039;doesn\&#039;t produce empty keys&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;_r=1&amp;&#039;), { _r: &#039;1&#039; });
        st.end();
    });

    t.test(&#039;cannot access Object prototype&#039;, function (st) {
        qs.parse(&#039;constructor[prototype][bad]=bad&#039;);
        qs.parse(&#039;bad[constructor][prototype][bad]=bad&#039;);
        st.equal(typeof Object.prototype.bad, &#039;undefined&#039;);
        st.end();
    });

    t.test(&#039;parses arrays of objects&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[][b]=c&#039;), { a: [{ b: &#039;c&#039; }] });
        st.deepEqual(qs.parse(&#039;a[0][b]=c&#039;), { a: [{ b: &#039;c&#039; }] });
        st.end();
    });

    t.test(&#039;allows for empty strings in arrays&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;] });

        st.deepEqual(
            qs.parse(&#039;a[0]=b&amp;a[1]&amp;a[2]=c&amp;a[19]=&#039;, { strictNullHandling: true, arrayLimit: 20 }),
            { a: [&#039;b&#039;, null, &#039;c&#039;, &#039;&#039;] },
            &#039;with arrayLimit 20 + array indices: null then empty string works&#039;
        );
        st.deepEqual(
            qs.parse(&#039;a[]=b&amp;a[]&amp;a[]=c&amp;a[]=&#039;, { strictNullHandling: true, arrayLimit: 0 }),
            { a: [&#039;b&#039;, null, &#039;c&#039;, &#039;&#039;] },
            &#039;with arrayLimit 0 + array brackets: null then empty string works&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[0]=b&amp;a[1]=&amp;a[2]=c&amp;a[19]&#039;, { strictNullHandling: true, arrayLimit: 20 }),
            { a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;, null] },
            &#039;with arrayLimit 20 + array indices: empty string then null works&#039;
        );
        st.deepEqual(
            qs.parse(&#039;a[]=b&amp;a[]=&amp;a[]=c&amp;a[]&#039;, { strictNullHandling: true, arrayLimit: 0 }),
            { a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;, null] },
            &#039;with arrayLimit 0 + array brackets: empty string then null works&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[]=&amp;a[]=b&amp;a[]=c&#039;),
            { a: [&#039;&#039;, &#039;b&#039;, &#039;c&#039;] },
            &#039;array brackets: empty strings work&#039;
        );
        st.end();
    });

    t.test(&#039;compacts sparse arrays&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[10]=1&amp;a[2]=2&#039;, { arrayLimit: 20 }), { a: [&#039;2&#039;, &#039;1&#039;] });
        st.deepEqual(qs.parse(&#039;a[1][b][2][c]=1&#039;, { arrayLimit: 20 }), { a: [{ b: [{ c: &#039;1&#039; }] }] });
        st.deepEqual(qs.parse(&#039;a[1][2][3][c]=1&#039;, { arrayLimit: 20 }), { a: [[[{ c: &#039;1&#039; }]]] });
        st.deepEqual(qs.parse(&#039;a[1][2][3][c][1]=1&#039;, { arrayLimit: 20 }), { a: [[[{ c: [&#039;1&#039;] }]]] });
        st.end();
    });

    t.test(&#039;parses sparse arrays&#039;, function (st) {
        /* eslint no-sparse-arrays: 0 */
        st.deepEqual(qs.parse(&#039;a[4]=1&amp;a[1]=2&#039;, { allowSparse: true }), { a: [, &#039;2&#039;, , , &#039;1&#039;] });
        st.deepEqual(qs.parse(&#039;a[1][b][2][c]=1&#039;, { allowSparse: true }), { a: [, { b: [, , { c: &#039;1&#039; }] }] });
        st.deepEqual(qs.parse(&#039;a[1][2][3][c]=1&#039;, { allowSparse: true }), { a: [, [, , [, , , { c: &#039;1&#039; }]]] });
        st.deepEqual(qs.parse(&#039;a[1][2][3][c][1]=1&#039;, { allowSparse: true }), { a: [, [, , [, , , { c: [, &#039;1&#039;] }]]] });
        st.end();
    });

    t.test(&#039;parses semi-parsed strings&#039;, function (st) {
        st.deepEqual(qs.parse({ &#039;a[b]&#039;: &#039;c&#039; }), { a: { b: &#039;c&#039; } });
        st.deepEqual(qs.parse({ &#039;a[b]&#039;: &#039;c&#039;, &#039;a[d]&#039;: &#039;e&#039; }), { a: { b: &#039;c&#039;, d: &#039;e&#039; } });
        st.end();
    });

    t.test(&#039;parses buffers correctly&#039;, function (st) {
        var b = SaferBuffer.from(&#039;test&#039;);
        st.deepEqual(qs.parse({ a: b }), { a: b });
        st.end();
    });

    t.test(&#039;parses jquery-param strings&#039;, function (st) {
        // readable = &#039;filter[0][]=int1&amp;filter[0][]==&amp;filter[0][]=77&amp;filter[]=and&amp;filter[2][]=int2&amp;filter[2][]==&amp;filter[2][]=8&#039;
        var encoded = &#039;filter%5B0%5D%5B%5D=int1&amp;filter%5B0%5D%5B%5D=%3D&amp;filter%5B0%5D%5B%5D=77&amp;filter%5B%5D=and&amp;filter%5B2%5D%5B%5D=int2&amp;filter%5B2%5D%5B%5D=%3D&amp;filter%5B2%5D%5B%5D=8&#039;;
        var expected = { filter: [[&#039;int1&#039;, &#039;=&#039;, &#039;77&#039;], &#039;and&#039;, [&#039;int2&#039;, &#039;=&#039;, &#039;8&#039;]] };
        st.deepEqual(qs.parse(encoded), expected);
        st.end();
    });

    t.test(&#039;continues parsing when no parent is found&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;[]=&amp;a=b&#039;), { 0: &#039;&#039;, a: &#039;b&#039; });
        st.deepEqual(qs.parse(&#039;[]&amp;a=b&#039;, { strictNullHandling: true }), { 0: null, a: &#039;b&#039; });
        st.deepEqual(qs.parse(&#039;[foo]=bar&#039;), { foo: &#039;bar&#039; });
        st.end();
    });

    t.test(&#039;does not error when parsing a very long array&#039;, function (st) {
        var str = &#039;a[]=a&#039;;
        while (Buffer.byteLength(str) &lt; 128 * 1024) {
            str = str + &#039;&amp;&#039; + str;
        }

        st.doesNotThrow(function () {
            qs.parse(str);
        });

        st.end();
    });

    t.test(&#039;should not throw when a native prototype has an enumerable property&#039;, function (st) {
        st.intercept(Object.prototype, &#039;crash&#039;, { value: &#039;&#039; });
        st.intercept(Array.prototype, &#039;crash&#039;, { value: &#039;&#039; });

        st.doesNotThrow(qs.parse.bind(null, &#039;a=b&#039;));
        st.deepEqual(qs.parse(&#039;a=b&#039;), { a: &#039;b&#039; });
        st.doesNotThrow(qs.parse.bind(null, &#039;a[][b]=c&#039;));
        st.deepEqual(qs.parse(&#039;a[][b]=c&#039;), { a: [{ b: &#039;c&#039; }] });

        st.end();
    });

    t.test(&#039;parses a string with an alternative string delimiter&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b;c=d&#039;, { delimiter: &#039;;&#039; }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;parses a string with an alternative RegExp delimiter&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b; c=d&#039;, { delimiter: /[;,] */ }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;does not use non-splittable objects as delimiters&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;c=d&#039;, { delimiter: true }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;allows overriding parameter limit&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;c=d&#039;, { parameterLimit: 1 }), { a: &#039;b&#039; });
        st.end();
    });

    t.test(&#039;allows setting the parameter limit to Infinity&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;c=d&#039;, { parameterLimit: Infinity }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;allows overriding array limit&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[0]=b&#039;, { arrayLimit: -1 }), { a: { 0: &#039;b&#039; } });
        st.deepEqual(qs.parse(&#039;a[0]=b&#039;, { arrayLimit: 0 }), { a: [&#039;b&#039;] });

        st.deepEqual(qs.parse(&#039;a[-1]=b&#039;, { arrayLimit: -1 }), { a: { &#039;-1&#039;: &#039;b&#039; } });
        st.deepEqual(qs.parse(&#039;a[-1]=b&#039;, { arrayLimit: 0 }), { a: { &#039;-1&#039;: &#039;b&#039; } });

        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { arrayLimit: -1 }), { a: { 0: &#039;b&#039;, 1: &#039;c&#039; } });
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { arrayLimit: 0 }), { a: { 0: &#039;b&#039;, 1: &#039;c&#039; } });

        st.end();
    });

    t.test(&#039;allows disabling array parsing&#039;, function (st) {
        var indices = qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { parseArrays: false });
        st.deepEqual(indices, { a: { 0: &#039;b&#039;, 1: &#039;c&#039; } });
        st.equal(Array.isArray(indices.a), false, &#039;parseArrays:false, indices case is not an array&#039;);

        var emptyBrackets = qs.parse(&#039;a[]=b&#039;, { parseArrays: false });
        st.deepEqual(emptyBrackets, { a: { 0: &#039;b&#039; } });
        st.equal(Array.isArray(emptyBrackets.a), false, &#039;parseArrays:false, empty brackets case is not an array&#039;);

        st.end();
    });

    t.test(&#039;allows for query string prefix&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;?foo=bar&#039;, { ignoreQueryPrefix: true }), { foo: &#039;bar&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&#039;, { ignoreQueryPrefix: true }), { foo: &#039;bar&#039; });
        st.deepEqual(qs.parse(&#039;?foo=bar&#039;, { ignoreQueryPrefix: false }), { &#039;?foo&#039;: &#039;bar&#039; });

        st.end();
    });

    t.test(&#039;parses an object&#039;, function (st) {
        var input = {
            &#039;user[name]&#039;: { &#039;pop[bob]&#039;: 3 },
            &#039;user[email]&#039;: null
        };

        var expected = {
            user: {
                name: { &#039;pop[bob]&#039;: 3 },
                email: null
            }
        };

        var result = qs.parse(input);

        st.deepEqual(result, expected);
        st.end();
    });

    t.test(&#039;parses string with comma as array divider&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo=bar,tee&#039;, { comma: true }), { foo: [&#039;bar&#039;, &#039;tee&#039;] });
        st.deepEqual(qs.parse(&#039;foo[bar]=coffee,tee&#039;, { comma: true }), { foo: { bar: [&#039;coffee&#039;, &#039;tee&#039;] } });
        st.deepEqual(qs.parse(&#039;foo=&#039;, { comma: true }), { foo: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo&#039;, { comma: true }), { foo: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo&#039;, { comma: true, strictNullHandling: true }), { foo: null });

        // test cases inversed from from stringify tests
        st.deepEqual(qs.parse(&#039;a[0]=c&#039;), { a: [&#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=c&#039;), { a: [&#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=c&#039;, { comma: true }), { a: [&#039;c&#039;] });

        st.deepEqual(qs.parse(&#039;a[0]=c&amp;a[1]=d&#039;), { a: [&#039;c&#039;, &#039;d&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=c&amp;a[]=d&#039;), { a: [&#039;c&#039;, &#039;d&#039;] });
        st.deepEqual(qs.parse(&#039;a=c,d&#039;, { comma: true }), { a: [&#039;c&#039;, &#039;d&#039;] });

        st.end();
    });

    t.test(&#039;parses values with comma as array divider&#039;, function (st) {
        st.deepEqual(qs.parse({ foo: &#039;bar,tee&#039; }, { comma: false }), { foo: &#039;bar,tee&#039; });
        st.deepEqual(qs.parse({ foo: &#039;bar,tee&#039; }, { comma: true }), { foo: [&#039;bar&#039;, &#039;tee&#039;] });
        st.end();
    });

    t.test(&#039;use number decoder, parses string that has one number with comma option enabled&#039;, function (st) {
        var decoder = function (str, defaultDecoder, charset, type) {
            if (!isNaN(Number(str))) {
                return parseFloat(str);
            }
            return defaultDecoder(str, defaultDecoder, charset, type);
        };

        st.deepEqual(qs.parse(&#039;foo=1&#039;, { comma: true, decoder: decoder }), { foo: 1 });
        st.deepEqual(qs.parse(&#039;foo=0&#039;, { comma: true, decoder: decoder }), { foo: 0 });

        st.end();
    });

    t.test(&#039;parses brackets holds array of arrays when having two parts of strings with comma as array divider&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo[]=1,2,3&amp;foo[]=4,5,6&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], [&#039;4&#039;, &#039;5&#039;, &#039;6&#039;]] });
        st.deepEqual(qs.parse(&#039;foo[]=1,2,3&amp;foo[]=&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], &#039;&#039;] });
        st.deepEqual(qs.parse(&#039;foo[]=1,2,3&amp;foo[]=,&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], [&#039;&#039;, &#039;&#039;]] });
        st.deepEqual(qs.parse(&#039;foo[]=1,2,3&amp;foo[]=a&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], &#039;a&#039;] });

        st.end();
    });

    t.test(&#039;parses url-encoded brackets holds array of arrays when having two parts of strings with comma as array divider&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo%5B%5D=1,2,3&amp;foo%5B%5D=4,5,6&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], [&#039;4&#039;, &#039;5&#039;, &#039;6&#039;]] });
        st.deepEqual(qs.parse(&#039;foo%5B%5D=1,2,3&amp;foo%5B%5D=&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], &#039;&#039;] });
        st.deepEqual(qs.parse(&#039;foo%5B%5D=1,2,3&amp;foo%5B%5D=,&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], [&#039;&#039;, &#039;&#039;]] });
        st.deepEqual(qs.parse(&#039;foo%5B%5D=1,2,3&amp;foo%5B%5D=a&#039;, { comma: true }), { foo: [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], &#039;a&#039;] });

        st.end();
    });

    t.test(&#039;parses comma delimited array while having percent-encoded comma treated as normal text&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo=a%2Cb&#039;, { comma: true }), { foo: &#039;a,b&#039; });
        st.deepEqual(qs.parse(&#039;foo=a%2C%20b,d&#039;, { comma: true }), { foo: [&#039;a, b&#039;, &#039;d&#039;] });
        st.deepEqual(qs.parse(&#039;foo=a%2C%20b,c%2C%20d&#039;, { comma: true }), { foo: [&#039;a, b&#039;, &#039;c, d&#039;] });

        st.end();
    });

    t.test(&#039;parses an object in dot notation&#039;, function (st) {
        var input = {
            &#039;user.name&#039;: { &#039;pop[bob]&#039;: 3 },
            &#039;user.email.&#039;: null
        };

        var expected = {
            user: {
                name: { &#039;pop[bob]&#039;: 3 },
                email: null
            }
        };

        var result = qs.parse(input, { allowDots: true });

        st.deepEqual(result, expected);
        st.end();
    });

    t.test(&#039;parses an object and not child values&#039;, function (st) {
        var input = {
            &#039;user[name]&#039;: { &#039;pop[bob]&#039;: { test: 3 } },
            &#039;user[email]&#039;: null
        };

        var expected = {
            user: {
                name: { &#039;pop[bob]&#039;: { test: 3 } },
                email: null
            }
        };

        var result = qs.parse(input);

        st.deepEqual(result, expected);
        st.end();
    });

    t.test(&#039;does not blow up when Buffer global is missing&#039;, function (st) {
        var restore = mockProperty(global, &#039;Buffer&#039;, { &#039;delete&#039;: true });

        var result = qs.parse(&#039;a=b&amp;c=d&#039;);

        restore();

        st.deepEqual(result, { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;does not crash when parsing circular references&#039;, function (st) {
        var a = {};
        a.b = a;

        var parsed;

        st.doesNotThrow(function () {
            parsed = qs.parse({ &#039;foo[bar]&#039;: &#039;baz&#039;, &#039;foo[baz]&#039;: a });
        });

        st.equal(&#039;foo&#039; in parsed, true, &#039;parsed has &quot;foo&quot; property&#039;);
        st.equal(&#039;bar&#039; in parsed.foo, true);
        st.equal(&#039;baz&#039; in parsed.foo, true);
        st.equal(parsed.foo.bar, &#039;baz&#039;);
        st.deepEqual(parsed.foo.baz, a);
        st.end();
    });

    t.test(&#039;does not crash when parsing deep objects&#039;, function (st) {
        var parsed;
        var str = &#039;foo&#039;;

        for (var i = 0; i &lt; 5000; i++) {
            str += &#039;[p]&#039;;
        }

        str += &#039;=bar&#039;;

        st.doesNotThrow(function () {
            parsed = qs.parse(str, { depth: 5000 });
        });

        st.equal(&#039;foo&#039; in parsed, true, &#039;parsed has &quot;foo&quot; property&#039;);

        var depth = 0;
        var ref = parsed.foo;
        while ((ref = ref.p)) {
            depth += 1;
        }

        st.equal(depth, 5000, &#039;parsed is 5000 properties deep&#039;);

        st.end();
    });

    t.test(&#039;parses null objects correctly&#039;, { skip: !Object.create }, function (st) {
        var a = Object.create(null);
        a.b = &#039;c&#039;;

        st.deepEqual(qs.parse(a), { b: &#039;c&#039; });
        var result = qs.parse({ a: a });
        st.equal(&#039;a&#039; in result, true, &#039;result has &quot;a&quot; property&#039;);
        st.deepEqual(result.a, a);
        st.end();
    });

    t.test(&#039;parses dates correctly&#039;, function (st) {
        var now = new Date();
        st.deepEqual(qs.parse({ a: now }), { a: now });
        st.end();
    });

    t.test(&#039;parses regular expressions correctly&#039;, function (st) {
        var re = /^test$/;
        st.deepEqual(qs.parse({ a: re }), { a: re });
        st.end();
    });

    t.test(&#039;does not allow overwriting prototype properties&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[hasOwnProperty]=b&#039;, { allowPrototypes: false }), {});
        st.deepEqual(qs.parse(&#039;hasOwnProperty=b&#039;, { allowPrototypes: false }), {});

        st.deepEqual(
            qs.parse(&#039;toString&#039;, { allowPrototypes: false }),
            {},
            &#039;bare &quot;toString&quot; results in {}&#039;
        );

        st.end();
    });

    t.test(&#039;can allow overwriting prototype properties&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[hasOwnProperty]=b&#039;, { allowPrototypes: true }), { a: { hasOwnProperty: &#039;b&#039; } });
        st.deepEqual(qs.parse(&#039;hasOwnProperty=b&#039;, { allowPrototypes: true }), { hasOwnProperty: &#039;b&#039; });

        st.deepEqual(
            qs.parse(&#039;toString&#039;, { allowPrototypes: true }),
            { toString: &#039;&#039; },
            &#039;bare &quot;toString&quot; results in { toString: &quot;&quot; }&#039;
        );

        st.end();
    });

    t.test(&#039;does not crash when the global Object prototype is frozen&#039;, { skip: !hasPropertyDescriptors || !hasOverrideMistake }, function (st) {
        // We can&#039;t actually freeze the global Object prototype as that will interfere with other tests, and once an object is frozen, it
        // can&#039;t be unfrozen. Instead, we add a new non-writable property to simulate this.
        st.teardown(mockProperty(Object.prototype, &#039;frozenProp&#039;, { value: &#039;foo&#039;, nonWritable: true, nonEnumerable: true }));

        st[&#039;throws&#039;](
            function () {
                var obj = {};
                obj.frozenProp = &#039;bar&#039;;
            },
            // node &lt; 6 has a different error message
            /^TypeError: Cannot assign to read only property &#039;frozenProp&#039; of (?:object &#039;#&lt;Object&gt;&#039;|#&lt;Object&gt;)/,
            &#039;regular assignment of an inherited non-writable property throws&#039;
        );

        var parsed;
        st.doesNotThrow(
            function () {
                parsed = qs.parse(&#039;frozenProp&#039;, { allowPrototypes: false });
            },
            &#039;parsing a nonwritable Object.prototype property does not throw&#039;
        );

        st.deepEqual(parsed, {}, &#039;bare &quot;frozenProp&quot; results in {}&#039;);

        st.end();
    });

    t.test(&#039;params starting with a closing bracket&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;]=toString&#039;), { &#039;]&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;]]=toString&#039;), { &#039;]]&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;]hello]=toString&#039;), { &#039;]hello]&#039;: &#039;toString&#039; });
        st.end();
    });

    t.test(&#039;params starting with a starting bracket&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;[=toString&#039;), { &#039;[&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;[[=toString&#039;), { &#039;[[&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;[hello[=toString&#039;), { &#039;[hello[&#039;: &#039;toString&#039; });
        st.end();
    });

    t.test(&#039;add keys to objects&#039;, function (st) {
        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=d&#039;),
            { a: { b: &#039;c&#039;, d: true } },
            &#039;can add keys to objects&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=toString&#039;),
            { a: { b: &#039;c&#039; } },
            &#039;can not overwrite prototype&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=toString&#039;, { allowPrototypes: true }),
            { a: { b: &#039;c&#039;, toString: true } },
            &#039;can overwrite prototype with allowPrototypes true&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=toString&#039;, { plainObjects: true }),
            { __proto__: null, a: { __proto__: null, b: &#039;c&#039;, toString: true } },
            &#039;can overwrite prototype with plainObjects true&#039;
        );

        st.end();
    });

    t.test(&#039;dunder proto is ignored&#039;, function (st) {
        var payload = &#039;categories[__proto__]=login&amp;categories[__proto__]&amp;categories[length]=42&#039;;
        var result = qs.parse(payload, { allowPrototypes: true });

        st.deepEqual(
            result,
            {
                categories: {
                    length: &#039;42&#039;
                }
            },
            &#039;silent [[Prototype]] payload&#039;
        );

        var plainResult = qs.parse(payload, { allowPrototypes: true, plainObjects: true });

        st.deepEqual(
            plainResult,
            {
                __proto__: null,
                categories: {
                    __proto__: null,
                    length: &#039;42&#039;
                }
            },
            &#039;silent [[Prototype]] payload: plain objects&#039;
        );

        var query = qs.parse(&#039;categories[__proto__]=cats&amp;categories[__proto__]=dogs&amp;categories[some][json]=toInject&#039;, { allowPrototypes: true });

        st.notOk(Array.isArray(query.categories), &#039;is not an array&#039;);
        st.notOk(query.categories instanceof Array, &#039;is not instanceof an array&#039;);
        st.deepEqual(query.categories, { some: { json: &#039;toInject&#039; } });
        st.equal(JSON.stringify(query.categories), &#039;{&quot;some&quot;:{&quot;json&quot;:&quot;toInject&quot;}}&#039;, &#039;stringifies as a non-array&#039;);

        st.deepEqual(
            qs.parse(&#039;foo[__proto__][hidden]=value&amp;foo[bar]=stuffs&#039;, { allowPrototypes: true }),
            {
                foo: {
                    bar: &#039;stuffs&#039;
                }
            },
            &#039;hidden values&#039;
        );

        st.deepEqual(
            qs.parse(&#039;foo[__proto__][hidden]=value&amp;foo[bar]=stuffs&#039;, { allowPrototypes: true, plainObjects: true }),
            {
                __proto__: null,
                foo: {
                    __proto__: null,
                    bar: &#039;stuffs&#039;
                }
            },
            &#039;hidden values: plain objects&#039;
        );

        st.end();
    });

    t.test(&#039;can return null objects&#039;, { skip: !Object.create }, function (st) {
        var expected = Object.create(null);
        expected.a = Object.create(null);
        expected.a.b = &#039;c&#039;;
        expected.a.hasOwnProperty = &#039;d&#039;;
        st.deepEqual(qs.parse(&#039;a[b]=c&amp;a[hasOwnProperty]=d&#039;, { plainObjects: true }), expected);
        st.deepEqual(qs.parse(null, { plainObjects: true }), Object.create(null));
        var expectedArray = Object.create(null);
        expectedArray.a = Object.create(null);
        expectedArray.a[0] = &#039;b&#039;;
        expectedArray.a.c = &#039;d&#039;;
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[c]=d&#039;, { plainObjects: true }), expectedArray);
        st.end();
    });

    t.test(&#039;can parse with custom encoding&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;%8c%a7=%91%e5%8d%e3%95%7b&#039;, {
            decoder: function (str) {
                var reg = /%([0-9A-F]{2})/ig;
                var result = [];
                var parts = reg.exec(str);
                while (parts) {
                    result.push(parseInt(parts[1], 16));
                    parts = reg.exec(str);
                }
                return String(iconv.decode(SaferBuffer.from(result), &#039;shift_jis&#039;));
            }
        }), { 県: &#039;大阪府&#039; });
        st.end();
    });

    t.test(&#039;receives the default decoder as a second argument&#039;, function (st) {
        st.plan(1);
        qs.parse(&#039;a&#039;, {
            decoder: function (str, defaultDecoder) {
                st.equal(defaultDecoder, utils.decode);
            }
        });
        st.end();
    });

    t.test(&#039;throws error with wrong decoder&#039;, function (st) {
        st[&#039;throws&#039;](function () {
            qs.parse({}, { decoder: &#039;string&#039; });
        }, new TypeError(&#039;Decoder has to be a function.&#039;));
        st.end();
    });

    t.test(&#039;does not mutate the options argument&#039;, function (st) {
        var options = {};
        qs.parse(&#039;a[b]=true&#039;, options);
        st.deepEqual(options, {});
        st.end();
    });

    t.test(&#039;throws if an invalid charset is specified&#039;, function (st) {
        st[&#039;throws&#039;](function () {
            qs.parse(&#039;a=b&#039;, { charset: &#039;foobar&#039; });
        }, new TypeError(&#039;The charset option must be either utf-8, iso-8859-1, or undefined&#039;));
        st.end();
    });

    t.test(&#039;parses an iso-8859-1 string if asked to&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;%A2=%BD&#039;, { charset: &#039;iso-8859-1&#039; }), { &#039;¢&#039;: &#039;½&#039; });
        st.end();
    });

    var urlEncodedCheckmarkInUtf8 = &#039;%E2%9C%93&#039;;
    var urlEncodedOSlashInUtf8 = &#039;%C3%B8&#039;;
    var urlEncodedNumCheckmark = &#039;%26%2310003%3B&#039;;
    var urlEncodedNumSmiley = &#039;%26%239786%3B&#039;;

    t.test(&#039;prefers an utf-8 charset specified by the utf8 sentinel to a default charset of iso-8859-1&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;utf8=&#039; + urlEncodedCheckmarkInUtf8 + &#039;&amp;&#039; + urlEncodedOSlashInUtf8 + &#039;=&#039; + urlEncodedOSlashInUtf8, { charsetSentinel: true, charset: &#039;iso-8859-1&#039; }), { ø: &#039;ø&#039; });
        st.end();
    });

    t.test(&#039;prefers an iso-8859-1 charset specified by the utf8 sentinel to a default charset of utf-8&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;utf8=&#039; + urlEncodedNumCheckmark + &#039;&amp;&#039; + urlEncodedOSlashInUtf8 + &#039;=&#039; + urlEncodedOSlashInUtf8, { charsetSentinel: true, charset: &#039;utf-8&#039; }), { &#039;Ã¸&#039;: &#039;Ã¸&#039; });
        st.end();
    });

    t.test(&#039;does not require the utf8 sentinel to be defined before the parameters whose decoding it affects&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=&#039; + urlEncodedOSlashInUtf8 + &#039;&amp;utf8=&#039; + urlEncodedNumCheckmark, { charsetSentinel: true, charset: &#039;utf-8&#039; }), { a: &#039;Ã¸&#039; });
        st.end();
    });

    t.test(&#039;should ignore an utf8 sentinel with an unknown value&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;utf8=foo&amp;&#039; + urlEncodedOSlashInUtf8 + &#039;=&#039; + urlEncodedOSlashInUtf8, { charsetSentinel: true, charset: &#039;utf-8&#039; }), { ø: &#039;ø&#039; });
        st.end();
    });

    t.test(&#039;uses the utf8 sentinel to switch to utf-8 when no default charset is given&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;utf8=&#039; + urlEncodedCheckmarkInUtf8 + &#039;&amp;&#039; + urlEncodedOSlashInUtf8 + &#039;=&#039; + urlEncodedOSlashInUtf8, { charsetSentinel: true }), { ø: &#039;ø&#039; });
        st.end();
    });

    t.test(&#039;uses the utf8 sentinel to switch to iso-8859-1 when no default charset is given&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;utf8=&#039; + urlEncodedNumCheckmark + &#039;&amp;&#039; + urlEncodedOSlashInUtf8 + &#039;=&#039; + urlEncodedOSlashInUtf8, { charsetSentinel: true }), { &#039;Ã¸&#039;: &#039;Ã¸&#039; });
        st.end();
    });

    t.test(&#039;interprets numeric entities in iso-8859-1 when `interpretNumericEntities`&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo=&#039; + urlEncodedNumSmiley, { charset: &#039;iso-8859-1&#039;, interpretNumericEntities: true }), { foo: &#039;☺&#039; });
        st.end();
    });

    t.test(&#039;handles a custom decoder returning `null`, in the `iso-8859-1` charset, when `interpretNumericEntities`&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo=&amp;bar=&#039; + urlEncodedNumSmiley, {
            charset: &#039;iso-8859-1&#039;,
            decoder: function (str, defaultDecoder, charset) {
                return str ? defaultDecoder(str, defaultDecoder, charset) : null;
            },
            interpretNumericEntities: true
        }), { foo: null, bar: &#039;☺&#039; });
        st.end();
    });

    t.test(&#039;does not interpret numeric entities in iso-8859-1 when `interpretNumericEntities` is absent&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo=&#039; + urlEncodedNumSmiley, { charset: &#039;iso-8859-1&#039; }), { foo: &#039;&amp;#9786;&#039; });
        st.end();
    });

    t.test(&#039;does not interpret numeric entities when the charset is utf-8, even when `interpretNumericEntities`&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo=&#039; + urlEncodedNumSmiley, { charset: &#039;utf-8&#039;, interpretNumericEntities: true }), { foo: &#039;&amp;#9786;&#039; });
        st.end();
    });

    t.test(&#039;does not interpret %uXXXX syntax in iso-8859-1 mode&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;%u263A=%u263A&#039;, { charset: &#039;iso-8859-1&#039; }), { &#039;%u263A&#039;: &#039;%u263A&#039; });
        st.end();
    });

    t.test(&#039;allows for decoding keys and values differently&#039;, function (st) {
        var decoder = function (str, defaultDecoder, charset, type) {
            if (type === &#039;key&#039;) {
                return defaultDecoder(str, defaultDecoder, charset, type).toLowerCase();
            }
            if (type === &#039;value&#039;) {
                return defaultDecoder(str, defaultDecoder, charset, type).toUpperCase();
            }
            throw &#039;this should never happen! type: &#039; + type;
        };

        st.deepEqual(qs.parse(&#039;KeY=vAlUe&#039;, { decoder: decoder }), { key: &#039;VALUE&#039; });
        st.end();
    });

    t.end();
});

test(&#039;parses empty keys&#039;, function (t) {
    emptyTestCases.forEach(function (testCase) {
        t.test(&#039;skips empty string key with &#039; + testCase.input, function (st) {
            st.deepEqual(qs.parse(testCase.input), testCase.noEmptyKeys);

            st.end();
        });
    });
});

test(&#039;`duplicates` option&#039;, function (t) {
    v.nonStrings.concat(&#039;not a valid option&#039;).forEach(function (invalidOption) {
        if (typeof invalidOption !== &#039;undefined&#039;) {
            t[&#039;throws&#039;](
                function () { qs.parse(&#039;&#039;, { duplicates: invalidOption }); },
                TypeError,
                &#039;throws on invalid option: &#039; + inspect(invalidOption)
            );
        }
    });

    t.deepEqual(
        qs.parse(&#039;foo=bar&amp;foo=baz&#039;),
        { foo: [&#039;bar&#039;, &#039;baz&#039;] },
        &#039;duplicates: default, combine&#039;
    );

    t.deepEqual(
        qs.parse(&#039;foo=bar&amp;foo=baz&#039;, { duplicates: &#039;combine&#039; }),
        { foo: [&#039;bar&#039;, &#039;baz&#039;] },
        &#039;duplicates: combine&#039;
    );

    t.deepEqual(
        qs.parse(&#039;foo=bar&amp;foo=baz&#039;, { duplicates: &#039;first&#039; }),
        { foo: &#039;bar&#039; },
        &#039;duplicates: first&#039;
    );

    t.deepEqual(
        qs.parse(&#039;foo=bar&amp;foo=baz&#039;, { duplicates: &#039;last&#039; }),
        { foo: &#039;baz&#039; },
        &#039;duplicates: last&#039;
    );

    t.end();
});

test(&#039;qs strictDepth option - throw cases&#039;, function (t) {
    t.test(&#039;throws an exception when depth exceeds the limit with strictDepth: true&#039;, function (st) {
        st[&#039;throws&#039;](
            function () {
                qs.parse(&#039;a[b][c][d][e][f][g][h][i]=j&#039;, { depth: 1, strictDepth: true });
            },
            RangeError,
            &#039;Should throw RangeError&#039;
        );
        st.end();
    });

    t.test(&#039;throws an exception for multiple nested arrays with strictDepth: true&#039;, function (st) {
        st[&#039;throws&#039;](
            function () {
                qs.parse(&#039;a[0][1][2][3][4]=b&#039;, { depth: 3, strictDepth: true });
            },
            RangeError,
            &#039;Should throw RangeError&#039;
        );
        st.end();
    });

    t.test(&#039;throws an exception for nested objects and arrays with strictDepth: true&#039;, function (st) {
        st[&#039;throws&#039;](
            function () {
                qs.parse(&#039;a[b][c][0][d][e]=f&#039;, { depth: 3, strictDepth: true });
            },
            RangeError,
            &#039;Should throw RangeError&#039;
        );
        st.end();
    });

    t.test(&#039;throws an exception for different types of values with strictDepth: true&#039;, function (st) {
        st[&#039;throws&#039;](
            function () {
                qs.parse(&#039;a[b][c][d][e]=true&amp;a[b][c][d][f]=42&#039;, { depth: 3, strictDepth: true });
            },
            RangeError,
            &#039;Should throw RangeError&#039;
        );
        st.end();
    });

});

test(&#039;qs strictDepth option - non-throw cases&#039;, function (t) {
    t.test(&#039;when depth is 0 and strictDepth true, do not throw&#039;, function (st) {
        st.doesNotThrow(
            function () {
                qs.parse(&#039;a[b][c][d][e]=true&amp;a[b][c][d][f]=42&#039;, { depth: 0, strictDepth: true });
            },
            RangeError,
            &#039;Should not throw RangeError&#039;
        );
        st.end();
    });

    t.test(&#039;parses successfully when depth is within the limit with strictDepth: true&#039;, function (st) {
        st.doesNotThrow(
            function () {
                var result = qs.parse(&#039;a[b]=c&#039;, { depth: 1, strictDepth: true });
                st.deepEqual(result, { a: { b: &#039;c&#039; } }, &#039;Should parse correctly&#039;);
            }
        );
        st.end();
    });

    t.test(&#039;does not throw an exception when depth exceeds the limit with strictDepth: false&#039;, function (st) {
        st.doesNotThrow(
            function () {
                var result = qs.parse(&#039;a[b][c][d][e][f][g][h][i]=j&#039;, { depth: 1 });
                st.deepEqual(result, { a: { b: { &#039;[c][d][e][f][g][h][i]&#039;: &#039;j&#039; } } }, &#039;Should parse with depth limit&#039;);
            }
        );
        st.end();
    });

    t.test(&#039;parses successfully when depth is within the limit with strictDepth: false&#039;, function (st) {
        st.doesNotThrow(
            function () {
                var result = qs.parse(&#039;a[b]=c&#039;, { depth: 1 });
                st.deepEqual(result, { a: { b: &#039;c&#039; } }, &#039;Should parse correctly&#039;);
            }
        );
        st.end();
    });

    t.test(&#039;does not throw when depth is exactly at the limit with strictDepth: true&#039;, function (st) {
        st.doesNotThrow(
            function () {
                var result = qs.parse(&#039;a[b][c]=d&#039;, { depth: 2, strictDepth: true });
                st.deepEqual(result, { a: { b: { c: &#039;d&#039; } } }, &#039;Should parse correctly&#039;);
            }
        );
        st.end();
    });
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
