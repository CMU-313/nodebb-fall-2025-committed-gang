<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cron/dist/job.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cron/dist/job.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">247</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">95.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.CronJob = void 0;
const child_process_1 = require(&quot;child_process&quot;);
const errors_1 = require(&quot;./errors&quot;);
const time_1 = require(&quot;./time&quot;);
class CronJob {
    get isActive() {
        return this._isActive;
    }
    get isCallbackRunning() {
        return this._isCallbackRunning;
    }
    constructor(cronTime, onTick, onComplete, start, timeZone, context, runOnInit, utcOffset, unrefTimeout, waitForCompletion, errorHandler, name, threshold) {
        this.unrefTimeout = false;
        this.lastExecution = null;
        this.runOnce = false;
        this.waitForCompletion = false;
        this.threshold = 250;
        this._isActive = false;
        this._isCallbackRunning = false;
        this._callbacks = [];
        this.context = (context !== null &amp;&amp; context !== void 0 ? context : this);
        this.waitForCompletion = Boolean(waitForCompletion);
        this.errorHandler = errorHandler;
        if (timeZone != null &amp;&amp; utcOffset != null) {
            throw new errors_1.ExclusiveParametersError(&#039;timeZone&#039;, &#039;utcOffset&#039;);
        }
        if (timeZone != null) {
            this.cronTime = new time_1.CronTime(cronTime, timeZone, null);
        }
        else if (utcOffset != null) {
            this.cronTime = new time_1.CronTime(cronTime, null, utcOffset);
        }
        else {
            this.cronTime = new time_1.CronTime(cronTime, timeZone, utcOffset);
        }
        if (unrefTimeout != null) {
            this.unrefTimeout = unrefTimeout;
        }
        if (onComplete != null) {
            this.onComplete = this._fnWrap(onComplete);
        }
        if (threshold != null) {
            this.threshold = Math.abs(threshold);
        }
        if (name != null) {
            this.name = name;
        }
        if (this.cronTime.realDate) {
            this.runOnce = true;
        }
        this.addCallback(this._fnWrap(onTick));
        if (runOnInit) {
            this.lastExecution = new Date();
            void this.fireOnTick();
        }
        if (start)
            this.start();
    }
    static from(params) {
        if (params.timeZone != null &amp;&amp; params.utcOffset != null) {
            throw new errors_1.ExclusiveParametersError(&#039;timeZone&#039;, &#039;utcOffset&#039;);
        }
        if (params.timeZone != null) {
            return new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, params.timeZone, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout, params.waitForCompletion, params.errorHandler, params.name, params.threshold);
        }
        else if (params.utcOffset != null) {
            return new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, null, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout, params.waitForCompletion, params.errorHandler, params.name, params.threshold);
        }
        else {
            return new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, params.timeZone, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout, params.waitForCompletion, params.errorHandler, params.name, params.threshold);
        }
    }
    _fnWrap(cmd) {
        var _a, _b;
        switch (typeof cmd) {
            case &#039;function&#039;: {
                return cmd;
            }
            case &#039;string&#039;: {
                const [command, ...args] = cmd.split(&#039; &#039;);
                return child_process_1.spawn.bind(undefined, command !== null &amp;&amp; command !== void 0 ? command : cmd, args, {});
            }
            case &#039;object&#039;: {
                return child_process_1.spawn.bind(undefined, cmd.command, (_a = cmd.args) !== null &amp;&amp; _a !== void 0 ? _a : [], (_b = cmd.options) !== null &amp;&amp; _b !== void 0 ? _b : {});
            }
        }
    }
    addCallback(callback) {
        if (typeof callback === &#039;function&#039;) {
            this._callbacks.push(callback);
        }
    }
    setTime(time) {
        if (!(time instanceof time_1.CronTime)) {
            throw new errors_1.CronError(&#039;time must be an instance of CronTime.&#039;);
        }
        const wasRunning = this._isActive;
        this.stop();
        this.cronTime = time;
        if (time.realDate)
            this.runOnce = true;
        if (wasRunning)
            this.start();
    }
    nextDate() {
        return this.cronTime.sendAt();
    }
    fireOnTick() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.waitForCompletion &amp;&amp; this._isCallbackRunning)
                return;
            this._isCallbackRunning = true;
            try {
                for (const callback of this._callbacks) {
                    const result = callback.call(this.context, this.onComplete);
                    if (this.waitForCompletion)
                        yield result;
                }
            }
            catch (error) {
                if (this.errorHandler != null)
                    this.errorHandler(error);
                else
                    console.error(&#039;[Cron] error in callback&#039;, error);
            }
            finally {
                this._isCallbackRunning = false;
            }
        });
    }
    nextDates(i) {
        return this.cronTime.sendAt(i !== null &amp;&amp; i !== void 0 ? i : 0);
    }
    start() {
        if (this._isActive)
            return;
        this._isActive = true;
        const MAXDELAY = 2147483647;
        let timeout = this.cronTime.getTimeout();
        let remaining = 0;
        let startTime;
        const setCronTimeout = (t) =&gt; {
            startTime = Date.now();
            this._timeout = setTimeout(callbackWrapper, t);
            if (this.unrefTimeout &amp;&amp; typeof this._timeout.unref === &#039;function&#039;) {
                this._timeout.unref();
            }
        };
        const callbackWrapper = () =&gt; {
            const diff = startTime + timeout - Date.now();
            if (diff &gt; 0) {
                let newTimeout = this.cronTime.getTimeout();
                if (newTimeout &gt; diff) {
                    newTimeout = diff;
                }
                remaining += newTimeout;
            }
            if (remaining) {
                if (remaining &gt; MAXDELAY) {
                    remaining -= MAXDELAY;
                    timeout = MAXDELAY;
                }
                else {
                    timeout = remaining;
                    remaining = 0;
                }
                setCronTimeout(timeout);
            }
            else {
                this.lastExecution = new Date();
                this._isActive = false;
                if (!this.runOnce)
                    this.start();
                void this.fireOnTick();
            }
        };
        if (timeout &gt;= 0) {
            if (timeout &gt; MAXDELAY) {
                remaining = timeout - MAXDELAY;
                timeout = MAXDELAY;
            }
            setCronTimeout(timeout);
        }
        else {
            const absoluteTimeout = Math.abs(timeout);
            const message = `[Cron] Missed execution deadline by ${absoluteTimeout}ms for job${this.name ? ` &quot;${this.name}&quot;` : &#039;&#039;} with cron expression &#039;${String(this.cronTime.source)}&#039;`;
            if (absoluteTimeout &lt;= this.threshold) {
                console.warn(`${message}. Executing immediately.`);
                this.lastExecution = new Date();
                void this.fireOnTick();
            }
            else {
                console.warn(`${message}. Skipping execution as it exceeds threshold (${this.threshold}ms).`);
            }
            timeout = this.cronTime.getTimeout();
            setCronTimeout(timeout);
        }
    }
    lastDate() {
        return this.lastExecution;
    }
    _executeOnComplete() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.onComplete !== &#039;function&#039;)
                return;
            try {
                yield this.onComplete.call(this.context);
            }
            catch (error) {
                console.error(&#039;[Cron] error in onComplete callback:&#039;, error);
            }
        });
    }
    _waitForJobCompletion() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this._isCallbackRunning) {
                yield new Promise(resolve =&gt; setTimeout(resolve, 100));
            }
        });
    }
    stop() {
        if (this._timeout)
            clearTimeout(this._timeout);
        this._isActive = false;
        if (!this.waitForCompletion) {
            void this._executeOnComplete();
            return;
        }
        return Promise.resolve().then(() =&gt; __awaiter(this, void 0, void 0, function* () {
            yield this._waitForJobCompletion();
            yield this._executeOnComplete();
        }));
    }
}
exports.CronJob = CronJob;
//# sourceMappingURL=job.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
