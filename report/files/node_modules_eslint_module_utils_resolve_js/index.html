<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint-module-utils/resolve.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint-module-utils/resolve.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">255</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">48.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

exports.__esModule = true;

const fs = require(&#039;fs&#039;);
const Module = require(&#039;module&#039;);
const path = require(&#039;path&#039;);
const { getPhysicalFilename } = require(&#039;./contextCompat&#039;);

const hashObject = require(&#039;./hash&#039;).hashObject;
const ModuleCache = require(&#039;./ModuleCache&#039;).default;
const pkgDir = require(&#039;./pkgDir&#039;).default;

const CASE_SENSITIVE_FS = !fs.existsSync(path.join(__dirname.toUpperCase(), &#039;reSOLVE.js&#039;));
exports.CASE_SENSITIVE_FS = CASE_SENSITIVE_FS;

const ERROR_NAME = &#039;EslintPluginImportResolveError&#039;;

const fileExistsCache = new ModuleCache();

// Polyfill Node&#039;s `Module.createRequireFromPath` if not present (added in Node v10.12.0)
// Use `Module.createRequire` if available (added in Node v12.2.0)
const createRequire = Module.createRequire
  // @ts-expect-error this only exists in older node
  || Module.createRequireFromPath
  || /** @type {(filename: string) =&gt; unknown} */ function (filename) {
    const mod = new Module(filename, void null);
    mod.filename = filename;
    // @ts-expect-error _nodeModulePaths is undocumented
    mod.paths = Module._nodeModulePaths(path.dirname(filename));

    // @ts-expect-error _compile is undocumented
    mod._compile(`module.exports = require;`, filename);

    return mod.exports;
  };

/** @type {(resolver: object) =&gt; resolver is import(&#039;./resolve&#039;).Resolver} */
function isResolverValid(resolver) {
  if (&#039;interfaceVersion&#039; in resolver &amp;&amp; resolver.interfaceVersion === 2) {
    return &#039;resolve&#039; in resolver &amp;&amp; !!resolver.resolve &amp;&amp; typeof resolver.resolve === &#039;function&#039;;
  }
  return &#039;resolveImport&#039; in resolver &amp;&amp; !!resolver.resolveImport &amp;&amp; typeof resolver.resolveImport === &#039;function&#039;;
}

/** @type {&lt;T extends string&gt;(target: T, sourceFile?: string | null | undefined) =&gt; undefined | ReturnType&lt;typeof require&gt;} */
function tryRequire(target, sourceFile) {
  let resolved;
  try {
    // Check if the target exists
    if (sourceFile != null) {
      try {
        resolved = createRequire(path.resolve(sourceFile)).resolve(target);
      } catch (e) {
        resolved = require.resolve(target);
      }
    } else {
      resolved = require.resolve(target);
    }
  } catch (e) {
    // If the target does not exist then just return undefined
    return undefined;
  }

  // If the target exists then return the loaded module
  return require(resolved);
}

/** @type {&lt;T extends Map&lt;string, unknown&gt;&gt;(resolvers: string[] | string | { [k: string]: string }, map: T) =&gt; T} */
function resolverReducer(resolvers, map) {
  if (Array.isArray(resolvers)) {
    resolvers.forEach((r) =&gt; resolverReducer(r, map));
    return map;
  }

  if (typeof resolvers === &#039;string&#039;) {
    map.set(resolvers, null);
    return map;
  }

  if (typeof resolvers === &#039;object&#039;) {
    for (const key in resolvers) {
      map.set(key, resolvers[key]);
    }
    return map;
  }

  const err = new Error(&#039;invalid resolver config&#039;);
  err.name = ERROR_NAME;
  throw err;
}

/** @type {(sourceFile: string) =&gt; string} */
function getBaseDir(sourceFile) {
  return pkgDir(sourceFile) || process.cwd();
}

/** @type {(name: string, sourceFile: string) =&gt; import(&#039;./resolve&#039;).Resolver} */
function requireResolver(name, sourceFile) {
  // Try to resolve package with conventional name
  const resolver = tryRequire(`eslint-import-resolver-${name}`, sourceFile)
    || tryRequire(name, sourceFile)
    || tryRequire(path.resolve(getBaseDir(sourceFile), name));

  if (!resolver) {
    const err = new Error(`unable to load resolver &quot;${name}&quot;.`);
    err.name = ERROR_NAME;
    throw err;
  }
  if (!isResolverValid(resolver)) {
    const err = new Error(`${name} with invalid interface loaded as resolver`);
    err.name = ERROR_NAME;
    throw err;
  }

  return resolver;
}

// https://stackoverflow.com/a/27382838
/** @type {import(&#039;./resolve&#039;).fileExistsWithCaseSync} */
exports.fileExistsWithCaseSync = function fileExistsWithCaseSync(filepath, cacheSettings, strict) {
  // don&#039;t care if the FS is case-sensitive
  if (CASE_SENSITIVE_FS) { return true; }

  // null means it resolved to a builtin
  if (filepath === null) { return true; }
  if (filepath.toLowerCase() === process.cwd().toLowerCase() &amp;&amp; !strict) { return true; }
  const parsedPath = path.parse(filepath);
  const dir = parsedPath.dir;

  let result = fileExistsCache.get(filepath, cacheSettings);
  if (result != null) { return result; }

  // base case
  if (dir === &#039;&#039; || parsedPath.root === filepath) {
    result = true;
  } else {
    const filenames = fs.readdirSync(dir);
    if (filenames.indexOf(parsedPath.base) === -1) {
      result = false;
    } else {
      result = fileExistsWithCaseSync(dir, cacheSettings, strict);
    }
  }
  fileExistsCache.set(filepath, result);
  return result;
};

/** @type {import(&#039;./types&#039;).ESLintSettings | null} */
let prevSettings = null;
let memoizedHash = &#039;&#039;;
/** @type {(modulePath: string, sourceFile: string, settings: import(&#039;./types&#039;).ESLintSettings) =&gt; import(&#039;./resolve&#039;).ResolvedResult} */
function fullResolve(modulePath, sourceFile, settings) {
  // check if this is a bonus core module
  const coreSet = new Set(settings[&#039;import/core-modules&#039;]);
  if (coreSet.has(modulePath)) { return { found: true, path: null }; }

  const sourceDir = path.dirname(sourceFile);

  if (prevSettings !== settings) {
    memoizedHash = hashObject(settings).digest(&#039;hex&#039;);
    prevSettings = settings;
  }

  const cacheKey = sourceDir + memoizedHash + modulePath;

  const cacheSettings = ModuleCache.getSettings(settings);

  const cachedPath = fileExistsCache.get(cacheKey, cacheSettings);
  if (cachedPath !== undefined) { return { found: true, path: cachedPath }; }

  /** @type {(resolvedPath: string | null) =&gt; void} */
  function cache(resolvedPath) {
    fileExistsCache.set(cacheKey, resolvedPath);
  }

  /** @type {(resolver: import(&#039;./resolve&#039;).Resolver, config: unknown) =&gt; import(&#039;./resolve&#039;).ResolvedResult} */
  function withResolver(resolver, config) {
    if (resolver.interfaceVersion === 2) {
      return resolver.resolve(modulePath, sourceFile, config);
    }

    try {
      const resolved = resolver.resolveImport(modulePath, sourceFile, config);
      if (resolved === undefined) { return { found: false }; }
      return { found: true, path: resolved };
    } catch (err) {
      return { found: false };
    }
  }

  const configResolvers = settings[&#039;import/resolver&#039;]
    || { node: settings[&#039;import/resolve&#039;] }; // backward compatibility

  const resolvers = resolverReducer(configResolvers, new Map());

  for (const pair of resolvers) {
    const name = pair[0];
    const config = pair[1];
    const resolver = requireResolver(name, sourceFile);
    const resolved = withResolver(resolver, config);

    if (!resolved.found) { continue; }

    // else, counts
    cache(resolved.path);
    return resolved;
  }

  // failed
  // cache(undefined)
  return { found: false };
}

/** @type {import(&#039;./resolve&#039;).relative} */
function relative(modulePath, sourceFile, settings) {
  return fullResolve(modulePath, sourceFile, settings).path;
}
exports.relative = relative;

/** @type {Set&lt;import(&#039;eslint&#039;).Rule.RuleContext&gt;} */
const erroredContexts = new Set();

/**
 * Given
 * @param p - module path
 * @param context - ESLint context
 * @return - the full module filesystem path; null if package is core; undefined if not found
 * @type {import(&#039;./resolve&#039;).default}
 */
function resolve(p, context) {
  try {
    return relative(p, getPhysicalFilename(context), context.settings);
  } catch (err) {
    if (!erroredContexts.has(context)) {
      // The `err.stack` string starts with `err.name` followed by colon and `err.message`.
      // We&#039;re filtering out the default `err.name` because it adds little value to the message.
      // @ts-expect-error this might be an Error
      let errMessage = err.message;
      // @ts-expect-error this might be an Error
      if (err.name !== ERROR_NAME &amp;&amp; err.stack) {
        // @ts-expect-error this might be an Error
        errMessage = err.stack.replace(/^Error: /, &#039;&#039;);
      }
      context.report({
        message: `Resolve error: ${errMessage}`,
        loc: { line: 1, column: 0 },
      });
      erroredContexts.add(context);
    }
  }
}
resolve.relative = relative;
exports.default = resolve;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
