<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/living/xhr/xhr-utils.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/living/xhr/xhr-utils.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">418</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.63</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
const fs = require(&quot;fs&quot;);
const { EventEmitter } = require(&quot;events&quot;);
const { URL } = require(&quot;whatwg-url&quot;);
const parseDataURL = require(&quot;data-urls&quot;);
const DOMException = require(&quot;../generated/DOMException&quot;);

const ProgressEvent = require(&quot;../generated/ProgressEvent&quot;);

const agentFactory = require(&quot;../helpers/agent-factory&quot;);
const Request = require(&quot;../helpers/http-request&quot;);
const { fireAnEvent } = require(&quot;../helpers/events&quot;);

const headerListSeparatorRegexp = /,[ \t]*/;
const simpleMethods = new Set([&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;]);
const simpleHeaders = new Set([&quot;accept&quot;, &quot;accept-language&quot;, &quot;content-language&quot;, &quot;content-type&quot;]);
const preflightHeaders = new Set([
  &quot;access-control-expose-headers&quot;,
  &quot;access-control-allow-headers&quot;,
  &quot;access-control-allow-credentials&quot;,
  &quot;access-control-allow-origin&quot;
]);

const READY_STATES = exports.READY_STATES = Object.freeze({
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
});

function getRequestHeader(requestHeaders, header) {
  const lcHeader = header.toLowerCase();
  const keys = Object.keys(requestHeaders);
  let n = keys.length;
  while (n--) {
    const key = keys[n];
    if (key.toLowerCase() === lcHeader) {
      return requestHeaders[key];
    }
  }
  return null;
}

function updateRequestHeader(requestHeaders, header, newValue) {
  const lcHeader = header.toLowerCase();
  const keys = Object.keys(requestHeaders);
  let n = keys.length;
  while (n--) {
    const key = keys[n];
    if (key.toLowerCase() === lcHeader) {
      requestHeaders[key] = newValue;
    }
  }
}

function dispatchError(xhr) {
  const errMessage = xhr.properties.error;
  requestErrorSteps(xhr, &quot;error&quot;, DOMException.create(xhr._globalObject, [errMessage, &quot;NetworkError&quot;]));

  if (xhr._ownerDocument) {
    const error = new Error(errMessage);
    error.type = &quot;XMLHttpRequest&quot;; // TODO this should become &quot;resource loading&quot; when XHR goes through resource loader

    xhr._ownerDocument._defaultView._virtualConsole.emit(&quot;jsdomError&quot;, error);
  }
}

function validCORSHeaders(xhr, response, flag, properties, origin) {
  const acaoStr = response.headers[&quot;access-control-allow-origin&quot;];
  const acao = acaoStr ? acaoStr.trim() : null;
  if (acao !== &quot;*&quot; &amp;&amp; acao !== origin) {
    properties.error = &quot;Cross origin &quot; + origin + &quot; forbidden&quot;;
    dispatchError(xhr);
    return false;
  }
  const acacStr = response.headers[&quot;access-control-allow-credentials&quot;];
  const acac = acacStr ? acacStr.trim() : null;
  if (flag.withCredentials &amp;&amp; acac !== &quot;true&quot;) {
    properties.error = &quot;Credentials forbidden&quot;;
    dispatchError(xhr);
    return false;
  }
  return true;
}

function validCORSPreflightHeaders(xhr, response, flag, properties) {
  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {
    return false;
  }
  const acahStr = response.headers[&quot;access-control-allow-headers&quot;];
  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);
  const forbiddenHeaders = acah.has(&quot;*&quot;) ?
  [] :
  Object.keys(flag.requestHeaders).filter(header =&gt; {
    const lcHeader = header.toLowerCase();
    return !simpleHeaders.has(lcHeader) &amp;&amp; !acah.has(lcHeader);
  });
  if (forbiddenHeaders.length &gt; 0) {
    properties.error = &quot;Headers &quot; + forbiddenHeaders + &quot; forbidden&quot;;
    dispatchError(xhr);
    return false;
  }
  return true;
}

function requestErrorSteps(xhr, event, exception) {
  const { flag, properties, upload } = xhr;

  xhr.readyState = READY_STATES.DONE;
  properties.send = false;

  setResponseToNetworkError(xhr);

  if (flag.synchronous) {
    throw exception;
  }

  fireAnEvent(&quot;readystatechange&quot;, xhr);

  if (!properties.uploadComplete) {
    properties.uploadComplete = true;

    if (properties.uploadListener) {
      fireAnEvent(event, upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });
      fireAnEvent(&quot;loadend&quot;, upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });
    }
  }

  fireAnEvent(event, xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });
  fireAnEvent(&quot;loadend&quot;, xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });
}

function setResponseToNetworkError(xhr) {
  const { properties } = xhr;

  properties.responseBuffer =
    properties.responseCache =
    properties.responseTextCache =
    properties.responseXMLCache = null;

  properties.responseHeaders = {};
  xhr.status = 0;
  xhr.statusText = &quot;&quot;;
}

// return a &quot;request&quot; client object or an event emitter matching the same behaviour for unsupported protocols
// the callback should be called with a &quot;request&quot; response object or an event emitter matching the same behaviour too
function createClient(xhr) {
  const { flag, properties } = xhr;
  const urlObj = new URL(flag.uri);
  const uri = urlObj.href;
  const ucMethod = flag.method.toUpperCase();

  const { requestManager } = flag;

  if (urlObj.protocol === &quot;file:&quot;) {
    const response = new EventEmitter();
    response.statusCode = 200;
    response.rawHeaders = [];
    response.headers = {};
    const filePath = urlObj.pathname
      .replace(/^file:\/\//, &quot;&quot;)
      .replace(/^\/([a-z]):\//i, &quot;$1:/&quot;)
      .replace(/%20/g, &quot; &quot;);

    const client = new EventEmitter();

    const readableStream = fs.createReadStream(filePath, { encoding: null });

    readableStream.on(&quot;data&quot;, chunk =&gt; {
      response.emit(&quot;data&quot;, chunk);
      client.emit(&quot;data&quot;, chunk);
    });

    readableStream.on(&quot;end&quot;, () =&gt; {
      response.emit(&quot;end&quot;);
      client.emit(&quot;end&quot;);
    });

    readableStream.on(&quot;error&quot;, err =&gt; {
      client.emit(&quot;error&quot;, err);
    });

    client.abort = function () {
      readableStream.destroy();
      client.emit(&quot;abort&quot;);
    };

    if (requestManager) {
      const req = {
        abort() {
          properties.abortError = true;
          xhr.abort();
        }
      };
      requestManager.add(req);
      const rmReq = requestManager.remove.bind(requestManager, req);
      client.on(&quot;abort&quot;, rmReq);
      client.on(&quot;error&quot;, rmReq);
      client.on(&quot;end&quot;, rmReq);
    }

    process.nextTick(() =&gt; client.emit(&quot;response&quot;, response, urlObj.href));

    return client;
  }

  if (urlObj.protocol === &quot;data:&quot;) {
    const response = new EventEmitter();

    const client = new EventEmitter();

    let buffer;
    try {
      const parsed = parseDataURL(uri);
      const contentType = parsed.mimeType.toString();
      buffer = Buffer.from(parsed.body);
      response.statusCode = 200;
      response.rawHeaders = [&quot;Content-Type&quot;, contentType];
      response.headers = { &quot;content-type&quot;: contentType };
    } catch (err) {
      process.nextTick(() =&gt; client.emit(&quot;error&quot;, err));
      return client;
    }

    client.abort = () =&gt; {
      // do nothing
    };

    process.nextTick(() =&gt; {
      client.emit(&quot;response&quot;, response, urlObj.href);
      process.nextTick(() =&gt; {
        response.emit(&quot;data&quot;, buffer);
        client.emit(&quot;data&quot;, buffer);
        response.emit(&quot;end&quot;);
        client.emit(&quot;end&quot;);
      });
    });

    return client;
  }
  const agents = agentFactory(flag.proxy, flag.strictSSL);
  const requestHeaders = {};

  for (const header in flag.requestHeaders) {
    requestHeaders[header] = flag.requestHeaders[header];
  }

  if (getRequestHeader(flag.requestHeaders, &quot;referer&quot;) === null) {
    requestHeaders.Referer = flag.referrer;
  }
  if (getRequestHeader(flag.requestHeaders, &quot;user-agent&quot;) === null) {
    requestHeaders[&quot;User-Agent&quot;] = flag.userAgent;
  }
  if (getRequestHeader(flag.requestHeaders, &quot;accept-language&quot;) === null) {
    requestHeaders[&quot;Accept-Language&quot;] = &quot;en&quot;;
  }
  if (getRequestHeader(flag.requestHeaders, &quot;accept&quot;) === null) {
    requestHeaders.Accept = &quot;*/*&quot;;
  }

  const crossOrigin = flag.origin !== urlObj.origin;
  if (crossOrigin) {
    requestHeaders.Origin = flag.origin;
  }

  const options = { rejectUnauthorized: flag.strictSSL, agents, followRedirects: true };
  if (flag.auth) {
    options.user = flag.auth.user || &quot;&quot;;
    options.pass = flag.auth.pass || &quot;&quot;;
  }
  if (flag.cookieJar &amp;&amp; (!crossOrigin || flag.withCredentials)) {
    options.cookieJar = flag.cookieJar;
  }

  const { body } = flag;
  const hasBody = body !== undefined &amp;&amp;
                  body !== null &amp;&amp;
                  body !== &quot;&quot; &amp;&amp;
                  !(ucMethod === &quot;HEAD&quot; || ucMethod === &quot;GET&quot;);

  if (hasBody &amp;&amp; getRequestHeader(flag.requestHeaders, &quot;content-type&quot;) === null) {
    requestHeaders[&quot;Content-Type&quot;] = &quot;text/plain;charset=UTF-8&quot;;
  }

  function doRequest() {
    try {
      requestHeaders[&quot;Accept-Encoding&quot;] = &quot;gzip, deflate&quot;;

      let len = 0;
      if (hasBody) {
        len = body.byteLength;
        requestHeaders[&quot;Content-Length&quot;] = len;
      }

      const requestClient = new Request(uri, options, { method: flag.method, headers: requestHeaders });
      if (hasBody) {
        requestClient.write(body);
      }
      return requestClient;
    } catch (e) {
      const eventEmitterclient = new EventEmitter();
      process.nextTick(() =&gt; eventEmitterclient.emit(&quot;error&quot;, e));
      eventEmitterclient.end = () =&gt; {};
      eventEmitterclient.abort = () =&gt; {
        // do nothing
      };
      return eventEmitterclient;
    }
  }

  let client;

  const nonSimpleHeaders = Object.keys(flag.requestHeaders)
    .filter(header =&gt; !simpleHeaders.has(header.toLowerCase()));

  if (crossOrigin &amp;&amp; (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length &gt; 0 || properties.uploadListener)) {
    client = new EventEmitter();

    const preflightRequestHeaders = {};
    for (const header in requestHeaders) {
      // the only existing request headers the cors spec allows on the preflight request are Origin and Referer
      const lcHeader = header.toLowerCase();
      if (lcHeader === &quot;origin&quot; || lcHeader === &quot;referer&quot;) {
        preflightRequestHeaders[header] = requestHeaders[header];
      }
    }

    preflightRequestHeaders[&quot;Access-Control-Request-Method&quot;] = flag.method;
    if (nonSimpleHeaders.length &gt; 0) {
      preflightRequestHeaders[&quot;Access-Control-Request-Headers&quot;] = nonSimpleHeaders.join(&quot;, &quot;);
    }

    preflightRequestHeaders[&quot;User-Agent&quot;] = flag.userAgent;

    flag.preflight = true;

    const rejectUnauthorized = flag.strictSSL;
    const preflightClient = new Request(
      uri,
      { agents, followRedirects: false },
      { method: &quot;OPTIONS&quot;, headers: preflightRequestHeaders, rejectUnauthorized }
    );

    preflightClient.on(&quot;response&quot;, resp =&gt; {
      // don&#039;t send the real request if the preflight request returned an error
      if (resp.statusCode &lt; 200 || resp.statusCode &gt; 299) {
        client.emit(&quot;error&quot;, new Error(&quot;Response for preflight has invalid HTTP status code &quot; + resp.statusCode));
        return;
      }
      // don&#039;t send the real request if we aren&#039;t allowed to use the headers
      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {
        setResponseToNetworkError(xhr);
        return;
      }
      // Set request gzip option right before headers are set
      const realClient = doRequest();
      realClient.on(&quot;response&quot;, (...args) =&gt; client.emit(&quot;response&quot;, ...args));
      realClient.on(&quot;data&quot;, chunk =&gt; client.emit(&quot;data&quot;, chunk));
      realClient.on(&quot;end&quot;, () =&gt; client.emit(&quot;end&quot;));
      realClient.on(&quot;abort&quot;, () =&gt; client.emit(&quot;abort&quot;));
      realClient.on(&quot;request&quot;, req =&gt; {
        client.headers = realClient.headers;
        client.emit(&quot;request&quot;, req);
      });
      realClient.on(&quot;redirect&quot;, (...args) =&gt; {
        client.emit(&quot;redirect&quot;, ...args);
      });
      realClient.on(&quot;error&quot;, err =&gt; {
        client.emit(&quot;error&quot;, err);
      });
      client.abort = () =&gt; {
        realClient.abort();
      };
      setImmediate(() =&gt; realClient.end());
    });

    preflightClient.on(&quot;error&quot;, err =&gt; {
      client.emit(&quot;error&quot;, err);
    });

    client.abort = () =&gt; {
      preflightClient.abort();
    };
    setImmediate(() =&gt; preflightClient.end());
  } else {
    client = doRequest();
    setImmediate(() =&gt; client.end());
  }

  if (requestManager) {
    const req = {
      abort() {
        properties.abortError = true;
        xhr.abort();
      }
    };
    requestManager.add(req);
    const rmReq = requestManager.remove.bind(requestManager, req);
    client.on(&quot;abort&quot;, rmReq);
    client.on(&quot;error&quot;, rmReq);
    client.on(&quot;end&quot;, rmReq);
  }
  return client;
}

exports.headerListSeparatorRegexp = headerListSeparatorRegexp;
exports.simpleHeaders = simpleHeaders;
exports.preflightHeaders = preflightHeaders;
exports.getRequestHeader = getRequestHeader;
exports.updateRequestHeader = updateRequestHeader;
exports.dispatchError = dispatchError;
exports.validCORSHeaders = validCORSHeaders;
exports.requestErrorSteps = requestErrorSteps;
exports.setResponseToNetworkError = setResponseToNetworkError;
exports.createClient = createClient;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
