<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ioredis/built/cluster/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ioredis/built/cluster/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">864</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">95.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.25</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const commands_1 = require(&quot;@ioredis/commands&quot;);
const events_1 = require(&quot;events&quot;);
const redis_errors_1 = require(&quot;redis-errors&quot;);
const standard_as_callback_1 = require(&quot;standard-as-callback&quot;);
const Command_1 = require(&quot;../Command&quot;);
const ClusterAllFailedError_1 = require(&quot;../errors/ClusterAllFailedError&quot;);
const Redis_1 = require(&quot;../Redis&quot;);
const ScanStream_1 = require(&quot;../ScanStream&quot;);
const transaction_1 = require(&quot;../transaction&quot;);
const utils_1 = require(&quot;../utils&quot;);
const applyMixin_1 = require(&quot;../utils/applyMixin&quot;);
const Commander_1 = require(&quot;../utils/Commander&quot;);
const ClusterOptions_1 = require(&quot;./ClusterOptions&quot;);
const ClusterSubscriber_1 = require(&quot;./ClusterSubscriber&quot;);
const ConnectionPool_1 = require(&quot;./ConnectionPool&quot;);
const DelayQueue_1 = require(&quot;./DelayQueue&quot;);
const util_1 = require(&quot;./util&quot;);
const Deque = require(&quot;denque&quot;);
const ClusterSubscriberGroup_1 = require(&quot;./ClusterSubscriberGroup&quot;);
const debug = (0, utils_1.Debug)(&quot;cluster&quot;);
const REJECT_OVERWRITTEN_COMMANDS = new WeakSet();
/**
 * Client for the official Redis Cluster
 */
class Cluster extends Commander_1.default {
    /**
     * Creates an instance of Cluster.
     */
    //TODO: Add an option that enables or disables sharded PubSub
    constructor(startupNodes, options = {}) {
        super();
        this.slots = [];
        /**
         * @ignore
         */
        this._groupsIds = {};
        /**
         * @ignore
         */
        this._groupsBySlot = Array(16384);
        /**
         * @ignore
         */
        this.isCluster = true;
        this.retryAttempts = 0;
        this.delayQueue = new DelayQueue_1.default();
        this.offlineQueue = new Deque();
        this.isRefreshing = false;
        this._refreshSlotsCacheCallbacks = [];
        this._autoPipelines = new Map();
        this._runningAutoPipelines = new Set();
        this._readyDelayedCallbacks = [];
        /**
         * Every time Cluster#connect() is called, this value will be
         * auto-incrementing. The purpose of this value is used for
         * discarding previous connect attampts when creating a new
         * connection.
         */
        this.connectionEpoch = 0;
        events_1.EventEmitter.call(this);
        this.startupNodes = startupNodes;
        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
        if (this.options.shardedSubscribers == true)
            this.shardedSubscribers = new ClusterSubscriberGroup_1.default(this);
        if (this.options.redisOptions &amp;&amp;
            this.options.redisOptions.keyPrefix &amp;&amp;
            !this.options.keyPrefix) {
            this.options.keyPrefix = this.options.redisOptions.keyPrefix;
        }
        // validate options
        if (typeof this.options.scaleReads !== &quot;function&quot; &amp;&amp;
            [&quot;all&quot;, &quot;master&quot;, &quot;slave&quot;].indexOf(this.options.scaleReads) === -1) {
            throw new Error(&#039;Invalid option scaleReads &quot;&#039; +
                this.options.scaleReads +
                &#039;&quot;. Expected &quot;all&quot;, &quot;master&quot;, &quot;slave&quot; or a custom function&#039;);
        }
        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
        this.connectionPool.on(&quot;-node&quot;, (redis, key) =&gt; {
            this.emit(&quot;-node&quot;, redis);
        });
        this.connectionPool.on(&quot;+node&quot;, (redis) =&gt; {
            this.emit(&quot;+node&quot;, redis);
        });
        this.connectionPool.on(&quot;drain&quot;, () =&gt; {
            this.setStatus(&quot;close&quot;);
        });
        this.connectionPool.on(&quot;nodeError&quot;, (error, key) =&gt; {
            this.emit(&quot;node error&quot;, error, key);
        });
        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
        if (this.options.scripts) {
            Object.entries(this.options.scripts).forEach(([name, definition]) =&gt; {
                this.defineCommand(name, definition);
            });
        }
        if (this.options.lazyConnect) {
            this.setStatus(&quot;wait&quot;);
        }
        else {
            this.connect().catch((err) =&gt; {
                debug(&quot;connecting failed: %s&quot;, err);
            });
        }
    }
    /**
     * Connect to a cluster
     */
    connect() {
        return new Promise((resolve, reject) =&gt; {
            if (this.status === &quot;connecting&quot; ||
                this.status === &quot;connect&quot; ||
                this.status === &quot;ready&quot;) {
                reject(new Error(&quot;Redis is already connecting/connected&quot;));
                return;
            }
            const epoch = ++this.connectionEpoch;
            this.setStatus(&quot;connecting&quot;);
            this.resolveStartupNodeHostnames()
                .then((nodes) =&gt; {
                if (this.connectionEpoch !== epoch) {
                    debug(&quot;discard connecting after resolving startup nodes because epoch not match: %d != %d&quot;, epoch, this.connectionEpoch);
                    reject(new redis_errors_1.RedisError(&quot;Connection is discarded because a new connection is made&quot;));
                    return;
                }
                if (this.status !== &quot;connecting&quot;) {
                    debug(&quot;discard connecting after resolving startup nodes because the status changed to %s&quot;, this.status);
                    reject(new redis_errors_1.RedisError(&quot;Connection is aborted&quot;));
                    return;
                }
                this.connectionPool.reset(nodes);
                const readyHandler = () =&gt; {
                    this.setStatus(&quot;ready&quot;);
                    this.retryAttempts = 0;
                    this.executeOfflineCommands();
                    this.resetNodesRefreshInterval();
                    resolve();
                };
                let closeListener = undefined;
                const refreshListener = () =&gt; {
                    this.invokeReadyDelayedCallbacks(undefined);
                    this.removeListener(&quot;close&quot;, closeListener);
                    this.manuallyClosing = false;
                    this.setStatus(&quot;connect&quot;);
                    if (this.options.enableReadyCheck) {
                        this.readyCheck((err, fail) =&gt; {
                            if (err || fail) {
                                debug(&quot;Ready check failed (%s). Reconnecting...&quot;, err || fail);
                                if (this.status === &quot;connect&quot;) {
                                    this.disconnect(true);
                                }
                            }
                            else {
                                readyHandler();
                            }
                        });
                    }
                    else {
                        readyHandler();
                    }
                };
                closeListener = () =&gt; {
                    const error = new Error(&quot;None of startup nodes is available&quot;);
                    this.removeListener(&quot;refresh&quot;, refreshListener);
                    this.invokeReadyDelayedCallbacks(error);
                    reject(error);
                };
                this.once(&quot;refresh&quot;, refreshListener);
                this.once(&quot;close&quot;, closeListener);
                this.once(&quot;close&quot;, this.handleCloseEvent.bind(this));
                this.refreshSlotsCache((err) =&gt; {
                    if (err &amp;&amp; err.message === ClusterAllFailedError_1.default.defaultMessage) {
                        Redis_1.default.prototype.silentEmit.call(this, &quot;error&quot;, err);
                        this.connectionPool.reset([]);
                    }
                });
                this.subscriber.start();
                if (this.options.shardedSubscribers) {
                    this.shardedSubscribers.start();
                }
            })
                .catch((err) =&gt; {
                this.setStatus(&quot;close&quot;);
                this.handleCloseEvent(err);
                this.invokeReadyDelayedCallbacks(err);
                reject(err);
            });
        });
    }
    /**
     * Disconnect from every node in the cluster.
     */
    disconnect(reconnect = false) {
        const status = this.status;
        this.setStatus(&quot;disconnecting&quot;);
        if (!reconnect) {
            this.manuallyClosing = true;
        }
        if (this.reconnectTimeout &amp;&amp; !reconnect) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
            debug(&quot;Canceled reconnecting attempts&quot;);
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        if (this.options.shardedSubscribers) {
            this.shardedSubscribers.stop();
        }
        if (status === &quot;wait&quot;) {
            this.setStatus(&quot;close&quot;);
            this.handleCloseEvent();
        }
        else {
            this.connectionPool.reset([]);
        }
    }
    /**
     * Quit the cluster gracefully.
     */
    quit(callback) {
        const status = this.status;
        this.setStatus(&quot;disconnecting&quot;);
        this.manuallyClosing = true;
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
        this.clearNodesRefreshInterval();
        this.subscriber.stop();
        if (this.options.shardedSubscribers) {
            this.shardedSubscribers.stop();
        }
        if (status === &quot;wait&quot;) {
            const ret = (0, standard_as_callback_1.default)(Promise.resolve(&quot;OK&quot;), callback);
            // use setImmediate to make sure &quot;close&quot; event
            // being emitted after quit() is returned
            setImmediate(function () {
                this.setStatus(&quot;close&quot;);
                this.handleCloseEvent();
            }.bind(this));
            return ret;
        }
        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) =&gt; node.quit().catch((err) =&gt; {
            // Ignore the error caused by disconnecting since
            // we&#039;re disconnecting...
            if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {
                return &quot;OK&quot;;
            }
            throw err;
        }))).then(() =&gt; &quot;OK&quot;), callback);
    }
    /**
     * Create a new instance with the same startup nodes and options as the current one.
     *
     * @example
     * ```js
     * var cluster = new Redis.Cluster([{ host: &quot;127.0.0.1&quot;, port: &quot;30001&quot; }]);
     * var anotherCluster = cluster.duplicate();
     * ```
     */
    duplicate(overrideStartupNodes = [], overrideOptions = {}) {
        const startupNodes = overrideStartupNodes.length &gt; 0
            ? overrideStartupNodes
            : this.startupNodes.slice(0);
        const options = Object.assign({}, this.options, overrideOptions);
        return new Cluster(startupNodes, options);
    }
    /**
     * Get nodes with the specified role
     */
    nodes(role = &quot;all&quot;) {
        if (role !== &quot;all&quot; &amp;&amp; role !== &quot;master&quot; &amp;&amp; role !== &quot;slave&quot;) {
            throw new Error(&#039;Invalid role &quot;&#039; + role + &#039;&quot;. Expected &quot;all&quot;, &quot;master&quot; or &quot;slave&quot;&#039;);
        }
        return this.connectionPool.getNodes(role);
    }
    /**
     * This is needed in order not to install a listener for each auto pipeline
     *
     * @ignore
     */
    delayUntilReady(callback) {
        this._readyDelayedCallbacks.push(callback);
    }
    /**
     * Get the number of commands queued in automatic pipelines.
     *
     * This is not available (and returns 0) until the cluster is connected and slots information have been received.
     */
    get autoPipelineQueueSize() {
        let queued = 0;
        for (const pipeline of this._autoPipelines.values()) {
            queued += pipeline.length;
        }
        return queued;
    }
    /**
     * Refresh the slot cache
     *
     * @ignore
     */
    refreshSlotsCache(callback) {
        if (callback) {
            this._refreshSlotsCacheCallbacks.push(callback);
        }
        if (this.isRefreshing) {
            return;
        }
        this.isRefreshing = true;
        const _this = this;
        const wrapper = (error) =&gt; {
            this.isRefreshing = false;
            for (const callback of this._refreshSlotsCacheCallbacks) {
                callback(error);
            }
            this._refreshSlotsCacheCallbacks = [];
        };
        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());
        let lastNodeError = null;
        function tryNode(index) {
            if (index === nodes.length) {
                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);
                return wrapper(error);
            }
            const node = nodes[index];
            const key = `${node.options.host}:${node.options.port}`;
            debug(&quot;getting slot cache from %s&quot;, key);
            _this.getInfoFromNode(node, function (err) {
                switch (_this.status) {
                    case &quot;close&quot;:
                    case &quot;end&quot;:
                        return wrapper(new Error(&quot;Cluster is disconnected.&quot;));
                    case &quot;disconnecting&quot;:
                        return wrapper(new Error(&quot;Cluster is disconnecting.&quot;));
                }
                if (err) {
                    _this.emit(&quot;node error&quot;, err, key);
                    lastNodeError = err;
                    tryNode(index + 1);
                }
                else {
                    _this.emit(&quot;refresh&quot;);
                    wrapper();
                }
            });
        }
        tryNode(0);
    }
    /**
     * @ignore
     */
    sendCommand(command, stream, node) {
        if (this.status === &quot;wait&quot;) {
            this.connect().catch(utils_1.noop);
        }
        if (this.status === &quot;end&quot;) {
            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            return command.promise;
        }
        let to = this.options.scaleReads;
        if (to !== &quot;master&quot;) {
            const isCommandReadOnly = command.isReadOnly ||
                ((0, commands_1.exists)(command.name) &amp;&amp; (0, commands_1.hasFlag)(command.name, &quot;readonly&quot;));
            if (!isCommandReadOnly) {
                to = &quot;master&quot;;
            }
        }
        let targetSlot = node ? node.slot : command.getSlot();
        const ttl = {};
        const _this = this;
        if (!node &amp;&amp; !REJECT_OVERWRITTEN_COMMANDS.has(command)) {
            REJECT_OVERWRITTEN_COMMANDS.add(command);
            const reject = command.reject;
            command.reject = function (err) {
                const partialTry = tryConnection.bind(null, true);
                _this.handleError(err, ttl, {
                    moved: function (slot, key) {
                        debug(&quot;command %s is moved to %s&quot;, command.name, key);
                        targetSlot = Number(slot);
                        if (_this.slots[slot]) {
                            _this.slots[slot][0] = key;
                        }
                        else {
                            _this.slots[slot] = [key];
                        }
                        _this._groupsBySlot[slot] =
                            _this._groupsIds[_this.slots[slot].join(&quot;;&quot;)];
                        _this.connectionPool.findOrCreate(_this.natMapper(key));
                        tryConnection();
                        debug(&quot;refreshing slot caches... (triggered by MOVED error)&quot;);
                        _this.refreshSlotsCache();
                    },
                    ask: function (slot, key) {
                        debug(&quot;command %s is required to ask %s:%s&quot;, command.name, key);
                        const mapped = _this.natMapper(key);
                        _this.connectionPool.findOrCreate(mapped);
                        tryConnection(false, `${mapped.host}:${mapped.port}`);
                    },
                    tryagain: partialTry,
                    clusterDown: partialTry,
                    connectionClosed: partialTry,
                    maxRedirections: function (redirectionError) {
                        reject.call(command, redirectionError);
                    },
                    defaults: function () {
                        reject.call(command, err);
                    },
                });
            };
        }
        tryConnection();
        function tryConnection(random, asking) {
            if (_this.status === &quot;end&quot;) {
                command.reject(new redis_errors_1.AbortError(&quot;Cluster is ended.&quot;));
                return;
            }
            let redis;
            if (_this.status === &quot;ready&quot; || command.name === &quot;cluster&quot;) {
                if (node &amp;&amp; node.redis) {
                    redis = node.redis;
                }
                else if (Command_1.default.checkFlag(&quot;ENTER_SUBSCRIBER_MODE&quot;, command.name) ||
                    Command_1.default.checkFlag(&quot;EXIT_SUBSCRIBER_MODE&quot;, command.name)) {
                    if (_this.options.shardedSubscribers == true &amp;&amp;
                        (command.name == &quot;ssubscribe&quot; || command.name == &quot;sunsubscribe&quot;)) {
                        const sub = _this.shardedSubscribers.getResponsibleSubscriber(targetSlot);
                        let status = -1;
                        if (command.name == &quot;ssubscribe&quot;)
                            status = _this.shardedSubscribers.addChannels(command.getKeys());
                        if (command.name == &quot;sunsubscribe&quot;)
                            status = _this.shardedSubscribers.removeChannels(command.getKeys());
                        if (status !== -1) {
                            redis = sub.getInstance();
                        }
                        else {
                            command.reject(new redis_errors_1.AbortError(&quot;Can&#039;t add or remove the given channels. Are they in the same slot?&quot;));
                        }
                    }
                    else {
                        redis = _this.subscriber.getInstance();
                    }
                    if (!redis) {
                        command.reject(new redis_errors_1.AbortError(&quot;No subscriber for the cluster&quot;));
                        return;
                    }
                }
                else {
                    if (!random) {
                        if (typeof targetSlot === &quot;number&quot; &amp;&amp; _this.slots[targetSlot]) {
                            const nodeKeys = _this.slots[targetSlot];
                            if (typeof to === &quot;function&quot;) {
                                const nodes = nodeKeys.map(function (key) {
                                    return _this.connectionPool.getInstanceByKey(key);
                                });
                                redis = to(nodes, command);
                                if (Array.isArray(redis)) {
                                    redis = (0, utils_1.sample)(redis);
                                }
                                if (!redis) {
                                    redis = nodes[0];
                                }
                            }
                            else {
                                let key;
                                if (to === &quot;all&quot;) {
                                    key = (0, utils_1.sample)(nodeKeys);
                                }
                                else if (to === &quot;slave&quot; &amp;&amp; nodeKeys.length &gt; 1) {
                                    key = (0, utils_1.sample)(nodeKeys, 1);
                                }
                                else {
                                    key = nodeKeys[0];
                                }
                                redis = _this.connectionPool.getInstanceByKey(key);
                            }
                        }
                        if (asking) {
                            redis = _this.connectionPool.getInstanceByKey(asking);
                            redis.asking();
                        }
                    }
                    if (!redis) {
                        redis =
                            (typeof to === &quot;function&quot;
                                ? null
                                : _this.connectionPool.getSampleInstance(to)) ||
                                _this.connectionPool.getSampleInstance(&quot;all&quot;);
                    }
                }
                if (node &amp;&amp; !node.redis) {
                    node.redis = redis;
                }
            }
            if (redis) {
                redis.sendCommand(command, stream);
            }
            else if (_this.options.enableOfflineQueue) {
                _this.offlineQueue.push({
                    command: command,
                    stream: stream,
                    node: node,
                });
            }
            else {
                command.reject(new Error(&quot;Cluster isn&#039;t ready and enableOfflineQueue options is false&quot;));
            }
        }
        return command.promise;
    }
    sscanStream(key, options) {
        return this.createScanStream(&quot;sscan&quot;, { key, options });
    }
    sscanBufferStream(key, options) {
        return this.createScanStream(&quot;sscanBuffer&quot;, { key, options });
    }
    hscanStream(key, options) {
        return this.createScanStream(&quot;hscan&quot;, { key, options });
    }
    hscanBufferStream(key, options) {
        return this.createScanStream(&quot;hscanBuffer&quot;, { key, options });
    }
    zscanStream(key, options) {
        return this.createScanStream(&quot;zscan&quot;, { key, options });
    }
    zscanBufferStream(key, options) {
        return this.createScanStream(&quot;zscanBuffer&quot;, { key, options });
    }
    /**
     * @ignore
     */
    handleError(error, ttl, handlers) {
        if (typeof ttl.value === &quot;undefined&quot;) {
            ttl.value = this.options.maxRedirections;
        }
        else {
            ttl.value -= 1;
        }
        if (ttl.value &lt;= 0) {
            handlers.maxRedirections(new Error(&quot;Too many Cluster redirections. Last error: &quot; + error));
            return;
        }
        const errv = error.message.split(&quot; &quot;);
        if (errv[0] === &quot;MOVED&quot;) {
            const timeout = this.options.retryDelayOnMoved;
            if (timeout &amp;&amp; typeof timeout === &quot;number&quot;) {
                this.delayQueue.push(&quot;moved&quot;, handlers.moved.bind(null, errv[1], errv[2]), { timeout });
            }
            else {
                handlers.moved(errv[1], errv[2]);
            }
        }
        else if (errv[0] === &quot;ASK&quot;) {
            handlers.ask(errv[1], errv[2]);
        }
        else if (errv[0] === &quot;TRYAGAIN&quot;) {
            this.delayQueue.push(&quot;tryagain&quot;, handlers.tryagain, {
                timeout: this.options.retryDelayOnTryAgain,
            });
        }
        else if (errv[0] === &quot;CLUSTERDOWN&quot; &amp;&amp;
            this.options.retryDelayOnClusterDown &gt; 0) {
            this.delayQueue.push(&quot;clusterdown&quot;, handlers.connectionClosed, {
                timeout: this.options.retryDelayOnClusterDown,
                callback: this.refreshSlotsCache.bind(this),
            });
        }
        else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG &amp;&amp;
            this.options.retryDelayOnFailover &gt; 0 &amp;&amp;
            this.status === &quot;ready&quot;) {
            this.delayQueue.push(&quot;failover&quot;, handlers.connectionClosed, {
                timeout: this.options.retryDelayOnFailover,
                callback: this.refreshSlotsCache.bind(this),
            });
        }
        else {
            handlers.defaults();
        }
    }
    resetOfflineQueue() {
        this.offlineQueue = new Deque();
    }
    clearNodesRefreshInterval() {
        if (this.slotsTimer) {
            clearTimeout(this.slotsTimer);
            this.slotsTimer = null;
        }
    }
    resetNodesRefreshInterval() {
        if (this.slotsTimer || !this.options.slotsRefreshInterval) {
            return;
        }
        const nextRound = () =&gt; {
            this.slotsTimer = setTimeout(() =&gt; {
                debug(&#039;refreshing slot caches... (triggered by &quot;slotsRefreshInterval&quot; option)&#039;);
                this.refreshSlotsCache(() =&gt; {
                    nextRound();
                });
            }, this.options.slotsRefreshInterval);
        };
        nextRound();
    }
    /**
     * Change cluster instance&#039;s status
     */
    setStatus(status) {
        debug(&quot;status: %s -&gt; %s&quot;, this.status || &quot;[empty]&quot;, status);
        this.status = status;
        process.nextTick(() =&gt; {
            this.emit(status);
        });
    }
    /**
     * Called when closed to check whether a reconnection should be made
     */
    handleCloseEvent(reason) {
        if (reason) {
            debug(&quot;closed because %s&quot;, reason);
        }
        let retryDelay;
        if (!this.manuallyClosing &amp;&amp;
            typeof this.options.clusterRetryStrategy === &quot;function&quot;) {
            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
        }
        if (typeof retryDelay === &quot;number&quot;) {
            this.setStatus(&quot;reconnecting&quot;);
            this.reconnectTimeout = setTimeout(() =&gt; {
                this.reconnectTimeout = null;
                debug(&quot;Cluster is disconnected. Retrying after %dms&quot;, retryDelay);
                this.connect().catch(function (err) {
                    debug(&quot;Got error %s when reconnecting. Ignoring...&quot;, err);
                });
            }, retryDelay);
        }
        else {
            this.setStatus(&quot;end&quot;);
            this.flushQueue(new Error(&quot;None of startup nodes is available&quot;));
        }
    }
    /**
     * Flush offline queue with error.
     */
    flushQueue(error) {
        let item;
        while ((item = this.offlineQueue.shift())) {
            item.command.reject(error);
        }
    }
    executeOfflineCommands() {
        if (this.offlineQueue.length) {
            debug(&quot;send %d commands in offline queue&quot;, this.offlineQueue.length);
            const offlineQueue = this.offlineQueue;
            this.resetOfflineQueue();
            let item;
            while ((item = offlineQueue.shift())) {
                this.sendCommand(item.command, item.stream, item.node);
            }
        }
    }
    natMapper(nodeKey) {
        const key = typeof nodeKey === &quot;string&quot;
            ? nodeKey
            : `${nodeKey.host}:${nodeKey.port}`;
        let mapped = null;
        if (this.options.natMap &amp;&amp; typeof this.options.natMap === &quot;function&quot;) {
            mapped = this.options.natMap(key);
        }
        else if (this.options.natMap &amp;&amp; typeof this.options.natMap === &quot;object&quot;) {
            mapped = this.options.natMap[key];
        }
        if (mapped) {
            debug(&quot;NAT mapping %s -&gt; %O&quot;, key, mapped);
            return Object.assign({}, mapped);
        }
        return typeof nodeKey === &quot;string&quot;
            ? (0, util_1.nodeKeyToRedisOptions)(nodeKey)
            : nodeKey;
    }
    getInfoFromNode(redis, callback) {
        if (!redis) {
            return callback(new Error(&quot;Node is disconnected&quot;));
        }
        // Use a duplication of the connection to avoid
        // timeouts when the connection is in the blocking
        // mode (e.g. waiting for BLPOP).
        const duplicatedConnection = redis.duplicate({
            enableOfflineQueue: true,
            enableReadyCheck: false,
            retryStrategy: null,
            connectionName: (0, util_1.getConnectionName)(&quot;refresher&quot;, this.options.redisOptions &amp;&amp; this.options.redisOptions.connectionName),
        });
        // Ignore error events since we will handle
        // exceptions for the CLUSTER SLOTS command.
        duplicatedConnection.on(&quot;error&quot;, utils_1.noop);
        duplicatedConnection.cluster(&quot;SLOTS&quot;, (0, utils_1.timeout)((err, result) =&gt; {
            duplicatedConnection.disconnect();
            if (err) {
                debug(&quot;error encountered running CLUSTER.SLOTS: %s&quot;, err);
                return callback(err);
            }
            if (this.status === &quot;disconnecting&quot; ||
                this.status === &quot;close&quot; ||
                this.status === &quot;end&quot;) {
                debug(&quot;ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s&quot;, result.length, this.status);
                callback();
                return;
            }
            const nodes = [];
            debug(&quot;cluster slots result count: %d&quot;, result.length);
            for (let i = 0; i &lt; result.length; ++i) {
                const items = result[i];
                const slotRangeStart = items[0];
                const slotRangeEnd = items[1];
                const keys = [];
                for (let j = 2; j &lt; items.length; j++) {
                    if (!items[j][0]) {
                        continue;
                    }
                    const node = this.natMapper({
                        host: items[j][0],
                        port: items[j][1],
                    });
                    node.readOnly = j !== 2;
                    nodes.push(node);
                    keys.push(node.host + &quot;:&quot; + node.port);
                }
                debug(&quot;cluster slots result [%d]: slots %d~%d served by %s&quot;, i, slotRangeStart, slotRangeEnd, keys);
                for (let slot = slotRangeStart; slot &lt;= slotRangeEnd; slot++) {
                    this.slots[slot] = keys;
                }
            }
            // Assign to each node keys a numeric value to make autopipeline comparison faster.
            this._groupsIds = Object.create(null);
            let j = 0;
            for (let i = 0; i &lt; 16384; i++) {
                const target = (this.slots[i] || []).join(&quot;;&quot;);
                if (!target.length) {
                    this._groupsBySlot[i] = undefined;
                    continue;
                }
                if (!this._groupsIds[target]) {
                    this._groupsIds[target] = ++j;
                }
                this._groupsBySlot[i] = this._groupsIds[target];
            }
            this.connectionPool.reset(nodes);
            callback();
        }, this.options.slotsRefreshTimeout));
    }
    invokeReadyDelayedCallbacks(err) {
        for (const c of this._readyDelayedCallbacks) {
            process.nextTick(c, err);
        }
        this._readyDelayedCallbacks = [];
    }
    /**
     * Check whether Cluster is able to process commands
     */
    readyCheck(callback) {
        this.cluster(&quot;INFO&quot;, (err, res) =&gt; {
            if (err) {
                return callback(err);
            }
            if (typeof res !== &quot;string&quot;) {
                return callback();
            }
            let state;
            const lines = res.split(&quot;\r\n&quot;);
            for (let i = 0; i &lt; lines.length; ++i) {
                const parts = lines[i].split(&quot;:&quot;);
                if (parts[0] === &quot;cluster_state&quot;) {
                    state = parts[1];
                    break;
                }
            }
            if (state === &quot;fail&quot;) {
                debug(&quot;cluster state not ok (%s)&quot;, state);
                callback(null, state);
            }
            else {
                callback();
            }
        });
    }
    resolveSrv(hostname) {
        return new Promise((resolve, reject) =&gt; {
            this.options.resolveSrv(hostname, (err, records) =&gt; {
                if (err) {
                    return reject(err);
                }
                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) =&gt; parseInt(a) - parseInt(b));
                function tryFirstOne(err) {
                    if (!sortedKeys.length) {
                        return reject(err);
                    }
                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);
                    if (!group.records.length) {
                        sortedKeys.shift();
                    }
                    self.dnsLookup(record.name).then((host) =&gt; resolve({
                        host,
                        port: record.port,
                    }), tryFirstOne);
                }
                tryFirstOne();
            });
        });
    }
    dnsLookup(hostname) {
        return new Promise((resolve, reject) =&gt; {
            this.options.dnsLookup(hostname, (err, address) =&gt; {
                if (err) {
                    debug(&quot;failed to resolve hostname %s to IP: %s&quot;, hostname, err.message);
                    reject(err);
                }
                else {
                    debug(&quot;resolved hostname %s to IP %s&quot;, hostname, address);
                    resolve(address);
                }
            });
        });
    }
    /**
     * Normalize startup nodes, and resolving hostnames to IPs.
     *
     * This process happens every time when #connect() is called since
     * #startupNodes and DNS records may chanage.
     */
    async resolveStartupNodeHostnames() {
        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
            throw new Error(&quot;`startupNodes` should contain at least one node.&quot;);
        }
        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);
        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);
        if (hostnames.length === 0) {
            return startupNodes;
        }
        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));
        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);
        return startupNodes.map((node) =&gt; {
            const config = hostnameToConfig.get(node.host);
            if (!config) {
                return node;
            }
            if (this.options.useSRVRecords) {
                return Object.assign({}, node, config);
            }
            return Object.assign({}, node, { host: config });
        });
    }
    createScanStream(command, { key, options = {} }) {
        return new ScanStream_1.default({
            objectMode: true,
            key: key,
            redis: this,
            command: command,
            ...options,
        });
    }
}
(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);
(0, transaction_1.addTransactionSupport)(Cluster.prototype);
exports.default = Cluster;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
