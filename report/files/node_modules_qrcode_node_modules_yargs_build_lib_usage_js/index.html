<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/qrcode/node_modules/yargs/build/lib/usage.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/qrcode/node_modules/yargs/build/lib/usage.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">541</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">97.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.70</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.usage = void 0;
// this file handles outputting usage instructions,
// failures, etc. keeps logging in one place.
const common_types_1 = require(&quot;./common-types&quot;);
const obj_filter_1 = require(&quot;./obj-filter&quot;);
const path = require(&quot;path&quot;);
const yerror_1 = require(&quot;./yerror&quot;);
const decamelize = require(&quot;decamelize&quot;);
const setBlocking = require(&quot;set-blocking&quot;);
const stringWidth = require(&quot;string-width&quot;);
function usage(yargs, y18n) {
    const __ = y18n.__;
    const self = {};
    // methods for ouputting/building failure message.
    const fails = [];
    self.failFn = function failFn(f) {
        fails.push(f);
    };
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
            return typeof arg1 === &#039;string&#039; ? [true, arg1] : [arg1, arg2];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
    };
    let failureOutput = false;
    self.fail = function fail(msg, err) {
        const logger = yargs._getLoggerInstance();
        if (fails.length) {
            for (let i = fails.length - 1; i &gt;= 0; --i) {
                fails[i](msg, err, self);
            }
        }
        else {
            if (yargs.getExitProcess())
                setBlocking(true);
            // don&#039;t output failure message more than once
            if (!failureOutput) {
                failureOutput = true;
                if (showHelpOnFail) {
                    yargs.showHelp(&#039;error&#039;);
                    logger.error();
                }
                if (msg || err)
                    logger.error(msg || err);
                if (failMessage) {
                    if (msg || err)
                        logger.error(&#039;&#039;);
                    logger.error(failMessage);
                }
            }
            err = err || new yerror_1.YError(msg);
            if (yargs.getExitProcess()) {
                return yargs.exit(1);
            }
            else if (yargs._hasParseCallback()) {
                return yargs.exit(1, err);
            }
            else {
                throw err;
            }
        }
    };
    // methods for ouputting/building help (usage) message.
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) =&gt; {
        if (msg === null) {
            usageDisabled = true;
            usages = [];
            return self;
        }
        usageDisabled = false;
        usages.push([msg, description || &#039;&#039;]);
        return self;
    };
    self.getUsage = () =&gt; {
        return usages;
    };
    self.getUsageDisabled = () =&gt; {
        return usageDisabled;
    };
    self.getPositionalGroupName = () =&gt; {
        return __(&#039;Positionals:&#039;);
    };
    let examples = [];
    self.example = (cmd, description) =&gt; {
        examples.push([cmd, description || &#039;&#039;]);
    };
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
        // the last default wins, so cancel out any previously set default
        if (isDefault) {
            commands = commands.map((cmdArray) =&gt; {
                cmdArray[2] = false;
                return cmdArray;
            });
        }
        commands.push([cmd, description || &#039;&#039;, isDefault, aliases, deprecated]);
    };
    self.getCommands = () =&gt; commands;
    let descriptions = {};
    self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
            keyOrKeys.forEach((k) =&gt; {
                self.describe(k, desc);
            });
        }
        else if (typeof keyOrKeys === &#039;object&#039;) {
            Object.keys(keyOrKeys).forEach((k) =&gt; {
                self.describe(k, keyOrKeys[k]);
            });
        }
        else {
            descriptions[keyOrKeys] = desc;
        }
    };
    self.getDescriptions = () =&gt; descriptions;
    let epilogs = [];
    self.epilog = (msg) =&gt; {
        epilogs.push(msg);
    };
    let wrapSet = false;
    let wrap;
    self.wrap = (cols) =&gt; {
        wrapSet = true;
        wrap = cols;
    };
    function getWrap() {
        if (!wrapSet) {
            wrap = windowWidth();
            wrapSet = true;
        }
        return wrap;
    }
    const deferY18nLookupPrefix = &#039;__yargsString__:&#039;;
    self.deferY18nLookup = str =&gt; deferY18nLookupPrefix + str;
    self.help = function help() {
        if (cachedHelpMessage)
            return cachedHelpMessage;
        normalizeAliases();
        // handle old demanded API
        const base$0 = yargs.customScriptName ? yargs.$0 : path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) =&gt; {
            if (key !== &#039;_&#039;)
                acc[key] = true;
            return acc;
        }, {}));
        const theWrap = getWrap();
        const ui = require(&#039;cliui&#039;)({
            width: theWrap,
            wrap: !!theWrap
        });
        // the usage string.
        if (!usageDisabled) {
            if (usages.length) {
                // user-defined usage.
                usages.forEach((usage) =&gt; {
                    ui.div(`${usage[0].replace(/\$0/g, base$0)}`);
                    if (usage[1]) {
                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });
                    }
                });
                ui.div();
            }
            else if (commands.length) {
                let u = null;
                // demonstrate how commands are used.
                if (demandedCommands._) {
                    u = `${base$0} &lt;${__(&#039;command&#039;)}&gt;\n`;
                }
                else {
                    u = `${base$0} [${__(&#039;command&#039;)}]\n`;
                }
                ui.div(`${u}`);
            }
        }
        // your application&#039;s commands, i.e., non-option
        // arguments populated in &#039;_&#039;.
        if (commands.length) {
            ui.div(__(&#039;Commands:&#039;));
            const context = yargs.getContext();
            const parentCommands = context.commands.length ? `${context.commands.join(&#039; &#039;)} ` : &#039;&#039;;
            if (yargs.getParserConfiguration()[&#039;sort-commands&#039;] === true) {
                commands = commands.sort((a, b) =&gt; a[0].localeCompare(b[0]));
            }
            commands.forEach((command) =&gt; {
                const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\$0 ?/, &#039;&#039;)}`; // drop $0 from default commands.
                ui.span({
                    text: commandString,
                    padding: [0, 2, 0, 2],
                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
                }, { text: command[1] });
                const hints = [];
                if (command[2])
                    hints.push(`[${__(&#039;default&#039;)}]`);
                if (command[3] &amp;&amp; command[3].length) {
                    hints.push(`[${__(&#039;aliases:&#039;)} ${command[3].join(&#039;, &#039;)}]`);
                }
                if (command[4]) {
                    if (typeof command[4] === &#039;string&#039;) {
                        hints.push(`[${__(&#039;deprecated: %s&#039;, command[4])}]`);
                    }
                    else {
                        hints.push(`[${__(&#039;deprecated&#039;)}]`);
                    }
                }
                if (hints.length) {
                    ui.div({ text: hints.join(&#039; &#039;), padding: [0, 0, 0, 2], align: &#039;right&#039; });
                }
                else {
                    ui.div();
                }
            });
            ui.div();
        }
        // perform some cleanup on the keys array, making it
        // only include top-level keys not their aliases.
        const aliasKeys = (Object.keys(options.alias) || [])
            .concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter(key =&gt; !yargs.parsed.newAliases[key] &amp;&amp; aliasKeys.every(alias =&gt; (options.alias[alias] || []).indexOf(key) === -1));
        // populate &#039;Options:&#039; group with any keys that have not
        // explicitly had a group set.
        const defaultGroup = __(&#039;Options:&#039;);
        if (!groups[defaultGroup])
            groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        // display &#039;Options:&#039; table along with any custom tables:
        Object.keys(groups).forEach((groupName) =&gt; {
            if (!groups[groupName].length)
                return;
            // if we&#039;ve grouped the key &#039;f&#039;, but &#039;f&#039; aliases &#039;foobar&#039;,
            // normalizedKeys should contain only &#039;foobar&#039;.
            const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) =&gt; {
                if (~aliasKeys.indexOf(key))
                    return key;
                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
                    if (~(options.alias[aliasKey] || []).indexOf(key))
                        return aliasKey;
                }
                return key;
            });
            if (normalizedKeys.length &lt; 1)
                return;
            ui.div(groupName);
            // actually generate the switches string --foo, -f, --bar.
            const switches = normalizedKeys.reduce((acc, key) =&gt; {
                acc[key] = [key].concat(options.alias[key] || [])
                    .map(sw =&gt; {
                    // for the special positional group don&#039;t
                    // add &#039;--&#039; or &#039;-&#039; prefix.
                    if (groupName === self.getPositionalGroupName())
                        return sw;
                    else {
                        return (
                        // matches yargs-parser logic in which single-digits
                        // aliases declared with a boolean type are now valid
                        /^[0-9]$/.test(sw)
                            ? ~options.boolean.indexOf(key) ? &#039;-&#039; : &#039;--&#039;
                            : sw.length &gt; 1 ? &#039;--&#039; : &#039;-&#039;) + sw;
                    }
                })
                    .join(&#039;, &#039;);
                return acc;
            }, {});
            normalizedKeys.forEach((key) =&gt; {
                const kswitch = switches[key];
                let desc = descriptions[key] || &#039;&#039;;
                let type = null;
                if (~desc.lastIndexOf(deferY18nLookupPrefix))
                    desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (~options.boolean.indexOf(key))
                    type = `[${__(&#039;boolean&#039;)}]`;
                if (~options.count.indexOf(key))
                    type = `[${__(&#039;count&#039;)}]`;
                if (~options.string.indexOf(key))
                    type = `[${__(&#039;string&#039;)}]`;
                if (~options.normalize.indexOf(key))
                    type = `[${__(&#039;string&#039;)}]`;
                if (~options.array.indexOf(key))
                    type = `[${__(&#039;array&#039;)}]`;
                if (~options.number.indexOf(key))
                    type = `[${__(&#039;number&#039;)}]`;
                const deprecatedExtra = (deprecated) =&gt; typeof deprecated === &#039;string&#039;
                    ? `[${__(&#039;deprecated: %s&#039;, deprecated)}]`
                    : `[${__(&#039;deprecated&#039;)}]`;
                const extra = [
                    (key in deprecatedOptions) ? deprecatedExtra(deprecatedOptions[key]) : null,
                    type,
                    (key in demandedOptions) ? `[${__(&#039;required&#039;)}]` : null,
                    options.choices &amp;&amp; options.choices[key] ? `[${__(&#039;choices:&#039;)} ${self.stringifiedValues(options.choices[key])}]` : null,
                    defaultString(options.default[key], options.defaultDescription[key])
                ].filter(Boolean).join(&#039; &#039;);
                ui.span({ text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 }, desc);
                if (extra)
                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: &#039;right&#039; });
                else
                    ui.div();
            });
            ui.div();
        });
        // describe some common use-cases for your application.
        if (examples.length) {
            ui.div(__(&#039;Examples:&#039;));
            examples.forEach((example) =&gt; {
                example[0] = example[0].replace(/\$0/g, base$0);
            });
            examples.forEach((example) =&gt; {
                if (example[1] === &#039;&#039;) {
                    ui.div({
                        text: example[0],
                        padding: [0, 2, 0, 2]
                    });
                }
                else {
                    ui.div({
                        text: example[0],
                        padding: [0, 2, 0, 2],
                        width: maxWidth(examples, theWrap) + 4
                    }, {
                        text: example[1]
                    });
                }
            });
            ui.div();
        }
        // the usage string.
        if (epilogs.length &gt; 0) {
            const e = epilogs.map(epilog =&gt; epilog.replace(/\$0/g, base$0)).join(&#039;\n&#039;);
            ui.div(`${e}\n`);
        }
        // Remove the trailing white spaces
        return ui.toString().replace(/\s*$/, &#039;&#039;);
    };
    // return the maximum width of a string
    // in the left-hand column of a table.
    function maxWidth(table, theWrap, modifier) {
        let width = 0;
        // table might be of the form [leftColumn],
        // or {key: leftColumn}
        if (!Array.isArray(table)) {
            table = Object.values(table).map(v =&gt; [v]);
        }
        table.forEach((v) =&gt; {
            width = Math.max(stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]), width);
        });
        // if we&#039;ve enabled &#039;wrap&#039; we should limit
        // the max-width of the left-column.
        if (theWrap)
            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
    }
    // make sure any options set for aliases,
    // are copied to the keys being aliased.
    function normalizeAliases() {
        // handle old demanded API
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach((key) =&gt; {
            options.alias[key].forEach((alias) =&gt; {
                // copy descriptions.
                if (descriptions[alias])
                    self.describe(key, descriptions[alias]);
                // copy demanded.
                if (alias in demandedOptions)
                    yargs.demandOption(key, demandedOptions[alias]);
                // type messages.
                if (~options.boolean.indexOf(alias))
                    yargs.boolean(key);
                if (~options.count.indexOf(alias))
                    yargs.count(key);
                if (~options.string.indexOf(alias))
                    yargs.string(key);
                if (~options.normalize.indexOf(alias))
                    yargs.normalize(key);
                if (~options.array.indexOf(alias))
                    yargs.array(key);
                if (~options.number.indexOf(alias))
                    yargs.number(key);
            });
        });
    }
    // if yargs is executing an async handler, we take a snapshot of the
    // help message to display on failure:
    let cachedHelpMessage;
    self.cacheHelpMessage = function () {
        cachedHelpMessage = this.help();
    };
    // however this snapshot must be cleared afterwards
    // not to be be used by next calls to parse
    self.clearCachedHelpMessage = function () {
        cachedHelpMessage = undefined;
    };
    // given a set of keys, place any keys that are
    // ungrouped under the &#039;Options:&#039; grouping.
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach((group) =&gt; {
            groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach((key) =&gt; {
            toCheck = [key].concat(aliases[key]);
            if (!toCheck.some(k =&gt; groupedKeys.indexOf(k) !== -1)) {
                groups[defaultGroup].push(key);
            }
        });
        return groupedKeys;
    }
    function filterHiddenOptions(key) {
        return yargs.getOptions().hiddenOptions.indexOf(key) &lt; 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
    }
    self.showHelp = (level) =&gt; {
        const logger = yargs._getLoggerInstance();
        if (!level)
            level = &#039;error&#039;;
        const emit = typeof level === &#039;function&#039; ? level : logger[level];
        emit(self.help());
    };
    self.functionDescription = (fn) =&gt; {
        const description = fn.name ? decamelize(fn.name, &#039;-&#039;) : __(&#039;generated-value&#039;);
        return [&#039;(&#039;, description, &#039;)&#039;].join(&#039;&#039;);
    };
    self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = &#039;&#039;;
        const sep = separator || &#039;, &#039;;
        const array = [].concat(values);
        if (!values || !array.length)
            return string;
        array.forEach((value) =&gt; {
            if (string.length)
                string += sep;
            string += JSON.stringify(value);
        });
        return string;
    };
    // format the default-value-string displayed in
    // the right-hand column.
    function defaultString(value, defaultDescription) {
        let string = `[${__(&#039;default:&#039;)} `;
        if (value === undefined &amp;&amp; !defaultDescription)
            return null;
        if (defaultDescription) {
            string += defaultDescription;
        }
        else {
            switch (typeof value) {
                case &#039;string&#039;:
                    string += `&quot;${value}&quot;`;
                    break;
                case &#039;object&#039;:
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
            }
        }
        return `${string}]`;
    }
    // guess the width of the console window, max-width 80.
    function windowWidth() {
        const maxWidth = 80;
        // CI is not a TTY
        /* c8 ignore next 2 */
        if (typeof process === &#039;object&#039; &amp;&amp; process.stdout &amp;&amp; process.stdout.columns) {
            return Math.min(maxWidth, process.stdout.columns);
        }
        else {
            return maxWidth;
        }
    }
    // logic for displaying application version.
    let version = null;
    self.version = (ver) =&gt; {
        version = ver;
    };
    self.showVersion = () =&gt; {
        const logger = yargs._getLoggerInstance();
        logger.log(version);
    };
    self.reset = function reset(localLookup) {
        // do not reset wrap here
        // do not reset fails here
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = obj_filter_1.objFilter(descriptions, k =&gt; !localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, undefined);
        ({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions
        } = frozen);
    };
    return self;
}
exports.usage = usage;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
