<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/node-jose/lib/jwk/keystore.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/node-jose/lib/jwk/keystore.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">702</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">66.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.62</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * jwk/keystore.js - JWK KeyStore Implementation
 *
 * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
 */
&quot;use strict&quot;;

var clone = require(&quot;lodash/clone&quot;),
    merge = require(&quot;../util/merge&quot;),
    forge = require(&quot;../deps/forge&quot;),
    util = require(&quot;../util&quot;);

var JWK = {
  BaseKey: require(&quot;./basekey.js&quot;),
  helpers: require(&quot;./helpers.js&quot;)
};

/**
 * @class JWK.KeyStoreRegistry
 * @classdesc
 * A registry of JWK.Key types that can be used.
 *
 * @description
 * **NOTE:** This constructor cannot be called directly. Instead use the
 * global {JWK.registry}
 */
var JWKRegistry = function() {
  var types = {};

  Object.defineProperty(this, &quot;register&quot;, {
    value: function(factory) {
      if (!factory || &quot;string&quot; !== typeof factory.kty || !factory.kty) {
        throw new Error(&quot;invalid Key factory&quot;);
      }

      var kty = factory.kty;
      types[kty] = factory;
      return this;
    }
  });
  Object.defineProperty(this, &quot;unregister&quot;, {
    value: function(factory) {
      if (!factory || &quot;string&quot; !== typeof factory.kty || !factory.kty) {
        throw new Error(&quot;invalid Key factory&quot;);
      }

      var kty = factory.kty;
      if (factory === types[kty]) {
        delete types[kty];
      }
      return this;
    }
  });

  Object.defineProperty(this, &quot;get&quot;, {
    value: function(kty) {
      return types[kty || &quot;&quot;] || undefined;
    }
  });
  Object.defineProperty(this, &quot;all&quot;, {
    value: function() {
      return Object.keys(types).map(function(t) { return types[t]; });
    }
  });
};

// Globals
var GLOBAL_REGISTRY = new JWKRegistry();

// importer
function processCert(input) {
  // convert certIssuer to readable attributes
  [&quot;certIssuer&quot;, &quot;certSubject&quot;].forEach(function(field) {
    /* eslint new-cap: [0] */
    var attrs = forge.pki.RDNAttributesAsArray(input[field]);
    var result = input[field] = {};
    attrs.forEach(function(a) {
      result[a.name || a.type] = a.value;
    });
  });

  return input;
}

function fromPEM(input) {
  var result = {};
  var pems = forge.pem.decode(input);
  var found = pems.some(function(p) {
    switch (p.type) {
      case &quot;CERTIFICATE&quot;:
        result.form = &quot;pkix&quot;;
        break;
      case &quot;PUBLIC KEY&quot;:
        result.form = &quot;spki&quot;;
        break;
      case &quot;PRIVATE KEY&quot;:
        result.form = &quot;pkcs8&quot;;
        break;
      case &quot;EC PRIVATE KEY&quot;:
        /* eslint no-fallthrough: [0] */
      case &quot;RSA PRIVATE KEY&quot;:
        result.form = &quot;private&quot;;
        break;
      default:
        return false;
    }

    result.body = p.body;
    return true;
  });
  if (!found) {
    throw new Error(&quot;supported PEM type not found&quot;);
  }
  return result;
}
function importFrom(registry, input) {
  // form can be one of:
  //  &#039;private&#039; | &#039;pkcs8&#039; | &#039;public&#039; | &#039;spki&#039; | &#039;pkix&#039; | &#039;x509&#039;
  var capture = {},
      errors = [],
      result;

  // conver from DER to ASN1
  var form = input.form,
      der = input.body,
      thumbprint = null;
  input = forge.asn1.fromDer(der);
  switch(form) {
    case &quot;private&quot;:
      registry.all().some(function(factory) {
        if (result) {
          return false;
        }
        if (!factory.validators) {
          return false;
        }

        var oid = factory.validators.oid,
            validator = factory.validators.privateKey;
        if (!validator) {
          return false;
        }
        capture = {};
        errors = [];
        result = forge.asn1.validate(input, validator, capture, errors);
        if (result) {
          capture.keyOid = forge.asn1.oidToDer(oid);
          capture.parsed = true;
        }
        return result;
      });
      capture.type = &quot;private&quot;;
      break;
    case &quot;pkcs8&quot;:
      result = forge.asn1.validate(input, JWK.helpers.validators.privateKey, capture, errors);
      capture.type = &quot;private&quot;;
      break;
    case &quot;public&quot;:
      // eslint no-fallthrough: [0] */
    case &quot;spki&quot;:
      result = forge.asn1.validate(input, JWK.helpers.validators.publicKey, capture, errors);
      capture.type = &quot;public&quot;;
      break;
    case &quot;pkix&quot;:
      /* eslint no-fallthrough: [0] */
    case &quot;x509&quot;:
      result = forge.asn1.validate(input, JWK.helpers.validators.certificate, capture, errors);
      if (result) {
        capture = processCert(capture);
        var md = forge.md.sha1.create();
        md.update(der);
        thumbprint = util.base64url.encode(Buffer.from(md.digest().toHex(), &quot;hex&quot;));
      }
      capture.type = &quot;public&quot;;
      break;
  }
  if (!result) {
    return null;
  }

  // convert oids
  if (capture.keyOid) {
    capture.keyOid = forge.asn1.derToOid(capture.keyOid);
  }

  // find and invoke the importer
  result = null;
  GLOBAL_REGISTRY.all().forEach(function(factory) {
    if (result) {
      return;
    }
    if (!factory) {
      return;
    }
    if (&quot;function&quot; !== typeof factory.import) {
      return;
    }
    result = factory.import(capture);
  });
  if (result &amp;&amp; capture.certSubject &amp;&amp; capture.certSubject.commonName) {
    result.kid = capture.certSubject.commonName;
  }
  if (result &amp;&amp; thumbprint) {
    result.x5t = thumbprint;
  }
  return result;
}

/**
 * @class JWK.KeyStore
 * @classdesc
 * Represents a collection of Keys.
 *
 * @description
 * **NOTE:** This constructor cannot be called directly. Instead call {@link
 * JWK.createKeyStore}.
 */
var JWKStore = function(registry, parent) {
  var keysets = {};

  /**
   * @method JWK.KeyStore#generate
   * @description
   * Generates a new random Key into this KeyStore.
   *
   * The type of {size} depends on the value of {kty}:
   *
   * + **`EC`**: String naming the curve to use, which can be one of:
   *   `&quot;P-256&quot;`, `&quot;P-384&quot;`, or `&quot;P-521&quot;` (default is **`&quot;P-256&quot;`**).
   * + **`RSA`**: Number describing the size of the key, in bits (default is
   *   **`2048`**).
   * + **`oct`**: Number describing the size of the key, in bits (default is
   *   **`256`**).
   *
   * Any properties in {props} are applied before the key is generated,
   * and are expected to be data types acceptable in JSON.  This allows the
   * generated key to have a specific key identifier, or to specify its
   * acceptable usage.
   *
   * The returned Promise, when fulfilled, returns the generated Key.
   *
   * @param {String} kty The type of generated key
   * @param {String|Number} [size] The size of the generated key
   * @param {Object} [props] Additional properties to apply to the generated
   *        key.
   * @returns {Promise} The promise for the generated Key
   * @throws {Error} If {kty} is not supported
   */
  Object.defineProperty(this, &quot;generate&quot;, {
    value: function(kty, size, props) {
      var keytype = registry.get(kty);
      if (!keytype) {
        return Promise.reject(new Error(&quot;unsupported key type&quot;));
      }

      props = clone(props || {});
      props.kty = kty;

      var self = this,
          promise = keytype.generate(size);
      return promise.then(function(jwk) {
        jwk = merge(props, jwk, {
          kty: kty
        });
        return self.add(jwk);
      });
    }
  });
  /**
   * @method JWK.KeyStore#add
   * @description
   * Adds a Key to this KeyStore. If {jwk} is a string, it is first
   * parsed into a plain JSON object. If {jwk} is already an instance
   * of JWK.Key, its (public) JSON representation is first obtained
   * then applied to a new JWK.Key object within this KeyStore.
   *
   * @param {String|Object} jwk The JSON Web Key (JWK)
   * @param {String} [form] The format of a String key to expect
   * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg &quot;pem&quot;)
   * @returns {Promise} The promise for the added key
   */
  Object.defineProperty(this, &quot;add&quot;, {
    value: function(jwk, form, extras) {
      extras = extras || {};

      var factors;
      if (Buffer.isBuffer(jwk) || typeof jwk === &quot;string&quot;) {
        // form can be &#039;json&#039;, &#039;pkcs8&#039;, &#039;spki&#039;, &#039;pkix&#039;, &#039;x509&#039;, &#039;pem&#039;
        form = (form || &quot;json&quot;).toLowerCase();
        if (&quot;json&quot; === form) {
          jwk = JSON.parse(jwk.toString(&quot;utf8&quot;));
        } else {
          try {
            if (&quot;pem&quot; === form) {
              // convert *first* PEM -&gt; DER
              factors = fromPEM(jwk);
            } else {
              factors = {
                body: jwk.toString(&quot;binary&quot;),
                form: form
              };
            }
            jwk = importFrom(registry, factors);
            if (!jwk) {
              throw new Error(&quot;no importer for key&quot;);
            }
            Object.keys(extras).forEach(function(field){
              jwk[field] = extras[field];
            });
          } catch (err) {
            return Promise.reject(err);
          }
        }
      } else if (JWKStore.isKey(jwk)) {
        // assume a complete duplicate is desired
        jwk = jwk.toJSON(true);
      } else {
        jwk = clone(jwk);
      }

      var keytype = registry.get(jwk.kty);
      if (!keytype) {
        return Promise.reject(new Error(&quot;unsupported key type&quot;));
      }

      var self = this,
          promise = keytype.prepare(jwk);
      return promise.then(function(cfg) {
        return new JWK.BaseKey(jwk.kty, self, jwk, cfg);
      }).then(function(jwk) {
        var kid = jwk.kid || &quot;&quot;;
        var keys = keysets[kid] = keysets[kid] || [];
        keys.push(jwk);

        return jwk;
      });
    }
  });
  /**
   * @method JWK.KeyStore#remove
   * @description
   * Removes a Key from this KeyStore.
   *
   * **NOTE:** The removed Key&#039;s {keystore} property is not changed.
   *
   * @param {JWK.Key} jwk The key to remove.
   */
  Object.defineProperty(this, &quot;remove&quot;, {
    value: function(jwk) {
      if (!jwk) {
        return;
      }

      var keys = keysets[jwk.kid];
      if (!keys) {
        return;
      }

      var pos = keys.indexOf(jwk);
      if (pos === -1) {
        return;
      }

      keys.splice(pos, 1);
      if (!keys.length) {
        delete keysets[jwk.kid];
      }
    }
  });

  /**
   * @method JWK.KeyStore#all
   * @description
   * Retrieves all of the contained Keys that optinally match all of the
   * given properties.
   *
   * If {props} are specified, this method only returns Keys which exactly
   * match the given properties. The properties can be any of the
   * following:
   *
   * + **alg**: The algorithm for the Key.
   * + **use**: The usage for the Key.
   * + **kid**: The identifier for the Key.
   *
   * If no properties are given, this method returns all of the Keys for this
   * KeyStore.
   *
   * @param {Object} [props] The properties to match against
   * @param {Boolean} [local = false] `true` if only the Keys
   *        directly contained by this KeyStore should be returned, or
   *        `false` if it should return all Keys of this KeyStore and
   *        its ancestors.
   * @returns {JWK.Key[]} The list of matching Keys, or an empty array if no
   *          matches are found.
   */
  Object.defineProperty(this, &quot;all&quot;, {
    value: function(props, local) {
      props = props || {};

      // workaround for issues/109
      if (props.kid !== undefined &amp;&amp; props.kid !== null &amp;&amp; typeof props.kid !== &quot;string&quot;) {
        props.kid = String(props.kid);
      }

      var candidates = [];
      var matches = function(key) {
        // match on &#039;kty&#039;
        if (props.kty &amp;&amp;
            key.kty &amp;&amp;
            props.kty !== key.kty) {
          return false;
        }
        // match on &#039;use&#039;
        if (props.use &amp;&amp;
            key.use &amp;&amp;
            props.use !== key.use) {
          return false;
        }
        // match on &#039;alg&#039;
        if (props.alg) {
          if (props.alg !== &quot;dir&quot; &amp;&amp;
              key.alg &amp;&amp;
              props.alg !== key.alg) {
            return false;
          }
          return key.supports(props.alg);
        }
        //TODO: match on &#039;key_ops&#039;

        return true;
      };
      Object.keys(keysets).forEach(function(id) {
        if (props.kid &amp;&amp; props.kid !== id) {
          return;
        }

        var keys = keysets[id].filter(matches);
        if (keys.length) {
          candidates = candidates.concat(keys);
        }
      });

      if (!local &amp;&amp; parent) {
        candidates = candidates.concat(parent.all(props));
      }

      return candidates;
    }
  });
  /**
   * @method JWK.KeyStore#get
   * @description
   * Retrieves the contained Key matching the given {kid}, and optionally
   * all of the given properties.  This method equivalent to calling
   * {@link JWK.Store#all}, then returning the first Key whose
   * &quot;kid&quot; is {kid}. If {kid} is undefined, then the first Key that
   * is returned from `all()` is returned.
   *
   * @param {String} [kid] The key identifier to match against.
   * @param {Object} [props] The properties to match against.
   * @param {Boolean} [local = false] `true` if only the Keys
   *        directly contained by this KeyStore should be returned, or
   *        `false` if it should return all Keys of this KeyStore and
   *        its ancestors.
   * @returns {JWK.Key} The Key matching {kid} and {props}, or `null`
   *          if no match is found.
   */
  Object.defineProperty(this, &quot;get&quot;, {
    value: function(kid, props, local) {
      // reconcile arguments
      if (typeof kid === &quot;boolean&quot;) {
        local = kid;
        props = kid = null;
      } else if (typeof kid === &quot;object&quot;) {
        local = props;
        props = kid;
        kid = null;
      }

      // fixup props
      props = props || {};
      if (kid) {
        props.kid = kid;
      }

      // workaround for issues/109
      if (props.kid !== undefined &amp;&amp; props.kid !== null &amp;&amp; typeof props.kid !== &quot;string&quot;) {
       props.kid = String(props.kid);
      }

      var candidates = this.all(props, true);
      if (!candidates.length &amp;&amp; parent &amp;&amp; !local) {
        candidates = parent.get(props, local);
      }
      return candidates[0] || null;
    }
  });

  /**
   * @method JWK.KeyStore#temp
   * @description
   * Creates a temporary KeyStore based on this KeyStore.
   *
   * @returns {JWK.KeyStore} The temporary KeyStore.
   */
  Object.defineProperty(this, &quot;temp&quot;, {
    value: function() {
      return new JWKStore(registry, this);
    }
  });

  /**
   * @method JWK.KeyStore#toJSON
   * @description
   * Generates a JSON representation of this KeyStore, which conforms
   * to a JWK Set from {I-D.ietf-jose-json-web-key}.
   *
   * @param {Boolean} [isPrivate = false] `true` if the private fields
   *        of stored keys are to be included.
   * @returns {Object} The JSON representation of this KeyStore.
   */
  Object.defineProperty(this, &quot;toJSON&quot;, {
    value: function(isPrivate) {
      var keys = [];

      Object.keys(keysets).forEach(function(kid) {
        var items = keysets[kid].map(function(k) {
          return k.toJSON(isPrivate);
        });
        keys = keys.concat(items);
      });

      return {
        keys: keys
      };
    }
  });
};

/**
 * Determines if the given object is an instance of JWK.KeyStore.
 *
 * @param {Object} obj The object to test
 * @returns {Boolean} `true` if {obj} is an instance of JWK.KeyStore,
 *          and `false` otherwise.
 */
JWKStore.isKeyStore = function(obj) {
  if (!obj) {
    return false;
  }

  if (&quot;object&quot; !== typeof obj) {
    return false;
  }

  if (&quot;function&quot; !== typeof obj.get ||
      &quot;function&quot; !== typeof obj.all ||
      &quot;function&quot; !== typeof obj.generate ||
      &quot;function&quot; !== typeof obj.add ||
      &quot;function&quot; !== typeof obj.remove) {
    return false;
  }

  return true;
};

/**
 * Creates a new empty KeyStore.
 *
 * @returns {JWK.KeyStore} The empty KeyStore.
 */
JWKStore.createKeyStore = function() {
  return new JWKStore(GLOBAL_REGISTRY);
};

/**
 * Coerces the given object into a KeyStore. This method uses the following
 * algorithm to coerce {ks}:
 *
 * 1. if {ks} is an instance of JWK.KeyStore, it is returned directly
 * 2. if {ks} is a string, it is parsed into a JSON value
 * 3. if {ks} is an array, it creates a new JWK.KeyStore and calls {@link
 *    JWK.KeyStore#add} for each element in the {ks} array.
 * 4. if {ks} is a JSON object, it creates a new JWK.KeyStore and calls {@link
 *    JWK.KeyStore#add} for each element in the &quot;keys&quot; property.
 *
 * @param {Object|String} ks The value to coerce into a
 *        KeyStore
 * @returns {Promise(JWK.KeyStore)} A promise for the coerced KeyStore.
 */
JWKStore.asKeyStore = function(ks) {
  if (JWKStore.isKeyStore(ks)) {
    return Promise.resolve(ks);
  }

  var store = JWKStore.createKeyStore(),
      keys;

  if (typeof ks === &quot;string&quot;) {
    ks = JSON.parse(ks);
  }

  if (Array.isArray(ks)) {
    keys = ks;
  } else if (&quot;keys&quot; in ks) {
    keys = ks.keys;
  } else {
    return Promise.reject(new Error(&quot;invalid keystore&quot;));
  }

  keys = keys.map(function(k) {
    return store.add(k);
  });

  var promise = Promise.all(keys);
  promise = promise.then(function() {
    return store;
  });

  return promise;
};


/**
 * Determines if the given object is a JWK.Key instance.
 *
 * @param {Object} obj The object to test
 * @returns `true` if {obj} is a JWK.Key
 */
JWKStore.isKey = function(obj) {
  if (!obj) {
    return false;
  }

  if (&quot;object&quot; !== typeof obj) {
    return false;
  }

  if (!JWKStore.isKeyStore(obj.keystore)) {
    return false;
  }

  if (&quot;string&quot; !== typeof obj.kty ||
      &quot;number&quot; !== typeof obj.length ||
      &quot;function&quot; !== typeof obj.algorithms ||
      &quot;function&quot; !== typeof obj.supports ||
      &quot;function&quot; !== typeof obj.encrypt ||
      &quot;function&quot; !== typeof obj.decrypt ||
      &quot;function&quot; !== typeof obj.wrap ||
      &quot;function&quot; !== typeof obj.unwrap ||
      &quot;function&quot; !== typeof obj.sign ||
      &quot;function&quot; !== typeof obj.verify) {
    return false;
  }

  return true;
};

/**
 * Creates a new key with the given properties.  This method is a convenience
 * to calling `JWK.createKeyStore()` then `generate()` on the returned keystore.
 *
 * @param {String} kty The type of generated key
 * @param {String|Number} [size] The size of the generated key
 * @param {Object} [props] Additional properties to apply to the generated
 *        key.
 * @returns {Promise} The promise for the generated Key
 * @throws {Error} If {kty} is not supported
 * @see JWKStore#generate
 */
JWKStore.createKey = function(kty, size, props) {
  var ks = JWKStore.createKeyStore();
  return ks.generate(kty, size, props);
}

/**
 * Coerces the given object into a Key. If {key} is an instance of JWK.Key,
 * it is returned directly. Otherwise, this method first creates a new
 * JWK.KeyStore and calls {@link JWK.KeyStore#add} on this new KeyStore.
 *
 * @param {Object|String} key The value to coerce into a Key
 * @param {String} [form] The format of a String Key to expect
 * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg &quot;pem&quot;)
 * @returns {Promise(JWK.Key)} A promise for the coerced Key.
 */
JWKStore.asKey = function(key, form, extras) {
  if (JWKStore.isKey(key)) {
    return Promise.resolve(key);
  }

  var ks = JWKStore.createKeyStore();
  key = ks.add(key, form, extras);

  return key;
};

module.exports = {
  KeyRegistry: JWKRegistry,
  KeyStore: JWKStore,
  registry: GLOBAL_REGISTRY
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
