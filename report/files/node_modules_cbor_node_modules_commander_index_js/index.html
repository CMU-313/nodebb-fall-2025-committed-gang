<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cbor/node_modules/commander/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cbor/node_modules/commander/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.84</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1334</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">124.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.50</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * Module dependencies.
 */

var EventEmitter = require(&#039;events&#039;).EventEmitter;
var spawn = require(&#039;child_process&#039;).spawn;
var path = require(&#039;path&#039;);
var dirname = path.dirname;
var basename = path.basename;
var fs = require(&#039;fs&#039;);

/**
 * Inherit `Command` from `EventEmitter.prototype`.
 */

require(&#039;util&#039;).inherits(Command, EventEmitter);

/**
 * Expose the root command.
 */

exports = module.exports = new Command();

/**
 * Expose `Command`.
 */

exports.Command = Command;

/**
 * Expose `Option`.
 */

exports.Option = Option;

/**
 * Initialize a new `Option` with the given `flags` and `description`.
 *
 * @param {String} flags
 * @param {String} description
 * @api public
 */

function Option(flags, description) {
  this.flags = flags;
  this.required = flags.indexOf(&#039;&lt;&#039;) &gt;= 0;
  this.optional = flags.indexOf(&#039;[&#039;) &gt;= 0;
  this.negate = flags.indexOf(&#039;-no-&#039;) !== -1;
  flags = flags.split(/[ ,|]+/);
  if (flags.length &gt; 1 &amp;&amp; !/^[[&lt;]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || &#039;&#039;;
}

/**
 * Return option name.
 *
 * @return {String}
 * @api private
 */

Option.prototype.name = function() {
  return this.long.replace(/^--/, &#039;&#039;);
};

/**
 * Return option name, in a camelcase format that can be used
 * as a object attribute key.
 *
 * @return {String}
 * @api private
 */

Option.prototype.attributeName = function() {
  return camelcase(this.name().replace(/^no-/, &#039;&#039;));
};

/**
 * Check if `arg` matches the short or long flag.
 *
 * @param {String} arg
 * @return {Boolean}
 * @api private
 */

Option.prototype.is = function(arg) {
  return this.short === arg || this.long === arg;
};

/**
 * Initialize a new `Command`.
 *
 * @param {String} name
 * @api public
 */

function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = new Set();
  this._allowUnknownOption = false;
  this._args = [];
  this._name = name || &#039;&#039;;

  this._helpFlags = &#039;-h, --help&#039;;
  this._helpDescription = &#039;output usage information&#039;;
  this._helpShortFlag = &#039;-h&#039;;
  this._helpLongFlag = &#039;--help&#039;;
}

/**
 * Define a command.
 *
 * There are two styles of command: pay attention to where to put the description.
 *
 * Examples:
 *
 *      // Command implemented using action handler (description is supplied separately to `.command`)
 *      program
 *        .command(&#039;clone &lt;source&gt; [destination]&#039;)
 *        .description(&#039;clone a repository into a newly created directory&#039;)
 *        .action((source, destination) =&gt; {
 *          console.log(&#039;clone command called&#039;);
 *        });
 *
 *      // Command implemented using separate executable file (description is second parameter to `.command`)
 *      program
 *        .command(&#039;start &lt;service&gt;&#039;, &#039;start named service&#039;)
 *        .command(&#039;stop [service]&#039;, &#039;stop named serice, or all if no name supplied&#039;);
 *
 * @param {string} nameAndArgs - command name and arguments, args are `&lt;required&gt;` or `[optional]` and last may also be `variadic...`
 * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
 * @param {Object} [execOpts] - configuration options (for executable)
 * @return {Command} returns new command for action handler, or top-level command for executable command
 * @api public
 */

Command.prototype.command = function(nameAndArgs, actionOptsOrExecDesc, execOpts) {
  var desc = actionOptsOrExecDesc;
  var opts = execOpts;
  if (typeof desc === &#039;object&#039; &amp;&amp; desc !== null) {
    opts = desc;
    desc = null;
  }
  opts = opts || {};
  var args = nameAndArgs.split(/ +/);
  var cmd = new Command(args.shift());

  if (desc) {
    cmd.description(desc);
    this.executables = true;
    this._execs.add(cmd._name);
    if (opts.isDefault) this.defaultExecutable = cmd._name;
  }
  cmd._noHelp = !!opts.noHelp;
  cmd._helpFlags = this._helpFlags;
  cmd._helpDescription = this._helpDescription;
  cmd._helpShortFlag = this._helpShortFlag;
  cmd._helpLongFlag = this._helpLongFlag;
  cmd._executableFile = opts.executableFile; // Custom name for executable file
  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;

  if (desc) return this;
  return cmd;
};

/**
 * Define argument syntax for the top-level command.
 *
 * @api public
 */

Command.prototype.arguments = function(desc) {
  return this.parseExpectedArgs(desc.split(/ +/));
};

/**
 * Add an implicit `help [cmd]` subcommand
 * which invokes `--help` for the given command.
 *
 * @api private
 */

Command.prototype.addImplicitHelpCommand = function() {
  this.command(&#039;help [cmd]&#039;, &#039;display help for [cmd]&#039;);
};

/**
 * Parse expected `args`.
 *
 * For example `[&quot;[type]&quot;]` becomes `[{ required: false, name: &#039;type&#039; }]`.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parseExpectedArgs = function(args) {
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg) {
    var argDetails = {
      required: false,
      name: &#039;&#039;,
      variadic: false
    };

    switch (arg[0]) {
      case &#039;&lt;&#039;:
        argDetails.required = true;
        argDetails.name = arg.slice(1, -1);
        break;
      case &#039;[&#039;:
        argDetails.name = arg.slice(1, -1);
        break;
    }

    if (argDetails.name.length &gt; 3 &amp;&amp; argDetails.name.slice(-3) === &#039;...&#039;) {
      argDetails.variadic = true;
      argDetails.name = argDetails.name.slice(0, -3);
    }
    if (argDetails.name) {
      self._args.push(argDetails);
    }
  });
  return this;
};

/**
 * Register callback `fn` for the command.
 *
 * Examples:
 *
 *      program
 *        .command(&#039;help&#039;)
 *        .description(&#039;display verbose help&#039;)
 *        .action(function() {
 *           // output help here
 *        });
 *
 * @param {Function} fn
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.action = function(fn) {
  var self = this;
  var listener = function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length &gt; 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required &amp;&amp; args[i] == null) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  };
  var parent = this.parent || this;
  var name = parent === this ? &#039;*&#039; : this._name;
  parent.on(&#039;command:&#039; + name, listener);
  if (this._alias) parent.on(&#039;command:&#039; + this._alias, listener);
  return this;
};

/**
 * Define option with `flags`, `description` and optional
 * coercion `fn`.
 *
 * The `flags` string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when `--help` is used.
 *
 *    &quot;-p, --pepper&quot;
 *    &quot;-p|--pepper&quot;
 *    &quot;-p --pepper&quot;
 *
 * Examples:
 *
 *     // simple boolean defaulting to undefined
 *     program.option(&#039;-p, --pepper&#039;, &#039;add pepper&#039;);
 *
 *     program.pepper
 *     // =&gt; undefined
 *
 *     --pepper
 *     program.pepper
 *     // =&gt; true
 *
 *     // simple boolean defaulting to true (unless non-negated option is also defined)
 *     program.option(&#039;-C, --no-cheese&#039;, &#039;remove cheese&#039;);
 *
 *     program.cheese
 *     // =&gt; true
 *
 *     --no-cheese
 *     program.cheese
 *     // =&gt; false
 *
 *     // required argument
 *     program.option(&#039;-C, --chdir &lt;path&gt;&#039;, &#039;change the working directory&#039;);
 *
 *     --chdir /tmp
 *     program.chdir
 *     // =&gt; &quot;/tmp&quot;
 *
 *     // optional argument
 *     program.option(&#039;-c, --cheese [type]&#039;, &#039;add cheese [marble]&#039;);
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|*} [fn] or default
 * @param {*} [defaultValue]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.option = function(flags, description, fn, defaultValue) {
  var self = this,
    option = new Option(flags, description),
    oname = option.name(),
    name = option.attributeName();

  // default as 3rd arg
  if (typeof fn !== &#039;function&#039;) {
    if (fn instanceof RegExp) {
      // This is a bit simplistic (especially no error messages), and probably better handled by caller using custom option processing.
      // No longer documented in README, but still present for backwards compatibility.
      var regex = fn;
      fn = function(val, def) {
        var m = regex.exec(val);
        return m ? m[0] : def;
      };
    } else {
      defaultValue = fn;
      fn = null;
    }
  }

  // preassign default value for --no-*, [optional], &lt;required&gt;, or plain flag if boolean value
  if (option.negate || option.optional || option.required || typeof defaultValue === &#039;boolean&#039;) {
    // when --no-foo we make sure default is true, unless a --foo option is already defined
    if (option.negate) {
      var opts = self.opts();
      defaultValue = Object.prototype.hasOwnProperty.call(opts, name) ? opts[name] : true;
    }
    // preassign only if we have a default
    if (defaultValue !== undefined) {
      self[name] = defaultValue;
      option.defaultValue = defaultValue;
    }
  }

  // register the option
  this.options.push(option);

  // when it&#039;s passed assign the value
  // and conditionally invoke the callback
  this.on(&#039;option:&#039; + oname, function(val) {
    // coercion
    if (val !== null &amp;&amp; fn) {
      val = fn(val, self[name] === undefined ? defaultValue : self[name]);
    }

    // unassigned or boolean value
    if (typeof self[name] === &#039;boolean&#039; || typeof self[name] === &#039;undefined&#039;) {
      // if no value, negate false, and we have a default, then use it!
      if (val == null) {
        self[name] = option.negate
          ? false
          : defaultValue || true;
      } else {
        self[name] = val;
      }
    } else if (val !== null) {
      // reassign
      self[name] = option.negate ? false : val;
    }
  });

  return this;
};

/**
 * Allow unknown options on the command line.
 *
 * @param {Boolean} arg if `true` or omitted, no error will be thrown
 * for unknown options.
 * @api public
 */
Command.prototype.allowUnknownOption = function(arg) {
  this._allowUnknownOption = arguments.length === 0 || arg;
  return this;
};

/**
 * Parse `argv`, settings options and invoking commands when defined.
 *
 * @param {Array} argv
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parse = function(argv) {
  // implicit help
  if (this.executables) this.addImplicitHelpCommand();

  // store raw args
  this.rawArgs = argv;

  // guess name
  this._name = this._name || basename(argv[1], &#039;.js&#039;);

  // github-style sub-commands with no sub-command
  if (this.executables &amp;&amp; argv.length &lt; 3 &amp;&amp; !this.defaultExecutable) {
    // this user needs help
    argv.push(this._helpLongFlag);
  }

  // process argv
  var normalized = this.normalize(argv.slice(2));
  var parsed = this.parseOptions(normalized);
  var args = this.args = parsed.args;

  var result = this.parseArgs(this.args, parsed.unknown);

  if (args[0] === &#039;help&#039; &amp;&amp; args.length === 1) this.help();

  // &lt;cmd&gt; --help
  if (args[0] === &#039;help&#039;) {
    args[0] = args[1];
    args[1] = this._helpLongFlag;
  }

  // executable sub-commands
  // (Debugging note for future: args[0] is not right if an action has been called)
  var name = result.args[0];
  var subCommand = null;

  // Look for subcommand
  if (name) {
    subCommand = this.commands.find(function(command) {
      return command._name === name;
    });
  }

  // Look for alias
  if (!subCommand &amp;&amp; name) {
    subCommand = this.commands.find(function(command) {
      return command.alias() === name;
    });
    if (subCommand) {
      name = subCommand._name;
      args[0] = name;
    }
  }

  // Look for default subcommand
  if (!subCommand &amp;&amp; this.defaultExecutable) {
    name = this.defaultExecutable;
    args.unshift(name);
    subCommand = this.commands.find(function(command) {
      return command._name === name;
    });
  }

  if (this._execs.has(name)) {
    return this.executeSubCommand(argv, args, parsed.unknown, subCommand ? subCommand._executableFile : undefined);
  }

  return result;
};

/**
 * Execute a sub-command executable.
 *
 * @param {Array} argv
 * @param {Array} args
 * @param {Array} unknown
 * @param {String} specifySubcommand
 * @api private
 */

Command.prototype.executeSubCommand = function(argv, args, unknown, executableFile) {
  args = args.concat(unknown);

  if (!args.length) this.help();

  var isExplicitJS = false; // Whether to use node to launch &quot;executable&quot;

  // executable
  var pm = argv[1];
  // name of the subcommand, like `pm-install`
  var bin = basename(pm, path.extname(pm)) + &#039;-&#039; + args[0];
  if (executableFile != null) {
    bin = executableFile;
    // Check for same extensions as we scan for below so get consistent launch behaviour.
    var executableExt = path.extname(executableFile);
    isExplicitJS = executableExt === &#039;.js&#039; || executableExt === &#039;.ts&#039; || executableExt === &#039;.mjs&#039;;
  }

  // In case of globally installed, get the base dir where executable
  //  subcommand file should be located at
  var baseDir;

  var resolvedLink = fs.realpathSync(pm);

  baseDir = dirname(resolvedLink);

  // prefer local `./&lt;bin&gt;` to bin in the $PATH
  var localBin = path.join(baseDir, bin);

  // whether bin file is a js script with explicit `.js` or `.ts` extension
  if (exists(localBin + &#039;.js&#039;)) {
    bin = localBin + &#039;.js&#039;;
    isExplicitJS = true;
  } else if (exists(localBin + &#039;.ts&#039;)) {
    bin = localBin + &#039;.ts&#039;;
    isExplicitJS = true;
  } else if (exists(localBin + &#039;.mjs&#039;)) {
    bin = localBin + &#039;.mjs&#039;;
    isExplicitJS = true;
  } else if (exists(localBin)) {
    bin = localBin;
  }

  args = args.slice(1);

  var proc;
  if (process.platform !== &#039;win32&#039;) {
    if (isExplicitJS) {
      args.unshift(bin);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);

      proc = spawn(process.argv[0], args, { stdio: &#039;inherit&#039;, customFds: [0, 1, 2] });
    } else {
      proc = spawn(bin, args, { stdio: &#039;inherit&#039;, customFds: [0, 1, 2] });
    }
  } else {
    args.unshift(bin);
    // add executable arguments to spawn
    args = incrementNodeInspectorPort(process.execArgv).concat(args);
    proc = spawn(process.execPath, args, { stdio: &#039;inherit&#039; });
  }

  var signals = [&#039;SIGUSR1&#039;, &#039;SIGUSR2&#039;, &#039;SIGTERM&#039;, &#039;SIGINT&#039;, &#039;SIGHUP&#039;];
  signals.forEach(function(signal) {
    process.on(signal, function() {
      if (proc.killed === false &amp;&amp; proc.exitCode === null) {
        proc.kill(signal);
      }
    });
  });
  proc.on(&#039;close&#039;, process.exit.bind(process));
  proc.on(&#039;error&#039;, function(err) {
    if (err.code === &#039;ENOENT&#039;) {
      console.error(&#039;error: %s(1) does not exist, try --help&#039;, bin);
    } else if (err.code === &#039;EACCES&#039;) {
      console.error(&#039;error: %s(1) not executable. try chmod or run with root&#039;, bin);
    }
    process.exit(1);
  });

  // Store the reference to the child process
  this.runningCommand = proc;
};

/**
 * Normalize `args`, splitting joined short flags. For example
 * the arg &quot;-abc&quot; is equivalent to &quot;-a -b -c&quot;.
 * This also normalizes equal sign and splits &quot;--abc=def&quot; into &quot;--abc def&quot;.
 *
 * @param {Array} args
 * @return {Array}
 * @api private
 */

Command.prototype.normalize = function(args) {
  var ret = [],
    arg,
    lastOpt,
    index,
    short,
    opt;

  for (var i = 0, len = args.length; i &lt; len; ++i) {
    arg = args[i];
    if (i &gt; 0) {
      lastOpt = this.optionFor(args[i - 1]);
    }

    if (arg === &#039;--&#039;) {
      // Honor option terminator
      ret = ret.concat(args.slice(i));
      break;
    } else if (lastOpt &amp;&amp; lastOpt.required) {
      ret.push(arg);
    } else if (arg.length &gt; 2 &amp;&amp; arg[0] === &#039;-&#039; &amp;&amp; arg[1] !== &#039;-&#039;) {
      short = arg.slice(0, 2);
      opt = this.optionFor(short);
      if (opt &amp;&amp; (opt.required || opt.optional)) {
        ret.push(short);
        ret.push(arg.slice(2));
      } else {
        arg.slice(1).split(&#039;&#039;).forEach(function(c) {
          ret.push(&#039;-&#039; + c);
        });
      }
    } else if (/^--/.test(arg) &amp;&amp; ~(index = arg.indexOf(&#039;=&#039;))) {
      ret.push(arg.slice(0, index), arg.slice(index + 1));
    } else {
      ret.push(arg);
    }
  }

  return ret;
};

/**
 * Parse command `args`.
 *
 * When listener(s) are available those
 * callbacks are invoked, otherwise the &quot;*&quot;
 * event is emitted and those actions are invoked.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api private
 */

Command.prototype.parseArgs = function(args, unknown) {
  var name;

  if (args.length) {
    name = args[0];
    if (this.listeners(&#039;command:&#039; + name).length) {
      this.emit(&#039;command:&#039; + args.shift(), args, unknown);
    } else {
      this.emit(&#039;command:*&#039;, args);
    }
  } else {
    outputHelpIfNecessary(this, unknown);

    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length &gt; 0) {
      this.unknownOption(unknown[0]);
    }
    if (this.commands.length === 0 &amp;&amp;
        this._args.filter(function(a) { return a.required; }).length === 0) {
      this.emit(&#039;command:*&#039;);
    }
  }

  return this;
};

/**
 * Return an option matching `arg` if any.
 *
 * @param {String} arg
 * @return {Option}
 * @api private
 */

Command.prototype.optionFor = function(arg) {
  for (var i = 0, len = this.options.length; i &lt; len; ++i) {
    if (this.options[i].is(arg)) {
      return this.options[i];
    }
  }
};

/**
 * Parse options from `argv` returning `argv`
 * void of these options.
 *
 * @param {Array} argv
 * @return {Array}
 * @api public
 */

Command.prototype.parseOptions = function(argv) {
  var args = [],
    len = argv.length,
    literal,
    option,
    arg;

  var unknownOptions = [];

  // parse options
  for (var i = 0; i &lt; len; ++i) {
    arg = argv[i];

    // literal args after --
    if (literal) {
      args.push(arg);
      continue;
    }

    if (arg === &#039;--&#039;) {
      literal = true;
      continue;
    }

    // find matching Option
    option = this.optionFor(arg);

    // option is defined
    if (option) {
      // requires arg
      if (option.required) {
        arg = argv[++i];
        if (arg == null) return this.optionMissingArgument(option);
        this.emit(&#039;option:&#039; + option.name(), arg);
      // optional arg
      } else if (option.optional) {
        arg = argv[i + 1];
        if (arg == null || (arg[0] === &#039;-&#039; &amp;&amp; arg !== &#039;-&#039;)) {
          arg = null;
        } else {
          ++i;
        }
        this.emit(&#039;option:&#039; + option.name(), arg);
      // flag
      } else {
        this.emit(&#039;option:&#039; + option.name());
      }
      continue;
    }

    // looks like an option
    if (arg.length &gt; 1 &amp;&amp; arg[0] === &#039;-&#039;) {
      unknownOptions.push(arg);

      // If the next argument looks like it might be
      // an argument for this option, we pass it on.
      // If it isn&#039;t, then it&#039;ll simply be ignored
      if ((i + 1) &lt; argv.length &amp;&amp; (argv[i + 1][0] !== &#039;-&#039; || argv[i + 1] === &#039;-&#039;)) {
        unknownOptions.push(argv[++i]);
      }
      continue;
    }

    // arg
    args.push(arg);
  }

  return { args: args, unknown: unknownOptions };
};

/**
 * Return an object containing options as key-value pairs
 *
 * @return {Object}
 * @api public
 */
Command.prototype.opts = function() {
  var result = {},
    len = this.options.length;

  for (var i = 0; i &lt; len; i++) {
    var key = this.options[i].attributeName();
    result[key] = key === this._versionOptionName ? this._version : this[key];
  }
  return result;
};

/**
 * Argument `name` is missing.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.missingArgument = function(name) {
  console.error(&quot;error: missing required argument &#039;%s&#039;&quot;, name);
  process.exit(1);
};

/**
 * `Option` is missing an argument, but received `flag` or nothing.
 *
 * @param {String} option
 * @param {String} flag
 * @api private
 */

Command.prototype.optionMissingArgument = function(option, flag) {
  if (flag) {
    console.error(&quot;error: option &#039;%s&#039; argument missing, got &#039;%s&#039;&quot;, option.flags, flag);
  } else {
    console.error(&quot;error: option &#039;%s&#039; argument missing&quot;, option.flags);
  }
  process.exit(1);
};

/**
 * Unknown option `flag`.
 *
 * @param {String} flag
 * @api private
 */

Command.prototype.unknownOption = function(flag) {
  if (this._allowUnknownOption) return;
  console.error(&quot;error: unknown option &#039;%s&#039;&quot;, flag);
  process.exit(1);
};

/**
 * Variadic argument with `name` is not the last argument as required.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.variadicArgNotLast = function(name) {
  console.error(&quot;error: variadic arguments must be last &#039;%s&#039;&quot;, name);
  process.exit(1);
};

/**
 * Set the program version to `str`.
 *
 * This method auto-registers the &quot;-V, --version&quot; flag
 * which will print the version number when passed.
 *
 * You can optionally supply the  flags and description to override the defaults.
 *
 * @param {String} str
 * @param {String} [flags]
 * @param {String} [description]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.version = function(str, flags, description) {
  if (arguments.length === 0) return this._version;
  this._version = str;
  flags = flags || &#039;-V, --version&#039;;
  description = description || &#039;output the version number&#039;;
  var versionOption = new Option(flags, description);
  this._versionOptionName = versionOption.long.substr(2) || &#039;version&#039;;
  this.options.push(versionOption);
  this.on(&#039;option:&#039; + this._versionOptionName, function() {
    process.stdout.write(str + &#039;\n&#039;);
    process.exit(0);
  });
  return this;
};

/**
 * Set the description to `str`.
 *
 * @param {String} str
 * @param {Object} argsDescription
 * @return {String|Command}
 * @api public
 */

Command.prototype.description = function(str, argsDescription) {
  if (arguments.length === 0) return this._description;
  this._description = str;
  this._argsDescription = argsDescription;
  return this;
};

/**
 * Set an alias for the command
 *
 * @param {String} alias
 * @return {String|Command}
 * @api public
 */

Command.prototype.alias = function(alias) {
  var command = this;
  if (this.commands.length !== 0) {
    command = this.commands[this.commands.length - 1];
  }

  if (arguments.length === 0) return command._alias;

  if (alias === command._name) throw new Error(&#039;Command alias can\&#039;t be the same as its name&#039;);

  command._alias = alias;
  return this;
};

/**
 * Set / get the command usage `str`.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.usage = function(str) {
  var args = this._args.map(function(arg) {
    return humanReadableArgName(arg);
  });

  var usage = &#039;[options]&#039; +
    (this.commands.length ? &#039; [command]&#039; : &#039;&#039;) +
    (this._args.length ? &#039; &#039; + args.join(&#039; &#039;) : &#039;&#039;);

  if (arguments.length === 0) return this._usage || usage;
  this._usage = str;

  return this;
};

/**
 * Get or set the name of the command
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.name = function(str) {
  if (arguments.length === 0) return this._name;
  this._name = str;
  return this;
};

/**
 * Return prepared commands.
 *
 * @return {Array}
 * @api private
 */

Command.prototype.prepareCommands = function() {
  return this.commands.filter(function(cmd) {
    return !cmd._noHelp;
  }).map(function(cmd) {
    var args = cmd._args.map(function(arg) {
      return humanReadableArgName(arg);
    }).join(&#039; &#039;);

    return [
      cmd._name +
        (cmd._alias ? &#039;|&#039; + cmd._alias : &#039;&#039;) +
        (cmd.options.length ? &#039; [options]&#039; : &#039;&#039;) +
        (args ? &#039; &#039; + args : &#039;&#039;),
      cmd._description
    ];
  });
};

/**
 * Return the largest command length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestCommandLength = function() {
  var commands = this.prepareCommands();
  return commands.reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);
};

/**
 * Return the largest option length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestOptionLength = function() {
  var options = [].slice.call(this.options);
  options.push({
    flags: this._helpFlags
  });

  return options.reduce(function(max, option) {
    return Math.max(max, option.flags.length);
  }, 0);
};

/**
 * Return the largest arg length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestArgLength = function() {
  return this._args.reduce(function(max, arg) {
    return Math.max(max, arg.name.length);
  }, 0);
};

/**
 * Return the pad width.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.padWidth = function() {
  var width = this.largestOptionLength();
  if (this._argsDescription &amp;&amp; this._args.length) {
    if (this.largestArgLength() &gt; width) {
      width = this.largestArgLength();
    }
  }

  if (this.commands &amp;&amp; this.commands.length) {
    if (this.largestCommandLength() &gt; width) {
      width = this.largestCommandLength();
    }
  }

  return width;
};

/**
 * Return help for options.
 *
 * @return {String}
 * @api private
 */

Command.prototype.optionHelp = function() {
  var width = this.padWidth();

  // Append the help information
  return this.options.map(function(option) {
    return pad(option.flags, width) + &#039;  &#039; + option.description +
      ((!option.negate &amp;&amp; option.defaultValue !== undefined) ? &#039; (default: &#039; + JSON.stringify(option.defaultValue) + &#039;)&#039; : &#039;&#039;);
  }).concat([pad(this._helpFlags, width) + &#039;  &#039; + this._helpDescription])
    .join(&#039;\n&#039;);
};

/**
 * Return command help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.commandHelp = function() {
  if (!this.commands.length) return &#039;&#039;;

  var commands = this.prepareCommands();
  var width = this.padWidth();

  return [
    &#039;Commands:&#039;,
    commands.map(function(cmd) {
      var desc = cmd[1] ? &#039;  &#039; + cmd[1] : &#039;&#039;;
      return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
    }).join(&#039;\n&#039;).replace(/^/gm, &#039;  &#039;),
    &#039;&#039;
  ].join(&#039;\n&#039;);
};

/**
 * Return program help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [
      this._description,
      &#039;&#039;
    ];

    var argsDescription = this._argsDescription;
    if (argsDescription &amp;&amp; this._args.length) {
      var width = this.padWidth();
      desc.push(&#039;Arguments:&#039;);
      desc.push(&#039;&#039;);
      this._args.forEach(function(arg) {
        desc.push(&#039;  &#039; + pad(arg.name, width) + &#039;  &#039; + argsDescription[arg.name]);
      });
      desc.push(&#039;&#039;);
    }
  }

  var cmdName = this._name;
  if (this._alias) {
    cmdName = cmdName + &#039;|&#039; + this._alias;
  }
  var parentCmdNames = &#039;&#039;;
  for (var parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {
    parentCmdNames = parentCmd.name() + &#039; &#039; + parentCmdNames;
  }
  var usage = [
    &#039;Usage: &#039; + parentCmdNames + cmdName + &#039; &#039; + this.usage(),
    &#039;&#039;
  ];

  var cmds = [];
  var commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = [
    &#039;Options:&#039;,
    &#039;&#039; + this.optionHelp().replace(/^/gm, &#039;  &#039;),
    &#039;&#039;
  ];

  return usage
    .concat(desc)
    .concat(options)
    .concat(cmds)
    .join(&#039;\n&#039;);
};

/**
 * Output help information for this command.
 *
 * When listener(s) are available for the helpLongFlag
 * those callbacks are invoked.
 *
 * @api public
 */

Command.prototype.outputHelp = function(cb) {
  if (!cb) {
    cb = function(passthru) {
      return passthru;
    };
  }
  const cbOutput = cb(this.helpInformation());
  if (typeof cbOutput !== &#039;string&#039; &amp;&amp; !Buffer.isBuffer(cbOutput)) {
    throw new Error(&#039;outputHelp callback must return a string or a Buffer&#039;);
  }
  process.stdout.write(cbOutput);
  this.emit(this._helpLongFlag);
};

/**
 * You can pass in flags and a description to override the help
 * flags and help description for your command.
 *
 * @param {String} [flags]
 * @param {String} [description]
 * @return {Command}
 * @api public
 */

Command.prototype.helpOption = function(flags, description) {
  this._helpFlags = flags || this._helpFlags;
  this._helpDescription = description || this._helpDescription;

  var splitFlags = this._helpFlags.split(/[ ,|]+/);

  if (splitFlags.length &gt; 1) this._helpShortFlag = splitFlags.shift();

  this._helpLongFlag = splitFlags.shift();

  return this;
};

/**
 * Output help information and exit.
 *
 * @param {Function} [cb]
 * @api public
 */

Command.prototype.help = function(cb) {
  this.outputHelp(cb);
  process.exit();
};

/**
 * Camel-case the given `flag`
 *
 * @param {String} flag
 * @return {String}
 * @api private
 */

function camelcase(flag) {
  return flag.split(&#039;-&#039;).reduce(function(str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Pad `str` to `width`.
 *
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(&#039; &#039;);
}

/**
 * Output help information if necessary
 *
 * @param {Command} command to output help for
 * @param {Array} array of options to search for -h or --help
 * @api private
 */

function outputHelpIfNecessary(cmd, options) {
  options = options || [];

  for (var i = 0; i &lt; options.length; i++) {
    if (options[i] === cmd._helpLongFlag || options[i] === cmd._helpShortFlag) {
      cmd.outputHelp();
      process.exit(0);
    }
  }
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Object} arg
 * @return {String}
 * @api private
 */

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? &#039;...&#039; : &#039;&#039;);

  return arg.required
    ? &#039;&lt;&#039; + nameOutput + &#039;&gt;&#039;
    : &#039;[&#039; + nameOutput + &#039;]&#039;;
}

// for versions before node v0.8 when there weren&#039;t `fs.existsSync`
function exists(file) {
  try {
    if (fs.statSync(file).isFile()) {
      return true;
    }
  } catch (e) {
    return false;
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) =&gt; {
    var result = arg;
    if (arg.indexOf(&#039;--inspect&#039;) === 0) {
      var debugOption;
      var debugHost = &#039;127.0.0.1&#039;;
      var debugPort = &#039;9229&#039;;
      var match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        // e.g. --inspect
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          // e.g. --inspect=1234
          debugPort = match[3];
        } else {
          // e.g. --inspect=localhost
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        // e.g. --inspect=localhost:1234
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }

      if (debugOption &amp;&amp; debugPort !== &#039;0&#039;) {
        result = `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
    }
    return result;
  });
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
