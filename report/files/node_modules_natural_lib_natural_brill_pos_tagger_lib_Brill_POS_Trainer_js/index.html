<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/natural/lib/natural/brill_pos_tagger/lib/Brill_POS_Trainer.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/natural/lib/natural/brill_pos_tagger/lib/Brill_POS_Trainer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">431</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">97.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
  Brill POS Trainer class
  Copyright (C) 2017 Hugo W.L. ter Doest

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

// Algorithm is based on:
// Exploring the Statistical Derivation of Transformational Rule Sequences
// for Part-of-Speech Tagging, Lance A. Ramshaw and Mitchell P. Marcus
// http://acl-arc.comp.nus.edu.sg/archives/acl-arc-090501d4/data/pdf/anthology-PDF/W/W94/W94-0111.pdf

&#039;use strict&#039;

const TransformationRule = require(&#039;./TransformationRule&#039;)
const RuleSet = require(&#039;./RuleSet&#039;)
const Sentence = require(&#039;./Sentence&#039;)

// Training continues as long as there are rules with a positive score
// that have not been selected before
const minScore = 0

// After training rules with a score below scoreThreshold are pruned
function BrillPOSTrainer (ruleScoreThreshold) {
  if (ruleScoreThreshold) {
    this.ruleScoreThreshold = ruleScoreThreshold
  } else {
    this.ruleScoreThreshold = 1
  }
}

// Return the highest scoring rule from the rule set
BrillPOSTrainer.prototype.selectHighRule = function () {
  let highestRule = null

  // Walk through the map and find the rule with highest score
  this.positiveRules.getRules().forEach(function (rule) {
    if (highestRule === null) {
      if (!rule.hasBeenSelectedAsHighRuleBefore) {
        highestRule = rule
      }
    } else {
      if ((rule.score() &gt; highestRule.score()) &amp;&amp;
        !rule.hasBeenSelectedAsHighRuleBefore) {
        highestRule = rule
      }
    }
  })

  if (highestRule !== null) {
    highestRule.hasBeenSelectedAsHighRuleBefore = true
  }
  // Return the rule with the highest score
  return highestRule
}

BrillPOSTrainer.prototype.mapRuleToSite = function (rule, i, j) {
  if (!this.mapRuleToSites[rule.key()]) {
    this.mapRuleToSites[rule.key()] = {}
  }
  if (!this.mapRuleToSites[rule.key()][i]) {
    this.mapRuleToSites[rule.key()][i] = {}
  }
  this.mapRuleToSites[rule.key()][i][j] = true
}

BrillPOSTrainer.prototype.mapSiteToRule = function (i, j, rule) {
  if (!this.mapSiteToRules[i]) {
    this.mapSiteToRules[i] = {}
  }
  if (!this.mapSiteToRules[i][j]) {
    this.mapSiteToRules[i][j] = {}
  }
  this.mapSiteToRules[i][j][rule.key()] = rule
}

BrillPOSTrainer.prototype.associateSiteWithRule = function (i, j, rule) {
  this.mapRuleToSite(rule, i, j)
  this.mapSiteToRule(i, j, rule)
}

BrillPOSTrainer.prototype.siteIsAssociatedWithRule = function (i, j, rule) {
  if (this.mapSiteToRules[i]) {
    if (this.mapSiteToRules[i][j]) {
      if (this.mapSiteToRules[i][j][rule.key()]) {
        return true
      }
    }
  }
  return false
}

// Returns an array of all sites associated with rule
BrillPOSTrainer.prototype.getSites = function (rule) {
  const that = this
  const result = []
  Object.keys(this.mapRuleToSites[rule.key()]).forEach(function (i) {
    Object.keys(that.mapRuleToSites[rule.key()][i]).forEach(function (j) {
      // Unary plus the convert hash keys i and j to integer
      result.push([+i, +j])
    })
  })
  // logger.debug(&quot;BrillPOSTrainer.prototype.getSites: sites &quot; + JSON.stringify(result));
  return (result)
}

// Returns an array of all rules associated with the site
BrillPOSTrainer.prototype.getRules = function (i, j) {
  let result = []
  const that = this

  if (this.mapSiteToRules[i]) {
    if (this.mapSiteToRules[i][j]) {
      result = Object.keys(this.mapSiteToRules[i][j]).map(function (key) {
        return that.mapSiteToRules[i][j][key]
      })
    }
  }
  return result
}

BrillPOSTrainer.prototype.disconnectSiteFromRule = function (i, j, rule) {
  // mapRuleToSites
  if (this.mapRuleToSites[rule.key()]) {
    if (this.mapRuleToSites[rule.key()][i]) {
      if (this.mapRuleToSites[rule.key()][i][j]) {
        delete this.mapRuleToSites[rule.key()][i][j]
      }
    }
  }

  // mapSiteToRules
  if (this.mapSiteToRules[i]) {
    if (this.mapSiteToRules[i][j]) {
      if (this.mapSiteToRules[i][j][rule.key()]) {
        delete this.mapSiteToRules[i][j][rule.key()]
      }
    }
  }
}

// Adjusts the score of the rule at position i, j of the corpus
BrillPOSTrainer.prototype.scoreRule = function (rule, i, j) {
  // logger.debug(&quot;BrillPOSTrainer.prototype.scoreRule: entry&quot;);
  const token = this.corpus.sentences[i].taggedWords[j]
  const rightTag = token.tag
  const oldTag = token.testTag
  const newTag = token.newTag
  if (rightTag !== oldTag) {
    // Old tag is wrong
    if (newTag === rightTag) {
      // New tag is right
      rule.positive++
      // If the score changes, it may be selected again as highest scoring rule
      rule.hasBeenSelectedAsHighRuleBefore = false
      // logger.debug(&quot;BrillPOSTrainer.prototype.scoreRule: positive: &quot; + rule.key() + &quot;\t score: &quot; + rule.positive);
    } else {
      // New tag is wrong as well --&gt; neutral
      rule.neutral++
      // logger.debug(&quot;BrillPOSTrainer.prototype.scoreRule: neutral: &quot; + rule.key() + &quot;\t score: &quot; + rule.neutral);
    }
  } else {
    // Old tag is right
    if (newTag === rightTag) {
      // New tag is right --&gt; neutral
      rule.neutral++
      // logger.debug(&quot;BrillPOSTrainer.prototype.scoreRule: neutral: &quot; + rule.key() + &quot;\t score: &quot; + rule.neutral);
    } else {
      // New tag is false
      rule.negative++
      // If the score changes, it may be selected again as highest scoring rule
      rule.hasBeenSelectedAsHighRuleBefore = false
      // logger.debug(&quot;BrillPOSTrainer.prototype.scoreRule: negative: &quot; + rule.key() + &quot;\t score: &quot; + rule.negative);
    }
  }
  // logger.debug(&quot;BrillPOSTrainer.prototype.scoreRule: exit&quot;);
}

// Generate positive rules for this given site using templates
BrillPOSTrainer.prototype.generatePositiveRules = function (i, j) {
  const sentence = this.corpus.sentences[i]
  const token = sentence.taggedWords[j]
  // A positive rule should trigger on the currently assigned testTag
  const oldTag = token.testTag
  // logger.debug(&quot;BrillPOSTrainer.prototype.generatePositiveRules: oldTag &quot; + oldTag);
  // It should assign the right tag as given by the corpus
  const newTag = token.tag
  // logger.debug(&quot;BrillPOSTrainer.prototype.generatePositiveRules: newTag &quot; + newTag);

  const newRules = new RuleSet()
  // Exit if testTag already is the right tag --&gt; will not result in positive rules
  if (oldTag === newTag) {
    return newRules
  }

  this.templates.forEach(function (template) {
    if (template.windowFitsSite(sentence, j)) {
      if (template.meta.nrParameters === 1) {
        template.meta.parameter1Values(sentence, j).forEach(function (value) {
          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value))
        })
      } else {
        if (template.meta.nrParameters === 2) {
          template.meta.parameter1Values(sentence, j).forEach(function (value1) {
            template.meta.parameter2Values(sentence, j).forEach(function (value2) {
              newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName, value1, value2))
            })
          })
        } else {
          // 0 paramaters
          newRules.addRule(new TransformationRule(oldTag, newTag, template.predicateName))
        }
      }
    }
  })
  return newRules
}

// Finds all rules that are applicable at some site
BrillPOSTrainer.prototype.scanForPositiveRules = function () {
  // logger.debug(&quot;BrillPOSTrainer.prototype.scanForPositiveRules: entry&quot;);
  const that = this
  this.corpus.sentences.forEach(function (sentence, i) {
    sentence.taggedWords.forEach(function (token, j) {
      // logger.debug(&quot;BrillPOSTrainer.prototype.scanForPositiveRules: sentence no &quot; + i);
      const newRules = that.generatePositiveRules(i, j)
      newRules.getRules().forEach(function (rule) {
        that.positiveRules.addRule(rule)
        // logger.debug(&quot;BrillPOSTrainer.prototype.scanForPositiveRules: nrRules &quot; + that.positiveRules.nrRules());
      })
    })
  })
  // logger.debug(&quot;BrillPOSTrainer.prototype.scanForPositiveRules: exit, number of rules: &quot; + this.positiveRules.nrRules());
}

// Find all sites where the rules can be applied, register these sites and
// update the scores
BrillPOSTrainer.prototype.scanForSites = function () {
  // logger.debug(&quot;BrillPOSTrainer.prototype.scanForSites: entry&quot;);
  const that = this

  // Scan the corpus
  this.corpus.sentences.forEach(function (sentence, i) {
    if (i % 100 === 0) {
      // logger.info(&quot;BrillPOSTrainer.prototype.scanForSites: sentence &quot; + i);
    }

    const taggedSentence = new Sentence()
    sentence.taggedWords.forEach(function (wordObject) {
      taggedSentence.addTaggedWord(wordObject.token, wordObject.testTag)
    })

    sentence.taggedWords.forEach(function (token, j) {
      that.positiveRules.getRules().forEach(function (rule) {
        if (rule.isApplicableAt(sentence, taggedSentence, j)) {
          that.associateSiteWithRule(i, j, rule)
          that.scoreRule(rule, i, j)
          // logger.debug(&quot;BrillPOSTrainer.prototype.scanForSites: (sentence, token, rule): (&quot; + i + &quot;, &quot; + j + &quot;, &quot; + rule.prettyPrint() + &quot;)&quot;);
        }
      })
    })
  })

  // logger.debug(&quot;BrillPOSTrainer.prototype.scanForSites: exit&quot;);
}

// Returns a list of sites that may have been touched by a changing tag
BrillPOSTrainer.prototype.neighbourhood = function (i, j) {
  const sentenceLength = this.corpus.sentences[i].length
  const list = []

  if (this.index &gt; 2) {
    list.push([i, j - 3])
  }
  if (this.index &gt; 1) {
    list.push([i, j - 2])
  }
  if (this.index &gt; 0) {
    list.push([i, j - 1])
  }
  if (this.index &lt; sentenceLength - 1) {
    list.push([i, j + 1])
  }
  if (this.index &lt; sentenceLength - 2) {
    list.push([i, j + 2])
  }
  if (this.index &gt; sentenceLength - 3) {
    list.push([i, j + 3])
  }
  return list
}

// corpus: an array of token arrays
// templates: an array of rule templates
// lexicon: lexicon that provides method tagWord(word)
BrillPOSTrainer.prototype.train = function (corpus, templates, lexicon) {
  this.corpus = corpus
  this.templates = templates
  this.positiveRules = new RuleSet()
  this.mapRuleToSites = {}
  this.mapSiteToRules = {}

  // logger.debug(&quot;BrillPOSTrainer.prototype.train: entry&quot;);
  this.corpus.tag(lexicon)
  this.scanForPositiveRules()
  // logger.info(&quot;BrillPOSTrainer.prototype.train: initial number of rules: &quot; + this.positiveRules.nrRules());
  this.scanForSites()

  let highRule = this.selectHighRule()
  let iterationNumber = 0
  const that = this
  while ((highRule !== null) &amp;&amp; (highRule.score() &gt; minScore)) {
    if ((iterationNumber % 5) === 0) {
      // logger.info(&quot;BrillPOSTrainer.prototype.train: training iteration: &quot; + iterationNumber);
    }
    // logger.debug(&quot;BrillPOSTrainer.prototype.train: highRule selected: &quot; + highRule.key());
    // logger.debug(&quot;BrillPOSTrainer.prototype.train: number of rules: &quot; + this.positiveRules.nrRules());
    // logger.debug(&quot;BrillPOSTrainer.prototype.train: score of highRule: &quot; + highRule.score());

    // Apply the high rule to each change site on its site list
    this.getSites(highRule).forEach(function (site) {
      // logger.debug(&quot;BrillPOSTrainer.prototype.train: apply highRule to: &quot; + site);
      // logger.debug(&quot;BrillPOSTrainer.prototype.train: sentence length: &quot; + that.corpus.sentences[site[0]].length);
      highRule.applyAt(that.corpus.sentences[site[0]], site[1])
    })

    const unseenRules = new RuleSet()
    this.getSites(highRule).forEach(function (site) {
      that.neighbourhood(site[0], site[1]).forEach(function (testSite) {
        // Generate positive rules for testSite
        const newRules = that.generatePositiveRules(testSite[0], testSite[1])

        // Disconnect test site from its rules
        // because highrule has been applied
        that.getRules(testSite[0], testSite[1]).forEach(function (rule) {
          if (!newRules.hasRule(rule)) {
            that.disconnectSiteFromRule(testSite[0], testSite[1], rule)
          }
        })

        // Connect new rules not already connected to the test site
        newRules.getRules().forEach(function (rule) {
          if (!that.siteIsAssociatedWithRule(testSite[0].testSite[1], rule)) {
            if (that.positiveRules.hasRule(rule)) {
              that.associateSiteWithRule(testSite[0], testSite[1], rule)
            } else {
              unseenRules.addRule(rule)
            }
          }
        })

        // Process unseen rules
        if (unseenRules.nrRules() &gt; 0) {
          unseenRules.getRules().forEach(function (rule) {
            that.positiveRules.addRule(rule)
          })
          that.corpus.sentences.forEach(function (sentence, i) {
            const taggedSentence = sentence.map(function (token) {
              return [token.token, token.testTag]
            })
            sentence.forEach(function (token, j) {
              unseenRules.getRules().forEach(function (rule) {
                if (rule.isApplicableAt(sentence, taggedSentence, j)) {
                  that.associateSiteWithRule(i, j, rule)
                  that.scoreRule(rule, i, j)
                }
              })
            })
          })
        }
      })
    })

    // Select next highest scoring rule
    highRule = this.selectHighRule()
    iterationNumber++
  }
  // logger.info(&quot;BrillPOSTrainer.prototype.train: number of iterations: &quot; + iterationNumber);
  // logger.info(&quot;BrillPOSTrainer.prototype.train: number of rules: &quot; + this.positiveRules.nrRules());

  // Remove rules having a non-positive score
  this.positiveRules.getRules().forEach(function (rule) {
    if (rule.score() &lt; that.ruleScoreThreshold) {
      that.positiveRules.removeRule(rule)
    }
  })

  // logger.info(&quot;BrillPOSTrainer.prototype.train: number of rules after pruning: &quot; + this.positiveRules.nrRules());
  // logger.debug(&quot;BrillPOSTrainer.prototype.train: exit&quot;);
  return this.positiveRules
}

BrillPOSTrainer.prototype.printRulesWithScores = function () {
  let result = &#039;&#039;

  function compareRules (a, b) {
    if (a.score() &gt; b.score()) {
      return -1
    } else {
      if (a.score() &lt; b.score()) {
        return 1
      } else {
        return 0
      }
    }
  }

  const rules = this.positiveRules.getRules()
  const sortedRules = rules.sort(compareRules)

  sortedRules.forEach(function (rule) {
    // if (rule.score() &gt; 0) {
    result += rule.score() + &#039;\t&#039; + rule.positive + &#039;\t&#039; + rule.negative + &#039;\t&#039; + rule.neutral + &#039;\t&#039; + rule.prettyPrint() + &#039;\n&#039;
    // }
  })
  return result
}

module.exports = BrillPOSTrainer
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
