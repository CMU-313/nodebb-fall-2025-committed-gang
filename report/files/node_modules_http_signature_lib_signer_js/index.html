<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/http-signature/lib/signer.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/http-signature/lib/signer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">402</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">59.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require(&#039;assert-plus&#039;);
var crypto = require(&#039;crypto&#039;);
var http = require(&#039;http&#039;);
var util = require(&#039;util&#039;);
var sshpk = require(&#039;sshpk&#039;);
var jsprim = require(&#039;jsprim&#039;);
var utils = require(&#039;./utils&#039;);

var sprintf = require(&#039;util&#039;).format;

var HASH_ALGOS = utils.HASH_ALGOS;
var PK_ALGOS = utils.PK_ALGOS;
var InvalidAlgorithmError = utils.InvalidAlgorithmError;
var HttpSignatureError = utils.HttpSignatureError;
var validateAlgorithm = utils.validateAlgorithm;

///--- Globals

var AUTHZ_FMT =
  &#039;Signature keyId=&quot;%s&quot;,algorithm=&quot;%s&quot;,headers=&quot;%s&quot;,signature=&quot;%s&quot;&#039;;

///--- Specific Errors

function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);

function StrictParsingError(message) {
  HttpSignatureError.call(this, message, StrictParsingError);
}
util.inherits(StrictParsingError, HttpSignatureError);

/* See createSigner() */
function RequestSigner(options) {
  assert.object(options, &#039;options&#039;);

  var alg = [];
  if (options.algorithm !== undefined) {
    assert.string(options.algorithm, &#039;options.algorithm&#039;);
    alg = validateAlgorithm(options.algorithm);
  }
  this.rs_alg = alg;

  /*
   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones
   * with an rs_signer.
   *
   * rs_signFunc-based RequestSigners have to build up their entire signing
   * string within the rs_lines array and give it to rs_signFunc as a single
   * concat&#039;d blob. rs_signer-based RequestSigners can add a line at a time to
   * their signing state by using rs_signer.update(), thus only needing to
   * buffer the hash function state and one line at a time.
   */
  if (options.sign !== undefined) {
    assert.func(options.sign, &#039;options.sign&#039;);
    this.rs_signFunc = options.sign;

  } else if (alg[0] === &#039;hmac&#039; &amp;&amp; options.key !== undefined) {
    assert.string(options.keyId, &#039;options.keyId&#039;);
    this.rs_keyId = options.keyId;

    if (typeof (options.key) !== &#039;string&#039; &amp;&amp; !Buffer.isBuffer(options.key))
      throw (new TypeError(&#039;options.key for HMAC must be a string or Buffer&#039;));

    /*
     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their
     * data in chunks rather than requiring it all to be given in one go
     * at the end, so they are more similar to signers than signFuncs.
     */
    this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
    this.rs_signer.sign = function () {
      var digest = this.digest(&#039;base64&#039;);
      return ({
        hashAlgorithm: alg[1],
        toString: function () { return (digest); }
      });
    };

  } else if (options.key !== undefined) {
    var key = options.key;
    if (typeof (key) === &#039;string&#039; || Buffer.isBuffer(key))
      key = sshpk.parsePrivateKey(key);

    assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
      &#039;options.key must be a sshpk.PrivateKey&#039;);
    this.rs_key = key;

    assert.string(options.keyId, &#039;options.keyId&#039;);
    this.rs_keyId = options.keyId;

    if (!PK_ALGOS[key.type]) {
      throw (new InvalidAlgorithmError(key.type.toUpperCase() + &#039; type &#039; +
        &#039;keys are not supported&#039;));
    }

    if (alg[0] !== undefined &amp;&amp; key.type !== alg[0]) {
      throw (new InvalidAlgorithmError(&#039;options.key must be a &#039; +
        alg[0].toUpperCase() + &#039; key, was given a &#039; +
        key.type.toUpperCase() + &#039; key instead&#039;));
    }

    this.rs_signer = key.createSign(alg[1]);

  } else {
    throw (new TypeError(&#039;options.sign (func) or options.key is required&#039;));
  }

  this.rs_headers = [];
  this.rs_lines = [];
}

/**
 * Adds a header to be signed, with its value, into this signer.
 *
 * @param {String} header
 * @param {String} value
 * @return {String} value written
 */
RequestSigner.prototype.writeHeader = function (header, value) {
  assert.string(header, &#039;header&#039;);
  header = header.toLowerCase();
  assert.string(value, &#039;value&#039;);

  this.rs_headers.push(header);

  if (this.rs_signFunc) {
    this.rs_lines.push(header + &#039;: &#039; + value);

  } else {
    var line = header + &#039;: &#039; + value;
    if (this.rs_headers.length &gt; 0)
      line = &#039;\n&#039; + line;
    this.rs_signer.update(line);
  }

  return (value);
};

/**
 * Adds a default Date header, returning its value.
 *
 * @return {String}
 */
RequestSigner.prototype.writeDateHeader = function () {
  return (this.writeHeader(&#039;date&#039;, jsprim.rfc1123(new Date())));
};

/**
 * Adds the request target line to be signed.
 *
 * @param {String} method, HTTP method (e.g. &#039;get&#039;, &#039;post&#039;, &#039;put&#039;)
 * @param {String} path
 */
RequestSigner.prototype.writeTarget = function (method, path) {
  assert.string(method, &#039;method&#039;);
  assert.string(path, &#039;path&#039;);
  method = method.toLowerCase();
  this.writeHeader(&#039;(request-target)&#039;, method + &#039; &#039; + path);
};

/**
 * Calculate the value for the Authorization header on this request
 * asynchronously.
 *
 * @param {Func} callback (err, authz)
 */
RequestSigner.prototype.sign = function (cb) {
  assert.func(cb, &#039;callback&#039;);

  if (this.rs_headers.length &lt; 1)
    throw (new Error(&#039;At least one header must be signed&#039;));

  var alg, authz;
  if (this.rs_signFunc) {
    var data = this.rs_lines.join(&#039;\n&#039;);
    var self = this;
    this.rs_signFunc(data, function (err, sig) {
      if (err) {
        cb(err);
        return;
      }
      try {
        assert.object(sig, &#039;signature&#039;);
        assert.string(sig.keyId, &#039;signature.keyId&#039;);
        assert.string(sig.algorithm, &#039;signature.algorithm&#039;);
        assert.string(sig.signature, &#039;signature.signature&#039;);
        alg = validateAlgorithm(sig.algorithm);

        authz = sprintf(AUTHZ_FMT,
          sig.keyId,
          sig.algorithm,
          self.rs_headers.join(&#039; &#039;),
          sig.signature);
      } catch (e) {
        cb(e);
        return;
      }
      cb(null, authz);
    });

  } else {
    try {
      var sigObj = this.rs_signer.sign();
    } catch (e) {
      cb(e);
      return;
    }
    alg = (this.rs_alg[0] || this.rs_key.type) + &#039;-&#039; + sigObj.hashAlgorithm;
    var signature = sigObj.toString();
    authz = sprintf(AUTHZ_FMT,
      this.rs_keyId,
      alg,
      this.rs_headers.join(&#039; &#039;),
      signature);
    cb(null, authz);
  }
};

///--- Exported API

module.exports = {
  /**
   * Identifies whether a given object is a request signer or not.
   *
   * @param {Object} object, the object to identify
   * @returns {Boolean}
   */
  isSigner: function (obj) {
    if (typeof (obj) === &#039;object&#039; &amp;&amp; obj instanceof RequestSigner)
      return (true);
    return (false);
  },

  /**
   * Creates a request signer, used to asynchronously build a signature
   * for a request (does not have to be an http.ClientRequest).
   *
   * @param {Object} options, either:
   *                   - {String} keyId
   *                   - {String|Buffer} key
   *                   - {String} algorithm (optional, required for HMAC)
   *                 or:
   *                   - {Func} sign (data, cb)
   * @return {RequestSigner}
   */
  createSigner: function createSigner(options) {
    return (new RequestSigner(options));
  },

  /**
   * Adds an &#039;Authorization&#039; header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it&#039;s not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn&#039;t need to check the return type; it&#039;s just there if you want
   * to be pedantic.
   *
   * The optional flag indicates whether parsing should use strict enforcement
   * of the version draft-cavage-http-signatures-04 of the spec or beyond.
   * The default is to be loose and support
   * older versions for compatibility.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to [&#039;date&#039;].
   *                   - {String} algorithm optional (unless key is HMAC);
   *                              default is the same as the sshpk default
   *                              signing algorithm for the type of key given
   *                   - {String} httpVersion optional; defaults to &#039;1.1&#039;.
   *                   - {Boolean} strict optional; defaults to &#039;false&#039;.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
   *                                 the given key.
   * @throws {sshpk.KeyParseError} if key was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert.object(request, &#039;request&#039;);
    assert.object(options, &#039;options&#039;);
    assert.optionalString(options.algorithm, &#039;options.algorithm&#039;);
    assert.string(options.keyId, &#039;options.keyId&#039;);
    assert.optionalArrayOfString(options.headers, &#039;options.headers&#039;);
    assert.optionalString(options.httpVersion, &#039;options.httpVersion&#039;);

    if (!request.getHeader(&#039;Date&#039;))
      request.setHeader(&#039;Date&#039;, jsprim.rfc1123(new Date()));
    if (!options.headers)
      options.headers = [&#039;date&#039;];
    if (!options.httpVersion)
      options.httpVersion = &#039;1.1&#039;;

    var alg = [];
    if (options.algorithm) {
      options.algorithm = options.algorithm.toLowerCase();
      alg = validateAlgorithm(options.algorithm);
    }

    var i;
    var stringToSign = &#039;&#039;;
    for (i = 0; i &lt; options.headers.length; i++) {
      if (typeof (options.headers[i]) !== &#039;string&#039;)
        throw new TypeError(&#039;options.headers must be an array of Strings&#039;);

      var h = options.headers[i].toLowerCase();

      if (h === &#039;request-line&#039;) {
        if (!options.strict) {
          /**
           * We allow headers from the older spec drafts if strict parsing isn&#039;t
           * specified in options.
           */
          stringToSign +=
            request.method + &#039; &#039; + request.path + &#039; HTTP/&#039; +
            options.httpVersion;
        } else {
          /* Strict parsing doesn&#039;t allow older draft headers. */
          throw (new StrictParsingError(&#039;request-line is not a valid header &#039; +
            &#039;with strict parsing enabled.&#039;));
        }
      } else if (h === &#039;(request-target)&#039;) {
        stringToSign +=
          &#039;(request-target): &#039; + request.method.toLowerCase() + &#039; &#039; +
          request.path;
      } else {
        var value = request.getHeader(h);
        if (value === undefined || value === &#039;&#039;) {
          throw new MissingHeaderError(h + &#039; was not in the request&#039;);
        }
        stringToSign += h + &#039;: &#039; + value;
      }

      if ((i + 1) &lt; options.headers.length)
        stringToSign += &#039;\n&#039;;
    }

    /* This is just for unit tests. */
    if (request.hasOwnProperty(&#039;_stringToSign&#039;)) {
      request._stringToSign = stringToSign;
    }

    var signature;
    if (alg[0] === &#039;hmac&#039;) {
      if (typeof (options.key) !== &#039;string&#039; &amp;&amp; !Buffer.isBuffer(options.key))
        throw (new TypeError(&#039;options.key must be a string or Buffer&#039;));

      var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest(&#039;base64&#039;);

    } else {
      var key = options.key;
      if (typeof (key) === &#039;string&#039; || Buffer.isBuffer(key))
        key = sshpk.parsePrivateKey(options.key);

      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
        &#039;options.key must be a sshpk.PrivateKey&#039;);

      if (!PK_ALGOS[key.type]) {
        throw (new InvalidAlgorithmError(key.type.toUpperCase() + &#039; type &#039; +
          &#039;keys are not supported&#039;));
      }

      if (alg[0] !== undefined &amp;&amp; key.type !== alg[0]) {
        throw (new InvalidAlgorithmError(&#039;options.key must be a &#039; +
          alg[0].toUpperCase() + &#039; key, was given a &#039; +
          key.type.toUpperCase() + &#039; key instead&#039;));
      }

      var signer = key.createSign(alg[1]);
      signer.update(stringToSign);
      var sigObj = signer.sign();
      if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
        throw (new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() +
          &#039; is not a supported hash algorithm&#039;));
      }
      options.algorithm = key.type + &#039;-&#039; + sigObj.hashAlgorithm;
      signature = sigObj.toString();
      assert.notStrictEqual(signature, &#039;&#039;, &#039;empty signature produced&#039;);
    }

    var authzHeaderName = options.authorizationHeaderName || &#039;Authorization&#039;;

    request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(&#039; &#039;),
                                               signature));

    return true;
  }

};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
