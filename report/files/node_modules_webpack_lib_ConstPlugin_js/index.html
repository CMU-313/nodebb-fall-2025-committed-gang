<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/ConstPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/ConstPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">540</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC,
	JAVASCRIPT_MODULE_TYPE_ESM
} = require(&quot;./ModuleTypeConstants&quot;);
const CachedConstDependency = require(&quot;./dependencies/CachedConstDependency&quot;);
const ConstDependency = require(&quot;./dependencies/ConstDependency&quot;);
const { evaluateToString } = require(&quot;./javascript/JavascriptParserHelpers&quot;);
const { parseResource } = require(&quot;./util/identifier&quot;);

/** @typedef {import(&quot;estree&quot;).AssignmentProperty} AssignmentProperty */
/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;estree&quot;).Identifier} Identifier */
/** @typedef {import(&quot;estree&quot;).Pattern} Pattern */
/** @typedef {import(&quot;estree&quot;).SourceLocation} SourceLocation */
/** @typedef {import(&quot;estree&quot;).Statement} Statement */
/** @typedef {import(&quot;estree&quot;).Super} Super */
/** @typedef {import(&quot;estree&quot;).VariableDeclaration} VariableDeclaration */
/** @typedef {import(&quot;./Compiler&quot;)} Compiler */
/** @typedef {import(&quot;./javascript/BasicEvaluatedExpression&quot;)} BasicEvaluatedExpression */
/** @typedef {import(&quot;./javascript/JavascriptParser&quot;)} JavascriptParser */
/** @typedef {import(&quot;./javascript/JavascriptParser&quot;).Range} Range */

/**
 * @param {Set&lt;string&gt;} declarations set of declarations
 * @param {Identifier | Pattern} pattern pattern to collect declarations from
 */
const collectDeclaration = (declarations, pattern) =&gt; {
	const stack = [pattern];
	while (stack.length &gt; 0) {
		const node = /** @type {Pattern} */ (stack.pop());
		switch (node.type) {
			case &quot;Identifier&quot;:
				declarations.add(node.name);
				break;
			case &quot;ArrayPattern&quot;:
				for (const element of node.elements) {
					if (element) {
						stack.push(element);
					}
				}
				break;
			case &quot;AssignmentPattern&quot;:
				stack.push(node.left);
				break;
			case &quot;ObjectPattern&quot;:
				for (const property of node.properties) {
					stack.push(/** @type {AssignmentProperty} */ (property).value);
				}
				break;
			case &quot;RestElement&quot;:
				stack.push(node.argument);
				break;
		}
	}
};

/**
 * @param {Statement} branch branch to get hoisted declarations from
 * @param {boolean} includeFunctionDeclarations whether to include function declarations
 * @returns {Array&lt;string&gt;} hoisted declarations
 */
const getHoistedDeclarations = (branch, includeFunctionDeclarations) =&gt; {
	const declarations = new Set();
	/** @type {Array&lt;Statement | null | undefined&gt;} */
	const stack = [branch];
	while (stack.length &gt; 0) {
		const node = stack.pop();
		// Some node could be `null` or `undefined`.
		if (!node) continue;
		switch (node.type) {
			// Walk through control statements to look for hoisted declarations.
			// Some branches are skipped since they do not allow declarations.
			case &quot;BlockStatement&quot;:
				for (const stmt of node.body) {
					stack.push(stmt);
				}
				break;
			case &quot;IfStatement&quot;:
				stack.push(node.consequent);
				stack.push(node.alternate);
				break;
			case &quot;ForStatement&quot;:
				stack.push(/** @type {VariableDeclaration} */ (node.init));
				stack.push(node.body);
				break;
			case &quot;ForInStatement&quot;:
			case &quot;ForOfStatement&quot;:
				stack.push(/** @type {VariableDeclaration} */ (node.left));
				stack.push(node.body);
				break;
			case &quot;DoWhileStatement&quot;:
			case &quot;WhileStatement&quot;:
			case &quot;LabeledStatement&quot;:
				stack.push(node.body);
				break;
			case &quot;SwitchStatement&quot;:
				for (const cs of node.cases) {
					for (const consequent of cs.consequent) {
						stack.push(consequent);
					}
				}
				break;
			case &quot;TryStatement&quot;:
				stack.push(node.block);
				if (node.handler) {
					stack.push(node.handler.body);
				}
				stack.push(node.finalizer);
				break;
			case &quot;FunctionDeclaration&quot;:
				if (includeFunctionDeclarations) {
					collectDeclaration(declarations, /** @type {Identifier} */ (node.id));
				}
				break;
			case &quot;VariableDeclaration&quot;:
				if (node.kind === &quot;var&quot;) {
					for (const decl of node.declarations) {
						collectDeclaration(declarations, decl.id);
					}
				}
				break;
		}
	}
	return Array.from(declarations);
};

const PLUGIN_NAME = &quot;ConstPlugin&quot;;

class ConstPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cachedParseResource = parseResource.bindCache(compiler.root);
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory }) =&gt; {
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				compilation.dependencyTemplates.set(
					CachedConstDependency,
					new CachedConstDependency.Template()
				);

				/**
				 * @param {JavascriptParser} parser the parser
				 */
				const handler = parser =&gt; {
					parser.hooks.terminate.tap(PLUGIN_NAME, statement =&gt; true);
					parser.hooks.statementIf.tap(PLUGIN_NAME, statement =&gt; {
						if (parser.scope.isAsmJs) return;
						const param = parser.evaluateExpression(statement.test);
						const bool = param.asBool();
						if (typeof bool === &quot;boolean&quot;) {
							if (!param.couldHaveSideEffects()) {
								const dep = new ConstDependency(
									`${bool}`,
									/** @type {Range} */ (param.range)
								);
								dep.loc = /** @type {SourceLocation} */ (statement.loc);
								parser.state.module.addPresentationalDependency(dep);
							} else {
								parser.walkExpression(statement.test);
							}
							const branchToRemove = bool
								? statement.alternate
								: statement.consequent;
							if (branchToRemove) {
								// Before removing the dead branch, the hoisted declarations
								// must be collected.
								//
								// Given the following code:
								//
								//     if (true) f() else g()
								//     if (false) {
								//       function f() {}
								//       const g = function g() {}
								//       if (someTest) {
								//         let a = 1
								//         var x, {y, z} = obj
								//       }
								//     } else {
								//       …
								//     }
								//
								// the generated code is:
								//
								//     if (true) f() else {}
								//     if (false) {
								//       var f, x, y, z;   (in loose mode)
								//       var x, y, z;      (in strict mode)
								//     } else {
								//       …
								//     }
								//
								// NOTE: When code runs in strict mode, `var` declarations
								// are hoisted but `function` declarations don&#039;t.
								//
								const declarations = parser.scope.isStrict
									? getHoistedDeclarations(branchToRemove, false)
									: getHoistedDeclarations(branchToRemove, true);
								const replacement =
									declarations.length &gt; 0
										? `{ var ${declarations.join(&quot;, &quot;)}; }`
										: &quot;{}&quot;;
								const dep = new ConstDependency(
									replacement,
									/** @type {Range} */ (branchToRemove.range)
								);
								dep.loc = /** @type {SourceLocation} */ (branchToRemove.loc);
								parser.state.module.addPresentationalDependency(dep);
							}
							return bool;
						}
					});
					parser.hooks.expressionConditionalOperator.tap(
						PLUGIN_NAME,
						expression =&gt; {
							if (parser.scope.isAsmJs) return;
							const param = parser.evaluateExpression(expression.test);
							const bool = param.asBool();
							if (typeof bool === &quot;boolean&quot;) {
								if (!param.couldHaveSideEffects()) {
									const dep = new ConstDependency(
										` ${bool}`,
										/** @type {Range} */ (param.range)
									);
									dep.loc = /** @type {SourceLocation} */ (expression.loc);
									parser.state.module.addPresentationalDependency(dep);
								} else {
									parser.walkExpression(expression.test);
								}
								// Expressions do not hoist.
								// It is safe to remove the dead branch.
								//
								// Given the following code:
								//
								//   false ? someExpression() : otherExpression();
								//
								// the generated code is:
								//
								//   false ? 0 : otherExpression();
								//
								const branchToRemove = bool
									? expression.alternate
									: expression.consequent;
								const dep = new ConstDependency(
									&quot;0&quot;,
									/** @type {Range} */ (branchToRemove.range)
								);
								dep.loc = /** @type {SourceLocation} */ (branchToRemove.loc);
								parser.state.module.addPresentationalDependency(dep);
								return bool;
							}
						}
					);
					parser.hooks.expressionLogicalOperator.tap(
						PLUGIN_NAME,
						expression =&gt; {
							if (parser.scope.isAsmJs) return;
							if (
								expression.operator === &quot;&amp;&amp;&quot; ||
								expression.operator === &quot;||&quot;
							) {
								const param = parser.evaluateExpression(expression.left);
								const bool = param.asBool();
								if (typeof bool === &quot;boolean&quot;) {
									// Expressions do not hoist.
									// It is safe to remove the dead branch.
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() &amp;&amp; someExpression();
									//
									// the generated code is:
									//
									//   falsyExpression() &amp;&amp; false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() &amp;&amp; someExpression();
									//
									// the generated code is:
									//
									//   true &amp;&amp; someExpression();
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   truthyExpression() || false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   false &amp;&amp; someExpression();
									//
									const keepRight =
										(expression.operator === &quot;&amp;&amp;&quot; &amp;&amp; bool) ||
										(expression.operator === &quot;||&quot; &amp;&amp; !bool);

									if (
										!param.couldHaveSideEffects() &amp;&amp;
										(param.isBoolean() || keepRight)
									) {
										// for case like
										//
										//   return&#039;development&#039;===process.env.NODE_ENV&amp;&amp;&#039;foo&#039;
										//
										// we need a space before the bool to prevent result like
										//
										//   returnfalse&amp;&amp;&#039;foo&#039;
										//
										const dep = new ConstDependency(
											` ${bool}`,
											/** @type {Range} */ (param.range)
										);
										dep.loc = /** @type {SourceLocation} */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
									} else {
										parser.walkExpression(expression.left);
									}
									if (!keepRight) {
										const dep = new ConstDependency(
											&quot;0&quot;,
											/** @type {Range} */ (expression.right.range)
										);
										dep.loc = /** @type {SourceLocation} */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
									}
									return keepRight;
								}
							} else if (expression.operator === &quot;??&quot;) {
								const param = parser.evaluateExpression(expression.left);
								const keepRight = param.asNullish();
								if (typeof keepRight === &quot;boolean&quot;) {
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   nonNullish ?? someExpression();
									//
									// the generated code is:
									//
									//   nonNullish ?? 0;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   nullish ?? someExpression();
									//
									// the generated code is:
									//
									//   null ?? someExpression();
									//
									if (!param.couldHaveSideEffects() &amp;&amp; keepRight) {
										// cspell:word returnnull
										// for case like
										//
										//   return(&#039;development&#039;===process.env.NODE_ENV&amp;&amp;null)??&#039;foo&#039;
										//
										// we need a space before the bool to prevent result like
										//
										//   returnnull??&#039;foo&#039;
										//
										const dep = new ConstDependency(
											&quot; null&quot;,
											/** @type {Range} */ (param.range)
										);
										dep.loc = /** @type {SourceLocation} */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
									} else {
										const dep = new ConstDependency(
											&quot;0&quot;,
											/** @type {Range} */ (expression.right.range)
										);
										dep.loc = /** @type {SourceLocation} */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
										parser.walkExpression(expression.left);
									}

									return keepRight;
								}
							}
						}
					);
					parser.hooks.optionalChaining.tap(PLUGIN_NAME, expr =&gt; {
						/** @type {Expression[]} */
						const optionalExpressionsStack = [];
						/** @type {Expression | Super} */
						let next = expr.expression;

						while (
							next.type === &quot;MemberExpression&quot; ||
							next.type === &quot;CallExpression&quot;
						) {
							if (next.type === &quot;MemberExpression&quot;) {
								if (next.optional) {
									// SuperNode can not be optional
									optionalExpressionsStack.push(
										/** @type {Expression} */ (next.object)
									);
								}
								next = next.object;
							} else {
								if (next.optional) {
									// SuperNode can not be optional
									optionalExpressionsStack.push(
										/** @type {Expression} */ (next.callee)
									);
								}
								next = next.callee;
							}
						}

						while (optionalExpressionsStack.length) {
							const expression = optionalExpressionsStack.pop();
							const evaluated = parser.evaluateExpression(
								/** @type {Expression} */ (expression)
							);

							if (evaluated.asNullish()) {
								// ------------------------------------------
								//
								// Given the following code:
								//
								//   nullishMemberChain?.a.b();
								//
								// the generated code is:
								//
								//   undefined;
								//
								// ------------------------------------------
								//
								const dep = new ConstDependency(
									&quot; undefined&quot;,
									/** @type {Range} */ (expr.range)
								);
								dep.loc = /** @type {SourceLocation} */ (expr.loc);
								parser.state.module.addPresentationalDependency(dep);
								return true;
							}
						}
					});
					parser.hooks.evaluateIdentifier
						.for(&quot;__resourceQuery&quot;)
						.tap(PLUGIN_NAME, expr =&gt; {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							return evaluateToString(
								cachedParseResource(parser.state.module.resource).query
							)(expr);
						});
					parser.hooks.expression
						.for(&quot;__resourceQuery&quot;)
						.tap(PLUGIN_NAME, expr =&gt; {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							const dep = new CachedConstDependency(
								JSON.stringify(
									cachedParseResource(parser.state.module.resource).query
								),
								/** @type {Range} */ (expr.range),
								&quot;__resourceQuery&quot;
							);
							dep.loc = /** @type {SourceLocation} */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						});

					parser.hooks.evaluateIdentifier
						.for(&quot;__resourceFragment&quot;)
						.tap(PLUGIN_NAME, expr =&gt; {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							return evaluateToString(
								cachedParseResource(parser.state.module.resource).fragment
							)(expr);
						});
					parser.hooks.expression
						.for(&quot;__resourceFragment&quot;)
						.tap(PLUGIN_NAME, expr =&gt; {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							const dep = new CachedConstDependency(
								JSON.stringify(
									cachedParseResource(parser.state.module.resource).fragment
								),
								/** @type {Range} */ (expr.range),
								&quot;__resourceFragment&quot;
							);
							dep.loc = /** @type {SourceLocation} */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						});
				};

				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, handler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)
					.tap(PLUGIN_NAME, handler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_ESM)
					.tap(PLUGIN_NAME, handler);
			}
		);
	}
}

module.exports = ConstPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
