<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/optionator/lib/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/optionator/lib/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">49.24</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">466</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">101.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by LiveScript 1.6.0
(function(){
  var VERSION, ref$, id, map, compact, any, groupBy, partition, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, naturalJoin, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  VERSION = &#039;0.9.4&#039;;
  ref$ = require(&#039;prelude-ls&#039;), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;
  deepIs = require(&#039;deep-is&#039;);
  ref$ = require(&#039;./util&#039;), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;
  ref$ = require(&#039;./help&#039;), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
  ref$ = require(&#039;type-check&#039;), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;
  parseLevn = require(&#039;levn&#039;).parsedTypeParse;
  camelizeKeys = function(obj){
    var key, value, resultObj$ = {};
    for (key in obj) {
      value = obj[key];
      resultObj$[camelize(key)] = value;
    }
    return resultObj$;
  };
  parseString = function(string){
    var assignOpt, regex, replaceRegex, result;
    assignOpt = &#039;--?[a-zA-Z][-a-z-A-Z0-9]*=&#039;;
    regex = RegExp(&#039;(?:&#039; + assignOpt + &#039;)?(?:\&#039;(?:\\\\\&#039;|[^\&#039;])+\&#039;|&quot;(?:\\\\&quot;|[^&quot;])+&quot;)|[^\&#039;&quot;\\s]+&#039;, &#039;g&#039;);
    replaceRegex = RegExp(&#039;^(&#039; + assignOpt + &#039;)?[\&#039;&quot;]([\\s\\S]*)[\&#039;&quot;]$&#039;);
    result = map(function(it){
      return it.replace(replaceRegex, &#039;$1$2&#039;);
    }, string.match(regex) || []);
    return result;
  };
  main = function(libOptions){
    var opts, defaults, required, traverse, getOption, parse;
    opts = {};
    defaults = {};
    required = [];
    if (toString$.call(libOptions.stdout).slice(8, -1) === &#039;Undefined&#039;) {
      libOptions.stdout = process.stdout;
    }
    libOptions.positionalAnywhere == null &amp;&amp; (libOptions.positionalAnywhere = true);
    libOptions.typeAliases == null &amp;&amp; (libOptions.typeAliases = {});
    libOptions.defaults == null &amp;&amp; (libOptions.defaults = {});
    if (libOptions.concatRepeatedArrays != null) {
      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;
    }
    if (libOptions.mergeRepeatedObjects != null) {
      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;
    }
    traverse = function(options){
      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;
      if (toString$.call(options).slice(8, -1) !== &#039;Array&#039;) {
        throw new Error(&#039;No options defined.&#039;);
      }
      for (i$ = 0, len$ = options.length; i$ &lt; len$; ++i$) {
        option = options[i$];
        if (option.heading == null) {
          name = option.option;
          if (opts[name] != null) {
            throw new Error(&quot;Option &#039;&quot; + name + &quot;&#039; already defined.&quot;);
          }
          for (k in ref$ = libOptions.defaults) {
            v = ref$[k];
            option[k] == null &amp;&amp; (option[k] = v);
          }
          if (option.type === &#039;Boolean&#039;) {
            option.boolean == null &amp;&amp; (option.boolean = true);
          }
          if (option.parsedType == null) {
            if (!option.type) {
              throw new Error(&quot;No type defined for option &#039;&quot; + name + &quot;&#039;.&quot;);
            }
            try {
              type = (that = libOptions.typeAliases[option.type]) != null
                ? that
                : option.type;
              option.parsedType = parseType(type);
            } catch (e$) {
              e = e$;
              throw new Error(&quot;Option &#039;&quot; + name + &quot;&#039;: Error parsing type &#039;&quot; + option.type + &quot;&#039;: &quot; + e.message);
            }
          }
          if (option[&#039;default&#039;]) {
            try {
              defaults[name] = parseLevn(option.parsedType, option[&#039;default&#039;]);
            } catch (e$) {
              e = e$;
              throw new Error(&quot;Option &#039;&quot; + name + &quot;&#039;: Error parsing default value &#039;&quot; + option[&#039;default&#039;] + &quot;&#039; for type &#039;&quot; + option.type + &quot;&#039;: &quot; + e.message);
            }
          }
          if (option[&#039;enum&#039;] &amp;&amp; !option.parsedPossiblities) {
            parsedPossibilities = [];
            parsedType = option.parsedType;
            for (j$ = 0, len1$ = (ref$ = option[&#039;enum&#039;]).length; j$ &lt; len1$; ++j$) {
              possibility = ref$[j$];
              try {
                parsedPossibilities.push(parseLevn(parsedType, possibility));
              } catch (e$) {
                e = e$;
                throw new Error(&quot;Option &#039;&quot; + name + &quot;&#039;: Error parsing enum value &#039;&quot; + possibility + &quot;&#039; for type &#039;&quot; + option.type + &quot;&#039;: &quot; + e.message);
              }
            }
            option.parsedPossibilities = parsedPossibilities;
          }
          if (that = option.dependsOn) {
            if (that.length) {
              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);
              dependsType = rawDependsType.toLowerCase();
              if (dependsOpts.length) {
                if (dependsType === &#039;and&#039; || dependsType === &#039;or&#039;) {
                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));
                } else {
                  throw new Error(&quot;Option &#039;&quot; + name + &quot;&#039;: If you have more than one dependency, you must specify either &#039;and&#039; or &#039;or&#039;&quot;);
                }
              } else {
                if ((ref$ = dependsType.toLowerCase()) === &#039;and&#039; || ref$ === &#039;or&#039;) {
                  option.dependsOn = null;
                } else {
                  option.dependsOn = [&#039;and&#039;, rawDependsType];
                }
              }
            } else {
              option.dependsOn = null;
            }
          }
          if (option.required) {
            required.push(name);
          }
          opts[name] = option;
          if (option.concatRepeatedArrays != null) {
            cra = option.concatRepeatedArrays;
            if (&#039;Boolean&#039; === toString$.call(cra).slice(8, -1)) {
              option.concatRepeatedArrays = [cra, {}];
            } else if (cra.length === 1) {
              option.concatRepeatedArrays = [cra[0], {}];
            } else if (cra.length !== 2) {
              throw new Error(&quot;Invalid setting for concatRepeatedArrays&quot;);
            }
          }
          if (option.alias || option.aliases) {
            if (name === &#039;NUM&#039;) {
              throw new Error(&quot;-NUM option can&#039;t have aliases.&quot;);
            }
            if (option.alias) {
              option.aliases == null &amp;&amp; (option.aliases = [].concat(option.alias));
            }
            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ &lt; len1$; ++j$) {
              alias = ref$[j$];
              if (opts[alias] != null) {
                throw new Error(&quot;Option &#039;&quot; + alias + &quot;&#039; already defined.&quot;);
              }
              opts[alias] = option;
            }
            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];
            option.shortNames == null &amp;&amp; (option.shortNames = shortNames);
            option.longNames == null &amp;&amp; (option.longNames = longNames);
          }
          if ((!option.aliases || option.shortNames.length === 0) &amp;&amp; option.type === &#039;Boolean&#039; &amp;&amp; option[&#039;default&#039;] === &#039;true&#039;) {
            option.negateName = true;
          }
        }
      }
      function fn$(it){
        return it.length === 1;
      }
    };
    traverse(libOptions.options);
    getOption = function(name){
      var opt, possiblyMeant;
      opt = opts[name];
      if (opt == null) {
        possiblyMeant = closestString(keys(opts), name);
        throw new Error(&quot;Invalid option &#039;&quot; + nameToRaw(name) + &quot;&#039;&quot; + (possiblyMeant ? &quot; - perhaps you meant &#039;&quot; + nameToRaw(possiblyMeant) + &quot;&#039;?&quot; : &#039;.&#039;));
      }
      return opt;
    };
    parse = function(input, arg$){
      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;
      slice = (arg$ != null
        ? arg$
        : {}).slice;
      obj = {};
      positional = [];
      restPositional = false;
      overrideRequired = false;
      prop = null;
      setValue = function(name, value){
        var opt, val, cra, e, currentType;
        opt = getOption(name);
        if (opt.boolean) {
          val = value;
        } else {
          try {
            cra = opt.concatRepeatedArrays;
            if (cra != null &amp;&amp; cra[0] &amp;&amp; cra[1].oneValuePerFlag &amp;&amp; opt.parsedType.length === 1 &amp;&amp; opt.parsedType[0].structure === &#039;array&#039;) {
              val = [parseLevn(opt.parsedType[0].of, value)];
            } else {
              val = parseLevn(opt.parsedType, value);
            }
          } catch (e$) {
            e = e$;
            throw new Error(&quot;Invalid value for option &#039;&quot; + name + &quot;&#039; - expected type &quot; + opt.type + &quot;, received value: &quot; + value + &quot;.&quot;);
          }
          if (opt[&#039;enum&#039;] &amp;&amp; !any(function(it){
            return deepIs(it, val);
          }, opt.parsedPossibilities)) {
            throw new Error(&quot;Option &quot; + name + &quot;: &#039;&quot; + val + &quot;&#039; not one of &quot; + naturalJoin(opt[&#039;enum&#039;]) + &quot;.&quot;);
          }
        }
        currentType = toString$.call(obj[name]).slice(8, -1);
        if (obj[name] != null) {
          if (opt.concatRepeatedArrays != null &amp;&amp; opt.concatRepeatedArrays[0] &amp;&amp; currentType === &#039;Array&#039;) {
            obj[name] = obj[name].concat(val);
          } else if (opt.mergeRepeatedObjects &amp;&amp; currentType === &#039;Object&#039;) {
            import$(obj[name], val);
          } else {
            obj[name] = val;
          }
        } else {
          obj[name] = val;
        }
        if (opt.restPositional) {
          restPositional = true;
        }
        if (opt.overrideRequired) {
          overrideRequired = true;
        }
      };
      setDefaults = function(){
        var name, ref$, value;
        for (name in ref$ = defaults) {
          value = ref$[name];
          if (obj[name] == null) {
            obj[name] = value;
          }
        }
      };
      checkRequired = function(){
        var i$, ref$, len$, name;
        if (overrideRequired) {
          return;
        }
        for (i$ = 0, len$ = (ref$ = required).length; i$ &lt; len$; ++i$) {
          name = ref$[i$];
          if (!obj[name]) {
            throw new Error(&quot;Option &quot; + nameToRaw(name) + &quot; is required.&quot;);
          }
        }
      };
      mutuallyExclusiveError = function(first, second){
        throw new Error(&quot;The options &quot; + nameToRaw(first) + &quot; and &quot; + nameToRaw(second) + &quot; are mutually exclusive - you cannot use them at the same time.&quot;);
      };
      checkMutuallyExclusive = function(){
        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
        rules = libOptions.mutuallyExclusive;
        if (!rules) {
          return;
        }
        for (i$ = 0, len$ = rules.length; i$ &lt; len$; ++i$) {
          rule = rules[i$];
          present = null;
          for (j$ = 0, len1$ = rule.length; j$ &lt; len1$; ++j$) {
            element = rule[j$];
            if (toString$.call(element).slice(8, -1) === &#039;Array&#039;) {
              for (k$ = 0, len2$ = element.length; k$ &lt; len2$; ++k$) {
                opt = element[k$];
                if (opt in obj) {
                  if (present != null) {
                    mutuallyExclusiveError(present, opt);
                  } else {
                    present = opt;
                    break;
                  }
                }
              }
            } else {
              if (element in obj) {
                if (present != null) {
                  mutuallyExclusiveError(present, element);
                } else {
                  present = element;
                }
              }
            }
          }
        }
      };
      checkDependency = function(option){
        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
        dependsOn = option.dependsOn;
        if (!dependsOn || option.dependenciesMet) {
          return true;
        }
        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);
        for (i$ = 0, len$ = targetOptionNames.length; i$ &lt; len$; ++i$) {
          targetOptionName = targetOptionNames[i$];
          targetOption = obj[targetOptionName];
          if (targetOption &amp;&amp; checkDependency(targetOption)) {
            if (type === &#039;or&#039;) {
              return true;
            }
          } else if (type === &#039;and&#039;) {
            throw new Error(&quot;The option &#039;&quot; + option.option + &quot;&#039; did not have its dependencies met.&quot;);
          }
        }
        if (type === &#039;and&#039;) {
          return true;
        } else {
          throw new Error(&quot;The option &#039;&quot; + option.option + &quot;&#039; did not meet any of its dependencies.&quot;);
        }
      };
      checkDependencies = function(){
        var name;
        for (name in obj) {
          checkDependency(opts[name]);
        }
      };
      checkProp = function(){
        if (prop) {
          throw new Error(&quot;Value for &#039;&quot; + prop + &quot;&#039; of type &#039;&quot; + getOption(prop).type + &quot;&#039; required.&quot;);
        }
      };
      switch (toString$.call(input).slice(8, -1)) {
      case &#039;String&#039;:
        args = parseString(input.slice(slice != null ? slice : 0));
        break;
      case &#039;Array&#039;:
        args = input.slice(slice != null ? slice : 2);
        break;
      case &#039;Object&#039;:
        obj = {};
        for (key in input) {
          value = input[key];
          if (key !== &#039;_&#039;) {
            option = getOption(dasherize(key));
            if (parsedTypeCheck(option.parsedType, value)) {
              obj[option.option] = value;
            } else {
              throw new Error(&quot;Option &#039;&quot; + option.option + &quot;&#039;: Invalid type for &#039;&quot; + value + &quot;&#039; - expected type &#039;&quot; + option.type + &quot;&#039;.&quot;);
            }
          }
        }
        checkMutuallyExclusive();
        checkDependencies();
        setDefaults();
        checkRequired();
        return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;
      default:
        throw new Error(&quot;Invalid argument to &#039;parse&#039;: &quot; + input + &quot;.&quot;);
      }
      for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
        arg = args[i$];
        if (arg === &#039;--&#039;) {
          restPositional = true;
        } else if (restPositional) {
          positional.push(arg);
        } else {
          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {
            result = that;
            checkProp();
            short = result[1].length === 1;
            argName = result[2];
            usingAssign = result[3] != null;
            val = result[4];
            if (usingAssign &amp;&amp; val == null) {
              throw new Error(&quot;No value for &#039;&quot; + argName + &quot;&#039; specified.&quot;);
            }
            if (short) {
              flags = chars(argName);
              len = flags.length;
              for (j$ = 0, len1$ = flags.length; j$ &lt; len1$; ++j$) {
                i = j$;
                flag = flags[j$];
                opt = getOption(flag);
                name = opt.option;
                if (restPositional) {
                  positional.push(flag);
                } else if (i === len - 1) {
                  if (usingAssign) {
                    valPrime = opt.boolean ? parseLevn([{
                      type: &#039;Boolean&#039;
                    }], val) : val;
                    setValue(name, valPrime);
                  } else if (opt.boolean) {
                    setValue(name, true);
                  } else {
                    prop = name;
                  }
                } else if (opt.boolean) {
                  setValue(name, true);
                } else {
                  throw new Error(&quot;Can&#039;t set argument &#039;&quot; + flag + &quot;&#039; when not last flag in a group of short flags.&quot;);
                }
              }
            } else {
              negated = false;
              if (that = argName.match(/^no-(.+)$/)) {
                negated = true;
                noedName = that[1];
                opt = getOption(noedName);
              } else {
                opt = getOption(argName);
              }
              name = opt.option;
              if (opt.boolean) {
                valPrime = usingAssign ? parseLevn([{
                  type: &#039;Boolean&#039;
                }], val) : true;
                if (negated) {
                  setValue(name, !valPrime);
                } else {
                  setValue(name, valPrime);
                }
              } else {
                if (negated) {
                  throw new Error(&quot;Only use &#039;no-&#039; prefix for Boolean options, not with &#039;&quot; + noedName + &quot;&#039;.&quot;);
                }
                if (usingAssign) {
                  setValue(name, val);
                } else {
                  prop = name;
                }
              }
            }
          } else if (that = arg.match(/^-([0-9]+(?:\.[0-9]+)?)$/)) {
            opt = opts.NUM;
            if (!opt) {
              throw new Error(&#039;No -NUM option defined.&#039;);
            }
            setValue(opt.option, that[1]);
          } else {
            if (prop) {
              setValue(prop, arg);
              prop = null;
            } else {
              positional.push(arg);
              if (!libOptions.positionalAnywhere) {
                restPositional = true;
              }
            }
          }
        }
      }
      checkProp();
      checkMutuallyExclusive();
      checkDependencies();
      setDefaults();
      checkRequired();
      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;
    };
    return {
      parse: parse,
      parseArgv: function(it){
        return parse(it, {
          slice: 2
        });
      },
      generateHelp: generateHelp(libOptions),
      generateHelpForOption: generateHelpForOption(getOption, libOptions)
    };
  };
  main.VERSION = VERSION;
  module.exports = main;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
