<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bootbox/dist/bootbox.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bootbox/dist/bootbox.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1208</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*! @preserve
 * bootbox.js
 * version: 6.0.3
 * author: Nick Payne &lt;nick@kurai.co.uk&gt;
 * license: MIT
 * http://bootboxjs.com/
 */
(function (root, factory) {
  &#039;use strict&#039;;
  if (typeof define === &#039;function&#039; &amp;&amp; define.amd) {
    // AMD
    define([&#039;jquery&#039;], factory);
  } else if (typeof exports === &#039;object&#039;) {
    // Node, CommonJS-like
    module.exports = factory(require(&#039;jquery&#039;));
  } else {
    // Browser globals (root is window)
    root.bootbox = factory(root.jQuery);
  }
}(this, function init($, undefined) {
  &#039;use strict&#039;;

  let exports = {};

  let VERSION = &#039;6.0.3&#039;;
  exports.VERSION = VERSION;

  let locales = {
    &#039;en&#039; : {
      OK      : &#039;OK&#039;,
      CANCEL  : &#039;Cancel&#039;,
      CONFIRM : &#039;OK&#039;
    }
  };

  let templates = {
    dialog:         &#039;&lt;div class=&quot;bootbox modal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-hidden=&quot;true&quot;&gt;&lt;div class=&quot;modal-dialog&quot;&gt;&lt;div class=&quot;modal-content&quot;&gt;&lt;div class=&quot;modal-body&quot;&gt;&lt;div class=&quot;bootbox-body&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#039;,
    header:         &#039;&lt;div class=&quot;modal-header&quot;&gt;&lt;h5 class=&quot;modal-title&quot;&gt;&lt;/h5&gt;&lt;/div&gt;&#039;,
    footer:         &#039;&lt;div class=&quot;modal-footer&quot;&gt;&lt;/div&gt;&#039;,
    closeButton:    &#039;&lt;button type=&quot;button&quot; class=&quot;bootbox-close-button close btn-close&quot; aria-hidden=&quot;true&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt;&#039;,
    form:           &#039;&lt;form class=&quot;bootbox-form&quot;&gt;&lt;/form&gt;&#039;,
    button:         &#039;&lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;&lt;/button&gt;&#039;,
    option:         &#039;&lt;option value=&quot;&quot;&gt;&lt;/option&gt;&#039;,
    promptMessage:  &#039;&lt;div class=&quot;bootbox-prompt-message&quot;&gt;&lt;/div&gt;&#039;,
    inputs: {
      text:         &#039;&lt;input class=&quot;bootbox-input bootbox-input-text form-control&quot; autocomplete=&quot;off&quot; type=&quot;text&quot; /&gt;&#039;,
      textarea:     &#039;&lt;textarea class=&quot;bootbox-input bootbox-input-textarea form-control&quot;&gt;&lt;/textarea&gt;&#039;,
      email:        &#039;&lt;input class=&quot;bootbox-input bootbox-input-email form-control&quot; autocomplete=&quot;off&quot; type=&quot;email&quot; /&gt;&#039;,
      select:       &#039;&lt;select class=&quot;bootbox-input bootbox-input-select form-select&quot;&gt;&lt;/select&gt;&#039;,
      checkbox:     &#039;&lt;div class=&quot;form-check checkbox&quot;&gt;&lt;label class=&quot;form-check-label&quot;&gt;&lt;input class=&quot;form-check-input bootbox-input bootbox-input-checkbox&quot; type=&quot;checkbox&quot; /&gt;&lt;/label&gt;&lt;/div&gt;&#039;,
      radio:        &#039;&lt;div class=&quot;form-check radio&quot;&gt;&lt;label class=&quot;form-check-label&quot;&gt;&lt;input class=&quot;form-check-input bootbox-input bootbox-input-radio&quot; type=&quot;radio&quot; name=&quot;bootbox-radio&quot; /&gt;&lt;/label&gt;&lt;/div&gt;&#039;,
      date:         &#039;&lt;input class=&quot;bootbox-input bootbox-input-date form-control&quot; autocomplete=&quot;off&quot; type=&quot;date&quot; /&gt;&#039;,
      time:         &#039;&lt;input class=&quot;bootbox-input bootbox-input-time form-control&quot; autocomplete=&quot;off&quot; type=&quot;time&quot; /&gt;&#039;,
      number:       &#039;&lt;input class=&quot;bootbox-input bootbox-input-number form-control&quot; autocomplete=&quot;off&quot; type=&quot;number&quot; /&gt;&#039;,
      password:     &#039;&lt;input class=&quot;bootbox-input bootbox-input-password form-control&quot; autocomplete=&quot;off&quot; type=&quot;password&quot; /&gt;&#039;,
      range:        &#039;&lt;input class=&quot;bootbox-input bootbox-input-range form-control-range&quot; autocomplete=&quot;off&quot; type=&quot;range&quot; /&gt;&#039;
    }
  };


  let defaults = {
    // Default language used when generating buttons for alert, confirm, and prompt dialogs
    locale: &#039;en&#039;,
    // Show backdrop or not. Default to static so user has to interact with dialog
    backdrop: &#039;static&#039;,
    // Animate the modal in/out
    animate: true,
    // Additional class string applied to the top level dialog
    className: null,
    // Whether or not to include a close button
    closeButton: true,
    // Show the dialog immediately by default
    show: true,
    // Dialog container
    container: &#039;body&#039;,
    // Default value (used by the prompt helper)
    value: &#039;&#039;,
    // Default input type (used by the prompt helper)
    inputType: &#039;text&#039;,
    // Custom error message to report if prompt fails validation
    errorMessage: null,
    // Switch button order from cancel/confirm (default) to confirm/cancel
    swapButtonOrder: false,
    // Center modal vertically in page
    centerVertical: false,
    // Append &quot;multiple&quot; property to the select when using the &quot;prompt&quot; helper
    multiple: false,
    // Automatically scroll modal content when height exceeds viewport height
    scrollable: false,
    // Whether or not to destroy the modal on hide
    reusable: false,
    // The element which triggered the dialog
    relatedTarget: null,
    // The size of the modal to generate
    size: null,
    // A unique indentifier for this modal
    id: null
  };


  // PUBLIC FUNCTIONS
  // *************************************************************************************************************

  /**
   * Return all currently registered locales, or a specific locale if &quot;name&quot; is defined
   * @param {string} [name]
   * @returns {(Object|Object[])} An array of the available locale objects, or a single locale object if {name} is not null
   */
  exports.locales = function (name) {
    return name ? locales[name] : locales;
  };


  /**
   * Register localized strings for the OK, CONFIRM, and CANCEL buttons
   * @param {string} name - The key used to identify the new locale in the locales array
   * @param {Object} values - An object containing the localized string for each of the OK, CANCEL, and CONFIRM properties of a locale
   * @returns The updated bootbox object
   */
  exports.addLocale = function (name, values) {
    $.each([&#039;OK&#039;, &#039;CANCEL&#039;, &#039;CONFIRM&#039;], function (_, v) {
      if (!values[v]) {
        throw new Error(&#039;Please supply a translation for &quot;&#039; + v + &#039;&quot;&#039;);
      }
    });

    locales[name] = {
      OK: values.OK,
      CANCEL: values.CANCEL,
      CONFIRM: values.CONFIRM
    };

    return exports;
  };

 
  /**
   * Remove a previously-registered locale
   * @param {string} name - The key identifying the locale to remove
   * @returns The updated bootbox object
   */
  exports.removeLocale = function (name) {
    if (name !== &#039;en&#039;) {
      delete locales[name];
    }
    else {
      throw new Error(&#039;&quot;en&quot; is used as the default and fallback locale and cannot be removed.&#039;);
    }

    return exports;
  };


  /**
   * Set the default locale
   * @param {string} name - The key identifying the locale to set as the default locale for all future bootbox calls 
   * @returns The updated bootbox object
   */
  exports.setLocale = function (name) {
    return exports.setDefaults(&#039;locale&#039;, name);
  };


  /**
   * Override default value(s) of Bootbox.
   * @returns The updated bootbox object
   */
  exports.setDefaults = function () {
    let values = {};

    if (arguments.length === 2) {
      // Allow passing of single key/value...
      values[arguments[0]] = arguments[1];
    } else {
      // ... and as an object too
      values = arguments[0];
    }

    $.extend(defaults, values);

    return exports;
  };


  /**
   * Hides all currently active Bootbox modals
   * @returns The current bootbox object
   */
  exports.hideAll = function () {
    $(&#039;.bootbox&#039;).modal(&#039;hide&#039;);

    return exports;
  };

 
  /**
   * Allows the base init() function to be overridden
   * @param {function} _$ - A function to be called when the bootbox instance is created
   * @returns The current bootbox object
   */
  exports.init = function (_$) {
    return init(_$ || $);
  };


  // CORE HELPER FUNCTIONS
  // *************************************************************************************************************

  /**
   * The core dialog helper function, which can be used to create any custom Bootstrap modal. 
   * @param {Object} options - An object used to configure the various properties which define a Bootbox dialog
   * @returns A jQuery object upon which Bootstrap&#039;s modal function has been called
   */
  exports.dialog = function (options) {
    if ($.fn.modal === undefined) {
      throw new Error(
        &#039;&quot;$.fn.modal&quot; is not defined; please double check you have included the Bootstrap JavaScript library. See https://getbootstrap.com/docs/5.1/getting-started/introduction/ for more details.&#039;
      );
    }

    options = sanitize(options);

    if ($.fn.modal.Constructor.VERSION) {
      options.fullBootstrapVersion = $.fn.modal.Constructor.VERSION;
      let i = options.fullBootstrapVersion.indexOf(&#039;.&#039;);
      options.bootstrap = options.fullBootstrapVersion.substring(0, i);
    }
    else {
      // Assuming version 2.3.2, as that was the last &quot;supported&quot; 2.x version
      options.bootstrap = &#039;2&#039;;
      options.fullBootstrapVersion = &#039;2.3.2&#039;;
      console.warn(&#039;Bootbox will *mostly* work with Bootstrap 2, but we do not officially support it. Please upgrade, if possible.&#039;);
    }

    let dialog = $(templates.dialog);
    let innerDialog = dialog.find(&#039;.modal-dialog&#039;);
    let body = dialog.find(&#039;.modal-body&#039;);
    let header = $(templates.header);
    let footer = $(templates.footer);
    let buttons = options.buttons;

    let callbacks = {
      onEscape: options.onEscape
    };

    body.find(&#039;.bootbox-body&#039;).html(options.message);

    // Only attempt to create buttons if at least one has been defined in the options object
    if (getKeyLength(options.buttons) &gt; 0) {
      each(buttons, function (key, b) {
        let button = $(templates.button);
        button.data(&#039;bb-handler&#039;, key);
        button.addClass(b.className);

        switch (key) {
          case &#039;ok&#039;:
          case &#039;confirm&#039;:
            button.addClass(&#039;bootbox-accept&#039;);
            break;

          case &#039;cancel&#039;:
            button.addClass(&#039;bootbox-cancel&#039;);
            break;
        }

        button.html(b.label);

        if (b.id) {
          button.attr({ &#039;id&#039;: b.id });
        }

        if (b.disabled === true) {
          button.prop({ disabled: true });
        }

        footer.append(button);

        callbacks[key] = b.callback;
      });

      body.after(footer);
    }

    if (options.animate === true) {
      dialog.addClass(&#039;fade&#039;);
    }

    if (options.className) {
      dialog.addClass(options.className);
    }

    if (options.id) {
      dialog.attr({ &#039;id&#039;: options.id });
    }

    if (options.size) {
      // Requires Bootstrap 3.1.0 or higher
      if (options.fullBootstrapVersion.substring(0, 3) &lt; &#039;3.1&#039;) {
        console.warn(&#039;&quot;size&quot; requires Bootstrap 3.1.0 or higher. You appear to be using &#039; + options.fullBootstrapVersion + &#039;. Please upgrade to use this option.&#039;);
      }

      switch (options.size) {
        case &#039;small&#039;:
        case &#039;sm&#039;:
          innerDialog.addClass(&#039;modal-sm&#039;);
          break;

        case &#039;large&#039;:
        case &#039;lg&#039;:
          innerDialog.addClass(&#039;modal-lg&#039;);
          break;

        case &#039;extra-large&#039;:
        case &#039;xl&#039;:
          innerDialog.addClass(&#039;modal-xl&#039;);

          // Requires Bootstrap 4.2.0 or higher
          if (options.fullBootstrapVersion.substring(0, 3) &lt; &#039;4.2&#039;) {
            console.warn(&#039;Using size &quot;xl&quot;/&quot;extra-large&quot; requires Bootstrap 4.2.0 or higher. You appear to be using &#039; + options.fullBootstrapVersion + &#039;. Please upgrade to use this option.&#039;);
          }
          break;
      }
    }

    if (options.scrollable) {
      innerDialog.addClass(&#039;modal-dialog-scrollable&#039;);

      // Requires Bootstrap 4.3.0 or higher
      if (options.fullBootstrapVersion.substring(0, 3) &lt; &#039;4.3&#039;) {
        console.warn(&#039;Using &quot;scrollable&quot; requires Bootstrap 4.3.0 or higher. You appear to be using &#039; + options.fullBootstrapVersion + &#039;. Please upgrade to use this option.&#039;);
      }
    }

    if(options.title || options.closeButton) {
      if (options.title) {
        header.find(&#039;.modal-title&#039;).html(options.title);
      }
      else {
        header.addClass(&#039;border-0&#039;);
      }

      if (options.closeButton) {
        let closeButton = $(templates.closeButton);      
        if (options.bootstrap &lt; 5) {
          closeButton.html(&#039;&amp;times;&#039;);
        }

        /* Note: the close button for Bootstrap 5+ does not contain content */
        if(options.bootstrap &lt; 4) {
          /* Bootstrap 3 and under */
          header.prepend(closeButton);
        }
        else {
          header.append(closeButton);
        }
      }

      body.before(header);
    }

    if (options.centerVertical) {
      innerDialog.addClass(&#039;modal-dialog-centered&#039;);

      // Requires Bootstrap 4.0.0-beta.3 or higher
      if (options.fullBootstrapVersion &lt; &#039;4.0.0&#039;) {
        console.warn(&#039;&quot;centerVertical&quot; requires Bootstrap 4.0.0-beta.3 or higher. You appear to be using &#039; + options.fullBootstrapVersion + &#039;. Please upgrade to use this option.&#039;);
      }
    }

    // Bootstrap event listeners; these handle extra setup &amp; teardown required after the underlying modal has performed certain actions.

    if(!options.reusable) {
      // make sure we unbind any listeners once the dialog has definitively been dismissed
      dialog.one(&#039;hide.bs.modal&#039;, { dialog: dialog }, unbindModal);
      dialog.one(&#039;hidden.bs.modal&#039;, { dialog: dialog }, destroyModal);
    }

    if (options.onHide) {
      if (typeof options.onHide === &#039;function&#039;) {
        dialog.on(&#039;hide.bs.modal&#039;, options.onHide);
      }
      else {
        throw new Error(&#039;Argument supplied to &quot;onHide&quot; must be a function&#039;);
      }
    }

    if (options.onHidden) {
      if (typeof options.onHidden === &#039;function&#039;) {
        dialog.on(&#039;hidden.bs.modal&#039;, options.onHidden);
      }
      else {
        throw new Error(&#039;Argument supplied to &quot;onHidden&quot; must be a function&#039;);
      }
    }

    if (options.onShow) {
      if (typeof options.onShow === &#039;function&#039;) {
        dialog.on(&#039;show.bs.modal&#039;, options.onShow);
      }
      else {
        throw new Error(&#039;Argument supplied to &quot;onShow&quot; must be a function&#039;);
      }
    }

    dialog.one(&#039;shown.bs.modal&#039;, { dialog: dialog }, focusPrimaryButton);

    if (options.onShown) {
      if (typeof options.onShown === &#039;function&#039;) {
        dialog.on(&#039;shown.bs.modal&#039;, options.onShown);
      }
      else {
        throw new Error(&#039;Argument supplied to &quot;onShown&quot; must be a function&#039;);
      }
    }

    // Bootbox event listeners; used to decouple some behaviours from their respective triggers

    if (options.backdrop === true) {
      let startedOnBody = false;

      // Prevents the event from propagating to the backdrop, when something inside the dialog is clicked
      dialog.on(&#039;mousedown&#039;, &#039;.modal-content&#039;, function(e) {
        e.stopPropagation();

        startedOnBody = true;
      });

      // A boolean true/false according to the Bootstrap docs should show a dialog the user can dismiss by clicking on the background.
      // We always only ever pass static/false to the actual $.modal function because with &quot;true&quot; we can&#039;t trap this event (the .modal-backdrop swallows it).
      // However, we still want to sort-of respect true and invoke the escape mechanism instead
      dialog.on(&#039;click.dismiss.bs.modal&#039;, function (e) {
        if (startedOnBody || e.target !== e.currentTarget) {
          return;
        }

        dialog.trigger(&#039;escape.close.bb&#039;);
      });
    }

    dialog.on(&#039;escape.close.bb&#039;, function (e) {
      // The if() statement looks redundant but it isn&#039;t; without it, if we *didn&#039;t* have an onEscape handler then processCallback would automatically dismiss the dialog
      if (callbacks.onEscape) {
        processCallback(e, dialog, callbacks.onEscape);
      }
    });

    dialog.on(&#039;click&#039;, &#039;.modal-footer button:not(.disabled)&#039;, function (e) {
      let callbackKey = $(this).data(&#039;bb-handler&#039;);

      if (callbackKey !== undefined) {
        // Only process callbacks for buttons we recognize:
        processCallback(e, dialog, callbacks[callbackKey]);
      }
    });

    dialog.on(&#039;click&#039;, &#039;.bootbox-close-button&#039;, function (e) {
      // onEscape might be falsy, but that&#039;s fine; the fact is if the user has managed to click the close button we have to close the dialog, callback or not
      processCallback(e, dialog, callbacks.onEscape);
    });

    dialog.on(&#039;keyup&#039;, function (e) {
      if (e.which === 27) {
        dialog.trigger(&#039;escape.close.bb&#039;);
      }
    });

    /*
    The remainder of this method simply deals with adding our dialog element to the DOM, augmenting it with 
    Bootstrap&#039;s modal functionality and then giving the resulting object back to our caller
    */

    $(options.container).append(dialog);

    dialog.modal({
      backdrop: options.backdrop,
      keyboard: false,
      show: false
    });

    if (options.show) {
      dialog.modal(&#039;show&#039;, options.relatedTarget);
    }

    return dialog;
  };


  /**
   * Helper function to simulate the native alert() behavior. **NOTE**: This is non-blocking, so any code that must happen after the alert is dismissed should be placed within the callback function for this alert.
   * @returns  A jQuery object upon which Bootstrap&#039;s modal function has been called
   */
  exports.alert = function () {
    let options;

    options = mergeDialogOptions(&#039;alert&#039;, [&#039;ok&#039;], [&#039;message&#039;, &#039;callback&#039;], arguments);

    // @TODO: can this move inside exports.dialog when we&#039;re iterating over each button and checking its button.callback value instead?
    if (options.callback &amp;&amp; typeof options.callback !== &#039;function&#039;) {
      throw new Error(&#039;alert requires the &quot;callback&quot; property to be a function when provided&#039;);
    }

    // Override the ok and escape callback to make sure they just invoke the single user-supplied one (if provided)
    options.buttons.ok.callback = options.onEscape = function () {
      if (typeof options.callback  === &#039;function&#039;) {
        return options.callback.call(this);
      }

      return true;
    };

    return exports.dialog(options);
  };


  /**
   * Helper function to simulate the native confirm() behavior. **NOTE**: This is non-blocking, so any code that must happen after the confirm is dismissed should be placed within the callback function for this confirm.
   * @returns A jQuery object upon which Bootstrap&#039;s modal function has been called
   */
  exports.confirm = function () {
    let options;

    options = mergeDialogOptions(&#039;confirm&#039;, [&#039;cancel&#039;, &#039;confirm&#039;], [&#039;message&#039;, &#039;callback&#039;], arguments);

    // confirm specific validation; they don&#039;t make sense without a callback so make sure it&#039;s present
    if (typeof options.callback !== &#039;function&#039;) {
      throw new Error(&#039;confirm requires a callback&#039;);
    }

    // Overrides; undo anything the user tried to set they shouldn&#039;t have
    options.buttons.cancel.callback = options.onEscape = function () {
      return options.callback.call(this, false);
    };

    options.buttons.confirm.callback = function () {
      return options.callback.call(this, true);
    };

    return exports.dialog(options);
  };


  /**
   * Helper function to simulate the native prompt() behavior. **NOTE**: This is non-blocking, so any code that must happen after the prompt is dismissed should be placed within the callback function for this prompt.
   * @returns A jQuery object upon which Bootstrap&#039;s modal function has been called
   */
  exports.prompt = function () {
    let options;
    let promptDialog;
    let form;
    let input;
    let shouldShow;
    let inputOptions;

    // We have to create our form first, otherwise its value is undefined when gearing up our options.
    // @TODO this could be solved by allowing message to be a function instead...
    form = $(templates.form);

    // prompt defaults are more complex than others in that users can override more defaults
    options = mergeDialogOptions(&#039;prompt&#039;, [&#039;cancel&#039;, &#039;confirm&#039;], [&#039;title&#039;, &#039;callback&#039;], arguments);

    if (!options.value) {
      options.value = defaults.value;
    }

    if (!options.inputType) {
      options.inputType = defaults.inputType;
    }

    // Capture the user&#039;s &#039;show&#039; value; we always set this to false before spawning the dialog to give us a chance to attach some handlers to it, but we need to make sure we respect a preference not to show it
    shouldShow = (options.show === undefined) ? defaults.show : options.show;

    // This is required prior to calling the dialog builder below - we need to add an event handler just before the prompt is shown
    options.show = false;

    // Handles the &#039;cancel&#039; action
    options.buttons.cancel.callback = options.onEscape = function () {
      return options.callback.call(this, null);
    };

    // Prompt submitted - extract the prompt value. This requires a bit of work, given the different input types available.
    options.buttons.confirm.callback = function () {
      let value;

      if (options.inputType === &#039;checkbox&#039;) {
        value = input.find(&#039;input:checked&#039;).map(function () {
          return $(this).val();
        }).get();
        if(value.length === 0 &amp;&amp; options.required === true) {
            // prevents button callback from being called if no checkboxes have been checked
            return false;
        }
      } else if (options.inputType === &#039;radio&#039;) {
        value = input.find(&#039;input:checked&#039;).val();
      }
      else {
        let el = input[0];
        
        if (el.checkValidity &amp;&amp; !el.checkValidity()) {
          // If a custom error message was provided, add it now
          if(options.errorMessage){
            el.setCustomValidity(options.errorMessage);
          }
          
          if(el.reportValidity) { 
            el.reportValidity();
          }

          // prevents button callback from being called
          return false;
        } else {
          if (options.inputType === &#039;select&#039; &amp;&amp; options.multiple === true) {
            value = input.find(&#039;option:selected&#039;).map(function () {
              return $(this).val();
            }).get();
          }
          else {
            value = input.val();
          }
        }
      }

      return options.callback.call(this, value);
    };

    // prompt-specific validation
    if (!options.title) {
      throw new Error(&#039;prompt requires a title&#039;);
    }

    if (typeof options.callback !== &#039;function&#039;) {
      throw new Error(&#039;prompt requires a callback&#039;);
    }

    if (!templates.inputs[options.inputType]) {
      throw new Error(&#039;Invalid prompt type&#039;);
    }

    // Create the input based on the supplied type
    input = $(templates.inputs[options.inputType]);

    switch (options.inputType) {
      case &#039;text&#039;:
      case &#039;textarea&#039;:
      case &#039;email&#039;:
      case &#039;password&#039;:
        input.val(options.value);

        if (options.placeholder) {
          input.attr(&#039;placeholder&#039;, options.placeholder);
        }

        if (options.pattern) {
          input.attr(&#039;pattern&#039;, options.pattern);
        }

        if (options.maxlength) {
          input.attr(&#039;maxlength&#039;, options.maxlength);
        }

        if (options.required) {
          input.prop({ &#039;required&#039;: true });
        }

        if (options.rows &amp;&amp; !isNaN(parseInt(options.rows))) {
          if (options.inputType === &#039;textarea&#039;) {
            input.attr({ &#039;rows&#039;: options.rows });
          }
        }
        break;

      case &#039;date&#039;:
      case &#039;time&#039;:
      case &#039;number&#039;:
      case &#039;range&#039;:
        input.val(options.value);

        if (options.placeholder) {
          input.attr(&#039;placeholder&#039;, options.placeholder);
        }

        if (options.pattern) {
          input.attr(&#039;pattern&#039;, options.pattern);
        }
        else {
          if(options.inputType === &#039;date&#039;) {
            // Add the ISO-8601 short date format as a fallback for browsers without native type=&quot;date&quot; support
            input.attr(&#039;pattern&#039;, &#039;\d{4}-\d{2}-\d{2}&#039;);
          }
          else if(options.inputType === &#039;time&#039;) {
            // Add an HH:MM pattern as a fallback for browsers without native type=&quot;time&quot; support
            input.attr(&#039;pattern&#039;, &#039;\d{2}:\d{2}&#039;);
          }
        }

        if (options.required) {
          input.prop({ &#039;required&#039;: true });
        }

        // These input types have extra attributes which affect their input validation.
        // Warning: For most browsers, date inputs are buggy in their implementation of &#039;step&#039;, so this attribute will have no effect. Therefore, we don&#039;t set the attribute for date inputs.
        // @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date#Setting_maximum_and_minimum_dates
        if (options.inputType !== &#039;date&#039;) {
          if (options.step) {
            if (options.step === &#039;any&#039; || (!isNaN(options.step) &amp;&amp; parseFloat(options.step) &gt; 0)) {
              input.attr(&#039;step&#039;, options.step);
            }
            else {
              throw new Error(&#039;&quot;step&quot; must be a valid positive number or the value &quot;any&quot;. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-step for more information.&#039;);
            }
          }
        }

        if (minAndMaxAreValid(options.inputType, options.min, options.max)) {
          if (options.min !== undefined) {
            input.attr(&#039;min&#039;, options.min);
          }
          if (options.max !== undefined) {
            input.attr(&#039;max&#039;, options.max);
          }
        }
        break;

      case &#039;select&#039;:
        let groups = {};
        inputOptions = options.inputOptions || [];

        if (!Array.isArray(inputOptions)) {
          throw new Error(&#039;Please pass an array of input options&#039;);
        }

        if (!inputOptions.length) {
          throw new Error(&#039;prompt with &quot;inputType&quot; set to &quot;select&quot; requires at least one option&#039;);
        }

        if (options.required) {
          input.prop({ &#039;required&#039;: true });
        }

        if (options.multiple) {
          input.prop({ &#039;multiple&#039;: true });
        }

        each(inputOptions, function (_, option) {
          // Assume the element to attach to is the input...
          let elem = input;

          if (option.value === undefined || option.text === undefined) {
            throw new Error(&#039;each option needs a &quot;value&quot; property and a &quot;text&quot; property&#039;);
          }

          // ... but override that element if this option sits in a group

          if (option.group) {
            // Initialise group if necessary
            if (!groups[option.group]) {
              groups[option.group] = $(&#039;&lt;optgroup /&gt;&#039;).attr(&#039;label&#039;, option.group);
            }

            elem = groups[option.group];
          }

          let o = $(templates.option);
          o.attr(&#039;value&#039;, option.value).text(option.text);
          elem.append(o);
        });

        each(groups, function (_, group) {
          input.append(group);
        });

        // Safe to set a select&#039;s value as per a normal input
        input.val(options.value);
        if (options.bootstrap &lt; 5) {
          input.removeClass(&#039;form-select&#039;).addClass(&#039;form-control&#039;);
        }
        break;

      case &#039;checkbox&#039;:
        let checkboxValues = Array.isArray(options.value) ? options.value : [options.value];
        inputOptions = options.inputOptions || [];

        if (!inputOptions.length) {
          throw new Error(&#039;prompt with &quot;inputType&quot; set to &quot;checkbox&quot; requires at least one option&#039;);
        }

        // Checkboxes have to nest within a containing element, so they break the rules a bit and we end up re-assigning our &#039;input&#039; element to this container instead
        input = $(&#039;&lt;div class=&quot;bootbox-checkbox-list&quot;&gt;&lt;/div&gt;&#039;);

        each(inputOptions, function (_, option) {
          if (option.value === undefined || option.text === undefined) {
            throw new Error(&#039;each option needs a &quot;value&quot; property and a &quot;text&quot; property&#039;);
          }

          let checkbox = $(templates.inputs[options.inputType]);

          checkbox.find(&#039;input&#039;).attr(&#039;value&#039;, option.value);
          checkbox.find(&#039;label&#039;).append(&#039;\n&#039; + option.text);

          // We&#039;ve ensured values is an array, so we can always iterate over it
          each(checkboxValues, function (_, value) {
            if (value === option.value) {
              checkbox.find(&#039;input&#039;).prop(&#039;checked&#039;, true);
            }
          });

          input.append(checkbox);
        });
        break;

      case &#039;radio&#039;:
        // Make sure that value is not an array (only a single radio can ever be checked)
        if (options.value !== undefined &amp;&amp; Array.isArray(options.value)) {
          throw new Error(&#039;prompt with &quot;inputType&quot; set to &quot;radio&quot; requires a single, non-array value for &quot;value&quot;&#039;);
        }

        inputOptions = options.inputOptions || [];

        if (!inputOptions.length) {
          throw new Error(&#039;prompt with &quot;inputType&quot; set to &quot;radio&quot; requires at least one option&#039;);
        }

        // Radiobuttons have to nest within a containing element, so they break the rules a bit and we end up re-assigning our &#039;input&#039; element to this container instead
        input = $(&#039;&lt;div class=&quot;bootbox-radiobutton-list&quot;&gt;&lt;/div&gt;&#039;);

        // Radiobuttons should always have an initial checked input checked in a &quot;group&quot;.
        // If value is undefined or doesn&#039;t match an input option, select the first radiobutton
        let checkFirstRadio = true;

        each(inputOptions, function (_, option) {
          if (option.value === undefined || option.text === undefined) {
            throw new Error(&#039;each option needs a &quot;value&quot; property and a &quot;text&quot; property&#039;);
          }

          let radio = $(templates.inputs[options.inputType]);

          radio.find(&#039;input&#039;).attr(&#039;value&#039;, option.value);
          radio.find(&#039;label&#039;).append(&#039;\n&#039; + option.text);

          if (options.value !== undefined) {
            if (option.value === options.value) {
              radio.find(&#039;input&#039;).prop(&#039;checked&#039;, true);
              checkFirstRadio = false;
            }
          }

          input.append(radio);
        });

        if (checkFirstRadio) {
          input.find(&#039;input[type=&quot;radio&quot;]&#039;).first().prop(&#039;checked&#039;, true);
        }
        break;
    }

    // Now place it in our form
    form.append(input);

    form.on(&#039;submit&#039;, function (e) {
      e.preventDefault();
      // Fix for SammyJS (or similar JS routing library) hijacking the form post.
      e.stopPropagation();

      // @TODO can we actually click *the* button object instead?
      // e.g. buttons.confirm.click() or similar
      promptDialog.find(&#039;.bootbox-accept&#039;).trigger(&#039;click&#039;);
    });

    if (options.message &amp;&amp; options.message.trim() !== &#039;&#039;) {
      // Add the form to whatever content the user may have added.
      let message = $(templates.promptMessage).html(options.message);
      form.prepend(message);
      options.message = form;
    }
    else {
      options.message = form;
    }

    // Generate the dialog
    promptDialog = exports.dialog(options);

    // Clear the existing handler focusing the submit button...
    promptDialog.off(&#039;shown.bs.modal&#039;, focusPrimaryButton);

    // ...and replace it with one focusing our input, if possible
    promptDialog.on(&#039;shown.bs.modal&#039;, function () {
      // Need the closure here since input isn&#039;tcan object otherwise
      input.focus();
    });

    if (shouldShow === true) {
      promptDialog.modal(&#039;show&#039;);
    }

    return promptDialog;
  };


  // INTERNAL FUNCTIONS
  // *************************************************************************************************************

  // Map a flexible set of arguments into a single returned object.
  // If args.length is already one just return it, otherwise use the properties argument to map the unnamed args to object properties.
  // So in the latter case:
  //
  //    mapArguments([&quot;foo&quot;, $.noop], [&quot;message&quot;, &quot;callback&quot;])
  //  
  //  results in
  //
  //    { message: &quot;foo&quot;, callback: $.noop }
  //
  function mapArguments(args, properties) {
    let argsLength = args.length;
    let options = {};

    if (argsLength &lt; 1 || argsLength &gt; 2) {
      throw new Error(&#039;Invalid argument length&#039;);
    }

    if (argsLength === 2 || typeof args[0] === &#039;string&#039;) {
      options[properties[0]] = args[0];
      options[properties[1]] = args[1];
    } else {
      options = args[0];
    }

    return options;
  }


  // Merge a set of default dialog options with user supplied arguments
  function mergeArguments(defaults, args, properties) {
    return $.extend(
      // Deep merge
      true,
      // Ensure the target is an empty, unreferenced object
      {},
      // The base options object for this type of dialog (often just buttons)
      defaults,
      // &#039;args&#039; could be an object or array; if it&#039;s an array properties will map it to a proper options object
      mapArguments(args, properties)
    );
  }


  // This entry-level method makes heavy use of composition to take a simple range of inputs and return valid options suitable for passing to bootbox.dialog
  function mergeDialogOptions(className, labels, properties, args) {
    let locale;
    if (args &amp;&amp; args[0]) {
      locale = args[0].locale || defaults.locale;
      let swapButtons = args[0].swapButtonOrder || defaults.swapButtonOrder;

      if (swapButtons) {
        labels = labels.reverse();
      }
    }

    // Build up a base set of dialog properties
    let baseOptions = {
      className: &#039;bootbox-&#039; + className,
      buttons: createLabels(labels, locale)
    };

    // Ensure the buttons properties generated, *after* merging with user args are still valid against the supplied labels
    return validateButtons(
      // Merge the generated base properties with user supplied arguments
      mergeArguments(
        baseOptions,
        args,
        // If args.length &gt; 1, properties specify how each arg maps to an object key
        properties
      ),
      labels
    );
  }


  // Checks each button object to see if key is valid. 
  // This function will only be called by the alert, confirm, and prompt helpers. 
  function validateButtons(options, buttons) {
    let allowedButtons = {};
    each(buttons, function (key, value) {
      allowedButtons[value] = true;
    });

    each(options.buttons, function (key) {
      if (allowedButtons[key] === undefined) {
        throw new Error(&#039;button key &quot;&#039; + key + &#039;&quot; is not allowed (options are &#039; + buttons.join(&#039; &#039;) + &#039;)&#039;);
      }
    });

    return options;
  }


  // From a given list of arguments, return a suitable object of button labels.
  // All this does is normalise the given labels and translate them where possible.
  // e.g. &quot;ok&quot;, &quot;confirm&quot; -&gt; { ok: &quot;OK&quot;, cancel: &quot;Annuleren&quot; }
  function createLabels(labels, locale) {
    let buttons = {};

    for (let i = 0, j = labels.length; i &lt; j; i++) {
      let argument = labels[i];
      let key = argument.toLowerCase();
      let value = argument.toUpperCase();

      buttons[key] = {
        label: getText(value, locale)
      };
    }

    return buttons;
  }


  // Get localized text from a locale. Defaults to &#039;en&#039; locale if no locale provided or a non-registered locale is requested
  function getText(key, locale) {
    let labels = locales[locale];

    return labels ? labels[key] : locales.en[key];
  }


  // Filter and tidy up any user supplied parameters to this dialog.
  // Also looks for any shorthands used and ensures that the options which are returned are all normalized properly
  function sanitize(options) {
    let buttons;
    let total;

    if (typeof options !== &#039;object&#039;) {
      throw new Error(&#039;Please supply an object of options&#039;);
    }

    if (!options.message) {
      throw new Error(&#039;&quot;message&quot; option must not be null or an empty string.&#039;);
    }

    // Make sure any supplied options take precedence over defaults
    options = $.extend({}, defaults, options);

    // Make sure backdrop is either true, false, or &#039;static&#039;
    if (!options.backdrop) {
      options.backdrop = (options.backdrop === false || options.backdrop === 0) ? false : &#039;static&#039;;
    } else {
      options.backdrop = typeof options.backdrop === &#039;string&#039; &amp;&amp; options.backdrop.toLowerCase() === &#039;static&#039; ? &#039;static&#039; : true;
    } 

    // No buttons is still a valid dialog but it&#039;s cleaner to always have a buttons object to iterate over, even if it&#039;s empty
    if (!options.buttons) {
      options.buttons = {};
    }
    
    buttons = options.buttons;

    total = getKeyLength(buttons);

    each(buttons, function (key, button, index) {
      if (typeof button === &#039;function&#039;) {
        // Short form, assume value is our callback. Since button isn&#039;t an object it isn&#039;t a reference either so re-assign it
        button = buttons[key] = {
          callback: button
        };
      }

      // Before any further checks, make sure button is the correct type
      if (typeof button !== &#039;object&#039;) {
        throw new Error(&#039;button with key &quot;&#039; + key + &#039;&quot; must be an object&#039;);
      }

      if (!button.label) {
        // The lack of an explicit label means we&#039;ll assume the key is good enough
        button.label = key;
      }

      if (!button.className) {
        let isPrimary = false;
        if (options.swapButtonOrder) {
          isPrimary = index === 0;
        }
        else {
          isPrimary = index === total - 1;
        }

        if (total &lt;= 2 &amp;&amp; isPrimary) {
          // always add a primary to the main option in a one or two-button dialog
          button.className = &#039;btn-primary&#039;;
        } 
        else {
          // adding both classes allows us to target both BS3 and BS4+ without needing to check the version
          button.className = &#039;btn-secondary btn-default&#039;;
        }
      }
    });

    return options;
  }


  // Returns a count of the properties defined on the object
  function getKeyLength(obj) {
    return Object.keys(obj).length;
  }


  // Tiny wrapper function around jQuery.each; just adds index as the third parameter
  function each(collection, iterator) {
    let index = 0;
    $.each(collection, function (key, value) {
      iterator(key, value, index++);
    });
  }


  function focusPrimaryButton(e) {
    e.data.dialog.find(&#039;.bootbox-accept&#039;).first().trigger(&#039;focus&#039;);
  }


  function destroyModal(e) {
    // Ensure we don&#039;t accidentally intercept hidden events triggered by children of the current dialog. 
    // We shouldn&#039;t need to handle this anymore, now that Bootstrap namespaces its events, but still worth doing.
    if (e.target === e.data.dialog[0]) {
      e.data.dialog.remove();
    }
  }


  function unbindModal(e) {
    if (e.target === e.data.dialog[0]) {
      e.data.dialog.off(&#039;escape.close.bb&#039;);
      e.data.dialog.off(&#039;click&#039;);
    }
  }


  //  Handle the invoked dialog callback
  function processCallback(e, dialog, callback) {
    e.stopPropagation();
    e.preventDefault();

    // By default we assume a callback will get rid of the dialog, although it is given the opportunity to override this

    // If the callback can be invoked and it *explicitly returns false*, then we&#039;ll set a flag to keep the dialog active...
    let preserveDialog = typeof callback === &#039;function&#039; &amp;&amp; callback.call(dialog, e) === false;

    // ... otherwise we&#039;ll bin it
    if (!preserveDialog) {
      dialog.modal(&#039;hide&#039;);
    }
  }

  // Validate `min` and `max` values based on the current `inputType` value
  function minAndMaxAreValid(type, min, max) {
    let result = false;
    let minValid = true;
    let maxValid = true;

    if (type === &#039;date&#039;) {
      if (min !== undefined &amp;&amp; !(minValid = dateIsValid(min))) {
        console.warn(&#039;Browsers which natively support the &quot;date&quot; input type expect date values to be of the form &quot;YYYY-MM-DD&quot; (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your min value may not be enforced by this browser.&#039;);
      }
      else if (max !== undefined &amp;&amp; !(maxValid = dateIsValid(max))) {
        console.warn(&#039;Browsers which natively support the &quot;date&quot; input type expect date values to be of the form &quot;YYYY-MM-DD&quot; (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your max value may not be enforced by this browser.&#039;);
      }
    }
    else if (type === &#039;time&#039;) {
      if (min !== undefined &amp;&amp; !(minValid = timeIsValid(min))) {
        throw new Error(&#039;&quot;min&quot; is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.&#039;);
      }
      else if (max !== undefined &amp;&amp; !(maxValid = timeIsValid(max))) {
        throw new Error(&#039;&quot;max&quot; is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.&#039;);
      }
    }
    else {
      if (min !== undefined &amp;&amp; isNaN(min)) {
        minValid = false;
        throw new Error(&#039;&quot;min&quot; must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-min for more information.&#039;);
      }

      if (max !== undefined &amp;&amp; isNaN(max)) {
        maxValid = false;
        throw new Error(&#039;&quot;max&quot; must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.&#039;);
      }
    }

    if (minValid &amp;&amp; maxValid) {
      if (max &lt; min) {
        throw new Error(&#039;&quot;max&quot; must be greater than or equal to &quot;min&quot;. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.&#039;);
      }
      else {
        result = true;
      }
    }

    return result;
  }

  function timeIsValid(value) {
    return /([01][0-9]|2[0-3]):[0-5][0-9]?:[0-5][0-9]/.test(value);
  }

  function dateIsValid(value) {
    return /(\d{4})-(\d{2})-(\d{2})/.test(value);
  }

  //  The Bootbox object
  return exports;
}));
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
