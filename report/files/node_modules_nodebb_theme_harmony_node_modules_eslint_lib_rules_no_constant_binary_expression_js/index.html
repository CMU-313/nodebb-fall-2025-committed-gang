<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-constant-binary-expression.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-constant-binary-expression.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">604</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.95</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit
 * @author Jordan Eldredge &lt;https://jordaneldredge.com&gt;
 */

&quot;use strict&quot;;

const {
	isNullLiteral,
	isConstant,
	isReferenceToGlobalVariable,
	isLogicalAssignmentOperator,
	ECMASCRIPT_GLOBALS,
} = require(&quot;./utils/ast-utils&quot;);

const NUMERIC_OR_STRING_BINARY_OPERATORS = new Set([
	&quot;+&quot;,
	&quot;-&quot;,
	&quot;*&quot;,
	&quot;/&quot;,
	&quot;%&quot;,
	&quot;|&quot;,
	&quot;^&quot;,
	&quot;&amp;&quot;,
	&quot;**&quot;,
	&quot;&lt;&lt;&quot;,
	&quot;&gt;&gt;&quot;,
	&quot;&gt;&gt;&gt;&quot;,
]);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a node is `null` or `undefined`. Similar to the one
 * found in ast-utils.js, but this one correctly handles the edge case that
 * `undefined` has been redefined.
 * @param {Scope} scope Scope in which the expression was found.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} Whether or not the node is a `null` or `undefined`.
 * @public
 */
function isNullOrUndefined(scope, node) {
	return (
		isNullLiteral(node) ||
		(node.type === &quot;Identifier&quot; &amp;&amp;
			node.name === &quot;undefined&quot; &amp;&amp;
			isReferenceToGlobalVariable(scope, node)) ||
		(node.type === &quot;UnaryExpression&quot; &amp;&amp; node.operator === &quot;void&quot;)
	);
}

/**
 * Test if an AST node has a statically knowable constant nullishness. Meaning,
 * it will always resolve to a constant value of either: `null`, `undefined`
 * or not `null` _or_ `undefined`. An expression that can vary between those
 * three states at runtime would return `false`.
 * @param {Scope} scope The scope in which the node was found.
 * @param {ASTNode} node The AST node being tested.
 * @param {boolean} nonNullish if `true` then nullish values are not considered constant.
 * @returns {boolean} Does `node` have constant nullishness?
 */
function hasConstantNullishness(scope, node, nonNullish) {
	if (nonNullish &amp;&amp; isNullOrUndefined(scope, node)) {
		return false;
	}

	switch (node.type) {
		case &quot;ObjectExpression&quot;: // Objects are never nullish
		case &quot;ArrayExpression&quot;: // Arrays are never nullish
		case &quot;ArrowFunctionExpression&quot;: // Functions never nullish
		case &quot;FunctionExpression&quot;: // Functions are never nullish
		case &quot;ClassExpression&quot;: // Classes are never nullish
		case &quot;NewExpression&quot;: // Objects are never nullish
		case &quot;Literal&quot;: // Nullish, or non-nullish, literals never change
		case &quot;TemplateLiteral&quot;: // A string is never nullish
		case &quot;UpdateExpression&quot;: // Numbers are never nullish
		case &quot;BinaryExpression&quot;: // Numbers, strings, or booleans are never nullish
			return true;
		case &quot;CallExpression&quot;: {
			if (node.callee.type !== &quot;Identifier&quot;) {
				return false;
			}
			const functionName = node.callee.name;

			return (
				(functionName === &quot;Boolean&quot; ||
					functionName === &quot;String&quot; ||
					functionName === &quot;Number&quot;) &amp;&amp;
				isReferenceToGlobalVariable(scope, node.callee)
			);
		}
		case &quot;LogicalExpression&quot;: {
			return (
				node.operator === &quot;??&quot; &amp;&amp;
				hasConstantNullishness(scope, node.right, true)
			);
		}
		case &quot;AssignmentExpression&quot;:
			if (node.operator === &quot;=&quot;) {
				return hasConstantNullishness(scope, node.right, nonNullish);
			}

			/*
			 * Handling short-circuiting assignment operators would require
			 * walking the scope. We won&#039;t attempt that (for now...) /
			 */
			if (isLogicalAssignmentOperator(node.operator)) {
				return false;
			}

			/*
			 * The remaining assignment expressions all result in a numeric or
			 * string (non-nullish) value:
			 *   &quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;&lt;&lt;=&quot;, &quot;&gt;&gt;=&quot;, &quot;&gt;&gt;&gt;=&quot;, &quot;|=&quot;, &quot;^=&quot;, &quot;&amp;=&quot;
			 */

			return true;
		case &quot;UnaryExpression&quot;:
			/*
			 * &quot;void&quot; Always returns `undefined`
			 * &quot;typeof&quot; All types are strings, and thus non-nullish
			 * &quot;!&quot; Boolean is never nullish
			 * &quot;delete&quot; Returns a boolean, which is never nullish
			 * Math operators always return numbers or strings, neither of which
			 * are non-nullish &quot;+&quot;, &quot;-&quot;, &quot;~&quot;
			 */

			return true;
		case &quot;SequenceExpression&quot;: {
			const last = node.expressions.at(-1);

			return hasConstantNullishness(scope, last, nonNullish);
		}
		case &quot;Identifier&quot;:
			return (
				node.name === &quot;undefined&quot; &amp;&amp;
				isReferenceToGlobalVariable(scope, node)
			);
		case &quot;JSXElement&quot;: // ESLint has a policy of not assuming any specific JSX behavior.
		case &quot;JSXFragment&quot;:
			return false;
		default:
			return false;
	}
}

/**
 * Test if an AST node is a boolean value that never changes. Specifically we
 * test for:
 * 1. Literal booleans (`true` or `false`)
 * 2. Unary `!` expressions with a constant value
 * 3. Constant booleans created via the `Boolean` global function
 * @param {Scope} scope The scope in which the node was found.
 * @param {ASTNode} node The node to test
 * @returns {boolean} Is `node` guaranteed to be a boolean?
 */
function isStaticBoolean(scope, node) {
	switch (node.type) {
		case &quot;Literal&quot;:
			return typeof node.value === &quot;boolean&quot;;
		case &quot;CallExpression&quot;:
			return (
				node.callee.type === &quot;Identifier&quot; &amp;&amp;
				node.callee.name === &quot;Boolean&quot; &amp;&amp;
				isReferenceToGlobalVariable(scope, node.callee) &amp;&amp;
				(node.arguments.length === 0 ||
					isConstant(scope, node.arguments[0], true))
			);
		case &quot;UnaryExpression&quot;:
			return (
				node.operator === &quot;!&quot; &amp;&amp; isConstant(scope, node.argument, true)
			);
		default:
			return false;
	}
}

/**
 * Test if an AST node will always give the same result when compared to a
 * boolean value. Note that comparison to boolean values is different than
 * truthiness.
 * https://262.ecma-international.org/5.1/#sec-11.9.3
 *
 * JavaScript `==` operator works by converting the boolean to `1` (true) or
 * `+0` (false) and then checks the values `==` equality to that number.
 * @param {Scope} scope The scope in which node was found.
 * @param {ASTNode} node The node to test.
 * @returns {boolean} Will `node` always coerce to the same boolean value?
 */
function hasConstantLooseBooleanComparison(scope, node) {
	switch (node.type) {
		case &quot;ObjectExpression&quot;:
		case &quot;ClassExpression&quot;:
			/**
			 * In theory objects like:
			 *
			 * `{toString: () =&gt; a}`
			 * `{valueOf: () =&gt; a}`
			 *
			 * Or a classes like:
			 *
			 * `class { static toString() { return a } }`
			 * `class { static valueOf() { return a } }`
			 *
			 * Are not constant verifiably when `inBooleanPosition` is
			 * false, but it&#039;s an edge case we&#039;ve opted not to handle.
			 */
			return true;
		case &quot;ArrayExpression&quot;: {
			const nonSpreadElements = node.elements.filter(
				e =&gt;
					// Elements can be `null` in sparse arrays: `[,,]`;
					e !== null &amp;&amp; e.type !== &quot;SpreadElement&quot;,
			);

			/*
			 * Possible future direction if needed: We could check if the
			 * single value would result in variable boolean comparison.
			 * For now we will err on the side of caution since `[x]` could
			 * evaluate to `[0]` or `[1]`.
			 */
			return node.elements.length === 0 || nonSpreadElements.length &gt; 1;
		}
		case &quot;ArrowFunctionExpression&quot;:
		case &quot;FunctionExpression&quot;:
			return true;
		case &quot;UnaryExpression&quot;:
			if (
				node.operator === &quot;void&quot; || // Always returns `undefined`
				node.operator === &quot;typeof&quot; // All `typeof` strings, when coerced to number, are not 0 or 1.
			) {
				return true;
			}
			if (node.operator === &quot;!&quot;) {
				return isConstant(scope, node.argument, true);
			}

			/*
			 * We won&#039;t try to reason about +, -, ~, or delete
			 * In theory, for the mathematical operators, we could look at the
			 * argument and try to determine if it coerces to a constant numeric
			 * value.
			 */
			return false;
		case &quot;NewExpression&quot;: // Objects might have custom `.valueOf` or `.toString`.
			return false;
		case &quot;CallExpression&quot;: {
			if (
				node.callee.type === &quot;Identifier&quot; &amp;&amp;
				node.callee.name === &quot;Boolean&quot; &amp;&amp;
				isReferenceToGlobalVariable(scope, node.callee)
			) {
				return (
					node.arguments.length === 0 ||
					isConstant(scope, node.arguments[0], true)
				);
			}
			return false;
		}
		case &quot;Literal&quot;: // True or false, literals never change
			return true;
		case &quot;Identifier&quot;:
			return (
				node.name === &quot;undefined&quot; &amp;&amp;
				isReferenceToGlobalVariable(scope, node)
			);
		case &quot;TemplateLiteral&quot;:
			/*
			 * In theory we could try to check if the quasi are sufficient to
			 * prove that the expression will always be true, but it would be
			 * tricky to get right. For example: `000.${foo}000`
			 */
			return node.expressions.length === 0;
		case &quot;AssignmentExpression&quot;:
			if (node.operator === &quot;=&quot;) {
				return hasConstantLooseBooleanComparison(scope, node.right);
			}

			/*
			 * Handling short-circuiting assignment operators would require
			 * walking the scope. We won&#039;t attempt that (for now...)
			 *
			 * The remaining assignment expressions all result in a numeric or
			 * string (non-nullish) values which could be truthy or falsy:
			 *   &quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;&lt;&lt;=&quot;, &quot;&gt;&gt;=&quot;, &quot;&gt;&gt;&gt;=&quot;, &quot;|=&quot;, &quot;^=&quot;, &quot;&amp;=&quot;
			 */
			return false;
		case &quot;SequenceExpression&quot;: {
			const last = node.expressions.at(-1);

			return hasConstantLooseBooleanComparison(scope, last);
		}
		case &quot;JSXElement&quot;: // ESLint has a policy of not assuming any specific JSX behavior.
		case &quot;JSXFragment&quot;:
			return false;
		default:
			return false;
	}
}

/**
 * Test if an AST node will always give the same result when _strictly_ compared
 * to a boolean value. This can happen if the expression can never be boolean, or
 * if it is always the same boolean value.
 * @param {Scope} scope The scope in which the node was found.
 * @param {ASTNode} node The node to test
 * @returns {boolean} Will `node` always give the same result when compared to a
 * static boolean value?
 */
function hasConstantStrictBooleanComparison(scope, node) {
	switch (node.type) {
		case &quot;ObjectExpression&quot;: // Objects are not booleans
		case &quot;ArrayExpression&quot;: // Arrays are not booleans
		case &quot;ArrowFunctionExpression&quot;: // Functions are not booleans
		case &quot;FunctionExpression&quot;:
		case &quot;ClassExpression&quot;: // Classes are not booleans
		case &quot;NewExpression&quot;: // Objects are not booleans
		case &quot;TemplateLiteral&quot;: // Strings are not booleans
		case &quot;Literal&quot;: // True, false, or not boolean, literals never change.
		case &quot;UpdateExpression&quot;: // Numbers are not booleans
			return true;
		case &quot;BinaryExpression&quot;:
			return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);
		case &quot;UnaryExpression&quot;: {
			if (node.operator === &quot;delete&quot;) {
				return false;
			}
			if (node.operator === &quot;!&quot;) {
				return isConstant(scope, node.argument, true);
			}

			/*
			 * The remaining operators return either strings or numbers, neither
			 * of which are boolean.
			 */
			return true;
		}
		case &quot;SequenceExpression&quot;: {
			const last = node.expressions.at(-1);

			return hasConstantStrictBooleanComparison(scope, last);
		}
		case &quot;Identifier&quot;:
			return (
				node.name === &quot;undefined&quot; &amp;&amp;
				isReferenceToGlobalVariable(scope, node)
			);
		case &quot;AssignmentExpression&quot;:
			if (node.operator === &quot;=&quot;) {
				return hasConstantStrictBooleanComparison(scope, node.right);
			}

			/*
			 * Handling short-circuiting assignment operators would require
			 * walking the scope. We won&#039;t attempt that (for now...)
			 */
			if (isLogicalAssignmentOperator(node.operator)) {
				return false;
			}

			/*
			 * The remaining assignment expressions all result in either a number
			 * or a string, neither of which can ever be boolean.
			 */
			return true;
		case &quot;CallExpression&quot;: {
			if (node.callee.type !== &quot;Identifier&quot;) {
				return false;
			}
			const functionName = node.callee.name;

			if (
				(functionName === &quot;String&quot; || functionName === &quot;Number&quot;) &amp;&amp;
				isReferenceToGlobalVariable(scope, node.callee)
			) {
				return true;
			}
			if (
				functionName === &quot;Boolean&quot; &amp;&amp;
				isReferenceToGlobalVariable(scope, node.callee)
			) {
				return (
					node.arguments.length === 0 ||
					isConstant(scope, node.arguments[0], true)
				);
			}
			return false;
		}
		case &quot;JSXElement&quot;: // ESLint has a policy of not assuming any specific JSX behavior.
		case &quot;JSXFragment&quot;:
			return false;
		default:
			return false;
	}
}

/**
 * Test if an AST node will always result in a newly constructed object
 * @param {Scope} scope The scope in which the node was found.
 * @param {ASTNode} node The node to test
 * @returns {boolean} Will `node` always be new?
 */
function isAlwaysNew(scope, node) {
	switch (node.type) {
		case &quot;ObjectExpression&quot;:
		case &quot;ArrayExpression&quot;:
		case &quot;ArrowFunctionExpression&quot;:
		case &quot;FunctionExpression&quot;:
		case &quot;ClassExpression&quot;:
			return true;
		case &quot;NewExpression&quot;: {
			if (node.callee.type !== &quot;Identifier&quot;) {
				return false;
			}

			/*
			 * All the built-in constructors are always new, but
			 * user-defined constructors could return a sentinel
			 * object.
			 *
			 * Catching these is especially useful for primitive constructors
			 * which return boxed values, a surprising gotcha&#039; in JavaScript.
			 */
			return (
				Object.hasOwn(ECMASCRIPT_GLOBALS, node.callee.name) &amp;&amp;
				isReferenceToGlobalVariable(scope, node.callee)
			);
		}
		case &quot;Literal&quot;:
			// Regular expressions are objects, and thus always new
			return typeof node.regex === &quot;object&quot;;
		case &quot;SequenceExpression&quot;: {
			const last = node.expressions.at(-1);

			return isAlwaysNew(scope, last);
		}
		case &quot;AssignmentExpression&quot;:
			if (node.operator === &quot;=&quot;) {
				return isAlwaysNew(scope, node.right);
			}
			return false;
		case &quot;ConditionalExpression&quot;:
			return (
				isAlwaysNew(scope, node.consequent) &amp;&amp;
				isAlwaysNew(scope, node.alternate)
			);
		case &quot;JSXElement&quot;: // ESLint has a policy of not assuming any specific JSX behavior.
		case &quot;JSXFragment&quot;:
			return false;
		default:
			return false;
	}
}

/**
 * Checks if one operand will cause the result to be constant.
 * @param {Scope} scope Scope in which the expression was found.
 * @param {ASTNode} a One side of the expression
 * @param {ASTNode} b The other side of the expression
 * @param {string} operator The binary expression operator
 * @returns {ASTNode | null} The node which will cause the expression to have a constant result.
 */
function findBinaryExpressionConstantOperand(scope, a, b, operator) {
	if (operator === &quot;==&quot; || operator === &quot;!=&quot;) {
		if (
			(isNullOrUndefined(scope, a) &amp;&amp;
				hasConstantNullishness(scope, b, false)) ||
			(isStaticBoolean(scope, a) &amp;&amp;
				hasConstantLooseBooleanComparison(scope, b))
		) {
			return b;
		}
	} else if (operator === &quot;===&quot; || operator === &quot;!==&quot;) {
		if (
			(isNullOrUndefined(scope, a) &amp;&amp;
				hasConstantNullishness(scope, b, false)) ||
			(isStaticBoolean(scope, a) &amp;&amp;
				hasConstantStrictBooleanComparison(scope, b))
		) {
			return b;
		}
	}
	return null;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;problem&quot;,
		docs: {
			description:
				&quot;Disallow expressions where the operation doesn&#039;t affect the value&quot;,
			recommended: true,
			url: &quot;https://eslint.org/docs/latest/rules/no-constant-binary-expression&quot;,
		},
		schema: [],
		messages: {
			constantBinaryOperand:
				&quot;Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.&quot;,
			constantShortCircuit:
				&quot;Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.&quot;,
			alwaysNew:
				&quot;Unexpected comparison to newly constructed object. These two values can never be equal.&quot;,
			bothAlwaysNew:
				&quot;Unexpected comparison of two newly constructed objects. These two values can never be equal.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		return {
			LogicalExpression(node) {
				const { operator, left } = node;
				const scope = sourceCode.getScope(node);

				if (
					(operator === &quot;&amp;&amp;&quot; || operator === &quot;||&quot;) &amp;&amp;
					isConstant(scope, left, true)
				) {
					context.report({
						node: left,
						messageId: &quot;constantShortCircuit&quot;,
						data: { property: &quot;truthiness&quot;, operator },
					});
				} else if (
					operator === &quot;??&quot; &amp;&amp;
					hasConstantNullishness(scope, left, false)
				) {
					context.report({
						node: left,
						messageId: &quot;constantShortCircuit&quot;,
						data: { property: &quot;nullishness&quot;, operator },
					});
				}
			},
			BinaryExpression(node) {
				const scope = sourceCode.getScope(node);
				const { right, left, operator } = node;
				const rightConstantOperand =
					findBinaryExpressionConstantOperand(
						scope,
						left,
						right,
						operator,
					);
				const leftConstantOperand = findBinaryExpressionConstantOperand(
					scope,
					right,
					left,
					operator,
				);

				if (rightConstantOperand) {
					context.report({
						node: rightConstantOperand,
						messageId: &quot;constantBinaryOperand&quot;,
						data: { operator, otherSide: &quot;left&quot; },
					});
				} else if (leftConstantOperand) {
					context.report({
						node: leftConstantOperand,
						messageId: &quot;constantBinaryOperand&quot;,
						data: { operator, otherSide: &quot;right&quot; },
					});
				} else if (operator === &quot;===&quot; || operator === &quot;!==&quot;) {
					if (isAlwaysNew(scope, left)) {
						context.report({ node: left, messageId: &quot;alwaysNew&quot; });
					} else if (isAlwaysNew(scope, right)) {
						context.report({ node: right, messageId: &quot;alwaysNew&quot; });
					}
				} else if (operator === &quot;==&quot; || operator === &quot;!=&quot;) {
					/*
					 * If both sides are &quot;new&quot;, then both sides are objects and
					 * therefore they will be compared by reference even with `==`
					 * equality.
					 */
					if (isAlwaysNew(scope, left) &amp;&amp; isAlwaysNew(scope, right)) {
						context.report({
							node: left,
							messageId: &quot;bothAlwaysNew&quot;,
						});
					}
				}
			},

			/*
			 * In theory we could handle short-circuiting assignment operators,
			 * for some constant values, but that would require walking the
			 * scope to find the value of the variable being assigned. This is
			 * dependent on https://github.com/eslint/eslint/issues/13776
			 *
			 * AssignmentExpression() {},
			 */
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
