<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/key-spacing.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/key-spacing.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">823</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">76.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.58</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to specify spacing of object literal keys and values
 * @author Brandon Mills
 * @deprecated in ESLint v8.53.0
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);
const { getGraphemeCount } = require(&quot;../shared/string-utils&quot;);

/**
 * Checks whether a string contains a line terminator as defined in
 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
 * @param {string} str String to test.
 * @returns {boolean} True if str contains a line terminator.
 */
function containsLineTerminator(str) {
	return astUtils.LINEBREAK_MATCHER.test(str);
}

/**
 * Gets the last element of an array.
 * @param {Array} arr An array.
 * @returns {any} Last element of arr.
 */
function last(arr) {
	return arr.at(-1);
}

/**
 * Checks whether a node is contained on a single line.
 * @param {ASTNode} node AST Node being evaluated.
 * @returns {boolean} True if the node is a single line.
 */
function isSingleLine(node) {
	return node.loc.end.line === node.loc.start.line;
}

/**
 * Checks whether the properties on a single line.
 * @param {ASTNode[]} properties List of Property AST nodes.
 * @returns {boolean} True if all properties is on a single line.
 */
function isSingleLineProperties(properties) {
	const [firstProp] = properties,
		lastProp = last(properties);

	return firstProp.loc.start.line === lastProp.loc.end.line;
}

/**
 * Initializes a single option property from the configuration with defaults for undefined values
 * @param {Object} toOptions Object to be initialized
 * @param {Object} fromOptions Object to be initialized from
 * @returns {Object} The object with correctly initialized options and values
 */
function initOptionProperty(toOptions, fromOptions) {
	toOptions.mode = fromOptions.mode || &quot;strict&quot;;

	// Set value of beforeColon
	if (typeof fromOptions.beforeColon !== &quot;undefined&quot;) {
		toOptions.beforeColon = +fromOptions.beforeColon;
	} else {
		toOptions.beforeColon = 0;
	}

	// Set value of afterColon
	if (typeof fromOptions.afterColon !== &quot;undefined&quot;) {
		toOptions.afterColon = +fromOptions.afterColon;
	} else {
		toOptions.afterColon = 1;
	}

	// Set align if exists
	if (typeof fromOptions.align !== &quot;undefined&quot;) {
		if (typeof fromOptions.align === &quot;object&quot;) {
			toOptions.align = fromOptions.align;
		} else {
			// &quot;string&quot;
			toOptions.align = {
				on: fromOptions.align,
				mode: toOptions.mode,
				beforeColon: toOptions.beforeColon,
				afterColon: toOptions.afterColon,
			};
		}
	}

	return toOptions;
}

/**
 * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values
 * @param {Object} toOptions Object to be initialized
 * @param {Object} fromOptions Object to be initialized from
 * @returns {Object} The object with correctly initialized options and values
 */
function initOptions(toOptions, fromOptions) {
	if (typeof fromOptions.align === &quot;object&quot;) {
		// Initialize the alignment configuration
		toOptions.align = initOptionProperty({}, fromOptions.align);
		toOptions.align.on = fromOptions.align.on || &quot;colon&quot;;
		toOptions.align.mode = fromOptions.align.mode || &quot;strict&quot;;

		toOptions.multiLine = initOptionProperty(
			{},
			fromOptions.multiLine || fromOptions,
		);
		toOptions.singleLine = initOptionProperty(
			{},
			fromOptions.singleLine || fromOptions,
		);
	} else {
		// string or undefined
		toOptions.multiLine = initOptionProperty(
			{},
			fromOptions.multiLine || fromOptions,
		);
		toOptions.singleLine = initOptionProperty(
			{},
			fromOptions.singleLine || fromOptions,
		);

		// If alignment options are defined in multiLine, pull them out into the general align configuration
		if (toOptions.multiLine.align) {
			toOptions.align = {
				on: toOptions.multiLine.align.on,
				mode:
					toOptions.multiLine.align.mode || toOptions.multiLine.mode,
				beforeColon: toOptions.multiLine.align.beforeColon,
				afterColon: toOptions.multiLine.align.afterColon,
			};
		}
	}

	return toOptions;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin&quot;,
						url: &quot;https://eslint.style&quot;,
					},
					rule: {
						name: &quot;key-spacing&quot;,
						url: &quot;https://eslint.style/rules/key-spacing&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description:
				&quot;Enforce consistent spacing between keys and values in object literal properties&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/key-spacing&quot;,
		},

		fixable: &quot;whitespace&quot;,

		schema: [
			{
				anyOf: [
					{
						type: &quot;object&quot;,
						properties: {
							align: {
								anyOf: [
									{
										enum: [&quot;colon&quot;, &quot;value&quot;],
									},
									{
										type: &quot;object&quot;,
										properties: {
											mode: {
												enum: [&quot;strict&quot;, &quot;minimum&quot;],
											},
											on: {
												enum: [&quot;colon&quot;, &quot;value&quot;],
											},
											beforeColon: {
												type: &quot;boolean&quot;,
											},
											afterColon: {
												type: &quot;boolean&quot;,
											},
										},
										additionalProperties: false,
									},
								],
							},
							mode: {
								enum: [&quot;strict&quot;, &quot;minimum&quot;],
							},
							beforeColon: {
								type: &quot;boolean&quot;,
							},
							afterColon: {
								type: &quot;boolean&quot;,
							},
						},
						additionalProperties: false,
					},
					{
						type: &quot;object&quot;,
						properties: {
							singleLine: {
								type: &quot;object&quot;,
								properties: {
									mode: {
										enum: [&quot;strict&quot;, &quot;minimum&quot;],
									},
									beforeColon: {
										type: &quot;boolean&quot;,
									},
									afterColon: {
										type: &quot;boolean&quot;,
									},
								},
								additionalProperties: false,
							},
							multiLine: {
								type: &quot;object&quot;,
								properties: {
									align: {
										anyOf: [
											{
												enum: [&quot;colon&quot;, &quot;value&quot;],
											},
											{
												type: &quot;object&quot;,
												properties: {
													mode: {
														enum: [
															&quot;strict&quot;,
															&quot;minimum&quot;,
														],
													},
													on: {
														enum: [
															&quot;colon&quot;,
															&quot;value&quot;,
														],
													},
													beforeColon: {
														type: &quot;boolean&quot;,
													},
													afterColon: {
														type: &quot;boolean&quot;,
													},
												},
												additionalProperties: false,
											},
										],
									},
									mode: {
										enum: [&quot;strict&quot;, &quot;minimum&quot;],
									},
									beforeColon: {
										type: &quot;boolean&quot;,
									},
									afterColon: {
										type: &quot;boolean&quot;,
									},
								},
								additionalProperties: false,
							},
						},
						additionalProperties: false,
					},
					{
						type: &quot;object&quot;,
						properties: {
							singleLine: {
								type: &quot;object&quot;,
								properties: {
									mode: {
										enum: [&quot;strict&quot;, &quot;minimum&quot;],
									},
									beforeColon: {
										type: &quot;boolean&quot;,
									},
									afterColon: {
										type: &quot;boolean&quot;,
									},
								},
								additionalProperties: false,
							},
							multiLine: {
								type: &quot;object&quot;,
								properties: {
									mode: {
										enum: [&quot;strict&quot;, &quot;minimum&quot;],
									},
									beforeColon: {
										type: &quot;boolean&quot;,
									},
									afterColon: {
										type: &quot;boolean&quot;,
									},
								},
								additionalProperties: false,
							},
							align: {
								type: &quot;object&quot;,
								properties: {
									mode: {
										enum: [&quot;strict&quot;, &quot;minimum&quot;],
									},
									on: {
										enum: [&quot;colon&quot;, &quot;value&quot;],
									},
									beforeColon: {
										type: &quot;boolean&quot;,
									},
									afterColon: {
										type: &quot;boolean&quot;,
									},
								},
								additionalProperties: false,
							},
						},
						additionalProperties: false,
					},
				],
			},
		],
		messages: {
			extraKey: &quot;Extra space after {{computed}}key &#039;{{key}}&#039;.&quot;,
			extraValue:
				&quot;Extra space before value for {{computed}}key &#039;{{key}}&#039;.&quot;,
			missingKey: &quot;Missing space after {{computed}}key &#039;{{key}}&#039;.&quot;,
			missingValue:
				&quot;Missing space before value for {{computed}}key &#039;{{key}}&#039;.&quot;,
		},
	},

	create(context) {
		/**
		 * OPTIONS
		 * &quot;key-spacing&quot;: [2, {
		 *     beforeColon: false,
		 *     afterColon: true,
		 *     align: &quot;colon&quot; // Optional, or &quot;value&quot;
		 * }
		 */
		const options = context.options[0] || {},
			ruleOptions = initOptions({}, options),
			multiLineOptions = ruleOptions.multiLine,
			singleLineOptions = ruleOptions.singleLine,
			alignmentOptions = ruleOptions.align || null;

		const sourceCode = context.sourceCode;

		/**
		 * Determines if the given property is key-value property.
		 * @param {ASTNode} property Property node to check.
		 * @returns {boolean} Whether the property is a key-value property.
		 */
		function isKeyValueProperty(property) {
			return !(
				(
					property.method ||
					property.shorthand ||
					property.kind !== &quot;init&quot; ||
					property.type !== &quot;Property&quot;
				) // Could be &quot;ExperimentalSpreadProperty&quot; or &quot;SpreadElement&quot;
			);
		}

		/**
		 * Starting from the given node (a property.key node here) looks forward
		 * until it finds the colon punctuator and returns it.
		 * @param {ASTNode} node The node to start looking from.
		 * @returns {ASTNode} The colon punctuator.
		 */
		function getNextColon(node) {
			return sourceCode.getTokenAfter(node, astUtils.isColonToken);
		}

		/**
		 * Starting from the given node (a property.key node here) looks forward
		 * until it finds the last token before a colon punctuator and returns it.
		 * @param {ASTNode} node The node to start looking from.
		 * @returns {ASTNode} The last token before a colon punctuator.
		 */
		function getLastTokenBeforeColon(node) {
			const colonToken = getNextColon(node);

			return sourceCode.getTokenBefore(colonToken);
		}

		/**
		 * Starting from the given node (a property.key node here) looks forward
		 * until it finds the first token after a colon punctuator and returns it.
		 * @param {ASTNode} node The node to start looking from.
		 * @returns {ASTNode} The first token after a colon punctuator.
		 */
		function getFirstTokenAfterColon(node) {
			const colonToken = getNextColon(node);

			return sourceCode.getTokenAfter(colonToken);
		}

		/**
		 * Checks whether a property is a member of the property group it follows.
		 * @param {ASTNode} lastMember The last Property known to be in the group.
		 * @param {ASTNode} candidate The next Property that might be in the group.
		 * @returns {boolean} True if the candidate property is part of the group.
		 */
		function continuesPropertyGroup(lastMember, candidate) {
			const groupEndLine = lastMember.loc.start.line,
				candidateValueStartLine = (
					isKeyValueProperty(candidate)
						? getFirstTokenAfterColon(candidate.key)
						: candidate
				).loc.start.line;

			if (candidateValueStartLine - groupEndLine &lt;= 1) {
				return true;
			}

			/*
			 * Check that the first comment is adjacent to the end of the group, the
			 * last comment is adjacent to the candidate property, and that successive
			 * comments are adjacent to each other.
			 */
			const leadingComments = sourceCode.getCommentsBefore(candidate);

			if (
				leadingComments.length &amp;&amp;
				leadingComments[0].loc.start.line - groupEndLine &lt;= 1 &amp;&amp;
				candidateValueStartLine - last(leadingComments).loc.end.line &lt;=
					1
			) {
				for (let i = 1; i &lt; leadingComments.length; i++) {
					if (
						leadingComments[i].loc.start.line -
							leadingComments[i - 1].loc.end.line &gt;
						1
					) {
						return false;
					}
				}
				return true;
			}

			return false;
		}

		/**
		 * Gets an object literal property&#039;s key as the identifier name or string value.
		 * @param {ASTNode} property Property node whose key to retrieve.
		 * @returns {string} The property&#039;s key.
		 */
		function getKey(property) {
			const key = property.key;

			if (property.computed) {
				return sourceCode.getText().slice(key.range[0], key.range[1]);
			}
			return astUtils.getStaticPropertyName(property);
		}

		/**
		 * Reports an appropriately-formatted error if spacing is incorrect on one
		 * side of the colon.
		 * @param {ASTNode} property Key-value pair in an object literal.
		 * @param {string} side Side being verified - either &quot;key&quot; or &quot;value&quot;.
		 * @param {string} whitespace Actual whitespace string.
		 * @param {number} expected Expected whitespace length.
		 * @param {string} mode Value of the mode as &quot;strict&quot; or &quot;minimum&quot;
		 * @returns {void}
		 */
		function report(property, side, whitespace, expected, mode) {
			const diff = whitespace.length - expected;

			if (
				((diff &amp;&amp; mode === &quot;strict&quot;) ||
					(diff &lt; 0 &amp;&amp; mode === &quot;minimum&quot;) ||
					(diff &gt; 0 &amp;&amp; !expected &amp;&amp; mode === &quot;minimum&quot;)) &amp;&amp;
				!(expected &amp;&amp; containsLineTerminator(whitespace))
			) {
				const nextColon = getNextColon(property.key),
					tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {
						includeComments: true,
					}),
					tokenAfterColon = sourceCode.getTokenAfter(nextColon, {
						includeComments: true,
					}),
					isKeySide = side === &quot;key&quot;,
					isExtra = diff &gt; 0,
					diffAbs = Math.abs(diff),
					spaces = Array(diffAbs + 1).join(&quot; &quot;);

				const locStart = isKeySide
					? tokenBeforeColon.loc.end
					: nextColon.loc.start;
				const locEnd = isKeySide
					? nextColon.loc.start
					: tokenAfterColon.loc.start;
				const missingLoc = isKeySide
					? tokenBeforeColon.loc
					: tokenAfterColon.loc;
				const loc = isExtra
					? { start: locStart, end: locEnd }
					: missingLoc;

				let fix;

				if (isExtra) {
					let range;

					// Remove whitespace
					if (isKeySide) {
						range = [
							tokenBeforeColon.range[1],
							tokenBeforeColon.range[1] + diffAbs,
						];
					} else {
						range = [
							tokenAfterColon.range[0] - diffAbs,
							tokenAfterColon.range[0],
						];
					}
					fix = function (fixer) {
						return fixer.removeRange(range);
					};
				} else {
					// Add whitespace
					if (isKeySide) {
						fix = function (fixer) {
							return fixer.insertTextAfter(
								tokenBeforeColon,
								spaces,
							);
						};
					} else {
						fix = function (fixer) {
							return fixer.insertTextBefore(
								tokenAfterColon,
								spaces,
							);
						};
					}
				}

				let messageId;

				if (isExtra) {
					messageId = side === &quot;key&quot; ? &quot;extraKey&quot; : &quot;extraValue&quot;;
				} else {
					messageId = side === &quot;key&quot; ? &quot;missingKey&quot; : &quot;missingValue&quot;;
				}

				context.report({
					node: property[side],
					loc,
					messageId,
					data: {
						computed: property.computed ? &quot;computed &quot; : &quot;&quot;,
						key: getKey(property),
					},
					fix,
				});
			}
		}

		/**
		 * Gets the number of characters in a key, including quotes around string
		 * keys and braces around computed property keys.
		 * @param {ASTNode} property Property of on object literal.
		 * @returns {number} Width of the key.
		 */
		function getKeyWidth(property) {
			const startToken = sourceCode.getFirstToken(property);
			const endToken = getLastTokenBeforeColon(property.key);

			return getGraphemeCount(
				sourceCode
					.getText()
					.slice(startToken.range[0], endToken.range[1]),
			);
		}

		/**
		 * Gets the whitespace around the colon in an object literal property.
		 * @param {ASTNode} property Property node from an object literal.
		 * @returns {Object} Whitespace before and after the property&#039;s colon.
		 */
		function getPropertyWhitespace(property) {
			const whitespace = /(\s*):(\s*)/u.exec(
				sourceCode
					.getText()
					.slice(property.key.range[1], property.value.range[0]),
			);

			if (whitespace) {
				return {
					beforeColon: whitespace[1],
					afterColon: whitespace[2],
				};
			}
			return null;
		}

		/**
		 * Creates groups of properties.
		 * @param {ASTNode} node ObjectExpression node being evaluated.
		 * @returns {Array&lt;ASTNode[]&gt;} Groups of property AST node lists.
		 */
		function createGroups(node) {
			if (node.properties.length === 1) {
				return [node.properties];
			}

			return node.properties.reduce(
				(groups, property) =&gt; {
					const currentGroup = last(groups),
						prev = last(currentGroup);

					if (!prev || continuesPropertyGroup(prev, property)) {
						currentGroup.push(property);
					} else {
						groups.push([property]);
					}

					return groups;
				},
				[[]],
			);
		}

		/**
		 * Verifies correct vertical alignment of a group of properties.
		 * @param {ASTNode[]} properties List of Property AST nodes.
		 * @returns {void}
		 */
		function verifyGroupAlignment(properties) {
			const length = properties.length,
				widths = properties.map(getKeyWidth), // Width of keys, including quotes
				align = alignmentOptions.on; // &quot;value&quot; or &quot;colon&quot;
			let targetWidth = Math.max(...widths),
				beforeColon,
				afterColon,
				mode;

			if (alignmentOptions &amp;&amp; length &gt; 1) {
				// When aligning values within a group, use the alignment configuration.
				beforeColon = alignmentOptions.beforeColon;
				afterColon = alignmentOptions.afterColon;
				mode = alignmentOptions.mode;
			} else {
				beforeColon = multiLineOptions.beforeColon;
				afterColon = multiLineOptions.afterColon;
				mode = alignmentOptions.mode;
			}

			// Conditionally include one space before or after colon
			targetWidth += align === &quot;colon&quot; ? beforeColon : afterColon;

			for (let i = 0; i &lt; length; i++) {
				const property = properties[i];
				const whitespace = getPropertyWhitespace(property);

				if (whitespace) {
					// Object literal getters/setters lack a colon
					const width = widths[i];

					if (align === &quot;value&quot;) {
						report(
							property,
							&quot;key&quot;,
							whitespace.beforeColon,
							beforeColon,
							mode,
						);
						report(
							property,
							&quot;value&quot;,
							whitespace.afterColon,
							targetWidth - width,
							mode,
						);
					} else {
						// align = &quot;colon&quot;
						report(
							property,
							&quot;key&quot;,
							whitespace.beforeColon,
							targetWidth - width,
							mode,
						);
						report(
							property,
							&quot;value&quot;,
							whitespace.afterColon,
							afterColon,
							mode,
						);
					}
				}
			}
		}

		/**
		 * Verifies spacing of property conforms to specified options.
		 * @param {ASTNode} node Property node being evaluated.
		 * @param {Object} lineOptions Configured singleLine or multiLine options
		 * @returns {void}
		 */
		function verifySpacing(node, lineOptions) {
			const actual = getPropertyWhitespace(node);

			if (actual) {
				// Object literal getters/setters lack colons
				report(
					node,
					&quot;key&quot;,
					actual.beforeColon,
					lineOptions.beforeColon,
					lineOptions.mode,
				);
				report(
					node,
					&quot;value&quot;,
					actual.afterColon,
					lineOptions.afterColon,
					lineOptions.mode,
				);
			}
		}

		/**
		 * Verifies spacing of each property in a list.
		 * @param {ASTNode[]} properties List of Property AST nodes.
		 * @param {Object} lineOptions Configured singleLine or multiLine options
		 * @returns {void}
		 */
		function verifyListSpacing(properties, lineOptions) {
			const length = properties.length;

			for (let i = 0; i &lt; length; i++) {
				verifySpacing(properties[i], lineOptions);
			}
		}

		/**
		 * Verifies vertical alignment, taking into account groups of properties.
		 * @param {ASTNode} node ObjectExpression node being evaluated.
		 * @returns {void}
		 */
		function verifyAlignment(node) {
			createGroups(node).forEach(group =&gt; {
				const properties = group.filter(isKeyValueProperty);

				if (
					properties.length &gt; 0 &amp;&amp;
					isSingleLineProperties(properties)
				) {
					verifyListSpacing(properties, multiLineOptions);
				} else {
					verifyGroupAlignment(properties);
				}
			});
		}

		//--------------------------------------------------------------------------
		// Public API
		//--------------------------------------------------------------------------

		if (alignmentOptions) {
			// Verify vertical alignment

			return {
				ObjectExpression(node) {
					if (isSingleLine(node)) {
						verifyListSpacing(
							node.properties.filter(isKeyValueProperty),
							singleLineOptions,
						);
					} else {
						verifyAlignment(node);
					}
				},
			};
		}

		// Obey beforeColon and afterColon in each property as configured
		return {
			Property(node) {
				verifySpacing(
					node,
					isSingleLine(node.parent)
						? singleLineOptions
						: multiLineOptions,
				);
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
