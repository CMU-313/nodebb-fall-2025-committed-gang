<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/xregexp/lib/xregexp.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/xregexp/lib/xregexp.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.76</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1882</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">141.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.80</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

var _sliceInstanceProperty2 = require(&quot;@babel/runtime-corejs3/core-js-stable/instance/slice&quot;);
var _Array$from = require(&quot;@babel/runtime-corejs3/core-js-stable/array/from&quot;);
var _Symbol = require(&quot;@babel/runtime-corejs3/core-js-stable/symbol&quot;);
var _getIteratorMethod = require(&quot;@babel/runtime-corejs3/core-js/get-iterator-method&quot;);
var _Array$isArray = require(&quot;@babel/runtime-corejs3/core-js-stable/array/is-array&quot;);
var _Object$defineProperty = require(&quot;@babel/runtime-corejs3/core-js-stable/object/define-property&quot;);
var _interopRequireDefault = require(&quot;@babel/runtime-corejs3/helpers/interopRequireDefault&quot;);
_Object$defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports[&quot;default&quot;] = void 0;
var _slicedToArray2 = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/helpers/slicedToArray&quot;));
var _create = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/object/create&quot;));
var _flags = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/flags&quot;));
var _sort = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/sort&quot;));
var _slice = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/slice&quot;));
var _parseInt2 = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/parse-int&quot;));
var _indexOf = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/index-of&quot;));
var _forEach = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/for-each&quot;));
var _concat = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/concat&quot;));
function _createForOfIteratorHelper(r, e) { var t = &quot;undefined&quot; != typeof _Symbol &amp;&amp; _getIteratorMethod(r) || r[&quot;@@iterator&quot;]; if (!t) { if (_Array$isArray(r) || (t = _unsupportedIterableToArray(r)) || e &amp;&amp; r &amp;&amp; &quot;number&quot; == typeof r.length) { t &amp;&amp; (r = t); var _n2 = 0, F = function F() {}; return { s: F, n: function n() { return _n2 &gt;= r.length ? { done: !0 } : { done: !1, value: r[_n2++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(&quot;Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[&quot;return&quot;] || t[&quot;return&quot;](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { var _context9; if (&quot;string&quot; == typeof r) return _arrayLikeToArray(r, a); var t = _sliceInstanceProperty2(_context9 = {}.toString.call(r)).call(_context9, 8, -1); return &quot;Object&quot; === t &amp;&amp; r.constructor &amp;&amp; (t = r.constructor.name), &quot;Map&quot; === t || &quot;Set&quot; === t ? _Array$from(r) : &quot;Arguments&quot; === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a &gt; r.length) &amp;&amp; (a = r.length); for (var e = 0, n = Array(a); e &lt; a; e++) n[e] = r[e]; return n; }
/*!
 * XRegExp 5.1.2
 * &lt;xregexp.com&gt;
 * Steven Levithan (c) 2007-present MIT License
 */

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */

// ==--------------------------==
// Private stuff
// ==--------------------------==

// Property name used for extended regex instance data
var REGEX_DATA = &#039;xregexp&#039;;
// Optional features that can be installed and uninstalled
var features = {
  astral: false,
  namespacing: true
};
// Storage for fixed/extended native methods
var fixed = {};
// Storage for regexes cached by `XRegExp.cache`
var regexCache = (0, _create[&quot;default&quot;])(null);
// Storage for pattern details cached by the `XRegExp` constructor
var patternCache = (0, _create[&quot;default&quot;])(null);
// Storage for regex syntax tokens added internally or by `XRegExp.addToken`
var tokens = [];
// Token scopes
var defaultScope = &#039;default&#039;;
var classScope = &#039;class&#039;;
// Regexes that match native regex syntax, including octals
var nativeTokens = {
  // Any native multicharacter token in default scope, or any single character
  &#039;default&#039;: /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|&lt;[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
  // Any native multicharacter token in character class scope, or any single character
  &#039;class&#039;: /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
};
// Any backreference or dollar-prefixed character in replacement strings
var replacementToken = /\$(?:\{([^\}]+)\}|&lt;([^&gt;]+)&gt;|(\d\d?|[\s\S]?))/g;
// Check for correct `exec` handling of nonparticipating capturing groups
var correctExecNpcg = /()??/.exec(&#039;&#039;)[1] === undefined;
// Check for ES6 `flags` prop support
var hasFlagsProp = (0, _flags[&quot;default&quot;])(/x/) !== undefined;
function hasNativeFlag(flag) {
  // Can&#039;t check based on the presence of properties/getters since browsers might support such
  // properties even when they don&#039;t support the corresponding flag in regex construction (tested
  // in Chrome 48, where `&#039;unicode&#039; in /x/` is true but trying to construct a regex with flag `u`
  // throws an error)
  var isSupported = true;
  try {
    // Can&#039;t use regex literals for testing even in a `try` because regex literals with
    // unsupported flags cause a compilation error in IE
    new RegExp(&#039;&#039;, flag);

    // Work around a broken/incomplete IE11 polyfill for sticky introduced in core-js 3.6.0
    if (flag === &#039;y&#039;) {
      // Using function to avoid babel transform to regex literal
      var gy = function () {
        return &#039;gy&#039;;
      }();
      var incompleteY = &#039;.a&#039;.replace(new RegExp(&#039;a&#039;, gy), &#039;.&#039;) === &#039;..&#039;;
      if (incompleteY) {
        isSupported = false;
      }
    }
  } catch (exception) {
    isSupported = false;
  }
  return isSupported;
}
// Check for ES2021 `d` flag support
var hasNativeD = hasNativeFlag(&#039;d&#039;);
// Check for ES2018 `s` flag support
var hasNativeS = hasNativeFlag(&#039;s&#039;);
// Check for ES6 `u` flag support
var hasNativeU = hasNativeFlag(&#039;u&#039;);
// Check for ES6 `y` flag support
var hasNativeY = hasNativeFlag(&#039;y&#039;);
// Tracker for known flags, including addon flags
var registeredFlags = {
  d: hasNativeD,
  g: true,
  i: true,
  m: true,
  s: hasNativeS,
  u: hasNativeU,
  y: hasNativeY
};
// Flags to remove when passing to native `RegExp` constructor
var nonnativeFlags = hasNativeS ? /[^dgimsuy]+/g : /[^dgimuy]+/g;

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {!RegExp} Augmented regex.
 */
function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
  var _context;
  regex[REGEX_DATA] = {
    captureNames: captureNames
  };
  if (isInternalOnly) {
    return regex;
  }

  // Can&#039;t auto-inherit these since the XRegExp constructor returns a nonprimitive value
  if (regex.__proto__) {
    regex.__proto__ = XRegExp.prototype;
  } else {
    for (var p in XRegExp.prototype) {
      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn&#039;t be worth it here, since this
      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
      // extensions exist on `regex.prototype` anyway
      regex[p] = XRegExp.prototype[p];
    }
  }
  regex[REGEX_DATA].source = xSource;
  // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
  regex[REGEX_DATA].flags = xFlags ? (0, _sort[&quot;default&quot;])(_context = xFlags.split(&#039;&#039;)).call(_context).join(&#039;&#039;) : xFlags;
  return regex;
}

/**
 * Removes any duplicate characters from the provided string.
 *
 * @private
 * @param {String} str String to remove duplicate characters from.
 * @returns {string} String with any duplicate characters removed.
 */
function clipDuplicates(str) {
  return str.replace(/([\s\S])(?=[\s\S]*\1)/g, &#039;&#039;);
}

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @private
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   - `addG` {Boolean} Add flag g while copying the regex.
 *   - `addY` {Boolean} Add flag y while copying the regex.
 *   - `removeG` {Boolean} Remove flag g while copying the regex.
 *   - `removeY` {Boolean} Remove flag y while copying the regex.
 *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 *   - `source` {String} Overrides `&lt;regex&gt;.source`, for special cases.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
function copyRegex(regex, options) {
  var _context2;
  if (!XRegExp.isRegExp(regex)) {
    throw new TypeError(&#039;Type RegExp expected&#039;);
  }
  var xData = regex[REGEX_DATA] || {};
  var flags = getNativeFlags(regex);
  var flagsToAdd = &#039;&#039;;
  var flagsToRemove = &#039;&#039;;
  var xregexpSource = null;
  var xregexpFlags = null;
  options = options || {};
  if (options.removeG) {
    flagsToRemove += &#039;g&#039;;
  }
  if (options.removeY) {
    flagsToRemove += &#039;y&#039;;
  }
  if (flagsToRemove) {
    flags = flags.replace(new RegExp(&quot;[&quot;.concat(flagsToRemove, &quot;]+&quot;), &#039;g&#039;), &#039;&#039;);
  }
  if (options.addG) {
    flagsToAdd += &#039;g&#039;;
  }
  if (options.addY) {
    flagsToAdd += &#039;y&#039;;
  }
  if (flagsToAdd) {
    flags = clipDuplicates(flags + flagsToAdd);
  }
  if (!options.isInternalOnly) {
    if (xData.source !== undefined) {
      xregexpSource = xData.source;
    }
    // null or undefined; don&#039;t want to add to `flags` if the previous value was null, since
    // that indicates we&#039;re not tracking original precompilation flags
    if ((0, _flags[&quot;default&quot;])(xData) != null) {
      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
      // removed for non-internal regexes, so don&#039;t need to handle it
      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags[&quot;default&quot;])(xData) + flagsToAdd) : (0, _flags[&quot;default&quot;])(xData);
    }
  }

  // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
  // translation to native regex syntax
  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice[&quot;default&quot;])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
  return regex;
}

/**
 * Converts hexadecimal to decimal.
 *
 * @private
 * @param {String} hex
 * @returns {number}
 */
function dec(hex) {
  return (0, _parseInt2[&quot;default&quot;])(hex, 16);
}

/**
 * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an
 * inline comment or whitespace with flag x. This is used directly as a token handler function
 * passed to `XRegExp.addToken`.
 *
 * @private
 * @param {String} match Match arg of `XRegExp.addToken` handler
 * @param {String} scope Scope arg of `XRegExp.addToken` handler
 * @param {String} flags Flags arg of `XRegExp.addToken` handler
 * @returns {string} Either &#039;&#039; or &#039;(?:)&#039;, depending on which is needed in the context of the match.
 */
function getContextualTokenSeparator(match, scope, flags) {
  var matchEndPos = match.index + match[0].length;
  var precedingChar = match.input[match.index - 1];
  var followingChar = match.input[matchEndPos];
  if (
  // No need to separate tokens if at the beginning or end of a group, before or after a
  // group, or before or after a `|`
  /^[()|]$/.test(precedingChar) || /^[()|]$/.test(followingChar) ||
  // No need to separate tokens if at the beginning or end of the pattern
  match.index === 0 || matchEndPos === match.input.length ||
  // No need to separate tokens if at the beginning of a noncapturing group or lookaround.
  // Looks only at the last 4 chars (at most) for perf when constructing long regexes.
  /\(\?(?:[:=!]|&lt;[=!])$/.test(match.input.substring(match.index - 4, match.index)) ||
  // Avoid separating tokens when the following token is a quantifier
  isQuantifierNext(match.input, matchEndPos, flags)) {
    return &#039;&#039;;
  }
  // Keep tokens separated. This avoids e.g. inadvertedly changing `\1 1` or `\1(?#)1` to `\11`.
  // This also ensures all tokens remain as discrete atoms, e.g. it prevents converting the
  // syntax error `(? :` into `(?:`.
  return &#039;(?:)&#039;;
}

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {string} Native flags in use.
 */
function getNativeFlags(regex) {
  return hasFlagsProp ? (0, _flags[&quot;default&quot;])(regex) :
  // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
  // with an empty string) allows this to continue working predictably when
  // `XRegExp.proptotype.toString` is overridden
  /\/([a-z]*)$/i.exec(RegExp.prototype.toString.call(regex))[1];
}

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {boolean} Whether the regex uses named capture.
 */
function hasNamedCapture(regex) {
  return !!(regex[REGEX_DATA] &amp;&amp; regex[REGEX_DATA].captureNames);
}

/**
 * Converts decimal to hexadecimal.
 *
 * @private
 * @param {Number|String} dec
 * @returns {string}
 */
function hex(dec) {
  return (0, _parseInt2[&quot;default&quot;])(dec, 10).toString(16);
}

/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @private
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next nonignorable token is a quantifier.
 */
function isQuantifierNext(pattern, pos, flags) {
  var inlineCommentPattern = &#039;\\(\\?#[^)]*\\)&#039;;
  var lineCommentPattern = &#039;#[^#\\n]*&#039;;
  var quantifierPattern = &#039;[?*+]|{\\d+(?:,\\d*)?}&#039;;
  var regex = (0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;x&#039;) !== -1 ? // Ignore any leading whitespace, line comments, and inline comments
  /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : // Ignore any leading inline comments
  /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/;
  return regex.test((0, _slice[&quot;default&quot;])(pattern).call(pattern, pos));
}

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @private
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {boolean} Whether the object matches the type.
 */
function isType(value, type) {
  return Object.prototype.toString.call(value) === &quot;[object &quot;.concat(type, &quot;]&quot;);
}

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @private
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
function nullThrows(value) {
  // null or undefined
  if (value == null) {
    throw new TypeError(&#039;Cannot convert null or undefined to object&#039;);
  }
  return value;
}

/**
 * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
 *
 * @private
 * @param {String} str
 * @returns {string}
 */
function pad4(str) {
  while (str.length &lt; 4) {
    str = &quot;0&quot;.concat(str);
  }
  return str;
}

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @private
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {!Object} Object with properties `pattern` and `flags`.
 */
function prepareFlags(pattern, flags) {
  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
  if (clipDuplicates(flags) !== flags) {
    throw new SyntaxError(&quot;Invalid duplicate regex flag &quot;.concat(flags));
  }

  // Strip and apply a leading mode modifier with any combination of flags except `dgy`
  pattern = pattern.replace(/^\(\?([\w$]+)\)/, function ($0, $1) {
    if (/[dgy]/.test($1)) {
      throw new SyntaxError(&quot;Cannot use flags dgy in mode modifier &quot;.concat($0));
    }
    // Allow duplicate flags within the mode modifier
    flags = clipDuplicates(flags + $1);
    return &#039;&#039;;
  });

  // Throw on unknown native or nonnative flags
  var _iterator = _createForOfIteratorHelper(flags),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var flag = _step.value;
      if (!registeredFlags[flag]) {
        throw new SyntaxError(&quot;Unknown regex flag &quot;.concat(flag));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    pattern: pattern,
    flags: flags
  };
}

/**
 * Prepares an options object from the given value.
 *
 * @private
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
function prepareOptions(value) {
  var options = {};
  if (isType(value, &#039;String&#039;)) {
    (0, _forEach[&quot;default&quot;])(XRegExp).call(XRegExp, value, /[^\s,]+/, function (match) {
      options[match] = true;
    });
    return options;
  }
  return value;
}

/**
 * Registers a flag so it doesn&#039;t throw an &#039;unknown flag&#039; error.
 *
 * @private
 * @param {String} flag Single-character flag to register.
 */
function registerFlag(flag) {
  if (!/^[\w$]$/.test(flag)) {
    throw new Error(&#039;Flag must be a single character A-Za-z0-9_$&#039;);
  }
  registeredFlags[flag] = true;
}

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @private
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: &#039;default&#039; or &#039;class&#039;.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
function runTokens(pattern, flags, pos, scope, context) {
  var i = tokens.length;
  var leadChar = pattern[pos];
  var result = null;
  var match;
  var t;

  // Run in reverse insertion order
  while (i--) {
    t = tokens[i];
    if (t.leadChar &amp;&amp; t.leadChar !== leadChar || t.scope !== scope &amp;&amp; t.scope !== &#039;all&#039; || t.flag &amp;&amp; !((0, _indexOf[&quot;default&quot;])(flags).call(flags, t.flag) !== -1)) {
      continue;
    }
    match = XRegExp.exec(pattern, t.regex, pos, &#039;sticky&#039;);
    if (match) {
      result = {
        matchLength: match[0].length,
        output: t.handler.call(context, match, scope, flags),
        reparse: t.reparse
      };
      // Finished with token tests
      break;
    }
  }
  return result;
}

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setAstral(on) {
  features.astral = on;
}

/**
 * Adds named capture groups to the `groups` property of match arrays. See here for details:
 * https://github.com/tc39/proposal-regexp-named-groups
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setNamespacing(on) {
  features.namespacing = on;
}

// ==--------------------------==
// Constructor
// ==--------------------------==

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     - `d` - indices for capturing groups (ES2021)
 *     - `g` - global
 *     - `i` - ignore case
 *     - `m` - multiline anchors
 *     - `u` - unicode (ES6)
 *     - `y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     - `n` - named capture only
 *     - `s` - dot matches all (aka singleline) - works even when not natively supported
 *     - `x` - free-spacing and line comments (aka extended)
 *     - `A` - 21-bit Unicode properties (aka astral) - requires the Unicode Base addon
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp(`(?&lt;year&gt;  [0-9]{4} ) -?  # year
 *          (?&lt;month&gt; [0-9]{2} ) -?  # month
 *          (?&lt;day&gt;   [0-9]{2} )     # day`, &#039;x&#039;);
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
function XRegExp(pattern, flags) {
  if (XRegExp.isRegExp(pattern)) {
    if (flags !== undefined) {
      throw new TypeError(&#039;Cannot supply flags when copying a RegExp&#039;);
    }
    return copyRegex(pattern);
  }

  // Copy the argument behavior of `RegExp`
  pattern = pattern === undefined ? &#039;&#039; : String(pattern);
  flags = flags === undefined ? &#039;&#039; : String(flags);
  if (XRegExp.isInstalled(&#039;astral&#039;) &amp;&amp; !((0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;A&#039;) !== -1)) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += &#039;A&#039;;
  }
  if (!patternCache[pattern]) {
    patternCache[pattern] = {};
  }
  if (!patternCache[pattern][flags]) {
    var context = {
      hasNamedCapture: false,
      captureNames: []
    };
    var scope = defaultScope;
    var output = &#039;&#039;;
    var pos = 0;
    var result;

    // Check for flag-related errors, and strip/apply flags in a leading mode modifier
    var applied = prepareFlags(pattern, flags);
    var appliedPattern = applied.pattern;
    var appliedFlags = (0, _flags[&quot;default&quot;])(applied);

    // Use XRegExp&#039;s tokens to translate the pattern to a native regex pattern.
    // `appliedPattern.length` may change on each iteration if tokens use `reparse`
    while (pos &lt; appliedPattern.length) {
      do {
        // Check for custom tokens at the current position
        result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
        // If the matched token used the `reparse` option, splice its output into the
        // pattern before running tokens again at the same position
        if (result &amp;&amp; result.reparse) {
          appliedPattern = (0, _slice[&quot;default&quot;])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice[&quot;default&quot;])(appliedPattern).call(appliedPattern, pos + result.matchLength);
        }
      } while (result &amp;&amp; result.reparse);
      if (result) {
        output += result.output;
        pos += result.matchLength || 1;
      } else {
        // Get the native token at the current position
        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, &#039;sticky&#039;),
          _XRegExp$exec2 = (0, _slicedToArray2[&quot;default&quot;])(_XRegExp$exec, 1),
          token = _XRegExp$exec2[0];
        output += token;
        pos += token.length;
        if (token === &#039;[&#039; &amp;&amp; scope === defaultScope) {
          scope = classScope;
        } else if (token === &#039;]&#039; &amp;&amp; scope === classScope) {
          scope = defaultScope;
        }
      }
    }
    patternCache[pattern][flags] = {
      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
      // groups are sometimes inserted during regex transpilation in order to keep tokens
      // separated. However, more than one empty group in a row is never needed.
      pattern: output.replace(/(?:\(\?:\))+/g, &#039;(?:)&#039;),
      // Strip all but native flags
      flags: appliedFlags.replace(nonnativeFlags, &#039;&#039;),
      // `context.captureNames` has an item for each capturing group, even if unnamed
      captures: context.hasNamedCapture ? context.captureNames : null
    };
  }
  var generated = patternCache[pattern][flags];
  return augment(new RegExp(generated.pattern, (0, _flags[&quot;default&quot;])(generated)), generated.captures, pattern, flags);
}

// Add `RegExp.prototype` to the prototype chain
XRegExp.prototype = /(?:)/;

// ==--------------------------==
// Public properties
// ==--------------------------==

/**
 * The XRegExp version number as a string containing three dot-separated parts. For example,
 * &#039;2.0.0-beta-3&#039;.
 *
 * @static
 * @memberOf XRegExp
 * @type String
 */
XRegExp.version = &#039;5.1.2&#039;;

// ==--------------------------==
// Public methods
// ==--------------------------==

// Intentionally undocumented; used in tests and addons
XRegExp._clipDuplicates = clipDuplicates;
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   - The match array, with named backreference properties.
 *   - The regex scope where the match was found: &#039;default&#039; or &#039;class&#039;.
 *   - The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   - `scope` {String} Scope where the token applies: &#039;default&#039;, &#039;class&#039;, or &#039;all&#039;.
 *   - `flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an &#039;unknown flag&#039; error when the flag is used.
 *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an &#039;unknown flag&#039; error when any of the flags are used.
 *   - `reparse` {Boolean} Whether the `handler` function&#039;s output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   - `leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn&#039;t change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token&#039;s performance
 *     since the token can be skipped at any positions where this character doesn&#039;t appear.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   () =&gt; &#039;\\x07&#039;,
 *   {scope: &#039;all&#039;}
 * );
 * XRegExp(&#039;\\a[\\a-\\n]+&#039;).test(&#039;\x07\n\x07&#039;); // -&gt; true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
 * // Since `scope` is not specified, it uses &#039;default&#039; (i.e., transformations apply outside of
 * // character classes only)
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   (match) =&gt; `${match[1]}${match[2] ? &#039;&#039; : &#039;?&#039;}`,
 *   {flag: &#039;U&#039;}
 * );
 * XRegExp(&#039;a+&#039;, &#039;U&#039;).exec(&#039;aaa&#039;)[0]; // -&gt; &#039;a&#039;
 * XRegExp(&#039;a+?&#039;, &#039;U&#039;).exec(&#039;aaa&#039;)[0]; // -&gt; &#039;aaa&#039;
 */
XRegExp.addToken = function (regex, handler, options) {
  options = options || {};
  var _options = options,
    optionalFlags = _options.optionalFlags;
  if (options.flag) {
    registerFlag(options.flag);
  }
  if (optionalFlags) {
    optionalFlags = optionalFlags.split(&#039;&#039;);
    var _iterator2 = _createForOfIteratorHelper(optionalFlags),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var flag = _step2.value;
        registerFlag(flag);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  // Add to the private list of syntax tokens
  tokens.push({
    regex: copyRegex(regex, {
      addG: true,
      addY: hasNativeY,
      isInternalOnly: true
    }),
    handler: handler,
    scope: options.scope || defaultScope,
    flag: options.flag,
    reparse: options.reparse,
    leadChar: options.leadChar
  });

  // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
  // might now produce different results
  XRegExp.cache.flush(&#039;patterns&#039;);
};

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * let match;
 * while (match = XRegExp.cache(&#039;.&#039;, &#039;gs&#039;).exec(&#039;abc&#039;)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function (pattern, flags) {
  if (!regexCache[pattern]) {
    regexCache[pattern] = {};
  }
  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
};

// Intentionally undocumented; used in tests
XRegExp.cache.flush = function (cacheName) {
  if (cacheName === &#039;patterns&#039;) {
    // Flush the pattern cache used by the `XRegExp` constructor
    patternCache = (0, _create[&quot;default&quot;])(null);
  } else {
    // Flush the regex cache populated by `XRegExp.cache`
    regexCache = (0, _create[&quot;default&quot;])(null);
  }
};

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any position within a regex that uses any flags.
 *
 * @memberOf XRegExp
 * @param {String} str String to escape.
 * @returns {string} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape(&#039;Escaped? &lt;.&gt;&#039;);
 * // -&gt; &#039;Escaped\?\u0020&lt;\.&gt;&#039;
 */
// Following are the contexts where each metacharacter needs to be escaped because it would
// otherwise have a special meaning, change the meaning of surrounding characters, or cause an
// error. Context &#039;default&#039; means outside character classes only.
// - `\` - context: all
// - `[()*+?.$|` - context: default
// - `]` - context: default with flag u or if forming the end of a character class
// - `{}` - context: default with flag u or if part of a valid/complete quantifier pattern
// - `,` - context: default if in a position that causes an unescaped `{` to turn into a quantifier.
//   Ex: `/^a{1\,2}$/` matches `&#039;a{1,2}&#039;`, but `/^a{1,2}$/` matches `&#039;a&#039;` or `&#039;aa&#039;`
// - `#` and &lt;whitespace&gt; - context: default with flag x
// - `^` - context: default, and context: class if it&#039;s the first character in the class
// - `-` - context: class if part of a valid character class range
XRegExp.escape = function (str) {
  return String(nullThrows(str)).
  // Escape most special chars with a backslash
  replace(/[\\\[\]{}()*+?.^$|]/g, &#039;\\$&amp;&#039;).
  // Convert to \uNNNN for special chars that can&#039;t be escaped when used with ES6 flag `u`
  replace(/[\s#\-,]/g, function (match) {
    return &quot;\\u&quot;.concat(pad4(hex(match.charCodeAt(0))));
  });
};

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named capture properties are included on the match array&#039;s `groups`
 * property. Optional `pos` and `sticky` arguments specify the search start position, and whether
 * the match must start at the specified position only. The `lastIndex` property of the provided
 * regex is not used, but is updated for compatibility. Also fixes browser bugs compared to the
 * native `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `&#039;sticky&#039;` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named capture properties on the `groups` object, or `null`. If
 *   the `namespacing` feature is off, named capture properties are directly on the match array.
 * @example
 *
 * // Basic use, with named capturing group
 * let match = XRegExp.exec(&#039;U+2620&#039;, XRegExp(&#039;U\\+(?&lt;hex&gt;[0-9A-F]{4})&#039;));
 * match.groups.hex; // -&gt; &#039;2620&#039;
 *
 * // With pos and sticky, in a loop
 * let pos = 3, result = [], match;
 * while (match = XRegExp.exec(&#039;&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;&#039;, /&lt;(\d)&gt;/, pos, &#039;sticky&#039;)) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -&gt; [&#039;2&#039;, &#039;3&#039;, &#039;4&#039;]
 */
XRegExp.exec = function (str, regex, pos, sticky) {
  var cacheKey = &#039;g&#039;;
  var addY = false;
  var fakeY = false;
  var match;
  addY = hasNativeY &amp;&amp; !!(sticky || regex.sticky &amp;&amp; sticky !== false);
  if (addY) {
    cacheKey += &#039;y&#039;;
  } else if (sticky) {
    // Simulate sticky matching by appending an empty capture to the original regex. The
    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
    // and will not search the rest of the subject string. We&#039;ll know that the original regex
    // has failed if that last capture is `&#039;&#039;` rather than `undefined` (i.e., if that last
    // capture participated in the match).
    fakeY = true;
    cacheKey += &#039;FakeY&#039;;
  }
  regex[REGEX_DATA] = regex[REGEX_DATA] || {};

  // Shares cached copies with `XRegExp.match`/`replace`
  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
    addG: true,
    addY: addY,
    source: fakeY ? &quot;&quot;.concat(regex.source, &quot;|()&quot;) : undefined,
    removeY: sticky === false,
    isInternalOnly: true
  }));
  pos = pos || 0;
  r2.lastIndex = pos;

  // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
  match = fixed.exec.call(r2, str);

  // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
  // the original regexp failed (see above).
  if (fakeY &amp;&amp; match &amp;&amp; match.pop() === &#039;&#039;) {
    match = null;
  }
  if (regex.global) {
    regex.lastIndex = match ? r2.lastIndex : 0;
  }
  return match;
};

/**
 * Executes a provided function once per regex match. Searches always start at the beginning of the
 * string and continue until the end, regardless of the state of the regex&#039;s `global` property and
 * initial `lastIndex`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   - The match array, with named backreference properties.
 *   - The zero-based match index.
 *   - The string being traversed.
 *   - The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * const evens = [];
 * XRegExp.forEach(&#039;1a2345&#039;, /\d/, (match, i) =&gt; {
 *   if (i % 2) evens.push(+match[0]);
 * });
 * // evens -&gt; [2, 4]
 */
XRegExp.forEach = function (str, regex, callback) {
  var pos = 0;
  var i = -1;
  var match;
  while (match = XRegExp.exec(str, regex, pos)) {
    // Because `regex` is provided to `callback`, the function could use the deprecated/
    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
    // doesn&#039;t use `lastIndex` to set the search position, this can&#039;t lead to an infinite loop,
    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
    // regexes, mutating the regex will not have any effect on the iteration or matched strings,
    // which is a nice side effect that brings extra safety.
    callback(match, ++i, str, regex);
    pos = match.index + (match[0].length || 1);
  }
};

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * const globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -&gt; true
 */
XRegExp.globalize = function (regex) {
  return copyRegex(regex, {
    addG: true
  });
};

/**
 * Installs optional features according to the specified options. Can be undone using
 * `XRegExp.uninstall`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // Adds named capture groups to the `groups` property of matches
 *   namespacing: true
 * });
 *
 * // With an options string
 * XRegExp.install(&#039;astral namespacing&#039;);
 */
XRegExp.install = function (options) {
  options = prepareOptions(options);
  if (!features.astral &amp;&amp; options.astral) {
    setAstral(true);
  }
  if (!features.namespacing &amp;&amp; options.namespacing) {
    setNamespacing(true);
  }
};

/**
 * Checks whether an individual optional feature is installed.
 *
 * @memberOf XRegExp
 * @param {String} feature Name of the feature to check. One of:
 *   - `astral`
 *   - `namespacing`
 * @returns {boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled(&#039;astral&#039;);
 */
XRegExp.isInstalled = function (feature) {
  return !!features[feature];
};

/**
 * Returns `true` if an object is a regex; `false` if it isn&#039;t. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @memberOf XRegExp
 * @param {*} value Object to check.
 * @returns {boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp(&#039;string&#039;); // -&gt; false
 * XRegExp.isRegExp(/regex/i); // -&gt; true
 * XRegExp.isRegExp(RegExp(&#039;^&#039;, &#039;m&#039;)); // -&gt; true
 * XRegExp.isRegExp(XRegExp(&#039;(?s).&#039;)); // -&gt; true
 */
XRegExp.isRegExp = function (value) {
  return Object.prototype.toString.call(value) === &#039;[object RegExp]&#039;;
};
// Same as `isType(value, &#039;RegExp&#039;)`, but avoiding that function call here for perf since
// `isRegExp` is used heavily by internals including regex construction

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope=&#039;one&#039;] Use &#039;one&#039; to return the first match as a string. Use &#039;all&#039; to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is &#039;all&#039;.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match(&#039;abc&#039;, /\w/); // -&gt; &#039;a&#039;
 * XRegExp.match(&#039;abc&#039;, /\w/g, &#039;one&#039;); // -&gt; &#039;a&#039;
 * XRegExp.match(&#039;abc&#039;, /x/g, &#039;one&#039;); // -&gt; null
 *
 * // Match all
 * XRegExp.match(&#039;abc&#039;, /\w/g); // -&gt; [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]
 * XRegExp.match(&#039;abc&#039;, /\w/, &#039;all&#039;); // -&gt; [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]
 * XRegExp.match(&#039;abc&#039;, /x/, &#039;all&#039;); // -&gt; []
 */
XRegExp.match = function (str, regex, scope) {
  var global = regex.global &amp;&amp; scope !== &#039;one&#039; || scope === &#039;all&#039;;
  var cacheKey = (global ? &#039;g&#039; : &#039;&#039;) + (regex.sticky ? &#039;y&#039; : &#039;&#039;) || &#039;noGY&#039;;
  regex[REGEX_DATA] = regex[REGEX_DATA] || {};

  // Shares cached copies with `XRegExp.exec`/`replace`
  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
    addG: !!global,
    removeG: scope === &#039;one&#039;,
    isInternalOnly: true
  }));
  var result = String(nullThrows(str)).match(r2);
  if (regex.global) {
    regex.lastIndex = scope === &#039;one&#039; &amp;&amp; result ?
    // Can&#039;t use `r2.lastIndex` since `r2` is nonglobal in this case
    result.index + result[0].length : 0;
  }
  return global ? result || [] : result &amp;&amp; result[0];
};

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and or objects with
 * `regex` and `backref` properties. When a backreference is specified, the named or numbered
 * backreference is passed forward to the next regex or returned.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within &lt;b&gt; tags
 * XRegExp.matchChain(&#039;1 &lt;b&gt;2&lt;/b&gt; 3 &lt;b&gt;4 a 56&lt;/b&gt;&#039;, [
 *   XRegExp(&#039;(?is)&lt;b&gt;.*?&lt;/b&gt;&#039;),
 *   /\d+/
 * ]);
 * // -&gt; [&#039;2&#039;, &#039;4&#039;, &#039;56&#039;]
 *
 * // Passing forward and returning specific backreferences
 * const html = `&lt;a href=&quot;http://xregexp.com/api/&quot;&gt;XRegExp&lt;/a&gt;
 *               &lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;`;
 * XRegExp.matchChain(html, [
 *   {regex: /&lt;a href=&quot;([^&quot;]+)&quot;&gt;/i, backref: 1},
 *   {regex: XRegExp(&#039;(?i)^https?://(?&lt;domain&gt;[^/?#]+)&#039;), backref: &#039;domain&#039;}
 * ]);
 * // -&gt; [&#039;xregexp.com&#039;, &#039;www.google.com&#039;]
 */
XRegExp.matchChain = function (str, chain) {
  return function recurseChain(values, level) {
    var item = chain[level].regex ? chain[level] : {
      regex: chain[level]
    };
    var matches = [];
    function addMatch(match) {
      if (item.backref) {
        var ERR_UNDEFINED_GROUP = &quot;Backreference to undefined group: &quot;.concat(item.backref);
        var isNamedBackref = isNaN(item.backref);
        if (isNamedBackref &amp;&amp; XRegExp.isInstalled(&#039;namespacing&#039;)) {
          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`
          if (!(match.groups &amp;&amp; item.backref in match.groups)) {
            throw new ReferenceError(ERR_UNDEFINED_GROUP);
          }
        } else if (!match.hasOwnProperty(item.backref)) {
          throw new ReferenceError(ERR_UNDEFINED_GROUP);
        }
        var backrefValue = isNamedBackref &amp;&amp; XRegExp.isInstalled(&#039;namespacing&#039;) ? match.groups[item.backref] : match[item.backref];
        matches.push(backrefValue || &#039;&#039;);
      } else {
        matches.push(match[0]);
      }
    }
    var _iterator3 = _createForOfIteratorHelper(values),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var value = _step3.value;
        (0, _forEach[&quot;default&quot;])(XRegExp).call(XRegExp, value, item.regex, addMatch);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
  }([str], 0);
};

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `$&lt;n&gt;` or `${n}` for named and numbered backreferences.
 * Replacement functions can use named backreferences via the last argument. Also fixes browser bugs
 * compared to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     - $$ - Inserts a literal $ character.
 *     - $&amp;, $0 - Inserts the matched substring.
 *     - $` - Inserts the string that precedes the matched substring (left context).
 *     - $&#039; - Inserts the string that follows the matched substring (right context).
 *     - $n, $nn - Where n/nn are digits referencing an existing capturing group, inserts
 *       backreference n/nn.
 *     - $&lt;n&gt;, ${n} - Where n is a name or any number of digits that reference an existing capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     - args[0] - The matched substring (corresponds to `$&amp;` above). If the `namespacing` feature
 *       is off, named backreferences are accessible as properties of this argument.
 *     - args[1..n] - One argument for each backreference (corresponding to `$1`, `$2`, etc. above).
 *       If the regex has no capturing groups, no arguments appear in this position.
 *     - args[n+1] - The zero-based index of the match within the entire search string.
 *     - args[n+2] - The total string being searched.
 *     - args[n+3] - If the the search pattern is a regex with named capturing groups, the last
 *       argument is the groups object. Its keys are the backreference names and its values are the
 *       backreference values. If the `namespacing` feature is off, this argument is not present.
 * @param {String} [scope] Use &#039;one&#039; to replace the first match only, or &#039;all&#039;. Defaults to &#039;one&#039;.
 *   Defaults to &#039;all&#039; if using a regex with flag g.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * const name = XRegExp(&#039;(?&lt;first&gt;\\w+) (?&lt;last&gt;\\w+)&#039;);
 * XRegExp.replace(&#039;John Smith&#039;, name, &#039;$&lt;last&gt;, $&lt;first&gt;&#039;);
 * // -&gt; &#039;Smith, John&#039;
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace(&#039;John Smith&#039;, name, (...args) =&gt; {
 *   const groups = args[args.length - 1];
 *   return `${groups.last}, ${groups.first}`;
 * });
 * // -&gt; &#039;Smith, John&#039;
 *
 * // String search, with replace-all
 * XRegExp.replace(&#039;RegExp builds RegExps&#039;, &#039;RegExp&#039;, &#039;XRegExp&#039;, &#039;all&#039;);
 * // -&gt; &#039;XRegExp builds XRegExps&#039;
 */
XRegExp.replace = function (str, search, replacement, scope) {
  var isRegex = XRegExp.isRegExp(search);
  var global = search.global &amp;&amp; scope !== &#039;one&#039; || scope === &#039;all&#039;;
  var cacheKey = (global ? &#039;g&#039; : &#039;&#039;) + (search.sticky ? &#039;y&#039; : &#039;&#039;) || &#039;noGY&#039;;
  var s2 = search;
  if (isRegex) {
    search[REGEX_DATA] = search[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`&#039;s
    // `lastIndex` isn&#039;t updated *during* replacement iterations
    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
      addG: !!global,
      removeG: scope === &#039;one&#039;,
      isInternalOnly: true
    }));
  } else if (global) {
    s2 = new RegExp(XRegExp.escape(String(search)), &#039;g&#039;);
  }

  // Fixed `replace` required for named backreferences, etc.
  var result = fixed.replace.call(nullThrows(str), s2, replacement);
  if (isRegex &amp;&amp; search.global) {
    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
    search.lastIndex = 0;
  }
  return result;
};

/**
 * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
 * array of replacement details. Later replacements operate on the output of earlier replacements.
 * Replacement details are accepted as an array with a regex or string to search for, the
 * replacement string or function, and an optional scope of &#039;one&#039; or &#039;all&#039;. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `$&lt;name&gt;` or
 * `${name}`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp(&#039;(?&lt;name&gt;a)&#039;), &#039;z$&lt;name&gt;&#039;],
 *   [/b/gi, &#039;y&#039;],
 *   [/c/g, &#039;x&#039;, &#039;one&#039;], // scope &#039;one&#039; overrides /g
 *   [/d/, &#039;w&#039;, &#039;all&#039;],  // scope &#039;all&#039; overrides lack of /g
 *   [&#039;e&#039;, &#039;v&#039;, &#039;all&#039;],  // scope &#039;all&#039; allows replace-all for strings
 *   [/f/g, (match) =&gt; match.toUpperCase()]
 * ]);
 */
XRegExp.replaceEach = function (str, replacements) {
  var _iterator4 = _createForOfIteratorHelper(replacements),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var r = _step4.value;
      str = XRegExp.replace(str, r[0], r[1], r[2]);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return str;
};

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split(&#039;a b c&#039;, &#039; &#039;);
 * // -&gt; [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]
 *
 * // With limit
 * XRegExp.split(&#039;a b c&#039;, &#039; &#039;, 2);
 * // -&gt; [&#039;a&#039;, &#039;b&#039;]
 *
 * // Backreferences in result array
 * XRegExp.split(&#039;..word1..&#039;, /([a-z]+)(\d+)/i);
 * // -&gt; [&#039;..&#039;, &#039;word&#039;, &#039;1&#039;, &#039;..&#039;]
 */
XRegExp.split = function (str, separator, limit) {
  return fixed.split.call(nullThrows(str), separator, limit);
};

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `&#039;sticky&#039;` is accepted as an alternative to `true`.
 * @returns {boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test(&#039;abc&#039;, /c/); // -&gt; true
 *
 * // With pos and sticky
 * XRegExp.test(&#039;abc&#039;, /c/, 0, &#039;sticky&#039;); // -&gt; false
 * XRegExp.test(&#039;abc&#039;, /c/, 2, &#039;sticky&#039;); // -&gt; true
 */
// Do this the easy way :-)
XRegExp.test = function (str, regex, pos, sticky) {
  return !!XRegExp.exec(str, regex, pos, sticky);
};

/**
 * Uninstalls optional features according to the specified options. Used to undo the actions of
 * `XRegExp.install`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons (unless enabled per regex)
 *   astral: true,
 *
 *   // Don&#039;t add named capture groups to the `groups` property of matches
 *   namespacing: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall(&#039;astral namespacing&#039;);
 */
XRegExp.uninstall = function (options) {
  options = prepareOptions(options);
  if (features.astral &amp;&amp; options.astral) {
    setAstral(false);
  }
  if (features.namespacing &amp;&amp; options.namespacing) {
    setNamespacing(false);
  }
};

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @param {Object} [options] Options object with optional properties:
 *   - `conjunction` {String} Type of conjunction to use: &#039;or&#039; (default) or &#039;none&#039;.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union([&#039;a+b*c&#039;, /(dogs)\1/, /(cats)\1/], &#039;i&#039;);
 * // -&gt; /a\+b\*c|(dogs)\1|(cats)\2/i
 *
 * XRegExp.union([/man/, /bear/, /pig/], &#039;i&#039;, {conjunction: &#039;none&#039;});
 * // -&gt; /manbearpig/i
 */
XRegExp.union = function (patterns, flags, options) {
  options = options || {};
  var conjunction = options.conjunction || &#039;or&#039;;
  var numCaptures = 0;
  var numPriorCaptures;
  var captureNames;
  function rewrite(match, paren, backref) {
    var name = captureNames[numCaptures - numPriorCaptures];

    // Capturing group
    if (paren) {
      ++numCaptures;
      // If the current capture has a name, preserve the name
      if (name) {
        return &quot;(?&lt;&quot;.concat(name, &quot;&gt;&quot;);
      }
      // Backreference
    } else if (backref) {
      // Rewrite the backreference
      return &quot;\\&quot;.concat(+backref + numPriorCaptures);
    }
    return match;
  }
  if (!(isType(patterns, &#039;Array&#039;) &amp;&amp; patterns.length)) {
    throw new TypeError(&#039;Must provide a nonempty array of patterns to merge&#039;);
  }
  var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
  var output = [];
  var _iterator5 = _createForOfIteratorHelper(patterns),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var pattern = _step5.value;
      if (XRegExp.isRegExp(pattern)) {
        numPriorCaptures = numCaptures;
        captureNames = pattern[REGEX_DATA] &amp;&amp; pattern[REGEX_DATA].captureNames || [];

        // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
        // independently valid; helps keep this simple. Named captures are put back
        output.push(XRegExp(pattern.source).source.replace(parts, rewrite));
      } else {
        output.push(XRegExp.escape(pattern));
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  var separator = conjunction === &#039;none&#039; ? &#039;&#039; : &#039;|&#039;;
  return XRegExp(output.join(separator), flags);
};

// ==--------------------------==
// Fixed/extended native methods
// ==--------------------------==

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
fixed.exec = function (str) {
  var origLastIndex = this.lastIndex;
  var match = RegExp.prototype.exec.apply(this, arguments);
  if (match) {
    // Fix browsers whose `exec` methods don&#039;t return `undefined` for nonparticipating capturing
    // groups. This fixes IE 5.5-8, but not IE 9&#039;s quirks mode or emulation of older IEs. IE 9
    // in standards mode follows the spec.
    if (!correctExecNpcg &amp;&amp; match.length &gt; 1 &amp;&amp; (0, _indexOf[&quot;default&quot;])(match).call(match, &#039;&#039;) !== -1) {
      var _context3;
      var r2 = copyRegex(this, {
        removeG: true,
        isInternalOnly: true
      });
      // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
      // matching due to characters outside the match
      (0, _slice[&quot;default&quot;])(_context3 = String(str)).call(_context3, match.index).replace(r2, function () {
        var len = arguments.length;
        // Skip index 0 and the last 2
        for (var i = 1; i &lt; len - 2; ++i) {
          if ((i &lt; 0 || arguments.length &lt;= i ? undefined : arguments[i]) === undefined) {
            match[i] = undefined;
          }
        }
      });
    }

    // Attach named capture properties
    if (this[REGEX_DATA] &amp;&amp; this[REGEX_DATA].captureNames) {
      var groupsObject = match;
      if (XRegExp.isInstalled(&#039;namespacing&#039;)) {
        // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec
        match.groups = (0, _create[&quot;default&quot;])(null);
        groupsObject = match.groups;
      }
      // Skip index 0
      for (var i = 1; i &lt; match.length; ++i) {
        var name = this[REGEX_DATA].captureNames[i - 1];
        if (name) {
          groupsObject[name] = match[i];
        }
      }
      // Preserve any existing `groups` obj that came from native ES2018 named capture
    } else if (!match.groups &amp;&amp; XRegExp.isInstalled(&#039;namespacing&#039;)) {
      match.groups = undefined;
    }

    // Fix browsers that increment `lastIndex` after zero-length matches
    if (this.global &amp;&amp; !match[0].length &amp;&amp; this.lastIndex &gt; match.index) {
      this.lastIndex = match.index;
    }
  }
  if (!this.global) {
    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
    this.lastIndex = origLastIndex;
  }
  return match;
};

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {boolean} Whether the regex matched the provided value.
 */
fixed.test = function (str) {
  // Do this the easy way :-)
  return !!fixed.exec.call(this, str);
};

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`.
 *
 * @memberOf String
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
fixed.match = function (regex) {
  if (!XRegExp.isRegExp(regex)) {
    // Use the native `RegExp` rather than `XRegExp`
    regex = new RegExp(regex);
  } else if (regex.global) {
    var result = String.prototype.match.apply(this, arguments);
    // Fixes IE bug
    regex.lastIndex = 0;
    return result;
  }
  return fixed.exec.call(regex, nullThrows(this));
};

/**
 * Adds support for `${n}` (or `$&lt;n&gt;`) tokens for named and numbered backreferences in replacement
 * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also
 * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex
 * search value, and the value of a replacement regex&#039;s `lastIndex` property during replacement
 * iterations and upon completion. Note that this doesn&#039;t support SpiderMonkey&#039;s proprietary third
 * (`flags`) argument. Use via `XRegExp.replace`.
 *
 * @memberOf String
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {string} New string with one or all matches replaced.
 */
fixed.replace = function (search, replacement) {
  var isRegex = XRegExp.isRegExp(search);
  var origLastIndex;
  var captureNames;
  var result;
  if (isRegex) {
    if (search[REGEX_DATA]) {
      captureNames = search[REGEX_DATA].captureNames;
    }
    // Only needed if `search` is nonglobal
    origLastIndex = search.lastIndex;
  } else {
    search += &#039;&#039;; // Type-convert
  }

  // Don&#039;t use `typeof`; some older browsers return &#039;function&#039; for regex objects
  if (isType(replacement, &#039;Function&#039;)) {
    // Stringifying `this` fixes a bug in IE &lt; 9 where the last argument in replacement
    // functions isn&#039;t type-converted to a string
    result = String(this).replace(search, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (captureNames) {
        var groupsObject;
        if (XRegExp.isInstalled(&#039;namespacing&#039;)) {
          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec
          groupsObject = (0, _create[&quot;default&quot;])(null);
          args.push(groupsObject);
        } else {
          // Change the `args[0]` string primitive to a `String` object that can store
          // properties. This really does need to use `String` as a constructor
          args[0] = new String(args[0]);
          groupsObject = args[0];
        }

        // Store named backreferences
        for (var i = 0; i &lt; captureNames.length; ++i) {
          if (captureNames[i]) {
            groupsObject[captureNames[i]] = args[i + 1];
          }
        }
      }
      // ES6 specs the context for replacement functions as `undefined`
      return replacement.apply(void 0, args);
    });
  } else {
    // Ensure that the last value of `args` will be a string when given nonstring `this`,
    // while still throwing on null or undefined context
    result = String(nullThrows(this)).replace(search, function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return String(replacement).replace(replacementToken, replacer);
      function replacer($0, bracketed, angled, dollarToken) {
        bracketed = bracketed || angled;

        // ES2018 added a new trailing `groups` arg that&#039;s passed to replacement functions
        // when the search regex uses native named capture
        var numNonCaptureArgs = isType(args[args.length - 1], &#039;Object&#039;) ? 4 : 3;
        var numCaptures = args.length - numNonCaptureArgs;

        // Handle named or numbered backreference with curly or angled braces: ${n}, $&lt;n&gt;
        if (bracketed) {
          // Handle backreference to numbered capture, if `bracketed` is an integer. Use
          // `0` for the entire match. Any number of leading zeros may be used.
          if (/^\d+$/.test(bracketed)) {
            // Type-convert and drop leading zeros
            var _n = +bracketed;
            if (_n &lt;= numCaptures) {
              return args[_n] || &#039;&#039;;
            }
          }

          // Handle backreference to named capture. If the name does not refer to an
          // existing capturing group, it&#039;s an error. Also handles the error for numbered
          // backference that does not refer to an existing group.
          // Using `indexOf` since having groups with the same name is already an error,
          // otherwise would need `lastIndexOf`.
          var n = captureNames ? (0, _indexOf[&quot;default&quot;])(captureNames).call(captureNames, bracketed) : -1;
          if (n &lt; 0) {
            throw new SyntaxError(&quot;Backreference to undefined group &quot;.concat($0));
          }
          return args[n + 1] || &#039;&#039;;
        }

        // Handle `$`-prefixed variable
        // Handle space/blank first because type conversion with `+` drops space padding
        // and converts spaces and empty strings to `0`
        if (dollarToken === &#039;&#039; || dollarToken === &#039; &#039;) {
          throw new SyntaxError(&quot;Invalid token &quot;.concat($0));
        }
        if (dollarToken === &#039;&amp;&#039; || +dollarToken === 0) {
          // $&amp;, $0 (not followed by 1-9), $00
          return args[0];
        }
        if (dollarToken === &#039;$&#039;) {
          // $$
          return &#039;$&#039;;
        }
        if (dollarToken === &#039;`&#039;) {
          var _context4;
          // $` (left context)
          return (0, _slice[&quot;default&quot;])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);
        }
        if (dollarToken === &quot;&#039;&quot;) {
          var _context5;
          // $&#039; (right context)
          return (0, _slice[&quot;default&quot;])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);
        }

        // Handle numbered backreference without braces
        // Type-convert and drop leading zero
        dollarToken = +dollarToken;
        // XRegExp behavior for `$n` and `$nn`:
        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$&lt;..&gt;` for more digits.
        // - `$1` is an error if no capturing groups.
        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$&lt;1&gt;0`
        //   instead.
        // - `$01` is `$1` if at least one capturing group, else it&#039;s an error.
        // - `$0` (not followed by 1-9) and `$00` are the entire match.
        // Native behavior, for comparison:
        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
        // - `$1` is a literal `$1` if no capturing groups.
        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
        // - `$01` is `$1` if at least one capturing group, else it&#039;s a literal `$01`.
        // - `$0` is a literal `$0`.
        if (!isNaN(dollarToken)) {
          if (dollarToken &gt; numCaptures) {
            throw new SyntaxError(&quot;Backreference to undefined group &quot;.concat($0));
          }
          return args[dollarToken] || &#039;&#039;;
        }

        // `$` followed by an unsupported char is an error, unlike native JS
        throw new SyntaxError(&quot;Invalid token &quot;.concat($0));
      }
    });
  }
  if (isRegex) {
    if (search.global) {
      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
      search.lastIndex = 0;
    } else {
      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
      search.lastIndex = origLastIndex;
    }
  }
  return result;
};

/**
 * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.
 *
 * @memberOf String
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {!Array} Array of substrings.
 */
fixed.split = function (separator, limit) {
  if (!XRegExp.isRegExp(separator)) {
    // Browsers handle nonregex split correctly, so use the faster native method
    return String.prototype.split.apply(this, arguments);
  }
  var str = String(this);
  var output = [];
  var origLastIndex = separator.lastIndex;
  var lastLastIndex = 0;
  var lastLength;

  // Values for `limit`, per the spec:
  // If undefined: pow(2,32) - 1
  // If 0, Infinity, or NaN: 0
  // If positive number: limit = floor(limit); if (limit &gt;= pow(2,32)) limit -= pow(2,32);
  // If negative number: pow(2,32) - floor(abs(limit))
  // If other: Type-convert, then use the above rules
  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
  limit = (limit === undefined ? -1 : limit) &gt;&gt;&gt; 0;
  (0, _forEach[&quot;default&quot;])(XRegExp).call(XRegExp, str, separator, function (match) {
    // This condition is not the same as `if (match[0].length)`
    if (match.index + match[0].length &gt; lastLastIndex) {
      output.push((0, _slice[&quot;default&quot;])(str).call(str, lastLastIndex, match.index));
      if (match.length &gt; 1 &amp;&amp; match.index &lt; str.length) {
        Array.prototype.push.apply(output, (0, _slice[&quot;default&quot;])(match).call(match, 1));
      }
      lastLength = match[0].length;
      lastLastIndex = match.index + lastLength;
    }
  });
  if (lastLastIndex === str.length) {
    if (!separator.test(&#039;&#039;) || lastLength) {
      output.push(&#039;&#039;);
    }
  } else {
    output.push((0, _slice[&quot;default&quot;])(str).call(str, lastLastIndex));
  }
  separator.lastIndex = origLastIndex;
  return output.length &gt; limit ? (0, _slice[&quot;default&quot;])(output).call(output, 0, limit) : output;
};

// ==--------------------------==
// Built-in syntax/flag tokens
// ==--------------------------==

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function (match, scope) {
  // \B is allowed in default scope only
  if (match[1] === &#039;B&#039; &amp;&amp; scope === defaultScope) {
    return match[0];
  }
  throw new SyntaxError(&quot;Invalid escape &quot;.concat(match[0]));
}, {
  scope: &#039;all&#039;,
  leadChar: &#039;\\&#039;
});

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function (match, scope, flags) {
  var code = dec(match[1]);
  if (code &gt; 0x10FFFF) {
    throw new SyntaxError(&quot;Invalid Unicode code point &quot;.concat(match[0]));
  }
  if (code &lt;= 0xFFFF) {
    // Converting to \uNNNN avoids needing to escape the literal character and keep it
    // separate from preceding tokens
    return &quot;\\u&quot;.concat(pad4(hex(code)));
  }
  // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
  if (hasNativeU &amp;&amp; (0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;u&#039;) !== -1) {
    return match[0];
  }
  throw new SyntaxError(&#039;Cannot use Unicode code point above \\u{FFFF} without flag u&#039;);
}, {
  scope: &#039;all&#039;,
  leadChar: &#039;\\&#039;
});

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, {
  leadChar: &#039;(&#039;
});

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, {
  flag: &#039;x&#039;
});

/*
 * Dot, in dotAll mode (aka singleline mode, flag s) only.
 */
if (!hasNativeS) {
  XRegExp.addToken(/\./, function () {
    return &#039;[\\s\\S]&#039;;
  }, {
    flag: &#039;s&#039;,
    leadChar: &#039;.&#039;
  });
}

/*
 * Named backreference: `\k&lt;name&gt;`. Backreference names can use RegExpIdentifierName characters
 * only. Also allows numbered backreferences as `\k&lt;n&gt;`.
 */
XRegExp.addToken(/\\k&lt;([^&gt;]+)&gt;/, function (match) {
  var _context6, _context7;
  // Groups with the same name is an error, else would need `lastIndexOf`
  var index = isNaN(match[1]) ? (0, _indexOf[&quot;default&quot;])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];
  var endIndex = match.index + match[0].length;
  if (!index || index &gt; this.captureNames.length) {
    throw new SyntaxError(&quot;Backreference to undefined group &quot;.concat(match[0]));
  }
  // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
  // inadvertedly changing `(?&lt;n&gt;)\k&lt;n&gt;1` to `()\11`.
  return (0, _concat[&quot;default&quot;])(_context7 = &quot;\\&quot;.concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? &#039;&#039; : &#039;(?:)&#039;);
}, {
  leadChar: &#039;\\&#039;
});

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE &lt; 9 doesn&#039;t support backreferences above `\99` in regex syntax.
 */
XRegExp.addToken(/\\(\d+)/, function (match, scope) {
  if (!(scope === defaultScope &amp;&amp; /^[1-9]/.test(match[1]) &amp;&amp; +match[1] &lt;= this.captureNames.length) &amp;&amp; match[1] !== &#039;0&#039;) {
    throw new SyntaxError(&quot;Cannot use octal escape or backreference to undefined group &quot;.concat(match[0]));
  }
  return match[0];
}, {
  scope: &#039;all&#039;,
  leadChar: &#039;\\&#039;
});

/*
 * Named capturing group; match the opening delimiter only: `(?&lt;name&gt;`. Capture names can use the
 * RegExpIdentifierName characters only. Names can&#039;t be integers. Supports Python-style
 * `(?P&lt;name&gt;` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
XRegExp.addToken(/\(\?P?&lt;((?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0897-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF65-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDD40-\uDD65\uDD69-\uDD6D\uDD6F-\uDD85\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEC2-\uDEC4\uDEFC-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7-\uDFC0\uDFC2\uDFC5\uDFC7-\uDFCA\uDFCC-\uDFD3\uDFE1\uDFE2]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDED0-\uDEE3\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0\uDFF0-\uDFF9]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF42\uDF50-\uDF5A\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC40-\uDC55\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD39]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDD70-\uDD79\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDCF0-\uDCF9\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDCD0-\uDCF9\uDDD0-\uDDFA\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]|\uDB40[\uDD00-\uDDEF])*)&gt;/, function (match) {
  var _context8;
  if (!XRegExp.isInstalled(&#039;namespacing&#039;) &amp;&amp; (match[1] === &#039;length&#039; || match[1] === &#039;__proto__&#039;)) {
    throw new SyntaxError(&quot;Cannot use reserved word as capture name &quot;.concat(match[0]));
  }
  if ((0, _indexOf[&quot;default&quot;])(_context8 = this.captureNames).call(_context8, match[1]) !== -1) {
    throw new SyntaxError(&quot;Cannot use same name for multiple groups &quot;.concat(match[0]));
  }
  this.captureNames.push(match[1]);
  this.hasNamedCapture = true;
  return &#039;(&#039;;
}, {
  leadChar: &#039;(&#039;
});

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds named capture only mode (flag n).
 */
XRegExp.addToken(/\((?!\?)/, function (match, scope, flags) {
  if ((0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;n&#039;) !== -1) {
    return &#039;(?:&#039;;
  }
  this.captureNames.push(null);
  return &#039;(&#039;;
}, {
  optionalFlags: &#039;n&#039;,
  leadChar: &#039;(&#039;
});
var _default = exports[&quot;default&quot;] = XRegExp;
module.exports = exports.default;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
