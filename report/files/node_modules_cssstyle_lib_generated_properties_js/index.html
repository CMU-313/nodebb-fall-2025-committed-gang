<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cssstyle/lib/generated/properties.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cssstyle/lib/generated/properties.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2674</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">138.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">29.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
// autogenerated - 2025-06-25
// https://www.w3.org/Style/CSS/all-properties.en.html

var external_dependency_parsers_0 = require(&quot;../parsers.js&quot;);
var external_dependency_strings_1 = require(&quot;../utils/strings.js&quot;);
var backgroundImage_export_parse, backgroundImage_export_isValid, backgroundImage_export_definition;
backgroundImage_export_parse = function parse(v) {
  return external_dependency_parsers_0.parseImage(v);
};
backgroundImage_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v, [&quot;none&quot;]) === &quot;string&quot;) {
    return true;
  }
  return typeof backgroundImage_export_parse(v) === &quot;string&quot;;
};
backgroundImage_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;background&quot;, &quot;&quot;);
      this._setProperty(&quot;background-image&quot;, v);
    } else {
      this._setProperty(&quot;background-image&quot;, backgroundImage_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;background-image&quot;);
  },
  enumerable: true,
  configurable: true
};
var backgroundPosition_export_parse, backgroundPosition_export_isValid, backgroundPosition_export_definition;
backgroundPosition_export_parse = function parse(v) {
  const parts = external_dependency_parsers_0.splitValue(v);
  if (!parts.length || parts.length &gt; 2) {
    return;
  }
  const validKeywordsX = [&quot;left&quot;, &quot;center&quot;, &quot;right&quot;];
  const validKeywordsY = [&quot;top&quot;, &quot;center&quot;, &quot;bottom&quot;];
  if (parts.length === 1) {
    const dim = external_dependency_parsers_0.parseMeasurement(parts[0]);
    if (dim) {
      return dim;
    }
    const validKeywords = new Set([...validKeywordsX, ...validKeywordsY]);
    return external_dependency_parsers_0.parseKeyword(v, [...validKeywords]);
  }
  const [partX, partY] = parts;
  const posX = external_dependency_parsers_0.parseMeasurement(partX) || external_dependency_parsers_0.parseKeyword(partX, validKeywordsX);
  if (posX) {
    const posY = external_dependency_parsers_0.parseMeasurement(partY) || external_dependency_parsers_0.parseKeyword(partY, validKeywordsY);
    if (posY) {
      return `${posX} ${posY}`;
    }
  }
};
backgroundPosition_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof backgroundPosition_export_parse(v) === &quot;string&quot;;
};
backgroundPosition_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;background&quot;, &quot;&quot;);
      this._setProperty(&quot;background-position&quot;, v);
    } else {
      this._setProperty(&quot;background-position&quot;, backgroundPosition_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;background-position&quot;);
  },
  enumerable: true,
  configurable: true
};
var backgroundRepeat_export_parse, backgroundRepeat_export_isValid, backgroundRepeat_export_definition;
backgroundRepeat_export_parse = function parse(v) {
  const keywords = [&quot;repeat&quot;, &quot;repeat-x&quot;, &quot;repeat-y&quot;, &quot;no-repeat&quot;, &quot;space&quot;, &quot;round&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
backgroundRepeat_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof backgroundRepeat_export_parse(v) === &quot;string&quot;;
};
backgroundRepeat_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;background&quot;, &quot;&quot;);
      this._setProperty(&quot;background-repeat&quot;, v);
    } else {
      this._setProperty(&quot;background-repeat&quot;, backgroundRepeat_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;background-repeat&quot;);
  },
  enumerable: true,
  configurable: true
};
var backgroundAttachment_export_parse, backgroundAttachment_export_isValid, backgroundAttachment_export_definition;
backgroundAttachment_export_parse = function parse(v) {
  const keywords = [&quot;fixed&quot;, &quot;scroll&quot;, &quot;local&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
backgroundAttachment_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof backgroundAttachment_export_parse(v) === &quot;string&quot;;
};
backgroundAttachment_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;background&quot;, &quot;&quot;);
      this._setProperty(&quot;background-attachment&quot;, v);
    } else {
      this._setProperty(&quot;background-attachment&quot;, backgroundAttachment_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;background-attachment&quot;);
  },
  enumerable: true,
  configurable: true
};
var backgroundColor_export_parse, backgroundColor_export_isValid, backgroundColor_export_definition;
backgroundColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
backgroundColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
backgroundColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;background&quot;, &quot;&quot;);
      this._setProperty(&quot;background-color&quot;, v);
    } else {
      this._setProperty(&quot;background-color&quot;, backgroundColor_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;background-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var background_export_definition;
// FIXME:
// * support multiple backgrounds
// * also fix longhands

const background_local_var_shorthandFor = new Map([[&quot;background-image&quot;, {
  parse: backgroundImage_export_parse,
  isValid: backgroundImage_export_isValid,
  definition: backgroundImage_export_definition
}], [&quot;background-position&quot;, {
  parse: backgroundPosition_export_parse,
  isValid: backgroundPosition_export_isValid,
  definition: backgroundPosition_export_definition
}], [&quot;background-repeat&quot;, {
  parse: backgroundRepeat_export_parse,
  isValid: backgroundRepeat_export_isValid,
  definition: backgroundRepeat_export_definition
}], [&quot;background-attachment&quot;, {
  parse: backgroundAttachment_export_parse,
  isValid: backgroundAttachment_export_isValid,
  definition: backgroundAttachment_export_definition
}], [&quot;background-color&quot;, {
  parse: backgroundColor_export_parse,
  isValid: backgroundColor_export_isValid,
  definition: backgroundColor_export_definition
}]]);
background_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (/^none$/i.test(v)) {
      for (const [key] of background_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;background&quot;, external_dependency_strings_1.asciiLowercase(v));
    } else if (external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of background_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;background&quot;, v);
    } else {
      this._shorthandSetter(&quot;background&quot;, v, background_local_var_shorthandFor);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;background&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;background&quot;, background_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var borderWidth_export_parse, borderWidth_export_isValid, borderWidth_export_definition;
borderWidth_export_parse = function parse(v) {
  const keywords = [&quot;thin&quot;, &quot;medium&quot;, &quot;thick&quot;];
  const key = external_dependency_parsers_0.parseKeyword(v, keywords);
  if (key) {
    return key;
  }
  return external_dependency_parsers_0.parseLength(v, true);
};
borderWidth_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderWidth_export_parse(v) === &quot;string&quot;;
};
borderWidth_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-width&quot;, v);
    } else {
      const positions = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
      this._implicitSetter(&quot;border&quot;, &quot;width&quot;, v, borderWidth_export_isValid, borderWidth_export_parse, positions);
    }
  },
  get() {
    return this.getPropertyValue(&quot;border-width&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderStyle_export_parse, borderStyle_export_isValid, borderStyle_export_definition;
borderStyle_export_parse = function parse(v) {
  const keywords = [&quot;none&quot;, &quot;hidden&quot;, &quot;dotted&quot;, &quot;dashed&quot;, &quot;solid&quot;, &quot;double&quot;, &quot;groove&quot;, &quot;ridge&quot;, &quot;inset&quot;, &quot;outset&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderStyle_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderStyle_export_parse(v) === &quot;string&quot;;
};
borderStyle_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (/^none$/i.test(v)) {
      v = &quot;&quot;;
    }
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-style&quot;, v);
      return;
    }
    const positions = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
    this._implicitSetter(&quot;border&quot;, &quot;style&quot;, v, borderStyle_export_isValid, borderStyle_export_parse, positions);
  },
  get() {
    return this.getPropertyValue(&quot;border-style&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderColor_export_parse, borderColor_export_isValid, borderColor_export_definition;
borderColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
borderColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
borderColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-color&quot;, v);
    } else {
      const positions = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
      this._implicitSetter(&quot;border&quot;, &quot;color&quot;, v, borderColor_export_isValid, borderColor_export_parse, positions);
    }
  },
  get() {
    return this.getPropertyValue(&quot;border-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var border_export_definition;
const border_local_var_shorthandFor = new Map([[&quot;border-width&quot;, {
  parse: borderWidth_export_parse,
  isValid: borderWidth_export_isValid,
  definition: borderWidth_export_definition
}], [&quot;border-style&quot;, {
  parse: borderStyle_export_parse,
  isValid: borderStyle_export_isValid,
  definition: borderStyle_export_definition
}], [&quot;border-color&quot;, {
  parse: borderColor_export_parse,
  isValid: borderColor_export_isValid,
  definition: borderColor_export_definition
}]]);
border_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (/^none$/i.test(v)) {
      v = &quot;&quot;;
    }
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of border_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;border&quot;, v);
    } else {
      this._midShorthandSetter(&quot;border&quot;, v, border_local_var_shorthandFor, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;border&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;border&quot;, border_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var borderTopWidth_export_parse, borderTopWidth_export_isValid, borderTopWidth_export_definition;
borderTopWidth_export_parse = function parse(v) {
  const keywords = [&quot;thin&quot;, &quot;medium&quot;, &quot;thick&quot;];
  const key = external_dependency_parsers_0.parseKeyword(v, keywords);
  if (key) {
    return key;
  }
  return external_dependency_parsers_0.parseLength(v, true);
};
borderTopWidth_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderTopWidth_export_parse(v) === &quot;string&quot;;
};
borderTopWidth_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-top&quot;, &quot;&quot;);
      this._setProperty(&quot;border-width&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-top-width&quot;, borderTopWidth_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-top-width&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderTopStyle_export_parse, borderTopStyle_export_isValid, borderTopStyle_export_definition;
borderTopStyle_export_parse = function parse(v) {
  const keywords = [&quot;none&quot;, &quot;hidden&quot;, &quot;dotted&quot;, &quot;dashed&quot;, &quot;solid&quot;, &quot;double&quot;, &quot;groove&quot;, &quot;ridge&quot;, &quot;inset&quot;, &quot;outset&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderTopStyle_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderTopStyle_export_parse(v) === &quot;string&quot;;
};
borderTopStyle_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    const val = borderTopStyle_export_parse(v);
    if (val === &quot;none&quot; || val === &quot;hidden&quot; || v === &quot;&quot;) {
      this._setProperty(&quot;border-top-style&quot;, &quot;&quot;);
      this._setProperty(&quot;border-top-color&quot;, &quot;&quot;);
      this._setProperty(&quot;border-top-width&quot;, &quot;&quot;);
      return;
    }
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-top&quot;, &quot;&quot;);
      this._setProperty(&quot;border-style&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-top-style&quot;, val);
  },
  get() {
    return this.getPropertyValue(&quot;border-top-style&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderTopColor_export_parse, borderTopColor_export_isValid, borderTopColor_export_definition;
borderTopColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
borderTopColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
borderTopColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-top&quot;, &quot;&quot;);
      this._setProperty(&quot;border-color&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-top-color&quot;, borderTopColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-top-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderBottom_export_definition;
const borderBottom_local_var_shorthandFor = new Map([[&quot;border-bottom-width&quot;, {
  parse: borderTopWidth_export_parse,
  isValid: borderTopWidth_export_isValid,
  definition: borderTopWidth_export_definition
}], [&quot;border-bottom-style&quot;, {
  parse: borderTopStyle_export_parse,
  isValid: borderTopStyle_export_isValid,
  definition: borderTopStyle_export_definition
}], [&quot;border-bottom-color&quot;, {
  parse: borderTopColor_export_parse,
  isValid: borderTopColor_export_isValid,
  definition: borderTopColor_export_definition
}]]);
borderBottom_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of borderBottom_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-bottom&quot;, v);
    } else {
      this._shorthandSetter(&quot;border-bottom&quot;, v, borderBottom_local_var_shorthandFor);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;border-bottom&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;border-bottom&quot;, borderBottom_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var borderBottomColor_export_parse, borderBottomColor_export_isValid, borderBottomColor_export_definition;
borderBottomColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
borderBottomColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
borderBottomColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-bottom&quot;, &quot;&quot;);
      this._setProperty(&quot;border-color&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-bottom-color&quot;, borderBottomColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-bottom-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderBottomStyle_export_parse, borderBottomStyle_export_isValid, borderBottomStyle_export_definition;
borderBottomStyle_export_parse = function parse(v) {
  const keywords = [&quot;none&quot;, &quot;hidden&quot;, &quot;dotted&quot;, &quot;dashed&quot;, &quot;solid&quot;, &quot;double&quot;, &quot;groove&quot;, &quot;ridge&quot;, &quot;inset&quot;, &quot;outset&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderBottomStyle_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderBottomStyle_export_parse(v) === &quot;string&quot;;
};
borderBottomStyle_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    const val = borderBottomStyle_export_parse(v);
    if (val === &quot;none&quot; || val === &quot;hidden&quot;) {
      this._setProperty(&quot;border-bottom-style&quot;, &quot;&quot;);
      this._setProperty(&quot;border-bottom-color&quot;, &quot;&quot;);
      this._setProperty(&quot;border-bottom-width&quot;, &quot;&quot;);
      return;
    }
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-bottom&quot;, &quot;&quot;);
      this._setProperty(&quot;border-style&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-bottom-style&quot;, val);
  },
  get() {
    return this.getPropertyValue(&quot;border-bottom-style&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderBottomWidth_export_parse, borderBottomWidth_export_isValid, borderBottomWidth_export_definition;
borderBottomWidth_export_parse = function parse(v) {
  const keywords = [&quot;thin&quot;, &quot;medium&quot;, &quot;thick&quot;];
  const key = external_dependency_parsers_0.parseKeyword(v, keywords);
  if (key) {
    return key;
  }
  return external_dependency_parsers_0.parseLength(v, true);
};
borderBottomWidth_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderBottomWidth_export_parse(v) === &quot;string&quot;;
};
borderBottomWidth_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-bottom&quot;, &quot;&quot;);
      this._setProperty(&quot;border-width&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-bottom-width&quot;, borderBottomWidth_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-bottom-width&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderCollapse_export_parse, borderCollapse_export_isValid, borderCollapse_export_definition;
borderCollapse_export_parse = function parse(v) {
  return external_dependency_parsers_0.parseKeyword(v, [&quot;collapse&quot;, &quot;separate&quot;]);
};
borderCollapse_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderCollapse_export_parse(v) === &quot;string&quot;;
};
borderCollapse_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;border-collapse&quot;, borderCollapse_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-collapse&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderLeft_export_definition;
const borderLeft_local_var_shorthandFor = new Map([[&quot;border-left-width&quot;, {
  parse: borderTopWidth_export_parse,
  isValid: borderTopWidth_export_isValid,
  definition: borderTopWidth_export_definition
}], [&quot;border-left-style&quot;, {
  parse: borderTopStyle_export_parse,
  isValid: borderTopStyle_export_isValid,
  definition: borderTopStyle_export_definition
}], [&quot;border-left-color&quot;, {
  parse: borderTopColor_export_parse,
  isValid: borderTopColor_export_isValid,
  definition: borderTopColor_export_definition
}]]);
borderLeft_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of borderLeft_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-left&quot;, v);
    } else {
      this._shorthandSetter(&quot;border-left&quot;, v, borderLeft_local_var_shorthandFor);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;border-left&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;border-left&quot;, borderLeft_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var borderLeftColor_export_parse, borderLeftColor_export_isValid, borderLeftColor_export_definition;
borderLeftColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
borderLeftColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
borderLeftColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-left&quot;, &quot;&quot;);
      this._setProperty(&quot;border-color&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-left-color&quot;, borderLeftColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-left-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderLeftStyle_export_parse, borderLeftStyle_export_isValid, borderLeftStyle_export_definition;
borderLeftStyle_export_parse = function parse(v) {
  const keywords = [&quot;none&quot;, &quot;hidden&quot;, &quot;dotted&quot;, &quot;dashed&quot;, &quot;solid&quot;, &quot;double&quot;, &quot;groove&quot;, &quot;ridge&quot;, &quot;inset&quot;, &quot;outset&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderLeftStyle_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderLeftStyle_export_parse(v) === &quot;string&quot;;
};
borderLeftStyle_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    const val = borderLeftStyle_export_parse(v);
    if (val === &quot;none&quot; || val === &quot;hidden&quot;) {
      this._setProperty(&quot;border-left-style&quot;, &quot;&quot;);
      this._setProperty(&quot;border-left-color&quot;, &quot;&quot;);
      this._setProperty(&quot;border-left-width&quot;, &quot;&quot;);
      return;
    }
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-left&quot;, &quot;&quot;);
      this._setProperty(&quot;border-style&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-left-style&quot;, val);
  },
  get() {
    return this.getPropertyValue(&quot;border-left-style&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderLeftWidth_export_parse, borderLeftWidth_export_isValid, borderLeftWidth_export_definition;
borderLeftWidth_export_parse = function parse(v) {
  const keywords = [&quot;thin&quot;, &quot;medium&quot;, &quot;thick&quot;];
  const key = external_dependency_parsers_0.parseKeyword(v, keywords);
  if (key) {
    return key;
  }
  return external_dependency_parsers_0.parseLength(v, true);
};
borderLeftWidth_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderLeftWidth_export_parse(v) === &quot;string&quot;;
};
borderLeftWidth_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-left&quot;, &quot;&quot;);
      this._setProperty(&quot;border-width&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-left-width&quot;, borderLeftWidth_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-left-width&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderRight_export_definition;
const borderRight_local_var_shorthandFor = new Map([[&quot;border-right-width&quot;, {
  parse: borderTopWidth_export_parse,
  isValid: borderTopWidth_export_isValid,
  definition: borderTopWidth_export_definition
}], [&quot;border-right-style&quot;, {
  parse: borderTopStyle_export_parse,
  isValid: borderTopStyle_export_isValid,
  definition: borderTopStyle_export_definition
}], [&quot;border-right-color&quot;, {
  parse: borderTopColor_export_parse,
  isValid: borderTopColor_export_isValid,
  definition: borderTopColor_export_definition
}]]);
borderRight_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of borderRight_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-right&quot;, v);
    } else {
      this._shorthandSetter(&quot;border-right&quot;, v, borderRight_local_var_shorthandFor);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;border-right&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;border-right&quot;, borderRight_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var borderRightColor_export_parse, borderRightColor_export_isValid, borderRightColor_export_definition;
borderRightColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
borderRightColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
borderRightColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-right&quot;, &quot;&quot;);
      this._setProperty(&quot;border-color&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-right-color&quot;, borderRightColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-right-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderRightStyle_export_parse, borderRightStyle_export_isValid, borderRightStyle_export_definition;
borderRightStyle_export_parse = function parse(v) {
  const keywords = [&quot;none&quot;, &quot;hidden&quot;, &quot;dotted&quot;, &quot;dashed&quot;, &quot;solid&quot;, &quot;double&quot;, &quot;groove&quot;, &quot;ridge&quot;, &quot;inset&quot;, &quot;outset&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
borderRightStyle_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderRightStyle_export_parse(v) === &quot;string&quot;;
};
borderRightStyle_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    const val = borderRightStyle_export_parse(v);
    if (val === &quot;none&quot; || val === &quot;hidden&quot;) {
      this._setProperty(&quot;border-right-style&quot;, &quot;&quot;);
      this._setProperty(&quot;border-right-color&quot;, &quot;&quot;);
      this._setProperty(&quot;border-right-width&quot;, &quot;&quot;);
      return;
    }
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-right&quot;, &quot;&quot;);
      this._setProperty(&quot;border-style&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-right-style&quot;, val);
  },
  get() {
    return this.getPropertyValue(&quot;border-right-style&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderRightWidth_export_parse, borderRightWidth_export_isValid, borderRightWidth_export_definition;
borderRightWidth_export_parse = function parse(v) {
  const keywords = [&quot;thin&quot;, &quot;medium&quot;, &quot;thick&quot;];
  const key = external_dependency_parsers_0.parseKeyword(v, keywords);
  if (key) {
    return key;
  }
  return external_dependency_parsers_0.parseLength(v, true);
};
borderRightWidth_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderRightWidth_export_parse(v) === &quot;string&quot;;
};
borderRightWidth_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-right&quot;, &quot;&quot;);
      this._setProperty(&quot;border-width&quot;, &quot;&quot;);
    }
    this._setProperty(&quot;border-right-width&quot;, borderRightWidth_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-right-width&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderSpacing_export_parse, borderSpacing_export_isValid, borderSpacing_export_definition;
borderSpacing_export_parse = function parse(v) {
  if (v === &quot;&quot;) {
    return v;
  }
  const key = external_dependency_parsers_0.parseKeyword(v);
  if (key) {
    return key;
  }
  const parts = external_dependency_parsers_0.splitValue(v);
  if (!parts.length || parts.length &gt; 2) {
    return;
  }
  const val = [];
  for (const part of parts) {
    const dim = external_dependency_parsers_0.parseLength(part);
    if (!dim) {
      return;
    }
    val.push(dim);
  }
  return val.join(&quot; &quot;);
};
borderSpacing_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof borderSpacing_export_parse(v) === &quot;string&quot;;
};
borderSpacing_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;border-spacing&quot;, borderSpacing_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;border-spacing&quot;);
  },
  enumerable: true,
  configurable: true
};
var borderTop_export_definition;
const borderTop_local_var_shorthandFor = new Map([[&quot;border-top-width&quot;, {
  parse: borderTopWidth_export_parse,
  isValid: borderTopWidth_export_isValid,
  definition: borderTopWidth_export_definition
}], [&quot;border-top-style&quot;, {
  parse: borderTopStyle_export_parse,
  isValid: borderTopStyle_export_isValid,
  definition: borderTopStyle_export_definition
}], [&quot;border-top-color&quot;, {
  parse: borderTopColor_export_parse,
  isValid: borderTopColor_export_isValid,
  definition: borderTopColor_export_definition
}]]);
borderTop_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of borderTop_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;border&quot;, &quot;&quot;);
      this._setProperty(&quot;border-top&quot;, v);
    } else {
      this._shorthandSetter(&quot;border-top&quot;, v, borderTop_local_var_shorthandFor);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;border-top&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;border-top&quot;, borderTop_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var bottom_export_parse, bottom_export_isValid, bottom_export_definition;
bottom_export_parse = function parse(v) {
  const dim = external_dependency_parsers_0.parseMeasurement(v);
  if (dim) {
    return dim;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
bottom_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof bottom_export_parse(v) === &quot;string&quot;;
};
bottom_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;bottom&quot;, bottom_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;bottom&quot;);
  },
  enumerable: true,
  configurable: true
};
var clear_export_parse, clear_export_isValid, clear_export_definition;
clear_export_parse = function parse(v) {
  const keywords = [&quot;inline-start&quot;, &quot;inline-end&quot;, &quot;block-start&quot;, &quot;block-end&quot;, &quot;left&quot;, &quot;right&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;both-inline&quot;, &quot;both-block&quot;, &quot;both&quot;, &quot;none&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
clear_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof clear_export_parse(v) === &quot;string&quot;;
};
clear_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;clear&quot;, clear_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;clear&quot;);
  },
  enumerable: true,
  configurable: true
};
var clip_export_parse, clip_export_isValid, clip_export_definition;
// deprecated
// @see https://drafts.fxtf.org/css-masking/#clip-property

clip_export_parse = function parse(v) {
  if (v === &quot;&quot;) {
    return v;
  }
  const val = external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
  if (val) {
    return val;
  }
  // parse legacy &lt;shape&gt;
  v = external_dependency_strings_1.asciiLowercase(v);
  const matches = v.match(/^rect\(\s*(.*)\s*\)$/);
  if (!matches) {
    return;
  }
  const parts = matches[1].split(/\s*,\s*/);
  if (parts.length !== 4) {
    return;
  }
  const valid = parts.every(function (part, index) {
    const measurement = external_dependency_parsers_0.parseMeasurement(part.trim());
    parts[index] = measurement;
    return typeof measurement === &quot;string&quot;;
  });
  if (!valid) {
    return;
  }
  return `rect(${parts.join(&quot;, &quot;)})`;
};
clip_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof clip_export_parse(v) === &quot;string&quot;;
};
clip_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;clip&quot;, clip_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;clip&quot;);
  },
  enumerable: true,
  configurable: true
};
var color_export_parse, color_export_isValid, color_export_definition;
color_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
color_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
color_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;color&quot;, color_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;color&quot;);
  },
  enumerable: true,
  configurable: true
};
var flexGrow_export_parse, flexGrow_export_isValid, flexGrow_export_definition;
flexGrow_export_parse = function parse(v) {
  return external_dependency_parsers_0.parseNumber(v, true);
};
flexGrow_export_isValid = function isValid(v) {
  return typeof flexGrow_export_parse(v) === &quot;string&quot;;
};
flexGrow_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;flex&quot;, &quot;&quot;);
      this._setProperty(&quot;flex-grow&quot;, v);
    } else {
      this._setProperty(&quot;flex-grow&quot;, flexGrow_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;flex-grow&quot;);
  },
  enumerable: true,
  configurable: true
};
var flexShrink_export_parse, flexShrink_export_isValid, flexShrink_export_definition;
flexShrink_export_parse = function parse(v) {
  return external_dependency_parsers_0.parseNumber(v, true);
};
flexShrink_export_isValid = function isValid(v) {
  return typeof flexShrink_export_parse(v) === &quot;string&quot;;
};
flexShrink_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;flex&quot;, &quot;&quot;);
      this._setProperty(&quot;flex-shrink&quot;, v);
    } else {
      this._setProperty(&quot;flex-shrink&quot;, flexShrink_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;flex-shrink&quot;);
  },
  enumerable: true,
  configurable: true
};
var flexBasis_export_parse, flexBasis_export_isValid, flexBasis_export_definition;
flexBasis_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v);
  if (val) {
    return val;
  }
  const keywords = [&quot;content&quot;, &quot;auto&quot;, &quot;min-content&quot;, &quot;max-content&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
flexBasis_export_isValid = function isValid(v) {
  return typeof flexBasis_export_parse(v) === &quot;string&quot;;
};
flexBasis_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;flex&quot;, &quot;&quot;);
      this._setProperty(&quot;flex-basis&quot;, v);
    } else {
      this._setProperty(&quot;flex-basis&quot;, flexBasis_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;flex-basis&quot;);
  },
  enumerable: true,
  configurable: true
};
var flex_export_parse, flex_export_isValid, flex_export_definition;
const flex_local_var_shorthandFor = new Map([[&quot;flex-grow&quot;, {
  parse: flexGrow_export_parse,
  isValid: flexGrow_export_isValid,
  definition: flexGrow_export_definition
}], [&quot;flex-shrink&quot;, {
  parse: flexShrink_export_parse,
  isValid: flexShrink_export_isValid,
  definition: flexShrink_export_definition
}], [&quot;flex-basis&quot;, {
  parse: flexBasis_export_parse,
  isValid: flexBasis_export_isValid,
  definition: flexBasis_export_definition
}]]);
flex_export_parse = function parse(v) {
  const key = external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;, &quot;none&quot;]);
  if (key) {
    if (key === &quot;auto&quot;) {
      return &quot;1 1 auto&quot;;
    }
    if (key === &quot;none&quot;) {
      return &quot;0 0 auto&quot;;
    }
    if (key === &quot;initial&quot;) {
      return &quot;0 1 auto&quot;;
    }
    return;
  }
  const obj = external_dependency_parsers_0.parseShorthand(v, flex_local_var_shorthandFor);
  if (obj) {
    const flex = {
      &quot;flex-grow&quot;: &quot;1&quot;,
      &quot;flex-shrink&quot;: &quot;1&quot;,
      &quot;flex-basis&quot;: &quot;0%&quot;
    };
    const items = Object.entries(obj);
    for (const [property, value] of items) {
      flex[property] = value;
    }
    return [...Object.values(flex)].join(&quot; &quot;);
  }
};
flex_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof flex_export_parse(v) === &quot;string&quot;;
};
flex_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._shorthandSetter(&quot;flex&quot;, &quot;&quot;, flex_local_var_shorthandFor);
      this._setProperty(&quot;flex&quot;, v);
    } else {
      this._shorthandSetter(&quot;flex&quot;, flex_export_parse(v), flex_local_var_shorthandFor);
    }
  },
  get() {
    let val = this.getPropertyValue(&quot;flex&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    val = this._shorthandGetter(&quot;flex&quot;, flex_local_var_shorthandFor);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var float_export_parse, float_export_isValid, float_export_definition;
float_export_parse = function parse(v) {
  const keywords = [&quot;left&quot;, &quot;right&quot;, &quot;none&quot;, &quot;inline-start&quot;, &quot;inline-end&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
float_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof float_export_parse(v) === &quot;string&quot;;
};
float_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;float&quot;, float_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;float&quot;);
  },
  enumerable: true,
  configurable: true
};
var floodColor_export_parse, floodColor_export_isValid, floodColor_export_definition;
floodColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
floodColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
floodColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;flood-color&quot;, floodColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;flood-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var fontStyle_export_parse, fontStyle_export_isValid, fontStyle_export_definition;
fontStyle_export_parse = function parse(v) {
  const keywords = [&quot;normal&quot;, &quot;italic&quot;, &quot;oblique&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontStyle_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof fontStyle_export_parse(v) === &quot;string&quot;;
};
fontStyle_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;font&quot;, &quot;&quot;);
      this._setProperty(&quot;font-style&quot;, v);
    } else {
      this._setProperty(&quot;font-style&quot;, fontStyle_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;font-style&quot;);
  },
  enumerable: true,
  configurable: true
};
var fontVariant_export_parse, fontVariant_export_isValid, fontVariant_export_definition;
fontVariant_export_parse = function parse(v) {
  const num = external_dependency_parsers_0.parseNumber(v, true);
  if (num &amp;&amp; parseFloat(num) &lt;= 1000) {
    return num;
  }
  const keywords = [&quot;normal&quot;, &quot;none&quot;, &quot;small-caps&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontVariant_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof fontVariant_export_parse(v) === &quot;string&quot;;
};
fontVariant_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;font&quot;, &quot;&quot;);
      this._setProperty(&quot;font-valiant&quot;, v);
    } else {
      this._setProperty(&quot;font-variant&quot;, fontVariant_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;font-variant&quot;);
  },
  enumerable: true,
  configurable: true
};
var fontWeight_export_parse, fontWeight_export_isValid, fontWeight_export_definition;
fontWeight_export_parse = function parse(v) {
  const num = external_dependency_parsers_0.parseNumber(v, true);
  if (num &amp;&amp; parseFloat(num) &lt;= 1000) {
    return num;
  }
  const keywords = [&quot;normal&quot;, &quot;bold&quot;, &quot;lighter&quot;, &quot;bolder&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontWeight_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof fontWeight_export_parse(v) === &quot;string&quot;;
};
fontWeight_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;font&quot;, &quot;&quot;);
      this._setProperty(&quot;font-weight&quot;, v);
    } else {
      this._setProperty(&quot;font-weight&quot;, fontWeight_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;font-weight&quot;);
  },
  enumerable: true,
  configurable: true
};
var fontSize_export_parse, fontSize_export_isValid, fontSize_export_definition;
fontSize_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v, true);
  if (val) {
    return val;
  }
  const keywords = [&quot;xx-small&quot;, &quot;x-small&quot;, &quot;small&quot;, &quot;medium&quot;, &quot;large&quot;, &quot;x-large&quot;, &quot;xx-large&quot;, &quot;xxx-large&quot;, &quot;smaller&quot;, &quot;larger&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
fontSize_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof fontSize_export_parse(v) === &quot;string&quot;;
};
fontSize_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;font&quot;, &quot;&quot;);
      this._setProperty(&quot;font-size&quot;, v);
    } else {
      this._setProperty(&quot;font-size&quot;, fontSize_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;font-size&quot;);
  },
  enumerable: true,
  configurable: true
};
var lineHeight_export_parse, lineHeight_export_isValid, lineHeight_export_definition;
lineHeight_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseKeyword(v, [&quot;normal&quot;]);
  if (val) {
    return val;
  }
  const num = external_dependency_parsers_0.parseNumber(v, true);
  if (num) {
    return num;
  }
  return external_dependency_parsers_0.parseMeasurement(v, true);
};
lineHeight_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof lineHeight_export_parse(v) === &quot;string&quot;;
};
lineHeight_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;font&quot;, &quot;&quot;);
      this._setProperty(&quot;line-height&quot;, v);
    } else {
      this._setProperty(&quot;line-height&quot;, lineHeight_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;line-height&quot;);
  },
  enumerable: true,
  configurable: true
};
var fontFamily_export_parse, fontFamily_export_isValid, fontFamily_export_definition;
fontFamily_export_parse = function parse(v) {
  if (v === &quot;&quot;) {
    return v;
  }
  const keywords = [&quot;serif&quot;, &quot;sans-serif&quot;, &quot;cursive&quot;, &quot;fantasy&quot;, &quot;monospace&quot;, &quot;system-ui&quot;, &quot;math&quot;, &quot;ui-serif&quot;, &quot;ui-sans-serif&quot;, &quot;ui-monospace&quot;, &quot;ui-rounded&quot;];
  const genericValues = [&quot;fangsong&quot;, &quot;kai&quot;, &quot;khmer-mul&quot;, &quot;nastaliq&quot;];
  const val = external_dependency_parsers_0.splitValue(v, {
    delimiter: &quot;,&quot;
  });
  const font = [];
  let valid = false;
  for (const i of val) {
    const str = external_dependency_parsers_0.parseString(i);
    if (str) {
      font.push(str);
      valid = true;
      continue;
    }
    const key = external_dependency_parsers_0.parseKeyword(i, keywords);
    if (key) {
      font.push(key);
      valid = true;
      continue;
    }
    const obj = external_dependency_parsers_0.parseFunction(i);
    if (obj) {
      const {
        name,
        value
      } = obj;
      if (name === &quot;generic&quot; &amp;&amp; genericValues.includes(value)) {
        font.push(`${name}(${value})`);
        valid = true;
        continue;
      }
    }
    // This implementation does not strictly follow the specification.
    // The spec does not require the first letter of the font-family to be
    // capitalized, and unquoted font-family names are not restricted to ASCII.
    // However, in the real world, the first letter of the ASCII font-family
    // names are capitalized, and unquoted font-family names do not contain
    // spaces, e.g. `Times`. And non-ASCII font-family names are quoted even
    // without spaces, e.g. `&quot;&quot;`.
    // @see https://drafts.csswg.org/css-fonts/#font-family-prop
    if (i !== &quot;undefined&quot; &amp;&amp; /^(?:[A-Z][A-Za-z\d-]+(?:\s+[A-Z][A-Za-z\d-]+)*|-?[a-z][a-z-]+)$/.test(i)) {
      font.push(i.trim());
      valid = true;
      continue;
    }
    if (!valid) {
      return;
    }
  }
  return font.join(&quot;, &quot;);
};
fontFamily_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof fontFamily_export_parse(v) === &quot;string&quot;;
};
fontFamily_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;font&quot;, &quot;&quot;);
      this._setProperty(&quot;font-family&quot;, v);
    } else {
      this._setProperty(&quot;font-family&quot;, fontFamily_export_parse(v));
    }
  },
  get() {
    return this.getPropertyValue(&quot;font-family&quot;);
  },
  enumerable: true,
  configurable: true
};
var font_export_parse, font_export_definition;
const font_local_var_shorthandFor = new Map([[&quot;font-style&quot;, {
  parse: fontStyle_export_parse,
  isValid: fontStyle_export_isValid,
  definition: fontStyle_export_definition
}], [&quot;font-variant&quot;, {
  parse: fontVariant_export_parse,
  isValid: fontVariant_export_isValid,
  definition: fontVariant_export_definition
}], [&quot;font-weight&quot;, {
  parse: fontWeight_export_parse,
  isValid: fontWeight_export_isValid,
  definition: fontWeight_export_definition
}], [&quot;font-size&quot;, {
  parse: fontSize_export_parse,
  isValid: fontSize_export_isValid,
  definition: fontSize_export_definition
}], [&quot;line-height&quot;, {
  parse: lineHeight_export_parse,
  isValid: lineHeight_export_isValid,
  definition: lineHeight_export_definition
}], [&quot;font-family&quot;, {
  parse: fontFamily_export_parse,
  isValid: fontFamily_export_isValid,
  definition: fontFamily_export_definition
}]]);
font_export_parse = function parse(v) {
  const keywords = [&quot;caption&quot;, &quot;icon&quot;, &quot;menu&quot;, &quot;message-box&quot;, &quot;small-caption&quot;, &quot;status-bar&quot;];
  const key = external_dependency_parsers_0.parseKeyword(v, keywords);
  if (key) {
    return key;
  }
  const [fontBlock, ...families] = external_dependency_parsers_0.splitValue(v, {
    delimiter: &quot;,&quot;
  });
  const [fontBlockA, fontBlockB] = external_dependency_parsers_0.splitValue(fontBlock, {
    delimiter: &quot;/&quot;
  });
  const font = {
    &quot;font-style&quot;: &quot;normal&quot;,
    &quot;font-variant&quot;: &quot;normal&quot;,
    &quot;font-weight&quot;: &quot;normal&quot;
  };
  const fontFamilies = new Set();
  if (fontBlockB) {
    const [lineB, ...familiesB] = fontBlockB.trim().split(&quot; &quot;);
    if (!lineB || !{
      parse: lineHeight_export_parse,
      isValid: lineHeight_export_isValid,
      definition: lineHeight_export_definition
    }.isValid(lineB) || !familiesB.length) {
      return;
    }
    const lineHeightB = {
      parse: lineHeight_export_parse,
      isValid: lineHeight_export_isValid,
      definition: lineHeight_export_definition
    }.parse(lineB);
    const familyB = familiesB.join(&quot; &quot;);
    if ({
      parse: fontFamily_export_parse,
      isValid: fontFamily_export_isValid,
      definition: fontFamily_export_definition
    }.isValid(familyB)) {
      fontFamilies.add({
        parse: fontFamily_export_parse,
        isValid: fontFamily_export_isValid,
        definition: fontFamily_export_definition
      }.parse(familyB));
    } else {
      return;
    }
    const parts = external_dependency_parsers_0.splitValue(fontBlockA.trim());
    const properties = [&quot;font-style&quot;, &quot;font-variant&quot;, &quot;font-weight&quot;, &quot;font-size&quot;];
    for (const part of parts) {
      if (part === &quot;normal&quot;) {
        continue;
      } else {
        for (const property of properties) {
          switch (property) {
            case &quot;font-style&quot;:
            case &quot;font-variant&quot;:
            case &quot;font-weight&quot;:
            case &quot;font-size&quot;:
              {
                const value = font_local_var_shorthandFor.get(property);
                if (value.isValid(part)) {
                  font[property] = value.parse(part);
                }
                break;
              }
            default:
          }
        }
      }
    }
    if (Object.hasOwn(font, &quot;font-size&quot;)) {
      font[&quot;line-height&quot;] = lineHeightB;
    } else {
      return;
    }
  } else {
    // FIXME: Switch to toReversed() when we can drop Node.js 18 support.
    const revParts = [...external_dependency_parsers_0.splitValue(fontBlockA.trim())].reverse();
    const revFontFamily = [];
    const properties = [&quot;font-style&quot;, &quot;font-variant&quot;, &quot;font-weight&quot;, &quot;line-height&quot;];
    font[&quot;font-style&quot;] = &quot;normal&quot;;
    font[&quot;font-variant&quot;] = &quot;normal&quot;;
    font[&quot;font-weight&quot;] = &quot;normal&quot;;
    font[&quot;line-height&quot;] = &quot;normal&quot;;
    let fontSizeA;
    for (const part of revParts) {
      if (fontSizeA) {
        if (part === &quot;normal&quot;) {
          continue;
        } else {
          for (const property of properties) {
            switch (property) {
              case &quot;font-style&quot;:
              case &quot;font-variant&quot;:
              case &quot;font-weight&quot;:
              case &quot;line-height&quot;:
                {
                  const value = font_local_var_shorthandFor.get(property);
                  if (value.isValid(part)) {
                    font[property] = value.parse(part);
                  }
                  break;
                }
              default:
            }
          }
        }
      } else if ({
        parse: fontSize_export_parse,
        isValid: fontSize_export_isValid,
        definition: fontSize_export_definition
      }.isValid(part)) {
        fontSizeA = {
          parse: fontSize_export_parse,
          isValid: fontSize_export_isValid,
          definition: fontSize_export_definition
        }.parse(part);
      } else if ({
        parse: fontFamily_export_parse,
        isValid: fontFamily_export_isValid,
        definition: fontFamily_export_definition
      }.isValid(part)) {
        revFontFamily.push(part);
      } else {
        return;
      }
    }
    const family = revFontFamily.reverse().join(&quot; &quot;);
    if (fontSizeA &amp;&amp; {
      parse: fontFamily_export_parse,
      isValid: fontFamily_export_isValid,
      definition: fontFamily_export_definition
    }.isValid(family)) {
      font[&quot;font-size&quot;] = fontSizeA;
      fontFamilies.add({
        parse: fontFamily_export_parse,
        isValid: fontFamily_export_isValid,
        definition: fontFamily_export_definition
      }.parse(family));
    } else {
      return;
    }
  }
  for (const family of families) {
    if ({
      parse: fontFamily_export_parse,
      isValid: fontFamily_export_isValid,
      definition: fontFamily_export_definition
    }.isValid(family)) {
      fontFamilies.add({
        parse: fontFamily_export_parse,
        isValid: fontFamily_export_isValid,
        definition: fontFamily_export_definition
      }.parse(family));
    } else {
      return;
    }
  }
  font[&quot;font-family&quot;] = [...fontFamilies].join(&quot;, &quot;);
  return font;
};
font_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (v === &quot;&quot; || external_dependency_parsers_0.hasVarFunc(v)) {
      for (const [key] of font_local_var_shorthandFor) {
        this._setProperty(key, &quot;&quot;);
      }
      this._setProperty(&quot;font&quot;, v);
    } else {
      const obj = font_export_parse(v);
      if (!obj) {
        return;
      }
      const str = new Set();
      for (const [key] of font_local_var_shorthandFor) {
        const val = obj[key];
        if (typeof val === &quot;string&quot;) {
          this._setProperty(key, val);
          if (val &amp;&amp; val !== &quot;normal&quot; &amp;&amp; !str.has(val)) {
            if (key === &quot;line-height&quot;) {
              str.add(`/ ${val}`);
            } else {
              str.add(val);
            }
          }
        }
      }
      this._setProperty(&quot;font&quot;, [...str].join(&quot; &quot;));
    }
  },
  get() {
    const val = this.getPropertyValue(&quot;font&quot;);
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return val;
    }
    const str = new Set();
    for (const [key] of font_local_var_shorthandFor) {
      const v = this.getPropertyValue(key);
      if (external_dependency_parsers_0.hasVarFunc(v)) {
        return &quot;&quot;;
      }
      if (v &amp;&amp; v !== &quot;normal&quot; &amp;&amp; !str.has(v)) {
        if (key === &quot;line-height&quot;) {
          str.add(`/ ${v}`);
        } else {
          str.add(`${v}`);
        }
      }
    }
    return [...str].join(&quot; &quot;);
  },
  enumerable: true,
  configurable: true
};
var height_export_parse, height_export_isValid, height_export_definition;
height_export_parse = function parse(v) {
  const dim = external_dependency_parsers_0.parseMeasurement(v, true);
  if (dim) {
    return dim;
  }
  const keywords = [&quot;auto&quot;, &quot;min-content&quot;, &quot;max-content&quot;, &quot;fit-content&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
height_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof height_export_parse(v) === &quot;string&quot;;
};
height_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;height&quot;, height_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;height&quot;);
  },
  enumerable: true,
  configurable: true
};
var left_export_parse, left_export_isValid, left_export_definition;
left_export_parse = function parse(v) {
  const dim = external_dependency_parsers_0.parseMeasurement(v);
  if (dim) {
    return dim;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
left_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof left_export_parse(v) === &quot;string&quot;;
};
left_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;left&quot;, left_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;left&quot;);
  },
  enumerable: true,
  configurable: true
};
var lightingColor_export_parse, lightingColor_export_isValid, lightingColor_export_definition;
lightingColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
lightingColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
lightingColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;lighting-color&quot;, lightingColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;lighting-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var margin_export_parse, margin_export_isValid, margin_export_definition;
const margin_local_var_positions = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
margin_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
margin_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof margin_export_parse(v) === &quot;string&quot;;
};
margin_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._implicitSetter(&quot;margin&quot;, &quot;&quot;, &quot;&quot;, margin_export_isValid, margin_export_parse, margin_local_var_positions);
      this._setProperty(&quot;margin&quot;, v);
    } else {
      this._implicitSetter(&quot;margin&quot;, &quot;&quot;, v, margin_export_isValid, margin_export_parse, margin_local_var_positions);
    }
  },
  get() {
    const val = this._implicitGetter(&quot;margin&quot;, margin_local_var_positions);
    if (val === &quot;&quot;) {
      return this.getPropertyValue(&quot;margin&quot;);
    }
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var marginBottom_export_parse, marginBottom_export_isValid, marginBottom_export_definition;
marginBottom_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
marginBottom_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof marginBottom_export_parse(v) === &quot;string&quot;;
};
marginBottom_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;margin&quot;, &quot;&quot;);
      this._setProperty(&quot;margin-bottom&quot;, v);
    } else {
      this._subImplicitSetter(&quot;margin&quot;, &quot;bottom&quot;, v, marginBottom_export_isValid, marginBottom_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;margin-bottom&quot;);
  },
  enumerable: true,
  configurable: true
};
var marginLeft_export_parse, marginLeft_export_isValid, marginLeft_export_definition;
marginLeft_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
marginLeft_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof marginLeft_export_parse(v) === &quot;string&quot;;
};
marginLeft_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;margin&quot;, &quot;&quot;);
      this._setProperty(&quot;margin-left&quot;, v);
    } else {
      this._subImplicitSetter(&quot;margin&quot;, &quot;left&quot;, v, marginLeft_export_isValid, marginLeft_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;margin-left&quot;);
  },
  enumerable: true,
  configurable: true
};
var marginRight_export_parse, marginRight_export_isValid, marginRight_export_definition;
marginRight_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
marginRight_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof marginRight_export_parse(v) === &quot;string&quot;;
};
marginRight_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;margin&quot;, &quot;&quot;);
      this._setProperty(&quot;margin-right&quot;, v);
    } else {
      this._subImplicitSetter(&quot;margin&quot;, &quot;right&quot;, v, marginRight_export_isValid, marginRight_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;margin-right&quot;);
  },
  enumerable: true,
  configurable: true
};
var marginTop_export_parse, marginTop_export_isValid, marginTop_export_definition;
marginTop_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
marginTop_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof marginTop_export_parse(v) === &quot;string&quot;;
};
marginTop_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;margin&quot;, &quot;&quot;);
      this._setProperty(&quot;margin-top&quot;, v);
    } else {
      this._subImplicitSetter(&quot;margin&quot;, &quot;top&quot;, v, marginTop_export_isValid, marginTop_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;margin-top&quot;);
  },
  enumerable: true,
  configurable: true
};
var opacity_export_parse, opacity_export_isValid, opacity_export_definition;
opacity_export_parse = function parse(v) {
  let num = external_dependency_parsers_0.parseNumber(v);
  if (num) {
    num = parseFloat(num);
    if (num &lt; 0) {
      return &quot;0&quot;;
    } else if (num &gt; 1) {
      return &quot;1&quot;;
    }
    return `${num}`;
  }
  let pct = external_dependency_parsers_0.parsePercent(v);
  if (pct) {
    pct = parseFloat(pct);
    if (pct &lt; 0) {
      return &quot;0%&quot;;
    } else if (pct &gt; 100) {
      return &quot;100%&quot;;
    }
    return `${pct}%`;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
opacity_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof opacity_export_parse(v) === &quot;string&quot;;
};
opacity_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;opacity&quot;, opacity_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;opacity&quot;);
  },
  enumerable: true,
  configurable: true
};
var outlineColor_export_parse, outlineColor_export_isValid, outlineColor_export_definition;
outlineColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
outlineColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
outlineColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;outline-color&quot;, outlineColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;outline-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var padding_export_parse, padding_export_isValid, padding_export_definition;
const padding_local_var_positions = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
padding_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v, true);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
padding_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof padding_export_parse(v) === &quot;string&quot;;
};
padding_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._implicitSetter(&quot;padding&quot;, &quot;&quot;, &quot;&quot;, padding_export_isValid, padding_export_parse, padding_local_var_positions);
      this._setProperty(&quot;padding&quot;, v);
    } else {
      this._implicitSetter(&quot;padding&quot;, &quot;&quot;, v, padding_export_isValid, padding_export_parse, padding_local_var_positions);
    }
  },
  get() {
    const val = this._implicitGetter(&quot;padding&quot;, padding_local_var_positions);
    if (val === &quot;&quot;) {
      return this.getPropertyValue(&quot;padding&quot;);
    }
    if (external_dependency_parsers_0.hasVarFunc(val)) {
      return &quot;&quot;;
    }
    return val;
  },
  enumerable: true,
  configurable: true
};
var paddingBottom_export_parse, paddingBottom_export_isValid, paddingBottom_export_definition;
paddingBottom_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v, true);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
paddingBottom_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof paddingBottom_export_parse(v) === &quot;string&quot;;
};
paddingBottom_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;padding&quot;, &quot;&quot;);
      this._setProperty(&quot;padding-bottom&quot;, v);
    } else {
      this._subImplicitSetter(&quot;padding&quot;, &quot;bottom&quot;, v, paddingBottom_export_isValid, paddingBottom_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;padding-bottom&quot;);
  },
  enumerable: true,
  configurable: true
};
var paddingLeft_export_parse, paddingLeft_export_isValid, paddingLeft_export_definition;
paddingLeft_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v, true);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
paddingLeft_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof paddingLeft_export_parse(v) === &quot;string&quot;;
};
paddingLeft_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;padding&quot;, &quot;&quot;);
      this._setProperty(&quot;padding-left&quot;, v);
    } else {
      this._subImplicitSetter(&quot;padding&quot;, &quot;left&quot;, v, paddingLeft_export_isValid, paddingLeft_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;padding-left&quot;);
  },
  enumerable: true,
  configurable: true
};
var paddingRight_export_parse, paddingRight_export_isValid, paddingRight_export_definition;
paddingRight_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v, true);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
paddingRight_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof paddingRight_export_parse(v) === &quot;string&quot;;
};
paddingRight_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;padding&quot;, &quot;&quot;);
      this._setProperty(&quot;padding-right&quot;, v);
    } else {
      this._subImplicitSetter(&quot;padding&quot;, &quot;right&quot;, v, paddingRight_export_isValid, paddingRight_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;padding-right&quot;);
  },
  enumerable: true,
  configurable: true
};
var paddingTop_export_parse, paddingTop_export_isValid, paddingTop_export_definition;
paddingTop_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseMeasurement(v, true);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
paddingTop_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof paddingTop_export_parse(v) === &quot;string&quot;;
};
paddingTop_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    if (external_dependency_parsers_0.hasVarFunc(v)) {
      this._setProperty(&quot;padding&quot;, &quot;&quot;);
      this._setProperty(&quot;padding-top&quot;, v);
    } else {
      this._subImplicitSetter(&quot;padding&quot;, &quot;top&quot;, v, paddingTop_export_isValid, paddingTop_export_parse, [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;]);
    }
  },
  get() {
    return this.getPropertyValue(&quot;padding-top&quot;);
  },
  enumerable: true,
  configurable: true
};
var right_export_parse, right_export_isValid, right_export_definition;
right_export_parse = function parse(v) {
  const dim = external_dependency_parsers_0.parseMeasurement(v);
  if (dim) {
    return dim;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
right_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof right_export_parse(v) === &quot;string&quot;;
};
right_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;right&quot;, right_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;right&quot;);
  },
  enumerable: true,
  configurable: true
};
var stopColor_export_parse, stopColor_export_isValid, stopColor_export_definition;
stopColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
stopColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
stopColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;stop-color&quot;, stopColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;stop-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var top_export_parse, top_export_isValid, top_export_definition;
top_export_parse = function parse(v) {
  const dim = external_dependency_parsers_0.parseMeasurement(v);
  if (dim) {
    return dim;
  }
  return external_dependency_parsers_0.parseKeyword(v, [&quot;auto&quot;]);
};
top_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof top_export_parse(v) === &quot;string&quot;;
};
top_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;top&quot;, top_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;top&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitBorderAfterColor_export_parse, webkitBorderAfterColor_export_isValid, webkitBorderAfterColor_export_definition;
webkitBorderAfterColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderAfterColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderAfterColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-border-after-color&quot;, webkitBorderAfterColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-border-after-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitBorderBeforeColor_export_parse, webkitBorderBeforeColor_export_isValid, webkitBorderBeforeColor_export_definition;
webkitBorderBeforeColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderBeforeColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderBeforeColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-border-before-color&quot;, webkitBorderBeforeColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-border-before-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitBorderEndColor_export_parse, webkitBorderEndColor_export_isValid, webkitBorderEndColor_export_definition;
webkitBorderEndColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderEndColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderEndColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-border-end-color&quot;, webkitBorderEndColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-border-end-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitBorderStartColor_export_parse, webkitBorderStartColor_export_isValid, webkitBorderStartColor_export_definition;
webkitBorderStartColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitBorderStartColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitBorderStartColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-border-start-color&quot;, webkitBorderStartColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-border-start-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitColumnRuleColor_export_parse, webkitColumnRuleColor_export_isValid, webkitColumnRuleColor_export_definition;
webkitColumnRuleColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitColumnRuleColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitColumnRuleColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-column-rule-color&quot;, webkitColumnRuleColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-column-rule-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitTapHighlightColor_export_parse, webkitTapHighlightColor_export_isValid, webkitTapHighlightColor_export_definition;
webkitTapHighlightColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitTapHighlightColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitTapHighlightColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-tap-highlight-color&quot;, webkitTapHighlightColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-tap-highlight-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitTextEmphasisColor_export_parse, webkitTextEmphasisColor_export_isValid, webkitTextEmphasisColor_export_definition;
webkitTextEmphasisColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitTextEmphasisColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitTextEmphasisColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-text-emphasis-color&quot;, webkitTextEmphasisColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-text-emphasis-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitTextFillColor_export_parse, webkitTextFillColor_export_isValid, webkitTextFillColor_export_definition;
webkitTextFillColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitTextFillColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitTextFillColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-text-fill-color&quot;, webkitTextFillColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-text-fill-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var webkitTextStrokeColor_export_parse, webkitTextStrokeColor_export_isValid, webkitTextStrokeColor_export_definition;
webkitTextStrokeColor_export_parse = function parse(v) {
  const val = external_dependency_parsers_0.parseColor(v);
  if (val) {
    return val;
  }
  return external_dependency_parsers_0.parseKeyword(v);
};
webkitTextStrokeColor_export_isValid = function isValid(v) {
  if (v === &quot;&quot; || typeof external_dependency_parsers_0.parseKeyword(v) === &quot;string&quot;) {
    return true;
  }
  return external_dependency_parsers_0.isValidColor(v);
};
webkitTextStrokeColor_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;-webkit-text-stroke-color&quot;, webkitTextStrokeColor_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;-webkit-text-stroke-color&quot;);
  },
  enumerable: true,
  configurable: true
};
var width_export_parse, width_export_isValid, width_export_definition;
width_export_parse = function parse(v) {
  const dim = external_dependency_parsers_0.parseMeasurement(v, true);
  if (dim) {
    return dim;
  }
  const keywords = [&quot;auto&quot;, &quot;min-content&quot;, &quot;max-content&quot;, &quot;fit-content&quot;];
  return external_dependency_parsers_0.parseKeyword(v, keywords);
};
width_export_isValid = function isValid(v) {
  if (v === &quot;&quot;) {
    return true;
  }
  return typeof width_export_parse(v) === &quot;string&quot;;
};
width_export_definition = {
  set(v) {
    v = external_dependency_parsers_0.prepareValue(v, this._global);
    this._setProperty(&quot;width&quot;, width_export_parse(v));
  },
  get() {
    return this.getPropertyValue(&quot;width&quot;);
  },
  enumerable: true,
  configurable: true
};
module.exports = {
  backgroundImage: backgroundImage_export_definition,
  &quot;background-image&quot;: backgroundImage_export_definition,
  backgroundPosition: backgroundPosition_export_definition,
  &quot;background-position&quot;: backgroundPosition_export_definition,
  backgroundRepeat: backgroundRepeat_export_definition,
  &quot;background-repeat&quot;: backgroundRepeat_export_definition,
  backgroundAttachment: backgroundAttachment_export_definition,
  &quot;background-attachment&quot;: backgroundAttachment_export_definition,
  backgroundColor: backgroundColor_export_definition,
  &quot;background-color&quot;: backgroundColor_export_definition,
  background: background_export_definition,
  borderWidth: borderWidth_export_definition,
  &quot;border-width&quot;: borderWidth_export_definition,
  borderStyle: borderStyle_export_definition,
  &quot;border-style&quot;: borderStyle_export_definition,
  borderColor: borderColor_export_definition,
  &quot;border-color&quot;: borderColor_export_definition,
  border: border_export_definition,
  borderTopWidth: borderTopWidth_export_definition,
  &quot;border-top-width&quot;: borderTopWidth_export_definition,
  borderTopStyle: borderTopStyle_export_definition,
  &quot;border-top-style&quot;: borderTopStyle_export_definition,
  borderTopColor: borderTopColor_export_definition,
  &quot;border-top-color&quot;: borderTopColor_export_definition,
  borderBottom: borderBottom_export_definition,
  &quot;border-bottom&quot;: borderBottom_export_definition,
  borderBottomColor: borderBottomColor_export_definition,
  &quot;border-bottom-color&quot;: borderBottomColor_export_definition,
  borderBottomStyle: borderBottomStyle_export_definition,
  &quot;border-bottom-style&quot;: borderBottomStyle_export_definition,
  borderBottomWidth: borderBottomWidth_export_definition,
  &quot;border-bottom-width&quot;: borderBottomWidth_export_definition,
  borderCollapse: borderCollapse_export_definition,
  &quot;border-collapse&quot;: borderCollapse_export_definition,
  borderLeft: borderLeft_export_definition,
  &quot;border-left&quot;: borderLeft_export_definition,
  borderLeftColor: borderLeftColor_export_definition,
  &quot;border-left-color&quot;: borderLeftColor_export_definition,
  borderLeftStyle: borderLeftStyle_export_definition,
  &quot;border-left-style&quot;: borderLeftStyle_export_definition,
  borderLeftWidth: borderLeftWidth_export_definition,
  &quot;border-left-width&quot;: borderLeftWidth_export_definition,
  borderRight: borderRight_export_definition,
  &quot;border-right&quot;: borderRight_export_definition,
  borderRightColor: borderRightColor_export_definition,
  &quot;border-right-color&quot;: borderRightColor_export_definition,
  borderRightStyle: borderRightStyle_export_definition,
  &quot;border-right-style&quot;: borderRightStyle_export_definition,
  borderRightWidth: borderRightWidth_export_definition,
  &quot;border-right-width&quot;: borderRightWidth_export_definition,
  borderSpacing: borderSpacing_export_definition,
  &quot;border-spacing&quot;: borderSpacing_export_definition,
  borderTop: borderTop_export_definition,
  &quot;border-top&quot;: borderTop_export_definition,
  bottom: bottom_export_definition,
  clear: clear_export_definition,
  clip: clip_export_definition,
  color: color_export_definition,
  flexGrow: flexGrow_export_definition,
  &quot;flex-grow&quot;: flexGrow_export_definition,
  flexShrink: flexShrink_export_definition,
  &quot;flex-shrink&quot;: flexShrink_export_definition,
  flexBasis: flexBasis_export_definition,
  &quot;flex-basis&quot;: flexBasis_export_definition,
  flex: flex_export_definition,
  float: float_export_definition,
  floodColor: floodColor_export_definition,
  &quot;flood-color&quot;: floodColor_export_definition,
  fontStyle: fontStyle_export_definition,
  &quot;font-style&quot;: fontStyle_export_definition,
  fontVariant: fontVariant_export_definition,
  &quot;font-variant&quot;: fontVariant_export_definition,
  fontWeight: fontWeight_export_definition,
  &quot;font-weight&quot;: fontWeight_export_definition,
  fontSize: fontSize_export_definition,
  &quot;font-size&quot;: fontSize_export_definition,
  lineHeight: lineHeight_export_definition,
  &quot;line-height&quot;: lineHeight_export_definition,
  fontFamily: fontFamily_export_definition,
  &quot;font-family&quot;: fontFamily_export_definition,
  font: font_export_definition,
  height: height_export_definition,
  left: left_export_definition,
  lightingColor: lightingColor_export_definition,
  &quot;lighting-color&quot;: lightingColor_export_definition,
  margin: margin_export_definition,
  marginBottom: marginBottom_export_definition,
  &quot;margin-bottom&quot;: marginBottom_export_definition,
  marginLeft: marginLeft_export_definition,
  &quot;margin-left&quot;: marginLeft_export_definition,
  marginRight: marginRight_export_definition,
  &quot;margin-right&quot;: marginRight_export_definition,
  marginTop: marginTop_export_definition,
  &quot;margin-top&quot;: marginTop_export_definition,
  opacity: opacity_export_definition,
  outlineColor: outlineColor_export_definition,
  &quot;outline-color&quot;: outlineColor_export_definition,
  padding: padding_export_definition,
  paddingBottom: paddingBottom_export_definition,
  &quot;padding-bottom&quot;: paddingBottom_export_definition,
  paddingLeft: paddingLeft_export_definition,
  &quot;padding-left&quot;: paddingLeft_export_definition,
  paddingRight: paddingRight_export_definition,
  &quot;padding-right&quot;: paddingRight_export_definition,
  paddingTop: paddingTop_export_definition,
  &quot;padding-top&quot;: paddingTop_export_definition,
  right: right_export_definition,
  stopColor: stopColor_export_definition,
  &quot;stop-color&quot;: stopColor_export_definition,
  top: top_export_definition,
  webkitBorderAfterColor: webkitBorderAfterColor_export_definition,
  &quot;-webkit-border-after-color&quot;: webkitBorderAfterColor_export_definition,
  &quot;WebkitBorderAfterColor&quot;: webkitBorderAfterColor_export_definition,
  webkitBorderBeforeColor: webkitBorderBeforeColor_export_definition,
  &quot;-webkit-border-before-color&quot;: webkitBorderBeforeColor_export_definition,
  &quot;WebkitBorderBeforeColor&quot;: webkitBorderBeforeColor_export_definition,
  webkitBorderEndColor: webkitBorderEndColor_export_definition,
  &quot;-webkit-border-end-color&quot;: webkitBorderEndColor_export_definition,
  &quot;WebkitBorderEndColor&quot;: webkitBorderEndColor_export_definition,
  webkitBorderStartColor: webkitBorderStartColor_export_definition,
  &quot;-webkit-border-start-color&quot;: webkitBorderStartColor_export_definition,
  &quot;WebkitBorderStartColor&quot;: webkitBorderStartColor_export_definition,
  webkitColumnRuleColor: webkitColumnRuleColor_export_definition,
  &quot;-webkit-column-rule-color&quot;: webkitColumnRuleColor_export_definition,
  &quot;WebkitColumnRuleColor&quot;: webkitColumnRuleColor_export_definition,
  webkitTapHighlightColor: webkitTapHighlightColor_export_definition,
  &quot;-webkit-tap-highlight-color&quot;: webkitTapHighlightColor_export_definition,
  &quot;WebkitTapHighlightColor&quot;: webkitTapHighlightColor_export_definition,
  webkitTextEmphasisColor: webkitTextEmphasisColor_export_definition,
  &quot;-webkit-text-emphasis-color&quot;: webkitTextEmphasisColor_export_definition,
  &quot;WebkitTextEmphasisColor&quot;: webkitTextEmphasisColor_export_definition,
  webkitTextFillColor: webkitTextFillColor_export_definition,
  &quot;-webkit-text-fill-color&quot;: webkitTextFillColor_export_definition,
  &quot;WebkitTextFillColor&quot;: webkitTextFillColor_export_definition,
  webkitTextStrokeColor: webkitTextStrokeColor_export_definition,
  &quot;-webkit-text-stroke-color&quot;: webkitTextStrokeColor_export_definition,
  &quot;WebkitTextStrokeColor&quot;: webkitTextStrokeColor_export_definition,
  width: width_export_definition
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
