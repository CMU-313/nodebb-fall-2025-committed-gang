<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/living/generated/HTMLElement.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3138</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">112.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">31.59</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const conversions = require(&quot;webidl-conversions&quot;);
const utils = require(&quot;./utils.js&quot;);

const HTMLConstructor_helpers_html_constructor = require(&quot;../helpers/html-constructor.js&quot;).HTMLConstructor;
const ceReactionsPreSteps_helpers_custom_elements = require(&quot;../helpers/custom-elements.js&quot;).ceReactionsPreSteps;
const ceReactionsPostSteps_helpers_custom_elements = require(&quot;../helpers/custom-elements.js&quot;).ceReactionsPostSteps;
const EventHandlerNonNull = require(&quot;./EventHandlerNonNull.js&quot;);
const OnErrorEventHandlerNonNull = require(&quot;./OnErrorEventHandlerNonNull.js&quot;);
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const Element = require(&quot;./Element.js&quot;);

const interfaceName = &quot;HTMLElement&quot;;

exports.is = value =&gt; {
  return utils.isObject(value) &amp;&amp; utils.hasOwn(value, implSymbol) &amp;&amp; value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value =&gt; {
  return utils.isObject(value) &amp;&amp; value instanceof Impl.implementation;
};
exports.convert = (globalObject, value, { context = &quot;The provided value&quot; } = {}) =&gt; {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new globalObject.TypeError(`${context} is not of type &#039;HTMLElement&#039;.`);
};

function makeWrapper(globalObject, newTarget) {
  let proto;
  if (newTarget !== undefined) {
    proto = newTarget.prototype;
  }

  if (!utils.isObject(proto)) {
    proto = globalObject[ctorRegistrySymbol][&quot;HTMLElement&quot;].prototype;
  }

  return Object.create(proto);
}

exports.create = (globalObject, constructorArgs, privateData) =&gt; {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) =&gt; {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) =&gt; {
  Element._internalSetup(wrapper, globalObject);
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) =&gt; {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = (globalObject, newTarget) =&gt; {
  const wrapper = makeWrapper(globalObject, newTarget);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([&quot;Window&quot;]);

exports.install = (globalObject, globalNames) =&gt; {
  if (!globalNames.some(globalName =&gt; exposed.has(globalName))) {
    return;
  }

  const ctorRegistry = utils.initCtorRegistry(globalObject);
  class HTMLElement extends globalObject.Element {
    constructor() {
      return HTMLConstructor_helpers_html_constructor(globalObject, interfaceName, new.target);
    }

    click() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;click&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      return esValue[implSymbol].click();
    }

    attachInternals() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;attachInternals&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol].attachInternals());
    }

    focus() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;focus&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      return esValue[implSymbol].focus();
    }

    blur() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;blur&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      return esValue[implSymbol].blur();
    }

    get title() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get title&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        const value = esValue[implSymbol]._reflectGetTheContentAttribute(&quot;title&quot;);
        return value === null ? &quot;&quot; : value;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set title(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set title&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;DOMString&quot;](V, {
        context: &quot;Failed to set the &#039;title&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol]._reflectSetTheContentAttribute(&quot;title&quot;, V);
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get lang() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;get lang&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        const value = esValue[implSymbol]._reflectGetTheContentAttribute(&quot;lang&quot;);
        return value === null ? &quot;&quot; : value;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set lang(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;set lang&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      V = conversions[&quot;DOMString&quot;](V, {
        context: &quot;Failed to set the &#039;lang&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol]._reflectSetTheContentAttribute(&quot;lang&quot;, V);
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get translate() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get translate&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        return esValue[implSymbol][&quot;translate&quot;];
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set translate(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set translate&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;boolean&quot;](V, {
        context: &quot;Failed to set the &#039;translate&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol][&quot;translate&quot;] = V;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get dir() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;get dir&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        return esValue[implSymbol][&quot;dir&quot;];
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set dir(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(&quot;&#039;set dir&#039; called on an object that is not a valid instance of HTMLElement.&quot;);
      }

      V = conversions[&quot;DOMString&quot;](V, {
        context: &quot;Failed to set the &#039;dir&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol][&quot;dir&quot;] = V;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get hidden() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get hidden&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        return esValue[implSymbol]._reflectGetTheContentAttribute(&quot;hidden&quot;) !== null;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set hidden(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set hidden&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;boolean&quot;](V, {
        context: &quot;Failed to set the &#039;hidden&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        if (V) {
          esValue[implSymbol]._reflectSetTheContentAttribute(&quot;hidden&quot;, &quot;&quot;);
        } else {
          esValue[implSymbol]._reflectDeleteTheContentAttribute(&quot;hidden&quot;);
        }
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get accessKey() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get accessKey&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        const value = esValue[implSymbol]._reflectGetTheContentAttribute(&quot;accesskey&quot;);
        return value === null ? &quot;&quot; : value;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set accessKey(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set accessKey&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;DOMString&quot;](V, {
        context: &quot;Failed to set the &#039;accessKey&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol]._reflectSetTheContentAttribute(&quot;accesskey&quot;, V);
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get draggable() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get draggable&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        return esValue[implSymbol][&quot;draggable&quot;];
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set draggable(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set draggable&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;boolean&quot;](V, {
        context: &quot;Failed to set the &#039;draggable&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol][&quot;draggable&quot;] = V;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    get offsetParent() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get offsetParent&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;offsetParent&quot;]);
    }

    get offsetTop() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get offsetTop&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return esValue[implSymbol][&quot;offsetTop&quot;];
    }

    get offsetLeft() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get offsetLeft&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return esValue[implSymbol][&quot;offsetLeft&quot;];
    }

    get offsetWidth() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get offsetWidth&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return esValue[implSymbol][&quot;offsetWidth&quot;];
    }

    get offsetHeight() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get offsetHeight&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return esValue[implSymbol][&quot;offsetHeight&quot;];
    }

    get style() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get style&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.getSameObject(this, &quot;style&quot;, () =&gt; {
        return utils.tryWrapperForImpl(esValue[implSymbol][&quot;style&quot;]);
      });
    }

    set style(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set style&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      const Q = esValue[&quot;style&quot;];
      if (!utils.isObject(Q)) {
        throw new globalObject.TypeError(&quot;Property &#039;style&#039; is not an object&quot;);
      }
      Reflect.set(Q, &quot;cssText&quot;, V);
    }

    get onabort() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onabort&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onabort&quot;]);
    }

    set onabort(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onabort&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onabort&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onabort&quot;] = V;
    }

    get onauxclick() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onauxclick&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onauxclick&quot;]);
    }

    set onauxclick(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onauxclick&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onauxclick&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onauxclick&quot;] = V;
    }

    get onbeforeinput() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onbeforeinput&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onbeforeinput&quot;]);
    }

    set onbeforeinput(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onbeforeinput&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onbeforeinput&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onbeforeinput&quot;] = V;
    }

    get onbeforematch() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onbeforematch&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onbeforematch&quot;]);
    }

    set onbeforematch(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onbeforematch&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onbeforematch&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onbeforematch&quot;] = V;
    }

    get onbeforetoggle() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onbeforetoggle&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onbeforetoggle&quot;]);
    }

    set onbeforetoggle(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onbeforetoggle&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onbeforetoggle&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onbeforetoggle&quot;] = V;
    }

    get onblur() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onblur&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onblur&quot;]);
    }

    set onblur(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onblur&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onblur&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onblur&quot;] = V;
    }

    get oncancel() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncancel&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncancel&quot;]);
    }

    set oncancel(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncancel&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncancel&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncancel&quot;] = V;
    }

    get oncanplay() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncanplay&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncanplay&quot;]);
    }

    set oncanplay(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncanplay&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncanplay&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncanplay&quot;] = V;
    }

    get oncanplaythrough() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncanplaythrough&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncanplaythrough&quot;]);
    }

    set oncanplaythrough(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncanplaythrough&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncanplaythrough&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncanplaythrough&quot;] = V;
    }

    get onchange() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onchange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onchange&quot;]);
    }

    set onchange(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onchange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onchange&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onchange&quot;] = V;
    }

    get onclick() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onclick&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onclick&quot;]);
    }

    set onclick(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onclick&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onclick&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onclick&quot;] = V;
    }

    get onclose() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onclose&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onclose&quot;]);
    }

    set onclose(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onclose&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onclose&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onclose&quot;] = V;
    }

    get oncontextlost() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncontextlost&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncontextlost&quot;]);
    }

    set oncontextlost(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncontextlost&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncontextlost&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncontextlost&quot;] = V;
    }

    get oncontextmenu() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncontextmenu&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncontextmenu&quot;]);
    }

    set oncontextmenu(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncontextmenu&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncontextmenu&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncontextmenu&quot;] = V;
    }

    get oncontextrestored() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncontextrestored&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncontextrestored&quot;]);
    }

    set oncontextrestored(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncontextrestored&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncontextrestored&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncontextrestored&quot;] = V;
    }

    get oncopy() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncopy&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncopy&quot;]);
    }

    set oncopy(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncopy&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncopy&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncopy&quot;] = V;
    }

    get oncuechange() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncuechange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncuechange&quot;]);
    }

    set oncuechange(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncuechange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncuechange&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncuechange&quot;] = V;
    }

    get oncut() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oncut&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oncut&quot;]);
    }

    set oncut(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oncut&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oncut&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oncut&quot;] = V;
    }

    get ondblclick() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondblclick&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondblclick&quot;]);
    }

    set ondblclick(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondblclick&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondblclick&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondblclick&quot;] = V;
    }

    get ondrag() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondrag&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondrag&quot;]);
    }

    set ondrag(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondrag&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondrag&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondrag&quot;] = V;
    }

    get ondragend() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondragend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondragend&quot;]);
    }

    set ondragend(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondragend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondragend&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondragend&quot;] = V;
    }

    get ondragenter() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondragenter&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondragenter&quot;]);
    }

    set ondragenter(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondragenter&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondragenter&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondragenter&quot;] = V;
    }

    get ondragleave() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondragleave&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondragleave&quot;]);
    }

    set ondragleave(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondragleave&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondragleave&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondragleave&quot;] = V;
    }

    get ondragover() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondragover&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondragover&quot;]);
    }

    set ondragover(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondragover&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondragover&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondragover&quot;] = V;
    }

    get ondragstart() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondragstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondragstart&quot;]);
    }

    set ondragstart(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondragstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondragstart&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondragstart&quot;] = V;
    }

    get ondrop() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondrop&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondrop&quot;]);
    }

    set ondrop(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondrop&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondrop&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondrop&quot;] = V;
    }

    get ondurationchange() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ondurationchange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ondurationchange&quot;]);
    }

    set ondurationchange(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ondurationchange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ondurationchange&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ondurationchange&quot;] = V;
    }

    get onemptied() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onemptied&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onemptied&quot;]);
    }

    set onemptied(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onemptied&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onemptied&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onemptied&quot;] = V;
    }

    get onended() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onended&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onended&quot;]);
    }

    set onended(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onended&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onended&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onended&quot;] = V;
    }

    get onerror() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onerror&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onerror&quot;]);
    }

    set onerror(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onerror&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = OnErrorEventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onerror&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onerror&quot;] = V;
    }

    get onfocus() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onfocus&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onfocus&quot;]);
    }

    set onfocus(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onfocus&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onfocus&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onfocus&quot;] = V;
    }

    get onformdata() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onformdata&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onformdata&quot;]);
    }

    set onformdata(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onformdata&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onformdata&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onformdata&quot;] = V;
    }

    get oninput() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oninput&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oninput&quot;]);
    }

    set oninput(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oninput&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oninput&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oninput&quot;] = V;
    }

    get oninvalid() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get oninvalid&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;oninvalid&quot;]);
    }

    set oninvalid(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set oninvalid&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;oninvalid&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;oninvalid&quot;] = V;
    }

    get onkeydown() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onkeydown&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onkeydown&quot;]);
    }

    set onkeydown(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onkeydown&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onkeydown&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onkeydown&quot;] = V;
    }

    get onkeypress() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onkeypress&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onkeypress&quot;]);
    }

    set onkeypress(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onkeypress&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onkeypress&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onkeypress&quot;] = V;
    }

    get onkeyup() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onkeyup&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onkeyup&quot;]);
    }

    set onkeyup(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onkeyup&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onkeyup&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onkeyup&quot;] = V;
    }

    get onload() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onload&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onload&quot;]);
    }

    set onload(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onload&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onload&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onload&quot;] = V;
    }

    get onloadeddata() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onloadeddata&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onloadeddata&quot;]);
    }

    set onloadeddata(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onloadeddata&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onloadeddata&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onloadeddata&quot;] = V;
    }

    get onloadedmetadata() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onloadedmetadata&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onloadedmetadata&quot;]);
    }

    set onloadedmetadata(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onloadedmetadata&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onloadedmetadata&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onloadedmetadata&quot;] = V;
    }

    get onloadstart() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onloadstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onloadstart&quot;]);
    }

    set onloadstart(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onloadstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onloadstart&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onloadstart&quot;] = V;
    }

    get onmousedown() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onmousedown&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmousedown&quot;]);
    }

    set onmousedown(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onmousedown&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmousedown&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmousedown&quot;] = V;
    }

    get onmouseenter() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmouseenter&quot;]);
    }

    set onmouseenter(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmouseenter&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmouseenter&quot;] = V;
    }

    get onmouseleave() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmouseleave&quot;]);
    }

    set onmouseleave(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmouseleave&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmouseleave&quot;] = V;
    }

    get onmousemove() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onmousemove&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmousemove&quot;]);
    }

    set onmousemove(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onmousemove&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmousemove&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmousemove&quot;] = V;
    }

    get onmouseout() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onmouseout&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmouseout&quot;]);
    }

    set onmouseout(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onmouseout&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmouseout&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmouseout&quot;] = V;
    }

    get onmouseover() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onmouseover&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmouseover&quot;]);
    }

    set onmouseover(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onmouseover&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmouseover&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmouseover&quot;] = V;
    }

    get onmouseup() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onmouseup&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onmouseup&quot;]);
    }

    set onmouseup(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onmouseup&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onmouseup&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onmouseup&quot;] = V;
    }

    get onpaste() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onpaste&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onpaste&quot;]);
    }

    set onpaste(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onpaste&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onpaste&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onpaste&quot;] = V;
    }

    get onpause() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onpause&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onpause&quot;]);
    }

    set onpause(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onpause&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onpause&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onpause&quot;] = V;
    }

    get onplay() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onplay&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onplay&quot;]);
    }

    set onplay(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onplay&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onplay&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onplay&quot;] = V;
    }

    get onplaying() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onplaying&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onplaying&quot;]);
    }

    set onplaying(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onplaying&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onplaying&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onplaying&quot;] = V;
    }

    get onprogress() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onprogress&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onprogress&quot;]);
    }

    set onprogress(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onprogress&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onprogress&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onprogress&quot;] = V;
    }

    get onratechange() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onratechange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onratechange&quot;]);
    }

    set onratechange(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onratechange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onratechange&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onratechange&quot;] = V;
    }

    get onreset() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onreset&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onreset&quot;]);
    }

    set onreset(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onreset&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onreset&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onreset&quot;] = V;
    }

    get onresize() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onresize&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onresize&quot;]);
    }

    set onresize(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onresize&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onresize&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onresize&quot;] = V;
    }

    get onscroll() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onscroll&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onscroll&quot;]);
    }

    set onscroll(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onscroll&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onscroll&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onscroll&quot;] = V;
    }

    get onscrollend() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onscrollend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onscrollend&quot;]);
    }

    set onscrollend(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onscrollend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onscrollend&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onscrollend&quot;] = V;
    }

    get onsecuritypolicyviolation() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onsecuritypolicyviolation&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onsecuritypolicyviolation&quot;]);
    }

    set onsecuritypolicyviolation(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onsecuritypolicyviolation&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onsecuritypolicyviolation&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onsecuritypolicyviolation&quot;] = V;
    }

    get onseeked() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onseeked&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onseeked&quot;]);
    }

    set onseeked(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onseeked&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onseeked&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onseeked&quot;] = V;
    }

    get onseeking() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onseeking&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onseeking&quot;]);
    }

    set onseeking(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onseeking&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onseeking&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onseeking&quot;] = V;
    }

    get onselect() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onselect&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onselect&quot;]);
    }

    set onselect(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onselect&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onselect&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onselect&quot;] = V;
    }

    get onslotchange() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onslotchange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onslotchange&quot;]);
    }

    set onslotchange(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onslotchange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onslotchange&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onslotchange&quot;] = V;
    }

    get onstalled() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onstalled&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onstalled&quot;]);
    }

    set onstalled(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onstalled&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onstalled&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onstalled&quot;] = V;
    }

    get onsubmit() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onsubmit&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onsubmit&quot;]);
    }

    set onsubmit(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onsubmit&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onsubmit&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onsubmit&quot;] = V;
    }

    get onsuspend() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onsuspend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onsuspend&quot;]);
    }

    set onsuspend(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onsuspend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onsuspend&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onsuspend&quot;] = V;
    }

    get ontimeupdate() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ontimeupdate&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ontimeupdate&quot;]);
    }

    set ontimeupdate(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ontimeupdate&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ontimeupdate&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ontimeupdate&quot;] = V;
    }

    get ontoggle() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ontoggle&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ontoggle&quot;]);
    }

    set ontoggle(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ontoggle&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ontoggle&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ontoggle&quot;] = V;
    }

    get onvolumechange() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onvolumechange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onvolumechange&quot;]);
    }

    set onvolumechange(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onvolumechange&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onvolumechange&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onvolumechange&quot;] = V;
    }

    get onwaiting() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onwaiting&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onwaiting&quot;]);
    }

    set onwaiting(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onwaiting&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onwaiting&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onwaiting&quot;] = V;
    }

    get onwebkitanimationend() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onwebkitanimationend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onwebkitanimationend&quot;]);
    }

    set onwebkitanimationend(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onwebkitanimationend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onwebkitanimationend&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onwebkitanimationend&quot;] = V;
    }

    get onwebkitanimationiteration() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onwebkitanimationiteration&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onwebkitanimationiteration&quot;]);
    }

    set onwebkitanimationiteration(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onwebkitanimationiteration&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onwebkitanimationiteration&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onwebkitanimationiteration&quot;] = V;
    }

    get onwebkitanimationstart() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onwebkitanimationstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onwebkitanimationstart&quot;]);
    }

    set onwebkitanimationstart(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onwebkitanimationstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onwebkitanimationstart&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onwebkitanimationstart&quot;] = V;
    }

    get onwebkittransitionend() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onwebkittransitionend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onwebkittransitionend&quot;]);
    }

    set onwebkittransitionend(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onwebkittransitionend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onwebkittransitionend&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onwebkittransitionend&quot;] = V;
    }

    get onwheel() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get onwheel&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;onwheel&quot;]);
    }

    set onwheel(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set onwheel&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;onwheel&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;onwheel&quot;] = V;
    }

    get ontouchstart() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ontouchstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ontouchstart&quot;]);
    }

    set ontouchstart(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ontouchstart&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ontouchstart&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ontouchstart&quot;] = V;
    }

    get ontouchend() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ontouchend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ontouchend&quot;]);
    }

    set ontouchend(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ontouchend&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ontouchend&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ontouchend&quot;] = V;
    }

    get ontouchmove() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ontouchmove&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ontouchmove&quot;]);
    }

    set ontouchmove(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ontouchmove&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ontouchmove&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ontouchmove&quot;] = V;
    }

    get ontouchcancel() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get ontouchcancel&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][&quot;ontouchcancel&quot;]);
    }

    set ontouchcancel(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set ontouchcancel&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(globalObject, V, {
          context: &quot;Failed to set the &#039;ontouchcancel&#039; property on &#039;HTMLElement&#039;: The provided value&quot;
        });
      }
      esValue[implSymbol][&quot;ontouchcancel&quot;] = V;
    }

    get dataset() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get dataset&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      return utils.getSameObject(this, &quot;dataset&quot;, () =&gt; {
        return utils.tryWrapperForImpl(esValue[implSymbol][&quot;dataset&quot;]);
      });
    }

    get nonce() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get nonce&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      const value = esValue[implSymbol]._reflectGetTheContentAttribute(&quot;nonce&quot;);
      return value === null ? &quot;&quot; : value;
    }

    set nonce(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set nonce&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;DOMString&quot;](V, {
        context: &quot;Failed to set the &#039;nonce&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      esValue[implSymbol]._reflectSetTheContentAttribute(&quot;nonce&quot;, V);
    }

    get tabIndex() {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;get tabIndex&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        return esValue[implSymbol][&quot;tabIndex&quot;];
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }

    set tabIndex(V) {
      const esValue = this !== null &amp;&amp; this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new globalObject.TypeError(
          &quot;&#039;set tabIndex&#039; called on an object that is not a valid instance of HTMLElement.&quot;
        );
      }

      V = conversions[&quot;long&quot;](V, {
        context: &quot;Failed to set the &#039;tabIndex&#039; property on &#039;HTMLElement&#039;: The provided value&quot;,
        globals: globalObject
      });

      ceReactionsPreSteps_helpers_custom_elements(globalObject);
      try {
        esValue[implSymbol][&quot;tabIndex&quot;] = V;
      } finally {
        ceReactionsPostSteps_helpers_custom_elements(globalObject);
      }
    }
  }
  Object.defineProperties(HTMLElement.prototype, {
    click: { enumerable: true },
    attachInternals: { enumerable: true },
    focus: { enumerable: true },
    blur: { enumerable: true },
    title: { enumerable: true },
    lang: { enumerable: true },
    translate: { enumerable: true },
    dir: { enumerable: true },
    hidden: { enumerable: true },
    accessKey: { enumerable: true },
    draggable: { enumerable: true },
    offsetParent: { enumerable: true },
    offsetTop: { enumerable: true },
    offsetLeft: { enumerable: true },
    offsetWidth: { enumerable: true },
    offsetHeight: { enumerable: true },
    style: { enumerable: true },
    onabort: { enumerable: true },
    onauxclick: { enumerable: true },
    onbeforeinput: { enumerable: true },
    onbeforematch: { enumerable: true },
    onbeforetoggle: { enumerable: true },
    onblur: { enumerable: true },
    oncancel: { enumerable: true },
    oncanplay: { enumerable: true },
    oncanplaythrough: { enumerable: true },
    onchange: { enumerable: true },
    onclick: { enumerable: true },
    onclose: { enumerable: true },
    oncontextlost: { enumerable: true },
    oncontextmenu: { enumerable: true },
    oncontextrestored: { enumerable: true },
    oncopy: { enumerable: true },
    oncuechange: { enumerable: true },
    oncut: { enumerable: true },
    ondblclick: { enumerable: true },
    ondrag: { enumerable: true },
    ondragend: { enumerable: true },
    ondragenter: { enumerable: true },
    ondragleave: { enumerable: true },
    ondragover: { enumerable: true },
    ondragstart: { enumerable: true },
    ondrop: { enumerable: true },
    ondurationchange: { enumerable: true },
    onemptied: { enumerable: true },
    onended: { enumerable: true },
    onerror: { enumerable: true },
    onfocus: { enumerable: true },
    onformdata: { enumerable: true },
    oninput: { enumerable: true },
    oninvalid: { enumerable: true },
    onkeydown: { enumerable: true },
    onkeypress: { enumerable: true },
    onkeyup: { enumerable: true },
    onload: { enumerable: true },
    onloadeddata: { enumerable: true },
    onloadedmetadata: { enumerable: true },
    onloadstart: { enumerable: true },
    onmousedown: { enumerable: true },
    onmouseenter: { enumerable: true },
    onmouseleave: { enumerable: true },
    onmousemove: { enumerable: true },
    onmouseout: { enumerable: true },
    onmouseover: { enumerable: true },
    onmouseup: { enumerable: true },
    onpaste: { enumerable: true },
    onpause: { enumerable: true },
    onplay: { enumerable: true },
    onplaying: { enumerable: true },
    onprogress: { enumerable: true },
    onratechange: { enumerable: true },
    onreset: { enumerable: true },
    onresize: { enumerable: true },
    onscroll: { enumerable: true },
    onscrollend: { enumerable: true },
    onsecuritypolicyviolation: { enumerable: true },
    onseeked: { enumerable: true },
    onseeking: { enumerable: true },
    onselect: { enumerable: true },
    onslotchange: { enumerable: true },
    onstalled: { enumerable: true },
    onsubmit: { enumerable: true },
    onsuspend: { enumerable: true },
    ontimeupdate: { enumerable: true },
    ontoggle: { enumerable: true },
    onvolumechange: { enumerable: true },
    onwaiting: { enumerable: true },
    onwebkitanimationend: { enumerable: true },
    onwebkitanimationiteration: { enumerable: true },
    onwebkitanimationstart: { enumerable: true },
    onwebkittransitionend: { enumerable: true },
    onwheel: { enumerable: true },
    ontouchstart: { enumerable: true },
    ontouchend: { enumerable: true },
    ontouchmove: { enumerable: true },
    ontouchcancel: { enumerable: true },
    dataset: { enumerable: true },
    nonce: { enumerable: true },
    tabIndex: { enumerable: true },
    [Symbol.toStringTag]: { value: &quot;HTMLElement&quot;, configurable: true }
  });
  ctorRegistry[interfaceName] = HTMLElement;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: HTMLElement
  });
};

const Impl = require(&quot;../nodes/HTMLElement-impl.js&quot;);
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
