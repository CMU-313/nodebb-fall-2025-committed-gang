<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/natural/lib/natural/brill_pos_tagger/lib/RuleTemplates.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/natural/lib/natural/brill_pos_tagger/lib/RuleTemplates.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">712</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.98</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
  Rule templates that provide metadata for generating transformation rules
  Copyright (C) 2017 Hugo W.L. ter Doest

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

&#039;use strict&#039;

const ruleTemplates = {
  // Predicates as used in the English rules in data/English/tr_from_posjs.txt
  &#039;NEXT-TAG&#039;: {
    // maps to the predicate function
    function: nextTagIs,
    // Minimum required space before or after current position to be a relevant predicate
    window: [0, 1],
    // The number of parameters the predicate takes
    nrParameters: 1,
    // Function that returns relevant values for parameter 1
    parameter1Values: nextTagParameterValues
  },
  &#039;NEXT-WORD-IS-CAP&#039;: {
    function: nextWordIsCap,
    window: [0, 1],
    nrParameters: 0
  },
  &#039;PREV-1-OR-2-OR-3-TAG&#039;: {
    function: prev1Or2Or3Tag,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prev1Or2Or3TagParameterValues
  },
  &#039;PREV-1-OR-2-TAG&#039;: {
    function: prev1Or2Tag,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prev1Or2TagParameterValues
  },
  &#039;NEXT-WORD-IS-TAG&#039;: {
    function: nextTagIs,
    window: [0, 1],
    nrParameters: 1,
    parameter1Values: nextTagParameterValues
  },
  &#039;PREV-TAG&#039;: {
    function: prevTagIs,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prevTagParameterValues
  },
  /*
 &quot;CURRENT-WORD-IS-TAG&quot;: {
   &quot;function&quot;: current_word_is_tag,
   &quot;window&quot;: [0],
   &quot;nrParameter&quot;: 1,
   &quot;parameter1Values&quot;: currentTagParameterValues
   },
  */
  &#039;PREV-WORD-IS-CAP&#039;: {
    function: prevWordIsCap,
    window: [-1, 0],
    nrParameters: 0
  },
  &#039;CURRENT-WORD-IS-CAP&#039;: {
    function: currentWordIsCap,
    window: [0, 0],
    nrParameters: 0
  },
  &#039;CURRENT-WORD-IS-NUMBER&#039;: {
    function: currentWordIsNumber,
    window: [0, 0],
    nrParameters: 0
  },
  &#039;CURRENT-WORD-IS-URL&#039;: {
    function: currentWordIsURL,
    window: [0, 0],
    nrParameters: 0
  },
  &#039;CURRENT-WORD-ENDS-WITH&#039;: {
    function: currentWordEndsWith,
    window: [0, 0],
    nrParameters: 1,
    parameter1Values: currentWordEndsWithParameterValues
  },
  &#039;PREV-WORD-IS&#039;: {
    function: prevWordIs,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prevWordParameterValues
  },

  // Predicates as used in the Dutch rules in data/Dutch/brill_CONTEXTRULES.jg
  PREVTAG: {
    function: prevTagIs,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prevTagParameterValues
  },
  NEXT1OR2TAG: {
    function: next1Or2TagIs,
    window: [0, 1],
    nrParameters: 1,
    parameter1Values: next1Or2TagIsParameterValues
  },
  NEXTTAG: {
    function: nextTagIs,
    window: [0, 1],
    nrParameters: 1,
    parameter1Values: nextTagParameterValues
  },
  PREV1OR2TAG: {
    function: prev1Or2Tag,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prev1Or2TagParameterValues
  },
  WDAND2TAGAFT: {
    function: currentWordAnd2TagAfterAre,
    window: [0, 2],
    nrParameters: 2,
    parameter1Values: currentWordParameterValues,
    parameter2Values: twoTagAfterParameterValues
  },
  NEXT1OR2OR3TAG: {
    function: next1Or2Or3Tag,
    // Minimum required window to apply this template is one tag to the right
    window: [0, 1],
    nrParameters: 1,
    parameter1Values: next1Or2Or3TagParameterValues
  },
  CURWD: {
    function: currentWordIs,
    window: [0, 0],
    nrParameters: 1,
    parameter1Values: currentWordParameterValues
  },
  SURROUNDTAG: {
    function: surroundedByTags,
    window: [-1, 1],
    nrParameters: 2,
    parameter1Values: prevTagParameterValues,
    parameter2Values: nextTagParameterValues
  },
  PREV1OR2OR3TAG: {
    function: prev1Or2Or3Tag,
    // Minimum required window to apply this template is one tag to the left
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prev1Or2Or3TagParameterValues
  },
  WDNEXTTAG: {
    function: currentWordAndNextTagAre,
    window: [0, 1],
    nrParameters: 2,
    parameter1Values: currentWordParameterValues,
    parameter2Values: nextTagParameterValues
  },
  PREV1OR2WD: {
    function: prev1Or2WordIs,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prev1Or2WordParameterValues
  },
  NEXTWD: {
    function: nextWordIs,
    window: [0, 1],
    nrParameters: 1,
    parameter1Values: nextWordParameterValues
  },
  PREVWD: {
    function: prevWordIs,
    window: [-1, 0],
    nrParameters: 1,
    parameter1Values: prevWordParameterValues
  },
  NEXT2TAG: {
    function: next2TagIs,
    window: [0, 2],
    nrParameters: 1,
    parameter1Values: next2TagParameterValues
  },
  WDAND2TAGBFR: {
    function: currentWordAnd2TagBeforeAre,
    window: [-2, 0],
    nrParameters: 2,
    parameter1Values: currentWordParameterValues,
    parameter2Values: twoTagBeforeParameterValues
  },
  WDAND2AFT: {
    function: currentWordAnd2AfterAre,
    window: [0, 2],
    nrParameters: 2,
    parameter1Values: currentWordParameterValues,
    parameter2Values: twoTagAfterParameterValues
  },
  WDPREVTAG: {
    function: currentWordAndPrevTagAre,
    window: [-1, 0],
    nrParameters: 2,
    parameter1Values: currentWordParameterValues,
    parameter2Values: prevTagParameterValues
  },
  RBIGRAM: {
    function: rightBigramIs,
    window: [0, 1],
    nrParameters: 2,
    parameter1Values: currentWordParameterValues,
    parameter2Values: nextWordParameterValues
  },
  LBIGRAM: {
    function: leftBigramIs,
    window: [-1, 0],
    nrParameters: 2,
    parameter1Values: prevWordParameterValues,
    parameter2Values: currentWordParameterValues
  },
  NEXTBIGRAM: {
    function: nextBigramIs,
    window: [0, 2],
    nrParameters: 2,
    parameter1Values: nextWordParameterValues,
    parameter2Values: twoWordAfterParameterValues
  },
  PREVBIGRAM: {
    function: prevBigramIs,
    window: [-2, 0],
    nrParameters: 2,
    parameter1Values: twoWordBeforeParameterValues,
    parameter2Values: prevWordParameterValues
  },
  PREV2TAG: {
    function: prev2TagIs,
    window: [-2, 0],
    nrParameters: 2,
    parameter1Values: twoTagBeforeParameterValues,
    parameter2Values: prevTagParameterValues
  },
  NEXT1OR2WD: {
    function: next1Or2WordIs,
    window: [0, 1],
    nrParameters: 1,
    parameter1Values: next1Or2WordParameterValues
  },
  DEFAULT: {
    function: defaultPredicate,
    window: [0, 0],
    nrParameters: 0
  }
}

// ==================================
// Predicates that start with words
// ==================================
function nextWordIsCap (sentence, i, parameter) {
  if (i &lt; sentence.taggedWords.length - 1) {
    const nextWord = sentence.taggedWords[i + 1].token
    return (nextWord[0] === nextWord[0].toUpperCase())
  }
  return (false)
}

function nextWordIs (sentence, i, parameter) {
  if (i &lt; sentence.taggedWords.length - 1) {
    return (sentence.taggedWords[i + 1].token === parameter)
  }
}

function nextWordParameterValues (sentence, i) {
  if (i &lt; sentence.taggedWords.length - 1) {
    return [sentence.taggedWords[i + 1].token]
  } else {
    return []
  }
}

function prevWordIsCap (sentence, i, parameter) {
  let prevWord = null
  if (i &gt; 0) {
    prevWord = sentence.taggedWords[i - 1].token
    return (prevWord[0] === prevWord[0].toUpperCase())
  }
  return (false)
}

function currentWordIsCap (sentence, i, parameter) {
  const currentWord = sentence.taggedWords[i].token
  return (currentWord[0] === currentWord[0].toUpperCase())
}

function currentWordParameterValues (sentence, i) {
  return [sentence[i].token]
}

function currentWordIs (sentence, i, parameter) {
  return (sentence.taggedWords[i].token === parameter)
}

function isNumeric (num) {
  return (!isNaN(num))
}

function currentWordIsNumber (sentence, i, parameter) {
  let isNumber = isNumeric(sentence.taggedWords[i].token)
  // Attempt to parse it as a float
  if (!isNumber) {
    isNumber = parseFloat(sentence.taggedWords[i].token)
  }
  return ((parameter === &#039;YES&#039;) ? isNumber : !isNumber)
}

// Checks if the current word is a url
// Adapted from the original Javascript Brill tagger
function currentWordIsURL (sentence, i, parameter) {
  let isURL = false
  if (sentence.taggedWords[i].token.indexOf(&#039;.&#039;) &gt; -1) {
    // url if there are two contiguous alpha characters
    if (/[a-zA-Z]{2}/.test(sentence.taggedWords[i].token)) {
      isURL = true
    }
  }
  return ((parameter === &#039;YES&#039;) ? isURL : !isURL)
}

function currentWordAnd2TagAfterAre (sentence, i, parameter1, parameter2) {
  if (i &lt; sentence.taggedWords.length - 2) {
    if (sentence.taggedWords[i + 2][1] === parameter2) {
      return (sentence.taggedWords[i].token === parameter1)
    } else {
      return (false)
    }
  } else {
    return (false)
  }
}

function twoTagAfterParameterValues (sentence, i) {
  if (i &lt; sentence.taggedWords.length - 2) {
    return [sentence.taggedWords[i + 2].tag]
  } else {
    return []
  }
}

function currentWordAndNextTagAre (sentence, i, parameter1, parameter2) {
  let nextTag = false
  // check current word
  const currentWord = (sentence.taggedWords[i].token === parameter1)
  // check next tag
  if (i &lt; sentence.taggedWords.length - 1) {
    nextTag = (sentence.taggedWords[i + 1].tag === parameter2)
  }
  return (currentWord &amp;&amp; nextTag)
}

function currentWordAndPrevTagAre (sentence, i, parameter1, parameter2) {
  let prevTag = false
  // check current word
  const currentWord = (sentence.taggedWords[i].token === parameter2)
  // check prev tag
  if (i &gt; 0) {
    prevTag = (sentence.taggedWords[i - 1].tag === parameter1)
  }
  return (currentWord &amp;&amp; prevTag)
}

function currentWordAnd2TagBeforeAre (sentence, i, parameter1, parameter2) {
  let twoTagsBefore = false
  // check current word
  const currentWord = (sentence.taggedWords[i].token === parameter2)
  if (i &gt; 1) {
    // check two tags before
    twoTagsBefore = (sentence.taggedWords[i - 2].tag === parameter1)
  }
  return (currentWord &amp;&amp; twoTagsBefore)
}

function twoTagBeforeParameterValues (sentence, i) {
  if (i &gt; 1) {
    return [sentence.taggedWords[i - 2].tag]
  } else {
    return []
  }
}

function currentWordAnd2AfterAre (sentence, i, parameter1, parameter2) {
  let twoWordsAfter = false
  // check current word
  const currentWord = (sentence.taggedWords[i].token === parameter1)
  if (i &lt; sentence.taggedWords.length - 2) {
    twoWordsAfter = (sentence.taggedWords[i + 2].token === parameter2)
  }
  return (currentWord &amp;&amp; twoWordsAfter)
}

function prevWordIs (sentence, i, parameter) {
  if (i &gt; 0) {
    return (sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase())
  } else {
    return (false)
  }
}

// Returns the right value for parameter 1 of prevWordIs
function prevWordParameterValues (sentence, i) {
  if (i &gt; 0) {
    return [sentence.taggedWords[i - 1].token]
  } else {
    return []
  }
}

function prev1Or2WordIs (sentence, i, parameter) {
  let prev1 = false
  let prev2 = false
  if (i &gt; 0) {
    prev1 = (sentence.taggedWords[i - 1].token.toLowerCase() === parameter.toLowerCase())
  }
  if (i &gt; 1) {
    prev2 = (sentence.taggedWords[i - 2].token.toLowerCase() === parameter.toLowerCase())
  }
  return (prev1 || prev2)
}

function prev1Or2WordParameterValues (sentence, i) {
  const values = []
  if (i &gt; 0) {
    values.push(sentence[i - 1].token)
  }
  if (i &gt; 1) {
    values.push(sentence[i - 2].token)
  }
  return values
}

// Indicates whether or not this string ends with the specified string.
// Adapted from the original Javascript Brill tagger
function currentWordEndsWith (sentence, i, parameter) {
  const word = sentence.taggedWords[i].token
  if (!parameter || (parameter.length &gt; word.length)) {
    return false
  }
  return (word.indexOf(parameter) === (word.length - parameter.length))
}

// sentence is an array of token records
function currentWordEndsWithParameterValues (sentence, i) {
  const values = [&#039;ing&#039;]

  return values
}

function rightBigramIs (sentence, i, parameter1, parameter2) {
  const word1 = (sentence.taggedWords[i].token === parameter1)
  let word2 = false
  if (i &lt; sentence.taggedWords.length - 1) {
    word2 = (sentence.taggedWords[i + 1].token === parameter2)
  }
  return (word1 &amp;&amp; word2)
}

function leftBigramIs (sentence, i, parameter1, parameter2) {
  let word1 = false
  const word2 = (sentence.taggedWords[i].token === parameter2)
  if (i &gt; 0) {
    word1 = (sentence.taggedWords[i - 1].token === parameter1)
  }
  return (word1 &amp;&amp; word2)
}

function nextBigramIs (sentence, i, parameter1, parameter2) {
  let word1 = false
  let word2 = false
  if (i &lt; sentence.taggedWords.length - 1) {
    word1 = (sentence.taggedWords[i + 1].token === parameter1)
  }
  if (i &lt; sentence.taggedWords.length - 2) {
    word2 = (sentence.taggedWords[i + 2].token === parameter2)
  }
  return (word1 &amp;&amp; word2)
}

function twoWordAfterParameterValues (sentence, i) {
  if (i &lt; sentence.taggedWords.length - 2) {
    return [sentence.taggedWords[i + 2].token]
  } else {
    return []
  }
}

function prevBigramIs (sentence, i, parameter1, parameter2) {
  let word1 = false
  let word2 = false
  if (i &gt; 1) {
    word1 = (sentence.taggedWords[i - 2].token === parameter1)
  }
  if (i &gt; 0) {
    word2 = (sentence.taggedWords[i - 1].token === parameter2)
  }
  return (word1 &amp;&amp; word2)
}

function twoWordBeforeParameterValues (sentence, i) {
  if (i &gt; 1) {
    return [sentence.taggedWords[i - 2].token]
  } else {
    return []
  }
}

function next1Or2WordIs (sentence, i, parameter1, parameter2) {
  let next1 = false
  let next2 = false
  if (i &lt; sentence.taggedWords.length - 1) {
    next1 = (sentence.taggedWords[i + 1].token === parameter1)
  }
  if (i &lt; sentence.taggedWords.length - 2) {
    next2 = (sentence.taggedWords[i + 2].token === parameter2)
  }
  return (next1 || next2)
}

function next1Or2WordParameterValues (sentence, i) {
  const values = []
  if (i &lt; sentence.taggedWords.length - 1) {
    values.push(sentence.taggedWords[i + 1].token)
  }
  if (i &lt; sentence.taggedWords.length - 2) {
    values.push(sentence.taggedWords[i + 2].token)
  }
  return values
}

// ==================================
// Predicates about tags
// ==================================
function nextTagIs (sentence, i, parameter) {
  if (i &lt; sentence.taggedWords.length - 1) {
    return (sentence.taggedWords[i + 1].tag === parameter)
  } else {
    return (false)
  }
}

function nextTagParameterValues (sentence, i) {
  if (i &lt; sentence.taggedWords.length - 1) {
    return [sentence.taggedWords[i + 1].tag]
  } else {
    return []
  }
}

function next2TagIs (sentence, i, parameter) {
  if (i &lt; sentence.taggedWords.length - 2) {
    return (sentence.taggedWords[i + 2].tag === parameter)
  } else {
    return (false)
  }
}

function next2TagParameterValues (sentence, i) {
  if (i &lt; sentence.taggedWords.length - 2) {
    return [sentence.taggedWords[i + 2].tag]
  } else {
    return []
  }
}

function next1Or2TagIs (sentence, i, parameter) {
  let next1 = false
  let next2 = false
  if (i &lt; sentence.taggedWords.length - 1) {
    next1 = (sentence.taggedWords[i + 1].tag === parameter)
  }
  if (i &lt; sentence.taggedWords.length - 2) {
    next2 = (sentence.taggedWords[i + 2].tag === parameter)
  }
  return (next1 || next2)
}

function next1Or2TagIsParameterValues (sentence, i) {
  const values = []
  if (i &lt; sentence.taggedWords.length - 1) {
    values.push(sentence.taggedWords[i + 1].tag)
  }
  if (i &lt; sentence.taggedWords.length - 2) {
    values.push(sentence.taggedWords[i + 2].tag)
  }
  return values
}

function next1Or2Or3Tag (sentence, i, parameter) {
  let next3 = false
  if (i &lt; sentence.taggedWords.length - 3) {
    next3 = (sentence.taggedWords[i + 3].tag === parameter)
  }
  return (next1Or2TagIs(sentence, i, parameter) || next3)
}

function next1Or2Or3TagParameterValues (sentence, i) {
  const values = next1Or2TagIsParameterValues(sentence, i)
  if (i &lt; sentence.taggedWords.length - 3) {
    values.push(sentence.taggedWords[i + 3].tag)
  }
  return values
}

function surroundedByTags (sentence, i, parameter1, parameter2) {
  if (i &lt; sentence.taggedWords.length - 1) {
    // check next tag
    if (sentence.taggedWords[i + 1].tag === parameter2) {
      // check previous tag
      if (i &gt; 0) {
        return (sentence.taggedWords[i - 1].tag === parameter1)
      } else {
        return (false)
      }
    } else {
      return (false)
    }
  } else {
    return (false)
  }
}

function prev1Or2Or3Tag (sentence, i, parameter) {
  let prev3 = null
  if (i &gt; 2) {
    prev3 = sentence.taggedWords[i - 3].tag
  }
  return (prev1Or2Tag(sentence, i, parameter) || (prev3 === parameter))
}

function prev1Or2Or3TagParameterValues (sentence, i) {
  const values = prev1Or2TagParameterValues(sentence, i)
  if (i &gt; 2) {
    values.push(sentence.taggedWords[i - 3].tag)
  }
  return values
}

function prev1Or2Tag (sentence, i, parameter) {
  let prev1 = null
  if (i &gt; 0) {
    prev1 = sentence.taggedWords[i - 1].tag
  }
  let prev2 = null
  if (i &gt; 1) {
    prev2 = sentence.taggedWords[i - 2].tag
  }
  return ((prev1 === parameter) || (prev2 === parameter))
}

function prev1Or2TagParameterValues (sentence, i) {
  const values = []
  if (i &gt; 0) {
    values.push(sentence.taggedWords[i - 1].tag)
  }
  if (i &gt; 1) {
    values.push(sentence.taggedWords[i - 2].tag)
  }
  return values
}

function prevTagIs (sentence, i, parameter) {
  let prev = false
  if (i &gt; 0) {
    prev = (sentence.taggedWords[i - 1].tag === parameter)
  }
  return (prev)
}

function prevTagParameterValues (sentence, i) {
  if (i &gt; 0) {
    return [sentence.taggedWords[i - 1].tag]
  } else {
    return []
  }
}

// Looks like a useless predicate because transformation already take the
// current tag into account
/*
function currentWordIsTag (sentence, i, parameter) {
  return (sentence.taggedWords[i].tag === parameter)
}
*/

function prev2TagIs (sentence, i, parameter) {
  let prev2 = false
  if (i &gt; 1) {
    prev2 = (sentence.taggedWords[i - 2].tag === parameter)
  }
  return (prev2)
}

function defaultPredicate (sentence, i, parameter) {
  return (false)
}

module.exports = ruleTemplates
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
