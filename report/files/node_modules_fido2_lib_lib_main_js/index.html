<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/lib/main.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/lib/main.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">798</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const crypto = require(&quot;crypto&quot;);
const {
	Fido2AttestationResult,
	Fido2AssertionResult,
} = require(&quot;./response&quot;);
const {
	coerceToArrayBuffer,
	abToBuf,
	printHex,
} = require(&quot;./utils&quot;);
const {
	MdsCollection,
} = require(&quot;./mds&quot;);

var globalAttestationMap = new Map();
var globalExtensionMap = new Map();
var globalMdsCollection = new Map();

/**
 * The main FIDO2 server class
 */
class Fido2Lib {
	/**
    * Creates a FIDO2 server class
    * @param {Object} opts Options for the server
    * @param {Number} [opts.timeout=60000] The amount of time to wait, in milliseconds, before a call has timed out
    * @param {String} [opts.rpId=&quot;localhost&quot;] The name of the server
    * @param {String} [opts.rpName=&quot;Anonymous Service&quot;] The name of the server
    * @param {String} [opts.rpIcon] A URL for the service&#039;s icon. Can be a [RFC 2397]{@link https://tools.ietf.org/html/rfc2397} data URL.
    * @param {Number} [opts.challengeSize=64] The number of bytes to use for the challenge
    * @param {Object} [opts.authenticatorSelectionCriteria] An object describing what types of authenticators are allowed to register with the service.
    * See [AuthenticatorSelectionCriteria]{@link https://w3.org/TR/webauthn/#authenticatorSelection} in the WebAuthn spec for details.
    * @param {String} [opts.authenticatorAttachment] Indicates whether authenticators should be part of the OS (&quot;platform&quot;), or can be roaming authenticators (&quot;cross-platform&quot;)
    * @param {Boolean} [opts.authenticatorRequireResidentKey] Indicates whether authenticators must store the key internally (true) or if they can use a KDF to generate keys
    * @param {String} [opts.authenticatorUserVerification] Indicates whether user verification should be performed. Options are &quot;required&quot;, &quot;preferred&quot;, or &quot;discouraged&quot;.
    * @param {String} [opts.attestation=&quot;direct&quot;] The preferred attestation type to be used.
    * See [AttestationConveyancePreference]{https://w3.org/TR/webauthn/#enumdef-attestationconveyancepreference} in the WebAuthn spec
    * @param {Array&lt;Number&gt;} [opts.cryptoParams] A list of COSE algorithm identifiers (e.g. -7)
    * ordered by the preference in which the authenticator should use them.
    */
	constructor(opts) {
		/* eslint complexity: [&quot;off&quot;] */
		opts = opts || {};

		// set defaults
		this.config = {};

		// timeout
		this.config.timeout = (opts.timeout === undefined) ? 60000 : opts.timeout; // 1 minute
		checkOptType(this.config, &quot;timeout&quot;, &quot;number&quot;);
		if (!(this.config.timeout &gt;&gt;&gt; 0 === parseFloat(this.config.timeout))) {
			throw new RangeError(&quot;timeout should be zero or positive integer&quot;);
		}

		// challengeSize
		this.config.challengeSize = opts.challengeSize || 64;
		checkOptType(this.config, &quot;challengeSize&quot;, &quot;number&quot;);
		if (this.config.challengeSize &lt; 32) {
			throw new RangeError(&quot;challenge size too small, must be 32 or greater&quot;);
		}

		// rpId
		this.config.rpId = opts.rpId;
		checkOptType(this.config, &quot;rpId&quot;, &quot;string&quot;);

		// rpName
		this.config.rpName = opts.rpName || &quot;Anonymous Service&quot;;
		checkOptType(this.config, &quot;rpName&quot;, &quot;string&quot;);

		// rpIcon
		this.config.rpIcon = opts.rpIcon;
		checkOptType(this.config, &quot;rpIcon&quot;, &quot;string&quot;);

		// authenticatorRequireResidentKey
		this.config.authenticatorRequireResidentKey = opts.authenticatorRequireResidentKey;
		checkOptType(this.config, &quot;authenticatorRequireResidentKey&quot;, &quot;boolean&quot;);

		// authenticatorAttachment
		this.config.authenticatorAttachment = opts.authenticatorAttachment;
		if (this.config.authenticatorAttachment !== undefined &amp;&amp;
            (this.config.authenticatorAttachment !== &quot;platform&quot; &amp;&amp;
            this.config.authenticatorAttachment !== &quot;cross-platform&quot;)) {
			throw new TypeError(&quot;expected authenticatorAttachment to be &#039;platform&#039;, or &#039;cross-platform&#039;, got: &quot; + this.config.authenticatorAttachment);
		}

		// authenticatorUserVerification
		this.config.authenticatorUserVerification = opts.authenticatorUserVerification;
		if (this.config.authenticatorUserVerification !== undefined &amp;&amp;
            (this.config.authenticatorUserVerification !== &quot;required&quot; &amp;&amp;
            this.config.authenticatorUserVerification !== &quot;preferred&quot; &amp;&amp;
            this.config.authenticatorUserVerification !== &quot;discouraged&quot;)) {
			throw new TypeError(&quot;expected authenticatorUserVerification to be &#039;required&#039;, &#039;preferred&#039;, or &#039;discouraged&#039;, got: &quot; + this.config.authenticatorUserVerification);
		}

		// attestation
		this.config.attestation = opts.attestation || &quot;direct&quot;;
		if (this.config.attestation !== &quot;direct&quot; &amp;&amp;
            this.config.attestation !== &quot;indirect&quot; &amp;&amp;
            this.config.attestation !== &quot;none&quot;) {
			throw new TypeError(&quot;expected attestation to be &#039;direct&#039;, &#039;indirect&#039;, or &#039;none&#039;, got: &quot; + this.config.attestation);
		}

		// cryptoParams
		this.config.cryptoParams = opts.cryptoParams || [-7, -257];
		checkOptType(this.config, &quot;cryptoParams&quot;, Array);
		if (this.config.cryptoParams.length &lt; 1) {
			throw new TypeError(&quot;cryptoParams must have at least one element&quot;);
		}
		this.config.cryptoParams.forEach((param) =&gt; {
			checkOptType({ cryptoParam: param }, &quot;cryptoParam&quot;, &quot;number&quot;);
		});

		this.attestationMap = globalAttestationMap;
		this.extSet = new Set(); // enabled extensions (all disabled by default)
		this.extOptMap = new Map(); // default options for extensions

		// TODO: convert icon file to data-URL icon
		// TODO: userVerification
	}

	/**
     * Gets a challenge and any other parameters for the `navigator.credentials.create()` call
     * The `challenge` property is an `ArrayBuffer` and will need to be encoded to be transmitted to the client.
     * @param {Object} [opts] An object containing various options for the option creation
     * @param {Object} [opts.extensionOptions] An object that contains the extensions to enable, and the options to use for each of them.
     * The keys of this object are the names of the extensions (e.g. - &quot;appid&quot;), and the value of each key is the option that will
     * be passed to that extension when it is generating the value to send to the client. This object overrides the extensions that
     * have been set with {@link enableExtension} and the options that have been set with {@link setExtensionOptions}. If an extension
     * was enabled with {@link enableExtension} but it isn&#039;t included in this object, the extension won&#039;t be sent to the client. Likewise,
     * if an extension was disabled with {@link disableExtension} but it is included in this object, it will be sent to the client.
     * @param {String} [extraData] Extra data to be signed by the authenticator during attestation. The challenge will be a hash:
     * SHA256(rawChallenge + extraData) and the `rawChallenge` will be returned as part of PublicKeyCredentialCreationOptions.
     * @returns {Promise&lt;PublicKeyCredentialCreationOptions&gt;} The options for creating calling `navigator.credentials.create()`
     */
	async attestationOptions(opts) {
		opts = opts || {};

		// The object being returned is described here:
		// https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions
		var challenge = crypto.randomBytes(this.config.challengeSize);
		challenge = coerceToArrayBuffer(challenge, &quot;challenge&quot;);
		var pubKeyCredParams = [];
		this.config.cryptoParams.forEach((coseId) =&gt; {
			pubKeyCredParams.push({
				type: &quot;public-key&quot;,
				alg: coseId });
		});

		// mix extraData into challenge
		let rawChallenge;
		if (opts.extraData) {
			rawChallenge = challenge;
			let extraData = coerceToArrayBuffer(opts.extraData, &quot;extraData&quot;);
			let hash = crypto.createHash(&quot;sha256&quot;);
			hash.update(abToBuf(challenge));
			hash.update(abToBuf(extraData));
			challenge = new Uint8Array(hash.digest()).buffer;
		}

		var options = {
			rp: {},
			user: {},
		};

		var extensions = createExtensions.call(this, &quot;attestation&quot;, opts.extensionOptions);

		/**
         * @typedef {Object} PublicKeyCredentialCreationOptions
         * @description This object is returned by {@link attestationOptions} and is basially the same as
         * the [PublicKeyCredentialCreationOptions]{@link https://w3.org/TR/webauthn/#dictdef-publickeycredentialcreationoptions}
         * object that is required to be passed to `navigator.credentials.create()`. With the exception of the `challenge` property,
         * all other properties are optional and only set if they were specified in the configuration paramater
         * that was passed to the constructor.
         * @property {Object} rp Relying party information (a.k.a. - server / service information)
         * @property {String} [rp.name] Relying party name (e.g. - &quot;ACME&quot;). This is only set if `rpName` was specified during the `new` call.
         * @property {String} [rp.id] Relying party ID, a domain name (e.g. - &quot;example.com&quot;). This is only set if `rpId` was specified during the `new` call.
         * @property {Object} user User information. This will be an empty object
         * @property {ArrayBuffer} challenge An ArrayBuffer filled with random bytes. This will be verified in {@link attestationResult}
         * @property {Array} [pubKeyCredParams] A list of PublicKeyCredentialParameters objects, based on the `cryptoParams` that was passed to the constructor.
         * @property {Number} [timeout] The amount of time that the call should take before returning an error
         * @property {String} [attestation] Whether the client should request attestation from the authenticator or not
         * @property {Object} [authenticatorSelectionCriteria] A object describing which authenticators are preferred for registration
         * @property {String} [authenticatorSelectionCriteria.attachment] What type of attachement is acceptable for new authenticators.
         * Allowed values are &quot;platform&quot;, meaning that the authenticator is embedded in the operating system, or
         * &quot;cross-platform&quot;, meaning that the authenticator is removeable (e.g. USB, NFC, or BLE).
         * @property {Boolean} [authenticatorSelectionCriteria.requireResidentKey] Indicates whether authenticators must store the keys internally, or if they can
         * store them externally (using a KDF or key wrapping)
         * @property {String} [authenticatorSelectionCriteria.userVerification] Indicates whether user verification is required for authenticators. User verification
         * means that an authenticator will validate a use through their biometrics (e.g. fingerprint) or knowledge (e.g. PIN). Allowed
         * values for `userVerification` are &quot;required&quot;, meaning that registration will fail if no authenticator provides user verification;
         * &quot;preferred&quot;, meaning that if multiple authenticators are available, the one(s) that provide user verification should be used; or
         * &quot;discouraged&quot;, which means that authenticators that don&#039;t provide user verification are preferred.
         * @property {ArrayBuffer} [rawChallenge] If `extraData` was passed to {@link attestationOptions}, this
         * will be the original challenge used, and `challenge` will be a hash:
         * SHA256(rawChallenge + extraData)
         * @property {Object} [extensions] The values of any enabled extensions.
         */
		setOpt(options.rp, &quot;name&quot;, this.config.rpName);
		setOpt(options.rp, &quot;id&quot;, this.config.rpId);
		setOpt(options.rp, &quot;icon&quot;, this.config.rpIcon);
		setOpt(options, &quot;challenge&quot;, challenge);
		setOpt(options, &quot;pubKeyCredParams&quot;, pubKeyCredParams);
		setOpt(options, &quot;timeout&quot;, this.config.timeout);
		setOpt(options, &quot;attestation&quot;, this.config.attestation);
		if (this.config.authenticatorAttachment !== undefined ||
            this.config.authenticatorRequireResidentKey !== undefined ||
            this.config.authenticatorUserVerification !== undefined) {
			options.authenticatorSelection = {};
			setOpt(options.authenticatorSelection, &quot;authenticatorAttachment&quot;, this.config.authenticatorAttachment);
			setOpt(options.authenticatorSelection, &quot;requireResidentKey&quot;, this.config.authenticatorRequireResidentKey);
			setOpt(options.authenticatorSelection, &quot;userVerification&quot;, this.config.authenticatorUserVerification);
		}
		setOpt(options, &quot;rawChallenge&quot;, rawChallenge);

		if (Object.keys(extensions).length &gt; 0) {
			options.extensions = extensions;
		}

		return options;
	}

	/**
     * Parses and validates an attestation response from the client
     * @param {Object} res The assertion result that was generated by the client.
     * See {@link https://w3.org/TR/webauthn/#authenticatorattestationresponse AuthenticatorAttestationResponse} in the WebAuthn spec.
     * @param {String} [res.id] The base64url encoded id returned by the client
     * @param {String} [res.rawId] The base64url encoded rawId returned by the client. If `res.rawId` is missing, `res.id` will be used instead. If both are missing an error will be thrown.
     * @param {String} res.response.clientDataJSON The base64url encoded clientDataJSON returned by the client
     * @param {String} res.response.authenticatorData The base64url encoded authenticatorData returned by the client
     * @param {Object} expected The expected parameters for the assertion response.
     * If these parameters don&#039;t match the recieved values, validation will fail and an error will be thrown.
     * @param {String} expected.challenge The base64url encoded challenge that was sent to the client, as generated by [assertionOptions]{@link Fido2Lib#assertionOptions}
     * @param {String} expected.origin The expected origin that the authenticator has signed over. For example, &quot;https://localhost:8443&quot; or &quot;https://webauthn.org&quot;
     * @param {String} expected.factor Which factor is expected for the assertion. Valid values are &quot;first&quot;, &quot;second&quot;, or &quot;either&quot;.
     * If &quot;first&quot;, this requires that the authenticator performed user verification (e.g. - biometric authentication, PIN authentication, etc.).
     * If &quot;second&quot;, this requires that the authenticator performed user presence (e.g. - user pressed a button).
     * If &quot;either&quot;, then either &quot;first&quot; or &quot;second&quot; is acceptable
     * @return {Promise&lt;Fido2AttestationResult&gt;} Returns a Promise that resolves to a {@link Fido2AttestationResult}
     * @throws {Error} If parsing or validation fails
     */
	async attestationResult(res, expected) {
		expected.flags = factorToFlags(expected.factor, [&quot;AT&quot;]);
		delete expected.factor;
		return Fido2AttestationResult.create(res, expected);
	}

	/**
     * Creates an assertion challenge and any other parameters for the `navigator.credentials.get()` call.
     * The `challenge` property is an `ArrayBuffer` and will need to be encoded to be transmitted to the client.
     * @param {Object} [opts] An object containing various options for the option creation
     * @param {Object} [opts.extensionOptions] An object that contains the extensions to enable, and the options to use for each of them.
     * The keys of this object are the names of the extensions (e.g. - &quot;appid&quot;), and the value of each key is the option that will
     * be passed to that extension when it is generating the value to send to the client. This object overrides the extensions that
     * have been set with {@link enableExtension} and the options that have been set with {@link setExtensionOptions}. If an extension
     * was enabled with {@link enableExtension} but it isn&#039;t included in this object, the extension won&#039;t be sent to the client. Likewise,
     * if an extension was disabled with {@link disableExtension} but it is included in this object, it will be sent to the client.
     * @param {String} [extraData] Extra data to be signed by the authenticator during attestation. The challenge will be a hash:
     * SHA256(rawChallenge + extraData) and the `rawChallenge` will be returned as part of PublicKeyCredentialCreationOptions.
     * @returns {Promise&lt;PublicKeyCredentialRequestOptions&gt;} The options to be passed to `navigator.credentials.get()`
     */
	async assertionOptions(opts) {
		opts = opts || {};

		// https://w3c.github.io/webauthn/#dictdef-publickeycredentialcreationoptions
		var challenge = crypto.randomBytes(this.config.challengeSize);
		challenge = coerceToArrayBuffer(challenge, &quot;challenge&quot;);
		var options = {};

		// mix extraData into challenge
		let rawChallenge;
		if (opts.extraData) {
			rawChallenge = challenge;
			let extraData = coerceToArrayBuffer(opts.extraData, &quot;extraData&quot;);
			let hash = crypto.createHash(&quot;sha256&quot;);
			hash.update(abToBuf(challenge));
			hash.update(abToBuf(extraData));
			challenge = new Uint8Array(hash.digest()).buffer;
		}

		var extensions = createExtensions.call(this, &quot;assertion&quot;, opts.extensionOptions);

		/**
         * @typedef {Object} PublicKeyCredentialRequestOptions
         * @description This object is returned by {@link assertionOptions} and is basially the same as
         * the [PublicKeyCredentialRequestOptions]{@link https://w3.org/TR/webauthn/#dictdef-publickeycredentialrequestoptions}
         * object that is required to be passed to `navigator.credentials.get()`. With the exception of the `challenge` property,
         * all other properties are optional and only set if they were specified in the configuration paramater
         * that was passed to the constructor.
         * @property {ArrayBuffer} challenge An ArrayBuffer filled with random bytes. This will be verified in {@link attestationResult}
         * @property {Number} [timeout] The amount of time that the call should take before returning an error
         * @property {String} [rpId] Relying party ID, a domain name (e.g. - &quot;example.com&quot;). This is only set if `rpId` was specified during the `new` call.
         * @property {String} [attestation] Whether the client should request attestation from the authenticator or not
         * @property {String} [userVerification] Indicates whether user verification is required for authenticators. User verification
         * means that an authenticator will validate a use through their biometrics (e.g. fingerprint) or knowledge (e.g. PIN). Allowed
         * values for `userVerification` are &quot;required&quot;, meaning that authentication will fail if no authenticator provides user verification;
         * &quot;preferred&quot;, meaning that if multiple authenticators are available, the one(s) that provide user verification should be used; or
         * &quot;discouraged&quot;, which means that authenticators that don&#039;t provide user verification are preferred.
         * @property {ArrayBuffer} [rawChallenge] If `extraData` was passed to {@link attestationOptions}, this
         * will be the original challenge used, and `challenge` will be a hash:
         * SHA256(rawChallenge + extraData)
         * @property {Object} [extensions] The values of any enabled extensions.
         */
		setOpt(options, &quot;challenge&quot;, challenge);
		setOpt(options, &quot;timeout&quot;, this.config.timeout);
		setOpt(options, &quot;rpId&quot;, this.config.rpId);
		setOpt(options, &quot;userVerification&quot;, this.config.authenticatorUserVerification);

		setOpt(options, &quot;rawChallenge&quot;, rawChallenge);

		if (Object.keys(extensions).length &gt; 0) {
			options.extensions = extensions;
		}

		return options;
	}

	/**
     * Parses and validates an assertion response from the client
     * @param {Object} res The assertion result that was generated by the client.
     * See {@link https://w3.org/TR/webauthn/#authenticatorassertionresponse AuthenticatorAssertionResponse} in the WebAuthn spec.
     * @param {String} [res.id] The base64url encoded id returned by the client
     * @param {String} [res.rawId] The base64url encoded rawId returned by the client. If `res.rawId` is missing, `res.id` will be used instead. If both are missing an error will be thrown.
     * @param {String} res.response.clientDataJSON The base64url encoded clientDataJSON returned by the client
     * @param {String} res.response.attestationObject The base64url encoded authenticatorData returned by the client
     * @param {String} res.response.signature The base64url encoded signature returned by the client
     * @param {String|null} [res.response.userHandle] The base64url encoded userHandle returned by the client. May be null or an empty string.
     * @param {Object} expected The expected parameters for the assertion response.
     * If these parameters don&#039;t match the recieved values, validation will fail and an error will be thrown.
     * @param {String} expected.challenge The base64url encoded challenge that was sent to the client, as generated by [assertionOptions]{@link Fido2Lib#assertionOptions}
     * @param {String} expected.origin The expected origin that the authenticator has signed over. For example, &quot;https://localhost:8443&quot; or &quot;https://webauthn.org&quot;
     * @param {String} expected.factor Which factor is expected for the assertion. Valid values are &quot;first&quot;, &quot;second&quot;, or &quot;either&quot;.
     * If &quot;first&quot;, this requires that the authenticator performed user verification (e.g. - biometric authentication, PIN authentication, etc.).
     * If &quot;second&quot;, this requires that the authenticator performed user presence (e.g. - user pressed a button).
     * If &quot;either&quot;, then either &quot;first&quot; or &quot;second&quot; is acceptable
     * @param {String} expected.publicKey A PEM encoded public key that will be used to validate the assertion response signature.
     * This is the public key that was returned for this user during [attestationResult]{@link Fido2Lib#attestationResult}
     * @param {Number} expected.prevCounter The previous value of the signature counter for this authenticator.
     * @param {String|null} expected.userHandle The expected userHandle, which was the user.id during registration
     * @return {Promise&lt;Fido2AssertionResult&gt;} Returns a Promise that resolves to a {@link Fido2AssertionResult}
     * @throws {Error} If parsing or validation fails
     */
	async assertionResult(res, expected) {
		expected.flags = factorToFlags(expected.factor, []);
		delete expected.factor;
		return Fido2AssertionResult.create(res, expected);
	}

	/**
     * Adds a new attestation format that will automatically be recognized and parsed
     * for any future {@link Fido2CreateRequest} messages
     * @param {String} fmt The name of the attestation format, as it appears in the
     * ARIN registry and / or as it will appear in the {@link Fido2CreateRequest}
     * message that is received
     * @param {Function} parseFn The function that will be called to parse the
     * attestation format. It will receive the `attStmt` as a parameter and will be
     * called from the context (`this`) of the `Fido2CreateRequest`
     * @param {Function} validateFn The function that will be called to validate the
     * attestation format. It will receive no arguments, as all the necessary
     * information for validating the attestation statement will be contained in the
     * calling context (`this`).
     */
	static addAttestationFormat(fmt, parseFn, validateFn) {
		// validate input
		if (typeof fmt !== &quot;string&quot;) {
			throw new TypeError(&quot;expected &#039;fmt&#039; to be string, got: &quot; + typeof fmt);
		}

		if (typeof parseFn !== &quot;function&quot;) {
			throw new TypeError(&quot;expected &#039;parseFn&#039; to be string, got: &quot; + typeof parseFn);
		}

		if (typeof validateFn !== &quot;function&quot;) {
			throw new TypeError(&quot;expected &#039;validateFn&#039; to be string, got: &quot; + typeof validateFn);
		}

		if (globalAttestationMap.has(fmt)) {
			throw new Error(`can&#039;t add format: &#039;${fmt}&#039; already exists`);
		}

		// add to attestationMap
		globalAttestationMap.set(fmt, {
			parseFn,
			validateFn,
		});

		return true;
	}

	/**
     * Deletes all currently registered attestation formats.
     */
	static deleteAllAttestationFormats() {
		globalAttestationMap.clear();
	}

	/**
     * Parses an attestation statememnt of the format specified
     * @private
     * @param {String} fmt The name of the format to be parsed, as specified in the
     * ARIN registry of attestation formats.
     * @param {Object} attStmt The attestation object to be parsed.
     * @return {Map} A Map of all the attestation fields that were parsed.
     * At this point the fields have not yet been verified.
     * @throws {Error} when a field cannot be parsed or verified.
     * @throws {TypeError} when supplied parameters `fmt` or `attStmt` are of the
     * wrong type
     */
	static parseAttestation(fmt, attStmt) {
		// validate input
		if (typeof fmt !== &quot;string&quot;) {
			throw new TypeError(&quot;expected &#039;fmt&#039; to be string, got: &quot; + typeof fmt);
		}

		if (typeof attStmt !== &quot;object&quot;) {
			throw new TypeError(&quot;expected &#039;attStmt&#039; to be object, got: &quot; + typeof attStmt);
		}

		// get from attestationMap
		var fmtObj = globalAttestationMap.get(fmt);
		if (typeof fmtObj !== &quot;object&quot; ||
            typeof fmtObj.parseFn !== &quot;function&quot; ||
            typeof fmtObj.validateFn !== &quot;function&quot;) {
			throw new Error(`no support for attestation format: ${fmt}`);
		}

		// call fn
		var ret = fmtObj.parseFn.call(this, attStmt);

		// validate return
		if (!(ret instanceof Map)) {
			throw new Error(`${fmt} parseFn did not return a Map`);
		}

		// return result
		return new Map([
			[&quot;fmt&quot;, fmt],
			...ret,
		]);
	}

	/**
     * Validates an attestation response. Will be called within the context (`this`) of a {@link Fido2AttestationResult}
     * @private
     */
	static async validateAttestation() {
		var fmt = this.authnrData.get(&quot;fmt&quot;);

		// validate input
		if (typeof fmt !== &quot;string&quot;) {
			throw new TypeError(&quot;expected &#039;fmt&#039; to be string, got: &quot; + typeof fmt);
		}

		// get from attestationMap
		var fmtObj = globalAttestationMap.get(fmt);
		if (typeof fmtObj !== &quot;object&quot; ||
            typeof fmtObj.parseFn !== &quot;function&quot; ||
            typeof fmtObj.validateFn !== &quot;function&quot;) {
			throw new Error(`no support for attestation format: ${fmt}`);
		}

		// call fn
		var ret = await fmtObj.validateFn.call(this);

		// validate return
		if (ret !== true) {
			throw new Error(`${fmt} validateFn did not return &#039;true&#039;`);
		}

		// return result
		return ret;
	}

	/**
     * Creates a new {@link MdsCollection}
     * @param {String} collectionName The name of the collection to create.
     * Used to identify the source of a {@link MdsEntry} when {@link Fido2Lib#findMdsEntry}
     * finds multiple matching entries from different sources (e.g. FIDO MDS 1 &amp; FIDO MDS 2)
     * @return {MdsCollection} The MdsCollection that was created
     * @see  MdsCollection
     */
	static createMdsCollection(collectionName) {
		return new MdsCollection(collectionName);
	}

	/**
     * Adds a new {@link MdsCollection} to the global MDS collection list that will be used for {@link findMdsEntry}
     * @param {MdsCollection} mdsCollection The MDS collection that will be used
     * @see  MdsCollection
     */
	static addMdsCollection(mdsCollection) {
		if (!(mdsCollection instanceof MdsCollection)) {
			throw new Error(&quot;expected &#039;mdsCollection&#039; to be instance of MdsCollection, got: &quot; + mdsCollection);
		}
		mdsCollection.validate();
		globalMdsCollection.set(mdsCollection.name, mdsCollection);
	}

	/**
     * Removes all entries from the global MDS collections list. Mostly used for testing.
     */
	static clearMdsCollections() {
		globalMdsCollection.clear();
	}

	/**
     * Returns {@link MdsEntry} objects that match the requested id. The
     * lookup is done by calling {@link MdsCollection#findEntry} on the current global
     * MDS collection. If no global MDS collection has been specified using
     * {@link setMdsCollection}, an `Error` will be thrown.
     * @param  {String|ArrayBuffer} id The authenticator id to look up metadata for
     * @return {Array.&lt;MdsEntry&gt;}    Returns an Array of {@link MdsEntry} for the specified id.
     * If no entry was found, the Array will be empty.
     * @see  MdsCollection
     */
	static findMdsEntry(id) {
		if (globalMdsCollection.size &lt; 1) {
			throw new Error(&quot;must set MDS collection before attempting to find an MDS entry&quot;);
		}

		var ret = [];
		for (let collection of globalMdsCollection.values()) {
			let entry = collection.findEntry(id);
			if (entry) ret.push(entry);
		}

		return ret;
	}

	/**
     * Adds a new global extension that will be available to all instantiations of
     * {@link Fido2Lib}. Note that the extension must still be enabled by calling
     * {@link enableExtension} for each instantiation of a Fido2Lib.
     * @param {String} extName     The name of the extension to add. (e.g. - &quot;appid&quot;)
     * @param {Function} optionGeneratorFn Extensions are included in
     * @param {Function} resultParserFn    [description]
     * @param {Function} resultValidatorFn [description]
     */
	static addExtension(extName, optionGeneratorFn, resultParserFn, resultValidatorFn) {
		if (typeof extName !== &quot;string&quot;) {
			throw new Error(&quot;expected &#039;extName&#039; to be String, got: &quot; + extName);
		}

		if (globalExtensionMap.has(extName)) {
			throw new Error(`the extension &#039;${extName}&#039; has already been added`);
		}

		if (typeof optionGeneratorFn !== &quot;function&quot;) {
			throw new Error(&quot;expected &#039;optionGeneratorFn&#039; to be a Function, got: &quot; + optionGeneratorFn);
		}

		if (typeof resultParserFn !== &quot;function&quot;) {
			throw new Error(&quot;expected &#039;resultParserFn&#039; to be a Function, got: &quot; + resultParserFn);
		}

		if (typeof resultValidatorFn !== &quot;function&quot;) {
			throw new Error(&quot;expected &#039;resultValidatorFn&#039; to be a Function, got: &quot; + resultValidatorFn);
		}

		globalExtensionMap.set(extName, {
			optionGeneratorFn,
			resultParserFn,
			resultValidatorFn,
		});
	}

	/**
     * Removes all extensions from the global extension registry. Mostly used for testing.
     */
	static deleteAllExtensions() {
		globalExtensionMap.clear();
	}

	/**
     * Generates the options to send to the client for the specified extension
     * @private
     * @param  {String} extName The name of the extension to generate options for. Must be a valid extension that has been registered through {@link Fido2Lib#addExtension}
     * @param  {String} type    The type of options that are being generated. Valid options are &quot;attestation&quot; or &quot;assertion&quot;.
     * @param  {Any} [options] Optional parameters to pass to the generator function
     * @return {Any}         The extension value that will be sent to the client. If `undefined`, this extension won&#039;t be included in the
     * options sent to the client.
     */
	generateExtensionOptions(extName, type, options) {
		if (typeof extName !== &quot;string&quot;) {
			throw new Error(&quot;expected &#039;extName&#039; to be String, got: &quot; + extName);
		}

		if (type !== &quot;attestation&quot; &amp;&amp; type !== &quot;assertion&quot;) {
			throw new Error(&quot;expected &#039;type&#039; to be &#039;attestation&#039; or &#039;assertion&#039;, got: &quot; + type);
		}

		var ext = globalExtensionMap.get(extName);
		if (typeof ext !== &quot;object&quot; ||
            typeof ext.optionGeneratorFn !== &quot;function&quot;) {
			throw new Error(`valid extension for &#039;${extName}&#039; not found`);
		}
		var ret = ext.optionGeneratorFn(extName, type, options);

		return ret;
	}

	static parseExtensionResult(extName, clientThing, authnrThing) {
		if (typeof extName !== &quot;string&quot;) {
			throw new Error(&quot;expected &#039;extName&#039; to be String, got: &quot; + extName);
		}

		var ext = globalExtensionMap.get(extName);
		if (typeof ext !== &quot;object&quot; ||
            typeof ext.parseFn !== &quot;function&quot;) {
			throw new Error(`valid extension for &#039;${extName}&#039; not found`);
		}
		var ret = ext.parseFn(extName, clientThing, authnrThing);

		return ret;
	}

	static validateExtensionResult(extName) {
		var ext = globalExtensionMap.get(extName);
		if (typeof ext !== &quot;object&quot; ||
            typeof ext.validateFn !== &quot;function&quot;) {
			throw new Error(`valid extension for &#039;${extName}&#039; not found`);
		}
		var ret = ext.validateFn.call(this);

		return ret;
	}

	/**
     * Enables the specified extension.
     * @param  {String} extName The name of the extension to enable. Must be a valid extension that has been registered through {@link Fido2Lib#addExtension}
     */
	enableExtension(extName) {
		if (typeof extName !== &quot;string&quot;) {
			throw new Error(&quot;expected &#039;extName&#039; to be String, got: &quot; + extName);
		}

		if (!globalExtensionMap.has(extName)) {
			throw new Error(`valid extension for &#039;${extName}&#039; not found`);
		}

		this.extSet.add(extName);
	}

	/**
     * Disables the specified extension.
     * @param  {String} extName The name of the extension to enable. Must be a valid extension that has been registered through {@link Fido2Lib#addExtension}
     */
	disableExtension(extName) {
		if (typeof extName !== &quot;string&quot;) {
			throw new Error(&quot;expected &#039;extName&#039; to be String, got: &quot; + extName);
		}

		if (!globalExtensionMap.has(extName)) {
			throw new Error(`valid extension for &#039;${extName}&#039; not found`);
		}

		this.extSet.delete(extName);
	}

	/**
     * Specifies the options to be used for the extension
     * @param  {String} extName The name of the extension to set the options for (e.g. - &quot;appid&quot;. Must be a valid extension that has been registered through {@link Fido2Lib#addExtension}
     * @param {Any} options The parameter that will be passed to the option generator function (e.g. - &quot;https://webauthn.org&quot;)
     */
	setExtensionOptions(extName, options) {
		if (typeof extName !== &quot;string&quot;) {
			throw new Error(&quot;expected &#039;extName&#039; to be String, got: &quot; + extName);
		}

		if (!globalExtensionMap.has(extName)) {
			throw new Error(`valid extension for &#039;${extName}&#039; not found`);
		}

		this.extOptMap.set(extName, options);
	}
}

function checkOptType(opts, prop, type) {
	if (typeof opts !== &quot;object&quot;) return;

	// undefined
	if (opts[prop] === undefined) return;

	// native type
	if (typeof type === &quot;string&quot;) {
		if (typeof opts[prop] !== type) {
			throw new TypeError(`expected ${prop} to be ${type}, got: ${opts[prop]}`);
		}
	}

	// class type
	if (typeof type === &quot;function&quot;) {
		if (!(opts[prop] instanceof type)) {
			throw new TypeError(`expected ${prop} to be ${type.name}, got: ${opts[prop]}`);
		}
	}
}

function setOpt(obj, prop, val) {
	if (val !== undefined) {
		obj[prop] = val;
	}
}

function factorToFlags(expectedFactor, flags) {
	// var flags = [&quot;AT&quot;];
	flags = flags || [];

	switch (expectedFactor) {
		case &quot;first&quot;:
			flags.push(&quot;UP&quot;);
			flags.push(&quot;UV&quot;);
			break;
		case &quot;second&quot;:
			flags.push(&quot;UP&quot;);
			break;
		case &quot;either&quot;:
			flags.push(&quot;UP-or-UV&quot;);
			break;
		default:
			throw new TypeError(&quot;expectedFactor should be &#039;first&#039;, &#039;second&#039; or &#039;either&#039;&quot;);
	}

	return flags;
}

function createExtensions(type, extObj) {
	/* eslint-disable no-invalid-this */
	var extensions = {};

	// default extensions
	var enabledExtensions = this.extSet;
	var extensionsOptions = this.extOptMap;

	// passed in extensions
	if (typeof extObj === &quot;object&quot;) {
		enabledExtensions = new Set(Object.keys(extObj));
		extensionsOptions = new Map();
		for (let key of Object.keys(extObj)) {
			extensionsOptions.set(key, extObj[key]);
		}
	}

	// generate extension values
	for (let extension of enabledExtensions) {
		let extVal = this.generateExtensionOptions(extension, type, extensionsOptions.get(extension));
		if (extVal !== undefined) extensions[extension] = extVal;
	}

	return extensions;
}

// add &#039;none&#039; attestation format
const noneAttestation = require(&quot;./attestations/none&quot;);
Fido2Lib.addAttestationFormat(
	noneAttestation.name,
	noneAttestation.parseFn,
	noneAttestation.validateFn
);

// add &#039;fido-u2f&#039; attestation format
const u2fAttestation = require(&quot;./attestations/fidoU2F&quot;);
Fido2Lib.addAttestationFormat(
	u2fAttestation.name,
	u2fAttestation.parseFn,
	u2fAttestation.validateFn
);

// add &#039;packed&#039; attestation format
const packedAttestation = require(&quot;./attestations/packed&quot;);
Fido2Lib.addAttestationFormat(
	packedAttestation.name,
	packedAttestation.parseFn,
	packedAttestation.validateFn
);

// add &#039;tpm&#039; attestation format
const tpmAttestation = require(&quot;./attestations/tpm&quot;);
Fido2Lib.addAttestationFormat(
	tpmAttestation.name,
	tpmAttestation.parseFn,
	tpmAttestation.validateFn
);

// add &#039;android-safetynet&#039; attestation format
const androidSafetyNetAttestation = require(&quot;./attestations/androidSafetyNet&quot;);
Fido2Lib.addAttestationFormat(
	androidSafetyNetAttestation.name,
	androidSafetyNetAttestation.parseFn,
	androidSafetyNetAttestation.validateFn
);


module.exports = {
	Fido2Lib,
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
