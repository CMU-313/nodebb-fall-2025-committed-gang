<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/Compilation.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/Compilation.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">5741</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">176.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">52.65</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const asyncLib = require(&quot;neo-async&quot;);
const {
	HookMap,
	SyncHook,
	SyncBailHook,
	SyncWaterfallHook,
	AsyncSeriesHook,
	AsyncSeriesBailHook,
	AsyncParallelHook
} = require(&quot;tapable&quot;);
const util = require(&quot;util&quot;);
const { CachedSource } = require(&quot;webpack-sources&quot;);
const { MultiItemCache } = require(&quot;./CacheFacade&quot;);
const Chunk = require(&quot;./Chunk&quot;);
const ChunkGraph = require(&quot;./ChunkGraph&quot;);
const ChunkGroup = require(&quot;./ChunkGroup&quot;);
const ChunkRenderError = require(&quot;./ChunkRenderError&quot;);
const ChunkTemplate = require(&quot;./ChunkTemplate&quot;);
const CodeGenerationError = require(&quot;./CodeGenerationError&quot;);
const CodeGenerationResults = require(&quot;./CodeGenerationResults&quot;);
const Dependency = require(&quot;./Dependency&quot;);
const DependencyTemplates = require(&quot;./DependencyTemplates&quot;);
const Entrypoint = require(&quot;./Entrypoint&quot;);
const ErrorHelpers = require(&quot;./ErrorHelpers&quot;);
const FileSystemInfo = require(&quot;./FileSystemInfo&quot;);
const {
	connectChunkGroupAndChunk,
	connectChunkGroupParentAndChild
} = require(&quot;./GraphHelpers&quot;);
const {
	makeWebpackError,
	tryRunOrWebpackError
} = require(&quot;./HookWebpackError&quot;);
const MainTemplate = require(&quot;./MainTemplate&quot;);
const Module = require(&quot;./Module&quot;);
const ModuleDependencyError = require(&quot;./ModuleDependencyError&quot;);
const ModuleDependencyWarning = require(&quot;./ModuleDependencyWarning&quot;);
const ModuleGraph = require(&quot;./ModuleGraph&quot;);
const ModuleHashingError = require(&quot;./ModuleHashingError&quot;);
const ModuleNotFoundError = require(&quot;./ModuleNotFoundError&quot;);
const ModuleProfile = require(&quot;./ModuleProfile&quot;);
const ModuleRestoreError = require(&quot;./ModuleRestoreError&quot;);
const ModuleStoreError = require(&quot;./ModuleStoreError&quot;);
const ModuleTemplate = require(&quot;./ModuleTemplate&quot;);
const { WEBPACK_MODULE_TYPE_RUNTIME } = require(&quot;./ModuleTypeConstants&quot;);
const RuntimeGlobals = require(&quot;./RuntimeGlobals&quot;);
const RuntimeTemplate = require(&quot;./RuntimeTemplate&quot;);
const Stats = require(&quot;./Stats&quot;);
const WebpackError = require(&quot;./WebpackError&quot;);
const buildChunkGraph = require(&quot;./buildChunkGraph&quot;);
const BuildCycleError = require(&quot;./errors/BuildCycleError&quot;);
const { Logger, LogType } = require(&quot;./logging/Logger&quot;);
const StatsFactory = require(&quot;./stats/StatsFactory&quot;);
const StatsPrinter = require(&quot;./stats/StatsPrinter&quot;);
const { equals: arrayEquals } = require(&quot;./util/ArrayHelpers&quot;);
const AsyncQueue = require(&quot;./util/AsyncQueue&quot;);
const LazySet = require(&quot;./util/LazySet&quot;);
const { getOrInsert } = require(&quot;./util/MapHelpers&quot;);
const WeakTupleMap = require(&quot;./util/WeakTupleMap&quot;);
const { cachedCleverMerge } = require(&quot;./util/cleverMerge&quot;);
const {
	compareLocations,
	concatComparators,
	compareSelect,
	compareIds,
	compareStringsNumeric,
	compareModulesByIdentifier
} = require(&quot;./util/comparators&quot;);
const createHash = require(&quot;./util/createHash&quot;);
const {
	arrayToSetDeprecation,
	soonFrozenObjectDeprecation,
	createFakeHook
} = require(&quot;./util/deprecation&quot;);
const processAsyncTree = require(&quot;./util/processAsyncTree&quot;);
const { getRuntimeKey } = require(&quot;./util/runtime&quot;);
const { isSourceEqual } = require(&quot;./util/source&quot;);

/** @template T @typedef {import(&quot;tapable&quot;).AsArray&lt;T&gt;} AsArray&lt;T&gt; */
/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).EntryDescriptionNormalized} EntryDescription */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).OutputNormalized} OutputOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).StatsOptions} StatsOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackPluginFunction} WebpackPluginFunction */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackPluginInstance} WebpackPluginInstance */
/** @typedef {import(&quot;./AsyncDependenciesBlock&quot;)} AsyncDependenciesBlock */
/** @typedef {import(&quot;./Cache&quot;)} Cache */
/** @typedef {import(&quot;./CacheFacade&quot;)} CacheFacade */
/** @typedef {import(&quot;./Chunk&quot;).ChunkName} ChunkName */
/** @typedef {import(&quot;./Chunk&quot;).ChunkId} ChunkId */
/** @typedef {import(&quot;./ChunkGroup&quot;).ChunkGroupOptions} ChunkGroupOptions */
/** @typedef {import(&quot;./Compiler&quot;)} Compiler */
/** @typedef {import(&quot;./Compiler&quot;).CompilationParams} CompilationParams */
/** @typedef {import(&quot;./Compiler&quot;).MemCache} MemCache */
/** @typedef {import(&quot;./Compiler&quot;).WeakReferences} WeakReferences */
/** @typedef {import(&quot;./Compiler&quot;).ModuleMemCachesItem} ModuleMemCachesItem */
/** @typedef {import(&quot;./DependenciesBlock&quot;)} DependenciesBlock */
/** @typedef {import(&quot;./Dependency&quot;).DependencyLocation} DependencyLocation */
/** @typedef {import(&quot;./Dependency&quot;).ReferencedExport} ReferencedExport */
/** @typedef {import(&quot;./DependencyTemplate&quot;)} DependencyTemplate */
/** @typedef {import(&quot;./Entrypoint&quot;).EntryOptions} EntryOptions */
/** @typedef {import(&quot;./Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;./Module&quot;).ValueCacheVersions} ValueCacheVersions */
/** @typedef {import(&quot;./Module&quot;).RuntimeRequirements} RuntimeRequirements */
/** @typedef {import(&quot;./NormalModule&quot;).NormalModuleCompilationHooks} NormalModuleCompilationHooks */
/** @typedef {import(&quot;./Module&quot;).FactoryMeta} FactoryMeta */
/** @typedef {import(&quot;./Module&quot;).CodeGenerationResult} CodeGenerationResult */
/** @typedef {import(&quot;./ModuleFactory&quot;)} ModuleFactory */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).ResolveOptions} ResolveOptions */
/** @typedef {import(&quot;./ChunkGraph&quot;).ModuleId} ModuleId */
/** @typedef {import(&quot;./ModuleGraphConnection&quot;)} ModuleGraphConnection */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryCreateDataContextInfo} ModuleFactoryCreateDataContextInfo */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import(&quot;./NormalModule&quot;).ParserOptions} ParserOptions */
/** @typedef {import(&quot;./NormalModule&quot;).GeneratorOptions} GeneratorOptions */
/** @typedef {import(&quot;./RequestShortener&quot;)} RequestShortener */
/** @typedef {import(&quot;./RuntimeModule&quot;)} RuntimeModule */
/** @typedef {import(&quot;./Template&quot;).RenderManifestEntry} RenderManifestEntry */
/** @typedef {import(&quot;./Template&quot;).RenderManifestOptions} RenderManifestOptions */
/** @typedef {import(&quot;./stats/DefaultStatsFactoryPlugin&quot;).StatsAsset} StatsAsset */
/** @typedef {import(&quot;./stats/DefaultStatsFactoryPlugin&quot;).StatsError} StatsError */
/** @typedef {import(&quot;./stats/DefaultStatsFactoryPlugin&quot;).StatsModule} StatsModule */
/** @typedef {import(&quot;./TemplatedPathPlugin&quot;).TemplatePath} TemplatePath */
/** @typedef {import(&quot;./util/Hash&quot;)} Hash */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).HashFunction} HashFunction */
/**
 * @template T
 * @typedef {import(&quot;./util/deprecation&quot;).FakeHook&lt;T&gt;} FakeHook&lt;T&gt;
 */
/** @typedef {import(&quot;./util/runtime&quot;).RuntimeSpec} RuntimeSpec */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/**
 * @callback Callback
 * @param {(WebpackError | null)=} err
 * @returns {void}
 */

/**
 * @callback ModuleCallback
 * @param {(WebpackError | null)=} err
 * @param {(Module | null)=} result
 * @returns {void}
 */

/**
 * @callback ModuleFactoryResultCallback
 * @param {(WebpackError | null)=} err
 * @param {ModuleFactoryResult=} result
 * @returns {void}
 */

/**
 * @callback ModuleOrFactoryResultCallback
 * @param {(WebpackError | null)=} err
 * @param {Module | ModuleFactoryResult=} result
 * @returns {void}
 */

/**
 * @callback ExecuteModuleCallback
 * @param {WebpackError | null} err
 * @param {ExecuteModuleResult=} result
 * @returns {void}
 */

/** @typedef {new (...args: EXPECTED_ANY[]) =&gt; Dependency} DepConstructor */

/** @typedef {Record&lt;string, Source&gt;} CompilationAssets */

/**
 * @typedef {object} AvailableModulesChunkGroupMapping
 * @property {ChunkGroup} chunkGroup
 * @property {Set&lt;Module&gt;} availableModules
 * @property {boolean} needCopy
 */

/**
 * @typedef {object} DependenciesBlockLike
 * @property {Dependency[]} dependencies
 * @property {AsyncDependenciesBlock[]} blocks
 */

/**
 * @typedef {object} ChunkPathData
 * @property {string | number} id
 * @property {string=} name
 * @property {string} hash
 * @property {((length: number) =&gt; string)=} hashWithLength
 * @property {(Record&lt;string, string&gt;)=} contentHash
 * @property {(Record&lt;string, (length: number) =&gt; string&gt;)=} contentHashWithLength
 */

/**
 * @typedef {object} ChunkHashContext
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 */

/**
 * @typedef {object} RuntimeRequirementsContext
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults the code generation results
 */

/**
 * @typedef {object} ExecuteModuleOptions
 * @property {EntryOptions=} entryOptions
 */

/** @typedef {EXPECTED_ANY} ExecuteModuleExports */

/**
 * @typedef {object} ExecuteModuleResult
 * @property {ExecuteModuleExports} exports
 * @property {boolean} cacheable
 * @property {Map&lt;string, { source: Source, info: AssetInfo | undefined }&gt;} assets
 * @property {LazySet&lt;string&gt;} fileDependencies
 * @property {LazySet&lt;string&gt;} contextDependencies
 * @property {LazySet&lt;string&gt;} missingDependencies
 * @property {LazySet&lt;string&gt;} buildDependencies
 */

/**
 * @typedef {object} ExecuteModuleObject
 * @property {string=} id module id
 * @property {ExecuteModuleExports} exports exports
 * @property {boolean} loaded is loaded
 * @property {Error=} error error
 */

/**
 * @typedef {object} ExecuteModuleArgument
 * @property {Module} module
 * @property {ExecuteModuleObject=} moduleObject
 * @property {TODO} preparedInfo
 * @property {CodeGenerationResult} codeGenerationResult
 */

/** @typedef {((id: string) =&gt; ExecuteModuleExports) &amp; { i?: ((options: ExecuteOptions) =&gt; void)[], c?: Record&lt;string, ExecuteModuleObject&gt; }} WebpackRequire */

/**
 * @typedef {object} ExecuteOptions
 * @property {string=} id module id
 * @property {ExecuteModuleObject} module module
 * @property {WebpackRequire} require require function
 */

/**
 * @typedef {object} ExecuteModuleContext
 * @property {Map&lt;string, { source: Source, info: AssetInfo | undefined }&gt;} assets
 * @property {Chunk} chunk
 * @property {ChunkGraph} chunkGraph
 * @property {WebpackRequire=} __webpack_require__
 */

/**
 * @typedef {object} EntryData
 * @property {Dependency[]} dependencies dependencies of the entrypoint that should be evaluated at startup
 * @property {Dependency[]} includeDependencies dependencies of the entrypoint that should be included but not evaluated
 * @property {EntryOptions} options options of the entrypoint
 */

/**
 * @typedef {object} LogEntry
 * @property {string} type
 * @property {EXPECTED_ANY[]=} args
 * @property {number} time
 * @property {string[]=} trace
 */

/**
 * @typedef {object} KnownAssetInfo
 * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)
 * @property {boolean=} minimized whether the asset is minimized
 * @property {string | string[]=} fullhash the value(s) of the full hash used for this asset
 * @property {string | string[]=} chunkhash the value(s) of the chunk hash used for this asset
 * @property {string | string[]=} modulehash the value(s) of the module hash used for this asset
 * @property {string | string[]=} contenthash the value(s) of the content hash used for this asset
 * @property {string=} sourceFilename when asset was created from a source file (potentially transformed), the original filename relative to compilation context
 * @property {number=} size size in bytes, only set after asset has been emitted
 * @property {boolean=} development true, when asset is only used for development and doesn&#039;t count towards user-facing assets
 * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)
 * @property {boolean=} javascriptModule true, when asset is javascript and an ESM
 * @property {Record&lt;string, string | string[]&gt;=} related object of pointers to other assets, keyed by type of relation (only points from parent to child)
 */

/** @typedef {KnownAssetInfo &amp; Record&lt;string, EXPECTED_ANY&gt;} AssetInfo */

/** @typedef {{ path: string, info: AssetInfo }} InterpolatedPathAndAssetInfo */

/**
 * @typedef {object} Asset
 * @property {string} name the filename of the asset
 * @property {Source} source source of the asset
 * @property {AssetInfo} info info about the asset
 */

/**
 * @typedef {object} ModulePathData
 * @property {string | number} id
 * @property {string} hash
 * @property {((length: number) =&gt; string)=} hashWithLength
 */

/**
 * @typedef {object} PathData
 * @property {ChunkGraph=} chunkGraph
 * @property {string=} hash
 * @property {((length: number) =&gt; string)=} hashWithLength
 * @property {(Chunk | ChunkPathData)=} chunk
 * @property {(Module | ModulePathData)=} module
 * @property {RuntimeSpec=} runtime
 * @property {string=} filename
 * @property {string=} basename
 * @property {string=} query
 * @property {string=} contentHashType
 * @property {string=} contentHash
 * @property {((length: number) =&gt; string)=} contentHashWithLength
 * @property {boolean=} noChunkHash
 * @property {string=} url
 */

/** @typedef {&quot;module&quot; | &quot;chunk&quot; | &quot;root-of-chunk&quot; | &quot;nested&quot;} ExcludeModulesType */

/**
 * @typedef {object} KnownNormalizedStatsOptions
 * @property {string} context
 * @property {RequestShortener} requestShortener
 * @property {string | false} chunksSort
 * @property {string | false} modulesSort
 * @property {string | false} chunkModulesSort
 * @property {string | false} nestedModulesSort
 * @property {string | false} assetsSort
 * @property {boolean} ids
 * @property {boolean} cachedAssets
 * @property {boolean} groupAssetsByEmitStatus
 * @property {boolean} groupAssetsByPath
 * @property {boolean} groupAssetsByExtension
 * @property {number} assetsSpace
 * @property {((value: string, asset: StatsAsset) =&gt; boolean)[]} excludeAssets
 * @property {((name: string, module: StatsModule, type: ExcludeModulesType) =&gt; boolean)[]} excludeModules
 * @property {((warning: StatsError, textValue: string) =&gt; boolean)[]} warningsFilter
 * @property {boolean} cachedModules
 * @property {boolean} orphanModules
 * @property {boolean} dependentModules
 * @property {boolean} runtimeModules
 * @property {boolean} groupModulesByCacheStatus
 * @property {boolean} groupModulesByLayer
 * @property {boolean} groupModulesByAttributes
 * @property {boolean} groupModulesByPath
 * @property {boolean} groupModulesByExtension
 * @property {boolean} groupModulesByType
 * @property {boolean | &quot;auto&quot;} entrypoints
 * @property {boolean} chunkGroups
 * @property {boolean} chunkGroupAuxiliary
 * @property {boolean} chunkGroupChildren
 * @property {number} chunkGroupMaxAssets
 * @property {number} modulesSpace
 * @property {number} chunkModulesSpace
 * @property {number} nestedModulesSpace
 * @property {false | &quot;none&quot; | &quot;error&quot; | &quot;warn&quot; | &quot;info&quot; | &quot;log&quot; | &quot;verbose&quot;} logging
 * @property {((value: string) =&gt; boolean)[]} loggingDebug
 * @property {boolean} loggingTrace
 * @property {TODO} _env
 */

/** @typedef {KnownNormalizedStatsOptions &amp; Omit&lt;StatsOptions, keyof KnownNormalizedStatsOptions&gt; &amp; Record&lt;string, EXPECTED_ANY&gt;} NormalizedStatsOptions */

/**
 * @typedef {object} KnownCreateStatsOptionsContext
 * @property {boolean=} forToString
 */

/** @typedef {KnownCreateStatsOptionsContext &amp; Record&lt;string, EXPECTED_ANY&gt;} CreateStatsOptionsContext */

/** @typedef {{ module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}} CodeGenerationJob */

/** @typedef {CodeGenerationJob[]} CodeGenerationJobs */

/** @typedef {{javascript: ModuleTemplate}} ModuleTemplates */

/** @typedef {Set&lt;Module&gt;} NotCodeGeneratedModules */

/** @typedef {Record&lt;string, TODO&gt;} Records */

/** @type {AssetInfo} */
const EMPTY_ASSET_INFO = Object.freeze({});

const esmDependencyCategory = &quot;esm&quot;;

// TODO webpack 6: remove
const deprecatedNormalModuleLoaderHook = util.deprecate(
	/**
	 * @param {Compilation} compilation compilation
	 * @returns {NormalModuleCompilationHooks[&quot;loader&quot;]} hooks
	 */
	compilation =&gt;
		require(&quot;./NormalModule&quot;).getCompilationHooks(compilation).loader,
	&quot;Compilation.hooks.normalModuleLoader was moved to NormalModule.getCompilationHooks(compilation).loader&quot;,
	&quot;DEP_WEBPACK_COMPILATION_NORMAL_MODULE_LOADER_HOOK&quot;
);

// TODO webpack 6: remove
/**
 * @param {ModuleTemplates | undefined} moduleTemplates module templates
 */
const defineRemovedModuleTemplates = moduleTemplates =&gt; {
	Object.defineProperties(moduleTemplates, {
		asset: {
			enumerable: false,
			configurable: false,
			get: () =&gt; {
				throw new WebpackError(
					&quot;Compilation.moduleTemplates.asset has been removed&quot;
				);
			}
		},
		webassembly: {
			enumerable: false,
			configurable: false,
			get: () =&gt; {
				throw new WebpackError(
					&quot;Compilation.moduleTemplates.webassembly has been removed&quot;
				);
			}
		}
	});
	moduleTemplates = undefined;
};

const byId = compareSelect(c =&gt; c.id, compareIds);

const byNameOrHash = concatComparators(
	compareSelect(c =&gt; c.name, compareIds),
	compareSelect(c =&gt; c.fullHash, compareIds)
);

const byMessage = compareSelect(err =&gt; `${err.message}`, compareStringsNumeric);

const byModule = compareSelect(
	err =&gt; (err.module &amp;&amp; err.module.identifier()) || &quot;&quot;,
	compareStringsNumeric
);

const byLocation = compareSelect(err =&gt; err.loc, compareLocations);

const compareErrors = concatComparators(byModule, byLocation, byMessage);

/**
 * @typedef {object} KnownUnsafeCacheData
 * @property {FactoryMeta=} factoryMeta factory meta
 * @property {ResolveOptions=} resolveOptions resolve options
 * @property {ParserOptions=} parserOptions
 * @property {GeneratorOptions=} generatorOptions
 */

/** @typedef {KnownUnsafeCacheData &amp; Record&lt;string, EXPECTED_ANY&gt;} UnsafeCacheData */

/**
 * @typedef {Module &amp; { restoreFromUnsafeCache?: (unsafeCacheData: UnsafeCacheData, moduleFactory: ModuleFactory, compilationParams: CompilationParams) =&gt; void }} ModuleWithRestoreFromUnsafeCache
 */

/** @type {WeakMap&lt;Dependency, ModuleWithRestoreFromUnsafeCache | null&gt;} */
const unsafeCacheDependencies = new WeakMap();

/** @type {WeakMap&lt;ModuleWithRestoreFromUnsafeCache, UnsafeCacheData&gt;} */
const unsafeCacheData = new WeakMap();

/** @typedef {{ id: ModuleId, modules?: Map&lt;Module, string | number | undefined&gt;, blocks?: (string | number | null)[] }} References */
/** @typedef {Map&lt;Module, WeakTupleMap&lt;EXPECTED_ANY[], EXPECTED_ANY&gt;&gt;} ModuleMemCaches */

class Compilation {
	/**
	 * Creates an instance of Compilation.
	 * @param {Compiler} compiler the compiler which created the compilation
	 * @param {CompilationParams} params the compilation parameters
	 */
	constructor(compiler, params) {
		this._backCompat = compiler._backCompat;

		const getNormalModuleLoader = () =&gt; deprecatedNormalModuleLoaderHook(this);
		/** @typedef {{ additionalAssets?: true | TODO }} ProcessAssetsAdditionalOptions */
		/** @type {AsyncSeriesHook&lt;[CompilationAssets], ProcessAssetsAdditionalOptions&gt;} */
		const processAssetsHook = new AsyncSeriesHook([&quot;assets&quot;]);

		let savedAssets = new Set();
		/**
		 * @param {CompilationAssets} assets assets
		 * @returns {CompilationAssets} new assets
		 */
		const popNewAssets = assets =&gt; {
			let newAssets;
			for (const file of Object.keys(assets)) {
				if (savedAssets.has(file)) continue;
				if (newAssets === undefined) {
					newAssets = Object.create(null);
				}
				newAssets[file] = assets[file];
				savedAssets.add(file);
			}
			return newAssets;
		};
		processAssetsHook.intercept({
			name: &quot;Compilation&quot;,
			call: () =&gt; {
				savedAssets = new Set(Object.keys(this.assets));
			},
			register: tap =&gt; {
				const { type, name } = tap;
				const { fn, additionalAssets, ...remainingTap } = tap;
				const additionalAssetsFn =
					additionalAssets === true ? fn : additionalAssets;
				/** @typedef {WeakSet&lt;CompilationAssets&gt;} ProcessedAssets */

				/** @type {ProcessedAssets | undefined} */
				const processedAssets = additionalAssetsFn ? new WeakSet() : undefined;
				switch (type) {
					case &quot;sync&quot;:
						if (additionalAssetsFn) {
							this.hooks.processAdditionalAssets.tap(name, assets =&gt; {
								if (
									/** @type {ProcessedAssets} */
									(processedAssets).has(this.assets)
								)
									additionalAssetsFn(assets);
							});
						}
						return {
							...remainingTap,
							type: &quot;async&quot;,
							/**
							 * @param {CompilationAssets} assets assets
							 * @param {(err?: Error | null, result?: void) =&gt; void} callback callback
							 * @returns {void}
							 */
							fn: (assets, callback) =&gt; {
								try {
									fn(assets);
								} catch (err) {
									return callback(/** @type {Error} */ (err));
								}
								if (processedAssets !== undefined)
									processedAssets.add(this.assets);
								const newAssets = popNewAssets(assets);
								if (newAssets !== undefined) {
									this.hooks.processAdditionalAssets.callAsync(
										newAssets,
										callback
									);
									return;
								}
								callback();
							}
						};
					case &quot;async&quot;:
						if (additionalAssetsFn) {
							this.hooks.processAdditionalAssets.tapAsync(
								name,
								(assets, callback) =&gt; {
									if (
										/** @type {ProcessedAssets} */
										(processedAssets).has(this.assets)
									)
										return additionalAssetsFn(assets, callback);
									callback();
								}
							);
						}
						return {
							...remainingTap,
							/**
							 * @param {CompilationAssets} assets assets
							 * @param {(err?: Error | null, result?: void) =&gt; void} callback callback
							 * @returns {void}
							 */
							fn: (assets, callback) =&gt; {
								fn(
									assets,
									/**
									 * @param {Error} err err
									 * @returns {void}
									 */
									err =&gt; {
										if (err) return callback(err);
										if (processedAssets !== undefined)
											processedAssets.add(this.assets);
										const newAssets = popNewAssets(assets);
										if (newAssets !== undefined) {
											this.hooks.processAdditionalAssets.callAsync(
												newAssets,
												callback
											);
											return;
										}
										callback();
									}
								);
							}
						};
					case &quot;promise&quot;:
						if (additionalAssetsFn) {
							this.hooks.processAdditionalAssets.tapPromise(name, assets =&gt; {
								if (
									/** @type {ProcessedAssets} */
									(processedAssets).has(this.assets)
								)
									return additionalAssetsFn(assets);
								return Promise.resolve();
							});
						}
						return {
							...remainingTap,
							/**
							 * @param {CompilationAssets} assets assets
							 * @returns {Promise&lt;CompilationAssets&gt;} result
							 */
							fn: assets =&gt; {
								const p = fn(assets);
								if (!p || !p.then) return p;
								return p.then(() =&gt; {
									if (processedAssets !== undefined)
										processedAssets.add(this.assets);
									const newAssets = popNewAssets(assets);
									if (newAssets !== undefined) {
										return this.hooks.processAdditionalAssets.promise(
											newAssets
										);
									}
								});
							}
						};
				}
			}
		});

		/** @type {SyncHook&lt;[CompilationAssets]&gt;} */
		const afterProcessAssetsHook = new SyncHook([&quot;assets&quot;]);

		/**
		 * @template T
		 * @param {string} name name of the hook
		 * @param {number} stage new stage
		 * @param {() =&gt; AsArray&lt;T&gt;} getArgs get old hook function args
		 * @param {string=} code deprecation code (not deprecated when unset)
		 * @returns {FakeHook&lt;Pick&lt;AsyncSeriesHook&lt;T&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt; | undefined} fake hook which redirects
		 */
		const createProcessAssetsHook = (name, stage, getArgs, code) =&gt; {
			if (!this._backCompat &amp;&amp; code) return;
			/**
			 * @param {string} reason reason
			 * @returns {string} error message
			 */
			const errorMessage =
				reason =&gt; `Can&#039;t automatically convert plugin using Compilation.hooks.${name} to Compilation.hooks.processAssets because ${reason}.
BREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`;
			/**
			 * @param {string | (import(&quot;tapable&quot;).TapOptions &amp; { name: string; } &amp; ProcessAssetsAdditionalOptions)} options hook options
			 * @returns {import(&quot;tapable&quot;).TapOptions &amp; { name: string; } &amp; ProcessAssetsAdditionalOptions} modified options
			 */
			const getOptions = options =&gt; {
				if (typeof options === &quot;string&quot;) options = { name: options };
				if (options.stage) {
					throw new Error(errorMessage(&quot;it&#039;s using the &#039;stage&#039; option&quot;));
				}
				return { ...options, stage };
			};
			return createFakeHook(
				{
					name,
					/** @type {AsyncSeriesHook&lt;T&gt;[&quot;intercept&quot;]} */
					intercept(interceptor) {
						throw new Error(errorMessage(&quot;it&#039;s using &#039;intercept&#039;&quot;));
					},
					/** @type {AsyncSeriesHook&lt;T&gt;[&quot;tap&quot;]} */
					tap: (options, fn) =&gt; {
						processAssetsHook.tap(getOptions(options), () =&gt; fn(...getArgs()));
					},
					/** @type {AsyncSeriesHook&lt;T&gt;[&quot;tapAsync&quot;]} */
					tapAsync: (options, fn) =&gt; {
						processAssetsHook.tapAsync(
							getOptions(options),
							(assets, callback) =&gt;
								/** @type {TODO} */ (fn)(...getArgs(), callback)
						);
					},
					/** @type {AsyncSeriesHook&lt;T&gt;[&quot;tapPromise&quot;]} */
					tapPromise: (options, fn) =&gt; {
						processAssetsHook.tapPromise(getOptions(options), () =&gt;
							fn(...getArgs())
						);
					}
				},
				`${name} is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS_ASSETS_STAGE_* as stage option)`,
				code
			);
		};
		this.hooks = Object.freeze({
			/** @type {SyncHook&lt;[Module]&gt;} */
			buildModule: new SyncHook([&quot;module&quot;]),
			/** @type {SyncHook&lt;[Module]&gt;} */
			rebuildModule: new SyncHook([&quot;module&quot;]),
			/** @type {SyncHook&lt;[Module, WebpackError]&gt;} */
			failedModule: new SyncHook([&quot;module&quot;, &quot;error&quot;]),
			/** @type {SyncHook&lt;[Module]&gt;} */
			succeedModule: new SyncHook([&quot;module&quot;]),
			/** @type {SyncHook&lt;[Module]&gt;} */
			stillValidModule: new SyncHook([&quot;module&quot;]),

			/** @type {SyncHook&lt;[Dependency, EntryOptions]&gt;} */
			addEntry: new SyncHook([&quot;entry&quot;, &quot;options&quot;]),
			/** @type {SyncHook&lt;[Dependency, EntryOptions, Error]&gt;} */
			failedEntry: new SyncHook([&quot;entry&quot;, &quot;options&quot;, &quot;error&quot;]),
			/** @type {SyncHook&lt;[Dependency, EntryOptions, Module]&gt;} */
			succeedEntry: new SyncHook([&quot;entry&quot;, &quot;options&quot;, &quot;module&quot;]),

			/** @type {SyncWaterfallHook&lt;[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]&gt;} */
			dependencyReferencedExports: new SyncWaterfallHook([
				&quot;referencedExports&quot;,
				&quot;dependency&quot;,
				&quot;runtime&quot;
			]),

			/** @type {SyncHook&lt;[ExecuteModuleArgument, ExecuteModuleContext]&gt;} */
			executeModule: new SyncHook([&quot;options&quot;, &quot;context&quot;]),
			/** @type {AsyncParallelHook&lt;[ExecuteModuleArgument, ExecuteModuleContext]&gt;} */
			prepareModuleExecution: new AsyncParallelHook([&quot;options&quot;, &quot;context&quot;]),

			/** @type {AsyncSeriesHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			finishModules: new AsyncSeriesHook([&quot;modules&quot;]),
			/** @type {AsyncSeriesHook&lt;[Module]&gt;} */
			finishRebuildingModule: new AsyncSeriesHook([&quot;module&quot;]),
			/** @type {SyncHook&lt;[]&gt;} */
			unseal: new SyncHook([]),
			/** @type {SyncHook&lt;[]&gt;} */
			seal: new SyncHook([]),

			/** @type {SyncHook&lt;[]&gt;} */
			beforeChunks: new SyncHook([]),
			/**
			 * The `afterChunks` hook is called directly after the chunks and module graph have
			 * been created and before the chunks and modules have been optimized. This hook is useful to
			 * inspect, analyze, and/or modify the chunk graph.
			 * @type {SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;}
			 */
			afterChunks: new SyncHook([&quot;chunks&quot;]),

			/** @type {SyncBailHook&lt;[Iterable&lt;Module&gt;], boolean | void&gt;} */
			optimizeDependencies: new SyncBailHook([&quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			afterOptimizeDependencies: new SyncHook([&quot;modules&quot;]),

			/** @type {SyncHook&lt;[]&gt;} */
			optimize: new SyncHook([]),
			/** @type {SyncBailHook&lt;[Iterable&lt;Module&gt;], boolean | void&gt;} */
			optimizeModules: new SyncBailHook([&quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			afterOptimizeModules: new SyncHook([&quot;modules&quot;]),

			/** @type {SyncBailHook&lt;[Iterable&lt;Chunk&gt;, ChunkGroup[]], boolean | void&gt;} */
			optimizeChunks: new SyncBailHook([&quot;chunks&quot;, &quot;chunkGroups&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;, ChunkGroup[]]&gt;} */
			afterOptimizeChunks: new SyncHook([&quot;chunks&quot;, &quot;chunkGroups&quot;]),

			/** @type {AsyncSeriesHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */
			optimizeTree: new AsyncSeriesHook([&quot;chunks&quot;, &quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */
			afterOptimizeTree: new SyncHook([&quot;chunks&quot;, &quot;modules&quot;]),

			/** @type {AsyncSeriesBailHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;], void&gt;} */
			optimizeChunkModules: new AsyncSeriesBailHook([&quot;chunks&quot;, &quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;, Iterable&lt;Module&gt;]&gt;} */
			afterOptimizeChunkModules: new SyncHook([&quot;chunks&quot;, &quot;modules&quot;]),
			/** @type {SyncBailHook&lt;[], boolean | void&gt;} */
			shouldRecord: new SyncBailHook([]),

			/** @type {SyncHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;} */
			additionalChunkRuntimeRequirements: new SyncHook([
				&quot;chunk&quot;,
				&quot;runtimeRequirements&quot;,
				&quot;context&quot;
			]),
			/** @type {HookMap&lt;SyncBailHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext], void&gt;&gt;} */
			runtimeRequirementInChunk: new HookMap(
				() =&gt; new SyncBailHook([&quot;chunk&quot;, &quot;runtimeRequirements&quot;, &quot;context&quot;])
			),
			/** @type {SyncHook&lt;[Module, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;} */
			additionalModuleRuntimeRequirements: new SyncHook([
				&quot;module&quot;,
				&quot;runtimeRequirements&quot;,
				&quot;context&quot;
			]),
			/** @type {HookMap&lt;SyncBailHook&lt;[Module, Set&lt;string&gt;, RuntimeRequirementsContext], void&gt;&gt;} */
			runtimeRequirementInModule: new HookMap(
				() =&gt; new SyncBailHook([&quot;module&quot;, &quot;runtimeRequirements&quot;, &quot;context&quot;])
			),
			/** @type {SyncHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext]&gt;} */
			additionalTreeRuntimeRequirements: new SyncHook([
				&quot;chunk&quot;,
				&quot;runtimeRequirements&quot;,
				&quot;context&quot;
			]),
			/** @type {HookMap&lt;SyncBailHook&lt;[Chunk, Set&lt;string&gt;, RuntimeRequirementsContext], void&gt;&gt;} */
			runtimeRequirementInTree: new HookMap(
				() =&gt; new SyncBailHook([&quot;chunk&quot;, &quot;runtimeRequirements&quot;, &quot;context&quot;])
			),

			/** @type {SyncHook&lt;[RuntimeModule, Chunk]&gt;} */
			runtimeModule: new SyncHook([&quot;module&quot;, &quot;chunk&quot;]),

			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;, Records]&gt;} */
			reviveModules: new SyncHook([&quot;modules&quot;, &quot;records&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			beforeModuleIds: new SyncHook([&quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			moduleIds: new SyncHook([&quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			optimizeModuleIds: new SyncHook([&quot;modules&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			afterOptimizeModuleIds: new SyncHook([&quot;modules&quot;]),

			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;, Records]&gt;} */
			reviveChunks: new SyncHook([&quot;chunks&quot;, &quot;records&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */
			beforeChunkIds: new SyncHook([&quot;chunks&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */
			chunkIds: new SyncHook([&quot;chunks&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */
			optimizeChunkIds: new SyncHook([&quot;chunks&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;]&gt;} */
			afterOptimizeChunkIds: new SyncHook([&quot;chunks&quot;]),

			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;, Records]&gt;} */
			recordModules: new SyncHook([&quot;modules&quot;, &quot;records&quot;]),
			/** @type {SyncHook&lt;[Iterable&lt;Chunk&gt;, Records]&gt;} */
			recordChunks: new SyncHook([&quot;chunks&quot;, &quot;records&quot;]),

			/** @type {SyncHook&lt;[Iterable&lt;Module&gt;]&gt;} */
			optimizeCodeGeneration: new SyncHook([&quot;modules&quot;]),

			/** @type {SyncHook&lt;[]&gt;} */
			beforeModuleHash: new SyncHook([]),
			/** @type {SyncHook&lt;[]&gt;} */
			afterModuleHash: new SyncHook([]),

			/** @type {SyncHook&lt;[]&gt;} */
			beforeCodeGeneration: new SyncHook([]),
			/** @type {SyncHook&lt;[]&gt;} */
			afterCodeGeneration: new SyncHook([]),

			/** @type {SyncHook&lt;[]&gt;} */
			beforeRuntimeRequirements: new SyncHook([]),
			/** @type {SyncHook&lt;[]&gt;} */
			afterRuntimeRequirements: new SyncHook([]),

			/** @type {SyncHook&lt;[]&gt;} */
			beforeHash: new SyncHook([]),
			/** @type {SyncHook&lt;[Chunk]&gt;} */
			contentHash: new SyncHook([&quot;chunk&quot;]),
			/** @type {SyncHook&lt;[]&gt;} */
			afterHash: new SyncHook([]),
			/** @type {SyncHook&lt;[Records]&gt;} */
			recordHash: new SyncHook([&quot;records&quot;]),
			/** @type {SyncHook&lt;[Compilation, Records]&gt;} */
			record: new SyncHook([&quot;compilation&quot;, &quot;records&quot;]),

			/** @type {SyncHook&lt;[]&gt;} */
			beforeModuleAssets: new SyncHook([]),
			/** @type {SyncBailHook&lt;[], boolean | void&gt;} */
			shouldGenerateChunkAssets: new SyncBailHook([]),
			/** @type {SyncHook&lt;[]&gt;} */
			beforeChunkAssets: new SyncHook([]),
			// TODO webpack 6 remove
			/** @deprecated */
			additionalChunkAssets:
				/** @type {FakeHook&lt;Pick&lt;AsyncSeriesHook&lt;[Set&lt;Chunk&gt;]&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt;} */
				(
					createProcessAssetsHook(
						&quot;additionalChunkAssets&quot;,
						Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,
						() =&gt; [this.chunks],
						&quot;DEP_WEBPACK_COMPILATION_ADDITIONAL_CHUNK_ASSETS&quot;
					)
				),

			// TODO webpack 6 deprecate
			/** @deprecated */
			additionalAssets:
				/** @type {FakeHook&lt;Pick&lt;AsyncSeriesHook&lt;[]&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt;} */
				(
					createProcessAssetsHook(
						&quot;additionalAssets&quot;,
						Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,
						() =&gt; []
					)
				),
			// TODO webpack 6 remove
			/** @deprecated */
			optimizeChunkAssets:
				/** @type {FakeHook&lt;Pick&lt;AsyncSeriesHook&lt;[Set&lt;Chunk&gt;]&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt;} */
				(
					createProcessAssetsHook(
						&quot;optimizeChunkAssets&quot;,
						Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE,
						() =&gt; [this.chunks],
						&quot;DEP_WEBPACK_COMPILATION_OPTIMIZE_CHUNK_ASSETS&quot;
					)
				),
			// TODO webpack 6 remove
			/** @deprecated */
			afterOptimizeChunkAssets:
				/** @type {FakeHook&lt;Pick&lt;AsyncSeriesHook&lt;[Set&lt;Chunk&gt;]&gt;, &quot;tap&quot; | &quot;tapAsync&quot; | &quot;tapPromise&quot; | &quot;name&quot;&gt;&gt;} */
				(
					createProcessAssetsHook(
						&quot;afterOptimizeChunkAssets&quot;,
						Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE + 1,
						() =&gt; [this.chunks],
						&quot;DEP_WEBPACK_COMPILATION_AFTER_OPTIMIZE_CHUNK_ASSETS&quot;
					)
				),
			// TODO webpack 6 deprecate
			/** @deprecated */
			optimizeAssets: processAssetsHook,
			// TODO webpack 6 deprecate
			/** @deprecated */
			afterOptimizeAssets: afterProcessAssetsHook,

			processAssets: processAssetsHook,
			afterProcessAssets: afterProcessAssetsHook,
			/** @type {AsyncSeriesHook&lt;[CompilationAssets]&gt;} */
			processAdditionalAssets: new AsyncSeriesHook([&quot;assets&quot;]),

			/** @type {SyncBailHook&lt;[], boolean | void&gt;} */
			needAdditionalSeal: new SyncBailHook([]),
			/** @type {AsyncSeriesHook&lt;[]&gt;} */
			afterSeal: new AsyncSeriesHook([]),

			/** @type {SyncWaterfallHook&lt;[RenderManifestEntry[], RenderManifestOptions]&gt;} */
			renderManifest: new SyncWaterfallHook([&quot;result&quot;, &quot;options&quot;]),

			/** @type {SyncHook&lt;[Hash]&gt;} */
			fullHash: new SyncHook([&quot;hash&quot;]),
			/** @type {SyncHook&lt;[Chunk, Hash, ChunkHashContext]&gt;} */
			chunkHash: new SyncHook([&quot;chunk&quot;, &quot;chunkHash&quot;, &quot;ChunkHashContext&quot;]),

			/** @type {SyncHook&lt;[Module, string]&gt;} */
			moduleAsset: new SyncHook([&quot;module&quot;, &quot;filename&quot;]),
			/** @type {SyncHook&lt;[Chunk, string]&gt;} */
			chunkAsset: new SyncHook([&quot;chunk&quot;, &quot;filename&quot;]),

			/** @type {SyncWaterfallHook&lt;[string, PathData, AssetInfo | undefined]&gt;} */
			assetPath: new SyncWaterfallHook([&quot;path&quot;, &quot;options&quot;, &quot;assetInfo&quot;]),

			/** @type {SyncBailHook&lt;[], boolean | void&gt;} */
			needAdditionalPass: new SyncBailHook([]),

			/** @type {SyncHook&lt;[Compiler, string, number]&gt;} */
			childCompiler: new SyncHook([
				&quot;childCompiler&quot;,
				&quot;compilerName&quot;,
				&quot;compilerIndex&quot;
			]),

			/** @type {SyncBailHook&lt;[string, LogEntry], boolean | void&gt;} */
			log: new SyncBailHook([&quot;origin&quot;, &quot;logEntry&quot;]),

			/** @type {SyncWaterfallHook&lt;[Error[]]&gt;} */
			processWarnings: new SyncWaterfallHook([&quot;warnings&quot;]),
			/** @type {SyncWaterfallHook&lt;[Error[]]&gt;} */
			processErrors: new SyncWaterfallHook([&quot;errors&quot;]),

			/** @type {HookMap&lt;SyncHook&lt;[Partial&lt;NormalizedStatsOptions&gt;, CreateStatsOptionsContext]&gt;&gt;} */
			statsPreset: new HookMap(() =&gt; new SyncHook([&quot;options&quot;, &quot;context&quot;])),
			/** @type {SyncHook&lt;[Partial&lt;NormalizedStatsOptions&gt;, CreateStatsOptionsContext]&gt;} */
			statsNormalize: new SyncHook([&quot;options&quot;, &quot;context&quot;]),
			/** @type {SyncHook&lt;[StatsFactory, NormalizedStatsOptions]&gt;} */
			statsFactory: new SyncHook([&quot;statsFactory&quot;, &quot;options&quot;]),
			/** @type {SyncHook&lt;[StatsPrinter, NormalizedStatsOptions]&gt;} */
			statsPrinter: new SyncHook([&quot;statsPrinter&quot;, &quot;options&quot;]),

			get normalModuleLoader() {
				return getNormalModuleLoader();
			}
		});
		/** @type {string=} */
		this.name = undefined;
		/** @type {number | undefined} */
		this.startTime = undefined;
		/** @type {number | undefined} */
		this.endTime = undefined;
		/** @type {Compiler} */
		this.compiler = compiler;
		this.resolverFactory = compiler.resolverFactory;
		/** @type {InputFileSystem} */
		this.inputFileSystem =
			/** @type {InputFileSystem} */
			(compiler.inputFileSystem);
		this.fileSystemInfo = new FileSystemInfo(this.inputFileSystem, {
			unmanagedPaths: compiler.unmanagedPaths,
			managedPaths: compiler.managedPaths,
			immutablePaths: compiler.immutablePaths,
			logger: this.getLogger(&quot;webpack.FileSystemInfo&quot;),
			hashFunction: compiler.options.output.hashFunction
		});
		if (compiler.fileTimestamps) {
			this.fileSystemInfo.addFileTimestamps(compiler.fileTimestamps, true);
		}
		if (compiler.contextTimestamps) {
			this.fileSystemInfo.addContextTimestamps(
				compiler.contextTimestamps,
				true
			);
		}
		/** @type {ValueCacheVersions} */
		this.valueCacheVersions = new Map();
		this.requestShortener = compiler.requestShortener;
		this.compilerPath = compiler.compilerPath;

		this.logger = this.getLogger(&quot;webpack.Compilation&quot;);

		const options = /** @type {WebpackOptions} */ (compiler.options);
		this.options = options;
		this.outputOptions = options &amp;&amp; options.output;
		/** @type {boolean} */
		this.bail = (options &amp;&amp; options.bail) || false;
		/** @type {boolean} */
		this.profile = (options &amp;&amp; options.profile) || false;

		this.params = params;
		this.mainTemplate = new MainTemplate(this.outputOptions, this);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions, this);
		this.runtimeTemplate = new RuntimeTemplate(
			this,
			this.outputOptions,
			this.requestShortener
		);
		/** @type {ModuleTemplates} */
		this.moduleTemplates = {
			javascript: new ModuleTemplate(this.runtimeTemplate, this)
		};
		defineRemovedModuleTemplates(this.moduleTemplates);

		// We need to think how implement types here
		/** @type {ModuleMemCaches | undefined} */
		this.moduleMemCaches = undefined;
		/** @type {ModuleMemCaches | undefined} */
		this.moduleMemCaches2 = undefined;
		this.moduleGraph = new ModuleGraph();
		/** @type {ChunkGraph} */
		this.chunkGraph = /** @type {TODO} */ (undefined);
		/** @type {CodeGenerationResults} */
		this.codeGenerationResults = /** @type {TODO} */ (undefined);

		/** @type {AsyncQueue&lt;Module, Module, Module&gt;} */
		this.processDependenciesQueue = new AsyncQueue({
			name: &quot;processDependencies&quot;,
			parallelism: options.parallelism || 100,
			processor: this._processModuleDependencies.bind(this)
		});
		/** @type {AsyncQueue&lt;Module, string, Module&gt;} */
		this.addModuleQueue = new AsyncQueue({
			name: &quot;addModule&quot;,
			parent: this.processDependenciesQueue,
			getKey: module =&gt; module.identifier(),
			processor: this._addModule.bind(this)
		});
		/** @type {AsyncQueue&lt;FactorizeModuleOptions, string, Module | ModuleFactoryResult&gt;} */
		this.factorizeQueue = new AsyncQueue({
			name: &quot;factorize&quot;,
			parent: this.addModuleQueue,
			processor: this._factorizeModule.bind(this)
		});
		/** @type {AsyncQueue&lt;Module, Module, Module&gt;} */
		this.buildQueue = new AsyncQueue({
			name: &quot;build&quot;,
			parent: this.factorizeQueue,
			processor: this._buildModule.bind(this)
		});
		/** @type {AsyncQueue&lt;Module, Module, Module&gt;} */
		this.rebuildQueue = new AsyncQueue({
			name: &quot;rebuild&quot;,
			parallelism: options.parallelism || 100,
			processor: this._rebuildModule.bind(this)
		});

		/**
		 * Modules in value are building during the build of Module in key.
		 * Means value blocking key from finishing.
		 * Needed to detect build cycles.
		 * @type {WeakMap&lt;Module, Set&lt;Module&gt;&gt;}
		 */
		this.creatingModuleDuringBuild = new WeakMap();

		/** @type {Map&lt;Exclude&lt;ChunkName, null&gt;, EntryData&gt;} */
		this.entries = new Map();
		/** @type {EntryData} */
		this.globalEntry = {
			dependencies: [],
			includeDependencies: [],
			options: {
				name: undefined
			}
		};
		/** @type {Map&lt;string, Entrypoint&gt;} */
		this.entrypoints = new Map();
		/** @type {Entrypoint[]} */
		this.asyncEntrypoints = [];
		/** @type {Set&lt;Chunk&gt;} */
		this.chunks = new Set();
		/** @type {ChunkGroup[]} */
		this.chunkGroups = [];
		/** @type {Map&lt;string, ChunkGroup&gt;} */
		this.namedChunkGroups = new Map();
		/** @type {Map&lt;string, Chunk&gt;} */
		this.namedChunks = new Map();
		/** @type {Set&lt;Module&gt;} */
		this.modules = new Set();
		if (this._backCompat) {
			arrayToSetDeprecation(this.chunks, &quot;Compilation.chunks&quot;);
			arrayToSetDeprecation(this.modules, &quot;Compilation.modules&quot;);
		}
		/**
		 * @private
		 * @type {Map&lt;string, Module&gt;}
		 */
		this._modules = new Map();
		/** @type {Records | null} */
		this.records = null;
		/** @type {string[]} */
		this.additionalChunkAssets = [];
		/** @type {CompilationAssets} */
		this.assets = {};
		/** @type {Map&lt;string, AssetInfo&gt;} */
		this.assetsInfo = new Map();
		/** @type {Map&lt;string, Map&lt;string, Set&lt;string&gt;&gt;&gt;} */
		this._assetsRelatedIn = new Map();
		/** @type {Error[]} */
		this.errors = [];
		/** @type {Error[]} */
		this.warnings = [];
		/** @type {Compilation[]} */
		this.children = [];
		/** @type {Map&lt;string, LogEntry[]&gt;} */
		this.logging = new Map();
		/** @type {Map&lt;DepConstructor, ModuleFactory&gt;} */
		this.dependencyFactories = new Map();
		/** @type {DependencyTemplates} */
		this.dependencyTemplates = new DependencyTemplates(
			this.outputOptions.hashFunction
		);
		/** @type {Record&lt;string, number&gt;} */
		this.childrenCounters = {};
		/** @type {Set&lt;number|string&gt; | null} */
		this.usedChunkIds = null;
		/** @type {Set&lt;number&gt; | null} */
		this.usedModuleIds = null;
		/** @type {boolean} */
		this.needAdditionalPass = false;
		/** @type {Set&lt;ModuleWithRestoreFromUnsafeCache&gt;} */
		this._restoredUnsafeCacheModuleEntries = new Set();
		/** @type {Map&lt;string, ModuleWithRestoreFromUnsafeCache&gt;} */
		this._restoredUnsafeCacheEntries = new Map();
		/** @type {WeakSet&lt;Module&gt;} */
		this.builtModules = new WeakSet();
		/** @type {WeakSet&lt;Module&gt;} */
		this.codeGeneratedModules = new WeakSet();
		/** @type {WeakSet&lt;Module&gt;} */
		this.buildTimeExecutedModules = new WeakSet();
		/** @type {Set&lt;string&gt;} */
		this.emittedAssets = new Set();
		/** @type {Set&lt;string&gt;} */
		this.comparedForEmitAssets = new Set();
		/** @type {LazySet&lt;string&gt;} */
		this.fileDependencies = new LazySet();
		/** @type {LazySet&lt;string&gt;} */
		this.contextDependencies = new LazySet();
		/** @type {LazySet&lt;string&gt;} */
		this.missingDependencies = new LazySet();
		/** @type {LazySet&lt;string&gt;} */
		this.buildDependencies = new LazySet();
		// TODO webpack 6 remove
		this.compilationDependencies = {
			add: util.deprecate(
				/**
				 * @param {string} item item
				 * @returns {LazySet&lt;string&gt;} file dependencies
				 */
				item =&gt; this.fileDependencies.add(item),
				&quot;Compilation.compilationDependencies is deprecated (used Compilation.fileDependencies instead)&quot;,
				&quot;DEP_WEBPACK_COMPILATION_COMPILATION_DEPENDENCIES&quot;
			)
		};

		this._modulesCache = this.getCache(&quot;Compilation/modules&quot;);
		this._assetsCache = this.getCache(&quot;Compilation/assets&quot;);
		this._codeGenerationCache = this.getCache(&quot;Compilation/codeGeneration&quot;);

		const unsafeCache = options.module.unsafeCache;
		this._unsafeCache = Boolean(unsafeCache);
		this._unsafeCachePredicate =
			typeof unsafeCache === &quot;function&quot; ? unsafeCache : () =&gt; true;
	}

	getStats() {
		return new Stats(this);
	}

	/**
	 * @param {string | boolean | StatsOptions | undefined} optionsOrPreset stats option value
	 * @param {CreateStatsOptionsContext=} context context
	 * @returns {NormalizedStatsOptions} normalized options
	 */
	createStatsOptions(optionsOrPreset, context = {}) {
		if (typeof optionsOrPreset === &quot;boolean&quot;) {
			optionsOrPreset = {
				preset: optionsOrPreset === false ? &quot;none&quot; : &quot;normal&quot;
			};
		} else if (typeof optionsOrPreset === &quot;string&quot;) {
			optionsOrPreset = { preset: optionsOrPreset };
		}
		if (typeof optionsOrPreset === &quot;object&quot; &amp;&amp; optionsOrPreset !== null) {
			// We use this method of shallow cloning this object to include
			// properties in the prototype chain
			/** @type {Partial&lt;NormalizedStatsOptions&gt;} */
			const options = {};
			// eslint-disable-next-line guard-for-in
			for (const key in optionsOrPreset) {
				options[key] = optionsOrPreset[/** @type {keyof StatsOptions} */ (key)];
			}
			if (options.preset !== undefined) {
				this.hooks.statsPreset.for(options.preset).call(options, context);
			}
			this.hooks.statsNormalize.call(options, context);
			return /** @type {NormalizedStatsOptions} */ (options);
		}
		/** @type {Partial&lt;NormalizedStatsOptions&gt;} */
		const options = {};
		this.hooks.statsNormalize.call(options, context);
		return /** @type {NormalizedStatsOptions} */ (options);
	}

	/**
	 * @param {NormalizedStatsOptions} options options
	 * @returns {StatsFactory} the stats factory
	 */
	createStatsFactory(options) {
		const statsFactory = new StatsFactory();
		this.hooks.statsFactory.call(statsFactory, options);
		return statsFactory;
	}

	/**
	 * @param {NormalizedStatsOptions} options options
	 * @returns {StatsPrinter} the stats printer
	 */
	createStatsPrinter(options) {
		const statsPrinter = new StatsPrinter();
		this.hooks.statsPrinter.call(statsPrinter, options);
		return statsPrinter;
	}

	/**
	 * @param {string} name cache name
	 * @returns {CacheFacade} the cache facade instance
	 */
	getCache(name) {
		return this.compiler.getCache(name);
	}

	/**
	 * @param {string | (() =&gt; string)} name name of the logger, or function called once to get the logger name
	 * @returns {Logger} a logger with that name
	 */
	getLogger(name) {
		if (!name) {
			throw new TypeError(&quot;Compilation.getLogger(name) called without a name&quot;);
		}
		/** @type {LogEntry[] | undefined} */
		let logEntries;
		return new Logger(
			(type, args) =&gt; {
				if (typeof name === &quot;function&quot;) {
					name = name();
					if (!name) {
						throw new TypeError(
							&quot;Compilation.getLogger(name) called with a function not returning a name&quot;
						);
					}
				}
				let trace;
				switch (type) {
					case LogType.warn:
					case LogType.error:
					case LogType.trace:
						trace = ErrorHelpers.cutOffLoaderExecution(
							/** @type {string} */ (new Error(&quot;Trace&quot;).stack)
						)
							.split(&quot;\n&quot;)
							.slice(3);
						break;
				}
				/** @type {LogEntry} */
				const logEntry = {
					time: Date.now(),
					type,
					args,
					trace
				};
				/* eslint-disable no-console */
				if (this.hooks.log.call(name, logEntry) === undefined) {
					if (
						logEntry.type === LogType.profileEnd &amp;&amp;
						typeof console.profileEnd === &quot;function&quot;
					) {
						console.profileEnd(
							`[${name}] ${/** @type {NonNullable&lt;LogEntry[&quot;args&quot;]&gt;} */ (logEntry.args)[0]}`
						);
					}
					if (logEntries === undefined) {
						logEntries = this.logging.get(name);
						if (logEntries === undefined) {
							logEntries = [];
							this.logging.set(name, logEntries);
						}
					}
					logEntries.push(logEntry);
					if (
						logEntry.type === LogType.profile &amp;&amp;
						typeof console.profile === &quot;function&quot;
					) {
						console.profile(
							`[${name}] ${
								/** @type {NonNullable&lt;LogEntry[&quot;args&quot;]&gt;} */
								(logEntry.args)[0]
							}`
						);
					}
					/* eslint-enable no-console */
				}
			},
			childName =&gt; {
				if (typeof name === &quot;function&quot;) {
					if (typeof childName === &quot;function&quot;) {
						return this.getLogger(() =&gt; {
							if (typeof name === &quot;function&quot;) {
								name = name();
								if (!name) {
									throw new TypeError(
										&quot;Compilation.getLogger(name) called with a function not returning a name&quot;
									);
								}
							}
							if (typeof childName === &quot;function&quot;) {
								childName = childName();
								if (!childName) {
									throw new TypeError(
										&quot;Logger.getChildLogger(name) called with a function not returning a name&quot;
									);
								}
							}
							return `${name}/${childName}`;
						});
					}
					return this.getLogger(() =&gt; {
						if (typeof name === &quot;function&quot;) {
							name = name();
							if (!name) {
								throw new TypeError(
									&quot;Compilation.getLogger(name) called with a function not returning a name&quot;
								);
							}
						}
						return `${name}/${childName}`;
					});
				}
				if (typeof childName === &quot;function&quot;) {
					return this.getLogger(() =&gt; {
						if (typeof childName === &quot;function&quot;) {
							childName = childName();
							if (!childName) {
								throw new TypeError(
									&quot;Logger.getChildLogger(name) called with a function not returning a name&quot;
								);
							}
						}
						return `${name}/${childName}`;
					});
				}
				return this.getLogger(`${name}/${childName}`);
			}
		);
	}

	/**
	 * @param {Module} module module to be added that was created
	 * @param {ModuleCallback} callback returns the module in the compilation,
	 * it could be the passed one (if new), or an already existing in the compilation
	 * @returns {void}
	 */
	addModule(module, callback) {
		this.addModuleQueue.add(module, callback);
	}

	/**
	 * @param {Module} module module to be added that was created
	 * @param {ModuleCallback} callback returns the module in the compilation,
	 * it could be the passed one (if new), or an already existing in the compilation
	 * @returns {void}
	 */
	_addModule(module, callback) {
		const identifier = module.identifier();
		const alreadyAddedModule = this._modules.get(identifier);
		if (alreadyAddedModule) {
			return callback(null, alreadyAddedModule);
		}

		const currentProfile = this.profile
			? this.moduleGraph.getProfile(module)
			: undefined;
		if (currentProfile !== undefined) {
			currentProfile.markRestoringStart();
		}

		this._modulesCache.get(identifier, null, (err, cacheModule) =&gt; {
			if (err) return callback(new ModuleRestoreError(module, err));

			if (currentProfile !== undefined) {
				currentProfile.markRestoringEnd();
				currentProfile.markIntegrationStart();
			}

			if (cacheModule) {
				cacheModule.updateCacheModule(module);

				module = cacheModule;
			}
			this._modules.set(identifier, module);
			this.modules.add(module);
			if (this._backCompat)
				ModuleGraph.setModuleGraphForModule(module, this.moduleGraph);
			if (currentProfile !== undefined) {
				currentProfile.markIntegrationEnd();
			}
			callback(null, module);
		});
	}

	/**
	 * Fetches a module from a compilation by its identifier
	 * @param {Module} module the module provided
	 * @returns {Module} the module requested
	 */
	getModule(module) {
		const identifier = module.identifier();
		return /** @type {Module} */ (this._modules.get(identifier));
	}

	/**
	 * Attempts to search for a module by its identifier
	 * @param {string} identifier identifier (usually path) for module
	 * @returns {Module|undefined} attempt to search for module and return it, else undefined
	 */
	findModule(identifier) {
		return this._modules.get(identifier);
	}

	/**
	 * Schedules a build of the module object
	 * @param {Module} module module to be built
	 * @param {ModuleCallback} callback the callback
	 * @returns {void}
	 */
	buildModule(module, callback) {
		this.buildQueue.add(module, callback);
	}

	/**
	 * Builds the module object
	 * @param {Module} module module to be built
	 * @param {ModuleCallback} callback the callback
	 * @returns {void}
	 */
	_buildModule(module, callback) {
		const currentProfile = this.profile
			? this.moduleGraph.getProfile(module)
			: undefined;
		if (currentProfile !== undefined) {
			currentProfile.markBuildingStart();
		}

		module.needBuild(
			{
				compilation: this,
				fileSystemInfo: this.fileSystemInfo,
				valueCacheVersions: this.valueCacheVersions
			},
			(err, needBuild) =&gt; {
				if (err) return callback(err);

				if (!needBuild) {
					if (currentProfile !== undefined) {
						currentProfile.markBuildingEnd();
					}
					this.hooks.stillValidModule.call(module);
					return callback();
				}

				this.hooks.buildModule.call(module);
				this.builtModules.add(module);
				module.build(
					this.options,
					this,
					this.resolverFactory.get(&quot;normal&quot;, module.resolveOptions),
					/** @type {InputFileSystem} */
					(this.inputFileSystem),
					err =&gt; {
						if (currentProfile !== undefined) {
							currentProfile.markBuildingEnd();
						}
						if (err) {
							this.hooks.failedModule.call(module, err);
							return callback(err);
						}
						if (currentProfile !== undefined) {
							currentProfile.markStoringStart();
						}
						this._modulesCache.store(module.identifier(), null, module, err =&gt; {
							if (currentProfile !== undefined) {
								currentProfile.markStoringEnd();
							}
							if (err) {
								this.hooks.failedModule.call(
									module,
									/** @type {WebpackError} */ (err)
								);
								return callback(new ModuleStoreError(module, err));
							}
							this.hooks.succeedModule.call(module);
							return callback();
						});
					}
				);
			}
		);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @param {ModuleCallback} callback callback to be triggered
	 * @returns {void}
	 */
	processModuleDependencies(module, callback) {
		this.processDependenciesQueue.add(module, callback);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @returns {void}
	 */
	processModuleDependenciesNonRecursive(module) {
		/**
		 * @param {DependenciesBlock} block block
		 */
		const processDependenciesBlock = block =&gt; {
			if (block.dependencies) {
				let i = 0;
				for (const dep of block.dependencies) {
					this.moduleGraph.setParents(dep, block, module, i++);
				}
			}
			if (block.blocks) {
				for (const b of block.blocks) processDependenciesBlock(b);
			}
		};

		processDependenciesBlock(module);
	}

	/**
	 * @param {Module} module to be processed for deps
	 * @param {ModuleCallback} callback callback to be triggered
	 * @returns {void}
	 */
	_processModuleDependencies(module, callback) {
		/** @type {Array&lt;{factory: ModuleFactory, dependencies: Dependency[], context: string|undefined, originModule: Module|null}&gt;} */
		const sortedDependencies = [];

		/** @type {DependenciesBlock} */
		let currentBlock;

		/** @type {Map&lt;ModuleFactory, Map&lt;string, Dependency[]&gt;&gt;} */
		let dependencies;
		/** @type {DepConstructor} */
		let factoryCacheKey;
		/** @type {ModuleFactory} */
		let factoryCacheKey2;
		/** @typedef {Map&lt;string, Dependency[]&gt;} FactoryCacheValue */
		/** @type {FactoryCacheValue | undefined} */
		let factoryCacheValue;
		/** @type {string} */
		let listCacheKey1;
		/** @type {string} */
		let listCacheKey2;
		/** @type {Dependency[]} */
		let listCacheValue;

		let inProgressSorting = 1;
		let inProgressTransitive = 1;

		/**
		 * @param {WebpackError=} err error
		 * @returns {void}
		 */
		const onDependenciesSorted = err =&gt; {
			if (err) return callback(err);

			// early exit without changing parallelism back and forth
			if (sortedDependencies.length === 0 &amp;&amp; inProgressTransitive === 1) {
				return callback();
			}

			// This is nested so we need to allow one additional task
			this.processDependenciesQueue.increaseParallelism();

			for (const item of sortedDependencies) {
				inProgressTransitive++;
				// eslint-disable-next-line no-loop-func
				this.handleModuleCreation(item, err =&gt; {
					// In V8, the Error objects keep a reference to the functions on the stack. These warnings &amp;
					// errors are created inside closures that keep a reference to the Compilation, so errors are
					// leaking the Compilation object.
					if (err &amp;&amp; this.bail) {
						if (inProgressTransitive &lt;= 0) return;
						inProgressTransitive = -1;
						// eslint-disable-next-line no-self-assign
						err.stack = err.stack;
						onTransitiveTasksFinished(err);
						return;
					}
					if (--inProgressTransitive === 0) onTransitiveTasksFinished();
				});
			}
			if (--inProgressTransitive === 0) onTransitiveTasksFinished();
		};

		/**
		 * @param {WebpackError=} err error
		 * @returns {void}
		 */
		const onTransitiveTasksFinished = err =&gt; {
			if (err) return callback(err);
			this.processDependenciesQueue.decreaseParallelism();

			return callback();
		};

		/**
		 * @param {Dependency} dep dependency
		 * @param {number} index index in block
		 * @returns {void}
		 */
		const processDependency = (dep, index) =&gt; {
			this.moduleGraph.setParents(dep, currentBlock, module, index);
			if (this._unsafeCache) {
				try {
					const unsafeCachedModule = unsafeCacheDependencies.get(dep);
					if (unsafeCachedModule === null) return;
					if (unsafeCachedModule !== undefined) {
						if (
							this._restoredUnsafeCacheModuleEntries.has(unsafeCachedModule)
						) {
							this._handleExistingModuleFromUnsafeCache(
								module,
								dep,
								unsafeCachedModule
							);
							return;
						}
						const identifier = unsafeCachedModule.identifier();
						const cachedModule =
							this._restoredUnsafeCacheEntries.get(identifier);
						if (cachedModule !== undefined) {
							// update unsafe cache to new module
							unsafeCacheDependencies.set(dep, cachedModule);
							this._handleExistingModuleFromUnsafeCache(
								module,
								dep,
								cachedModule
							);
							return;
						}
						inProgressSorting++;
						this._modulesCache.get(identifier, null, (err, cachedModule) =&gt; {
							if (err) {
								if (inProgressSorting &lt;= 0) return;
								inProgressSorting = -1;
								onDependenciesSorted(/** @type {WebpackError} */ (err));
								return;
							}
							try {
								if (!this._restoredUnsafeCacheEntries.has(identifier)) {
									const data = unsafeCacheData.get(cachedModule);
									if (data === undefined) {
										processDependencyForResolving(dep);
										if (--inProgressSorting === 0) onDependenciesSorted();
										return;
									}
									if (cachedModule !== unsafeCachedModule) {
										unsafeCacheDependencies.set(dep, cachedModule);
									}
									cachedModule.restoreFromUnsafeCache(
										data,
										this.params.normalModuleFactory,
										this.params
									);
									this._restoredUnsafeCacheEntries.set(
										identifier,
										cachedModule
									);
									this._restoredUnsafeCacheModuleEntries.add(cachedModule);
									if (!this.modules.has(cachedModule)) {
										inProgressTransitive++;
										this._handleNewModuleFromUnsafeCache(
											module,
											dep,
											cachedModule,
											err =&gt; {
												if (err) {
													if (inProgressTransitive &lt;= 0) return;
													inProgressTransitive = -1;
													onTransitiveTasksFinished(err);
												}
												if (--inProgressTransitive === 0)
													return onTransitiveTasksFinished();
											}
										);
										if (--inProgressSorting === 0) onDependenciesSorted();
										return;
									}
								}
								if (unsafeCachedModule !== cachedModule) {
									unsafeCacheDependencies.set(dep, cachedModule);
								}
								this._handleExistingModuleFromUnsafeCache(
									module,
									dep,
									cachedModule
								); // a3
							} catch (err) {
								if (inProgressSorting &lt;= 0) return;
								inProgressSorting = -1;
								onDependenciesSorted(/** @type {WebpackError} */ (err));
								return;
							}
							if (--inProgressSorting === 0) onDependenciesSorted();
						});
						return;
					}
				} catch (err) {
					// eslint-disable-next-line no-console
					console.error(err);
				}
			}
			processDependencyForResolving(dep);
		};

		/**
		 * @param {Dependency} dep dependency
		 * @returns {void}
		 */
		const processDependencyForResolving = dep =&gt; {
			const resourceIdent = dep.getResourceIdentifier();
			if (resourceIdent !== undefined &amp;&amp; resourceIdent !== null) {
				const category = dep.category;
				const constructor = /** @type {DepConstructor} */ (dep.constructor);
				if (factoryCacheKey === constructor) {
					// Fast path 1: same constructor as prev item
					if (listCacheKey1 === category &amp;&amp; listCacheKey2 === resourceIdent) {
						// Super fast path 1: also same resource
						listCacheValue.push(dep);
						return;
					}
				} else {
					const factory = this.dependencyFactories.get(constructor);
					if (factory === undefined) {
						throw new Error(
							`No module factory available for dependency type: ${constructor.name}`
						);
					}
					if (factoryCacheKey2 === factory) {
						// Fast path 2: same factory as prev item
						factoryCacheKey = constructor;
						if (listCacheKey1 === category &amp;&amp; listCacheKey2 === resourceIdent) {
							// Super fast path 2: also same resource
							listCacheValue.push(dep);
							return;
						}
					} else {
						// Slow path
						if (factoryCacheKey2 !== undefined) {
							// Archive last cache entry
							if (dependencies === undefined) dependencies = new Map();
							dependencies.set(
								factoryCacheKey2,
								/** @type {FactoryCacheValue} */ (factoryCacheValue)
							);
							factoryCacheValue = dependencies.get(factory);
							if (factoryCacheValue === undefined) {
								factoryCacheValue = new Map();
							}
						} else {
							factoryCacheValue = new Map();
						}
						factoryCacheKey = constructor;
						factoryCacheKey2 = factory;
					}
				}
				// Here webpack is using heuristic that assumes
				// mostly esm dependencies would be used
				// so we don&#039;t allocate extra string for them
				const cacheKey =
					category === esmDependencyCategory
						? resourceIdent
						: `${category}${resourceIdent}`;
				let list = /** @type {FactoryCacheValue} */ (factoryCacheValue).get(
					cacheKey
				);
				if (list === undefined) {
					/** @type {FactoryCacheValue} */
					(factoryCacheValue).set(cacheKey, (list = []));
					sortedDependencies.push({
						factory: factoryCacheKey2,
						dependencies: list,
						context: dep.getContext(),
						originModule: module
					});
				}
				list.push(dep);
				listCacheKey1 = category;
				listCacheKey2 = resourceIdent;
				listCacheValue = list;
			}
		};

		try {
			/** @type {DependenciesBlock[]} */
			const queue = [module];
			do {
				const block = /** @type {DependenciesBlock} */ (queue.pop());
				if (block.dependencies) {
					currentBlock = block;
					let i = 0;
					for (const dep of block.dependencies) processDependency(dep, i++);
				}
				if (block.blocks) {
					for (const b of block.blocks) queue.push(b);
				}
			} while (queue.length !== 0);
		} catch (err) {
			return callback(/** @type {WebpackError} */ (err));
		}

		if (--inProgressSorting === 0) onDependenciesSorted();
	}

	/**
	 * @private
	 * @param {Module} originModule original module
	 * @param {Dependency} dependency dependency
	 * @param {Module} module cached module
	 * @param {Callback} callback callback
	 */
	_handleNewModuleFromUnsafeCache(originModule, dependency, module, callback) {
		const moduleGraph = this.moduleGraph;

		moduleGraph.setResolvedModule(originModule, dependency, module);

		moduleGraph.setIssuerIfUnset(
			module,
			originModule !== undefined ? originModule : null
		);

		this._modules.set(module.identifier(), module);
		this.modules.add(module);
		if (this._backCompat)
			ModuleGraph.setModuleGraphForModule(module, this.moduleGraph);

		this._handleModuleBuildAndDependencies(
			originModule,
			module,
			true,
			false,
			callback
		);
	}

	/**
	 * @private
	 * @param {Module} originModule original modules
	 * @param {Dependency} dependency dependency
	 * @param {Module} module cached module
	 */
	_handleExistingModuleFromUnsafeCache(originModule, dependency, module) {
		const moduleGraph = this.moduleGraph;

		moduleGraph.setResolvedModule(originModule, dependency, module);
	}

	/**
	 * @typedef {object} HandleModuleCreationOptions
	 * @property {ModuleFactory} factory
	 * @property {Dependency[]} dependencies
	 * @property {Module | null} originModule
	 * @property {Partial&lt;ModuleFactoryCreateDataContextInfo&gt;=} contextInfo
	 * @property {string=} context
	 * @property {boolean=} recursive recurse into dependencies of the created module
	 * @property {boolean=} connectOrigin connect the resolved module with the origin module
	 * @property {boolean=} checkCycle check the cycle dependencies of the created module
	 */

	/**
	 * @param {HandleModuleCreationOptions} options options object
	 * @param {ModuleCallback} callback callback
	 * @returns {void}
	 */
	handleModuleCreation(
		{
			factory,
			dependencies,
			originModule,
			contextInfo,
			context,
			recursive = true,
			connectOrigin = recursive,
			checkCycle = !recursive
		},
		callback
	) {
		const moduleGraph = this.moduleGraph;

		const currentProfile = this.profile ? new ModuleProfile() : undefined;

		this.factorizeModule(
			{
				currentProfile,
				factory,
				dependencies,
				factoryResult: true,
				originModule,
				contextInfo,
				context
			},
			(err, factoryResult) =&gt; {
				const applyFactoryResultDependencies = () =&gt; {
					const { fileDependencies, contextDependencies, missingDependencies } =
						/** @type {ModuleFactoryResult} */ (factoryResult);
					if (fileDependencies) {
						this.fileDependencies.addAll(fileDependencies);
					}
					if (contextDependencies) {
						this.contextDependencies.addAll(contextDependencies);
					}
					if (missingDependencies) {
						this.missingDependencies.addAll(missingDependencies);
					}
				};
				if (err) {
					if (factoryResult) applyFactoryResultDependencies();
					if (dependencies.every(d =&gt; d.optional)) {
						this.warnings.push(err);
						return callback();
					}
					this.errors.push(err);
					return callback(err);
				}

				const newModule =
					/** @type {ModuleFactoryResult} */
					(factoryResult).module;

				if (!newModule) {
					applyFactoryResultDependencies();
					return callback();
				}

				if (currentProfile !== undefined) {
					moduleGraph.setProfile(newModule, currentProfile);
				}

				this.addModule(newModule, (err, _module) =&gt; {
					if (err) {
						applyFactoryResultDependencies();
						if (!err.module) {
							err.module = _module;
						}
						this.errors.push(err);

						return callback(err);
					}

					const module =
						/** @type {ModuleWithRestoreFromUnsafeCache} */
						(_module);

					if (
						this._unsafeCache &amp;&amp;
						/** @type {ModuleFactoryResult} */
						(factoryResult).cacheable !== false &amp;&amp;
						module.restoreFromUnsafeCache &amp;&amp;
						this._unsafeCachePredicate(module)
					) {
						const unsafeCacheableModule =
							/** @type {ModuleWithRestoreFromUnsafeCache} */
							(module);
						for (let i = 0; i &lt; dependencies.length; i++) {
							const dependency = dependencies[i];
							moduleGraph.setResolvedModule(
								connectOrigin ? originModule : null,
								dependency,
								unsafeCacheableModule
							);
							unsafeCacheDependencies.set(dependency, unsafeCacheableModule);
						}
						if (!unsafeCacheData.has(unsafeCacheableModule)) {
							unsafeCacheData.set(
								unsafeCacheableModule,
								unsafeCacheableModule.getUnsafeCacheData()
							);
						}
					} else {
						applyFactoryResultDependencies();
						for (let i = 0; i &lt; dependencies.length; i++) {
							const dependency = dependencies[i];
							moduleGraph.setResolvedModule(
								connectOrigin ? originModule : null,
								dependency,
								module
							);
						}
					}

					moduleGraph.setIssuerIfUnset(
						module,
						originModule !== undefined ? originModule : null
					);
					if (module !== newModule &amp;&amp; currentProfile !== undefined) {
						const otherProfile = moduleGraph.getProfile(module);
						if (otherProfile !== undefined) {
							currentProfile.mergeInto(otherProfile);
						} else {
							moduleGraph.setProfile(module, currentProfile);
						}
					}

					this._handleModuleBuildAndDependencies(
						originModule,
						module,
						recursive,
						checkCycle,
						callback
					);
				});
			}
		);
	}

	/**
	 * @private
	 * @param {Module | null} originModule original module
	 * @param {Module} module module
	 * @param {boolean} recursive true if make it recursive, otherwise false
	 * @param {boolean} checkCycle true if need to check cycle, otherwise false
	 * @param {ModuleCallback} callback callback
	 * @returns {void}
	 */
	_handleModuleBuildAndDependencies(
		originModule,
		module,
		recursive,
		checkCycle,
		callback
	) {
		// Check for cycles when build is trigger inside another build
		/** @type {Set&lt;Module&gt; | undefined} */
		let creatingModuleDuringBuildSet;
		if (
			checkCycle &amp;&amp;
			this.buildQueue.isProcessing(/** @type {Module} */ (originModule))
		) {
			// Track build dependency
			creatingModuleDuringBuildSet = this.creatingModuleDuringBuild.get(
				/** @type {Module} */
				(originModule)
			);
			if (creatingModuleDuringBuildSet === undefined) {
				creatingModuleDuringBuildSet = new Set();
				this.creatingModuleDuringBuild.set(
					/** @type {Module} */
					(originModule),
					creatingModuleDuringBuildSet
				);
			}
			creatingModuleDuringBuildSet.add(module);

			// When building is blocked by another module
			// search for a cycle, cancel the cycle by throwing
			// an error (otherwise this would deadlock)
			const blockReasons = this.creatingModuleDuringBuild.get(module);
			if (blockReasons !== undefined) {
				const set = new Set(blockReasons);
				for (const item of set) {
					const blockReasons = this.creatingModuleDuringBuild.get(item);
					if (blockReasons !== undefined) {
						for (const m of blockReasons) {
							if (m === module) {
								return callback(new BuildCycleError(module));
							}
							set.add(m);
						}
					}
				}
			}
		}

		this.buildModule(module, err =&gt; {
			if (creatingModuleDuringBuildSet !== undefined) {
				creatingModuleDuringBuildSet.delete(module);
			}
			if (err) {
				if (!err.module) {
					err.module = module;
				}
				this.errors.push(err);

				return callback(err);
			}

			if (!recursive) {
				this.processModuleDependenciesNonRecursive(module);
				callback(null, module);
				return;
			}

			// This avoids deadlocks for circular dependencies
			if (this.processDependenciesQueue.isProcessing(module)) {
				return callback(null, module);
			}

			this.processModuleDependencies(module, err =&gt; {
				if (err) {
					return callback(err);
				}
				callback(null, module);
			});
		});
	}

	/**
	 * @param {FactorizeModuleOptions} options options object
	 * @param {ModuleOrFactoryResultCallback} callback callback
	 * @returns {void}
	 */
	_factorizeModule(
		{
			currentProfile,
			factory,
			dependencies,
			originModule,
			factoryResult,
			contextInfo,
			context
		},
		callback
	) {
		if (currentProfile !== undefined) {
			currentProfile.markFactoryStart();
		}
		factory.create(
			{
				contextInfo: {
					issuer: originModule
						? /** @type {string} */ (originModule.nameForCondition())
						: &quot;&quot;,
					issuerLayer: originModule ? originModule.layer : null,
					compiler: /** @type {string} */ (this.compiler.name),
					...contextInfo
				},
				resolveOptions: originModule ? originModule.resolveOptions : undefined,
				context:
					context ||
					(originModule
						? /** @type {string} */ (originModule.context)
						: /** @type {string} */ (this.compiler.context)),
				dependencies
			},
			(err, result) =&gt; {
				if (result) {
					// TODO webpack 6: remove
					// For backward-compat
					if (result.module === undefined &amp;&amp; result instanceof Module) {
						result = {
							module: result
						};
					}
					if (!factoryResult) {
						const {
							fileDependencies,
							contextDependencies,
							missingDependencies
						} = result;
						if (fileDependencies) {
							this.fileDependencies.addAll(fileDependencies);
						}
						if (contextDependencies) {
							this.contextDependencies.addAll(contextDependencies);
						}
						if (missingDependencies) {
							this.missingDependencies.addAll(missingDependencies);
						}
					}
				}
				if (err) {
					const notFoundError = new ModuleNotFoundError(
						originModule,
						err,
						/** @type {DependencyLocation} */
						(dependencies.map(d =&gt; d.loc).find(Boolean))
					);
					return callback(notFoundError, factoryResult ? result : undefined);
				}
				if (!result) {
					return callback();
				}

				if (currentProfile !== undefined) {
					currentProfile.markFactoryEnd();
				}

				callback(null, factoryResult ? result : result.module);
			}
		);
	}

	/**
	 * @param {string} context context string path
	 * @param {Dependency} dependency dependency used to create Module chain
	 * @param {ModuleCallback} callback callback for when module chain is complete
	 * @returns {void} will throw if dependency instance is not a valid Dependency
	 */
	addModuleChain(context, dependency, callback) {
		return this.addModuleTree({ context, dependency }, callback);
	}

	/**
	 * @param {object} options options
	 * @param {string} options.context context string path
	 * @param {Dependency} options.dependency dependency used to create Module chain
	 * @param {Partial&lt;ModuleFactoryCreateDataContextInfo&gt;=} options.contextInfo additional context info for the root module
	 * @param {ModuleCallback} callback callback for when module chain is complete
	 * @returns {void} will throw if dependency instance is not a valid Dependency
	 */
	addModuleTree({ context, dependency, contextInfo }, callback) {
		if (
			typeof dependency !== &quot;object&quot; ||
			dependency === null ||
			!dependency.constructor
		) {
			return callback(
				new WebpackError(&quot;Parameter &#039;dependency&#039; must be a Dependency&quot;)
			);
		}
		const Dep = /** @type {DepConstructor} */ (dependency.constructor);
		const moduleFactory = this.dependencyFactories.get(Dep);
		if (!moduleFactory) {
			return callback(
				new WebpackError(
					`No dependency factory available for this dependency type: ${dependency.constructor.name}`
				)
			);
		}

		this.handleModuleCreation(
			{
				factory: moduleFactory,
				dependencies: [dependency],
				originModule: null,
				contextInfo,
				context
			},
			(err, result) =&gt; {
				if (err &amp;&amp; this.bail) {
					callback(err);
					this.buildQueue.stop();
					this.rebuildQueue.stop();
					this.processDependenciesQueue.stop();
					this.factorizeQueue.stop();
				} else if (!err &amp;&amp; result) {
					callback(null, result);
				} else {
					callback();
				}
			}
		);
	}

	/**
	 * @param {string} context context path for entry
	 * @param {Dependency} entry entry dependency that should be followed
	 * @param {string | EntryOptions} optionsOrName options or deprecated name of entry
	 * @param {ModuleCallback} callback callback function
	 * @returns {void} returns
	 */
	addEntry(context, entry, optionsOrName, callback) {
		// TODO webpack 6 remove
		const options =
			typeof optionsOrName === &quot;object&quot;
				? optionsOrName
				: { name: optionsOrName };

		this._addEntryItem(context, entry, &quot;dependencies&quot;, options, callback);
	}

	/**
	 * @param {string} context context path for entry
	 * @param {Dependency} dependency dependency that should be followed
	 * @param {EntryOptions} options options
	 * @param {ModuleCallback} callback callback function
	 * @returns {void} returns
	 */
	addInclude(context, dependency, options, callback) {
		this._addEntryItem(
			context,
			dependency,
			&quot;includeDependencies&quot;,
			options,
			callback
		);
	}

	/**
	 * @param {string} context context path for entry
	 * @param {Dependency} entry entry dependency that should be followed
	 * @param {&quot;dependencies&quot; | &quot;includeDependencies&quot;} target type of entry
	 * @param {EntryOptions} options options
	 * @param {ModuleCallback} callback callback function
	 * @returns {void} returns
	 */
	_addEntryItem(context, entry, target, options, callback) {
		const { name } = options;
		let entryData =
			name !== undefined ? this.entries.get(name) : this.globalEntry;
		if (entryData === undefined) {
			entryData = {
				dependencies: [],
				includeDependencies: [],
				options: {
					name: undefined,
					...options
				}
			};
			entryData[target].push(entry);
			this.entries.set(
				/** @type {NonNullable&lt;EntryOptions[&quot;name&quot;]&gt;} */
				(name),
				entryData
			);
		} else {
			entryData[target].push(entry);
			for (const _key of Object.keys(options)) {
				const key = /** @type {keyof EntryOptions} */ (_key);
				if (options[key] === undefined) continue;
				if (entryData.options[key] === options[key]) continue;
				if (
					Array.isArray(entryData.options[key]) &amp;&amp;
					Array.isArray(options[key]) &amp;&amp;
					arrayEquals(entryData.options[key], options[key])
				) {
					continue;
				}
				if (entryData.options[key] === undefined) {
					/** @type {TODO} */
					(entryData.options)[key] =
						/** @type {NonNullable&lt;EntryOptions[keyof EntryOptions]&gt;} */
						(options[key]);
				} else {
					return callback(
						new WebpackError(
							`Conflicting entry option ${key} = ${entryData.options[key]} vs ${options[key]}`
						)
					);
				}
			}
		}

		this.hooks.addEntry.call(entry, options);

		this.addModuleTree(
			{
				context,
				dependency: entry,
				contextInfo: entryData.options.layer
					? { issuerLayer: entryData.options.layer }
					: undefined
			},
			(err, module) =&gt; {
				if (err) {
					this.hooks.failedEntry.call(entry, options, err);
					return callback(err);
				}
				this.hooks.succeedEntry.call(
					entry,
					options,
					/** @type {Module} */
					(module)
				);
				return callback(null, module);
			}
		);
	}

	/**
	 * @param {Module} module module to be rebuilt
	 * @param {ModuleCallback} callback callback when module finishes rebuilding
	 * @returns {void}
	 */
	rebuildModule(module, callback) {
		this.rebuildQueue.add(module, callback);
	}

	/**
	 * @param {Module} module module to be rebuilt
	 * @param {ModuleCallback} callback callback when module finishes rebuilding
	 * @returns {void}
	 */
	_rebuildModule(module, callback) {
		this.hooks.rebuildModule.call(module);
		const oldDependencies = module.dependencies.slice();
		const oldBlocks = module.blocks.slice();
		module.invalidateBuild();
		this.buildQueue.invalidate(module);
		this.buildModule(module, err =&gt; {
			if (err) {
				return this.hooks.finishRebuildingModule.callAsync(module, err2 =&gt; {
					if (err2) {
						callback(
							makeWebpackError(err2, &quot;Compilation.hooks.finishRebuildingModule&quot;)
						);
						return;
					}
					callback(err);
				});
			}

			this.processDependenciesQueue.invalidate(module);
			this.moduleGraph.unfreeze();
			this.processModuleDependencies(module, err =&gt; {
				if (err) return callback(err);
				this.removeReasonsOfDependencyBlock(module, {
					dependencies: oldDependencies,
					blocks: oldBlocks
				});
				this.hooks.finishRebuildingModule.callAsync(module, err2 =&gt; {
					if (err2) {
						callback(
							makeWebpackError(err2, &quot;Compilation.hooks.finishRebuildingModule&quot;)
						);
						return;
					}
					callback(null, module);
				});
			});
		});
	}

	/**
	 * @private
	 * @param {Set&lt;Module&gt;} modules modules
	 */
	_computeAffectedModules(modules) {
		const moduleMemCacheCache = this.compiler.moduleMemCaches;
		if (!moduleMemCacheCache) return;
		if (!this.moduleMemCaches) {
			this.moduleMemCaches = new Map();
			this.moduleGraph.setModuleMemCaches(this.moduleMemCaches);
		}
		const { moduleGraph, moduleMemCaches } = this;
		const affectedModules = new Set();
		const infectedModules = new Set();
		let statNew = 0;
		let statChanged = 0;
		let statUnchanged = 0;
		let statReferencesChanged = 0;
		let statWithoutBuild = 0;

		/**
		 * @param {Module} module module
		 * @returns {WeakReferences | undefined} references
		 */
		const computeReferences = module =&gt; {
			/** @type {WeakReferences | undefined} */
			let references;
			for (const connection of moduleGraph.getOutgoingConnections(module)) {
				const d = connection.dependency;
				const m = connection.module;
				if (!d || !m || unsafeCacheDependencies.has(d)) continue;
				if (references === undefined) references = new WeakMap();
				references.set(d, m);
			}
			return references;
		};

		/**
		 * @param {Module} module the module
		 * @param {WeakReferences | undefined} references references
		 * @returns {boolean} true, when the references differ
		 */
		const compareReferences = (module, references) =&gt; {
			if (references === undefined) return true;
			for (const connection of moduleGraph.getOutgoingConnections(module)) {
				const d = connection.dependency;
				if (!d) continue;
				const entry = references.get(d);
				if (entry === undefined) continue;
				if (entry !== connection.module) return false;
			}
			return true;
		};

		const modulesWithoutCache = new Set(modules);
		for (const [module, cachedMemCache] of moduleMemCacheCache) {
			if (modulesWithoutCache.has(module)) {
				const buildInfo = module.buildInfo;
				if (buildInfo) {
					if (cachedMemCache.buildInfo !== buildInfo) {
						// use a new one
						/** @type {MemCache} */
						const memCache = new WeakTupleMap();
						moduleMemCaches.set(module, memCache);
						affectedModules.add(module);
						cachedMemCache.buildInfo = buildInfo;
						cachedMemCache.references = computeReferences(module);
						cachedMemCache.memCache = memCache;
						statChanged++;
					} else if (!compareReferences(module, cachedMemCache.references)) {
						// use a new one
						/** @type {MemCache} */
						const memCache = new WeakTupleMap();
						moduleMemCaches.set(module, memCache);
						affectedModules.add(module);
						cachedMemCache.references = computeReferences(module);
						cachedMemCache.memCache = memCache;
						statReferencesChanged++;
					} else {
						// keep the old mem cache
						moduleMemCaches.set(module, cachedMemCache.memCache);
						statUnchanged++;
					}
				} else {
					infectedModules.add(module);
					moduleMemCacheCache.delete(module);
					statWithoutBuild++;
				}
				modulesWithoutCache.delete(module);
			} else {
				moduleMemCacheCache.delete(module);
			}
		}

		for (const module of modulesWithoutCache) {
			const buildInfo = module.buildInfo;
			if (buildInfo) {
				// create a new entry
				const memCache = new WeakTupleMap();
				moduleMemCacheCache.set(module, {
					buildInfo,
					references: computeReferences(module),
					memCache
				});
				moduleMemCaches.set(module, memCache);
				affectedModules.add(module);
				statNew++;
			} else {
				infectedModules.add(module);
				statWithoutBuild++;
			}
		}

		/**
		 * @param {readonly ModuleGraphConnection[]} connections connections
		 * @returns {symbol|boolean} result
		 */
		const reduceAffectType = connections =&gt; {
			let affected = false;
			for (const { dependency } of connections) {
				if (!dependency) continue;
				const type = dependency.couldAffectReferencingModule();
				if (type === Dependency.TRANSITIVE) return Dependency.TRANSITIVE;
				if (type === false) continue;
				affected = true;
			}
			return affected;
		};
		const directOnlyInfectedModules = new Set();
		for (const module of infectedModules) {
			for (const [
				referencingModule,
				connections
			] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {
				if (!referencingModule) continue;
				if (infectedModules.has(referencingModule)) continue;
				const type = reduceAffectType(connections);
				if (!type) continue;
				if (type === true) {
					directOnlyInfectedModules.add(referencingModule);
				} else {
					infectedModules.add(referencingModule);
				}
			}
		}
		for (const module of directOnlyInfectedModules) infectedModules.add(module);
		const directOnlyAffectModules = new Set();
		for (const module of affectedModules) {
			for (const [
				referencingModule,
				connections
			] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {
				if (!referencingModule) continue;
				if (infectedModules.has(referencingModule)) continue;
				if (affectedModules.has(referencingModule)) continue;
				const type = reduceAffectType(connections);
				if (!type) continue;
				if (type === true) {
					directOnlyAffectModules.add(referencingModule);
				} else {
					affectedModules.add(referencingModule);
				}
				/** @type {MemCache} */
				const memCache = new WeakTupleMap();
				const cache =
					/** @type {ModuleMemCachesItem} */
					(moduleMemCacheCache.get(referencingModule));
				cache.memCache = memCache;
				moduleMemCaches.set(referencingModule, memCache);
			}
		}
		for (const module of directOnlyAffectModules) affectedModules.add(module);
		this.logger.log(
			`${Math.round(
				(100 * (affectedModules.size + infectedModules.size)) /
					this.modules.size
			)}% (${affectedModules.size} affected + ${
				infectedModules.size
			} infected of ${
				this.modules.size
			}) modules flagged as affected (${statNew} new modules, ${statChanged} changed, ${statReferencesChanged} references changed, ${statUnchanged} unchanged, ${statWithoutBuild} were not built)`
		);
	}

	_computeAffectedModulesWithChunkGraph() {
		const { moduleMemCaches } = this;
		if (!moduleMemCaches) return;
		const moduleMemCaches2 = (this.moduleMemCaches2 = new Map());
		const { moduleGraph, chunkGraph } = this;
		const key = &quot;memCache2&quot;;
		let statUnchanged = 0;
		let statChanged = 0;
		let statNew = 0;
		/**
		 * @param {Module} module module
		 * @returns {References} references
		 */
		const computeReferences = module =&gt; {
			const id = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));
			/** @type {Map&lt;Module, string | number | undefined&gt; | undefined} */
			let modules;
			/** @type {(string | number | null)[] | undefined} */
			let blocks;
			const outgoing = moduleGraph.getOutgoingConnectionsByModule(module);
			if (outgoing !== undefined) {
				for (const m of outgoing.keys()) {
					if (!m) continue;
					if (modules === undefined) modules = new Map();
					modules.set(m, /** @type {ModuleId} */ (chunkGraph.getModuleId(m)));
				}
			}
			if (module.blocks.length &gt; 0) {
				blocks = [];
				const queue = Array.from(module.blocks);
				for (const block of queue) {
					const chunkGroup = chunkGraph.getBlockChunkGroup(block);
					if (chunkGroup) {
						for (const chunk of chunkGroup.chunks) {
							blocks.push(chunk.id);
						}
					} else {
						blocks.push(null);
					}
					// eslint-disable-next-line prefer-spread
					queue.push.apply(queue, block.blocks);
				}
			}
			return { id, modules, blocks };
		};
		/**
		 * @param {Module} module module
		 * @param {object} references references
		 * @param {string | number} references.id id
		 * @param {Map&lt;Module, string | number | undefined&gt;=} references.modules modules
		 * @param {(string | number | null)[]=} references.blocks blocks
		 * @returns {boolean} ok?
		 */
		const compareReferences = (module, { id, modules, blocks }) =&gt; {
			if (id !== chunkGraph.getModuleId(module)) return false;
			if (modules !== undefined) {
				for (const [module, id] of modules) {
					if (chunkGraph.getModuleId(module) !== id) return false;
				}
			}
			if (blocks !== undefined) {
				const queue = Array.from(module.blocks);
				let i = 0;
				for (const block of queue) {
					const chunkGroup = chunkGraph.getBlockChunkGroup(block);
					if (chunkGroup) {
						for (const chunk of chunkGroup.chunks) {
							if (i &gt;= blocks.length || blocks[i++] !== chunk.id) return false;
						}
					} else if (i &gt;= blocks.length || blocks[i++] !== null) {
						return false;
					}
					// eslint-disable-next-line prefer-spread
					queue.push.apply(queue, block.blocks);
				}
				if (i !== blocks.length) return false;
			}
			return true;
		};

		for (const [module, memCache] of moduleMemCaches) {
			/** @type {{ references: References, memCache: MemCache } | undefined} */
			const cache = memCache.get(key);
			if (cache === undefined) {
				/** @type {WeakTupleMap&lt;Module[], RuntimeRequirements | null&gt; | undefined} */
				const memCache2 = new WeakTupleMap();
				memCache.set(key, {
					references: computeReferences(module),
					memCache: memCache2
				});
				moduleMemCaches2.set(module, memCache2);
				statNew++;
			} else if (!compareReferences(module, cache.references)) {
				/** @type {WeakTupleMap&lt;Module[], RuntimeRequirements | null&gt; | undefined} */
				const memCache = new WeakTupleMap();
				cache.references = computeReferences(module);
				cache.memCache = memCache;
				moduleMemCaches2.set(module, memCache);
				statChanged++;
			} else {
				moduleMemCaches2.set(module, cache.memCache);
				statUnchanged++;
			}
		}

		this.logger.log(
			`${Math.round(
				(100 * statChanged) / (statNew + statChanged + statUnchanged)
			)}% modules flagged as affected by chunk graph (${statNew} new modules, ${statChanged} changed, ${statUnchanged} unchanged)`
		);
	}

	/**
	 * @param {Callback} callback callback
	 */
	finish(callback) {
		this.factorizeQueue.clear();
		if (this.profile) {
			this.logger.time(&quot;finish module profiles&quot;);
			const ParallelismFactorCalculator = require(&quot;./util/ParallelismFactorCalculator&quot;);
			const p = new ParallelismFactorCalculator();
			const moduleGraph = this.moduleGraph;
			/** @type {Map&lt;Module, ModuleProfile&gt;} */
			const modulesWithProfiles = new Map();
			for (const module of this.modules) {
				const profile = moduleGraph.getProfile(module);
				if (!profile) continue;
				modulesWithProfiles.set(module, profile);
				p.range(
					profile.buildingStartTime,
					profile.buildingEndTime,
					f =&gt; (profile.buildingParallelismFactor = f)
				);
				p.range(
					profile.factoryStartTime,
					profile.factoryEndTime,
					f =&gt; (profile.factoryParallelismFactor = f)
				);
				p.range(
					profile.integrationStartTime,
					profile.integrationEndTime,
					f =&gt; (profile.integrationParallelismFactor = f)
				);
				p.range(
					profile.storingStartTime,
					profile.storingEndTime,
					f =&gt; (profile.storingParallelismFactor = f)
				);
				p.range(
					profile.restoringStartTime,
					profile.restoringEndTime,
					f =&gt; (profile.restoringParallelismFactor = f)
				);
				if (profile.additionalFactoryTimes) {
					for (const { start, end } of profile.additionalFactoryTimes) {
						const influence = (end - start) / profile.additionalFactories;
						p.range(
							start,
							end,
							f =&gt;
								(profile.additionalFactoriesParallelismFactor += f * influence)
						);
					}
				}
			}
			p.calculate();

			const logger = this.getLogger(&quot;webpack.Compilation.ModuleProfile&quot;);
			// Avoid coverage problems due indirect changes
			/**
			 * @param {number} value value
			 * @param {string} msg message
			 */
			/* istanbul ignore next */
			const logByValue = (value, msg) =&gt; {
				if (value &gt; 1000) {
					logger.error(msg);
				} else if (value &gt; 500) {
					logger.warn(msg);
				} else if (value &gt; 200) {
					logger.info(msg);
				} else if (value &gt; 30) {
					logger.log(msg);
				} else {
					logger.debug(msg);
				}
			};
			/**
			 * @param {string} category a category
			 * @param {(profile: ModuleProfile) =&gt; number} getDuration get duration callback
			 * @param {(profile: ModuleProfile) =&gt; number} getParallelism get parallelism callback
			 */
			const logNormalSummary = (category, getDuration, getParallelism) =&gt; {
				let sum = 0;
				let max = 0;
				for (const [module, profile] of modulesWithProfiles) {
					const p = getParallelism(profile);
					const d = getDuration(profile);
					if (d === 0 || p === 0) continue;
					const t = d / p;
					sum += t;
					if (t &lt;= 10) continue;
					logByValue(
						t,
						` | ${Math.round(t)} ms${
							p &gt;= 1.1 ? ` (parallelism ${Math.round(p * 10) / 10})` : &quot;&quot;
						} ${category} &gt; ${module.readableIdentifier(this.requestShortener)}`
					);
					max = Math.max(max, t);
				}
				if (sum &lt;= 10) return;
				logByValue(
					Math.max(sum / 10, max),
					`${Math.round(sum)} ms ${category}`
				);
			};
			/**
			 * @param {string} category a category
			 * @param {(profile: ModuleProfile) =&gt; number} getDuration get duration callback
			 * @param {(profile: ModuleProfile) =&gt; number} getParallelism get parallelism callback
			 */
			const logByLoadersSummary = (category, getDuration, getParallelism) =&gt; {
				const map = new Map();
				for (const [module, profile] of modulesWithProfiles) {
					const list = getOrInsert(
						map,
						`${module.type}!${module.identifier().replace(/(!|^)[^!]*$/, &quot;&quot;)}`,
						() =&gt; []
					);
					list.push({ module, profile });
				}

				let sum = 0;
				let max = 0;
				for (const [key, modules] of map) {
					let innerSum = 0;
					let innerMax = 0;
					for (const { module, profile } of modules) {
						const p = getParallelism(profile);
						const d = getDuration(profile);
						if (d === 0 || p === 0) continue;
						const t = d / p;
						innerSum += t;
						if (t &lt;= 10) continue;
						logByValue(
							t,
							` |  | ${Math.round(t)} ms${
								p &gt;= 1.1 ? ` (parallelism ${Math.round(p * 10) / 10})` : &quot;&quot;
							} ${category} &gt; ${module.readableIdentifier(
								this.requestShortener
							)}`
						);
						innerMax = Math.max(innerMax, t);
					}
					sum += innerSum;
					if (innerSum &lt;= 10) continue;
					const idx = key.indexOf(&quot;!&quot;);
					const loaders = key.slice(idx + 1);
					const moduleType = key.slice(0, idx);
					const t = Math.max(innerSum / 10, innerMax);
					logByValue(
						t,
						` | ${Math.round(innerSum)} ms ${category} &gt; ${
							loaders
								? `${
										modules.length
									} x ${moduleType} with ${this.requestShortener.shorten(
										loaders
									)}`
								: `${modules.length} x ${moduleType}`
						}`
					);
					max = Math.max(max, t);
				}
				if (sum &lt;= 10) return;
				logByValue(
					Math.max(sum / 10, max),
					`${Math.round(sum)} ms ${category}`
				);
			};
			logNormalSummary(
				&quot;resolve to new modules&quot;,
				p =&gt; p.factory,
				p =&gt; p.factoryParallelismFactor
			);
			logNormalSummary(
				&quot;resolve to existing modules&quot;,
				p =&gt; p.additionalFactories,
				p =&gt; p.additionalFactoriesParallelismFactor
			);
			logNormalSummary(
				&quot;integrate modules&quot;,
				p =&gt; p.restoring,
				p =&gt; p.restoringParallelismFactor
			);
			logByLoadersSummary(
				&quot;build modules&quot;,
				p =&gt; p.building,
				p =&gt; p.buildingParallelismFactor
			);
			logNormalSummary(
				&quot;store modules&quot;,
				p =&gt; p.storing,
				p =&gt; p.storingParallelismFactor
			);
			logNormalSummary(
				&quot;restore modules&quot;,
				p =&gt; p.restoring,
				p =&gt; p.restoringParallelismFactor
			);
			this.logger.timeEnd(&quot;finish module profiles&quot;);
		}
		this.logger.time(&quot;compute affected modules&quot;);
		this._computeAffectedModules(this.modules);
		this.logger.timeEnd(&quot;compute affected modules&quot;);
		this.logger.time(&quot;finish modules&quot;);
		const { modules, moduleMemCaches } = this;
		this.hooks.finishModules.callAsync(modules, err =&gt; {
			this.logger.timeEnd(&quot;finish modules&quot;);
			if (err) return callback(/** @type {WebpackError} */ (err));

			// extract warnings and errors from modules
			this.moduleGraph.freeze(&quot;dependency errors&quot;);
			// TODO keep a cacheToken (= {}) for each module in the graph
			// create a new one per compilation and flag all updated files
			// and parents with it
			this.logger.time(&quot;report dependency errors and warnings&quot;);
			for (const module of modules) {
				// TODO only run for modules with changed cacheToken
				// global WeakMap&lt;CacheToken, WeakSet&lt;Module&gt;&gt; to keep modules without errors/warnings
				const memCache = moduleMemCaches &amp;&amp; moduleMemCaches.get(module);
				if (memCache &amp;&amp; memCache.get(&quot;noWarningsOrErrors&quot;)) continue;
				let hasProblems = this.reportDependencyErrorsAndWarnings(module, [
					module
				]);
				const errors = module.getErrors();
				if (errors !== undefined) {
					for (const error of errors) {
						if (!error.module) {
							error.module = module;
						}
						this.errors.push(error);
						hasProblems = true;
					}
				}
				const warnings = module.getWarnings();
				if (warnings !== undefined) {
					for (const warning of warnings) {
						if (!warning.module) {
							warning.module = module;
						}
						this.warnings.push(warning);
						hasProblems = true;
					}
				}
				if (!hasProblems &amp;&amp; memCache) memCache.set(&quot;noWarningsOrErrors&quot;, true);
			}
			this.moduleGraph.unfreeze();
			this.logger.timeEnd(&quot;report dependency errors and warnings&quot;);

			callback();
		});
	}

	unseal() {
		this.hooks.unseal.call();
		this.chunks.clear();
		this.chunkGroups.length = 0;
		this.namedChunks.clear();
		this.namedChunkGroups.clear();
		this.entrypoints.clear();
		this.additionalChunkAssets.length = 0;
		this.assets = {};
		this.assetsInfo.clear();
		this.moduleGraph.removeAllModuleAttributes();
		this.moduleGraph.unfreeze();
		this.moduleMemCaches2 = undefined;
	}

	/**
	 * @param {Callback} callback signals when the call finishes
	 * @returns {void}
	 */
	seal(callback) {
		/**
		 * @param {WebpackError=} err err
		 * @returns {void}
		 */
		const finalCallback = err =&gt; {
			this.factorizeQueue.clear();
			this.buildQueue.clear();
			this.rebuildQueue.clear();
			this.processDependenciesQueue.clear();
			this.addModuleQueue.clear();
			return callback(err);
		};
		const chunkGraph = new ChunkGraph(
			this.moduleGraph,
			this.outputOptions.hashFunction
		);
		this.chunkGraph = chunkGraph;

		if (this._backCompat) {
			for (const module of this.modules) {
				ChunkGraph.setChunkGraphForModule(module, chunkGraph);
			}
		}

		this.hooks.seal.call();

		this.logger.time(&quot;optimize dependencies&quot;);
		while (this.hooks.optimizeDependencies.call(this.modules)) {
			/* empty */
		}
		this.hooks.afterOptimizeDependencies.call(this.modules);
		this.logger.timeEnd(&quot;optimize dependencies&quot;);

		this.logger.time(&quot;create chunks&quot;);
		this.hooks.beforeChunks.call();
		this.moduleGraph.freeze(&quot;seal&quot;);
		/** @type {Map&lt;Entrypoint, Module[]&gt;} */
		const chunkGraphInit = new Map();
		for (const [name, { dependencies, includeDependencies, options }] of this
			.entries) {
			const chunk = this.addChunk(name);
			if (options.filename) {
				chunk.filenameTemplate = options.filename;
			}
			const entrypoint = new Entrypoint(options);
			if (!options.dependOn &amp;&amp; !options.runtime) {
				entrypoint.setRuntimeChunk(chunk);
			}
			entrypoint.setEntrypointChunk(chunk);
			this.namedChunkGroups.set(name, entrypoint);
			this.entrypoints.set(name, entrypoint);
			this.chunkGroups.push(entrypoint);
			connectChunkGroupAndChunk(entrypoint, chunk);

			const entryModules = new Set();
			for (const dep of [...this.globalEntry.dependencies, ...dependencies]) {
				entrypoint.addOrigin(
					null,
					{ name },
					/** @type {Dependency &amp; { request: string }} */
					(dep).request
				);

				const module = this.moduleGraph.getModule(dep);
				if (module) {
					chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
					entryModules.add(module);
					const modulesList = chunkGraphInit.get(entrypoint);
					if (modulesList === undefined) {
						chunkGraphInit.set(entrypoint, [module]);
					} else {
						modulesList.push(module);
					}
				}
			}

			this.assignDepths(entryModules);

			/**
			 * @param {Dependency[]} deps deps
			 * @returns {Module[]} sorted deps
			 */
			const mapAndSort = deps =&gt;
				/** @type {Module[]} */
				(deps.map(dep =&gt; this.moduleGraph.getModule(dep)).filter(Boolean)).sort(
					compareModulesByIdentifier
				);
			const includedModules = [
				...mapAndSort(this.globalEntry.includeDependencies),
				...mapAndSort(includeDependencies)
			];

			let modulesList = chunkGraphInit.get(entrypoint);
			if (modulesList === undefined) {
				chunkGraphInit.set(entrypoint, (modulesList = []));
			}
			for (const module of includedModules) {
				this.assignDepth(module);
				modulesList.push(module);
			}
		}
		const runtimeChunks = new Set();
		outer: for (const [
			name,
			{
				options: { dependOn, runtime }
			}
		] of this.entries) {
			if (dependOn &amp;&amp; runtime) {
				const err =
					new WebpackError(`Entrypoint &#039;${name}&#039; has &#039;dependOn&#039; and &#039;runtime&#039; specified. This is not valid.
Entrypoints that depend on other entrypoints do not have their own runtime.
They will use the runtime(s) from referenced entrypoints instead.
Remove the &#039;runtime&#039; option from the entrypoint.`);
				const entry = /** @type {Entrypoint} */ (this.entrypoints.get(name));
				err.chunk = entry.getEntrypointChunk();
				this.errors.push(err);
			}
			if (dependOn) {
				const entry = /** @type {Entrypoint} */ (this.entrypoints.get(name));
				const referencedChunks = entry
					.getEntrypointChunk()
					.getAllReferencedChunks();
				const dependOnEntries = [];
				for (const dep of dependOn) {
					const dependency = this.entrypoints.get(dep);
					if (!dependency) {
						throw new Error(
							`Entry ${name} depends on ${dep}, but this entry was not found`
						);
					}
					if (referencedChunks.has(dependency.getEntrypointChunk())) {
						const err = new WebpackError(
							`Entrypoints &#039;${name}&#039; and &#039;${dep}&#039; use &#039;dependOn&#039; to depend on each other in a circular way.`
						);
						const entryChunk = entry.getEntrypointChunk();
						err.chunk = entryChunk;
						this.errors.push(err);
						entry.setRuntimeChunk(entryChunk);
						continue outer;
					}
					dependOnEntries.push(dependency);
				}
				for (const dependency of dependOnEntries) {
					connectChunkGroupParentAndChild(dependency, entry);
				}
			} else if (runtime) {
				const entry = /** @type {Entrypoint} */ (this.entrypoints.get(name));
				let chunk = this.namedChunks.get(runtime);
				if (chunk) {
					if (!runtimeChunks.has(chunk)) {
						const err =
							new WebpackError(`Entrypoint &#039;${name}&#039; has a &#039;runtime&#039; option which points to another entrypoint named &#039;${runtime}&#039;.
It&#039;s not valid to use other entrypoints as runtime chunk.
Did you mean to use &#039;dependOn: ${JSON.stringify(
								runtime
							)}&#039; instead to allow using entrypoint &#039;${name}&#039; within the runtime of entrypoint &#039;${runtime}&#039;? For this &#039;${runtime}&#039; must always be loaded when &#039;${name}&#039; is used.
Or do you want to use the entrypoints &#039;${name}&#039; and &#039;${runtime}&#039; independently on the same page with a shared runtime? In this case give them both the same value for the &#039;runtime&#039; option. It must be a name not already used by an entrypoint.`);
						const entryChunk =
							/** @type {Chunk} */
							(entry.getEntrypointChunk());
						err.chunk = entryChunk;
						this.errors.push(err);
						entry.setRuntimeChunk(entryChunk);
						continue;
					}
				} else {
					chunk = this.addChunk(runtime);
					chunk.preventIntegration = true;
					runtimeChunks.add(chunk);
				}
				entry.unshiftChunk(chunk);
				chunk.addGroup(entry);
				entry.setRuntimeChunk(chunk);
			}
		}
		buildChunkGraph(this, chunkGraphInit);
		this.hooks.afterChunks.call(this.chunks);
		this.logger.timeEnd(&quot;create chunks&quot;);

		this.logger.time(&quot;optimize&quot;);
		this.hooks.optimize.call();

		while (this.hooks.optimizeModules.call(this.modules)) {
			/* empty */
		}
		this.hooks.afterOptimizeModules.call(this.modules);

		while (this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups)) {
			/* empty */
		}
		this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);

		this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err =&gt; {
			if (err) {
				return finalCallback(
					makeWebpackError(err, &quot;Compilation.hooks.optimizeTree&quot;)
				);
			}

			this.hooks.afterOptimizeTree.call(this.chunks, this.modules);

			this.hooks.optimizeChunkModules.callAsync(
				this.chunks,
				this.modules,
				err =&gt; {
					if (err) {
						return finalCallback(
							makeWebpackError(err, &quot;Compilation.hooks.optimizeChunkModules&quot;)
						);
					}

					this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);

					const shouldRecord = this.hooks.shouldRecord.call() !== false;

					this.hooks.reviveModules.call(
						this.modules,
						/** @type {Records} */
						(this.records)
					);
					this.hooks.beforeModuleIds.call(this.modules);
					this.hooks.moduleIds.call(this.modules);
					this.hooks.optimizeModuleIds.call(this.modules);
					this.hooks.afterOptimizeModuleIds.call(this.modules);

					this.hooks.reviveChunks.call(
						this.chunks,
						/** @type {Records} */
						(this.records)
					);
					this.hooks.beforeChunkIds.call(this.chunks);
					this.hooks.chunkIds.call(this.chunks);
					this.hooks.optimizeChunkIds.call(this.chunks);
					this.hooks.afterOptimizeChunkIds.call(this.chunks);

					this.assignRuntimeIds();

					this.logger.time(&quot;compute affected modules with chunk graph&quot;);
					this._computeAffectedModulesWithChunkGraph();
					this.logger.timeEnd(&quot;compute affected modules with chunk graph&quot;);

					this.sortItemsWithChunkIds();

					if (shouldRecord) {
						this.hooks.recordModules.call(
							this.modules,
							/** @type {Records} */
							(this.records)
						);
						this.hooks.recordChunks.call(
							this.chunks,
							/** @type {Records} */
							(this.records)
						);
					}

					this.hooks.optimizeCodeGeneration.call(this.modules);
					this.logger.timeEnd(&quot;optimize&quot;);

					this.logger.time(&quot;module hashing&quot;);
					this.hooks.beforeModuleHash.call();
					this.createModuleHashes();
					this.hooks.afterModuleHash.call();
					this.logger.timeEnd(&quot;module hashing&quot;);

					this.logger.time(&quot;code generation&quot;);
					this.hooks.beforeCodeGeneration.call();
					this.codeGeneration(err =&gt; {
						if (err) {
							return finalCallback(err);
						}
						this.hooks.afterCodeGeneration.call();
						this.logger.timeEnd(&quot;code generation&quot;);

						this.logger.time(&quot;runtime requirements&quot;);
						this.hooks.beforeRuntimeRequirements.call();
						this.processRuntimeRequirements();
						this.hooks.afterRuntimeRequirements.call();
						this.logger.timeEnd(&quot;runtime requirements&quot;);

						this.logger.time(&quot;hashing&quot;);
						this.hooks.beforeHash.call();
						const codeGenerationJobs = this.createHash();
						this.hooks.afterHash.call();
						this.logger.timeEnd(&quot;hashing&quot;);

						this._runCodeGenerationJobs(codeGenerationJobs, err =&gt; {
							if (err) {
								return finalCallback(err);
							}

							if (shouldRecord) {
								this.logger.time(&quot;record hash&quot;);
								this.hooks.recordHash.call(
									/** @type {Records} */
									(this.records)
								);
								this.logger.timeEnd(&quot;record hash&quot;);
							}

							this.logger.time(&quot;module assets&quot;);
							this.clearAssets();

							this.hooks.beforeModuleAssets.call();
							this.createModuleAssets();
							this.logger.timeEnd(&quot;module assets&quot;);

							const cont = () =&gt; {
								this.logger.time(&quot;process assets&quot;);
								this.hooks.processAssets.callAsync(this.assets, err =&gt; {
									if (err) {
										return finalCallback(
											makeWebpackError(err, &quot;Compilation.hooks.processAssets&quot;)
										);
									}
									this.hooks.afterProcessAssets.call(this.assets);
									this.logger.timeEnd(&quot;process assets&quot;);
									this.assets =
										/** @type {CompilationAssets} */
										(
											this._backCompat
												? soonFrozenObjectDeprecation(
														this.assets,
														&quot;Compilation.assets&quot;,
														&quot;DEP_WEBPACK_COMPILATION_ASSETS&quot;,
														`BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.
	Do changes to assets earlier, e. g. in Compilation.hooks.processAssets.
	Make sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.`
													)
												: Object.freeze(this.assets)
										);

									this.summarizeDependencies();
									if (shouldRecord) {
										this.hooks.record.call(
											this,
											/** @type {Records} */
											(this.records)
										);
									}

									if (this.hooks.needAdditionalSeal.call()) {
										this.unseal();
										return this.seal(callback);
									}
									return this.hooks.afterSeal.callAsync(err =&gt; {
										if (err) {
											return finalCallback(
												makeWebpackError(err, &quot;Compilation.hooks.afterSeal&quot;)
											);
										}
										this.fileSystemInfo.logStatistics();
										finalCallback();
									});
								});
							};

							this.logger.time(&quot;create chunk assets&quot;);
							if (this.hooks.shouldGenerateChunkAssets.call() !== false) {
								this.hooks.beforeChunkAssets.call();
								this.createChunkAssets(err =&gt; {
									this.logger.timeEnd(&quot;create chunk assets&quot;);
									if (err) {
										return finalCallback(err);
									}
									cont();
								});
							} else {
								this.logger.timeEnd(&quot;create chunk assets&quot;);
								cont();
							}
						});
					});
				}
			);
		});
	}

	/**
	 * @param {Module} module module to report from
	 * @param {DependenciesBlock[]} blocks blocks to report from
	 * @returns {boolean} true, when it has warnings or errors
	 */
	reportDependencyErrorsAndWarnings(module, blocks) {
		let hasProblems = false;
		for (let indexBlock = 0; indexBlock &lt; blocks.length; indexBlock++) {
			const block = blocks[indexBlock];
			const dependencies = block.dependencies;

			for (let indexDep = 0; indexDep &lt; dependencies.length; indexDep++) {
				const d = dependencies[indexDep];

				const warnings = d.getWarnings(this.moduleGraph);
				if (warnings) {
					for (let indexWar = 0; indexWar &lt; warnings.length; indexWar++) {
						const w = warnings[indexWar];

						const warning = new ModuleDependencyWarning(module, w, d.loc);
						this.warnings.push(warning);
						hasProblems = true;
					}
				}
				const errors = d.getErrors(this.moduleGraph);
				if (errors) {
					for (let indexErr = 0; indexErr &lt; errors.length; indexErr++) {
						const e = errors[indexErr];

						const error = new ModuleDependencyError(module, e, d.loc);
						this.errors.push(error);
						hasProblems = true;
					}
				}
			}

			if (this.reportDependencyErrorsAndWarnings(module, block.blocks))
				hasProblems = true;
		}
		return hasProblems;
	}

	/**
	 * @param {Callback} callback callback
	 */
	codeGeneration(callback) {
		const { chunkGraph } = this;
		this.codeGenerationResults = new CodeGenerationResults(
			this.outputOptions.hashFunction
		);
		/** @type {CodeGenerationJobs} */
		const jobs = [];
		for (const module of this.modules) {
			const runtimes = chunkGraph.getModuleRuntimes(module);
			if (runtimes.size === 1) {
				for (const runtime of runtimes) {
					const hash = chunkGraph.getModuleHash(module, runtime);
					jobs.push({ module, hash, runtime, runtimes: [runtime] });
				}
			} else if (runtimes.size &gt; 1) {
				/** @type {Map&lt;string, { runtimes: RuntimeSpec[] }&gt;} */
				const map = new Map();
				for (const runtime of runtimes) {
					const hash = chunkGraph.getModuleHash(module, runtime);
					const job = map.get(hash);
					if (job === undefined) {
						const newJob = { module, hash, runtime, runtimes: [runtime] };
						jobs.push(newJob);
						map.set(hash, newJob);
					} else {
						job.runtimes.push(runtime);
					}
				}
			}
		}

		this._runCodeGenerationJobs(jobs, callback);
	}

	/**
	 * @private
	 * @param {CodeGenerationJobs} jobs code generation jobs
	 * @param {Callback} callback callback
	 * @returns {void}
	 */
	_runCodeGenerationJobs(jobs, callback) {
		if (jobs.length === 0) {
			return callback();
		}
		let statModulesFromCache = 0;
		let statModulesGenerated = 0;
		const { chunkGraph, moduleGraph, dependencyTemplates, runtimeTemplate } =
			this;
		const results = this.codeGenerationResults;
		/** @type {WebpackError[]} */
		const errors = [];
		/** @type {NotCodeGeneratedModules | undefined} */
		let notCodeGeneratedModules;
		const runIteration = () =&gt; {
			/** @type {CodeGenerationJobs} */
			let delayedJobs = [];
			let delayedModules = new Set();
			asyncLib.eachLimit(
				jobs,
				/** @type {number} */
				(this.options.parallelism),
				(job, callback) =&gt; {
					const { module } = job;
					const { codeGenerationDependencies } = module;
					if (
						codeGenerationDependencies !== undefined &amp;&amp;
						(notCodeGeneratedModules === undefined ||
							codeGenerationDependencies.some(dep =&gt; {
								const referencedModule = /** @type {Module} */ (
									moduleGraph.getModule(dep)
								);
								return /** @type {NotCodeGeneratedModules} */ (
									notCodeGeneratedModules
								).has(referencedModule);
							}))
					) {
						delayedJobs.push(job);
						delayedModules.add(module);
						return callback();
					}
					const { hash, runtime, runtimes } = job;
					this._codeGenerationModule(
						module,
						runtime,
						runtimes,
						hash,
						dependencyTemplates,
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						errors,
						results,
						(err, codeGenerated) =&gt; {
							if (codeGenerated) statModulesGenerated++;
							else statModulesFromCache++;
							callback(err);
						}
					);
				},
				err =&gt; {
					if (err) return callback(err);
					if (delayedJobs.length &gt; 0) {
						if (delayedJobs.length === jobs.length) {
							return callback(
								/** @type {WebpackError} */ (
									new Error(
										`Unable to make progress during code generation because of circular code generation dependency: ${Array.from(
											delayedModules,
											m =&gt; m.identifier()
										).join(&quot;, &quot;)}`
									)
								)
							);
						}
						jobs = delayedJobs;
						delayedJobs = [];
						notCodeGeneratedModules = delayedModules;
						delayedModules = new Set();
						return runIteration();
					}
					if (errors.length &gt; 0) {
						errors.sort(
							compareSelect(err =&gt; err.module, compareModulesByIdentifier)
						);
						for (const error of errors) {
							this.errors.push(error);
						}
					}
					this.logger.log(
						`${Math.round(
							(100 * statModulesGenerated) /
								(statModulesGenerated + statModulesFromCache)
						)}% code generated (${statModulesGenerated} generated, ${statModulesFromCache} from cache)`
					);
					callback();
				}
			);
		};
		runIteration();
	}

	/**
	 * @param {Module} module module
	 * @param {RuntimeSpec} runtime runtime
	 * @param {RuntimeSpec[]} runtimes runtimes
	 * @param {string} hash hash
	 * @param {DependencyTemplates} dependencyTemplates dependencyTemplates
	 * @param {ChunkGraph} chunkGraph chunkGraph
	 * @param {ModuleGraph} moduleGraph moduleGraph
	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
	 * @param {WebpackError[]} errors errors
	 * @param {CodeGenerationResults} results results
	 * @param {(err?: WebpackError | null, result?: boolean) =&gt; void} callback callback
	 */
	_codeGenerationModule(
		module,
		runtime,
		runtimes,
		hash,
		dependencyTemplates,
		chunkGraph,
		moduleGraph,
		runtimeTemplate,
		errors,
		results,
		callback
	) {
		let codeGenerated = false;
		const cache = new MultiItemCache(
			runtimes.map(runtime =&gt;
				this._codeGenerationCache.getItemCache(
					`${module.identifier()}|${getRuntimeKey(runtime)}`,
					`${hash}|${dependencyTemplates.getHash()}`
				)
			)
		);
		cache.get((err, cachedResult) =&gt; {
			if (err) return callback(/** @type {WebpackError} */ (err));
			let result;
			if (!cachedResult) {
				try {
					codeGenerated = true;
					this.codeGeneratedModules.add(module);
					result = module.codeGeneration({
						chunkGraph,
						moduleGraph,
						dependencyTemplates,
						runtimeTemplate,
						runtime,
						codeGenerationResults: results,
						compilation: this
					});
				} catch (err) {
					errors.push(
						new CodeGenerationError(module, /** @type {Error} */ (err))
					);
					result = cachedResult = {
						sources: new Map(),
						runtimeRequirements: null
					};
				}
			} else {
				result = cachedResult;
			}
			for (const runtime of runtimes) {
				results.add(module, runtime, result);
			}
			if (!cachedResult) {
				cache.store(result, err =&gt;
					callback(/** @type {WebpackError} */ (err), codeGenerated)
				);
			} else {
				callback(null, codeGenerated);
			}
		});
	}

	_getChunkGraphEntries() {
		/** @type {Set&lt;Chunk&gt;} */
		const treeEntries = new Set();
		for (const ep of this.entrypoints.values()) {
			const chunk = ep.getRuntimeChunk();
			if (chunk) treeEntries.add(chunk);
		}
		for (const ep of this.asyncEntrypoints) {
			const chunk = ep.getRuntimeChunk();
			if (chunk) treeEntries.add(chunk);
		}
		return treeEntries;
	}

	/**
	 * @param {object} options options
	 * @param {ChunkGraph=} options.chunkGraph the chunk graph
	 * @param {Iterable&lt;Module&gt;=} options.modules modules
	 * @param {Iterable&lt;Chunk&gt;=} options.chunks chunks
	 * @param {CodeGenerationResults=} options.codeGenerationResults codeGenerationResults
	 * @param {Iterable&lt;Chunk&gt;=} options.chunkGraphEntries chunkGraphEntries
	 * @returns {void}
	 */
	processRuntimeRequirements({
		chunkGraph = this.chunkGraph,
		modules = this.modules,
		chunks = this.chunks,
		codeGenerationResults = this.codeGenerationResults,
		chunkGraphEntries = this._getChunkGraphEntries()
	} = {}) {
		const context = { chunkGraph, codeGenerationResults };
		const { moduleMemCaches2 } = this;
		this.logger.time(&quot;runtime requirements.modules&quot;);
		const additionalModuleRuntimeRequirements =
			this.hooks.additionalModuleRuntimeRequirements;
		const runtimeRequirementInModule = this.hooks.runtimeRequirementInModule;
		for (const module of modules) {
			if (chunkGraph.getNumberOfModuleChunks(module) &gt; 0) {
				const memCache = moduleMemCaches2 &amp;&amp; moduleMemCaches2.get(module);
				for (const runtime of chunkGraph.getModuleRuntimes(module)) {
					if (memCache) {
						const cached = memCache.get(
							`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`
						);
						if (cached !== undefined) {
							if (cached !== null) {
								chunkGraph.addModuleRuntimeRequirements(
									module,
									runtime,
									/** @type {RuntimeRequirements} */
									(cached),
									false
								);
							}
							continue;
						}
					}
					let set;
					const runtimeRequirements =
						codeGenerationResults.getRuntimeRequirements(module, runtime);
					if (runtimeRequirements &amp;&amp; runtimeRequirements.size &gt; 0) {
						set = new Set(runtimeRequirements);
					} else if (additionalModuleRuntimeRequirements.isUsed()) {
						set = new Set();
					} else {
						if (memCache) {
							memCache.set(
								`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`,
								null
							);
						}
						continue;
					}
					additionalModuleRuntimeRequirements.call(module, set, context);

					for (const r of set) {
						const hook = runtimeRequirementInModule.get(r);
						if (hook !== undefined) hook.call(module, set, context);
					}
					if (set.size === 0) {
						if (memCache) {
							memCache.set(
								`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`,
								null
							);
						}
					} else if (memCache) {
						memCache.set(
							`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`,
							set
						);
						chunkGraph.addModuleRuntimeRequirements(
							module,
							runtime,
							set,
							false
						);
					} else {
						chunkGraph.addModuleRuntimeRequirements(module, runtime, set);
					}
				}
			}
		}
		this.logger.timeEnd(&quot;runtime requirements.modules&quot;);

		this.logger.time(&quot;runtime requirements.chunks&quot;);
		for (const chunk of chunks) {
			const set = new Set();
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
					module,
					chunk.runtime
				);
				for (const r of runtimeRequirements) set.add(r);
			}
			this.hooks.additionalChunkRuntimeRequirements.call(chunk, set, context);

			for (const r of set) {
				this.hooks.runtimeRequirementInChunk.for(r).call(chunk, set, context);
			}

			chunkGraph.addChunkRuntimeRequirements(chunk, set);
		}
		this.logger.timeEnd(&quot;runtime requirements.chunks&quot;);

		this.logger.time(&quot;runtime requirements.entries&quot;);
		for (const treeEntry of chunkGraphEntries) {
			const set = new Set();
			for (const chunk of treeEntry.getAllReferencedChunks()) {
				const runtimeRequirements =
					chunkGraph.getChunkRuntimeRequirements(chunk);
				for (const r of runtimeRequirements) set.add(r);
			}

			this.hooks.additionalTreeRuntimeRequirements.call(
				treeEntry,
				set,
				context
			);

			for (const r of set) {
				this.hooks.runtimeRequirementInTree
					.for(r)
					.call(treeEntry, set, context);
			}

			chunkGraph.addTreeRuntimeRequirements(treeEntry, set);
		}
		this.logger.timeEnd(&quot;runtime requirements.entries&quot;);
	}

	// TODO webpack 6 make chunkGraph argument non-optional
	/**
	 * @param {Chunk} chunk target chunk
	 * @param {RuntimeModule} module runtime module
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @returns {void}
	 */
	addRuntimeModule(chunk, module, chunkGraph = this.chunkGraph) {
		// Deprecated ModuleGraph association
		if (this._backCompat)
			ModuleGraph.setModuleGraphForModule(module, this.moduleGraph);

		// add it to the list
		this.modules.add(module);
		this._modules.set(module.identifier(), module);

		// connect to the chunk graph
		chunkGraph.connectChunkAndModule(chunk, module);
		chunkGraph.connectChunkAndRuntimeModule(chunk, module);
		if (module.fullHash) {
			chunkGraph.addFullHashModuleToChunk(chunk, module);
		} else if (module.dependentHash) {
			chunkGraph.addDependentHashModuleToChunk(chunk, module);
		}

		// attach runtime module
		module.attach(this, chunk, chunkGraph);

		// Setup internals
		const exportsInfo = this.moduleGraph.getExportsInfo(module);
		exportsInfo.setHasProvideInfo();
		if (typeof chunk.runtime === &quot;string&quot;) {
			exportsInfo.setUsedForSideEffectsOnly(chunk.runtime);
		} else if (chunk.runtime === undefined) {
			exportsInfo.setUsedForSideEffectsOnly(undefined);
		} else {
			for (const runtime of chunk.runtime) {
				exportsInfo.setUsedForSideEffectsOnly(runtime);
			}
		}
		chunkGraph.addModuleRuntimeRequirements(
			module,
			chunk.runtime,
			new Set([RuntimeGlobals.requireScope])
		);

		// runtime modules don&#039;t need ids
		chunkGraph.setModuleId(module, &quot;&quot;);

		// Call hook
		this.hooks.runtimeModule.call(module, chunk);
	}

	/**
	 * If `module` is passed, `loc` and `request` must also be passed.
	 * @param {string | ChunkGroupOptions} groupOptions options for the chunk group
	 * @param {Module=} module the module the references the chunk group
	 * @param {DependencyLocation=} loc the location from with the chunk group is referenced (inside of module)
	 * @param {string=} request the request from which the the chunk group is referenced
	 * @returns {ChunkGroup} the new or existing chunk group
	 */
	addChunkInGroup(groupOptions, module, loc, request) {
		if (typeof groupOptions === &quot;string&quot;) {
			groupOptions = { name: groupOptions };
		}
		const name = groupOptions.name;
		if (name) {
			const chunkGroup = this.namedChunkGroups.get(name);
			if (chunkGroup !== undefined) {
				if (module) {
					chunkGroup.addOrigin(
						module,
						/** @type {DependencyLocation} */
						(loc),
						/** @type {string} */
						(request)
					);
				}
				return chunkGroup;
			}
		}
		const chunkGroup = new ChunkGroup(groupOptions);
		if (module)
			chunkGroup.addOrigin(
				module,
				/** @type {DependencyLocation} */
				(loc),
				/** @type {string} */
				(request)
			);
		const chunk = this.addChunk(name);

		connectChunkGroupAndChunk(chunkGroup, chunk);

		this.chunkGroups.push(chunkGroup);
		if (name) {
			this.namedChunkGroups.set(name, chunkGroup);
		}
		return chunkGroup;
	}

	/**
	 * @param {EntryOptions} options options for the entrypoint
	 * @param {Module} module the module the references the chunk group
	 * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)
	 * @param {string} request the request from which the the chunk group is referenced
	 * @returns {Entrypoint} the new or existing entrypoint
	 */
	addAsyncEntrypoint(options, module, loc, request) {
		const name = options.name;
		if (name) {
			const entrypoint = this.namedChunkGroups.get(name);
			if (entrypoint instanceof Entrypoint) {
				if (entrypoint !== undefined) {
					if (module) {
						entrypoint.addOrigin(module, loc, request);
					}
					return entrypoint;
				}
			} else if (entrypoint) {
				throw new Error(
					`Cannot add an async entrypoint with the name &#039;${name}&#039;, because there is already an chunk group with this name`
				);
			}
		}
		const chunk = this.addChunk(name);
		if (options.filename) {
			chunk.filenameTemplate = options.filename;
		}
		const entrypoint = new Entrypoint(options, false);
		entrypoint.setRuntimeChunk(chunk);
		entrypoint.setEntrypointChunk(chunk);
		if (name) {
			this.namedChunkGroups.set(name, entrypoint);
		}
		this.chunkGroups.push(entrypoint);
		this.asyncEntrypoints.push(entrypoint);
		connectChunkGroupAndChunk(entrypoint, chunk);
		if (module) {
			entrypoint.addOrigin(module, loc, request);
		}
		return entrypoint;
	}

	/**
	 * This method first looks to see if a name is provided for a new chunk,
	 * and first looks to see if any named chunks already exist and reuse that chunk instead.
	 * @param {ChunkName=} name optional chunk name to be provided
	 * @returns {Chunk} create a chunk (invoked during seal event)
	 */
	addChunk(name) {
		if (name) {
			const chunk = this.namedChunks.get(name);
			if (chunk !== undefined) {
				return chunk;
			}
		}
		const chunk = new Chunk(name, this._backCompat);
		this.chunks.add(chunk);
		if (this._backCompat)
			ChunkGraph.setChunkGraphForChunk(chunk, this.chunkGraph);
		if (name) {
			this.namedChunks.set(name, chunk);
		}
		return chunk;
	}

	/**
	 * @deprecated
	 * @param {Module} module module to assign depth
	 * @returns {void}
	 */
	assignDepth(module) {
		const moduleGraph = this.moduleGraph;

		const queue = new Set([module]);
		/** @type {number} */
		let depth;

		moduleGraph.setDepth(module, 0);

		/**
		 * @param {Module} module module for processing
		 * @returns {void}
		 */
		const processModule = module =&gt; {
			if (!moduleGraph.setDepthIfLower(module, depth)) return;
			queue.add(module);
		};

		for (module of queue) {
			queue.delete(module);
			depth = /** @type {number} */ (moduleGraph.getDepth(module)) + 1;

			for (const connection of moduleGraph.getOutgoingConnections(module)) {
				const refModule = connection.module;
				if (refModule) {
					processModule(refModule);
				}
			}
		}
	}

	/**
	 * @param {Set&lt;Module&gt;} modules module to assign depth
	 * @returns {void}
	 */
	assignDepths(modules) {
		const moduleGraph = this.moduleGraph;

		/** @type {Set&lt;Module&gt;} */
		const queue = new Set(modules);
		// Track these in local variables so that queue only has one data type
		let nextDepthAt = queue.size;
		let depth = 0;

		let i = 0;
		for (const module of queue) {
			moduleGraph.setDepth(module, depth);
			// Some of these results come from cache, which speeds this up
			const connections = moduleGraph.getOutgoingConnectionsByModule(module);
			// connections will be undefined if there are no outgoing connections
			if (connections) {
				for (const refModule of connections.keys()) {
					if (refModule) queue.add(refModule);
				}
			}
			i++;
			// Since this is a breadth-first search, all modules added to the queue
			// while at depth N will be depth N+1
			if (i &gt;= nextDepthAt) {
				depth++;
				nextDepthAt = queue.size;
			}
		}
	}

	/**
	 * @param {Dependency} dependency the dependency
	 * @param {RuntimeSpec} runtime the runtime
	 * @returns {(string[] | ReferencedExport)[]} referenced exports
	 */
	getDependencyReferencedExports(dependency, runtime) {
		const referencedExports = dependency.getReferencedExports(
			this.moduleGraph,
			runtime
		);
		return this.hooks.dependencyReferencedExports.call(
			referencedExports,
			dependency,
			runtime
		);
	}

	/**
	 * @param {Module} module module relationship for removal
	 * @param {DependenciesBlockLike} block //TODO: good description
	 * @returns {void}
	 */
	removeReasonsOfDependencyBlock(module, block) {
		if (block.blocks) {
			for (const b of block.blocks) {
				this.removeReasonsOfDependencyBlock(module, b);
			}
		}

		if (block.dependencies) {
			for (const dep of block.dependencies) {
				const originalModule = this.moduleGraph.getModule(dep);
				if (originalModule) {
					this.moduleGraph.removeConnection(dep);

					if (this.chunkGraph) {
						for (const chunk of this.chunkGraph.getModuleChunks(
							originalModule
						)) {
							this.patchChunksAfterReasonRemoval(originalModule, chunk);
						}
					}
				}
			}
		}
	}

	/**
	 * @param {Module} module module to patch tie
	 * @param {Chunk} chunk chunk to patch tie
	 * @returns {void}
	 */
	patchChunksAfterReasonRemoval(module, chunk) {
		if (!module.hasReasons(this.moduleGraph, chunk.runtime)) {
			this.removeReasonsOfDependencyBlock(module, module);
		}
		if (
			!module.hasReasonForChunk(chunk, this.moduleGraph, this.chunkGraph) &amp;&amp;
			this.chunkGraph.isModuleInChunk(module, chunk)
		) {
			this.chunkGraph.disconnectChunkAndModule(chunk, module);
			this.removeChunkFromDependencies(module, chunk);
		}
	}

	/**
	 * @param {DependenciesBlock} block block tie for Chunk
	 * @param {Chunk} chunk chunk to remove from dep
	 * @returns {void}
	 */
	removeChunkFromDependencies(block, chunk) {
		/**
		 * @param {Dependency} d dependency to (maybe) patch up
		 */
		const iteratorDependency = d =&gt; {
			const depModule = this.moduleGraph.getModule(d);
			if (!depModule) {
				return;
			}
			this.patchChunksAfterReasonRemoval(depModule, chunk);
		};

		const blocks = block.blocks;
		for (let indexBlock = 0; indexBlock &lt; blocks.length; indexBlock++) {
			const asyncBlock = blocks[indexBlock];
			const chunkGroup =
				/** @type {ChunkGroup} */
				(this.chunkGraph.getBlockChunkGroup(asyncBlock));
			// Grab all chunks from the first Block&#039;s AsyncDepBlock
			const chunks = chunkGroup.chunks;
			// For each chunk in chunkGroup
			for (let indexChunk = 0; indexChunk &lt; chunks.length; indexChunk++) {
				const iteratedChunk = chunks[indexChunk];
				chunkGroup.removeChunk(iteratedChunk);
				// Recurse
				this.removeChunkFromDependencies(block, iteratedChunk);
			}
		}

		if (block.dependencies) {
			for (const dep of block.dependencies) iteratorDependency(dep);
		}
	}

	assignRuntimeIds() {
		const { chunkGraph } = this;
		/**
		 * @param {Entrypoint} ep an entrypoint
		 */
		const processEntrypoint = ep =&gt; {
			const runtime = /** @type {string} */ (ep.options.runtime || ep.name);
			const chunk = /** @type {Chunk} */ (ep.getRuntimeChunk());
			chunkGraph.setRuntimeId(runtime, /** @type {ChunkId} */ (chunk.id));
		};
		for (const ep of this.entrypoints.values()) {
			processEntrypoint(ep);
		}
		for (const ep of this.asyncEntrypoints) {
			processEntrypoint(ep);
		}
	}

	sortItemsWithChunkIds() {
		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.sortItems();
		}

		this.errors.sort(compareErrors);
		this.warnings.sort(compareErrors);
		this.children.sort(byNameOrHash);
	}

	summarizeDependencies() {
		for (
			let indexChildren = 0;
			indexChildren &lt; this.children.length;
			indexChildren++
		) {
			const child = this.children[indexChildren];

			this.fileDependencies.addAll(child.fileDependencies);
			this.contextDependencies.addAll(child.contextDependencies);
			this.missingDependencies.addAll(child.missingDependencies);
			this.buildDependencies.addAll(child.buildDependencies);
		}

		for (const module of this.modules) {
			module.addCacheDependencies(
				this.fileDependencies,
				this.contextDependencies,
				this.missingDependencies,
				this.buildDependencies
			);
		}
	}

	createModuleHashes() {
		let statModulesHashed = 0;
		let statModulesFromCache = 0;
		const { chunkGraph, runtimeTemplate, moduleMemCaches2 } = this;
		const { hashFunction, hashDigest, hashDigestLength } = this.outputOptions;
		/** @type {WebpackError[]} */
		const errors = [];
		for (const module of this.modules) {
			const memCache = moduleMemCaches2 &amp;&amp; moduleMemCaches2.get(module);
			for (const runtime of chunkGraph.getModuleRuntimes(module)) {
				if (memCache) {
					const digest =
						/** @type {string} */
						(memCache.get(`moduleHash-${getRuntimeKey(runtime)}`));
					if (digest !== undefined) {
						chunkGraph.setModuleHashes(
							module,
							runtime,
							digest,
							digest.slice(0, hashDigestLength)
						);
						statModulesFromCache++;
						continue;
					}
				}
				statModulesHashed++;
				const digest = this._createModuleHash(
					module,
					chunkGraph,
					runtime,
					hashFunction,
					runtimeTemplate,
					hashDigest,
					hashDigestLength,
					errors
				);
				if (memCache) {
					memCache.set(`moduleHash-${getRuntimeKey(runtime)}`, digest);
				}
			}
		}
		if (errors.length &gt; 0) {
			errors.sort(compareSelect(err =&gt; err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}
		this.logger.log(
			`${statModulesHashed} modules hashed, ${statModulesFromCache} from cache (${
				Math.round(
					(100 * (statModulesHashed + statModulesFromCache)) / this.modules.size
				) / 100
			} variants per module in average)`
		);
	}

	/**
	 * @private
	 * @param {Module} module module
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @param {RuntimeSpec} runtime runtime
	 * @param {OutputOptions[&quot;hashFunction&quot;]} hashFunction hash function
	 * @param {RuntimeTemplate} runtimeTemplate runtime template
	 * @param {OutputOptions[&quot;hashDigest&quot;]} hashDigest hash digest
	 * @param {OutputOptions[&quot;hashDigestLength&quot;]} hashDigestLength hash digest length
	 * @param {WebpackError[]} errors errors
	 * @returns {string} module hash digest
	 */
	_createModuleHash(
		module,
		chunkGraph,
		runtime,
		hashFunction,
		runtimeTemplate,
		hashDigest,
		hashDigestLength,
		errors
	) {
		let moduleHashDigest;
		try {
			const moduleHash = createHash(/** @type {HashFunction} */ (hashFunction));
			module.updateHash(moduleHash, {
				chunkGraph,
				runtime,
				runtimeTemplate
			});
			moduleHashDigest = /** @type {string} */ (moduleHash.digest(hashDigest));
		} catch (err) {
			errors.push(new ModuleHashingError(module, /** @type {Error} */ (err)));
			moduleHashDigest = &quot;XXXXXX&quot;;
		}
		chunkGraph.setModuleHashes(
			module,
			runtime,
			moduleHashDigest,
			moduleHashDigest.slice(0, hashDigestLength)
		);
		return moduleHashDigest;
	}

	createHash() {
		this.logger.time(&quot;hashing: initialize hash&quot;);
		const chunkGraph = /** @type {ChunkGraph} */ (this.chunkGraph);
		const runtimeTemplate = this.runtimeTemplate;
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(/** @type {HashFunction} */ (hashFunction));
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.logger.timeEnd(&quot;hashing: initialize hash&quot;);
		if (this.children.length &gt; 0) {
			this.logger.time(&quot;hashing: hash child compilations&quot;);
			for (const child of this.children) {
				hash.update(/** @type {string} */ (child.hash));
			}
			this.logger.timeEnd(&quot;hashing: hash child compilations&quot;);
		}
		if (this.warnings.length &gt; 0) {
			this.logger.time(&quot;hashing: hash warnings&quot;);
			for (const warning of this.warnings) {
				hash.update(`${warning.message}`);
			}
			this.logger.timeEnd(&quot;hashing: hash warnings&quot;);
		}
		if (this.errors.length &gt; 0) {
			this.logger.time(&quot;hashing: hash errors&quot;);
			for (const error of this.errors) {
				hash.update(`${error.message}`);
			}
			this.logger.timeEnd(&quot;hashing: hash errors&quot;);
		}

		this.logger.time(&quot;hashing: sort chunks&quot;);
		/*
		 * all non-runtime chunks need to be hashes first,
		 * since runtime chunk might use their hashes.
		 * runtime chunks need to be hashed in the correct order
		 * since they may depend on each other (for async entrypoints).
		 * So we put all non-runtime chunks first and hash them in any order.
		 * And order runtime chunks according to referenced between each other.
		 * Chunks need to be in deterministic order since we add hashes to full chunk
		 * during these hashing.
		 */
		/** @type {Chunk[]} */
		const unorderedRuntimeChunks = [];
		/** @type {Chunk[]} */
		const otherChunks = [];
		for (const c of this.chunks) {
			if (c.hasRuntime()) {
				unorderedRuntimeChunks.push(c);
			} else {
				otherChunks.push(c);
			}
		}
		unorderedRuntimeChunks.sort(byId);
		otherChunks.sort(byId);

		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
		/** @type {Map&lt;Chunk, RuntimeChunkInfo&gt;} */
		const runtimeChunksMap = new Map();
		for (const chunk of unorderedRuntimeChunks) {
			runtimeChunksMap.set(chunk, {
				chunk,
				referencedBy: [],
				remaining: 0
			});
		}
		let remaining = 0;
		for (const info of runtimeChunksMap.values()) {
			for (const other of new Set(
				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
					e =&gt; e.chunks[e.chunks.length - 1]
				)
			)) {
				const otherInfo =
					/** @type {RuntimeChunkInfo} */
					(runtimeChunksMap.get(other));
				otherInfo.referencedBy.push(info);
				info.remaining++;
				remaining++;
			}
		}
		/** @type {Chunk[]} */
		const runtimeChunks = [];
		for (const info of runtimeChunksMap.values()) {
			if (info.remaining === 0) {
				runtimeChunks.push(info.chunk);
			}
		}
		// If there are any references between chunks
		// make sure to follow these chains
		if (remaining &gt; 0) {
			const readyChunks = [];
			for (const chunk of runtimeChunks) {
				const hasFullHashModules =
					chunkGraph.getNumberOfChunkFullHashModules(chunk) !== 0;
				const info =
					/** @type {RuntimeChunkInfo} */
					(runtimeChunksMap.get(chunk));
				for (const otherInfo of info.referencedBy) {
					if (hasFullHashModules) {
						chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk);
					}
					remaining--;
					if (--otherInfo.remaining === 0) {
						readyChunks.push(otherInfo.chunk);
					}
				}
				if (readyChunks.length &gt; 0) {
					// This ensures deterministic ordering, since referencedBy is non-deterministic
					readyChunks.sort(byId);
					for (const c of readyChunks) runtimeChunks.push(c);
					readyChunks.length = 0;
				}
			}
		}
		// If there are still remaining references we have cycles and want to create a warning
		if (remaining &gt; 0) {
			const circularRuntimeChunkInfo = [];
			for (const info of runtimeChunksMap.values()) {
				if (info.remaining !== 0) {
					circularRuntimeChunkInfo.push(info);
				}
			}
			circularRuntimeChunkInfo.sort(compareSelect(i =&gt; i.chunk, byId));
			const err =
				new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
					circularRuntimeChunkInfo,
					c =&gt; c.chunk.name || c.chunk.id
				).join(&quot;, &quot;)})
This prevents using hashes of each other and should be avoided.`);
			err.chunk = circularRuntimeChunkInfo[0].chunk;
			this.warnings.push(err);
			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
		}
		this.logger.timeEnd(&quot;hashing: sort chunks&quot;);

		const fullHashChunks = new Set();
		/** @type {CodeGenerationJobs} */
		const codeGenerationJobs = [];
		/** @type {Map&lt;string, Map&lt;Module, CodeGenerationJob&gt;&gt;} */
		const codeGenerationJobsMap = new Map();
		/** @type {WebpackError[]} */
		const errors = [];

		/**
		 * @param {Chunk} chunk chunk
		 */
		const processChunk = chunk =&gt; {
			// Last minute module hash generation for modules that depend on chunk hashes
			this.logger.time(&quot;hashing: hash runtime modules&quot;);
			const runtime = chunk.runtime;
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!chunkGraph.hasModuleHashes(module, runtime)) {
					const hash = this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
					let hashMap = codeGenerationJobsMap.get(hash);
					if (hashMap) {
						const moduleJob = hashMap.get(module);
						if (moduleJob) {
							moduleJob.runtimes.push(runtime);
							continue;
						}
					} else {
						hashMap = new Map();
						codeGenerationJobsMap.set(hash, hashMap);
					}
					const job = {
						module,
						hash,
						runtime,
						runtimes: [runtime]
					};
					hashMap.set(module, job);
					codeGenerationJobs.push(job);
				}
			}
			this.logger.timeAggregate(&quot;hashing: hash runtime modules&quot;);
			try {
				this.logger.time(&quot;hashing: hash chunks&quot;);
				const chunkHash = createHash(
					/** @type {HashFunction} */ (hashFunction)
				);
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash, chunkGraph);
				this.hooks.chunkHash.call(chunk, chunkHash, {
					chunkGraph,
					codeGenerationResults: this.codeGenerationResults,
					moduleGraph: this.moduleGraph,
					runtimeTemplate: this.runtimeTemplate
				});
				const chunkHashDigest = /** @type {string} */ (
					chunkHash.digest(hashDigest)
				);
				hash.update(chunkHashDigest);
				chunk.hash = chunkHashDigest;
				chunk.renderedHash = chunk.hash.slice(0, hashDigestLength);
				const fullHashModules =
					chunkGraph.getChunkFullHashModulesIterable(chunk);
				if (fullHashModules) {
					fullHashChunks.add(chunk);
				} else {
					this.hooks.contentHash.call(chunk);
				}
			} catch (err) {
				this.errors.push(
					new ChunkRenderError(chunk, &quot;&quot;, /** @type {Error} */ (err))
				);
			}
			this.logger.timeAggregate(&quot;hashing: hash chunks&quot;);
		};
		for (const chunk of otherChunks) processChunk(chunk);
		for (const chunk of runtimeChunks) processChunk(chunk);
		if (errors.length &gt; 0) {
			errors.sort(compareSelect(err =&gt; err.module, compareModulesByIdentifier));
			for (const error of errors) {
				this.errors.push(error);
			}
		}

		this.logger.timeAggregateEnd(&quot;hashing: hash runtime modules&quot;);
		this.logger.timeAggregateEnd(&quot;hashing: hash chunks&quot;);
		this.logger.time(&quot;hashing: hash digest&quot;);
		this.hooks.fullHash.call(hash);
		this.fullHash = /** @type {string} */ (hash.digest(hashDigest));
		this.hash = this.fullHash.slice(0, hashDigestLength);
		this.logger.timeEnd(&quot;hashing: hash digest&quot;);

		this.logger.time(&quot;hashing: process full hash modules&quot;);
		for (const chunk of fullHashChunks) {
			for (const module of /** @type {Iterable&lt;RuntimeModule&gt;} */ (
				chunkGraph.getChunkFullHashModulesIterable(chunk)
			)) {
				const moduleHash = createHash(
					/** @type {HashFunction} */ (hashFunction)
				);
				module.updateHash(moduleHash, {
					chunkGraph,
					runtime: chunk.runtime,
					runtimeTemplate
				});
				const moduleHashDigest = /** @type {string} */ (
					moduleHash.digest(hashDigest)
				);
				const oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
				chunkGraph.setModuleHashes(
					module,
					chunk.runtime,
					moduleHashDigest,
					moduleHashDigest.slice(0, hashDigestLength)
				);
				/** @type {CodeGenerationJob} */
				(
					/** @type {Map&lt;Module, CodeGenerationJob&gt;} */
					(codeGenerationJobsMap.get(oldHash)).get(module)
				).hash = moduleHashDigest;
			}
			const chunkHash = createHash(/** @type {HashFunction} */ (hashFunction));
			chunkHash.update(chunk.hash);
			chunkHash.update(this.hash);
			const chunkHashDigest =
				/** @type {string} */
				(chunkHash.digest(hashDigest));
			chunk.hash = chunkHashDigest;
			chunk.renderedHash = chunk.hash.slice(0, hashDigestLength);
			this.hooks.contentHash.call(chunk);
		}
		this.logger.timeEnd(&quot;hashing: process full hash modules&quot;);
		return codeGenerationJobs;
	}

	/**
	 * @param {string} file file name
	 * @param {Source} source asset source
	 * @param {AssetInfo} assetInfo extra asset information
	 * @returns {void}
	 */
	emitAsset(file, source, assetInfo = {}) {
		if (this.assets[file]) {
			if (!isSourceEqual(this.assets[file], source)) {
				this.errors.push(
					new WebpackError(
						`Conflict: Multiple assets emit different content to the same filename ${file}${
							assetInfo.sourceFilename
								? `. Original source ${assetInfo.sourceFilename}`
								: &quot;&quot;
						}`
					)
				);
				this.assets[file] = source;
				this._setAssetInfo(file, assetInfo);
				return;
			}
			const oldInfo = this.assetsInfo.get(file);
			const newInfo = { ...oldInfo, ...assetInfo };
			this._setAssetInfo(file, newInfo, oldInfo);
			return;
		}
		this.assets[file] = source;
		this._setAssetInfo(file, assetInfo, undefined);
	}

	/**
	 * @private
	 * @param {string} file file name
	 * @param {AssetInfo=} newInfo new asset information
	 * @param {AssetInfo=} oldInfo old asset information
	 */
	_setAssetInfo(file, newInfo, oldInfo = this.assetsInfo.get(file)) {
		if (newInfo === undefined) {
			this.assetsInfo.delete(file);
		} else {
			this.assetsInfo.set(file, newInfo);
		}
		const oldRelated = oldInfo &amp;&amp; oldInfo.related;
		const newRelated = newInfo &amp;&amp; newInfo.related;
		if (oldRelated) {
			for (const key of Object.keys(oldRelated)) {
				/**
				 * @param {string} name name
				 */
				const remove = name =&gt; {
					const relatedIn = this._assetsRelatedIn.get(name);
					if (relatedIn === undefined) return;
					const entry = relatedIn.get(key);
					if (entry === undefined) return;
					entry.delete(file);
					if (entry.size !== 0) return;
					relatedIn.delete(key);
					if (relatedIn.size === 0) this._assetsRelatedIn.delete(name);
				};
				const entry = oldRelated[key];
				if (Array.isArray(entry)) {
					for (const name of entry) {
						remove(name);
					}
				} else if (entry) {
					remove(entry);
				}
			}
		}
		if (newRelated) {
			for (const key of Object.keys(newRelated)) {
				/**
				 * @param {string} name name
				 */
				const add = name =&gt; {
					let relatedIn = this._assetsRelatedIn.get(name);
					if (relatedIn === undefined) {
						this._assetsRelatedIn.set(name, (relatedIn = new Map()));
					}
					let entry = relatedIn.get(key);
					if (entry === undefined) {
						relatedIn.set(key, (entry = new Set()));
					}
					entry.add(file);
				};
				const entry = newRelated[key];
				if (Array.isArray(entry)) {
					for (const name of entry) {
						add(name);
					}
				} else if (entry) {
					add(entry);
				}
			}
		}
	}

	/**
	 * @param {string} file file name
	 * @param {Source | ((source: Source) =&gt; Source)} newSourceOrFunction new asset source or function converting old to new
	 * @param {(AssetInfo | ((assetInfo?: AssetInfo) =&gt; AssetInfo | undefined)) | undefined} assetInfoUpdateOrFunction new asset info or function converting old to new
	 */
	updateAsset(
		file,
		newSourceOrFunction,
		assetInfoUpdateOrFunction = undefined
	) {
		if (!this.assets[file]) {
			throw new Error(
				`Called Compilation.updateAsset for not existing filename ${file}`
			);
		}
		this.assets[file] =
			typeof newSourceOrFunction === &quot;function&quot;
				? newSourceOrFunction(this.assets[file])
				: newSourceOrFunction;
		if (assetInfoUpdateOrFunction !== undefined) {
			const oldInfo = this.assetsInfo.get(file) || EMPTY_ASSET_INFO;
			if (typeof assetInfoUpdateOrFunction === &quot;function&quot;) {
				this._setAssetInfo(file, assetInfoUpdateOrFunction(oldInfo), oldInfo);
			} else {
				this._setAssetInfo(
					file,
					cachedCleverMerge(oldInfo, assetInfoUpdateOrFunction),
					oldInfo
				);
			}
		}
	}

	/**
	 * @param {string} file file name
	 * @param {string} newFile the new name of file
	 */
	renameAsset(file, newFile) {
		const source = this.assets[file];
		if (!source) {
			throw new Error(
				`Called Compilation.renameAsset for not existing filename ${file}`
			);
		}
		if (this.assets[newFile] &amp;&amp; !isSourceEqual(this.assets[file], source)) {
			this.errors.push(
				new WebpackError(
					`Conflict: Called Compilation.renameAsset for already existing filename ${newFile} with different content`
				)
			);
		}
		const assetInfo = this.assetsInfo.get(file);
		// Update related in all other assets
		const relatedInInfo = this._assetsRelatedIn.get(file);
		if (relatedInInfo) {
			for (const [key, assets] of relatedInInfo) {
				for (const name of assets) {
					const info = this.assetsInfo.get(name);
					if (!info) continue;
					const related = info.related;
					if (!related) continue;
					const entry = related[key];
					let newEntry;
					if (Array.isArray(entry)) {
						newEntry = entry.map(x =&gt; (x === file ? newFile : x));
					} else if (entry === file) {
						newEntry = newFile;
					} else continue;
					this.assetsInfo.set(name, {
						...info,
						related: {
							...related,
							[key]: newEntry
						}
					});
				}
			}
		}
		this._setAssetInfo(file, undefined, assetInfo);
		this._setAssetInfo(newFile, assetInfo);
		delete this.assets[file];
		this.assets[newFile] = source;
		for (const chunk of this.chunks) {
			{
				const size = chunk.files.size;
				chunk.files.delete(file);
				if (size !== chunk.files.size) {
					chunk.files.add(newFile);
				}
			}
			{
				const size = chunk.auxiliaryFiles.size;
				chunk.auxiliaryFiles.delete(file);
				if (size !== chunk.auxiliaryFiles.size) {
					chunk.auxiliaryFiles.add(newFile);
				}
			}
		}
	}

	/**
	 * @param {string} file file name
	 */
	deleteAsset(file) {
		if (!this.assets[file]) {
			return;
		}
		delete this.assets[file];
		const assetInfo = this.assetsInfo.get(file);
		this._setAssetInfo(file, undefined, assetInfo);
		const related = assetInfo &amp;&amp; assetInfo.related;
		if (related) {
			for (const key of Object.keys(related)) {
				/**
				 * @param {string} file file
				 */
				const checkUsedAndDelete = file =&gt; {
					if (!this._assetsRelatedIn.has(file)) {
						this.deleteAsset(file);
					}
				};
				const items = related[key];
				if (Array.isArray(items)) {
					for (const file of items) {
						checkUsedAndDelete(file);
					}
				} else if (items) {
					checkUsedAndDelete(items);
				}
			}
		}
		// TODO If this becomes a performance problem
		// store a reverse mapping from asset to chunk
		for (const chunk of this.chunks) {
			chunk.files.delete(file);
			chunk.auxiliaryFiles.delete(file);
		}
	}

	getAssets() {
		/** @type {Readonly&lt;Asset&gt;[]} */
		const array = [];
		for (const assetName of Object.keys(this.assets)) {
			if (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {
				array.push({
					name: assetName,
					source: this.assets[assetName],
					info: this.assetsInfo.get(assetName) || EMPTY_ASSET_INFO
				});
			}
		}
		return array;
	}

	/**
	 * @param {string} name the name of the asset
	 * @returns {Readonly&lt;Asset&gt; | undefined} the asset or undefined when not found
	 */
	getAsset(name) {
		if (!Object.prototype.hasOwnProperty.call(this.assets, name)) return;
		return {
			name,
			source: this.assets[name],
			info: this.assetsInfo.get(name) || EMPTY_ASSET_INFO
		};
	}

	clearAssets() {
		for (const chunk of this.chunks) {
			chunk.files.clear();
			chunk.auxiliaryFiles.clear();
		}
	}

	createModuleAssets() {
		const { chunkGraph } = this;
		for (const module of this.modules) {
			const buildInfo = /** @type {BuildInfo} */ (module.buildInfo);
			if (buildInfo.assets) {
				const assetsInfo = buildInfo.assetsInfo;
				for (const assetName of Object.keys(buildInfo.assets)) {
					const fileName = this.getPath(assetName, {
						chunkGraph: this.chunkGraph,
						module
					});
					for (const chunk of chunkGraph.getModuleChunksIterable(module)) {
						chunk.auxiliaryFiles.add(fileName);
					}
					this.emitAsset(
						fileName,
						buildInfo.assets[assetName],
						assetsInfo ? assetsInfo.get(assetName) : undefined
					);
					this.hooks.moduleAsset.call(module, fileName);
				}
			}
		}
	}

	/**
	 * @param {RenderManifestOptions} options options object
	 * @returns {RenderManifestEntry[]} manifest entries
	 */
	getRenderManifest(options) {
		return this.hooks.renderManifest.call([], options);
	}

	/**
	 * @param {Callback} callback signals when the call finishes
	 * @returns {void}
	 */
	createChunkAssets(callback) {
		const outputOptions = this.outputOptions;
		const cachedSourceMap = new WeakMap();
		/** @type {Map&lt;string, {hash: string, source: Source, chunk: Chunk}&gt;} */
		const alreadyWrittenFiles = new Map();

		asyncLib.forEachLimit(
			this.chunks,
			15,
			(chunk, callback) =&gt; {
				/** @type {RenderManifestEntry[]} */
				let manifest;
				try {
					manifest = this.getRenderManifest({
						chunk,
						hash: /** @type {string} */ (this.hash),
						fullHash: /** @type {string} */ (this.fullHash),
						outputOptions,
						codeGenerationResults: this.codeGenerationResults,
						moduleTemplates: this.moduleTemplates,
						dependencyTemplates: this.dependencyTemplates,
						chunkGraph: this.chunkGraph,
						moduleGraph: this.moduleGraph,
						runtimeTemplate: this.runtimeTemplate
					});
				} catch (err) {
					this.errors.push(
						new ChunkRenderError(chunk, &quot;&quot;, /** @type {Error} */ (err))
					);
					return callback();
				}
				asyncLib.each(
					manifest,
					(fileManifest, callback) =&gt; {
						const ident = fileManifest.identifier;
						const usedHash = /** @type {string} */ (fileManifest.hash);

						const assetCacheItem = this._assetsCache.getItemCache(
							ident,
							usedHash
						);

						assetCacheItem.get((err, sourceFromCache) =&gt; {
							/** @type {TemplatePath} */
							let filenameTemplate;
							/** @type {string} */
							let file;
							/** @type {AssetInfo} */
							let assetInfo;

							let inTry = true;
							/**
							 * @param {Error} err error
							 * @returns {void}
							 */
							const errorAndCallback = err =&gt; {
								const filename =
									file ||
									(typeof file === &quot;string&quot;
										? file
										: typeof filenameTemplate === &quot;string&quot;
											? filenameTemplate
											: &quot;&quot;);

								this.errors.push(new ChunkRenderError(chunk, filename, err));
								inTry = false;
								return callback();
							};

							try {
								if (&quot;filename&quot; in fileManifest) {
									file = fileManifest.filename;
									assetInfo = fileManifest.info;
								} else {
									filenameTemplate = fileManifest.filenameTemplate;
									const pathAndInfo = this.getPathWithInfo(
										filenameTemplate,
										fileManifest.pathOptions
									);
									file = pathAndInfo.path;
									assetInfo = fileManifest.info
										? {
												...pathAndInfo.info,
												...fileManifest.info
											}
										: pathAndInfo.info;
								}

								if (err) {
									return errorAndCallback(err);
								}

								let source = sourceFromCache;

								// check if the same filename was already written by another chunk
								const alreadyWritten = alreadyWrittenFiles.get(file);
								if (alreadyWritten !== undefined) {
									if (alreadyWritten.hash !== usedHash) {
										inTry = false;
										return callback(
											new WebpackError(
												`Conflict: Multiple chunks emit assets to the same filename ${file}` +
													` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`
											)
										);
									}
									source = alreadyWritten.source;
								} else if (!source) {
									// render the asset
									source = fileManifest.render();

									// Ensure that source is a cached source to avoid additional cost because of repeated access
									if (!(source instanceof CachedSource)) {
										const cacheEntry = cachedSourceMap.get(source);
										if (cacheEntry) {
											source = cacheEntry;
										} else {
											const cachedSource = new CachedSource(source);
											cachedSourceMap.set(source, cachedSource);
											source = cachedSource;
										}
									}
								}
								this.emitAsset(file, source, assetInfo);
								if (fileManifest.auxiliary) {
									chunk.auxiliaryFiles.add(file);
								} else {
									chunk.files.add(file);
								}
								this.hooks.chunkAsset.call(chunk, file);
								alreadyWrittenFiles.set(file, {
									hash: usedHash,
									source,
									chunk
								});
								if (source !== sourceFromCache) {
									assetCacheItem.store(source, err =&gt; {
										if (err) return errorAndCallback(err);
										inTry = false;
										return callback();
									});
								} else {
									inTry = false;
									callback();
								}
							} catch (err) {
								if (!inTry) throw err;
								errorAndCallback(/** @type {Error} */ (err));
							}
						});
					},
					callback
				);
			},
			callback
		);
	}

	/**
	 * @param {TemplatePath} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {string} interpolated path
	 */
	getPath(filename, data = {}) {
		if (!data.hash) {
			data = {
				hash: this.hash,
				...data
			};
		}
		return this.getAssetPath(filename, data);
	}

	/**
	 * @param {TemplatePath} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {InterpolatedPathAndAssetInfo} interpolated path and asset info
	 */
	getPathWithInfo(filename, data = {}) {
		if (!data.hash) {
			data = {
				hash: this.hash,
				...data
			};
		}
		return this.getAssetPathWithInfo(filename, data);
	}

	/**
	 * @param {TemplatePath} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {string} interpolated path
	 */
	getAssetPath(filename, data) {
		return this.hooks.assetPath.call(
			typeof filename === &quot;function&quot; ? filename(data) : filename,
			data,
			undefined
		);
	}

	/**
	 * @param {TemplatePath} filename used to get asset path with hash
	 * @param {PathData} data context data
	 * @returns {InterpolatedPathAndAssetInfo} interpolated path and asset info
	 */
	getAssetPathWithInfo(filename, data) {
		const assetInfo = {};
		// TODO webpack 5: refactor assetPath hook to receive { path, info } object
		const newPath = this.hooks.assetPath.call(
			typeof filename === &quot;function&quot; ? filename(data, assetInfo) : filename,
			data,
			assetInfo
		);
		return { path: newPath, info: assetInfo };
	}

	getWarnings() {
		return this.hooks.processWarnings.call(this.warnings);
	}

	getErrors() {
		return this.hooks.processErrors.call(this.errors);
	}

	/**
	 * This function allows you to run another instance of webpack inside of webpack however as
	 * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
	 * from parent (or top level compiler) and creates a child Compilation
	 * @param {string} name name of the child compiler
	 * @param {Partial&lt;OutputOptions&gt;=} outputOptions // Need to convert config schema to types for this
	 * @param {Array&lt;WebpackPluginInstance | WebpackPluginFunction&gt;=} plugins webpack plugins that will be applied
	 * @returns {Compiler} creates a child Compiler instance
	 */
	createChildCompiler(name, outputOptions, plugins) {
		const idx = this.childrenCounters[name] || 0;
		this.childrenCounters[name] = idx + 1;
		return this.compiler.createChildCompiler(
			this,
			name,
			idx,
			outputOptions,
			plugins
		);
	}

	/**
	 * @param {Module} module the module
	 * @param {ExecuteModuleOptions} options options
	 * @param {ExecuteModuleCallback} callback callback
	 */
	executeModule(module, options, callback) {
		// Aggregate all referenced modules and ensure they are ready
		const modules = new Set([module]);
		processAsyncTree(
			modules,
			10,
			(module, push, callback) =&gt; {
				this.buildQueue.waitFor(module, err =&gt; {
					if (err) return callback(err);
					this.processDependenciesQueue.waitFor(module, err =&gt; {
						if (err) return callback(err);
						for (const { module: m } of this.moduleGraph.getOutgoingConnections(
							module
						)) {
							const size = modules.size;
							modules.add(m);
							if (modules.size !== size) push(m);
						}
						callback();
					});
				});
			},
			err =&gt; {
				if (err) return callback(/** @type {WebpackError} */ (err));

				// Create new chunk graph, chunk and entrypoint for the build time execution
				const chunkGraph = new ChunkGraph(
					this.moduleGraph,
					this.outputOptions.hashFunction
				);
				const runtime = &quot;build time&quot;;
				const { hashFunction, hashDigest, hashDigestLength } =
					this.outputOptions;
				const runtimeTemplate = this.runtimeTemplate;

				const chunk = new Chunk(&quot;build time chunk&quot;, this._backCompat);
				chunk.id = /** @type {ChunkId} */ (chunk.name);
				chunk.ids = [chunk.id];
				chunk.runtime = runtime;

				const entrypoint = new Entrypoint({
					runtime,
					chunkLoading: false,
					...options.entryOptions
				});
				chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);
				connectChunkGroupAndChunk(entrypoint, chunk);
				entrypoint.setRuntimeChunk(chunk);
				entrypoint.setEntrypointChunk(chunk);

				const chunks = new Set([chunk]);

				// Assign ids to modules and modules to the chunk
				for (const module of modules) {
					const id = module.identifier();
					chunkGraph.setModuleId(module, id);
					chunkGraph.connectChunkAndModule(chunk, module);
				}

				/** @type {WebpackError[]} */
				const errors = [];

				// Hash modules
				for (const module of modules) {
					this._createModuleHash(
						module,
						chunkGraph,
						runtime,
						hashFunction,
						runtimeTemplate,
						hashDigest,
						hashDigestLength,
						errors
					);
				}

				const codeGenerationResults = new CodeGenerationResults(
					this.outputOptions.hashFunction
				);
				/**
				 * @param {Module} module the module
				 * @param {Callback} callback callback
				 * @returns {void}
				 */
				const codeGen = (module, callback) =&gt; {
					this._codeGenerationModule(
						module,
						runtime,
						[runtime],
						chunkGraph.getModuleHash(module, runtime),
						this.dependencyTemplates,
						chunkGraph,
						this.moduleGraph,
						runtimeTemplate,
						errors,
						codeGenerationResults,
						(err, codeGenerated) =&gt; {
							callback(err);
						}
					);
				};

				const reportErrors = () =&gt; {
					if (errors.length &gt; 0) {
						errors.sort(
							compareSelect(err =&gt; err.module, compareModulesByIdentifier)
						);
						for (const error of errors) {
							this.errors.push(error);
						}
						errors.length = 0;
					}
				};

				// Generate code for all aggregated modules
				asyncLib.eachLimit(modules, 10, codeGen, err =&gt; {
					if (err) return callback(err);
					reportErrors();

					// for backward-compat temporary set the chunk graph
					// TODO webpack 6
					const old = this.chunkGraph;
					this.chunkGraph = chunkGraph;
					this.processRuntimeRequirements({
						chunkGraph,
						modules,
						chunks,
						codeGenerationResults,
						chunkGraphEntries: chunks
					});
					this.chunkGraph = old;

					const runtimeModules =
						chunkGraph.getChunkRuntimeModulesIterable(chunk);

					// Hash runtime modules
					for (const module of runtimeModules) {
						modules.add(module);
						this._createModuleHash(
							module,
							chunkGraph,
							runtime,
							hashFunction,
							runtimeTemplate,
							hashDigest,
							hashDigestLength,
							errors
						);
					}

					// Generate code for all runtime modules
					asyncLib.eachLimit(runtimeModules, 10, codeGen, err =&gt; {
						if (err) return callback(err);
						reportErrors();

						/** @type {Map&lt;Module, ExecuteModuleArgument&gt;} */
						const moduleArgumentsMap = new Map();
						/** @type {Map&lt;string, ExecuteModuleArgument&gt;} */
						const moduleArgumentsById = new Map();

						/** @type {ExecuteModuleResult[&quot;fileDependencies&quot;]} */
						const fileDependencies = new LazySet();
						/** @type {ExecuteModuleResult[&quot;contextDependencies&quot;]} */
						const contextDependencies = new LazySet();
						/** @type {ExecuteModuleResult[&quot;missingDependencies&quot;]} */
						const missingDependencies = new LazySet();
						/** @type {ExecuteModuleResult[&quot;buildDependencies&quot;]} */
						const buildDependencies = new LazySet();

						/** @type {ExecuteModuleResult[&quot;assets&quot;]} */
						const assets = new Map();

						let cacheable = true;

						/** @type {ExecuteModuleContext} */
						const context = {
							assets,
							__webpack_require__: undefined,
							chunk,
							chunkGraph
						};

						// Prepare execution
						asyncLib.eachLimit(
							modules,
							10,
							(module, callback) =&gt; {
								const codeGenerationResult = codeGenerationResults.get(
									module,
									runtime
								);
								/** @type {ExecuteModuleArgument} */
								const moduleArgument = {
									module,
									codeGenerationResult,
									preparedInfo: undefined,
									moduleObject: undefined
								};
								moduleArgumentsMap.set(module, moduleArgument);
								moduleArgumentsById.set(module.identifier(), moduleArgument);
								module.addCacheDependencies(
									fileDependencies,
									contextDependencies,
									missingDependencies,
									buildDependencies
								);
								if (
									/** @type {BuildInfo} */ (module.buildInfo).cacheable ===
									false
								) {
									cacheable = false;
								}
								if (module.buildInfo &amp;&amp; module.buildInfo.assets) {
									const { assets: moduleAssets, assetsInfo } = module.buildInfo;
									for (const assetName of Object.keys(moduleAssets)) {
										assets.set(assetName, {
											source: moduleAssets[assetName],
											info: assetsInfo ? assetsInfo.get(assetName) : undefined
										});
									}
								}
								this.hooks.prepareModuleExecution.callAsync(
									moduleArgument,
									context,
									callback
								);
							},
							err =&gt; {
								if (err) return callback(err);

								/** @type {ExecuteModuleExports | undefined} */
								let exports;
								try {
									const {
										strictModuleErrorHandling,
										strictModuleExceptionHandling
									} = this.outputOptions;

									/** @type {WebpackRequire} */
									const __webpack_require__ = id =&gt; {
										const cached = moduleCache[id];
										if (cached !== undefined) {
											if (cached.error) throw cached.error;
											return cached.exports;
										}
										const moduleArgument = moduleArgumentsById.get(id);
										return __webpack_require_module__(
											/** @type {ExecuteModuleArgument} */
											(moduleArgument),
											id
										);
									};
									const interceptModuleExecution = (__webpack_require__[
										/** @type {&quot;i&quot;} */
										(
											RuntimeGlobals.interceptModuleExecution.replace(
												`${RuntimeGlobals.require}.`,
												&quot;&quot;
											)
										)
									] = /** @type {NonNullable&lt;WebpackRequire[&quot;i&quot;]&gt;} */ ([]));
									const moduleCache = (__webpack_require__[
										/** @type {&quot;c&quot;} */ (
											RuntimeGlobals.moduleCache.replace(
												`${RuntimeGlobals.require}.`,
												&quot;&quot;
											)
										)
									] = /** @type {NonNullable&lt;WebpackRequire[&quot;c&quot;]&gt;} */ ({}));

									context.__webpack_require__ = __webpack_require__;

									/**
									 * @param {ExecuteModuleArgument} moduleArgument the module argument
									 * @param {string=} id id
									 * @returns {ExecuteModuleExports} exports
									 */
									const __webpack_require_module__ = (moduleArgument, id) =&gt; {
										/** @type {ExecuteOptions} */
										const execOptions = {
											id,
											module: {
												id,
												exports: {},
												loaded: false,
												error: undefined
											},
											require: __webpack_require__
										};
										for (const handler of interceptModuleExecution) {
											handler(execOptions);
										}
										const module = moduleArgument.module;
										this.buildTimeExecutedModules.add(module);
										const moduleObject = execOptions.module;
										moduleArgument.moduleObject = moduleObject;
										try {
											if (id) moduleCache[id] = moduleObject;

											tryRunOrWebpackError(
												() =&gt;
													this.hooks.executeModule.call(
														moduleArgument,
														context
													),
												&quot;Compilation.hooks.executeModule&quot;
											);
											moduleObject.loaded = true;
											return moduleObject.exports;
										} catch (execErr) {
											if (strictModuleExceptionHandling) {
												if (id) delete moduleCache[id];
											} else if (strictModuleErrorHandling) {
												moduleObject.error =
													/** @type {WebpackError} */
													(execErr);
											}
											if (!(/** @type {WebpackError} */ (execErr).module)) {
												/** @type {WebpackError} */
												(execErr).module = module;
											}
											throw execErr;
										}
									};

									for (const runtimeModule of chunkGraph.getChunkRuntimeModulesInOrder(
										chunk
									)) {
										__webpack_require_module__(
											/** @type {ExecuteModuleArgument} */
											(moduleArgumentsMap.get(runtimeModule))
										);
									}
									exports = __webpack_require__(module.identifier());
								} catch (execErr) {
									const { message, stack, module } =
										/** @type {WebpackError} */
										(execErr);
									const err = new WebpackError(
										`Execution of module code from module graph (${
											/** @type {Module} */
											(module).readableIdentifier(this.requestShortener)
										}) failed: ${message}`,
										{ cause: execErr }
									);
									err.stack = stack;
									err.module = module;
									return callback(err);
								}

								callback(null, {
									exports,
									assets,
									cacheable,
									fileDependencies,
									contextDependencies,
									missingDependencies,
									buildDependencies
								});
							}
						);
					});
				});
			}
		);
	}

	checkConstraints() {
		const chunkGraph = this.chunkGraph;

		/** @type {Set&lt;number|string&gt;} */
		const usedIds = new Set();

		for (const module of this.modules) {
			if (module.type === WEBPACK_MODULE_TYPE_RUNTIME) continue;
			const moduleId = chunkGraph.getModuleId(module);
			if (moduleId === null) continue;
			if (usedIds.has(moduleId)) {
				throw new Error(`checkConstraints: duplicate module id ${moduleId}`);
			}
			usedIds.add(moduleId);
		}

		for (const chunk of this.chunks) {
			for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
				if (!this.modules.has(module)) {
					throw new Error(
						&quot;checkConstraints: module in chunk but not in compilation &quot; +
							` ${chunk.debugId} ${module.debugId}`
					);
				}
			}
			for (const module of chunkGraph.getChunkEntryModulesIterable(chunk)) {
				if (!this.modules.has(module)) {
					throw new Error(
						&quot;checkConstraints: entry module in chunk but not in compilation &quot; +
							` ${chunk.debugId} ${module.debugId}`
					);
				}
			}
		}

		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.checkConstraints();
		}
	}
}

/**
 * @typedef {object} FactorizeModuleOptions
 * @property {ModuleProfile=} currentProfile
 * @property {ModuleFactory} factory
 * @property {Dependency[]} dependencies
 * @property {boolean=} factoryResult return full ModuleFactoryResult instead of only module
 * @property {Module | null} originModule
 * @property {Partial&lt;ModuleFactoryCreateDataContextInfo&gt;=} contextInfo
 * @property {string=} context
 */

/**
 * @param {FactorizeModuleOptions} options options object
 * @param {ModuleCallback | ModuleFactoryResultCallback} callback callback
 * @returns {void}
 */

// Workaround for typescript as it doesn&#039;t support function overloading in jsdoc within a class
/* eslint-disable jsdoc/require-asterisk-prefix */
Compilation.prototype.factorizeModule = /**
	 @type {{
	(options: FactorizeModuleOptions &amp; { factoryResult?: false }, callback: ModuleCallback): void;
	(options: FactorizeModuleOptions &amp; { factoryResult: true }, callback: ModuleFactoryResultCallback): void;
}} */ (
	function (options, callback) {
		this.factorizeQueue.add(options, /** @type {TODO} */ (callback));
	}
);
/* eslint-enable jsdoc/require-asterisk-prefix */

// Hide from typescript
const compilationPrototype = Compilation.prototype;

// TODO webpack 6 remove
Object.defineProperty(compilationPrototype, &quot;modifyHash&quot;, {
	writable: false,
	enumerable: false,
	configurable: false,
	value: () =&gt; {
		throw new Error(
			&quot;Compilation.modifyHash was removed in favor of Compilation.hooks.fullHash&quot;
		);
	}
});

// TODO webpack 6 remove
Object.defineProperty(compilationPrototype, &quot;cache&quot;, {
	enumerable: false,
	configurable: false,
	get: util.deprecate(
		/**
		 * @this {Compilation} the compilation
		 * @returns {Cache} the cache
		 */
		function () {
			return this.compiler.cache;
		},
		&quot;Compilation.cache was removed in favor of Compilation.getCache()&quot;,
		&quot;DEP_WEBPACK_COMPILATION_CACHE&quot;
	),
	set: util.deprecate(
		/**
		 * @param {EXPECTED_ANY} v value
		 */
		v =&gt; {},
		&quot;Compilation.cache was removed in favor of Compilation.getCache()&quot;,
		&quot;DEP_WEBPACK_COMPILATION_CACHE&quot;
	)
});

/**
 * Add additional assets to the compilation.
 */
Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL = -2000;

/**
 * Basic preprocessing of assets.
 */
Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS = -1000;

/**
 * Derive new assets from existing assets.
 * Existing assets should not be treated as complete.
 */
Compilation.PROCESS_ASSETS_STAGE_DERIVED = -200;

/**
 * Add additional sections to existing assets, like a banner or initialization code.
 */
Compilation.PROCESS_ASSETS_STAGE_ADDITIONS = -100;

/**
 * Optimize existing assets in a general way.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE = 100;

/**
 * Optimize the count of existing assets, e. g. by merging them.
 * Only assets of the same type should be merged.
 * For assets of different types see PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT = 200;

/**
 * Optimize the compatibility of existing assets, e. g. add polyfills or vendor-prefixes.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY = 300;

/**
 * Optimize the size of existing assets, e. g. by minimizing or omitting whitespace.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE = 400;

/**
 * Add development tooling to assets, e. g. by extracting a SourceMap.
 */
Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING = 500;

/**
 * Optimize the count of existing assets, e. g. by inlining assets of into other assets.
 * Only assets of different types should be inlined.
 * For assets of the same type see PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE = 700;

/**
 * Summarize the list of existing assets
 * e. g. creating an assets manifest of Service Workers.
 */
Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE = 1000;

/**
 * Optimize the hashes of the assets, e. g. by generating real hashes of the asset content.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH = 2500;

/**
 * Optimize the transfer of existing assets, e. g. by preparing a compressed (gzip) file as separate asset.
 */
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER = 3000;

/**
 * Analyse existing assets.
 */
Compilation.PROCESS_ASSETS_STAGE_ANALYSE = 4000;

/**
 * Creating assets for reporting purposes.
 */
Compilation.PROCESS_ASSETS_STAGE_REPORT = 5000;

module.exports = Compilation;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
