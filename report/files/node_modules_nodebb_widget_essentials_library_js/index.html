<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-widget-essentials/library.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-widget-essentials/library.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.62</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">679</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.62</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const nconf = require.main.require(&#039;nconf&#039;);
const validator = require.main.require(&#039;validator&#039;);
const benchpressjs = require.main.require(&#039;benchpressjs&#039;);
const _ = require.main.require(&#039;lodash&#039;);

const db = require.main.require(&#039;./src/database&#039;);
const categories = require.main.require(&#039;./src/categories&#039;);
const user = require.main.require(&#039;./src/user&#039;);
const plugins = require.main.require(&#039;./src/plugins&#039;);
const topics = require.main.require(&#039;./src/topics&#039;);
const posts = require.main.require(&#039;./src/posts&#039;);
const groups = require.main.require(&#039;./src/groups&#039;);
const utils = require.main.require(&#039;./src/utils&#039;);
const meta = require.main.require(&#039;./src/meta&#039;);
const privileges = require.main.require(&#039;./src/privileges&#039;);

let app;

const Widget = module.exports;

const sidebarLocations = [&#039;left&#039;, &#039;right&#039;, &#039;sidebar&#039;];

Widget.init = async function (params) {
	app = params.app;
};

Widget.renderHTMLWidget = async function (widget) {
	if (!isVisibleInCategory(widget) || !isVisibleInTopic(widget)) {
		return null;
	}
	const tpl = widget.data ? widget.data.html : &#039;&#039;;
	widget.html = await benchpressjs.compileRender(String(tpl), widget.templateData);
	return widget;
};

Widget.renderTextWidget = async function (widget) {
	if (!isVisibleInCategory(widget)) {
		return null;
	}
	const parseAsPost = !!widget.data.parseAsPost;
	const text = String(widget.data.text);

	if (parseAsPost) {
		widget.html = await plugins.hooks.fire(&#039;filter:parse.raw&#039;, text);
	} else {
		widget.html = text.replace(/\r\n/g, &#039;&lt;br /&gt;&#039;);
	}
	return widget;
};

Widget.renderSearchWidget = async function (widget) {
	if (widget.templateData.template.search) {
		return null;
	}
	const userPrivileges = await privileges.global.get(widget.uid);

	const inOptions = [
		{ value: &#039;titles&#039;, label: &#039;[[search:in-titles]]&#039; },
		{ value: &#039;titlesposts&#039;, label: &#039;[[search:in-titles-posts]]&#039; },
		{ value: &#039;posts&#039;, label: &#039;[[global:posts]]&#039; },
		{ value: &#039;categories&#039;, label: &#039;[[global:header.categories]]&#039; },
	];
	if (userPrivileges[&#039;search:users&#039;]) {
		inOptions.push({ value: &#039;users&#039;, label: &#039;[[global:users]]&#039; });
	}
	if (userPrivileges[&#039;search:tags&#039;]) {
		inOptions.push({ value: &#039;tags&#039;, label: &#039;[[tags:tags]]&#039; });
	}
	inOptions.forEach((option) =&gt; {
		option.selected = option.value === widget.data.defaultIn;
	});

	widget.html = await app.renderAsync(&#039;widgets/search&#039;, {
		inOptions: inOptions,
		showInControl: widget.data.showInControl === &#039;on&#039;,
		enableQuickSearch: widget.data.enableQuickSearch === &#039;on&#039;,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

function getValuesArray(widget, field) {
	const values = widget.data[field] || &#039;&#039;;
	return values.split(&#039;,&#039;).map(c =&gt; parseInt(c, 10)).filter(Boolean);
}

function isVisibleInCategory(widget) {
	const cids = getValuesArray(widget, &#039;cid&#039;);
	return !(
		cids.length &amp;&amp;
		(widget.templateData.template.category || widget.templateData.template.topic) &amp;&amp;
		!cids.includes(parseInt(widget.templateData.cid, 10))
	);
}

function isVisibleInTopic(widget) {
	const tids = getValuesArray(widget, &#039;tid&#039;);
	return !(
		tids.length &amp;&amp;
		widget.templateData.template.topic &amp;&amp;
		!tids.includes(parseInt(widget.templateData.tid, 10))
	);
}

Widget.renderRecentViewWidget = async function (widget) {
	const [data, allowedCids] = await Promise.all([
		topics.getLatestTopics({
			uid:
			widget.uid,
			start: 0,
			stop: 19,
			term: &#039;month&#039;,
		}),
		categories.getCidsByPrivilege(&#039;categories:cid&#039;, widget.uid, &#039;topics:create&#039;),
	]);

	data.relative_path = nconf.get(&#039;relative_path&#039;);
	data.loggedIn = !!widget.req.uid;
	data.config = data.config || {};
	data.config.relative_path = nconf.get(&#039;relative_path&#039;);
	data.canPost = allowedCids.length &gt; 0;
	widget.html = await app.renderAsync(&#039;recent&#039;, data);
	widget.html = widget.html.replace(/&lt;ol[\s\S]*?&lt;br \/&gt;/, &#039;&#039;).replace(&#039;&lt;br&gt;&#039;, &#039;&#039;);
	return widget;
};

Widget.renderOnlineUsersWidget = async function (widget) {
	const count = Math.max(1, widget.data.numUsers || 24);
	const uids = await user.getUidsFromSet(&#039;users:online&#039;, 0, count - 1);
	let userData = await user.getUsersFields(uids, [&#039;uid&#039;, &#039;username&#039;, &#039;userslug&#039;, &#039;picture&#039;, &#039;status&#039;, &#039;lastonline&#039;]);
	userData = userData.filter(user =&gt; user.status !== &#039;offline&#039;);
	userData.sort((a, b) =&gt; b.lastonline - a.lastonline);
	widget.html = await app.renderAsync(&#039;widgets/onlineusers&#039;, {
		online_users: userData,
		sidebar: sidebarLocations.includes(widget.location),
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderActiveUsersWidget = async function (widget) {
	const count = Math.max(1, widget.data.numUsers || 24);
	const cids = getValuesArray(widget, &#039;cid&#039;);
	let uids;
	if (cids.length) {
		uids = await categories.getActiveUsers(cids);
	} else if (widget.templateData.template.topic) {
		uids = await topics.getUids(widget.templateData.tid);
	} else {
		uids = await posts.getRecentPosterUids(0, count - 1);
	}
	uids = uids.slice(0, count);

	const userData = await user.getUsersFields(uids, [&#039;uid&#039;, &#039;username&#039;, &#039;userslug&#039;, &#039;picture&#039;, &#039;lastposttime&#039;]);
	userData.sort((a, b) =&gt; b.lastposttime - a.lastposttime);
	userData.forEach((u) =&gt; {
		if (u) {
			u.lastposttimeISO = utils.toISOString(u.lastposttime);
		}
	});

	widget.html = await app.renderAsync(&#039;widgets/activeusers&#039;, {
		active_users: userData,
		sidebar: sidebarLocations.includes(widget.location),
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderLatestUsersWidget = async function (widget) {
	const count = Math.max(1, widget.data.numUsers || 24);
	const users = await user.getUsersFromSet(&#039;users:joindate&#039;, widget.uid, 0, count - 1);
	widget.html = await app.renderAsync(&#039;widgets/latestusers&#039;, {
		users: users,
		sidebar: sidebarLocations.includes(widget.location),
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderTopPostersWidget = async function (widget) {
	const count = Math.max(1, widget.data.numUsers || 24);
	const users = await user.getUsersFromSet(&#039;users:postcount&#039;, widget.uid, 0, count - 1);

	widget.html = await app.renderAsync(&#039;widgets/topposters&#039;, {
		users: users,
		sidebar: sidebarLocations.includes(widget.location),
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderModeratorsWidget = async function (widget) {
	let cid;

	if (widget.data.cid) {
		cid = widget.data.cid;
	} else if (widget.templateData.template.category) {
		cid = widget.templateData.cid;
	} else if (widget.templateData.template.topic &amp;&amp; widget.templateData.category) {
		cid = widget.templateData.category.cid;
	}

	const moderators = await categories.getModerators(cid);
	if (!moderators.length) {
		return null;
	}
	widget.html = await app.renderAsync(&#039;widgets/moderators&#039;, {
		moderators: moderators,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderForumStatsWidget = async function (widget) {
	const socketRooms = require.main.require(&#039;./src/socket.io/admin/rooms&#039;);
	const [global, onlineCount, guestCount] = await Promise.all([
		db.getObjectFields(&#039;global&#039;, [&#039;topicCount&#039;, &#039;postCount&#039;, &#039;userCount&#039;]),
		db.sortedSetCount(&#039;users:online&#039;, Date.now() - (meta.config.onlineCutoff * 60000), &#039;+inf&#039;),
		socketRooms.getTotalGuestCount(),
	]);

	const stats = {
		topics: utils.makeNumberHumanReadable(global.topicCount ? global.topicCount : 0),
		posts: utils.makeNumberHumanReadable(global.postCount ? global.postCount : 0),
		users: utils.makeNumberHumanReadable(global.userCount ? global.userCount : 0),
		online: utils.makeNumberHumanReadable(onlineCount + guestCount),
		statsClass: widget.data.statsClass,
	};
	widget.html = await app.renderAsync(&#039;widgets/forumstats&#039;, stats);
	return widget;
};

Widget.renderRecentPostsWidget = async function (widget) {
	let cid;

	if (widget.data.cid) {
		cid = widget.data.cid;
	} else if (widget.templateData.template.category) {
		cid = widget.templateData.cid;
	} else if (widget.templateData.template.topic &amp;&amp; widget.templateData.category) {
		cid = widget.templateData.category.cid;
	}
	const numPosts = widget.data.numPosts || 4;
	let postsData;
	if (cid) {
		postsData = await categories.getRecentReplies(cid, widget.uid, 0, Math.max(0, numPosts - 1));
	} else {
		let cids = await categories.getCidsByPrivilege(&#039;categories:cid&#039;, widget.uid, &#039;topics:read&#039;);
		cids = cids.filter(cid =&gt; cid !== -1);
		const pids = await db.getSortedSetRevRange(
			cids.map(cid =&gt; `cid:${cid}:pids`), 0, Math.max(0, numPosts - 1),
		);
		postsData = await posts.getPostSummaryByPids(pids, widget.uid, { stripTags: true });
	}
	const data = {
		posts: postsData,
		numPosts: numPosts,
		cid: cid,
		relative_path: nconf.get(&#039;relative_path&#039;),
	};
	widget.html = await app.renderAsync(&#039;widgets/recentposts&#039;, data);
	return widget;
};

Widget.renderRecentTopicsWidget = async function (widget) {
	const numTopics = (widget.data.numTopics || 8) - 1;
	let cids = getValuesArray(widget, &#039;cid&#039;);

	let key;
	if (!cids.length) {
		cids = await categories.getCidsByPrivilege(&#039;categories:cid&#039;, widget.uid, &#039;topics:read&#039;);
		cids = cids.filter(cid =&gt; cid !== -1);
	}
	if (cids.length) {
		if (cids.length === 1) {
			key = `cid:${cids[0]}:tids:lastposttime`;
		} else {
			key = cids.map(cid =&gt; `cid:${cid}:tids:lastposttime`);
		}
	}
	const data = await topics.getTopicsFromSet(key, widget.uid, 0, Math.max(0, numTopics));
	data.topics.forEach((topicData) =&gt; {
		if (topicData &amp;&amp; !topicData.teaser) {
			topicData.teaser = {
				user: topicData.user,
				timestampISO: topicData.timestampISO,
			};
		}
	});
	widget.html = await app.renderAsync(&#039;widgets/recenttopics&#039;, {
		topics: data.topics,
		numTopics: numTopics,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderCategories = async function (widget) {
	let categoryData = await categories.getCategoriesByPrivilege(&#039;categories:cid&#039;, widget.uid, &#039;find&#039;);
	categoryData = categoryData.filter(c =&gt; c &amp;&amp; c.cid !== -1);
	const tree = categories.getTree(categoryData, 0);
	widget.html = await app.renderAsync(&#039;widgets/categories&#039;, {
		categories: tree,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderPopularTags = async function (widget) {
	const numTags = widget.data.numTags || 8;
	const display = widget.data.display || &#039;buttons&#039;;
	let tags = [];
	if (widget.templateData.template.category) {
		tags = await topics.getCategoryTagsData(widget.templateData.cid, 0, numTags - 1);
	} else {
		let cids = await categories.getCidsByPrivilege(&#039;categories:cid&#039;, widget.uid, &#039;topics:read&#039;);
		cids = cids.filter(cid =&gt; cid !== -1);
		tags = await topics.getCategoryTagsData(cids, 0, numTags - 1);
	}
	let maxCount = 1;
	tags.forEach((t) =&gt; {
		if (t.score &gt; maxCount) {
			maxCount = t.score;
		}
	});
	tags.forEach((t) =&gt; {
		t.widthPercent = ((t.score / maxCount) * 100).toFixed(2);
	});

	widget.html = await app.renderAsync(&#039;widgets/populartags&#039;, {
		tags: tags,
		display,
		template: widget.templateData.template,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderPopularTopics = async function (widget) {
	const numTopics = widget.data.numTopics || 8;
	const data = await topics.getSortedTopics({
		uid: widget.uid,
		start: 0,
		stop: numTopics - 1,
		term: widget.data.duration || &#039;alltime&#039;,
		sort: &#039;posts&#039;,
	});
	widget.html = await app.renderAsync(&#039;widgets/populartopics&#039;, {
		topics: data.topics,
		numTopics: numTopics,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderTopTopics = async function (widget) {
	const numTopics = widget.data.numTopics || 8;
	const data = await topics.getSortedTopics({
		uid: widget.uid,
		start: 0,
		stop: numTopics - 1,
		term: widget.data.duration || &#039;alltime&#039;,
		sort: &#039;votes&#039;,
	});
	widget.html = await app.renderAsync(&#039;widgets/toptopics&#039;, {
		topics: data.topics,
		numTopics: numTopics,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderMyGroups = async function (widget) {
	const { uid } = widget;
	const numGroups = parseInt(widget.data.numGroups, 10) || 9;
	const groupsData = await groups.getUserGroups([uid]);
	let userGroupData = groupsData.length ? groupsData[0] : [];
	userGroupData = userGroupData.slice(0, numGroups);
	widget.html = await app.renderAsync(&#039;widgets/groups&#039;, {
		groups: userGroupData,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderGroupPosts = async function (widget) {
	const numPosts = parseInt(widget.data.numPosts, 10) || 4;
	const postsData = await groups.getLatestMemberPosts(widget.data.groupName, numPosts, widget.uid);
	widget.html = await app.renderAsync(&#039;widgets/groupposts&#039;, { posts: postsData });
	return widget;
};

Widget.renderNewGroups = async function (widget) {
	const numGroups = parseInt(widget.data.numGroups, 10) || 8;
	const groupNames = await db.getSortedSetRevRange(&#039;groups:visible:createtime&#039;, 0, numGroups - 1);
	const groupsData = await groups.getGroupsData(groupNames);
	widget.html = await app.renderAsync(&#039;widgets/groups&#039;, {
		groups: groupsData.filter(Boolean),
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderSuggestedTopics = async function (widget) {
	const numTopics = Math.max(0, (widget.data.numTopics || 8) - 1);
	const cutoff = Math.max(0, parseInt(widget.data.cutoff, 10) || 0);
	async function getCategoryTopics(term, sort) {
		const data = await topics.getSortedTopics({
			cids: widget.templateData.cid,
			uid: widget.uid,
			start: 0,
			stop: 2 * numTopics,
			term: term,
			sort: sort,
		});
		return data.topics;
	}
	let topicData;
	if (widget.templateData.template.topic) {
		topicData = await topics.getSuggestedTopics(widget.templateData.tid, widget.uid, 0, numTopics, cutoff);
	} else if (widget.templateData.template.category) {
		topicData = await getCategoryTopics(&#039;month&#039;, &#039;votes&#039;);
		if (!topicData.length) {
			topicData = await getCategoryTopics(&#039;alltime&#039;, &#039;recent&#039;);
		}
		topicData = _.shuffle(topicData).slice(0, numTopics + 1);
		topicData = topicData.filter(topic =&gt; topic &amp;&amp; !topic.deleted);
	} else {
		const data = await topics.getTopicsFromSet(&#039;topics:recent&#039;, widget.uid, 0, numTopics);
		topicData = data ? data.topics : [];
		topicData = topicData.filter(topic =&gt; topic &amp;&amp; !topic.deleted);
	}

	const sidebarLocations = [&#039;left&#039;, &#039;right&#039;, &#039;sidebar&#039;];
	widget.html = await app.renderAsync(&#039;widgets/suggestedtopics&#039;, {
		topics: topicData,
		config: widget.templateData.config,
		sidebar: sidebarLocations.includes(widget.location),
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderUserPost = async function (widget) {
	const numPosts = Math.max(1, (widget.data.numPosts || 1));
	const type = widget.data.postType || &#039;last&#039;;
	let { uid } = widget;
	if (widget.templateData.template[&#039;account/profile&#039;]) {
		uid = widget.templateData.uid;
	} else if (widget.data.uid) {
		uid = widget.data.uid;
	}
	let pids = [];
	const cids = await categories.getCidsByPrivilege(&#039;categories:cid&#039;, widget.uid, &#039;topics:read&#039;);
	const sets = cids.map(c =&gt; `cid:${c}:uid:${uid}:pids`);
	const now = Date.now();
	if (type === &#039;last&#039;) {
		pids = await db.getSortedSetRevRangeByScore(sets, 0, numPosts, now, &#039;-inf&#039;);
	} else if (type === &#039;first&#039;) {
		pids = await db.getSortedSetRange(sets, 0, numPosts, now, &#039;-inf&#039;);
	} else if (type === &#039;best&#039;) {
		pids = await db.getSortedSetRevRange(
			cids.map(c =&gt; `cid:${c}:uid:${uid}:pids:votes`),
			0,
			numPosts,
			now,
			&#039;-inf&#039;
		);
	}
	const postObjs = await posts.getPostSummaryByPids(pids, widget.uid, { stripTags: false });
	if (!postObjs.length) {
		return null;
	}
	widget.html = await app.renderAsync(&#039;widgets/userpost&#039;, {
		posts: postObjs,
		config: widget.templateData.config,
		relative_path: nconf.get(&#039;relative_path&#039;),
	});
	return widget;
};

Widget.renderChatRoom = async function (widget) {
	const roomId = (widget.data.roomId || 0);
	if (!roomId) {
		return null;
	}

	const { uid } = widget;
	const chatsAPI = require.main.require(&#039;./src/api/chats&#039;);
	const messaging = require.main.require(&#039;./src/messaging&#039;);
	try {
		const [roomData, publicRooms] = await Promise.all([
			chatsAPI.get({ uid: uid }, { uid, roomId }),
			messaging.getPublicRooms(uid, uid),
		]);

		if (!roomData) {
			return null;
		}
		publicRooms.forEach((room) =&gt; {
			if (room &amp;&amp; parseInt(room.roomId, 10) === parseInt(roomId, 10)) {
				room.selected = true;
			}
		});

		widget.html = await app.renderAsync(&#039;widgets/chat&#039;, {
			roomId: roomId,
			isWidget: true,
			...roomData,
			publicRooms,
			config: widget.templateData.config,
			relative_path: nconf.get(&#039;relative_path&#039;),
		});
	} catch (err) {
		if (err.message === &#039;[[error:no-privileges]]&#039;) {
			return null;
		}
		throw err;
	}

	return widget;
};

Widget.defineWidgets = async function (widgets) {
	const widgetData = [
		{
			widget: &#039;html&#039;,
			name: &#039;HTML&#039;,
			description: &#039;Any text, html, or embedded script.&#039;,
			content: &#039;admin/partials/widgets/html&#039;,
		},
		{
			widget: &#039;text&#039;,
			name: &#039;Text&#039;,
			description: &#039;Text, optionally parsed as a post.&#039;,
			content: &#039;admin/partials/widgets/text&#039;,
		},
		{
			widget: &#039;search&#039;,
			name: &#039;Search&#039;,
			description: &#039;A search widget&#039;,
			content: &#039;admin/partials/widgets/search&#039;,
		},
		{
			widget: &#039;onlineusers&#039;,
			name: &#039;Online Users&#039;,
			description: &#039;List of online users&#039;,
			content: &#039;admin/partials/widgets/onlineusers&#039;,
		},
		{
			widget: &#039;activeusers&#039;,
			name: &#039;Active Users&#039;,
			description: &#039;List of active users in a category/topic&#039;,
			content: &#039;admin/partials/widgets/activeusers&#039;,
		},
		{
			widget: &#039;latestusers&#039;,
			name: &#039;Latest Users&#039;,
			description: &#039;List of latest registered users.&#039;,
			content: &#039;admin/partials/widgets/latestusers&#039;,
		},
		{
			widget: &#039;topposters&#039;,
			name: &#039;Top Posters&#039;,
			description: &#039;List of users with the most posts.&#039;,
			content: &#039;admin/partials/widgets/topposters&#039;,
		},
		{
			widget: &#039;moderators&#039;,
			name: &#039;Moderators&#039;,
			description: &#039;List of moderators in a category.&#039;,
			content: &#039;admin/partials/widgets/moderators&#039;,
		},
		{
			widget: &#039;forumstats&#039;,
			name: &#039;Forum Stats&#039;,
			description: &#039;Lists user, topics, and post count.&#039;,
			content: &#039;admin/partials/widgets/forumstats&#039;,
		},
		{
			widget: &#039;recentposts&#039;,
			name: &#039;Recent Posts&#039;,
			description: &#039;Lists the latest posts on your forum.&#039;,
			content: &#039;admin/partials/widgets/recentposts&#039;,
		},
		{
			widget: &#039;recenttopics&#039;,
			name: &#039;Recent Topics&#039;,
			description: &#039;Lists the latest topics on your forum.&#039;,
			content: &#039;admin/partials/widgets/recenttopics&#039;,
		},
		{
			widget: &#039;recentview&#039;,
			name: &#039;Recent View&#039;,
			description: &#039;Renders the /recent page&#039;,
			content: &#039;admin/partials/widgets/defaultwidget&#039;,
		},
		{
			widget: &#039;categories&#039;,
			name: &#039;Categories&#039;,
			description: &#039;Lists the categories on your forum&#039;,
			content: &#039;admin/partials/widgets/categories&#039;,
		},
		{
			widget: &#039;populartags&#039;,
			name: &#039;Popular Tags&#039;,
			description: &#039;Lists popular tags on your forum&#039;,
			content: &#039;admin/partials/widgets/populartags&#039;,
		},
		{
			widget: &#039;populartopics&#039;,
			name: &#039;Popular Topics&#039;,
			description: &#039;Lists popular topics on your forum&#039;,
			content: &#039;admin/partials/widgets/populartopics&#039;,
		},
		{
			widget: &#039;toptopics&#039;,
			name: &#039;Top Topics&#039;,
			description: &#039;Lists top topics on your forum&#039;,
			content: &#039;admin/partials/widgets/toptopics&#039;,
		},
		{
			widget: &#039;mygroups&#039;,
			name: &#039;My Groups&#039;,
			description: &#039;List of groups that you are in&#039;,
			content: &#039;admin/partials/widgets/mygroups&#039;,
		},
		{
			widget: &#039;newgroups&#039;,
			name: &#039;New Groups&#039;,
			description: &#039;List of newest groups&#039;,
			content: &#039;admin/partials/widgets/mygroups&#039;,
		},
		{
			widget: &#039;suggestedtopics&#039;,
			name: &#039;Suggested Topics&#039;,
			description: &#039;Lists of suggested topics.&#039;,
			content: &#039;admin/partials/widgets/suggestedtopics&#039;,
		},
		{
			widget: &#039;userpost&#039;,
			name: &#039;User Post&#039;,
			description: &#039;Display a users first/last/best post on their profile or by user id.&#039;,
			content: &#039;admin/partials/widgets/userpost&#039;,
		},
		{
			widget: &#039;chat&#039;,
			name: &#039;Chat Room&#039;,
			description: &#039;Display a chat room as a widget&#039;,
			content: &#039;admin/partials/widgets/chat&#039;,
		},
	];

	await Promise.all(widgetData.map(async (widget) =&gt; {
		widget.content = await app.renderAsync(widget.content, {});
	}));

	widgets = widgets.concat(widgetData);
	const groupNames = await db.getSortedSetRevRange(&#039;groups:visible:createtime&#039;, 0, -1);
	let groupsData = await groups.getGroupsData(groupNames);
	groupsData = groupsData.filter(Boolean);
	groupsData.forEach((group) =&gt; {
		group.name = validator.escape(String(group.name));
	});

	const html = await app.renderAsync(&#039;admin/partials/widgets/groupposts&#039;, { groups: groupsData });
	widgets.push({
		widget: &#039;groupposts&#039;,
		name: &#039;Group Posts&#039;,
		description: &#039;Posts made my members of a group&#039;,
		content: html,
	});

	return widgets;
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
