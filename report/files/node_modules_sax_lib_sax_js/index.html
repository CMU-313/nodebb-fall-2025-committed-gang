<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sax/lib/sax.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sax/lib/sax.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">48.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1598</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">86.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">19.40</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that&#039;s the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    &#039;comment&#039;, &#039;sgmlDecl&#039;, &#039;textNode&#039;, &#039;tagName&#039;, &#039;doctype&#039;,
    &#039;procInstName&#039;, &#039;procInstBody&#039;, &#039;entity&#039;, &#039;attribName&#039;,
    &#039;attribValue&#039;, &#039;cdata&#039;, &#039;script&#039;
  ]

  sax.EVENTS = [
    &#039;text&#039;,
    &#039;processinginstruction&#039;,
    &#039;sgmldeclaration&#039;,
    &#039;doctype&#039;,
    &#039;comment&#039;,
    &#039;opentagstart&#039;,
    &#039;attribute&#039;,
    &#039;opentag&#039;,
    &#039;closetag&#039;,
    &#039;opencdata&#039;,
    &#039;cdata&#039;,
    &#039;closecdata&#039;,
    &#039;error&#039;,
    &#039;end&#039;,
    &#039;ready&#039;,
    &#039;script&#039;,
    &#039;opennamespace&#039;,
    &#039;closenamespace&#039;
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = &#039;&#039;
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? &#039;toLowerCase&#039; : &#039;toUpperCase&#039;
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // disallow unquoted attribute values if not otherwise configured
    // and strict mode is true
    if (parser.opt.unquotedAttributeValues === undefined) {
      parser.opt.unquotedAttributeValues = !strict;
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, &#039;onready&#039;)
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i &lt; l; i++) {
      var len = parser[buffers[i]].length
      if (len &gt; maxAllowed) {
        // Text/cdata nodes can get big, and since they&#039;re buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won&#039;t get any bigger.
        switch (buffers[i]) {
          case &#039;textNode&#039;:
            closeText(parser)
            break

          case &#039;cdata&#039;:
            emitNode(parser, &#039;oncdata&#039;, parser.cdata)
            parser.cdata = &#039;&#039;
            break

          case &#039;script&#039;:
            emitNode(parser, &#039;onscript&#039;, parser.script)
            parser.script = &#039;&#039;
            break

          default:
            error(parser, &#039;Max buffer length exceeded: &#039; + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i &lt; l; i++) {
      parser[buffers[i]] = &#039;&#039;
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== &#039;&#039;) {
      emitNode(parser, &#039;oncdata&#039;, parser.cdata)
      parser.cdata = &#039;&#039;
    }
    if (parser.script !== &#039;&#039;) {
      emitNode(parser, &#039;onscript&#039;, parser.script)
      parser.script = &#039;&#039;
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require(&#039;stream&#039;).Stream
  } catch (ex) {
    Stream = function () {}
  }
  if (!Stream) Stream = function () {}

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== &#039;error&#039; &amp;&amp; ev !== &#039;end&#039;
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit(&#039;end&#039;)
    }

    this._parser.onerror = function (er) {
      me.emit(&#039;error&#039;, er)

      // if didn&#039;t throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, &#039;on&#039; + ev, {
        get: function () {
          return me._parser[&#039;on&#039; + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser[&#039;on&#039; + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === &#039;function&#039; &amp;&amp;
      typeof Buffer.isBuffer === &#039;function&#039; &amp;&amp;
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require(&#039;string_decoder&#039;).StringDecoder
        this._decoder = new SD(&#039;utf8&#039;)
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit(&#039;data&#039;, data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk &amp;&amp; chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser[&#039;on&#039; + ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
      me._parser[&#039;on&#039; + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = &#039;[CDATA[&#039;
  var DOCTYPE = &#039;DOCTYPE&#039;
  var XML_NAMESPACE = &#039;http://www.w3.org/XML/1998/namespace&#039;
  var XMLNS_NAMESPACE = &#039;http://www.w3.org/2000/xmlns/&#039;
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === &#039; &#039; || c === &#039;\n&#039; || c === &#039;\r&#039; || c === &#039;\t&#039;
  }

  function isQuote (c) {
    return c === &#039;&quot;&#039; || c === &#039;\&#039;&#039;
  }

  function isAttribEnd (c) {
    return c === &#039;&gt;&#039; || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp;amp and such.
    OPEN_WAKA: S++, // &lt;
    SGML_DECL: S++, // &lt;!BLARG
    SGML_DECL_QUOTED: S++, // &lt;!BLARG foo &quot;bar
    DOCTYPE: S++, // &lt;!DOCTYPE
    DOCTYPE_QUOTED: S++, // &lt;!DOCTYPE &quot;//blah
    DOCTYPE_DTD: S++, // &lt;!DOCTYPE &quot;//blah&quot; [ ...
    DOCTYPE_DTD_QUOTED: S++, // &lt;!DOCTYPE &quot;//blah&quot; [ &quot;foo
    COMMENT_STARTING: S++, // &lt;!-
    COMMENT: S++, // &lt;!--
    COMMENT_ENDING: S++, // &lt;!-- blah -
    COMMENT_ENDED: S++, // &lt;!-- blah --
    CDATA: S++, // &lt;![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // &lt;?hi
    PROC_INST_BODY: S++, // &lt;?hi there
    PROC_INST_ENDING: S++, // &lt;?hi &quot;there&quot; ?
    OPEN_TAG: S++, // &lt;strong
    OPEN_TAG_SLASH: S++, // &lt;strong /
    ATTRIB: S++, // &lt;a
    ATTRIB_NAME: S++, // &lt;a foo
    ATTRIB_NAME_SAW_WHITE: S++, // &lt;a foo _
    ATTRIB_VALUE: S++, // &lt;a foo=
    ATTRIB_VALUE_QUOTED: S++, // &lt;a foo=&quot;bar
    ATTRIB_VALUE_CLOSED: S++, // &lt;a foo=&quot;bar&quot;
    ATTRIB_VALUE_UNQUOTED: S++, // &lt;a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // &lt;foo bar=&quot;&amp;quot;&quot;
    ATTRIB_VALUE_ENTITY_U: S++, // &lt;foo bar=&amp;quot
    CLOSE_TAG: S++, // &lt;/a
    CLOSE_TAG_SAW_WHITE: S++, // &lt;/a   &gt;
    SCRIPT: S++, // &lt;script&gt; ...
    SCRIPT_ENDING: S++ // &lt;script&gt; ... &lt;
  }

  sax.XML_ENTITIES = {
    &#039;amp&#039;: &#039;&amp;&#039;,
    &#039;gt&#039;: &#039;&gt;&#039;,
    &#039;lt&#039;: &#039;&lt;&#039;,
    &#039;quot&#039;: &#039;&quot;&#039;,
    &#039;apos&#039;: &quot;&#039;&quot;
  }

  sax.ENTITIES = {
    &#039;amp&#039;: &#039;&amp;&#039;,
    &#039;gt&#039;: &#039;&gt;&#039;,
    &#039;lt&#039;: &#039;&lt;&#039;,
    &#039;quot&#039;: &#039;&quot;&#039;,
    &#039;apos&#039;: &quot;&#039;&quot;,
    &#039;AElig&#039;: 198,
    &#039;Aacute&#039;: 193,
    &#039;Acirc&#039;: 194,
    &#039;Agrave&#039;: 192,
    &#039;Aring&#039;: 197,
    &#039;Atilde&#039;: 195,
    &#039;Auml&#039;: 196,
    &#039;Ccedil&#039;: 199,
    &#039;ETH&#039;: 208,
    &#039;Eacute&#039;: 201,
    &#039;Ecirc&#039;: 202,
    &#039;Egrave&#039;: 200,
    &#039;Euml&#039;: 203,
    &#039;Iacute&#039;: 205,
    &#039;Icirc&#039;: 206,
    &#039;Igrave&#039;: 204,
    &#039;Iuml&#039;: 207,
    &#039;Ntilde&#039;: 209,
    &#039;Oacute&#039;: 211,
    &#039;Ocirc&#039;: 212,
    &#039;Ograve&#039;: 210,
    &#039;Oslash&#039;: 216,
    &#039;Otilde&#039;: 213,
    &#039;Ouml&#039;: 214,
    &#039;THORN&#039;: 222,
    &#039;Uacute&#039;: 218,
    &#039;Ucirc&#039;: 219,
    &#039;Ugrave&#039;: 217,
    &#039;Uuml&#039;: 220,
    &#039;Yacute&#039;: 221,
    &#039;aacute&#039;: 225,
    &#039;acirc&#039;: 226,
    &#039;aelig&#039;: 230,
    &#039;agrave&#039;: 224,
    &#039;aring&#039;: 229,
    &#039;atilde&#039;: 227,
    &#039;auml&#039;: 228,
    &#039;ccedil&#039;: 231,
    &#039;eacute&#039;: 233,
    &#039;ecirc&#039;: 234,
    &#039;egrave&#039;: 232,
    &#039;eth&#039;: 240,
    &#039;euml&#039;: 235,
    &#039;iacute&#039;: 237,
    &#039;icirc&#039;: 238,
    &#039;igrave&#039;: 236,
    &#039;iuml&#039;: 239,
    &#039;ntilde&#039;: 241,
    &#039;oacute&#039;: 243,
    &#039;ocirc&#039;: 244,
    &#039;ograve&#039;: 242,
    &#039;oslash&#039;: 248,
    &#039;otilde&#039;: 245,
    &#039;ouml&#039;: 246,
    &#039;szlig&#039;: 223,
    &#039;thorn&#039;: 254,
    &#039;uacute&#039;: 250,
    &#039;ucirc&#039;: 251,
    &#039;ugrave&#039;: 249,
    &#039;uuml&#039;: 252,
    &#039;yacute&#039;: 253,
    &#039;yuml&#039;: 255,
    &#039;copy&#039;: 169,
    &#039;reg&#039;: 174,
    &#039;nbsp&#039;: 160,
    &#039;iexcl&#039;: 161,
    &#039;cent&#039;: 162,
    &#039;pound&#039;: 163,
    &#039;curren&#039;: 164,
    &#039;yen&#039;: 165,
    &#039;brvbar&#039;: 166,
    &#039;sect&#039;: 167,
    &#039;uml&#039;: 168,
    &#039;ordf&#039;: 170,
    &#039;laquo&#039;: 171,
    &#039;not&#039;: 172,
    &#039;shy&#039;: 173,
    &#039;macr&#039;: 175,
    &#039;deg&#039;: 176,
    &#039;plusmn&#039;: 177,
    &#039;sup1&#039;: 185,
    &#039;sup2&#039;: 178,
    &#039;sup3&#039;: 179,
    &#039;acute&#039;: 180,
    &#039;micro&#039;: 181,
    &#039;para&#039;: 182,
    &#039;middot&#039;: 183,
    &#039;cedil&#039;: 184,
    &#039;ordm&#039;: 186,
    &#039;raquo&#039;: 187,
    &#039;frac14&#039;: 188,
    &#039;frac12&#039;: 189,
    &#039;frac34&#039;: 190,
    &#039;iquest&#039;: 191,
    &#039;times&#039;: 215,
    &#039;divide&#039;: 247,
    &#039;OElig&#039;: 338,
    &#039;oelig&#039;: 339,
    &#039;Scaron&#039;: 352,
    &#039;scaron&#039;: 353,
    &#039;Yuml&#039;: 376,
    &#039;fnof&#039;: 402,
    &#039;circ&#039;: 710,
    &#039;tilde&#039;: 732,
    &#039;Alpha&#039;: 913,
    &#039;Beta&#039;: 914,
    &#039;Gamma&#039;: 915,
    &#039;Delta&#039;: 916,
    &#039;Epsilon&#039;: 917,
    &#039;Zeta&#039;: 918,
    &#039;Eta&#039;: 919,
    &#039;Theta&#039;: 920,
    &#039;Iota&#039;: 921,
    &#039;Kappa&#039;: 922,
    &#039;Lambda&#039;: 923,
    &#039;Mu&#039;: 924,
    &#039;Nu&#039;: 925,
    &#039;Xi&#039;: 926,
    &#039;Omicron&#039;: 927,
    &#039;Pi&#039;: 928,
    &#039;Rho&#039;: 929,
    &#039;Sigma&#039;: 931,
    &#039;Tau&#039;: 932,
    &#039;Upsilon&#039;: 933,
    &#039;Phi&#039;: 934,
    &#039;Chi&#039;: 935,
    &#039;Psi&#039;: 936,
    &#039;Omega&#039;: 937,
    &#039;alpha&#039;: 945,
    &#039;beta&#039;: 946,
    &#039;gamma&#039;: 947,
    &#039;delta&#039;: 948,
    &#039;epsilon&#039;: 949,
    &#039;zeta&#039;: 950,
    &#039;eta&#039;: 951,
    &#039;theta&#039;: 952,
    &#039;iota&#039;: 953,
    &#039;kappa&#039;: 954,
    &#039;lambda&#039;: 955,
    &#039;mu&#039;: 956,
    &#039;nu&#039;: 957,
    &#039;xi&#039;: 958,
    &#039;omicron&#039;: 959,
    &#039;pi&#039;: 960,
    &#039;rho&#039;: 961,
    &#039;sigmaf&#039;: 962,
    &#039;sigma&#039;: 963,
    &#039;tau&#039;: 964,
    &#039;upsilon&#039;: 965,
    &#039;phi&#039;: 966,
    &#039;chi&#039;: 967,
    &#039;psi&#039;: 968,
    &#039;omega&#039;: 969,
    &#039;thetasym&#039;: 977,
    &#039;upsih&#039;: 978,
    &#039;piv&#039;: 982,
    &#039;ensp&#039;: 8194,
    &#039;emsp&#039;: 8195,
    &#039;thinsp&#039;: 8201,
    &#039;zwnj&#039;: 8204,
    &#039;zwj&#039;: 8205,
    &#039;lrm&#039;: 8206,
    &#039;rlm&#039;: 8207,
    &#039;ndash&#039;: 8211,
    &#039;mdash&#039;: 8212,
    &#039;lsquo&#039;: 8216,
    &#039;rsquo&#039;: 8217,
    &#039;sbquo&#039;: 8218,
    &#039;ldquo&#039;: 8220,
    &#039;rdquo&#039;: 8221,
    &#039;bdquo&#039;: 8222,
    &#039;dagger&#039;: 8224,
    &#039;Dagger&#039;: 8225,
    &#039;bull&#039;: 8226,
    &#039;hellip&#039;: 8230,
    &#039;permil&#039;: 8240,
    &#039;prime&#039;: 8242,
    &#039;Prime&#039;: 8243,
    &#039;lsaquo&#039;: 8249,
    &#039;rsaquo&#039;: 8250,
    &#039;oline&#039;: 8254,
    &#039;frasl&#039;: 8260,
    &#039;euro&#039;: 8364,
    &#039;image&#039;: 8465,
    &#039;weierp&#039;: 8472,
    &#039;real&#039;: 8476,
    &#039;trade&#039;: 8482,
    &#039;alefsym&#039;: 8501,
    &#039;larr&#039;: 8592,
    &#039;uarr&#039;: 8593,
    &#039;rarr&#039;: 8594,
    &#039;darr&#039;: 8595,
    &#039;harr&#039;: 8596,
    &#039;crarr&#039;: 8629,
    &#039;lArr&#039;: 8656,
    &#039;uArr&#039;: 8657,
    &#039;rArr&#039;: 8658,
    &#039;dArr&#039;: 8659,
    &#039;hArr&#039;: 8660,
    &#039;forall&#039;: 8704,
    &#039;part&#039;: 8706,
    &#039;exist&#039;: 8707,
    &#039;empty&#039;: 8709,
    &#039;nabla&#039;: 8711,
    &#039;isin&#039;: 8712,
    &#039;notin&#039;: 8713,
    &#039;ni&#039;: 8715,
    &#039;prod&#039;: 8719,
    &#039;sum&#039;: 8721,
    &#039;minus&#039;: 8722,
    &#039;lowast&#039;: 8727,
    &#039;radic&#039;: 8730,
    &#039;prop&#039;: 8733,
    &#039;infin&#039;: 8734,
    &#039;ang&#039;: 8736,
    &#039;and&#039;: 8743,
    &#039;or&#039;: 8744,
    &#039;cap&#039;: 8745,
    &#039;cup&#039;: 8746,
    &#039;int&#039;: 8747,
    &#039;there4&#039;: 8756,
    &#039;sim&#039;: 8764,
    &#039;cong&#039;: 8773,
    &#039;asymp&#039;: 8776,
    &#039;ne&#039;: 8800,
    &#039;equiv&#039;: 8801,
    &#039;le&#039;: 8804,
    &#039;ge&#039;: 8805,
    &#039;sub&#039;: 8834,
    &#039;sup&#039;: 8835,
    &#039;nsub&#039;: 8836,
    &#039;sube&#039;: 8838,
    &#039;supe&#039;: 8839,
    &#039;oplus&#039;: 8853,
    &#039;otimes&#039;: 8855,
    &#039;perp&#039;: 8869,
    &#039;sdot&#039;: 8901,
    &#039;lceil&#039;: 8968,
    &#039;rceil&#039;: 8969,
    &#039;lfloor&#039;: 8970,
    &#039;rfloor&#039;: 8971,
    &#039;lang&#039;: 9001,
    &#039;rang&#039;: 9002,
    &#039;loz&#039;: 9674,
    &#039;spades&#039;: 9824,
    &#039;clubs&#039;: 9827,
    &#039;hearts&#039;: 9829,
    &#039;diams&#039;: 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === &#039;number&#039; ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] &amp;&amp; parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, &#039;ontext&#039;, parser.textNode)
    parser.textNode = &#039;&#039;
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, &#039; &#039;)
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += &#039;\nLine: &#039; + parser.line +
        &#039;\nColumn: &#039; + parser.column +
        &#039;\nChar: &#039; + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, &#039;onerror&#039;, er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot &amp;&amp; !parser.closedRoot) strictFail(parser, &#039;Unclosed root tag&#039;)
    if ((parser.state !== S.BEGIN) &amp;&amp;
      (parser.state !== S.BEGIN_WHITESPACE) &amp;&amp;
      (parser.state !== S.TEXT)) {
      error(parser, &#039;Unexpected end&#039;)
    }
    closeText(parser)
    parser.c = &#039;&#039;
    parser.closed = true
    emit(parser, &#039;onend&#039;)
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== &#039;object&#039; || !(parser instanceof SAXParser)) {
      throw new Error(&#039;bad call to strictFail&#039;)
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns=&quot;foo&quot; or xmlns:foo=&quot;bar&quot;
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, &#039;onopentagstart&#039;, tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(&#039;:&#039;)
    var qualName = i &lt; 0 ? [ &#039;&#039;, name ] : name.split(&#039;:&#039;)
    var prefix = qualName[0]
    var local = qualName[1]

    // &lt;x &quot;xmlns&quot;=&quot;http://foo&quot;&gt;
    if (attribute &amp;&amp; name === &#039;xmlns&#039;) {
      prefix = &#039;xmlns&#039;
      local = &#039;&#039;
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = &#039;&#039;
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === &#039;xmlns&#039;) {
        // namespace binding attribute. push the binding into scope
        if (local === &#039;xml&#039; &amp;&amp; parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            &#039;xml: prefix must be bound to &#039; + XML_NAMESPACE + &#039;\n&#039; +
            &#039;Actual: &#039; + parser.attribValue)
        } else if (local === &#039;xmlns&#039; &amp;&amp; parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            &#039;xmlns: prefix must be bound to &#039; + XMLNS_NAMESPACE + &#039;\n&#039; +
            &#039;Actual: &#039; + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, &#039;onattribute&#039;, {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = &#039;&#039;
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || &#039;&#039;

      if (tag.prefix &amp;&amp; !tag.uri) {
        strictFail(parser, &#039;Unbound namespace prefix: &#039; +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns &amp;&amp; parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, &#039;onopennamespace&#039;, {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i &lt; l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === &#039;&#039; ? &#039;&#039; : (tag.ns[prefix] || &#039;&#039;)
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there&#039;s any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix &amp;&amp; prefix !== &#039;xmlns&#039; &amp;&amp; !uri) {
          strictFail(parser, &#039;Unbound namespace prefix: &#039; +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, &#039;onattribute&#039;, a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, &#039;onopentag&#039;, parser.tag)
    if (!selfClosing) {
      // special case for &lt;script&gt; in non-strict mode.
      if (!parser.noscript &amp;&amp; parser.tagName.toLowerCase() === &#039;script&#039;) {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = &#039;&#039;
    }
    parser.attribName = parser.attribValue = &#039;&#039;
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, &#039;Weird empty close tag.&#039;)
      parser.textNode += &#039;&lt;/&gt;&#039;
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== &#039;script&#039;) {
        parser.script += &#039;&lt;/&#039; + parser.tagName + &#039;&gt;&#039;
        parser.tagName = &#039;&#039;
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, &#039;onscript&#039;, parser.script)
      parser.script = &#039;&#039;
    }

    // first make sure that the closing tag actually exists.
    // &lt;a&gt;&lt;b&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, &#039;Unexpected close tag&#039;)
      } else {
        break
      }
    }

    // didn&#039;t find it.  we already failed for strict, so just abort.
    if (t &lt; 0) {
      strictFail(parser, &#039;Unmatched closing tag: &#039; + parser.tagName)
      parser.textNode += &#039;&lt;/&#039; + parser.tagName + &#039;&gt;&#039;
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- &gt; t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, &#039;onclosetag&#039;, parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns &amp;&amp; tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, &#039;onclosenamespace&#039;, { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = &#039;&#039;
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = &#039;&#039;

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === &#039;#&#039;) {
      if (entity.charAt(1) === &#039;x&#039;) {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, &#039;&#039;)
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, &#039;Invalid character entity&#039;)
      return &#039;&amp;&#039; + parser.entity + &#039;;&#039;
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === &#039;&lt;&#039;) {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, &#039;Non-whitespace before first tag.&#039;)
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = &#039;&#039;
    if (i &lt; chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        &#039;Cannot write after close. Assign an onready handler.&#039;)
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === &#039;object&#039;) {
      chunk = chunk.toString()
    }
    var i = 0
    var c = &#039;&#039;
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === &#039;\n&#039;) {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === &#039;\uFEFF&#039;) {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot &amp;&amp; !parser.closedRoot) {
            var starti = i - 1
            while (c &amp;&amp; c !== &#039;&lt;&#039; &amp;&amp; c !== &#039;&amp;&#039;) {
              c = charAt(chunk, i++)
              if (c &amp;&amp; parser.trackPosition) {
                parser.position++
                if (c === &#039;\n&#039;) {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === &#039;&lt;&#039; &amp;&amp; !(parser.sawRoot &amp;&amp; parser.closedRoot &amp;&amp; !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) &amp;&amp; (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, &#039;Text data outside of root node.&#039;)
            }
            if (c === &#039;&amp;&#039;) {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === &#039;&lt;&#039;) {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === &#039;/&#039;) {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += &#039;&lt;&#039; + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === &#039;!&#039;) {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = &#039;&#039;
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === &#039;/&#039;) {
            parser.state = S.CLOSE_TAG
            parser.tagName = &#039;&#039;
          } else if (c === &#039;?&#039;) {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = &#039;&#039;
          } else {
            strictFail(parser, &#039;Unencoded &lt;&#039;)
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 &lt; parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(&#039; &#039;) + c
            }
            parser.textNode += &#039;&lt;&#039; + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if (parser.sgmlDecl + c === &#039;--&#039;) {
            parser.state = S.COMMENT
            parser.comment = &#039;&#039;
            parser.sgmlDecl = &#039;&#039;
            continue;
          }

          if (parser.doctype &amp;&amp; parser.doctype !== true &amp;&amp; parser.sgmlDecl) {
            parser.state = S.DOCTYPE_DTD
            parser.doctype += &#039;&lt;!&#039; + parser.sgmlDecl + c
            parser.sgmlDecl = &#039;&#039;
          } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, &#039;onopencdata&#039;)
            parser.state = S.CDATA
            parser.sgmlDecl = &#039;&#039;
            parser.cdata = &#039;&#039;
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                &#039;Inappropriately located doctype declaration&#039;)
            }
            parser.doctype = &#039;&#039;
            parser.sgmlDecl = &#039;&#039;
          } else if (c === &#039;&gt;&#039;) {
            emitNode(parser, &#039;onsgmldeclaration&#039;, parser.sgmlDecl)
            parser.sgmlDecl = &#039;&#039;
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = &#039;&#039;
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === &#039;&gt;&#039;) {
            parser.state = S.TEXT
            emitNode(parser, &#039;ondoctype&#039;, parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === &#039;[&#039;) {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = &#039;&#039;
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          if (c === &#039;]&#039;) {
            parser.doctype += c
            parser.state = S.DOCTYPE
          } else if (c === &#039;&lt;&#039;) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else if (isQuote(c)) {
            parser.doctype += c
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          } else {
            parser.doctype += c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = &#039;&#039;
          }
          continue

        case S.COMMENT:
          if (c === &#039;-&#039;) {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === &#039;-&#039;) {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, &#039;oncomment&#039;, parser.comment)
            }
            parser.comment = &#039;&#039;
          } else {
            parser.comment += &#039;-&#039; + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== &#039;&gt;&#039;) {
            strictFail(parser, &#039;Malformed comment&#039;)
            // allow &lt;!-- blah -- bloo --&gt; in non-strict mode,
            // which is a comment of &quot; blah -- bloo &quot;
            parser.comment += &#039;--&#039; + c
            parser.state = S.COMMENT
          } else if (parser.doctype &amp;&amp; parser.doctype !== true) {
            parser.state = S.DOCTYPE_DTD
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === &#039;]&#039;) {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === &#039;]&#039;) {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += &#039;]&#039; + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === &#039;&gt;&#039;) {
            if (parser.cdata) {
              emitNode(parser, &#039;oncdata&#039;, parser.cdata)
            }
            emitNode(parser, &#039;onclosecdata&#039;)
            parser.cdata = &#039;&#039;
            parser.state = S.TEXT
          } else if (c === &#039;]&#039;) {
            parser.cdata += &#039;]&#039;
          } else {
            parser.cdata += &#039;]]&#039; + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === &#039;?&#039;) {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody &amp;&amp; isWhitespace(c)) {
            continue
          } else if (c === &#039;?&#039;) {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === &#039;&gt;&#039;) {
            emitNode(parser, &#039;onprocessinginstruction&#039;, {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = &#039;&#039;
            parser.state = S.TEXT
          } else {
            parser.procInstBody += &#039;?&#039; + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === &#039;&gt;&#039;) {
              openTag(parser)
            } else if (c === &#039;/&#039;) {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, &#039;Invalid character in tag name&#039;)
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === &#039;&gt;&#039;) {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, &#039;Forward-slash in opening tag not followed by &gt;&#039;)
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven&#039;t read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === &#039;&gt;&#039;) {
            openTag(parser)
          } else if (c === &#039;/&#039;) {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = &#039;&#039;
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, &#039;Invalid attribute name&#039;)
          }
          continue

        case S.ATTRIB_NAME:
          if (c === &#039;=&#039;) {
            parser.state = S.ATTRIB_VALUE
          } else if (c === &#039;&gt;&#039;) {
            strictFail(parser, &#039;Attribute without value&#039;)
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, &#039;Invalid attribute name&#039;)
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === &#039;=&#039;) {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, &#039;Attribute without value&#039;)
            parser.tag.attributes[parser.attribName] = &#039;&#039;
            parser.attribValue = &#039;&#039;
            emitNode(parser, &#039;onattribute&#039;, {
              name: parser.attribName,
              value: &#039;&#039;
            })
            parser.attribName = &#039;&#039;
            if (c === &#039;&gt;&#039;) {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, &#039;Invalid attribute name&#039;)
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            if (!parser.opt.unquotedAttributeValues) {
              error(parser, &#039;Unquoted attribute value&#039;)
            }
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === &#039;&amp;&#039;) {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = &#039;&#039;
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === &#039;&gt;&#039;) {
            openTag(parser)
          } else if (c === &#039;/&#039;) {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, &#039;No whitespace between attributes&#039;)
            parser.attribName = c
            parser.attribValue = &#039;&#039;
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, &#039;Invalid attribute name&#039;)
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === &#039;&amp;&#039;) {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === &#039;&gt;&#039;) {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += &#039;&lt;/&#039; + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, &#039;Invalid tagname in closing tag.&#039;)
              }
            } else {
              parser.tagName = c
            }
          } else if (c === &#039;&gt;&#039;) {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += &#039;&lt;/&#039; + parser.tagName
            parser.tagName = &#039;&#039;
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, &#039;Invalid tagname in closing tag&#039;)
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === &#039;&gt;&#039;) {
            closeTag(parser)
          } else {
            strictFail(parser, &#039;Invalid characters in closing tag&#039;)
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = &#039;textNode&#039;
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = &#039;attribValue&#039;
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = &#039;attribValue&#039;
              break
          }

          if (c === &#039;;&#039;) {
            var parsedEntity = parseEntity(parser)
            if (parser.opt.unparsedEntities &amp;&amp; !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
              parser.entity = &#039;&#039;
              parser.state = returnState
              parser.write(parsedEntity)
            } else {
              parser[buffer] += parsedEntity
              parser.entity = &#039;&#039;
              parser.state = returnState
            }
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, &#039;Invalid character in entity name&#039;)
            parser[buffer] += &#039;&amp;&#039; + parser.entity + c
            parser.entity = &#039;&#039;
            parser.state = returnState
          }

          continue

        default: /* istanbul ignore next */ {
          throw new Error(parser, &#039;Unknown state: &#039; + parser.state)
        }
      }
    } // while

    if (parser.position &gt;= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return &#039;&#039;
        }
        var result = &#039;&#039;
        while (++index &lt; length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint &lt; 0 || // not a valid Unicode code point
            codePoint &gt; 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError(&#039;Invalid code point: &#039; + codePoint)
          }
          if (codePoint &lt;= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint &gt;&gt; 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length &gt; MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, &#039;fromCodePoint&#039;, {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === &#039;undefined&#039; ? this.sax = {} : exports)
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
