<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sortablejs/src/Sortable.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sortablejs/src/Sortable.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2029</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">171.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">20.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**!
 * Sortable
 * @author	RubaXa   &lt;trash@rubaxa.org&gt;
 * @author	owenm    &lt;owen23355@gmail.com&gt;
 * @license MIT
 */

import { version } from &#039;../package.json&#039;;

import { IE11OrLess, Edge, FireFox, Safari, IOS, ChromeForAndroid } from &#039;./BrowserInfo.js&#039;;

import AnimationStateManager from &#039;./Animation.js&#039;;

import PluginManager from &#039;./PluginManager.js&#039;;

import dispatchEvent from &#039;./EventDispatcher.js&#039;;

import {
	on,
	off,
	closest,
	toggleClass,
	css,
	matrix,
	find,
	getWindowScrollingElement,
	getRect,
	isScrolledPast,
	getChild,
	lastChild,
	index,
	getRelativeScrollOffset,
	extend,
	throttle,
	scrollBy,
	clone,
	expando,
	getChildContainingRectFromElement,
	getParentOrHost
} from &#039;./utils.js&#039;;


let pluginEvent = function(eventName, sortable, { evt: originalEvent, ...data } = {}) {
	PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, {
		dragEl,
		parentEl,
		ghostEl,
		rootEl,
		nextEl,
		lastDownEl,
		cloneEl,
		cloneHidden,
		dragStarted: moved,
		putSortable,
		activeSortable: Sortable.active,
		originalEvent,

		oldIndex,
		oldDraggableIndex,
		newIndex,
		newDraggableIndex,

		hideGhostForTarget: _hideGhostForTarget,
		unhideGhostForTarget: _unhideGhostForTarget,


		cloneNowHidden() {
			cloneHidden = true;
		},
		cloneNowShown() {
			cloneHidden = false;
		},

		dispatchSortableEvent(name) {
			_dispatchEvent({ sortable, name, originalEvent });
		},

		...data
	});
};

function _dispatchEvent(info) {
	dispatchEvent({
		putSortable,
		cloneEl,
		targetEl: dragEl,
		rootEl,
		oldIndex,
		oldDraggableIndex,
		newIndex,
		newDraggableIndex,
		...info
	});
}


let dragEl,
	parentEl,
	ghostEl,
	rootEl,
	nextEl,
	lastDownEl,

	cloneEl,
	cloneHidden,

	oldIndex,
	newIndex,
	oldDraggableIndex,
	newDraggableIndex,

	activeGroup,
	putSortable,

	awaitingDragStarted = false,
	ignoreNextClick = false,
	sortables = [],

	tapEvt,
	touchEvt,
	lastDx,
	lastDy,
	tapDistanceLeft,
	tapDistanceTop,

	moved,

	lastTarget,
	lastDirection,
	pastFirstInvertThresh = false,
	isCircumstantialInvert = false,

	targetMoveDistance,

	// For positioning ghost absolutely
	ghostRelativeParent,
	ghostRelativeParentInitialScroll = [], // (left, top)

	_silent = false,
	savedInputChecked = [];

	/** @const */
	const documentExists = typeof document !== &#039;undefined&#039;,

	PositionGhostAbsolutely = IOS,

	CSSFloatProperty = Edge || IE11OrLess ? &#039;cssFloat&#039; : &#039;float&#039;,

	// This will not pass for IE9, because IE9 DnD only works on anchors
	supportDraggable = documentExists &amp;&amp; !ChromeForAndroid &amp;&amp; !IOS &amp;&amp; (&#039;draggable&#039; in document.createElement(&#039;div&#039;)),

	supportCssPointerEvents = (function() {
		if (!documentExists) return;
		// false when &lt;= IE11
		if (IE11OrLess) {
			return false;
		}
		let el = document.createElement(&#039;x&#039;);
		el.style.cssText = &#039;pointer-events:auto&#039;;
		return el.style.pointerEvents === &#039;auto&#039;;
	})(),

	_detectDirection = function(el, options) {
		let elCSS = css(el),
			elWidth = parseInt(elCSS.width)
				- parseInt(elCSS.paddingLeft)
				- parseInt(elCSS.paddingRight)
				- parseInt(elCSS.borderLeftWidth)
				- parseInt(elCSS.borderRightWidth),
			child1 = getChild(el, 0, options),
			child2 = getChild(el, 1, options),
			firstChildCSS = child1 &amp;&amp; css(child1),
			secondChildCSS = child2 &amp;&amp; css(child2),
			firstChildWidth = firstChildCSS &amp;&amp; parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
			secondChildWidth = secondChildCSS &amp;&amp; parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

		if (elCSS.display === &#039;flex&#039;) {
			return elCSS.flexDirection === &#039;column&#039; || elCSS.flexDirection === &#039;column-reverse&#039;
			? &#039;vertical&#039; : &#039;horizontal&#039;;
		}

		if (elCSS.display === &#039;grid&#039;) {
			return elCSS.gridTemplateColumns.split(&#039; &#039;).length &lt;= 1 ? &#039;vertical&#039; : &#039;horizontal&#039;;
		}

		if (child1 &amp;&amp; firstChildCSS.float &amp;&amp; firstChildCSS.float !== &#039;none&#039;) {
			let touchingSideChild2 = firstChildCSS.float === &#039;left&#039; ? &#039;left&#039; : &#039;right&#039;;

			return child2 &amp;&amp; (secondChildCSS.clear === &#039;both&#039; || secondChildCSS.clear === touchingSideChild2) ?
				&#039;vertical&#039; : &#039;horizontal&#039;;
		}

		return (child1 &amp;&amp;
			(
				firstChildCSS.display === &#039;block&#039; ||
				firstChildCSS.display === &#039;flex&#039; ||
				firstChildCSS.display === &#039;table&#039; ||
				firstChildCSS.display === &#039;grid&#039; ||
				firstChildWidth &gt;= elWidth &amp;&amp;
				elCSS[CSSFloatProperty] === &#039;none&#039; ||
				child2 &amp;&amp;
				elCSS[CSSFloatProperty] === &#039;none&#039; &amp;&amp;
				firstChildWidth + secondChildWidth &gt; elWidth
			) ?
			&#039;vertical&#039; : &#039;horizontal&#039;
		);
	},

	_dragElInRowColumn = function(dragRect, targetRect, vertical) {
		let dragElS1Opp = vertical ? dragRect.left : dragRect.top,
			dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
			dragElOppLength = vertical ? dragRect.width : dragRect.height,
			targetS1Opp = vertical ? targetRect.left : targetRect.top,
			targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
			targetOppLength = vertical ? targetRect.width : targetRect.height;

		return (
			dragElS1Opp === targetS1Opp ||
			dragElS2Opp === targetS2Opp ||
			(dragElS1Opp + dragElOppLength / 2) === (targetS1Opp + targetOppLength / 2)
		);
	},

	/**
	 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
	 * @param  {Number} x      X position
	 * @param  {Number} y      Y position
	 * @return {HTMLElement}   Element of the first found nearest Sortable
	 */
	_detectNearestEmptySortable = function(x, y) {
		let ret;
		sortables.some((sortable) =&gt; {
			const threshold = sortable[expando].options.emptyInsertThreshold;
			if (!threshold || lastChild(sortable)) return;

			const rect = getRect(sortable),
				insideHorizontally = x &gt;= (rect.left - threshold) &amp;&amp; x &lt;= (rect.right + threshold),
				insideVertically = y &gt;= (rect.top - threshold) &amp;&amp; y &lt;= (rect.bottom + threshold);

			if (insideHorizontally &amp;&amp; insideVertically) {
				return (ret = sortable);
			}
		});
		return ret;
	},

	_prepareGroup = function (options) {
		function toFn(value, pull) {
			return function(to, from, dragEl, evt) {
				let sameGroup = to.options.group.name &amp;&amp;
								from.options.group.name &amp;&amp;
								to.options.group.name === from.options.group.name;

				if (value == null &amp;&amp; (pull || sameGroup)) {
					// Default pull value
					// Default pull and put value if same group
					return true;
				} else if (value == null || value === false) {
					return false;
				} else if (pull &amp;&amp; value === &#039;clone&#039;) {
					return value;
				} else if (typeof value === &#039;function&#039;) {
					return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
				} else {
					let otherGroup = (pull ? to : from).options.group.name;

					return (value === true ||
					(typeof value === &#039;string&#039; &amp;&amp; value === otherGroup) ||
					(value.join &amp;&amp; value.indexOf(otherGroup) &gt; -1));
				}
			};
		}

		let group = {};
		let originalGroup = options.group;

		if (!originalGroup || typeof originalGroup != &#039;object&#039;) {
			originalGroup = {name: originalGroup};
		}

		group.name = originalGroup.name;
		group.checkPull = toFn(originalGroup.pull, true);
		group.checkPut = toFn(originalGroup.put);
		group.revertClone = originalGroup.revertClone;

		options.group = group;
	},

	_hideGhostForTarget = function() {
		if (!supportCssPointerEvents &amp;&amp; ghostEl) {
			css(ghostEl, &#039;display&#039;, &#039;none&#039;);
		}
	},

	_unhideGhostForTarget = function() {
		if (!supportCssPointerEvents &amp;&amp; ghostEl) {
			css(ghostEl, &#039;display&#039;, &#039;&#039;);
		}
	};


// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists &amp;&amp; !ChromeForAndroid) {
	document.addEventListener(&#039;click&#039;, function(evt) {
		if (ignoreNextClick) {
			evt.preventDefault();
			evt.stopPropagation &amp;&amp; evt.stopPropagation();
			evt.stopImmediatePropagation &amp;&amp; evt.stopImmediatePropagation();
			ignoreNextClick = false;
			return false;
		}
	}, true);
}

let nearestEmptyInsertDetectEvent = function(evt) {
	if (dragEl) {
		evt = evt.touches ? evt.touches[0] : evt;
		let nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

		if (nearest) {
			// Create imitation event
			let event = {};
			for (let i in evt) {
				if (evt.hasOwnProperty(i)) {
					event[i] = evt[i];
				}
			}
			event.target = event.rootEl = nearest;
			event.preventDefault = void 0;
			event.stopPropagation = void 0;
			nearest[expando]._onDragOver(event);
		}
	}
};


let _checkOutsideTargetEl = function(evt) {
	if (dragEl) {
		dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
	}
};


/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
	if (!(el &amp;&amp; el.nodeType &amp;&amp; el.nodeType === 1)) {
		throw `Sortable: \`el\` must be an HTMLElement, not ${ {}.toString.call(el) }`;
	}

	this.el = el; // root element
	this.options = options = Object.assign({}, options);


	// Export instance
	el[expando] = this;

	let defaults = {
		group: null,
		sort: true,
		disabled: false,
		store: null,
		handle: null,
		draggable: /^[uo]l$/i.test(el.nodeName) ? &#039;&gt;li&#039; : &#039;&gt;*&#039;,
		swapThreshold: 1, // percentage; 0 &lt;= x &lt;= 1
		invertSwap: false, // invert always
		invertedSwapThreshold: null, // will be set to same as swapThreshold if default
		removeCloneOnHide: true,
		direction: function() {
			return _detectDirection(el, this.options);
		},
		ghostClass: &#039;sortable-ghost&#039;,
		chosenClass: &#039;sortable-chosen&#039;,
		dragClass: &#039;sortable-drag&#039;,
		ignore: &#039;a, img&#039;,
		filter: null,
		preventOnFilter: true,
		animation: 0,
		easing: null,
		setData: function (dataTransfer, dragEl) {
			dataTransfer.setData(&#039;Text&#039;, dragEl.textContent);
		},
		dropBubble: false,
		dragoverBubble: false,
		dataIdAttr: &#039;data-id&#039;,
		delay: 0,
		delayOnTouchOnly: false,
		touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
		forceFallback: false,
		fallbackClass: &#039;sortable-fallback&#039;,
		fallbackOnBody: false,
		fallbackTolerance: 0,
		fallbackOffset: {x: 0, y: 0},
		// Disabled on Safari: #1571; Enabled on Safari IOS: #2244
		supportPointer: Sortable.supportPointer !== false &amp;&amp; (&#039;PointerEvent&#039; in window) &amp;&amp; (!Safari || IOS),
		emptyInsertThreshold: 5
	};

	PluginManager.initializePlugins(this, el, defaults);

	// Set default options
	for (let name in defaults) {
		!(name in options) &amp;&amp; (options[name] = defaults[name]);
	}

	_prepareGroup(options);

	// Bind all private methods
	for (let fn in this) {
		if (fn.charAt(0) === &#039;_&#039; &amp;&amp; typeof this[fn] === &#039;function&#039;) {
			this[fn] = this[fn].bind(this);
		}
	}

	// Setup drag mode
	this.nativeDraggable = options.forceFallback ? false : supportDraggable;

	if (this.nativeDraggable) {
		// Touch start threshold cannot be greater than the native dragstart threshold
		this.options.touchStartThreshold = 1;
	}

	// Bind events
	if (options.supportPointer) {
		on(el, &#039;pointerdown&#039;, this._onTapStart);
	} else {
		on(el, &#039;mousedown&#039;, this._onTapStart);
		on(el, &#039;touchstart&#039;, this._onTapStart);
	}

	if (this.nativeDraggable) {
		on(el, &#039;dragover&#039;, this);
		on(el, &#039;dragenter&#039;, this);
	}

	sortables.push(this.el);

	// Restore sorting
	options.store &amp;&amp; options.store.get &amp;&amp; this.sort(options.store.get(this) || []);

	// Add animation state manager
	Object.assign(this, AnimationStateManager());
}

Sortable.prototype = /** @lends Sortable.prototype */ {
	constructor: Sortable,

	_isOutsideThisEl: function(target) {
		if (!this.el.contains(target) &amp;&amp; target !== this.el) {
			lastTarget = null;
		}
	},

	_getDirection: function(evt, target) {
		return (typeof this.options.direction === &#039;function&#039;) ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
	},

	_onTapStart: function (/** Event|TouchEvent */evt) {
		if (!evt.cancelable) return;
		let _this = this,
			el = this.el,
			options = this.options,
			preventOnFilter = options.preventOnFilter,
			type = evt.type,
			touch = (evt.touches &amp;&amp; evt.touches[0]) || (evt.pointerType &amp;&amp; evt.pointerType === &#039;touch&#039; &amp;&amp; evt),
			target = (touch || evt).target,
			originalTarget = evt.target.shadowRoot &amp;&amp; ((evt.path &amp;&amp; evt.path[0]) || (evt.composedPath &amp;&amp; evt.composedPath()[0])) || target,
			filter = options.filter;

		_saveInputCheckedState(el);


		// Don&#039;t trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
		if (dragEl) {
			return;
		}

		if (/mousedown|pointerdown/.test(type) &amp;&amp; evt.button !== 0 || options.disabled) {
			return; // only left button and enabled
		}

		// cancel dnd if original target is content editable
		if (originalTarget.isContentEditable) {
			return;
		}

		// Safari ignores further event handling after mousedown
		if (!this.nativeDraggable &amp;&amp; Safari &amp;&amp; target &amp;&amp; target.tagName.toUpperCase() === &#039;SELECT&#039;) {
			return;
		}

		target = closest(target, options.draggable, el, false);


		if (target &amp;&amp; target.animated) {
			return;
		}

		if (lastDownEl === target) {
			// Ignoring duplicate `down`
			return;
		}

		// Get the index of the dragged element within its parent
		oldIndex = index(target);
		oldDraggableIndex = index(target, options.draggable);

		// Check filter
		if (typeof filter === &#039;function&#039;) {
			if (filter.call(this, evt, target, this)) {
				_dispatchEvent({
					sortable: _this,
					rootEl: originalTarget,
					name: &#039;filter&#039;,
					targetEl: target,
					toEl: el,
					fromEl: el
				});
				pluginEvent(&#039;filter&#039;, _this, { evt });
				preventOnFilter &amp;&amp; evt.preventDefault();
				return; // cancel dnd
			}
		}
		else if (filter) {
			filter = filter.split(&#039;,&#039;).some(function (criteria) {
				criteria = closest(originalTarget, criteria.trim(), el, false);

				if (criteria) {
					_dispatchEvent({
						sortable: _this,
						rootEl: criteria,
						name: &#039;filter&#039;,
						targetEl: target,
						fromEl: el,
						toEl: el
					});
					pluginEvent(&#039;filter&#039;, _this, { evt });
					return true;
				}
			});

			if (filter) {
				preventOnFilter &amp;&amp; evt.preventDefault();
				return; // cancel dnd
			}
		}

		if (options.handle &amp;&amp; !closest(originalTarget, options.handle, el, false)) {
			return;
		}

		// Prepare `dragstart`
		this._prepareDragStart(evt, touch, target);
	},

	_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target) {
		let _this = this,
			el = _this.el,
			options = _this.options,
			ownerDocument = el.ownerDocument,
			dragStartFn;

		if (target &amp;&amp; !dragEl &amp;&amp; (target.parentNode === el)) {
			let dragRect = getRect(target);
			rootEl = el;
			dragEl = target;
			parentEl = dragEl.parentNode;
			nextEl = dragEl.nextSibling;
			lastDownEl = target;
			activeGroup = options.group;

			Sortable.dragged = dragEl;

			tapEvt = {
				target: dragEl,
				clientX: (touch || evt).clientX,
				clientY: (touch || evt).clientY
			};

			tapDistanceLeft = tapEvt.clientX - dragRect.left;
			tapDistanceTop = tapEvt.clientY - dragRect.top;

			this._lastX = (touch || evt).clientX;
			this._lastY = (touch || evt).clientY;

			dragEl.style[&#039;will-change&#039;] = &#039;all&#039;;

			dragStartFn = function () {
				pluginEvent(&#039;delayEnded&#039;, _this, { evt });
				if (Sortable.eventCanceled) {
					_this._onDrop();
					return;
				}
				// Delayed drag has been triggered
				// we can re-enable the events: touchmove/mousemove
				_this._disableDelayedDragEvents();

				if (!FireFox &amp;&amp; _this.nativeDraggable) {
					dragEl.draggable = true;
				}

				// Bind the events: dragstart/dragend
				_this._triggerDragStart(evt, touch);

				// Drag start event
				_dispatchEvent({
					sortable: _this,
					name: &#039;choose&#039;,
					originalEvent: evt
				});

				// Chosen item
				toggleClass(dragEl, options.chosenClass, true);
			};

			// Disable &quot;draggable&quot;
			options.ignore.split(&#039;,&#039;).forEach(function (criteria) {
				find(dragEl, criteria.trim(), _disableDraggable);
			});

			on(ownerDocument, &#039;dragover&#039;, nearestEmptyInsertDetectEvent);
			on(ownerDocument, &#039;mousemove&#039;, nearestEmptyInsertDetectEvent);
			on(ownerDocument, &#039;touchmove&#039;, nearestEmptyInsertDetectEvent);

			if (options.supportPointer) {
				on(ownerDocument, &#039;pointerup&#039;, _this._onDrop);
				// Native D&amp;D triggers pointercancel
				!this.nativeDraggable &amp;&amp; on(ownerDocument, &#039;pointercancel&#039;, _this._onDrop);
			} else {
				on(ownerDocument, &#039;mouseup&#039;, _this._onDrop);
				on(ownerDocument, &#039;touchend&#039;, _this._onDrop);
				on(ownerDocument, &#039;touchcancel&#039;, _this._onDrop);
			}

			// Make dragEl draggable (must be before delay for FireFox)
			if (FireFox &amp;&amp; this.nativeDraggable) {
				this.options.touchStartThreshold = 4;
				dragEl.draggable = true;
			}

			pluginEvent(&#039;delayStart&#039;, this, { evt });

			// Delay is impossible for native DnD in Edge or IE
			if (options.delay &amp;&amp; (!options.delayOnTouchOnly || touch) &amp;&amp; (!this.nativeDraggable || !(Edge || IE11OrLess))) {
				if (Sortable.eventCanceled) {
					this._onDrop();
					return;
				}
				// If the user moves the pointer or let go the click or touch
				// before the delay has been reached:
				// disable the delayed drag
				if (options.supportPointer) {
					on(ownerDocument, &#039;pointerup&#039;, _this._disableDelayedDrag);
					on(ownerDocument, &#039;pointercancel&#039;, _this._disableDelayedDrag);
				} else {
					on(ownerDocument, &#039;mouseup&#039;, _this._disableDelayedDrag);
					on(ownerDocument, &#039;touchend&#039;, _this._disableDelayedDrag);
					on(ownerDocument, &#039;touchcancel&#039;, _this._disableDelayedDrag);
				}
				on(ownerDocument, &#039;mousemove&#039;, _this._delayedDragTouchMoveHandler);
				on(ownerDocument, &#039;touchmove&#039;, _this._delayedDragTouchMoveHandler);
				options.supportPointer &amp;&amp; on(ownerDocument, &#039;pointermove&#039;, _this._delayedDragTouchMoveHandler);

				_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
			} else {
				dragStartFn();
			}
		}
	},

	_delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/e) {
		let touch = e.touches ? e.touches[0] : e;
		if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY))
				&gt;= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable &amp;&amp; window.devicePixelRatio || 1))
		) {
			this._disableDelayedDrag();
		}
	},

	_disableDelayedDrag: function () {
		dragEl &amp;&amp; _disableDraggable(dragEl);
		clearTimeout(this._dragStartTimer);

		this._disableDelayedDragEvents();
	},

	_disableDelayedDragEvents: function () {
		let ownerDocument = this.el.ownerDocument;
		off(ownerDocument, &#039;mouseup&#039;, this._disableDelayedDrag);
		off(ownerDocument, &#039;touchend&#039;, this._disableDelayedDrag);
		off(ownerDocument, &#039;touchcancel&#039;, this._disableDelayedDrag);
		off(ownerDocument, &#039;pointerup&#039;, this._disableDelayedDrag);
		off(ownerDocument, &#039;pointercancel&#039;, this._disableDelayedDrag);
		off(ownerDocument, &#039;mousemove&#039;, this._delayedDragTouchMoveHandler);
		off(ownerDocument, &#039;touchmove&#039;, this._delayedDragTouchMoveHandler);
		off(ownerDocument, &#039;pointermove&#039;, this._delayedDragTouchMoveHandler);
	},

	_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
		touch = touch || (evt.pointerType == &#039;touch&#039; &amp;&amp; evt);

		if (!this.nativeDraggable || touch) {
			if (this.options.supportPointer) {
				on(document, &#039;pointermove&#039;, this._onTouchMove);
			} else if (touch) {
				on(document, &#039;touchmove&#039;, this._onTouchMove);
			} else {
				on(document, &#039;mousemove&#039;, this._onTouchMove);
			}
		} else {
			on(dragEl, &#039;dragend&#039;, this);
			on(rootEl, &#039;dragstart&#039;, this._onDragStart);
		}

		try {
			
			if (document.selection) {
				_nextTick(() =&gt; {
					document.selection.empty();
				});
			} else {
				window.getSelection().removeAllRanges();
			}
		} catch (err) {
		}
	},

	_dragStarted: function (fallback, evt) {
		let _this = this;
		awaitingDragStarted = false;
		if (rootEl &amp;&amp; dragEl) {
			pluginEvent(&#039;dragStarted&#039;, this, { evt });

			if (this.nativeDraggable) {
				on(document, &#039;dragover&#039;, _checkOutsideTargetEl);
			}
			let options = this.options;

			// Apply effect
			!fallback &amp;&amp; toggleClass(dragEl, options.dragClass, false);
			toggleClass(dragEl, options.ghostClass, true);

			Sortable.active = this;

			fallback &amp;&amp; this._appendGhost();

			// Drag start event
			_dispatchEvent({
				sortable: this,
				name: &#039;start&#039;,
				originalEvent: evt
			});
		} else {
			this._nulling();
		}
	},

	_emulateDragOver: function () {
		if (touchEvt) {
			this._lastX = touchEvt.clientX;
			this._lastY = touchEvt.clientY;

			_hideGhostForTarget();

			let target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
			let parent = target;

			while (target &amp;&amp; target.shadowRoot) {
				target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
				if (target === parent) break;
				parent = target;
			}

			dragEl.parentNode[expando]._isOutsideThisEl(target);

			if (parent) {
				do {
					if (parent[expando]) {
						let inserted;

						inserted = parent[expando]._onDragOver({
							clientX: touchEvt.clientX,
							clientY: touchEvt.clientY,
							target: target,
							rootEl: parent
						});

						if (inserted &amp;&amp; !this.options.dragoverBubble) {
							break;
						}
					}

					target = parent; // store last element
				}
				/* jshint boss:true */
				while (parent = getParentOrHost(parent));
			}

			_unhideGhostForTarget();
		}
	},


	_onTouchMove: function (/**TouchEvent*/evt) {
		if (tapEvt) {
			let	options = this.options,
				fallbackTolerance = options.fallbackTolerance,
				fallbackOffset = options.fallbackOffset,
				touch = evt.touches ? evt.touches[0] : evt,
				ghostMatrix = ghostEl &amp;&amp; matrix(ghostEl, true),
				scaleX = ghostEl &amp;&amp; ghostMatrix &amp;&amp; ghostMatrix.a,
				scaleY = ghostEl &amp;&amp; ghostMatrix &amp;&amp; ghostMatrix.d,
				relativeScrollOffset = PositionGhostAbsolutely &amp;&amp; ghostRelativeParent &amp;&amp; getRelativeScrollOffset(ghostRelativeParent),
				dx = ((touch.clientX - tapEvt.clientX)
						+ fallbackOffset.x) / (scaleX || 1)
						+ (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),
				dy = ((touch.clientY - tapEvt.clientY)
						+ fallbackOffset.y) / (scaleY || 1)
						+ (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1);

			// only set the status to dragging, when we are actually dragging
			if (!Sortable.active &amp;&amp; !awaitingDragStarted) {
				if (fallbackTolerance &amp;&amp;
					Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) &lt; fallbackTolerance
				) {
					return;
				}
				this._onDragStart(evt, true);
			}

			if (ghostEl) {
				if (ghostMatrix) {
					ghostMatrix.e += dx - (lastDx || 0);
					ghostMatrix.f += dy - (lastDy || 0);
				} else {
					ghostMatrix = {
						a: 1,
						b: 0,
						c: 0,
						d: 1,
						e: dx,
						f: dy
					};
				}

				let cssMatrix = `matrix(${ghostMatrix.a},${ghostMatrix.b},${ghostMatrix.c},${ghostMatrix.d},${ghostMatrix.e},${ghostMatrix.f})`;

				css(ghostEl, &#039;webkitTransform&#039;, cssMatrix);
				css(ghostEl, &#039;mozTransform&#039;, cssMatrix);
				css(ghostEl, &#039;msTransform&#039;, cssMatrix);
				css(ghostEl, &#039;transform&#039;, cssMatrix);

				lastDx = dx;
				lastDy = dy;

				touchEvt = touch;
			}

			evt.cancelable &amp;&amp; evt.preventDefault();
		}
	},

	_appendGhost: function () {
		// Bug if using scale(): https://stackoverflow.com/questions/2637058
		// Not being adjusted for
		if (!ghostEl) {
			let container = this.options.fallbackOnBody ? document.body : rootEl,
				rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
				options = this.options;

			// Position absolutely
			if (PositionGhostAbsolutely) {
				// Get relatively positioned parent
				ghostRelativeParent = container;

				while (
					css(ghostRelativeParent, &#039;position&#039;) === &#039;static&#039; &amp;&amp;
					css(ghostRelativeParent, &#039;transform&#039;) === &#039;none&#039; &amp;&amp;
					ghostRelativeParent !== document
				) {
					ghostRelativeParent = ghostRelativeParent.parentNode;
				}

				if (ghostRelativeParent !== document.body &amp;&amp; ghostRelativeParent !== document.documentElement) {
					if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();

					rect.top += ghostRelativeParent.scrollTop;
					rect.left += ghostRelativeParent.scrollLeft;
				} else {
					ghostRelativeParent = getWindowScrollingElement();
				}
				ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
			}


			ghostEl = dragEl.cloneNode(true);

			toggleClass(ghostEl, options.ghostClass, false);
			toggleClass(ghostEl, options.fallbackClass, true);
			toggleClass(ghostEl, options.dragClass, true);

			css(ghostEl, &#039;transition&#039;, &#039;&#039;);
			css(ghostEl, &#039;transform&#039;, &#039;&#039;);

			css(ghostEl, &#039;box-sizing&#039;, &#039;border-box&#039;);
			css(ghostEl, &#039;margin&#039;, 0);
			css(ghostEl, &#039;top&#039;, rect.top);
			css(ghostEl, &#039;left&#039;, rect.left);
			css(ghostEl, &#039;width&#039;, rect.width);
			css(ghostEl, &#039;height&#039;, rect.height);
			css(ghostEl, &#039;opacity&#039;, &#039;0.8&#039;);
			css(ghostEl, &#039;position&#039;, (PositionGhostAbsolutely ? &#039;absolute&#039; : &#039;fixed&#039;));
			css(ghostEl, &#039;zIndex&#039;, &#039;100000&#039;);
			css(ghostEl, &#039;pointerEvents&#039;, &#039;none&#039;);


			Sortable.ghost = ghostEl;

			container.appendChild(ghostEl);

			// Set transform-origin
			css(ghostEl, &#039;transform-origin&#039;, (tapDistanceLeft / parseInt(ghostEl.style.width) * 100) + &#039;% &#039; + (tapDistanceTop / parseInt(ghostEl.style.height) * 100) + &#039;%&#039;);
		}
	},

	_onDragStart: function (/**Event*/evt, /**boolean*/fallback) {
		let _this = this;
		let dataTransfer = evt.dataTransfer;
		let options = _this.options;

		pluginEvent(&#039;dragStart&#039;, this, { evt });
		if (Sortable.eventCanceled) {
			this._onDrop();
			return;
		}

		pluginEvent(&#039;setupClone&#039;, this);
		if (!Sortable.eventCanceled) {
			cloneEl = clone(dragEl);
			cloneEl.removeAttribute(&quot;id&quot;);
			cloneEl.draggable = false;
			cloneEl.style[&#039;will-change&#039;] = &#039;&#039;;

			this._hideClone();

			toggleClass(cloneEl, this.options.chosenClass, false);
			Sortable.clone = cloneEl;
		}


		// #1143: IFrame support workaround
		_this.cloneId = _nextTick(function() {
			pluginEvent(&#039;clone&#039;, _this);
			if (Sortable.eventCanceled) return;

			if (!_this.options.removeCloneOnHide) {
				rootEl.insertBefore(cloneEl, dragEl);
			}
			_this._hideClone();

			_dispatchEvent({
				sortable: _this,
				name: &#039;clone&#039;
			});
		});


		!fallback &amp;&amp; toggleClass(dragEl, options.dragClass, true);

		// Set proper drop events
		if (fallback) {
			ignoreNextClick = true;
			_this._loopId = setInterval(_this._emulateDragOver, 50);
		} else {
			// Undo what was set in _prepareDragStart before drag started
			off(document, &#039;mouseup&#039;, _this._onDrop);
			off(document, &#039;touchend&#039;, _this._onDrop);
			off(document, &#039;touchcancel&#039;, _this._onDrop);

			if (dataTransfer) {
				dataTransfer.effectAllowed = &#039;move&#039;;
				options.setData &amp;&amp; options.setData.call(_this, dataTransfer, dragEl);
			}

			on(document, &#039;drop&#039;, _this);

			// #1276 fix:
			css(dragEl, &#039;transform&#039;, &#039;translateZ(0)&#039;);
		}

		awaitingDragStarted = true;

		_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
		on(document, &#039;selectstart&#039;, _this);

		moved = true;

		window.getSelection().removeAllRanges();

		if (Safari) {
			css(document.body, &#039;user-select&#039;, &#039;none&#039;);
		}
	},


	// Returns true - if no further action is needed (either inserted or another condition)
	_onDragOver: function (/**Event*/evt) {
		let el = this.el,
			target = evt.target,
			dragRect,
			targetRect,
			revert,
			options = this.options,
			group = options.group,
			activeSortable = Sortable.active,
			isOwner = (activeGroup === group),
			canSort = options.sort,
			fromSortable = (putSortable || activeSortable),
			vertical,
			_this = this,
			completedFired = false;

		if (_silent) return;

		function dragOverEvent(name, extra) {
			pluginEvent(name, _this, {
				evt,
				isOwner,
				axis: vertical ? &#039;vertical&#039; : &#039;horizontal&#039;,
				revert,
				dragRect,
				targetRect,
				canSort,
				fromSortable,
				target,
				completed,
				onMove(target, after) {
					return onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
				},
				changed,
				...extra
			});
		}

		// Capture animation state
		function capture() {
			dragOverEvent(&#039;dragOverAnimationCapture&#039;);

			_this.captureAnimationState();
			if (_this !== fromSortable) {
				fromSortable.captureAnimationState();
			}
		}

		// Return invocation when dragEl is inserted (or completed)
		function completed(insertion) {
			dragOverEvent(&#039;dragOverCompleted&#039;, { insertion });

			if (insertion) {
				// Clones must be hidden before folding animation to capture dragRectAbsolute properly
				if (isOwner) {
					activeSortable._hideClone();
				} else {
					activeSortable._showClone(_this);
				}

				if (_this !== fromSortable) {
					// Set ghost class to new sortable&#039;s ghost class
					toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
					toggleClass(dragEl, options.ghostClass, true);
				}

				if (putSortable !== _this &amp;&amp; _this !== Sortable.active) {
					putSortable = _this;
				} else if (_this === Sortable.active &amp;&amp; putSortable) {
					putSortable = null;
				}

				// Animation
				if (fromSortable === _this) {
					_this._ignoreWhileAnimating = target;
				}
				_this.animateAll(function() {
					dragOverEvent(&#039;dragOverAnimationComplete&#039;);
					_this._ignoreWhileAnimating = null;
				});
				if (_this !== fromSortable) {
					fromSortable.animateAll();
					fromSortable._ignoreWhileAnimating = null;
				}
			}


			// Null lastTarget if it is not inside a previously swapped element
			if ((target === dragEl &amp;&amp; !dragEl.animated) || (target === el &amp;&amp; !target.animated)) {
				lastTarget = null;
			}

			// no bubbling and not fallback
			if (!options.dragoverBubble &amp;&amp; !evt.rootEl &amp;&amp; target !== document) {
				dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

				// Do not detect for empty insert if already inserted
				!insertion &amp;&amp; nearestEmptyInsertDetectEvent(evt);
			}

			!options.dragoverBubble &amp;&amp; evt.stopPropagation &amp;&amp; evt.stopPropagation();

			return (completedFired = true);
		}

		// Call when dragEl has been inserted
		function changed() {
			newIndex = index(dragEl);
			newDraggableIndex = index(dragEl, options.draggable);
			_dispatchEvent({
				sortable: _this,
				name: &#039;change&#039;,
				toEl: el,
				newIndex,
				newDraggableIndex,
				originalEvent: evt
			});
		}


		if (evt.preventDefault !== void 0) {
			evt.cancelable &amp;&amp; evt.preventDefault();
		}


		target = closest(target, options.draggable, el, true);

		dragOverEvent(&#039;dragOver&#039;);
		if (Sortable.eventCanceled) return completedFired;

		if (
			dragEl.contains(evt.target) ||
			target.animated &amp;&amp; target.animatingX &amp;&amp; target.animatingY ||
			_this._ignoreWhileAnimating === target
		) {
			return completed(false);
		}

		ignoreNextClick = false;

		if (activeSortable &amp;&amp; !options.disabled &amp;&amp;
			(isOwner
				? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
				: (
					putSortable === this ||
					(
						(this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &amp;&amp;
						group.checkPut(this, activeSortable, dragEl, evt)
					)
				)
			)
		) {
			vertical = this._getDirection(evt, target) === &#039;vertical&#039;;

			dragRect = getRect(dragEl);

			dragOverEvent(&#039;dragOverValid&#039;);
			if (Sortable.eventCanceled) return completedFired;

			if (revert) {
				parentEl = rootEl; // actualization
				capture();

				this._hideClone();

				dragOverEvent(&#039;revert&#039;);

				if (!Sortable.eventCanceled) {
					if (nextEl) {
						rootEl.insertBefore(dragEl, nextEl);
					} else {
						rootEl.appendChild(dragEl);
					}
				}

				return completed(true);
			}

			let elLastChild = lastChild(el, options.draggable);

			if (!elLastChild || _ghostIsLast(evt, vertical, this) &amp;&amp; !elLastChild.animated) {
				// Insert to end of list

				// If already at end of list: Do not insert
				if (elLastChild === dragEl) {
					return completed(false);
				}

				// if there is a last element, it is the target
				if (elLastChild &amp;&amp; el === evt.target) {
					target = elLastChild;
				}

				if (target) {
					targetRect = getRect(target);
				}

				if (onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
					capture();
					if (elLastChild &amp;&amp; elLastChild.nextSibling) { // the last draggable element is not the last node
						el.insertBefore(dragEl, elLastChild.nextSibling);
					}
					else {
						el.appendChild(dragEl);
					}
					parentEl = el; // actualization

					changed();
					return completed(true);
				}
			}
			else if (elLastChild &amp;&amp; _ghostIsFirst(evt, vertical, this)) {
				// Insert to start of list
				let firstChild = getChild(el, 0, options, true);
				if (firstChild === dragEl) {
					return completed(false);
				}
				target = firstChild;
				targetRect = getRect(target);

				if (onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
					capture();
					el.insertBefore(dragEl, firstChild);
					parentEl = el; // actualization

					changed();
					return completed(true);
				}
			}
			else if (target.parentNode === el) {
				targetRect = getRect(target);
				let direction = 0,
					targetBeforeFirstSwap,
					differentLevel = dragEl.parentNode !== el,
					differentRowCol = !_dragElInRowColumn(dragEl.animated &amp;&amp; dragEl.toRect || dragRect, target.animated &amp;&amp; target.toRect || targetRect, vertical),
					side1 = vertical ? &#039;top&#039; : &#039;left&#039;,
					scrolledPastTop = isScrolledPast(target, &#039;top&#039;, &#039;top&#039;) || isScrolledPast(dragEl, &#039;top&#039;, &#039;top&#039;),
					scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;


				if (lastTarget !== target) {
					targetBeforeFirstSwap = targetRect[side1];
					pastFirstInvertThresh = false;
					isCircumstantialInvert = (!differentRowCol &amp;&amp; options.invertSwap) || differentLevel;
				}

				direction = _getSwapDirection(
					evt, target, targetRect, vertical,
					differentRowCol ? 1 : options.swapThreshold,
					options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,
					isCircumstantialInvert,
					lastTarget === target
				);

				let sibling;

				if (direction !== 0) {
					// Check if target is beside dragEl in respective direction (ignoring hidden elements)
					let dragIndex = index(dragEl);

					do {
						dragIndex -= direction;
						sibling = parentEl.children[dragIndex];
					} while (sibling &amp;&amp; (css(sibling, &#039;display&#039;) === &#039;none&#039; || sibling === ghostEl));
				}
				// If dragEl is already beside target: Do not insert
				if (
					direction === 0 ||
					sibling === target
				) {
					return completed(false);
				}

				lastTarget = target;

				lastDirection = direction;

				let nextSibling = target.nextElementSibling,
					after = false;

				after = direction === 1;

				let moveVector = onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

				if (moveVector !== false) {
					if (moveVector === 1 || moveVector === -1) {
						after = (moveVector === 1);
					}

					_silent = true;
					setTimeout(_unsilent, 30);

					capture();

					if (after &amp;&amp; !nextSibling) {
						el.appendChild(dragEl);
					} else {
						target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
					}

					// Undo chrome&#039;s scroll adjustment (has no effect on other browsers)
					if (scrolledPastTop) {
						scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
					}

					parentEl = dragEl.parentNode; // actualization

					// must be done before animation
					if (targetBeforeFirstSwap !== undefined &amp;&amp; !isCircumstantialInvert) {
						targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
					}
					changed();

					return completed(true);
				}
			}

			if (el.contains(dragEl)) {
				return completed(false);
			}
		}

		return false;
	},

	_ignoreWhileAnimating: null,

	_offMoveEvents: function() {
		off(document, &#039;mousemove&#039;, this._onTouchMove);
		off(document, &#039;touchmove&#039;, this._onTouchMove);
		off(document, &#039;pointermove&#039;, this._onTouchMove);
		off(document, &#039;dragover&#039;, nearestEmptyInsertDetectEvent);
		off(document, &#039;mousemove&#039;, nearestEmptyInsertDetectEvent);
		off(document, &#039;touchmove&#039;, nearestEmptyInsertDetectEvent);
	},

	_offUpEvents: function () {
		let ownerDocument = this.el.ownerDocument;

		off(ownerDocument, &#039;mouseup&#039;, this._onDrop);
		off(ownerDocument, &#039;touchend&#039;, this._onDrop);
		off(ownerDocument, &#039;pointerup&#039;, this._onDrop);
		off(ownerDocument, &#039;pointercancel&#039;, this._onDrop);
		off(ownerDocument, &#039;touchcancel&#039;, this._onDrop);
		off(document, &#039;selectstart&#039;, this);
	},

	_onDrop: function (/**Event*/evt) {
		let el = this.el,
			options = this.options;

		// Get the index of the dragged element within its parent
		newIndex = index(dragEl);
		newDraggableIndex = index(dragEl, options.draggable);

		pluginEvent(&#039;drop&#039;, this, {
			evt
		});

		parentEl = dragEl &amp;&amp; dragEl.parentNode;

		// Get again after plugin event
		newIndex = index(dragEl);
		newDraggableIndex = index(dragEl, options.draggable);

		if (Sortable.eventCanceled) {
			this._nulling();
			return;
		}

		awaitingDragStarted = false;
		isCircumstantialInvert = false;
		pastFirstInvertThresh = false;

		clearInterval(this._loopId);

		clearTimeout(this._dragStartTimer);

		_cancelNextTick(this.cloneId);
		_cancelNextTick(this._dragStartId);

		// Unbind events
		if (this.nativeDraggable) {
			off(document, &#039;drop&#039;, this);
			off(el, &#039;dragstart&#039;, this._onDragStart);
		}
		this._offMoveEvents();
		this._offUpEvents();


		if (Safari) {
			css(document.body, &#039;user-select&#039;, &#039;&#039;);
		}

		css(dragEl, &#039;transform&#039;, &#039;&#039;);

		if (evt) {
			if (moved) {
				evt.cancelable &amp;&amp; evt.preventDefault();
				!options.dropBubble &amp;&amp; evt.stopPropagation();
			}

			ghostEl &amp;&amp; ghostEl.parentNode &amp;&amp; ghostEl.parentNode.removeChild(ghostEl);

			if (rootEl === parentEl || (putSortable &amp;&amp; putSortable.lastPutMode !== &#039;clone&#039;)) {
				// Remove clone(s)
				cloneEl &amp;&amp; cloneEl.parentNode &amp;&amp; cloneEl.parentNode.removeChild(cloneEl);
			}

			if (dragEl) {
				if (this.nativeDraggable) {
					off(dragEl, &#039;dragend&#039;, this);
				}

				_disableDraggable(dragEl);
				dragEl.style[&#039;will-change&#039;] = &#039;&#039;;

				// Remove classes
				// ghostClass is added in dragStarted
				if (moved &amp;&amp; !awaitingDragStarted) {
					toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
				}
				toggleClass(dragEl, this.options.chosenClass, false);

				// Drag stop event
				_dispatchEvent({
					sortable: this,
					name: &#039;unchoose&#039;,
					toEl: parentEl,
					newIndex: null,
					newDraggableIndex: null,
					originalEvent: evt
				});


				if (rootEl !== parentEl) {

					if (newIndex &gt;= 0) {
						// Add event
						_dispatchEvent({
							rootEl: parentEl,
							name: &#039;add&#039;,
							toEl: parentEl,
							fromEl: rootEl,
							originalEvent: evt
						});

						// Remove event
						_dispatchEvent({
							sortable: this,
							name: &#039;remove&#039;,
							toEl: parentEl,
							originalEvent: evt
						});

						// drag from one list and drop into another
						_dispatchEvent({
							rootEl: parentEl,
							name: &#039;sort&#039;,
							toEl: parentEl,
							fromEl: rootEl,
							originalEvent: evt
						});

						_dispatchEvent({
							sortable: this,
							name: &#039;sort&#039;,
							toEl: parentEl,
							originalEvent: evt
						});
					}

					putSortable &amp;&amp; putSortable.save();
				} else {
					if (newIndex !== oldIndex) {
						if (newIndex &gt;= 0) {
							// drag &amp; drop within the same list
							_dispatchEvent({
								sortable: this,
								name: &#039;update&#039;,
								toEl: parentEl,
								originalEvent: evt
							});

							_dispatchEvent({
								sortable: this,
								name: &#039;sort&#039;,
								toEl: parentEl,
								originalEvent: evt
							});
						}
					}
				}

				if (Sortable.active) {
					/* jshint eqnull:true */
					if (newIndex == null || newIndex === -1) {
						newIndex = oldIndex;
						newDraggableIndex = oldDraggableIndex;
					}

					_dispatchEvent({
						sortable: this,
						name: &#039;end&#039;,
						toEl: parentEl,
						originalEvent: evt
					});

					// Save sorting
					this.save();
				}
			}

		}
		this._nulling();
	},

	_nulling: function() {
		pluginEvent(&#039;nulling&#039;, this);

		rootEl =
		dragEl =
		parentEl =
		ghostEl =
		nextEl =
		cloneEl =
		lastDownEl =
		cloneHidden =

		tapEvt =
		touchEvt =

		moved =
		newIndex =
		newDraggableIndex =
		oldIndex =
		oldDraggableIndex =

		lastTarget =
		lastDirection =

		putSortable =
		activeGroup =
		Sortable.dragged =
		Sortable.ghost =
		Sortable.clone =
		Sortable.active = null;

		savedInputChecked.forEach(function (el) {
			el.checked = true;
		});

		savedInputChecked.length =
		lastDx =
		lastDy = 0;
	},

	handleEvent: function (/**Event*/evt) {
		switch (evt.type) {
			case &#039;drop&#039;:
			case &#039;dragend&#039;:
				this._onDrop(evt);
				break;

			case &#039;dragenter&#039;:
			case &#039;dragover&#039;:
				if (dragEl) {
					this._onDragOver(evt);
					_globalDragOver(evt);
				}
				break;

			case &#039;selectstart&#039;:
				evt.preventDefault();
				break;
		}
	},


	/**
	 * Serializes the item into an array of string.
	 * @returns {String[]}
	 */
	toArray: function () {
		let order = [],
			el,
			children = this.el.children,
			i = 0,
			n = children.length,
			options = this.options;

		for (; i &lt; n; i++) {
			el = children[i];
			if (closest(el, options.draggable, this.el, false)) {
				order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
			}
		}

		return order;
	},


	/**
	 * Sorts the elements according to the array.
	 * @param  {String[]}  order  order of the items
	 */
	sort: function (order, useAnimation) {
		let items = {}, rootEl = this.el;

		this.toArray().forEach(function (id, i) {
			let el = rootEl.children[i];

			if (closest(el, this.options.draggable, rootEl, false)) {
				items[id] = el;
			}
		}, this);

		useAnimation &amp;&amp; this.captureAnimationState();
		order.forEach(function (id) {
			if (items[id]) {
				rootEl.removeChild(items[id]);
				rootEl.appendChild(items[id]);
			}
		});
		useAnimation &amp;&amp; this.animateAll();
	},


	/**
	 * Save the current sorting
	 */
	save: function () {
		let store = this.options.store;
		store &amp;&amp; store.set &amp;&amp; store.set(this);
	},


	/**
	 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
	 * @param   {HTMLElement}  el
	 * @param   {String}       [selector]  default: `options.draggable`
	 * @returns {HTMLElement|null}
	 */
	closest: function (el, selector) {
		return closest(el, selector || this.options.draggable, this.el, false);
	},


	/**
	 * Set/get option
	 * @param   {string} name
	 * @param   {*}      [value]
	 * @returns {*}
	 */
	option: function (name, value) {
		let options = this.options;

		if (value === void 0) {
			return options[name];
		} else {
			let modifiedValue = PluginManager.modifyOption(this, name, value);
			if (typeof modifiedValue !== &#039;undefined&#039;) {
				options[name] = modifiedValue;
			} else {
				options[name] = value;
			}

			if (name === &#039;group&#039;) {
				_prepareGroup(options);
			}
		}
	},


	/**
	 * Destroy
	 */
	destroy: function () {
		pluginEvent(&#039;destroy&#039;, this);
		let el = this.el;

		el[expando] = null;

		off(el, &#039;mousedown&#039;, this._onTapStart);
		off(el, &#039;touchstart&#039;, this._onTapStart);
		off(el, &#039;pointerdown&#039;, this._onTapStart);

		if (this.nativeDraggable) {
			off(el, &#039;dragover&#039;, this);
			off(el, &#039;dragenter&#039;, this);
		}
		// Remove draggable attributes
		Array.prototype.forEach.call(el.querySelectorAll(&#039;[draggable]&#039;), function (el) {
			el.removeAttribute(&#039;draggable&#039;);
		});

		this._onDrop();

		this._disableDelayedDragEvents();

		sortables.splice(sortables.indexOf(this.el), 1);

		this.el = el = null;
	},

	_hideClone: function() {
		if (!cloneHidden) {
			pluginEvent(&#039;hideClone&#039;, this);
			if (Sortable.eventCanceled) return;


			css(cloneEl, &#039;display&#039;, &#039;none&#039;);
			if (this.options.removeCloneOnHide &amp;&amp; cloneEl.parentNode) {
				cloneEl.parentNode.removeChild(cloneEl);
			}
			cloneHidden = true;
		}
	},

	_showClone: function(putSortable) {
		if (putSortable.lastPutMode !== &#039;clone&#039;) {
			this._hideClone();
			return;
		}


		if (cloneHidden) {
			pluginEvent(&#039;showClone&#039;, this);
			if (Sortable.eventCanceled) return;

			// show clone at dragEl or original position
			if (dragEl.parentNode == rootEl &amp;&amp; !this.options.group.revertClone) {
				rootEl.insertBefore(cloneEl, dragEl);
			} else if (nextEl) {
				rootEl.insertBefore(cloneEl, nextEl);
			} else {
				rootEl.appendChild(cloneEl);
			}

			if (this.options.group.revertClone) {
				this.animate(dragEl, cloneEl);
			}

			css(cloneEl, &#039;display&#039;, &#039;&#039;);
			cloneHidden = false;
		}
	}
};

function _globalDragOver(/**Event*/evt) {
	if (evt.dataTransfer) {
		evt.dataTransfer.dropEffect = &#039;move&#039;;
	}
	evt.cancelable &amp;&amp; evt.preventDefault();
}

function onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
	let evt,
		sortable = fromEl[expando],
		onMoveFn = sortable.options.onMove,
		retVal;
	// Support for new CustomEvent feature
	if (window.CustomEvent &amp;&amp; !IE11OrLess &amp;&amp; !Edge) {
		evt = new CustomEvent(&#039;move&#039;, {
			bubbles: true,
			cancelable: true
		});
	} else {
		evt = document.createEvent(&#039;Event&#039;);
		evt.initEvent(&#039;move&#039;, true, true);
	}

	evt.to = toEl;
	evt.from = fromEl;
	evt.dragged = dragEl;
	evt.draggedRect = dragRect;
	evt.related = targetEl || toEl;
	evt.relatedRect = targetRect || getRect(toEl);
	evt.willInsertAfter = willInsertAfter;

	evt.originalEvent = originalEvent;

	fromEl.dispatchEvent(evt);

	if (onMoveFn) {
		retVal = onMoveFn.call(sortable, evt, originalEvent);
	}

	return retVal;
}

function _disableDraggable(el) {
	el.draggable = false;
}

function _unsilent() {
	_silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
	let firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
	const childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
	const spacer = 10;

	return vertical ?
		(evt.clientX &lt; childContainingRect.left - spacer || evt.clientY &lt; firstElRect.top &amp;&amp; evt.clientX &lt; firstElRect.right) :
		(evt.clientY &lt; childContainingRect.top - spacer || evt.clientY &lt; firstElRect.bottom &amp;&amp; evt.clientX &lt; firstElRect.left)
}

function _ghostIsLast(evt, vertical, sortable) {
	const lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
	const childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
	const spacer = 10;

	return vertical ?
		(evt.clientX &gt; childContainingRect.right + spacer || evt.clientY &gt; lastElRect.bottom &amp;&amp; evt.clientX &gt; lastElRect.left) :
		(evt.clientY &gt; childContainingRect.bottom + spacer || evt.clientX &gt; lastElRect.right &amp;&amp; evt.clientY &gt; lastElRect.top);
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
	let mouseOnAxis = vertical ? evt.clientY : evt.clientX,
		targetLength = vertical ? targetRect.height : targetRect.width,
		targetS1 = vertical ? targetRect.top : targetRect.left,
		targetS2 = vertical ? targetRect.bottom : targetRect.right,
		invert = false;


	if (!invertSwap) {
		// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
		if (isLastTarget &amp;&amp; targetMoveDistance &lt; targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
			// check if past first invert threshold on side opposite of lastDirection
			if (!pastFirstInvertThresh &amp;&amp;
				(lastDirection === 1 ?
					(
						mouseOnAxis &gt; targetS1 + targetLength * invertedSwapThreshold / 2
					) :
					(
						mouseOnAxis &lt; targetS2 - targetLength * invertedSwapThreshold / 2
					)
				)
			)
			{
				// past first invert threshold, do not restrict inverted threshold to dragEl shadow
				pastFirstInvertThresh = true;
			}

			if (!pastFirstInvertThresh) {
				// dragEl shadow (target move distance shadow)
				if (
					lastDirection === 1 ?
					(
						mouseOnAxis &lt; targetS1 + targetMoveDistance // over dragEl shadow
					) :
					(
						mouseOnAxis &gt; targetS2 - targetMoveDistance
					)
				)
				{
					return -lastDirection;
				}
			} else {
				invert = true;
			}
		} else {
			// Regular
			if (
				mouseOnAxis &gt; targetS1 + (targetLength * (1 - swapThreshold) / 2) &amp;&amp;
				mouseOnAxis &lt; targetS2 - (targetLength * (1 - swapThreshold) / 2)
			) {
				return _getInsertDirection(target);
			}
		}
	}

	invert = invert || invertSwap;

	if (invert) {
		// Invert of regular
		if (
			mouseOnAxis &lt; targetS1 + (targetLength * invertedSwapThreshold / 2) ||
			mouseOnAxis &gt; targetS2 - (targetLength * invertedSwapThreshold / 2)
		)
		{
			return ((mouseOnAxis &gt; targetS1 + targetLength / 2) ? 1 : -1);
		}
	}

	return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been &quot;inserted&quot; into that element&#039;s position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
	if (index(dragEl) &lt; index(target)) {
		return 1;
	} else {
		return -1;
	}
}


/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
	let str = el.tagName + el.className + el.src + el.href + el.textContent,
		i = str.length,
		sum = 0;

	while (i--) {
		sum += str.charCodeAt(i);
	}

	return sum.toString(36);
}

function _saveInputCheckedState(root) {
	savedInputChecked.length = 0;

	let inputs = root.getElementsByTagName(&#039;input&#039;);
	let idx = inputs.length;

	while (idx--) {
		let el = inputs[idx];
		el.checked &amp;&amp; savedInputChecked.push(el);
	}
}

function _nextTick(fn) {
	return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
	return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
	on(document, &#039;touchmove&#039;, function(evt) {
		if ((Sortable.active || awaitingDragStarted) &amp;&amp; evt.cancelable) {
			evt.preventDefault();
		}
	});
}


// Export utils
Sortable.utils = {
	on,
	off,
	css,
	find,
	is: function (el, selector) {
		return !!closest(el, selector, el, false);
	},
	extend,
	throttle,
	closest,
	toggleClass,
	clone,
	index,
	nextTick: _nextTick,
	cancelNextTick: _cancelNextTick,
	detectDirection: _detectDirection,
	getChild,
	expando
};


/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function(element) {
	return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function(...plugins) {
	if (plugins[0].constructor === Array) plugins = plugins[0];

	plugins.forEach((plugin) =&gt; {
		if (!plugin.prototype || !plugin.prototype.constructor) {
			throw `Sortable: Mounted plugin must be a constructor function, not ${ {}.toString.call(plugin) }`;
		}
		if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };

		PluginManager.mount(plugin);
	});
};



/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
	return new Sortable(el, options);
};


// Export
Sortable.version = version;


export default Sortable;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
