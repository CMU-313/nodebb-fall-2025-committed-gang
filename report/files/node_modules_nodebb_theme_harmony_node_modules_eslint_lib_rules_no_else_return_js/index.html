<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-else-return.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/no-else-return.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">451</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">40.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to flag `else` after a `return` in `if`
 * @author Ian Christian Myers
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);
const FixTracker = require(&quot;./utils/fix-tracker&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		defaultOptions: [{ allowElseIf: true }],

		docs: {
			description:
				&quot;Disallow `else` blocks after `return` statements in `if` statements&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/no-else-return&quot;,
		},

		schema: [
			{
				type: &quot;object&quot;,
				properties: {
					allowElseIf: {
						type: &quot;boolean&quot;,
					},
				},
				additionalProperties: false,
			},
		],

		fixable: &quot;code&quot;,

		messages: {
			unexpected: &quot;Unnecessary &#039;else&#039; after &#039;return&#039;.&quot;,
		},
	},

	create(context) {
		const [{ allowElseIf }] = context.options;
		const sourceCode = context.sourceCode;

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		/**
		 * Checks whether the given names can be safely used to declare block-scoped variables
		 * in the given scope. Name collisions can produce redeclaration syntax errors,
		 * or silently change references and modify behavior of the original code.
		 *
		 * This is not a generic function. In particular, it is assumed that the scope is a function scope or
		 * a function&#039;s inner scope, and that the names can be valid identifiers in the given scope.
		 * @param {string[]} names Array of variable names.
		 * @param {eslint-scope.Scope} scope Function scope or a function&#039;s inner scope.
		 * @returns {boolean} True if all names can be safely declared, false otherwise.
		 */
		function isSafeToDeclare(names, scope) {
			if (names.length === 0) {
				return true;
			}

			const functionScope = scope.variableScope;

			/*
			 * If this is a function scope, scope.variables will contain parameters, implicit variables such as &quot;arguments&quot;,
			 * all function-scoped variables (&#039;var&#039;), and block-scoped variables defined in the scope.
			 * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.
			 *
			 * Redeclaring any of these would cause a syntax error, except for the implicit variables.
			 */
			const declaredVariables = scope.variables.filter(
				({ defs }) =&gt; defs.length &gt; 0,
			);

			if (declaredVariables.some(({ name }) =&gt; names.includes(name))) {
				return false;
			}

			// Redeclaring a catch variable would also cause a syntax error.
			if (scope !== functionScope &amp;&amp; scope.upper.type === &quot;catch&quot;) {
				if (
					scope.upper.variables.some(({ name }) =&gt;
						names.includes(name),
					)
				) {
					return false;
				}
			}

			/*
			 * Redeclaring an implicit variable, such as &quot;arguments&quot;, would not cause a syntax error.
			 * However, if the variable was used, declaring a new one with the same name would change references
			 * and modify behavior.
			 */
			const usedImplicitVariables = scope.variables.filter(
				({ defs, references }) =&gt;
					defs.length === 0 &amp;&amp; references.length &gt; 0,
			);

			if (
				usedImplicitVariables.some(({ name }) =&gt; names.includes(name))
			) {
				return false;
			}

			/*
			 * Declaring a variable with a name that was already used to reference a variable from an upper scope
			 * would change references and modify behavior.
			 */
			if (scope.through.some(t =&gt; names.includes(t.identifier.name))) {
				return false;
			}

			/*
			 * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside
			 * the scope node (directly or in one of its descendants) is neither declared nor &#039;through&#039; in the scope.
			 *
			 * For example, this would be a syntax error &quot;Identifier &#039;a&#039; has already been declared&quot;:
			 * function foo() { if (bar) { let a; if (baz) { var a; } } }
			 */
			if (scope !== functionScope) {
				const scopeNodeRange = scope.block.range;
				const variablesToCheck = functionScope.variables.filter(
					({ name }) =&gt; names.includes(name),
				);

				if (
					variablesToCheck.some(v =&gt;
						v.defs.some(
							({ node: { range } }) =&gt;
								scopeNodeRange[0] &lt;= range[0] &amp;&amp;
								range[1] &lt;= scopeNodeRange[1],
						),
					)
				) {
					return false;
				}
			}

			return true;
		}

		/**
		 * Checks whether the removal of `else` and its braces is safe from variable name collisions.
		 * @param {Node} node The &#039;else&#039; node.
		 * @param {eslint-scope.Scope} scope The scope in which the node and the whole &#039;if&#039; statement is.
		 * @returns {boolean} True if it is safe, false otherwise.
		 */
		function isSafeFromNameCollisions(node, scope) {
			if (node.type === &quot;FunctionDeclaration&quot;) {
				// Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.
				return false;
			}

			if (node.type !== &quot;BlockStatement&quot;) {
				return true;
			}

			const elseBlockScope = scope.childScopes.find(
				({ block }) =&gt; block === node,
			);

			if (!elseBlockScope) {
				// ecmaVersion &lt; 6, `else` block statement cannot have its own scope, no possible collisions.
				return true;
			}

			/*
			 * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains
			 * only block-scoped variables (such as let and const variables or class and function declarations)
			 * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.
			 */
			const namesToCheck = elseBlockScope.variables.map(
				({ name }) =&gt; name,
			);

			return isSafeToDeclare(namesToCheck, scope);
		}

		/**
		 * Display the context report if rule is violated
		 * @param {Node} elseNode The &#039;else&#039; node
		 * @returns {void}
		 */
		function displayReport(elseNode) {
			const currentScope = sourceCode.getScope(elseNode.parent);

			context.report({
				node: elseNode,
				messageId: &quot;unexpected&quot;,
				fix(fixer) {
					if (!isSafeFromNameCollisions(elseNode, currentScope)) {
						return null;
					}

					const startToken = sourceCode.getFirstToken(elseNode);
					const elseToken = sourceCode.getTokenBefore(startToken);
					const source = sourceCode.getText(elseNode);
					const lastIfToken = sourceCode.getTokenBefore(elseToken);
					let fixedSource, firstTokenOfElseBlock;

					if (
						startToken.type === &quot;Punctuator&quot; &amp;&amp;
						startToken.value === &quot;{&quot;
					) {
						firstTokenOfElseBlock =
							sourceCode.getTokenAfter(startToken);
					} else {
						firstTokenOfElseBlock = startToken;
					}

					/*
					 * If the if block does not have curly braces and does not end in a semicolon
					 * and the else block starts with (, [, /, +, ` or -, then it is not
					 * safe to remove the else keyword, because ASI will not add a semicolon
					 * after the if block
					 */
					const ifBlockMaybeUnsafe =
						elseNode.parent.consequent.type !== &quot;BlockStatement&quot; &amp;&amp;
						lastIfToken.value !== &quot;;&quot;;
					const elseBlockUnsafe = /^[([/+`-]/u.test(
						firstTokenOfElseBlock.value,
					);

					if (ifBlockMaybeUnsafe &amp;&amp; elseBlockUnsafe) {
						return null;
					}

					const endToken = sourceCode.getLastToken(elseNode);
					const lastTokenOfElseBlock =
						sourceCode.getTokenBefore(endToken);

					if (lastTokenOfElseBlock.value !== &quot;;&quot;) {
						const nextToken = sourceCode.getTokenAfter(endToken);

						const nextTokenUnsafe =
							nextToken &amp;&amp; /^[([/+`-]/u.test(nextToken.value);
						const nextTokenOnSameLine =
							nextToken &amp;&amp;
							nextToken.loc.start.line ===
								lastTokenOfElseBlock.loc.start.line;

						/*
						 * If the else block contents does not end in a semicolon,
						 * and the else block starts with (, [, /, +, ` or -, then it is not
						 * safe to remove the else block, because ASI will not add a semicolon
						 * after the remaining else block contents
						 */
						if (
							nextTokenUnsafe ||
							(nextTokenOnSameLine &amp;&amp; nextToken.value !== &quot;}&quot;)
						) {
							return null;
						}
					}

					if (
						startToken.type === &quot;Punctuator&quot; &amp;&amp;
						startToken.value === &quot;{&quot;
					) {
						fixedSource = source.slice(1, -1);
					} else {
						fixedSource = source;
					}

					/*
					 * Extend the replacement range to include the entire
					 * function to avoid conflicting with no-useless-return.
					 * https://github.com/eslint/eslint/issues/8026
					 *
					 * Also, to avoid name collisions between two else blocks.
					 */
					return new FixTracker(fixer, sourceCode)
						.retainEnclosingFunction(elseNode)
						.replaceTextRange(
							[elseToken.range[0], elseNode.range[1]],
							fixedSource,
						);
				},
			});
		}

		/**
		 * Check to see if the node is a ReturnStatement
		 * @param {Node} node The node being evaluated
		 * @returns {boolean} True if node is a return
		 */
		function checkForReturn(node) {
			return node.type === &quot;ReturnStatement&quot;;
		}

		/**
		 * Naive return checking, does not iterate through the whole
		 * BlockStatement because we make the assumption that the ReturnStatement
		 * will be the last node in the body of the BlockStatement.
		 * @param {Node} node The consequent/alternate node
		 * @returns {boolean} True if it has a return
		 */
		function naiveHasReturn(node) {
			if (node.type === &quot;BlockStatement&quot;) {
				const body = node.body,
					lastChildNode = body.at(-1);

				return lastChildNode &amp;&amp; checkForReturn(lastChildNode);
			}
			return checkForReturn(node);
		}

		/**
		 * Check to see if the node is valid for evaluation,
		 * meaning it has an else.
		 * @param {Node} node The node being evaluated
		 * @returns {boolean} True if the node is valid
		 */
		function hasElse(node) {
			return node.alternate &amp;&amp; node.consequent;
		}

		/**
		 * If the consequent is an IfStatement, check to see if it has an else
		 * and both its consequent and alternate path return, meaning this is
		 * a nested case of rule violation.  If-Else not considered currently.
		 * @param {Node} node The consequent node
		 * @returns {boolean} True if this is a nested rule violation
		 */
		function checkForIf(node) {
			return (
				node.type === &quot;IfStatement&quot; &amp;&amp;
				hasElse(node) &amp;&amp;
				naiveHasReturn(node.alternate) &amp;&amp;
				naiveHasReturn(node.consequent)
			);
		}

		/**
		 * Check the consequent/body node to make sure it is not
		 * a ReturnStatement or an IfStatement that returns on both
		 * code paths.
		 * @param {Node} node The consequent or body node
		 * @returns {boolean} `true` if it is a Return/If node that always returns.
		 */
		function checkForReturnOrIf(node) {
			return checkForReturn(node) || checkForIf(node);
		}

		/**
		 * Check whether a node returns in every codepath.
		 * @param {Node} node The node to be checked
		 * @returns {boolean} `true` if it returns on every codepath.
		 */
		function alwaysReturns(node) {
			if (node.type === &quot;BlockStatement&quot;) {
				// If we have a BlockStatement, check each consequent body node.
				return node.body.some(checkForReturnOrIf);
			}

			/*
			 * If not a block statement, make sure the consequent isn&#039;t a
			 * ReturnStatement or an IfStatement with returns on both paths.
			 */
			return checkForReturnOrIf(node);
		}

		/**
		 * Check the if statement, but don&#039;t catch else-if blocks.
		 * @returns {void}
		 * @param {Node} node The node for the if statement to check
		 * @private
		 */
		function checkIfWithoutElse(node) {
			const parent = node.parent;

			/*
			 * Fixing this would require splitting one statement into two, so no error should
			 * be reported if this node is in a position where only one statement is allowed.
			 */
			if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
				return;
			}

			const consequents = [];
			let alternate;

			for (
				let currentNode = node;
				currentNode.type === &quot;IfStatement&quot;;
				currentNode = currentNode.alternate
			) {
				if (!currentNode.alternate) {
					return;
				}
				consequents.push(currentNode.consequent);
				alternate = currentNode.alternate;
			}

			if (consequents.every(alwaysReturns)) {
				displayReport(alternate);
			}
		}

		/**
		 * Check the if statement
		 * @returns {void}
		 * @param {Node} node The node for the if statement to check
		 * @private
		 */
		function checkIfWithElse(node) {
			const parent = node.parent;

			/*
			 * Fixing this would require splitting one statement into two, so no error should
			 * be reported if this node is in a position where only one statement is allowed.
			 */
			if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
				return;
			}

			const alternate = node.alternate;

			if (alternate &amp;&amp; alwaysReturns(node.consequent)) {
				displayReport(alternate);
			}
		}

		//--------------------------------------------------------------------------
		// Public API
		//--------------------------------------------------------------------------

		return {
			&quot;IfStatement:exit&quot;: allowElseIf
				? checkIfWithoutElse
				: checkIfWithElse,
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
