<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/serialization/ObjectMiddleware.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/serialization/ObjectMiddleware.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.49</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">840</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">99.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.66</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

&quot;use strict&quot;;

const { DEFAULTS } = require(&quot;../config/defaults&quot;);
const createHash = require(&quot;../util/createHash&quot;);
const AggregateErrorSerializer = require(&quot;./AggregateErrorSerializer&quot;);
const ArraySerializer = require(&quot;./ArraySerializer&quot;);
const DateObjectSerializer = require(&quot;./DateObjectSerializer&quot;);
const ErrorObjectSerializer = require(&quot;./ErrorObjectSerializer&quot;);
const MapObjectSerializer = require(&quot;./MapObjectSerializer&quot;);
const NullPrototypeObjectSerializer = require(&quot;./NullPrototypeObjectSerializer&quot;);
const PlainObjectSerializer = require(&quot;./PlainObjectSerializer&quot;);
const RegExpObjectSerializer = require(&quot;./RegExpObjectSerializer&quot;);
const SerializerMiddleware = require(&quot;./SerializerMiddleware&quot;);
const SetObjectSerializer = require(&quot;./SetObjectSerializer&quot;);

/** @typedef {import(&quot;../logging/Logger&quot;).Logger} Logger */
/** @typedef {typeof import(&quot;../util/Hash&quot;)} Hash */
/** @typedef {import(&quot;./SerializerMiddleware&quot;).LazyOptions} LazyOptions */
/** @typedef {import(&quot;./types&quot;).ComplexSerializableType} ComplexSerializableType */
/** @typedef {import(&quot;./types&quot;).PrimitiveSerializableType} PrimitiveSerializableType */

/** @typedef {new (...params: EXPECTED_ANY[]) =&gt; EXPECTED_ANY} Constructor */

/*

Format:

File -&gt; Section*
Section -&gt; ObjectSection | ReferenceSection | EscapeSection | OtherSection

ObjectSection -&gt; ESCAPE (
	number:relativeOffset (number &gt; 0) |
	string:request (string|null):export
) Section:value* ESCAPE ESCAPE_END_OBJECT
ReferenceSection -&gt; ESCAPE number:relativeOffset (number &lt; 0)
EscapeSection -&gt; ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)
EscapeSection -&gt; ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)
OtherSection -&gt; any (except ESCAPE)

Why using null as escape value?
Multiple null values can merged by the BinaryMiddleware, which makes it very efficient
Technically any value can be used.

*/

/**
 * @typedef {object} ObjectSerializerSnapshot
 * @property {number} length
 * @property {number} cycleStackSize
 * @property {number} referenceableSize
 * @property {number} currentPos
 * @property {number} objectTypeLookupSize
 * @property {number} currentPosTypeLookup
 */
/** @typedef {TODO} Value */
/** @typedef {EXPECTED_OBJECT | string} ReferenceableItem */

/**
 * @typedef {object} ObjectSerializerContext
 * @property {(value: Value) =&gt; void} write
 * @property {(value: ReferenceableItem) =&gt; void} setCircularReference
 * @property {() =&gt; ObjectSerializerSnapshot} snapshot
 * @property {(snapshot: ObjectSerializerSnapshot) =&gt; void} rollback
 * @property {((item: Value | (() =&gt; Value)) =&gt; void)=} writeLazy
 * @property {((item: (Value | (() =&gt; Value)), obj: LazyOptions | undefined) =&gt; import(&quot;./SerializerMiddleware&quot;).LazyFunction&lt;EXPECTED_ANY, EXPECTED_ANY, EXPECTED_ANY, LazyOptions&gt;)=} writeSeparate
 */

/**
 * @typedef {object} ObjectDeserializerContext
 * @property {() =&gt; Value} read
 * @property {(value: ReferenceableItem) =&gt; void} setCircularReference
 */

/**
 * @typedef {object} ObjectSerializer
 * @property {(value: Value, context: ObjectSerializerContext) =&gt; void} serialize
 * @property {(context: ObjectDeserializerContext) =&gt; Value} deserialize
 */

/**
 * @template T
 * @param {Set&lt;T&gt;} set set
 * @param {number} size count of items to keep
 */
const setSetSize = (set, size) =&gt; {
	let i = 0;
	for (const item of set) {
		if (i++ &gt;= size) {
			set.delete(item);
		}
	}
};

/**
 * @template K, X
 * @param {Map&lt;K, X&gt;} map map
 * @param {number} size count of items to keep
 */
const setMapSize = (map, size) =&gt; {
	let i = 0;
	for (const item of map.keys()) {
		if (i++ &gt;= size) {
			map.delete(item);
		}
	}
};

/**
 * @param {Buffer} buffer buffer
 * @param {string | Hash} hashFunction hash function to use
 * @returns {string} hash
 */
const toHash = (buffer, hashFunction) =&gt; {
	const hash = createHash(hashFunction);
	hash.update(buffer);
	return /** @type {string} */ (hash.digest(&quot;latin1&quot;));
};

const ESCAPE = null;
const ESCAPE_ESCAPE_VALUE = null;
const ESCAPE_END_OBJECT = true;
const ESCAPE_UNDEFINED = false;

const CURRENT_VERSION = 2;

/** @typedef {{ request?: string, name?: string | number | null, serializer?: ObjectSerializer }} SerializerConfig */
/** @typedef {{ request?: string, name?: string | number | null, serializer: ObjectSerializer }} SerializerConfigWithSerializer */

/** @type {Map&lt;Constructor, SerializerConfig&gt;} */
const serializers = new Map();
/** @type {Map&lt;string | number, ObjectSerializer&gt;} */
const serializerInversed = new Map();

/** @type {Set&lt;string&gt;} */
const loadedRequests = new Set();

const NOT_SERIALIZABLE = {};

const jsTypes = new Map();

jsTypes.set(Object, new PlainObjectSerializer());
jsTypes.set(Array, new ArraySerializer());
jsTypes.set(null, new NullPrototypeObjectSerializer());
jsTypes.set(Map, new MapObjectSerializer());
jsTypes.set(Set, new SetObjectSerializer());
jsTypes.set(Date, new DateObjectSerializer());
jsTypes.set(RegExp, new RegExpObjectSerializer());
jsTypes.set(Error, new ErrorObjectSerializer(Error));
jsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));
jsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));
jsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));
jsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));
jsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));

// @ts-expect-error ES2018 doesn&#039;t `AggregateError`, but it can be used by developers
// eslint-disable-next-line n/no-unsupported-features/es-builtins, n/no-unsupported-features/es-syntax
if (typeof AggregateError !== &quot;undefined&quot;) {
	jsTypes.set(
		// @ts-expect-error ES2018 doesn&#039;t `AggregateError`, but it can be used by developers
		// eslint-disable-next-line n/no-unsupported-features/es-builtins, n/no-unsupported-features/es-syntax
		AggregateError,
		new AggregateErrorSerializer()
	);
}

// If in a sandboxed environment (e.g. jest), this escapes the sandbox and registers
// real Object and Array types to. These types may occur in the wild too, e.g. when
// using Structured Clone in postMessage.
// eslint-disable-next-line n/exports-style
if (exports.constructor !== Object) {
	// eslint-disable-next-line n/exports-style
	const Obj = /** @type {ObjectConstructor} */ (exports.constructor);
	const Fn = /** @type {FunctionConstructor} */ (Obj.constructor);
	for (const [type, config] of Array.from(jsTypes)) {
		if (type) {
			const Type = new Fn(`return ${type.name};`)();
			jsTypes.set(Type, config);
		}
	}
}

{
	let i = 1;
	for (const [type, serializer] of jsTypes) {
		serializers.set(type, {
			request: &quot;&quot;,
			name: i++,
			serializer
		});
	}
}

for (const { request, name, serializer } of serializers.values()) {
	serializerInversed.set(
		`${request}/${name}`,
		/** @type {ObjectSerializer} */ (serializer)
	);
}

/** @type {Map&lt;RegExp, (request: string) =&gt; boolean&gt;} */
const loaders = new Map();

/** @typedef {ComplexSerializableType[]} DeserializedType */
/** @typedef {PrimitiveSerializableType[]} SerializedType */
/** @typedef {{ logger: Logger }} Context */

/**
 * @extends {SerializerMiddleware&lt;DeserializedType, SerializedType, Context&gt;}
 */
class ObjectMiddleware extends SerializerMiddleware {
	/**
	 * @param {(context: ObjectSerializerContext | ObjectDeserializerContext) =&gt; void} extendContext context extensions
	 * @param {string | Hash} hashFunction hash function to use
	 */
	constructor(extendContext, hashFunction = DEFAULTS.HASH_FUNCTION) {
		super();
		this.extendContext = extendContext;
		this._hashFunction = hashFunction;
	}

	/**
	 * @param {RegExp} regExp RegExp for which the request is tested
	 * @param {(request: string) =&gt; boolean} loader loader to load the request, returns true when successful
	 * @returns {void}
	 */
	static registerLoader(regExp, loader) {
		loaders.set(regExp, loader);
	}

	/**
	 * @param {Constructor} Constructor the constructor
	 * @param {string} request the request which will be required when deserializing
	 * @param {string | null} name the name to make multiple serializer unique when sharing a request
	 * @param {ObjectSerializer} serializer the serializer
	 * @returns {void}
	 */
	static register(Constructor, request, name, serializer) {
		const key = `${request}/${name}`;

		if (serializers.has(Constructor)) {
			throw new Error(
				`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`
			);
		}

		if (serializerInversed.has(key)) {
			throw new Error(
				`ObjectMiddleware.register: serializer for ${key} is already registered`
			);
		}

		serializers.set(Constructor, {
			request,
			name,
			serializer
		});

		serializerInversed.set(key, serializer);
	}

	/**
	 * @param {Constructor} Constructor the constructor
	 * @returns {void}
	 */
	static registerNotSerializable(Constructor) {
		if (serializers.has(Constructor)) {
			throw new Error(
				`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`
			);
		}

		serializers.set(Constructor, NOT_SERIALIZABLE);
	}

	/**
	 * @param {Constructor} object for serialization
	 * @returns {SerializerConfigWithSerializer} Serializer config
	 */
	static getSerializerFor(object) {
		const proto = Object.getPrototypeOf(object);
		let c;
		if (proto === null) {
			// Object created with Object.create(null)
			c = null;
		} else {
			c = proto.constructor;
			if (!c) {
				throw new Error(
					&quot;Serialization of objects with prototype without valid constructor property not possible&quot;
				);
			}
		}
		const config = serializers.get(c);

		if (!config) throw new Error(`No serializer registered for ${c.name}`);
		if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;

		return /** @type {SerializerConfigWithSerializer} */ (config);
	}

	/**
	 * @param {string} request request
	 * @param {string} name name
	 * @returns {ObjectSerializer} serializer
	 */
	static getDeserializerFor(request, name) {
		const key = `${request}/${name}`;
		const serializer = serializerInversed.get(key);

		if (serializer === undefined) {
			throw new Error(`No deserializer registered for ${key}`);
		}

		return serializer;
	}

	/**
	 * @param {string} request request
	 * @param {string} name name
	 * @returns {ObjectSerializer | undefined} serializer
	 */
	static _getDeserializerForWithoutError(request, name) {
		const key = `${request}/${name}`;
		const serializer = serializerInversed.get(key);
		return serializer;
	}

	/**
	 * @param {DeserializedType} data data
	 * @param {Context} context context object
	 * @returns {SerializedType | Promise&lt;SerializedType&gt; | null} serialized data
	 */
	serialize(data, context) {
		/** @type {Value[]} */
		let result = [CURRENT_VERSION];
		let currentPos = 0;
		/** @type {Map&lt;ReferenceableItem, number&gt;} */
		let referenceable = new Map();
		/**
		 * @param {ReferenceableItem} item referenceable item
		 */
		const addReferenceable = item =&gt; {
			referenceable.set(item, currentPos++);
		};
		let bufferDedupeMap = new Map();
		/**
		 * @param {Buffer} buf buffer
		 * @returns {Buffer} deduped buffer
		 */
		const dedupeBuffer = buf =&gt; {
			const len = buf.length;
			const entry = bufferDedupeMap.get(len);
			if (entry === undefined) {
				bufferDedupeMap.set(len, buf);
				return buf;
			}
			if (Buffer.isBuffer(entry)) {
				if (len &lt; 32) {
					if (buf.equals(entry)) {
						return entry;
					}
					bufferDedupeMap.set(len, [entry, buf]);
					return buf;
				}
				const hash = toHash(entry, this._hashFunction);
				const newMap = new Map();
				newMap.set(hash, entry);
				bufferDedupeMap.set(len, newMap);
				const hashBuf = toHash(buf, this._hashFunction);
				if (hash === hashBuf) {
					return entry;
				}
				return buf;
			} else if (Array.isArray(entry)) {
				if (entry.length &lt; 16) {
					for (const item of entry) {
						if (buf.equals(item)) {
							return item;
						}
					}
					entry.push(buf);
					return buf;
				}
				const newMap = new Map();
				const hash = toHash(buf, this._hashFunction);
				let found;
				for (const item of entry) {
					const itemHash = toHash(item, this._hashFunction);
					newMap.set(itemHash, item);
					if (found === undefined &amp;&amp; itemHash === hash) found = item;
				}
				bufferDedupeMap.set(len, newMap);
				if (found === undefined) {
					newMap.set(hash, buf);
					return buf;
				}
				return found;
			}
			const hash = toHash(buf, this._hashFunction);
			const item = entry.get(hash);
			if (item !== undefined) {
				return item;
			}
			entry.set(hash, buf);
			return buf;
		};
		let currentPosTypeLookup = 0;
		let objectTypeLookup = new Map();
		const cycleStack = new Set();
		/**
		 * @param {Value} item item to stack
		 * @returns {string} stack
		 */
		const stackToString = item =&gt; {
			const arr = Array.from(cycleStack);
			arr.push(item);
			return arr
				.map(item =&gt; {
					if (typeof item === &quot;string&quot;) {
						if (item.length &gt; 100) {
							return `String ${JSON.stringify(item.slice(0, 100)).slice(
								0,
								-1
							)}...&quot;`;
						}
						return `String ${JSON.stringify(item)}`;
					}
					try {
						const { request, name } = ObjectMiddleware.getSerializerFor(item);
						if (request) {
							return `${request}${name ? `.${name}` : &quot;&quot;}`;
						}
					} catch (_err) {
						// ignore -&gt; fallback
					}
					if (typeof item === &quot;object&quot; &amp;&amp; item !== null) {
						if (item.constructor) {
							if (item.constructor === Object)
								return `Object { ${Object.keys(item).join(&quot;, &quot;)} }`;
							if (item.constructor === Map) return `Map { ${item.size} items }`;
							if (item.constructor === Array)
								return `Array { ${item.length} items }`;
							if (item.constructor === Set) return `Set { ${item.size} items }`;
							if (item.constructor === RegExp) return item.toString();
							return `${item.constructor.name}`;
						}
						return `Object [null prototype] { ${Object.keys(item).join(
							&quot;, &quot;
						)} }`;
					}
					if (typeof item === &quot;bigint&quot;) {
						return `BigInt ${item}n`;
					}
					try {
						return `${item}`;
					} catch (err) {
						return `(${/** @type {Error} */ (err).message})`;
					}
				})
				.join(&quot; -&gt; &quot;);
		};
		/** @type {WeakSet&lt;Error&gt;} */
		let hasDebugInfoAttached;
		/** @type {ObjectSerializerContext} */
		let ctx = {
			write(value) {
				try {
					process(value);
				} catch (err) {
					if (err !== NOT_SERIALIZABLE) {
						if (hasDebugInfoAttached === undefined)
							hasDebugInfoAttached = new WeakSet();
						if (!hasDebugInfoAttached.has(/** @type {Error} */ (err))) {
							/** @type {Error} */
							(err).message += `\nwhile serializing ${stackToString(value)}`;
							hasDebugInfoAttached.add(/** @type {Error} */ (err));
						}
					}
					throw err;
				}
			},
			setCircularReference(ref) {
				addReferenceable(ref);
			},
			snapshot() {
				return {
					length: result.length,
					cycleStackSize: cycleStack.size,
					referenceableSize: referenceable.size,
					currentPos,
					objectTypeLookupSize: objectTypeLookup.size,
					currentPosTypeLookup
				};
			},
			rollback(snapshot) {
				result.length = snapshot.length;
				setSetSize(cycleStack, snapshot.cycleStackSize);
				setMapSize(referenceable, snapshot.referenceableSize);
				currentPos = snapshot.currentPos;
				setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);
				currentPosTypeLookup = snapshot.currentPosTypeLookup;
			},
			...context
		};
		this.extendContext(ctx);
		/**
		 * @param {Value} item item to serialize
		 */
		const process = item =&gt; {
			if (Buffer.isBuffer(item)) {
				// check if we can emit a reference
				const ref = referenceable.get(item);
				if (ref !== undefined) {
					result.push(ESCAPE, ref - currentPos);
					return;
				}
				const alreadyUsedBuffer = dedupeBuffer(item);
				if (alreadyUsedBuffer !== item) {
					const ref = referenceable.get(alreadyUsedBuffer);
					if (ref !== undefined) {
						referenceable.set(item, ref);
						result.push(ESCAPE, ref - currentPos);
						return;
					}
					item = alreadyUsedBuffer;
				}
				addReferenceable(item);

				result.push(item);
			} else if (item === ESCAPE) {
				result.push(ESCAPE, ESCAPE_ESCAPE_VALUE);
			} else if (
				typeof item === &quot;object&quot;
				// We don&#039;t have to check for null as ESCAPE is null and this has been checked before
			) {
				// check if we can emit a reference
				const ref = referenceable.get(item);
				if (ref !== undefined) {
					result.push(ESCAPE, ref - currentPos);
					return;
				}

				if (cycleStack.has(item)) {
					throw new Error(
						&quot;This is a circular references. To serialize circular references use &#039;setCircularReference&#039; somewhere in the circle during serialize and deserialize.&quot;
					);
				}

				const { request, name, serializer } =
					ObjectMiddleware.getSerializerFor(item);
				const key = `${request}/${name}`;
				const lastIndex = objectTypeLookup.get(key);

				if (lastIndex === undefined) {
					objectTypeLookup.set(key, currentPosTypeLookup++);

					result.push(ESCAPE, request, name);
				} else {
					result.push(ESCAPE, currentPosTypeLookup - lastIndex);
				}

				cycleStack.add(item);

				try {
					serializer.serialize(item, ctx);
				} finally {
					cycleStack.delete(item);
				}

				result.push(ESCAPE, ESCAPE_END_OBJECT);

				addReferenceable(item);
			} else if (typeof item === &quot;string&quot;) {
				if (item.length &gt; 1) {
					// short strings are shorter when not emitting a reference (this saves 1 byte per empty string)
					// check if we can emit a reference
					const ref = referenceable.get(item);
					if (ref !== undefined) {
						result.push(ESCAPE, ref - currentPos);
						return;
					}
					addReferenceable(item);
				}

				if (item.length &gt; 102400 &amp;&amp; context.logger) {
					context.logger.warn(
						`Serializing big strings (${Math.round(
							item.length / 1024
						)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`
					);
				}

				result.push(item);
			} else if (typeof item === &quot;function&quot;) {
				if (!SerializerMiddleware.isLazy(item))
					throw new Error(`Unexpected function ${item}`);

				/** @type {SerializedType | undefined} */
				const serializedData =
					SerializerMiddleware.getLazySerializedValue(item);

				if (serializedData !== undefined) {
					if (typeof serializedData === &quot;function&quot;) {
						result.push(serializedData);
					} else {
						throw new Error(&quot;Not implemented&quot;);
					}
				} else if (SerializerMiddleware.isLazy(item, this)) {
					throw new Error(&quot;Not implemented&quot;);
				} else {
					const data = SerializerMiddleware.serializeLazy(item, data =&gt;
						this.serialize([data], context)
					);
					SerializerMiddleware.setLazySerializedValue(item, data);
					result.push(data);
				}
			} else if (item === undefined) {
				result.push(ESCAPE, ESCAPE_UNDEFINED);
			} else {
				result.push(item);
			}
		};

		try {
			for (const item of data) {
				process(item);
			}
			return result;
		} catch (err) {
			if (err === NOT_SERIALIZABLE) return null;

			throw err;
		} finally {
			// Get rid of these references to avoid leaking memory
			// This happens because the optimized code v8 generates
			// is optimized for our &quot;ctx.write&quot; method so it will reference
			// it from e. g. Dependency.prototype.serialize -(IC)-&gt; ctx.write
			data =
				result =
				referenceable =
				bufferDedupeMap =
				objectTypeLookup =
				ctx =
					/** @type {EXPECTED_ANY} */
					(undefined);
		}
	}

	/**
	 * @param {SerializedType} data data
	 * @param {Context} context context object
	 * @returns {DeserializedType | Promise&lt;DeserializedType&gt;} deserialized data
	 */
	deserialize(data, context) {
		let currentDataPos = 0;
		const read = () =&gt; {
			if (currentDataPos &gt;= data.length)
				throw new Error(&quot;Unexpected end of stream&quot;);

			return data[currentDataPos++];
		};

		if (read() !== CURRENT_VERSION)
			throw new Error(&quot;Version mismatch, serializer changed&quot;);

		let currentPos = 0;
		/** @type {ReferenceableItem[]} */
		let referenceable = [];
		/**
		 * @param {Value} item referenceable item
		 */
		const addReferenceable = item =&gt; {
			referenceable.push(item);
			currentPos++;
		};
		let currentPosTypeLookup = 0;
		/** @type {ObjectSerializer[]} */
		let objectTypeLookup = [];
		let result = [];
		/** @type {ObjectDeserializerContext} */
		let ctx = {
			read() {
				return decodeValue();
			},
			setCircularReference(ref) {
				addReferenceable(ref);
			},
			...context
		};
		this.extendContext(ctx);
		const decodeValue = () =&gt; {
			const item = read();

			if (item === ESCAPE) {
				const nextItem = read();

				if (nextItem === ESCAPE_ESCAPE_VALUE) {
					return ESCAPE;
				} else if (nextItem === ESCAPE_UNDEFINED) {
					// Nothing
				} else if (nextItem === ESCAPE_END_OBJECT) {
					throw new Error(
						`Unexpected end of object at position ${currentDataPos - 1}`
					);
				} else {
					const request = nextItem;
					let serializer;

					if (typeof request === &quot;number&quot;) {
						if (request &lt; 0) {
							// relative reference
							return referenceable[currentPos + request];
						}
						serializer = objectTypeLookup[currentPosTypeLookup - request];
					} else {
						if (typeof request !== &quot;string&quot;) {
							throw new Error(
								`Unexpected type (${typeof request}) of request ` +
									`at position ${currentDataPos - 1}`
							);
						}
						const name = /** @type {string} */ (read());

						serializer = ObjectMiddleware._getDeserializerForWithoutError(
							request,
							name
						);

						if (serializer === undefined) {
							if (request &amp;&amp; !loadedRequests.has(request)) {
								let loaded = false;
								for (const [regExp, loader] of loaders) {
									if (regExp.test(request) &amp;&amp; loader(request)) {
										loaded = true;
										break;
									}
								}
								if (!loaded) {
									require(request);
								}

								loadedRequests.add(request);
							}

							serializer = ObjectMiddleware.getDeserializerFor(request, name);
						}

						objectTypeLookup.push(serializer);
						currentPosTypeLookup++;
					}
					try {
						const item = serializer.deserialize(ctx);
						const end1 = read();

						if (end1 !== ESCAPE) {
							throw new Error(&quot;Expected end of object&quot;);
						}

						const end2 = read();

						if (end2 !== ESCAPE_END_OBJECT) {
							throw new Error(&quot;Expected end of object&quot;);
						}

						addReferenceable(item);

						return item;
					} catch (err) {
						// As this is only for error handling, we omit creating a Map for
						// faster access to this information, as this would affect performance
						// in the good case
						let serializerEntry;
						for (const entry of serializers) {
							if (entry[1].serializer === serializer) {
								serializerEntry = entry;
								break;
							}
						}
						const name = !serializerEntry
							? &quot;unknown&quot;
							: !serializerEntry[1].request
								? serializerEntry[0].name
								: serializerEntry[1].name
									? `${serializerEntry[1].request} ${serializerEntry[1].name}`
									: serializerEntry[1].request;
						/** @type {Error} */
						(err).message += `\n(during deserialization of ${name})`;
						throw err;
					}
				}
			} else if (typeof item === &quot;string&quot;) {
				if (item.length &gt; 1) {
					addReferenceable(item);
				}

				return item;
			} else if (Buffer.isBuffer(item)) {
				addReferenceable(item);

				return item;
			} else if (typeof item === &quot;function&quot;) {
				return SerializerMiddleware.deserializeLazy(
					item,
					data =&gt;
						/** @type {[DeserializedType]} */
						(this.deserialize(data, context))[0]
				);
			} else {
				return item;
			}
		};

		try {
			while (currentDataPos &lt; data.length) {
				result.push(decodeValue());
			}
			return result;
		} finally {
			// Get rid of these references to avoid leaking memory
			// This happens because the optimized code v8 generates
			// is optimized for our &quot;ctx.read&quot; method so it will reference
			// it from e. g. Dependency.prototype.deserialize -(IC)-&gt; ctx.read
			result =
				referenceable =
				data =
				objectTypeLookup =
				ctx =
					/** @type {EXPECTED_ANY} */
					(undefined);
		}
	}
}

module.exports = ObjectMiddleware;
module.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
