<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@stylistic/eslint-plugin-js/dist/rules/lines-around-comment.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@stylistic/eslint-plugin-js/dist/rules/lines-around-comment.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">259</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.98</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { c as createRule, F as COMMENTS_IGNORE_PATTERN, a as isCommentToken, i as isTokenOnSameLine, v as isOpeningBraceToken } from &#039;../utils.js&#039;;
import &#039;eslint-visitor-keys&#039;;
import &#039;espree&#039;;

function getEmptyLineNums(lines) {
  const emptyLines = lines.map((line, i) =&gt; ({
    code: line.trim(),
    num: i + 1
  })).filter((line) =&gt; !line.code).map((line) =&gt; line.num);
  return emptyLines;
}
function getCommentLineNums(comments) {
  const lines = [];
  comments.forEach((token) =&gt; {
    const start = token.loc.start.line;
    const end = token.loc.end.line;
    lines.push(start, end);
  });
  return lines;
}
var linesAroundComment = createRule({
  name: &quot;lines-around-comment&quot;,
  package: &quot;js&quot;,
  meta: {
    type: &quot;layout&quot;,
    docs: {
      description: &quot;Require empty lines around comments&quot;
    },
    fixable: &quot;whitespace&quot;,
    schema: [
      {
        type: &quot;object&quot;,
        properties: {
          beforeBlockComment: {
            type: &quot;boolean&quot;,
            default: true
          },
          afterBlockComment: {
            type: &quot;boolean&quot;,
            default: false
          },
          beforeLineComment: {
            type: &quot;boolean&quot;,
            default: false
          },
          afterLineComment: {
            type: &quot;boolean&quot;,
            default: false
          },
          allowBlockStart: {
            type: &quot;boolean&quot;,
            default: false
          },
          allowBlockEnd: {
            type: &quot;boolean&quot;,
            default: false
          },
          allowClassStart: {
            type: &quot;boolean&quot;
          },
          allowClassEnd: {
            type: &quot;boolean&quot;
          },
          allowObjectStart: {
            type: &quot;boolean&quot;
          },
          allowObjectEnd: {
            type: &quot;boolean&quot;
          },
          allowArrayStart: {
            type: &quot;boolean&quot;
          },
          allowArrayEnd: {
            type: &quot;boolean&quot;
          },
          ignorePattern: {
            type: &quot;string&quot;
          },
          applyDefaultIgnorePatterns: {
            type: &quot;boolean&quot;
          },
          afterHashbangComment: {
            type: &quot;boolean&quot;,
            default: false
          }
        },
        additionalProperties: false
      }
    ],
    messages: {
      after: &quot;Expected line after comment.&quot;,
      before: &quot;Expected line before comment.&quot;
    }
  },
  create(context) {
    const options = Object.assign({}, context.options[0]);
    const ignorePattern = options.ignorePattern;
    const defaultIgnoreRegExp = COMMENTS_IGNORE_PATTERN;
    const customIgnoreRegExp = ignorePattern &amp;&amp; new RegExp(ignorePattern, &quot;u&quot;);
    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
    options.beforeBlockComment = typeof options.beforeBlockComment !== &quot;undefined&quot; ? options.beforeBlockComment : true;
    const sourceCode = context.sourceCode;
    const lines = sourceCode.lines;
    const numLines = lines.length + 1;
    const comments = sourceCode.getAllComments();
    const commentLines = getCommentLineNums(comments);
    const emptyLines = getEmptyLineNums(lines);
    const commentAndEmptyLines = new Set(commentLines.concat(emptyLines));
    function codeAroundComment(token) {
      let currentToken = token;
      do
        currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });
      while (currentToken &amp;&amp; isCommentToken(currentToken));
      if (currentToken &amp;&amp; isTokenOnSameLine(currentToken, token))
        return true;
      currentToken = token;
      do
        currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
      while (currentToken &amp;&amp; isCommentToken(currentToken));
      if (currentToken &amp;&amp; isTokenOnSameLine(token, currentToken))
        return true;
      return false;
    }
    function isParentNodeType(parent, nodeType) {
      return parent.type === nodeType;
    }
    function getParentNodeOfToken(token) {
      const node = sourceCode.getNodeByRangeIndex(token.range[0]);
      if (node &amp;&amp; node.type === &quot;StaticBlock&quot;) {
        const openingBrace = sourceCode.getFirstToken(node, { skip: 1 });
        return openingBrace &amp;&amp; token.range[0] &gt;= openingBrace.range[0] ? node : null;
      }
      return node;
    }
    function isCommentAtParentStart(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      if (parent &amp;&amp; isParentNodeType(parent, nodeType)) {
        let parentStartNodeOrToken = parent;
        if (parent.type === &quot;StaticBlock&quot;) {
          parentStartNodeOrToken = sourceCode.getFirstToken(parent, { skip: 1 });
        } else if (parent.type === &quot;SwitchStatement&quot;) {
          parentStartNodeOrToken = sourceCode.getTokenAfter(parent.discriminant, {
            filter: isOpeningBraceToken
          });
        }
        return !!parentStartNodeOrToken &amp;&amp; token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;
      }
      return false;
    }
    function isCommentAtParentEnd(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      return !!parent &amp;&amp; isParentNodeType(parent, nodeType) &amp;&amp; parent.loc.end.line - token.loc.end.line === 1;
    }
    function isCommentAtBlockStart(token) {
      return isCommentAtParentStart(token, &quot;ClassBody&quot;) || isCommentAtParentStart(token, &quot;BlockStatement&quot;) || isCommentAtParentStart(token, &quot;StaticBlock&quot;) || isCommentAtParentStart(token, &quot;SwitchCase&quot;) || isCommentAtParentStart(token, &quot;SwitchStatement&quot;);
    }
    function isCommentAtBlockEnd(token) {
      return isCommentAtParentEnd(token, &quot;ClassBody&quot;) || isCommentAtParentEnd(token, &quot;BlockStatement&quot;) || isCommentAtParentEnd(token, &quot;StaticBlock&quot;) || isCommentAtParentEnd(token, &quot;SwitchCase&quot;) || isCommentAtParentEnd(token, &quot;SwitchStatement&quot;);
    }
    function isCommentAtClassStart(token) {
      return isCommentAtParentStart(token, &quot;ClassBody&quot;);
    }
    function isCommentAtClassEnd(token) {
      return isCommentAtParentEnd(token, &quot;ClassBody&quot;);
    }
    function isCommentAtObjectStart(token) {
      return isCommentAtParentStart(token, &quot;ObjectExpression&quot;) || isCommentAtParentStart(token, &quot;ObjectPattern&quot;);
    }
    function isCommentAtObjectEnd(token) {
      return isCommentAtParentEnd(token, &quot;ObjectExpression&quot;) || isCommentAtParentEnd(token, &quot;ObjectPattern&quot;);
    }
    function isCommentAtArrayStart(token) {
      return isCommentAtParentStart(token, &quot;ArrayExpression&quot;) || isCommentAtParentStart(token, &quot;ArrayPattern&quot;);
    }
    function isCommentAtArrayEnd(token) {
      return isCommentAtParentEnd(token, &quot;ArrayExpression&quot;) || isCommentAtParentEnd(token, &quot;ArrayPattern&quot;);
    }
    function checkForEmptyLine(token, opts) {
      if (applyDefaultIgnorePatterns &amp;&amp; defaultIgnoreRegExp.test(token.value))
        return;
      if (customIgnoreRegExp &amp;&amp; customIgnoreRegExp.test(token.value))
        return;
      let after = opts.after;
      let before = opts.before;
      const prevLineNum = token.loc.start.line - 1;
      const nextLineNum = token.loc.end.line + 1;
      const commentIsNotAlone = codeAroundComment(token);
      const blockStartAllowed = options.allowBlockStart &amp;&amp; isCommentAtBlockStart(token) &amp;&amp; !(options.allowClassStart === false &amp;&amp; isCommentAtClassStart(token));
      const blockEndAllowed = options.allowBlockEnd &amp;&amp; isCommentAtBlockEnd(token) &amp;&amp; !(options.allowClassEnd === false &amp;&amp; isCommentAtClassEnd(token));
      const classStartAllowed = options.allowClassStart &amp;&amp; isCommentAtClassStart(token);
      const classEndAllowed = options.allowClassEnd &amp;&amp; isCommentAtClassEnd(token);
      const objectStartAllowed = options.allowObjectStart &amp;&amp; isCommentAtObjectStart(token);
      const objectEndAllowed = options.allowObjectEnd &amp;&amp; isCommentAtObjectEnd(token);
      const arrayStartAllowed = options.allowArrayStart &amp;&amp; isCommentAtArrayStart(token);
      const arrayEndAllowed = options.allowArrayEnd &amp;&amp; isCommentAtArrayEnd(token);
      const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
      const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
      if (prevLineNum &lt; 1)
        before = false;
      if (nextLineNum &gt;= numLines)
        after = false;
      if (commentIsNotAlone)
        return;
      const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });
      const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });
      if (!exceptionStartAllowed &amp;&amp; before &amp;&amp; !commentAndEmptyLines.has(prevLineNum) &amp;&amp; !(isCommentToken(previousTokenOrComment) &amp;&amp; isTokenOnSameLine(previousTokenOrComment, token))) {
        const lineStart = token.range[0] - token.loc.start.column;
        const range = [lineStart, lineStart];
        context.report({
          node: token,
          messageId: &quot;before&quot;,
          fix(fixer) {
            return fixer.insertTextBeforeRange(range, &quot;\n&quot;);
          }
        });
      }
      if (!exceptionEndAllowed &amp;&amp; after &amp;&amp; !commentAndEmptyLines.has(nextLineNum) &amp;&amp; !(isCommentToken(nextTokenOrComment) &amp;&amp; isTokenOnSameLine(token, nextTokenOrComment))) {
        context.report({
          node: token,
          messageId: &quot;after&quot;,
          fix(fixer) {
            return fixer.insertTextAfter(token, &quot;\n&quot;);
          }
        });
      }
    }
    return {
      Program() {
        comments.forEach((token) =&gt; {
          if (token.type === &quot;Line&quot;) {
            if (options.beforeLineComment || options.afterLineComment) {
              checkForEmptyLine(token, {
                after: options.afterLineComment,
                before: options.beforeLineComment
              });
            }
          } else if (token.type === &quot;Block&quot;) {
            if (options.beforeBlockComment || options.afterBlockComment) {
              checkForEmptyLine(token, {
                after: options.afterBlockComment,
                before: options.beforeBlockComment
              });
            }
          } else if (token.type === &quot;Shebang&quot;) {
            if (options.afterHashbangComment) {
              checkForEmptyLine(token, {
                after: options.afterHashbangComment,
                before: false
              });
            }
          }
        });
      }
    };
  }
});

export { linesAroundComment as default };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
