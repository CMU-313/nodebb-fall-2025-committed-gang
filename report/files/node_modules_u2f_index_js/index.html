<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/u2f/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/u2f/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">223</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">58.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.02</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">
var crypto = require(&#039;crypto&#039;);

// Convert binary certificate or public key to an OpenSSL-compatible PEM text format.
function convertCertToPEM(cert) {
    if (!Buffer.isBuffer(cert))
        throw new Error(&quot;convertCertToPEM: cert must be buffer.&quot;)

    var type;
    if (cert.length == 65 &amp;&amp; cert[0] == 0x04) {
        // If needed, we encode raw public key to ASN structure, adding metadata:
        // SEQUENCE {
        //   SEQUENCE {
        //      OBJECTIDENTIFIER 1.2.840.10045.2.1 (ecPublicKey)
        //      OBJECTIDENTIFIER 1.2.840.10045.3.1.7 (P-256)
        //   }
        //   BITSTRING &lt;raw public key&gt;
        // }
        // Luckily, to do that, we just need to prefix it with constant 26 bytes (metadata is constant).
        cert = Buffer.concat([
            new Buffer(&quot;3059301306072a8648ce3d020106082a8648ce3d030107034200&quot;, &quot;hex&quot;),
            cert]);

        type = &quot;PUBLIC KEY&quot;;
    } else {
        type = &quot;CERTIFICATE&quot;;
    }

    // 2. To get PEM string, ASN structure then must be base64-encoded, split to
    // lines of 64 chars each and prefixed/postfixed with ---BEGIN/END PUBLIC KEY--- etc.

    var pemStr = &quot;-----BEGIN &quot;+type+&quot;-----\n&quot;;
    for (var certStr = cert.toString(&#039;base64&#039;); certStr.length &gt; 64; certStr = certStr.slice(64))
        pemStr += certStr.slice(0, 64) + &#039;\n&#039;;
    pemStr += certStr + &#039;\n&#039;;
    pemStr += &quot;-----END &quot;+type+&quot;-----\n&quot;;

    return pemStr;
}

// Check ECDSA+SHA256 signature of given data.
// cert is buffer containing ASN encoded certificate or raw publicKey of len 65
// signature is buffer (ASN encoded: SEQUENCE of 2 ec points)
// returns: true/false
function checkECDSASignature(data, cert, signature) {
    if (!Buffer.isBuffer(signature) || asnLen(signature) != signature.length)
        throw new Error(&quot;checkSignature: signature must be buffer of valid ASN/DER structure.&quot;);

    return crypto.createVerify(&quot;RSA-SHA256&quot;) // The actual signature alg is ECDSA and determined
            .update(data)                    // by ASN/DER data in public key. SHA256 is what we set here.
            .verify(convertCertToPEM(cert), signature);
}

// Our hash is always SHA256. Returns buffer.
function hash(data) {
    return crypto.createHash(&#039;SHA256&#039;).update(data).digest();
}

// Decode initial bytes of buffer as ASN and return the length of the encoded structure.
// See http://en.wikipedia.org/wiki/X.690
// Only SEQUENCE top-level identifier is supported (which covers all certs luckily)
function asnLen(buf) {
    if (buf.length &lt; 2 || buf[0] != 0x30)
        throw new Error(&quot;Invalid data: Not a SEQUENCE ASN/DER structure&quot;);

    var len = buf[1];
    if (len &amp; 0x80) { // long form
        var bytesCnt = len &amp; 0x7F;
        if (buf.length &lt; 2+bytesCnt)
            throw new Error(&quot;Invalid data: ASN structure not fully represented&quot;);
        len = 0;
        for (var i = 0; i &lt; bytesCnt; i++)
            len = len*0x100 + buf[2+i];
        len += bytesCnt; // add bytes for length itself.
    }
    return len + 2; // add 2 initial bytes: type and length.
}

function toWebsafeBase64(buf) {
    return buf.toString(&#039;base64&#039;).replace(/\//g,&#039;_&#039;).replace(/\+/g,&#039;-&#039;).replace(/=/g, &#039;&#039;);
}



//==============================================================================
// Main API

// Generate request for client. Basically the same for registration and signature, except for the keyHandle.
function request(appId, keyHandle) {
    if (typeof appId !== &#039;string&#039;)
        throw new Error(&quot;U2F request(): appId must be provided.&quot;);

    var res = {
        version: &quot;U2F_V2&quot;,
        appId: appId,
        challenge: toWebsafeBase64(crypto.randomBytes(32))
    };
    if (keyHandle)
        res.keyHandle = keyHandle;
    return res;
}

// Check registration data. We&#039;re checking correct challenge and certificate signature.
// request: {version, appId, challenge} - from user session, kept on server.
// registerData: {clientData, registrationData} - result of u2f.register
function checkRegistration(request, registerData) {
    if (typeof registerData !== &#039;object&#039;)
        return {errorMessage: &quot;Invalid response from U2F token.&quot;};

    // Check registration error
    if (registerData.errorCode &amp;&amp; registerData.errorCode != 0)
        return {
            errorMessage: registerData.errorMessage || &quot;Error registering U2F token.&quot;,
            errorCode: registerData.errorCode,
        };

    // Unpack and check clientData, challenge.
    var clientData = new Buffer(registerData.clientData, &#039;base64&#039;);
    try {
        var clientDataObj = JSON.parse(clientData.toString(&#039;utf8&#039;));
    }
    catch (e) {
        return {errorMessage: &quot;Invalid clientData: not a valid JSON object&quot;}
    }
    if (clientDataObj.challenge !== request.challenge)
        return {errorMessage: &quot;Invalid challenge: not the one provided&quot;};

    // Parse registrationData.
    var buf = new Buffer(registerData.registrationData, &#039;base64&#039;);
    var reserved = buf[0];                       buf = buf.slice(1);
    var publicKey = buf.slice(0, 65);            buf = buf.slice(65);
    var keyHandleLen = buf[0];                   buf = buf.slice(1);
    var keyHandle = buf.slice(0, keyHandleLen);  buf = buf.slice(keyHandleLen);
    var certLen = asnLen(buf);
    var certificate = buf.slice(0, certLen);     buf = buf.slice(certLen);
    var signLen = asnLen(buf);
    var signature = buf.slice(0, signLen);       buf = buf.slice(signLen);
    if (buf.length !== 0)
        console.error(&quot;U2F Registration Warning: registrationData has extra bytes: &quot;+buf.toString(&#039;hex&#039;));

    var reservedByte = new Buffer(&#039;00&#039;, &#039;hex&#039;);
    var appIdHash = hash(request.appId);
    var clientDataHash = hash(clientData);

    var signatureBase = Buffer.concat([reservedByte, appIdHash, clientDataHash, keyHandle, publicKey]);

    if (checkECDSASignature(signatureBase, certificate, signature))
        return {
            successful: true,
            publicKey: toWebsafeBase64(publicKey),
            keyHandle: toWebsafeBase64(keyHandle),
            certificate: certificate
        };
    else
        return {errorMessage: &quot;Invalid signature.&quot;};
}


// Check signature data.
// request: {version, appId, challenge, keyHandle} - from user session, kept on server.
// signResult: {clientData, signatureData} - result of u2f.sign on client.
// publicKey: string from user account.
function checkSignature(request, signResult, publicKey) {
    if (typeof signResult !== &#039;object&#039;)
        return {errorMessage: &quot;Invalid response from U2F token.&quot;};

    // Check registration error
    if (signResult.errorCode &amp;&amp; signResult.errorCode != 0)
        return {
            errorMessage: signResult.errorMessage || &quot;Error getting signature from U2F token.&quot;,
            errorCode: signResult.errorCode,
        };

    // Unpack and check clientData, challenge.
    var clientData = new Buffer(signResult.clientData, &#039;base64&#039;);
    try {
        var clientDataObj = JSON.parse(clientData.toString(&#039;utf8&#039;));
    }
    catch (e) {
        return {errorMessage: &quot;Invalid clientData: not a valid JSON object&quot;}
    }
    if (clientDataObj.challenge !== request.challenge)
        return {errorMessage: &quot;Invalid challenge: not the one provided&quot;};

    // Parse signatureData
    var buf = new Buffer(signResult.signatureData, &#039;base64&#039;);
    var userPresenceFlag = buf.slice(0, 1);    buf = buf.slice(1);
    var counter = buf.slice(0, 4);             buf = buf.slice(4);
    var signLen = asnLen(buf);
    var signature = buf.slice(0, signLen);     buf = buf.slice(signLen);
    if (buf.length !== 0)
        console.error(&quot;U2F Authentication Warning: signatureData has extra bytes: &quot;+buf.toString(&#039;hex&#039;));

    var appIdHash = hash(request.appId);
    var clientDataHash = hash(clientData);

    var signatureBase = Buffer.concat([appIdHash, userPresenceFlag, counter, clientDataHash]);
    var cert = new Buffer(publicKey, &#039;base64&#039;);

    if (checkECDSASignature(signatureBase, cert, signature))
        return {
            successful: true,
            userPresent: (userPresenceFlag[0] &amp; 1) === 1,
            counter: counter.readUInt32BE(0)
        };
    else
        return {errorMessage: &quot;Invalid signature.&quot;};
}


// Set up appId as a convenience.
module.exports = {
    // Main API
    request: request,
    checkRegistration: checkRegistration,
    checkSignature: checkSignature,

    // Supplemental API, mostly for testing.
    _hash: hash,
    _checkECDSASignature: checkECDSASignature,
    _toWebsafeBase64: toWebsafeBase64,
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
