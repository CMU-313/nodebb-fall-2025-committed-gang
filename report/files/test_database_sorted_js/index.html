<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/database/sorted.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/database/sorted.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">76.70</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1672</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">97.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">23.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const db = require(&#039;../mocks/databasemock&#039;);

describe(&#039;Sorted Set methods&#039;, () =&gt; {
	before(async () =&gt; {
		await Promise.all([
			db.sortedSetAdd(&#039;sortedSetTest1&#039;, [1.1, 1.2, 1.3], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;]),
			db.sortedSetAdd(&#039;sortedSetTest2&#039;, [1, 4], [&#039;value1&#039;, &#039;value4&#039;]),
			db.sortedSetAdd(&#039;sortedSetTest3&#039;, [2, 4], [&#039;value2&#039;, &#039;value4&#039;]),
			db.sortedSetAdd(&#039;sortedSetTest4&#039;, [1, 1, 2, 3, 5], [&#039;b&#039;, &#039;a&#039;, &#039;d&#039;, &#039;e&#039;, &#039;c&#039;]),
			db.sortedSetAdd(&#039;sortedSetLex&#039;, [0, 0, 0, 0], [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;]),
		]);
	});

	describe(&#039;sortedSetScan&#039;, () =&gt; {
		it(&#039;should find matches in sorted set containing substring&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;scanzset&#039;, [1, 2, 3, 4, 5, 6], [&#039;aaaa&#039;, &#039;bbbb&#039;, &#039;bbcc&#039;, &#039;ddd&#039;, &#039;dddd&#039;, &#039;fghbc&#039;]);
			const data = await db.getSortedSetScan({
				key: &#039;scanzset&#039;,
				match: &#039;*bc*&#039;,
			});
			assert(data.includes(&#039;bbcc&#039;));
			assert(data.includes(&#039;fghbc&#039;));
		});

		it(&#039;should find matches in sorted set with scores&#039;, async () =&gt; {
			const data = await db.getSortedSetScan({
				key: &#039;scanzset&#039;,
				match: &#039;*bc*&#039;,
				withScores: true,
			});
			data.sort((a, b) =&gt; a.score - b.score);
			assert.deepStrictEqual(data, [{ value: &#039;bbcc&#039;, score: 3 }, { value: &#039;fghbc&#039;, score: 6 }]);
		});

		it(&#039;should find matches in sorted set with a limit&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;scanzset2&#039;, [1, 2, 3, 4, 5, 6], [&#039;aaab&#039;, &#039;bbbb&#039;, &#039;bbcb&#039;, &#039;ddb&#039;, &#039;dddd&#039;, &#039;fghbc&#039;]);
			const data = await db.getSortedSetScan({
				key: &#039;scanzset2&#039;,
				match: &#039;*b*&#039;,
				limit: 2,
			});
			assert.equal(data.length, 2);
		});

		it(&#039;should work for special characters&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;scanzset3&#039;, [1, 2, 3, 4, 5], [&#039;aaab{&#039;, &#039;bbbb&#039;, &#039;bbcb{&#039;, &#039;ddb&#039;, &#039;dddd&#039;]);
			const data = await db.getSortedSetScan({
				key: &#039;scanzset3&#039;,
				match: &#039;*b{&#039;,
				limit: 2,
			});
			assert.strictEqual(data.length, 2);
			assert(data.includes(&#039;aaab{&#039;));
			assert(data.includes(&#039;bbcb{&#039;));
		});

		it(&#039;should find everything starting with string&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;scanzset4&#039;, [1, 2, 3, 4, 5], [&#039;aaab{&#039;, &#039;bbbb&#039;, &#039;bbcb&#039;, &#039;ddb&#039;, &#039;dddd&#039;]);
			const data = await db.getSortedSetScan({
				key: &#039;scanzset4&#039;,
				match: &#039;b*&#039;,
			});
			assert.strictEqual(data.length, 2);
			assert(data.includes(&#039;bbbb&#039;));
			assert(data.includes(&#039;bbcb&#039;));
		});

		it(&#039;should find everything ending with string&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;scanzset5&#039;, [1, 2, 3, 4, 5, 6], [&#039;aaab{&#039;, &#039;bbbb&#039;, &#039;bbcb&#039;, &#039;ddb&#039;, &#039;dddd&#039;, &#039;adb&#039;]);
			const data = await db.getSortedSetScan({
				key: &#039;scanzset5&#039;,
				match: &#039;*db&#039;,
			});
			assert.strictEqual(data.length, 2);
			assert(data.includes(&#039;ddb&#039;));
			assert(data.includes(&#039;adb&#039;));
		});

		it(&#039;should not error with invalid input&#039;, async () =&gt; {
			const query = `-3217&#039;
OR 1251=CAST((CHR(113)||CHR(98)||CHR(118)||CHR(98)||CHR(113))||(SELECT
(CASE WHEN (1251=1251) THEN 1 ELSE 0
END))::text||(CHR(113)||CHR(113)||CHR(118)||CHR(98)||CHR(113)) AS
NUMERIC)-- WsPn&amp;query[cid]=-1&amp;parentCid=0&amp;selectedCids[]=-1&amp;privilege=topics:read&amp;states[]=watching&amp;states[]=tracking&amp;states[]=notwatching&amp;showLinks=`;
			const match = `*${query.toLowerCase()}*`;
			const data = await db.getSortedSetScan({
				key: &#039;categories:name&#039;,
				match: match,
				limit: 500,
			});
			assert.strictEqual(data.length, 0);
		});
	});

	describe(&#039;sortedSetAdd()&#039;, () =&gt; {
		it(&#039;should add an element to a sorted set&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;sorted1&#039;, 1, &#039;value1&#039;, function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it(&#039;should add two elements to a sorted set&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;sorted2&#039;, [1, 2], [&#039;value1&#039;, &#039;value2&#039;], function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it(&#039;should gracefully handle adding the same element twice&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;sorted2&#039;, [1, 2], [&#039;value1&#039;, &#039;value1&#039;], function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);

				db.sortedSetScore(&#039;sorted2&#039;, &#039;value1&#039;, function (err, score) {
					assert.equal(err, null);
					assert.equal(score, 2);
					assert.equal(arguments.length, 2);

					done();
				});
			});
		});

		it(&#039;should error if score is null&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;errorScore&#039;, null, &#039;value1&#039;, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-score, null]]&#039;);
				done();
			});
		});

		it(&#039;should error if any score is undefined&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;errorScore&#039;, [1, undefined], [&#039;value1&#039;, &#039;value2&#039;], (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-score, undefined]]&#039;);
				done();
			});
		});

		it(&#039;should add null value as `null` string&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;nullValueZSet&#039;, 1, null, (err) =&gt; {
				assert.ifError(err);
				db.getSortedSetRange(&#039;nullValueZSet&#039;, 0, -1, (err, values) =&gt; {
					assert.ifError(err);
					assert.strictEqual(values[0], &#039;null&#039;);
					done();
				});
			});
		});
	});

	describe(&#039;sortedSetsAdd()&#039;, () =&gt; {
		it(&#039;should add an element to two sorted sets&#039;, (done) =&gt; {
			db.sortedSetsAdd([&#039;sorted1&#039;, &#039;sorted2&#039;], 3, &#039;value3&#039;, function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				done();
			});
		});

		it(&#039;should add an element to two sorted sets with different scores&#039;, (done) =&gt; {
			db.sortedSetsAdd([&#039;sorted1&#039;, &#039;sorted2&#039;], [4, 5], &#039;value4&#039;, (err) =&gt; {
				assert.ifError(err);
				db.sortedSetsScore([&#039;sorted1&#039;, &#039;sorted2&#039;], &#039;value4&#039;, (err, scores) =&gt; {
					assert.ifError(err);
					assert.deepStrictEqual(scores, [4, 5]);
					done();
				});
			});
		});


		it(&#039;should error if keys.length is different than scores.length&#039;, (done) =&gt; {
			db.sortedSetsAdd([&#039;sorted1&#039;, &#039;sorted2&#039;], [4], &#039;value4&#039;, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should error if score is null&#039;, (done) =&gt; {
			db.sortedSetsAdd([&#039;sorted1&#039;, &#039;sorted2&#039;], null, &#039;value1&#039;, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-score, null]]&#039;);
				done();
			});
		});

		it(&#039;should error if scores has null&#039;, async () =&gt; {
			let err;
			try {
				await db.sortedSetsAdd([&#039;sorted1&#039;, &#039;sorted2&#039;], [1, null], &#039;dontadd&#039;);
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, &#039;[[error:invalid-score, 1,]]&#039;);
			assert.strictEqual(await db.isSortedSetMember(&#039;sorted1&#039;, &#039;dontadd&#039;), false);
			assert.strictEqual(await db.isSortedSetMember(&#039;sorted2&#039;, &#039;dontadd&#039;), false);
		});
	});

	describe(&#039;sortedSetAddMulti()&#039;, () =&gt; {
		it(&#039;should add elements into multiple sorted sets with different scores&#039;, (done) =&gt; {
			db.sortedSetAddBulk([
				[&#039;bulk1&#039;, 1, &#039;item1&#039;],
				[&#039;bulk2&#039;, 2, &#039;item1&#039;],
				[&#039;bulk2&#039;, 3, &#039;item2&#039;],
				[&#039;bulk3&#039;, 4, &#039;item3&#039;],
			], function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRevRangeWithScores([&#039;bulk1&#039;, &#039;bulk2&#039;, &#039;bulk3&#039;], 0, -1, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepStrictEqual(data, [{ value: &#039;item3&#039;, score: 4 },
						{ value: &#039;item2&#039;, score: 3 },
						{ value: &#039;item1&#039;, score: 2 },
						{ value: &#039;item1&#039;, score: 1 }]);
					done();
				});
			});
		});
		it(&#039;should not error if data is undefined&#039;, (done) =&gt; {
			db.sortedSetAddBulk(undefined, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should error if score is null&#039;, async () =&gt; {
			let err;
			try {
				await db.sortedSetAddBulk([
					[&#039;bulk4&#039;, 0, &#039;dontadd&#039;],
					[&#039;bulk5&#039;, null, &#039;dontadd&#039;],
				]);
			} catch (_err) {
				err = _err;
			}
			assert.equal(err.message, &#039;[[error:invalid-score, null]]&#039;);
			assert.strictEqual(await db.isSortedSetMember(&#039;bulk4&#039;, &#039;dontadd&#039;), false);
			assert.strictEqual(await db.isSortedSetMember(&#039;bulk5&#039;, &#039;dontadd&#039;), false);
		});
	});

	describe(&#039;getSortedSetRange()&#039;, () =&gt; {
		it(&#039;should return the lowest scored element&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;sortedSetTest1&#039;, 0, 0, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(value, [&#039;value1&#039;]);
				done();
			});
		});

		it(&#039;should return elements sorted by score lowest to highest&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;sortedSetTest1&#039;, 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;]);
				done();
			});
		});

		it(&#039;should return empty array if set does not exist&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;doesnotexist&#039;, 0, -1, (err, values) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(values));
				assert.equal(values.length, 0);
				done();
			});
		});

		it(&#039;should handle negative start/stop&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;negatives&#039;, [1, 2, 3, 4, 5], [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;, &#039;5&#039;], (err) =&gt; {
				assert.ifError(err);
				db.getSortedSetRange(&#039;negatives&#039;, -2, -4, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepEqual(data, []);
					done();
				});
			});
		});

		it(&#039;should handle negative start/stop&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;negatives&#039;, -4, -2, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;2&#039;, &#039;3&#039;, &#039;4&#039;]);
				done();
			});
		});

		it(&#039;should handle negative start/stop&#039;, (done) =&gt; {
			db.getSortedSetRevRange(&#039;negatives&#039;, -4, -2, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;4&#039;, &#039;3&#039;, &#039;2&#039;]);
				done();
			});
		});

		it(&#039;should handle negative start/stop&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;negatives&#039;, -5, -1, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;, &#039;5&#039;]);
				done();
			});
		});

		it(&#039;should handle negative start/stop&#039;, (done) =&gt; {
			db.getSortedSetRange(&#039;negatives&#039;, 0, -2, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;4&#039;]);
				done();
			});
		});

		it(&#039;should return empty array if keys is empty array&#039;, (done) =&gt; {
			db.getSortedSetRange([], 0, -1, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepStrictEqual(data, []);
				done();
			});
		});

		it(&#039;should return duplicates if two sets have same elements&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;dupezset1&#039;, [1, 2], [&#039;value 1&#039;, &#039;value 2&#039;]);
			await db.sortedSetAdd(&#039;dupezset2&#039;, [2, 3], [&#039;value 2&#039;, &#039;value 3&#039;]);
			const data = await db.getSortedSetRange([&#039;dupezset1&#039;, &#039;dupezset2&#039;], 0, -1);
			assert.deepStrictEqual(data, [&#039;value 1&#039;, &#039;value 2&#039;, &#039;value 2&#039;, &#039;value 3&#039;]);
		});

		it(&#039;should return correct number of elements&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;dupezset3&#039;, [1, 2, 3], [&#039;value 1&#039;, &#039;value 2&#039;, &#039;value3&#039;]);
			await db.sortedSetAdd(&#039;dupezset4&#039;, [0, 5], [&#039;value 0&#039;, &#039;value5&#039;]);
			const data = await db.getSortedSetRevRange([&#039;dupezset3&#039;, &#039;dupezset4&#039;], 0, 1);
			assert.deepStrictEqual(data, [&#039;value5&#039;, &#039;value3&#039;]);
		});

		it(&#039;should work with big arrays (length &gt; 100) &#039;, async function () {
			this.timeout(100000);
			const keys = [];
			for (let i = 0; i &lt; 400; i++) {
				/* eslint-disable no-await-in-loop */
				const bulkAdd = [];
				keys.push(`testzset${i}`);
				for (let k = 0; k &lt; 100; k++) {
					bulkAdd.push([`testzset${i}`, 1000000 + k + (i * 100), k + (i * 100)]);
				}
				await db.sortedSetAddBulk(bulkAdd);
			}

			let data = await db.getSortedSetRevRange(keys, 0, 3);
			assert.deepStrictEqual(data, [&#039;39999&#039;, &#039;39998&#039;, &#039;39997&#039;, &#039;39996&#039;]);

			data = await db.getSortedSetRevRangeWithScores(keys, 0, 3);
			assert.deepStrictEqual(data, [
				{ value: &#039;39999&#039;, score: 1039999 },
				{ value: &#039;39998&#039;, score: 1039998 },
				{ value: &#039;39997&#039;, score: 1039997 },
				{ value: &#039;39996&#039;, score: 1039996 },
			]);

			data = await db.getSortedSetRevRange(keys, 0, -1);
			assert.equal(data.length, 40000);

			data = await db.getSortedSetRange(keys, 9998, 10002);
			assert.deepStrictEqual(data, [&#039;9998&#039;, &#039;9999&#039;, &#039;10000&#039;, &#039;10001&#039;, &#039;10002&#039;]);
		});
	});

	describe(&#039;getSortedSetRevRange()&#039;, () =&gt; {
		it(&#039;should return the highest scored element&#039;, (done) =&gt; {
			db.getSortedSetRevRange(&#039;sortedSetTest1&#039;, 0, 0, function (err, value) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(value, [&#039;value3&#039;]);
				done();
			});
		});

		it(&#039;should return elements sorted by score highest to lowest&#039;, (done) =&gt; {
			db.getSortedSetRevRange(&#039;sortedSetTest1&#039;, 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [&#039;value3&#039;, &#039;value2&#039;, &#039;value1&#039;]);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRangeWithScores()&#039;, () =&gt; {
		it(&#039;should return array of elements sorted by score lowest to highest with scores&#039;, (done) =&gt; {
			db.getSortedSetRangeWithScores(&#039;sortedSetTest1&#039;, 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: &#039;value1&#039;, score: 1.1 }, { value: &#039;value2&#039;, score: 1.2 }, { value: &#039;value3&#039;, score: 1.3 }]);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRevRangeWithScores()&#039;, () =&gt; {
		it(&#039;should return array of elements sorted by score highest to lowest with scores&#039;, (done) =&gt; {
			db.getSortedSetRevRangeWithScores(&#039;sortedSetTest1&#039;, 0, -1, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: &#039;value3&#039;, score: 1.3 }, { value: &#039;value2&#039;, score: 1.2 }, { value: &#039;value1&#039;, score: 1.1 }]);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRangeByScore()&#039;, () =&gt; {
		it(&#039;should get count elements with score between min max sorted by score lowest to highest&#039;, (done) =&gt; {
			db.getSortedSetRangeByScore(&#039;sortedSetTest1&#039;, 0, -1, &#039;-inf&#039;, 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [&#039;value1&#039;, &#039;value2&#039;]);
				done();
			});
		});

		it(&#039;should return empty array if set does not exist&#039;, (done) =&gt; {
			db.getSortedSetRangeByScore(&#039;doesnotexist&#039;, 0, -1, &#039;-inf&#039;, 0, (err, values) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(values));
				assert.equal(values.length, 0);
				done();
			});
		});

		it(&#039;should return empty array if count is 0&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByScore(&#039;sortedSetTest1&#039;, 0, 0, &#039;+inf&#039;, &#039;-inf&#039;, (err, values) =&gt; {
				assert.ifError(err);
				assert.deepEqual(values, []);
				done();
			});
		});

		it(&#039;should return elements from 1 to end&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByScore(&#039;sortedSetTest1&#039;, 1, -1, &#039;+inf&#039;, &#039;-inf&#039;, (err, values) =&gt; {
				assert.ifError(err);
				assert.deepEqual(values, [&#039;value2&#039;, &#039;value1&#039;]);
				done();
			});
		});

		it(&#039;should return elements from 3 to last&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;partialZset&#039;, [1, 2, 3, 4, 5], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;, &#039;value4&#039;, &#039;value5&#039;], (err) =&gt; {
				assert.ifError(err);
				db.getSortedSetRangeByScore(&#039;partialZset&#039;, 3, 10, &#039;-inf&#039;, &#039;+inf&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepStrictEqual(data, [&#039;value4&#039;, &#039;value5&#039;]);
					done();
				});
			});
		});

		it(&#039;should return elements if min/max are numeric strings&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;zsetstringminmax&#039;, [1, 2, 3, 4, 5], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;, &#039;value4&#039;, &#039;value5&#039;]);
			const results = await db.getSortedSetRevRangeByScore(&#039;zsetstringminmax&#039;, 0, -1, &#039;3&#039;, &#039;3&#039;);
			assert.deepStrictEqual(results, [&#039;value3&#039;]);
		});
	});

	describe(&#039;getSortedSetRevRangeByScore()&#039;, () =&gt; {
		it(&#039;should get count elements with score between max min sorted by score highest to lowest&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByScore(&#039;sortedSetTest1&#039;, 0, -1, &#039;+inf&#039;, 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [&#039;value3&#039;, &#039;value2&#039;]);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRangeByScoreWithScores()&#039;, () =&gt; {
		it(&#039;should get count elements with score between min max sorted by score lowest to highest with scores&#039;, (done) =&gt; {
			db.getSortedSetRangeByScoreWithScores(&#039;sortedSetTest1&#039;, 0, -1, &#039;-inf&#039;, 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: &#039;value1&#039;, score: 1.1 }, { value: &#039;value2&#039;, score: 1.2 }]);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRevRangeByScoreWithScores()&#039;, () =&gt; {
		it(&#039;should get count elements with score between max min sorted by score highest to lowest&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByScoreWithScores(&#039;sortedSetTest1&#039;, 0, -1, &#039;+inf&#039;, 1.2, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [{ value: &#039;value3&#039;, score: 1.3 }, { value: &#039;value2&#039;, score: 1.2 }]);
				done();
			});
		});

		it(&#039;should work with an array of keys&#039;, async () =&gt; {
			await db.sortedSetAddBulk([
				[&#039;byScoreWithScoresKeys1&#039;, 1, &#039;value1&#039;],
				[&#039;byScoreWithScoresKeys2&#039;, 2, &#039;value2&#039;],
			]);
			const data = await db.getSortedSetRevRangeByScoreWithScores([&#039;byScoreWithScoresKeys1&#039;, &#039;byScoreWithScoresKeys2&#039;], 0, -1, 5, -5);
			assert.deepStrictEqual(data, [{ value: &#039;value2&#039;, score: 2 }, { value: &#039;value1&#039;, score: 1 }]);
		});
	});

	describe(&#039;sortedSetCount()&#039;, () =&gt; {
		it(&#039;should return 0 for a sorted set that does not exist&#039;, (done) =&gt; {
			db.sortedSetCount(&#039;doesnotexist&#039;, 0, 10, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 0);
				done();
			});
		});

		it(&#039;should return number of elements between scores min max inclusive&#039;, (done) =&gt; {
			db.sortedSetCount(&#039;sortedSetTest1&#039;, &#039;-inf&#039;, 1.2, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 2);
				done();
			});
		});

		it(&#039;should return number of elements between scores -inf +inf inclusive&#039;, (done) =&gt; {
			db.sortedSetCount(&#039;sortedSetTest1&#039;, &#039;-inf&#039;, &#039;+inf&#039;, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 3);
				done();
			});
		});
	});

	describe(&#039;sortedSetCard()&#039;, () =&gt; {
		it(&#039;should return 0 for a sorted set that does not exist&#039;, (done) =&gt; {
			db.sortedSetCard(&#039;doesnotexist&#039;, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 0);
				done();
			});
		});

		it(&#039;should return number of elements in a sorted set&#039;, (done) =&gt; {
			db.sortedSetCard(&#039;sortedSetTest1&#039;, function (err, count) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(count, 3);
				done();
			});
		});
	});

	describe(&#039;sortedSetsCard()&#039;, () =&gt; {
		it(&#039;should return the number of elements in sorted sets&#039;, (done) =&gt; {
			db.sortedSetsCard([&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;, &#039;doesnotexist&#039;], function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, [3, 2, 0]);
				done();
			});
		});

		it(&#039;should return empty array if keys is falsy&#039;, (done) =&gt; {
			db.sortedSetsCard(undefined, function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, []);
				done();
			});
		});

		it(&#039;should return empty array if keys is empty array&#039;, (done) =&gt; {
			db.sortedSetsCard([], function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, []);
				done();
			});
		});
	});

	describe(&#039;sortedSetsCardSum()&#039;, () =&gt; {
		it(&#039;should return the total number of elements in sorted sets&#039;, (done) =&gt; {
			db.sortedSetsCardSum([&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;, &#039;doesnotexist&#039;], function (err, sum) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(sum, 5);
				done();
			});
		});

		it(&#039;should return 0 if keys is falsy&#039;, (done) =&gt; {
			db.sortedSetsCardSum(undefined, function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, 0);
				done();
			});
		});

		it(&#039;should return 0 if keys is empty array&#039;, (done) =&gt; {
			db.sortedSetsCardSum([], function (err, counts) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(counts, 0);
				done();
			});
		});

		it(&#039;should return the total number of elements in sorted set&#039;, (done) =&gt; {
			db.sortedSetsCardSum(&#039;sortedSetTest1&#039;, function (err, sum) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(sum, 3);
				done();
			});
		});

		it(&#039;should work with min/max&#039;, async () =&gt; {
			let count = await db.sortedSetsCardSum([
				&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;,
			], &#039;-inf&#039;, 2);
			assert.strictEqual(count, 5);

			count = await db.sortedSetsCardSum([
				&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;,
			], 2, &#039;+inf&#039;);
			assert.strictEqual(count, 3);

			count = await db.sortedSetsCardSum([
				&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;,
			], &#039;-inf&#039;, &#039;+inf&#039;);
			assert.strictEqual(count, 7);
		});
	});

	describe(&#039;sortedSetRank()&#039;, () =&gt; {
		it(&#039;should return falsy if sorted set does not exist&#039;, (done) =&gt; {
			db.sortedSetRank(&#039;doesnotexist&#039;, &#039;value1&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it(&#039;should return falsy if element isnt in sorted set&#039;, (done) =&gt; {
			db.sortedSetRank(&#039;sortedSetTest1&#039;, &#039;value5&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it(&#039;should return the rank of the element in the sorted set sorted by lowest to highest score&#039;, (done) =&gt; {
			db.sortedSetRank(&#039;sortedSetTest1&#039;, &#039;value1&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 0);
				done();
			});
		});

		it(&#039;should return the rank sorted by the score and then the value (a)&#039;, (done) =&gt; {
			db.sortedSetRank(&#039;sortedSetTest4&#039;, &#039;a&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 0);
				done();
			});
		});

		it(&#039;should return the rank sorted by the score and then the value (b)&#039;, (done) =&gt; {
			db.sortedSetRank(&#039;sortedSetTest4&#039;, &#039;b&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 1);
				done();
			});
		});

		it(&#039;should return the rank sorted by the score and then the value (c)&#039;, (done) =&gt; {
			db.sortedSetRank(&#039;sortedSetTest4&#039;, &#039;c&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 4);
				done();
			});
		});
	});

	describe(&#039;sortedSetRevRank()&#039;, () =&gt; {
		it(&#039;should return falsy if sorted set doesnot exist&#039;, (done) =&gt; {
			db.sortedSetRevRank(&#039;doesnotexist&#039;, &#039;value1&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it(&#039;should return falsy if element isnt in sorted set&#039;, (done) =&gt; {
			db.sortedSetRevRank(&#039;sortedSetTest1&#039;, &#039;value5&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!rank, false);
				done();
			});
		});

		it(&#039;should return the rank of the element in the sorted set sorted by highest to lowest score&#039;, (done) =&gt; {
			db.sortedSetRevRank(&#039;sortedSetTest1&#039;, &#039;value1&#039;, function (err, rank) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(rank, 2);
				done();
			});
		});
	});

	describe(&#039;sortedSetsRanks()&#039;, () =&gt; {
		it(&#039;should return the ranks of values in sorted sets&#039;, (done) =&gt; {
			db.sortedSetsRanks([&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;], [&#039;value1&#039;, &#039;value4&#039;], function (err, ranks) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(ranks, [0, 1]);
				done();
			});
		});
	});

	describe(&#039;sortedSetRanks()&#039;, () =&gt; {
		it(&#039;should return the ranks of values in a sorted set&#039;, (done) =&gt; {
			db.sortedSetRanks(&#039;sortedSetTest1&#039;, [&#039;value2&#039;, &#039;value1&#039;, &#039;value3&#039;, &#039;value4&#039;], function (err, ranks) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(ranks, [1, 0, 2, null]);
				done();
			});
		});

		it(&#039;should return the ranks of values in a sorted set in reverse&#039;, (done) =&gt; {
			db.sortedSetRevRanks(&#039;sortedSetTest1&#039;, [&#039;value2&#039;, &#039;value1&#039;, &#039;value3&#039;, &#039;value4&#039;], function (err, ranks) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(ranks, [1, 2, 0, null]);
				done();
			});
		});
	});

	describe(&#039;sortedSetScore()&#039;, () =&gt; {
		it(&#039;should return falsy if sorted set does not exist&#039;, (done) =&gt; {
			db.sortedSetScore(&#039;doesnotexist&#039;, &#039;value1&#039;, function (err, score) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!score, false);
				assert.strictEqual(score, null);
				done();
			});
		});

		it(&#039;should return falsy if element is not in sorted set&#039;, (done) =&gt; {
			db.sortedSetScore(&#039;sortedSetTest1&#039;, &#039;value5&#039;, function (err, score) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.equal(!!score, false);
				assert.strictEqual(score, null);
				done();
			});
		});

		it(&#039;should return the score of an element&#039;, (done) =&gt; {
			db.sortedSetScore(&#039;sortedSetTest1&#039;, &#039;value2&#039;, function (err, score) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(score, 1.2);
				done();
			});
		});

		it(&#039;should not error if key is undefined&#039;, (done) =&gt; {
			db.sortedSetScore(undefined, 1, (err, score) =&gt; {
				assert.ifError(err);
				assert.strictEqual(score, null);
				done();
			});
		});

		it(&#039;should not error if value is undefined&#039;, (done) =&gt; {
			db.sortedSetScore(&#039;sortedSetTest1&#039;, undefined, (err, score) =&gt; {
				assert.ifError(err);
				assert.strictEqual(score, null);
				done();
			});
		});
	});

	describe(&#039;sortedSetsScore()&#039;, () =&gt; {
		it(&#039;should return the scores of value in sorted sets&#039;, (done) =&gt; {
			db.sortedSetsScore([&#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;, &#039;doesnotexist&#039;], &#039;value1&#039;, function (err, scores) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(scores, [1.1, 1, null]);
				done();
			});
		});

		it(&#039;should return scores even if some keys are undefined&#039;, (done) =&gt; {
			db.sortedSetsScore([&#039;sortedSetTest1&#039;, undefined, &#039;doesnotexist&#039;], &#039;value1&#039;, function (err, scores) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(scores, [1.1, null, null]);
				done();
			});
		});

		it(&#039;should return empty array if keys is empty array&#039;, (done) =&gt; {
			db.sortedSetsScore([], &#039;value1&#039;, function (err, scores) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(scores, []);
				done();
			});
		});
	});

	describe(&#039;sortedSetScores()&#039;, () =&gt; {
		before((done) =&gt; {
			db.sortedSetAdd(&#039;zeroScore&#039;, 0, &#039;value1&#039;, done);
		});

		it(&#039;should return 0 if score is 0&#039;, (done) =&gt; {
			db.sortedSetScores(&#039;zeroScore&#039;, [&#039;value1&#039;], (err, scores) =&gt; {
				assert.ifError(err);
				assert.strictEqual(scores[0], 0);
				done();
			});
		});

		it(&#039;should return the scores of value in sorted sets&#039;, (done) =&gt; {
			db.sortedSetScores(&#039;sortedSetTest1&#039;, [&#039;value2&#039;, &#039;value1&#039;, &#039;doesnotexist&#039;], function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, [1.2, 1.1, null]);
				done();
			});
		});

		it(&#039;should return scores even if some values are undefined&#039;, (done) =&gt; {
			db.sortedSetScores(&#039;sortedSetTest1&#039;, [&#039;value2&#039;, undefined, &#039;doesnotexist&#039;], function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, [1.2, null, null]);
				done();
			});
		});

		it(&#039;should return empty array if values is an empty array&#039;, (done) =&gt; {
			db.sortedSetScores(&#039;sortedSetTest1&#039;, [], function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, []);
				done();
			});
		});

		it(&#039;should return scores properly&#039;, (done) =&gt; {
			db.sortedSetsScore([&#039;zeroScore&#039;, &#039;sortedSetTest1&#039;, &#039;doesnotexist&#039;], &#039;value1&#039;, function (err, scores) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepStrictEqual(scores, [0, 1.1, null]);
				done();
			});
		});
	});

	describe(&#039;isSortedSetMember()&#039;, () =&gt; {
		before((done) =&gt; {
			db.sortedSetAdd(&#039;zeroscore&#039;, 0, &#039;itemwithzeroscore&#039;, done);
		});

		it(&#039;should return false if sorted set does not exist&#039;, (done) =&gt; {
			db.isSortedSetMember(&#039;doesnotexist&#039;, &#039;value1&#039;, function (err, isMember) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(isMember, false);
				done();
			});
		});

		it(&#039;should return false if element is not in sorted set&#039;, (done) =&gt; {
			db.isSortedSetMember(&#039;sorted2&#039;, &#039;value5&#039;, function (err, isMember) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.equal(isMember, false);
				done();
			});
		});

		it(&#039;should return true if element is in sorted set&#039;, (done) =&gt; {
			db.isSortedSetMember(&#039;sortedSetTest1&#039;, &#039;value2&#039;, function (err, isMember) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.strictEqual(isMember, true);
				done();
			});
		});

		it(&#039;should return true if element is in sorted set with score 0&#039;, (done) =&gt; {
			db.isSortedSetMember(&#039;zeroscore&#039;, &#039;itemwithzeroscore&#039;, (err, isMember) =&gt; {
				assert.ifError(err);
				assert.strictEqual(isMember, true);
				done();
			});
		});
	});

	describe(&#039;isSortedSetMembers()&#039;, () =&gt; {
		it(&#039;should return an array of booleans indicating membership&#039;, (done) =&gt; {
			db.isSortedSetMembers(&#039;sortedSetTest1&#039;, [&#039;value1&#039;, &#039;value2&#039;, &#039;value5&#039;], function (err, isMembers) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, [true, true, false]);
				done();
			});
		});

		it(&#039;should return true if element is in sorted set with score 0&#039;, (done) =&gt; {
			db.isSortedSetMembers(&#039;zeroscore&#039;, [&#039;itemwithzeroscore&#039;], function (err, isMembers) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, [true]);
				done();
			});
		});
	});

	describe(&#039;isMemberOfSortedSets&#039;, () =&gt; {
		it(&#039;should return true for members false for non members&#039;, (done) =&gt; {
			db.isMemberOfSortedSets([&#039;doesnotexist&#039;, &#039;sortedSetTest1&#039;, &#039;sortedSetTest2&#039;], &#039;value2&#039;, function (err, isMembers) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, [false, true, false]);
				done();
			});
		});

		it(&#039;should return empty array if keys is empty array&#039;, (done) =&gt; {
			db.isMemberOfSortedSets([], &#039;value2&#039;, function (err, isMembers) {
				assert.ifError(err);
				assert.equal(arguments.length, 2);
				assert.deepEqual(isMembers, []);
				done();
			});
		});
	});

	describe(&#039;getSortedSetsMembers&#039;, () =&gt; {
		it(&#039;should return members of a sorted set&#039;, async () =&gt; {
			const result = await db.getSortedSetMembers(&#039;sortedSetTest1&#039;);
			result.forEach((element) =&gt; {
				assert([&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;].includes(element));
			});
		});

		it(&#039;should return members of multiple sorted sets&#039;, (done) =&gt; {
			db.getSortedSetsMembers([&#039;doesnotexist&#039;, &#039;sortedSetTest1&#039;], function (err, sortedSets) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(sortedSets[0], []);
				sortedSets[0].forEach((element) =&gt; {
					assert.notEqual([&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;].indexOf(element), -1);
				});

				done();
			});
		});

		it(&#039;should return members of sorted set with scores&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;getSortedSetsMembersWithScores&#039;, [1, 2, 3], [&#039;v1&#039;, &#039;v2&#039;, &#039;v3&#039;]);
			const d = await db.getSortedSetMembersWithScores(&#039;getSortedSetsMembersWithScores&#039;);
			assert.deepEqual(d, [
				{ value: &#039;v1&#039;, score: 1 },
				{ value: &#039;v2&#039;, score: 2 },
				{ value: &#039;v3&#039;, score: 3 },
			]);
		});

		it(&#039;should return members of multiple sorted sets with scores&#039;, async () =&gt; {
			const d = await db.getSortedSetsMembersWithScores(
				[&#039;doesnotexist&#039;, &#039;getSortedSetsMembersWithScores&#039;]
			);
			assert.deepEqual(d[0], []);
			assert.deepEqual(d[1], [
				{ value: &#039;v1&#039;, score: 1 },
				{ value: &#039;v2&#039;, score: 2 },
				{ value: &#039;v3&#039;, score: 3 },
			]);
		});
	});

	describe(&#039;sortedSetUnionCard&#039;, () =&gt; {
		it(&#039;should return the number of elements in the union&#039;, (done) =&gt; {
			db.sortedSetUnionCard([&#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;], (err, count) =&gt; {
				assert.ifError(err);
				assert.equal(count, 3);
				done();
			});
		});
	});

	describe(&#039;getSortedSetUnion()&#039;, () =&gt; {
		it(&#039;should return an array of values from both sorted sets sorted by scores lowest to highest&#039;, (done) =&gt; {
			db.getSortedSetUnion({ sets: [&#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;], start: 0, stop: -1 }, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [&#039;value1&#039;, &#039;value2&#039;, &#039;value4&#039;]);
				done();
			});
		});

		it(&#039;should return an array of values and scores from both sorted sets sorted by scores lowest to highest&#039;, (done) =&gt; {
			db.getSortedSetUnion({ sets: [&#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;], start: 0, stop: -1, withScores: true }, function (err, data) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(data, [{ value: &#039;value1&#039;, score: 1 }, { value: &#039;value2&#039;, score: 2 }, { value: &#039;value4&#039;, score: 8 }]);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRevUnion()&#039;, () =&gt; {
		it(&#039;should return an array of values from both sorted sets sorted by scores highest to lowest&#039;, (done) =&gt; {
			db.getSortedSetRevUnion({ sets: [&#039;sortedSetTest2&#039;, &#039;sortedSetTest3&#039;], start: 0, stop: -1 }, function (err, values) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.deepEqual(values, [&#039;value4&#039;, &#039;value2&#039;, &#039;value1&#039;]);
				done();
			});
		});

		it(&#039;should return empty array if sets is empty&#039;, async () =&gt; {
			const result = await db.getSortedSetRevUnion({ sets: [], start: 0, stop: -1 });
			assert.deepStrictEqual(result, []);
		});
	});

	describe(&#039;sortedSetIncrBy()&#039;, () =&gt; {
		it(&#039;should create a sorted set with a field set to 1&#039;, (done) =&gt; {
			db.sortedSetIncrBy(&#039;sortedIncr&#039;, 1, &#039;field1&#039;, function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 1);
				db.sortedSetScore(&#039;sortedIncr&#039;, &#039;field1&#039;, (err, score) =&gt; {
					assert.equal(err, null);
					assert.strictEqual(score, 1);
					done();
				});
			});
		});

		it(&#039;should increment a field of a sorted set by 5&#039;, (done) =&gt; {
			db.sortedSetIncrBy(&#039;sortedIncr&#039;, 5, &#039;field1&#039;, function (err, newValue) {
				assert.equal(err, null);
				assert.equal(arguments.length, 2);
				assert.strictEqual(newValue, 6);
				db.sortedSetScore(&#039;sortedIncr&#039;, &#039;field1&#039;, (err, score) =&gt; {
					assert.equal(err, null);
					assert.strictEqual(score, 6);
					done();
				});
			});
		});

		it(&#039;should increment fields of sorted sets with a single call&#039;, async () =&gt; {
			const data = await db.sortedSetIncrByBulk([
				[&#039;sortedIncrBulk1&#039;, 1, &#039;value1&#039;],
				[&#039;sortedIncrBulk2&#039;, 2, &#039;value2&#039;],
				[&#039;sortedIncrBulk3&#039;, 3, &#039;value3&#039;],
				[&#039;sortedIncrBulk3&#039;, 4, &#039;value4&#039;],
			]);
			assert.deepStrictEqual(data, [1, 2, 3, 4]);
			assert.deepStrictEqual(
				await db.getSortedSetRangeWithScores(&#039;sortedIncrBulk1&#039;, 0, -1),
				[{ value: &#039;value1&#039;, score: 1 }],
			);
			assert.deepStrictEqual(
				await db.getSortedSetRangeWithScores(&#039;sortedIncrBulk2&#039;, 0, -1),
				[{ value: &#039;value2&#039;, score: 2 }],
			);
			assert.deepStrictEqual(
				await db.getSortedSetRangeWithScores(&#039;sortedIncrBulk3&#039;, 0, -1),
				[
					{ value: &#039;value3&#039;, score: 3 },
					{ value: &#039;value4&#039;, score: 4 },
				],
			);
		});

		it(&#039;should increment the same field&#039;, async () =&gt; {
			const data1 = await db.sortedSetIncrByBulk([
				[&#039;sortedIncrBulk5&#039;, 5, &#039;value5&#039;],
			]);

			const data2 = await db.sortedSetIncrByBulk([
				[&#039;sortedIncrBulk5&#039;, 5, &#039;value5&#039;],
			]);
			assert.deepStrictEqual(
				await db.getSortedSetRangeWithScores(&#039;sortedIncrBulk5&#039;, 0, -1),
				[
					{ value: &#039;value5&#039;, score: 10 },
				],
			);
		});
	});


	describe(&#039;sortedSetRemove()&#039;, () =&gt; {
		before((done) =&gt; {
			db.sortedSetAdd(&#039;sorted3&#039;, [1, 2], [&#039;value1&#039;, &#039;value2&#039;], done);
		});

		it(&#039;should remove an element from a sorted set&#039;, (done) =&gt; {
			db.sortedSetRemove(&#039;sorted3&#039;, &#039;value2&#039;, function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				db.isSortedSetMember(&#039;sorted3&#039;, &#039;value2&#039;, (err, isMember) =&gt; {
					assert.equal(err, null);
					assert.equal(isMember, false);
					done();
				});
			});
		});

		it(&#039;should not think the sorted set exists if the last element is removed&#039;, async () =&gt; {
			await db.sortedSetRemove(&#039;sorted3&#039;, &#039;value1&#039;);
			assert.strictEqual(await db.exists(&#039;sorted3&#039;), false);
		});

		it(&#039;should remove multiple values from multiple keys&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;multiTest1&#039;, [1, 2, 3, 4], [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;], (err) =&gt; {
				assert.ifError(err);
				db.sortedSetAdd(&#039;multiTest2&#039;, [3, 4, 5, 6], [&#039;three&#039;, &#039;four&#039;, &#039;five&#039;, &#039;six&#039;], (err) =&gt; {
					assert.ifError(err);
					db.sortedSetRemove([&#039;multiTest1&#039;, &#039;multiTest2&#039;], [&#039;two&#039;, &#039;three&#039;, &#039;four&#039;, &#039;five&#039;, &#039;doesnt exist&#039;], (err) =&gt; {
						assert.ifError(err);
						db.getSortedSetsMembers([&#039;multiTest1&#039;, &#039;multiTest2&#039;], (err, members) =&gt; {
							assert.ifError(err);
							assert.equal(members[0].length, 1);
							assert.equal(members[1].length, 1);
							assert.deepEqual(members, [[&#039;one&#039;], [&#039;six&#039;]]);
							done();
						});
					});
				});
			});
		});

		it(&#039;should remove value from multiple keys&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;multiTest3&#039;, [1, 2, 3, 4], [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;]);
			await db.sortedSetAdd(&#039;multiTest4&#039;, [3, 4, 5, 6], [&#039;three&#039;, &#039;four&#039;, &#039;five&#039;, &#039;six&#039;]);
			await db.sortedSetRemove([&#039;multiTest3&#039;, &#039;multiTest4&#039;], &#039;three&#039;);
			assert.deepStrictEqual(await db.getSortedSetRange(&#039;multiTest3&#039;, 0, -1), [&#039;one&#039;, &#039;two&#039;, &#039;four&#039;]);
			assert.deepStrictEqual(await db.getSortedSetRange(&#039;multiTest4&#039;, 0, -1), [&#039;four&#039;, &#039;five&#039;, &#039;six&#039;]);
		});

		it(&#039;should remove multiple values from multiple keys&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;multiTest5&#039;, [1], [&#039;one&#039;], (err) =&gt; {
				assert.ifError(err);
				db.sortedSetAdd(&#039;multiTest6&#039;, [2], [&#039;two&#039;], (err) =&gt; {
					assert.ifError(err);
					db.sortedSetAdd(&#039;multiTest7&#039;, [3], [333], (err) =&gt; {
						assert.ifError(err);
						db.sortedSetRemove([&#039;multiTest5&#039;, &#039;multiTest6&#039;, &#039;multiTest7&#039;], [&#039;one&#039;, &#039;two&#039;, 333], (err) =&gt; {
							assert.ifError(err);
							db.getSortedSetsMembers([&#039;multiTest5&#039;, &#039;multiTest6&#039;, &#039;multiTest7&#039;], (err, members) =&gt; {
								assert.ifError(err);
								assert.deepEqual(members, [[], [], []]);
								done();
							});
						});
					});
				});
			});
		});

		it(&#039;should not remove anything if values is empty array&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;removeNothing&#039;, [1, 2, 3], [&#039;val1&#039;, &#039;val2&#039;, &#039;val3&#039;], (err) =&gt; {
				assert.ifError(err);
				db.sortedSetRemove(&#039;removeNothing&#039;, [], (err) =&gt; {
					assert.ifError(err);
					db.getSortedSetRange(&#039;removeNothing&#039;, 0, -1, (err, data) =&gt; {
						assert.ifError(err);
						assert.deepStrictEqual(data, [&#039;val1&#039;, &#039;val2&#039;, &#039;val3&#039;]);
						done();
					});
				});
			});
		});

		it(&#039;should do a bulk remove&#039;, async () =&gt; {
			await db.sortedSetAddBulk([
				[&#039;bulkRemove1&#039;, 1, &#039;value1&#039;],
				[&#039;bulkRemove1&#039;, 2, &#039;value2&#039;],
				[&#039;bulkRemove2&#039;, 3, &#039;value2&#039;],
			]);
			await db.sortedSetRemoveBulk([
				[&#039;bulkRemove1&#039;, &#039;value1&#039;],
				[&#039;bulkRemove1&#039;, &#039;value2&#039;],
				[&#039;bulkRemove2&#039;, &#039;value2&#039;],
			]);
			const members = await db.getSortedSetsMembers([&#039;bulkRemove1&#039;, &#039;bulkRemove2&#039;]);
			assert.deepStrictEqual(members, [[], []]);
		});

		it(&#039;should not remove wrong elements in bulk remove&#039;, async () =&gt; {
			await db.sortedSetAddBulk([
				[&#039;bulkRemove4&#039;, 1, &#039;value1&#039;],
				[&#039;bulkRemove4&#039;, 2, &#039;value2&#039;],
				[&#039;bulkRemove4&#039;, 3, &#039;value4&#039;],
				[&#039;bulkRemove5&#039;, 1, &#039;value1&#039;],
				[&#039;bulkRemove5&#039;, 2, &#039;value2&#039;],
				[&#039;bulkRemove5&#039;, 3, &#039;value3&#039;],
			]);
			await db.sortedSetRemoveBulk([
				[&#039;bulkRemove4&#039;, &#039;value1&#039;],
				[&#039;bulkRemove4&#039;, &#039;value3&#039;],
				[&#039;bulkRemove5&#039;, &#039;value1&#039;],
				[&#039;bulkRemove5&#039;, &#039;value4&#039;],
			]);
			const members = await Promise.all([
				db.getSortedSetRange(&#039;bulkRemove4&#039;, 0, -1),
				db.getSortedSetRange(&#039;bulkRemove5&#039;, 0, -1),
			]);
			assert.deepStrictEqual(members[0], [&#039;value2&#039;, &#039;value4&#039;]);
			assert.deepStrictEqual(members[1], [&#039;value2&#039;, &#039;value3&#039;]);
		});
	});

	describe(&#039;sortedSetsRemove()&#039;, () =&gt; {
		before(async () =&gt; {
			await Promise.all([
				db.sortedSetAdd(&#039;sorted4&#039;, [1, 2], [&#039;value1&#039;, &#039;value2&#039;]),
				db.sortedSetAdd(&#039;sorted5&#039;, [1, 2], [&#039;value1&#039;, &#039;value3&#039;]),
			]);
		});

		it(&#039;should remove element from multiple sorted sets&#039;, (done) =&gt; {
			db.sortedSetsRemove([&#039;sorted4&#039;, &#039;sorted5&#039;], &#039;value1&#039;, function (err) {
				assert.equal(err, null);
				assert.equal(arguments.length, 1);
				db.sortedSetsScore([&#039;sorted4&#039;, &#039;sorted5&#039;], &#039;value1&#039;, (err, scores) =&gt; {
					assert.equal(err, null);
					assert.deepStrictEqual(scores, [null, null]);
					done();
				});
			});
		});
	});

	describe(&#039;sortedSetsRemoveRangeByScore()&#039;, () =&gt; {
		before((done) =&gt; {
			db.sortedSetAdd(&#039;sorted6&#039;, [1, 2, 3, 4, 5], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;, &#039;value4&#039;, &#039;value5&#039;], done);
		});

		it(&#039;should remove elements with scores between min max inclusive&#039;, (done) =&gt; {
			db.sortedSetsRemoveRangeByScore([&#039;sorted6&#039;], 4, 5, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRange(&#039;sorted6&#039;, 0, -1, (err, values) =&gt; {
					assert.ifError(err);
					assert.deepEqual(values, [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;]);
					done();
				});
			});
		});

		it(&#039;should remove elements with if strin score is passed in&#039;, (done) =&gt; {
			db.sortedSetAdd(&#039;sortedForRemove&#039;, [11, 22, 33], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;], (err) =&gt; {
				assert.ifError(err);
				db.sortedSetsRemoveRangeByScore([&#039;sortedForRemove&#039;], &#039;22&#039;, &#039;22&#039;, (err) =&gt; {
					assert.ifError(err);
					db.getSortedSetRange(&#039;sortedForRemove&#039;, 0, -1, (err, values) =&gt; {
						assert.ifError(err);
						assert.deepEqual(values, [&#039;value1&#039;, &#039;value3&#039;]);
						done();
					});
				});
			});
		});
	});

	describe(&#039;getSortedSetIntersect&#039;, () =&gt; {
		before(async () =&gt; {
			await Promise.all([
				db.sortedSetAdd(&#039;interSet1&#039;, [1, 2, 3], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;]),
				db.sortedSetAdd(&#039;interSet2&#039;, [4, 5, 6], [&#039;value2&#039;, &#039;value3&#039;, &#039;value5&#039;]),
			]);
		});

		it(&#039;should return the intersection of two sets&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet2&#039;],
				start: 0,
				stop: -1,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual([&#039;value2&#039;, &#039;value3&#039;], data);
				done();
			});
		});

		it(&#039;should return the intersection of two sets with scores&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet2&#039;],
				start: 0,
				stop: -1,
				withScores: true,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual([{ value: &#039;value2&#039;, score: 6 }, { value: &#039;value3&#039;, score: 8 }], data);
				done();
			});
		});

		it(&#039;should return the reverse intersection of two sets&#039;, (done) =&gt; {
			db.getSortedSetRevIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet2&#039;],
				start: 0,
				stop: 2,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual([&#039;value3&#039;, &#039;value2&#039;], data);
				done();
			});
		});

		it(&#039;should return the intersection of two sets with scores aggregate MIN&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet2&#039;],
				start: 0,
				stop: -1,
				withScores: true,
				aggregate: &#039;MIN&#039;,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual([{ value: &#039;value2&#039;, score: 2 }, { value: &#039;value3&#039;, score: 3 }], data);
				done();
			});
		});

		it(&#039;should return the intersection of two sets with scores aggregate MAX&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet2&#039;],
				start: 0,
				stop: -1,
				withScores: true,
				aggregate: &#039;MAX&#039;,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual([{ value: &#039;value2&#039;, score: 4 }, { value: &#039;value3&#039;, score: 5 }], data);
				done();
			});
		});

		it(&#039;should return the intersection with scores modified by weights&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet2&#039;],
				start: 0,
				stop: -1,
				withScores: true,
				weights: [1, 0.5],
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual([{ value: &#039;value2&#039;, score: 4 }, { value: &#039;value3&#039;, score: 5.5 }], data);
				done();
			});
		});

		it(&#039;should return empty array if sets do not exist&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet10&#039;, &#039;interSet12&#039;],
				start: 0,
				stop: -1,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.equal(data.length, 0);
				done();
			});
		});

		it(&#039;should return empty array if one set does not exist&#039;, (done) =&gt; {
			db.getSortedSetIntersect({
				sets: [&#039;interSet1&#039;, &#039;interSet12&#039;],
				start: 0,
				stop: -1,
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.equal(data.length, 0);
				done();
			});
		});

		it(&#039;should return correct results if sorting by different zset&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;bigzset&#039;, [1, 2, 3, 4, 5, 6], [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;]);
			await db.sortedSetAdd(&#039;smallzset&#039;, [3, 2, 1], [&#039;b&#039;, &#039;e&#039;, &#039;g&#039;]);
			const data = await db.getSortedSetRevIntersect({
				sets: [&#039;bigzset&#039;, &#039;smallzset&#039;],
				start: 0,
				stop: 19,
				weights: [1, 0],
				withScores: true,
			});
			assert.deepStrictEqual(data, [{ value: &#039;e&#039;, score: 5 }, { value: &#039;b&#039;, score: 2 }]);
			const data2 = await db.getSortedSetRevIntersect({
				sets: [&#039;bigzset&#039;, &#039;smallzset&#039;],
				start: 0,
				stop: 19,
				weights: [0, 1],
				withScores: true,
			});
			assert.deepStrictEqual(data2, [{ value: &#039;b&#039;, score: 3 }, { value: &#039;e&#039;, score: 2 }]);
		});

		it(&#039;should return correct results when intersecting big zsets&#039;, async () =&gt; {
			const scores = [];
			const values = [];
			for (let i = 0; i &lt; 30000; i++) {
				scores.push((i + 1) * 1000);
				values.push(String(i + 1));
			}
			await db.sortedSetAdd(&#039;verybigzset&#039;, scores, values);

			scores.length = 0;
			values.length = 0;
			for (let i = 15000; i &lt; 45000; i++) {
				scores.push((i + 1) * 1000);
				values.push(String(i + 1));
			}
			await db.sortedSetAdd(&#039;anotherbigzset&#039;, scores, values);
			const data = await db.getSortedSetRevIntersect({
				sets: [&#039;verybigzset&#039;, &#039;anotherbigzset&#039;],
				start: 0,
				stop: 3,
				weights: [1, 0],
				withScores: true,
			});
			assert.deepStrictEqual(data, [
				{ value: &#039;30000&#039;, score: 30000000 },
				{ value: &#039;29999&#039;, score: 29999000 },
				{ value: &#039;29998&#039;, score: 29998000 },
				{ value: &#039;29997&#039;, score: 29997000 },
			]);
		});
	});

	describe(&#039;sortedSetIntersectCard&#039;, () =&gt; {
		before(async () =&gt; {
			await Promise.all([
				db.sortedSetAdd(&#039;interCard1&#039;, [0, 0, 0], [&#039;value1&#039;, &#039;value2&#039;, &#039;value3&#039;]),
				db.sortedSetAdd(&#039;interCard2&#039;, [0, 0, 0], [&#039;value2&#039;, &#039;value3&#039;, &#039;value4&#039;]),
				db.sortedSetAdd(&#039;interCard3&#039;, [0, 0, 0], [&#039;value3&#039;, &#039;value4&#039;, &#039;value5&#039;]),
				db.sortedSetAdd(&#039;interCard4&#039;, [0, 0, 0], [&#039;value4&#039;, &#039;value5&#039;, &#039;value6&#039;]),
			]);
		});

		it(&#039;should return # of elements in intersection&#039;, (done) =&gt; {
			db.sortedSetIntersectCard([&#039;interCard1&#039;, &#039;interCard2&#039;, &#039;interCard3&#039;], (err, count) =&gt; {
				assert.ifError(err);
				assert.strictEqual(count, 1);
				done();
			});
		});

		it(&#039;should return 0 if intersection is empty&#039;, (done) =&gt; {
			db.sortedSetIntersectCard([&#039;interCard1&#039;, &#039;interCard4&#039;], (err, count) =&gt; {
				assert.ifError(err);
				assert.strictEqual(count, 0);
				done();
			});
		});
	});

	describe(&#039;getSortedSetRangeByLex&#039;, () =&gt; {
		it(&#039;should return an array of all values&#039;, (done) =&gt; {
			db.getSortedSetRangeByLex(&#039;sortedSetLex&#039;, &#039;-&#039;, &#039;+&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;]);
				done();
			});
		});

		it(&#039;should return an array with an inclusive range by default&#039;, (done) =&gt; {
			db.getSortedSetRangeByLex(&#039;sortedSetLex&#039;, &#039;a&#039;, &#039;d&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;]);
				done();
			});
		});

		it(&#039;should return an array with an inclusive range&#039;, (done) =&gt; {
			db.getSortedSetRangeByLex(&#039;sortedSetLex&#039;, &#039;[a&#039;, &#039;[d&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;]);
				done();
			});
		});

		it(&#039;should return an array with an exclusive range&#039;, (done) =&gt; {
			db.getSortedSetRangeByLex(&#039;sortedSetLex&#039;, &#039;(a&#039;, &#039;(d&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;b&#039;, &#039;c&#039;]);
				done();
			});
		});

		it(&#039;should return an array limited to the first two values&#039;, (done) =&gt; {
			db.getSortedSetRangeByLex(&#039;sortedSetLex&#039;, &#039;-&#039;, &#039;+&#039;, 0, 2, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;a&#039;, &#039;b&#039;]);
				done();
			});
		});

		it(&#039;should return correct result&#039;, async () =&gt; {
			await db.sortedSetAdd(&#039;sortedSetLexSearch&#039;, [0, 0, 0], [&#039;baris:usakli:1&#039;, &#039;baris usakli:2&#039;, &#039;baris soner:3&#039;]);
			const query = &#039;baris:&#039;;
			const min = query;
			const max = query.slice(0, -1) + String.fromCharCode(query.charCodeAt(query.length - 1) + 1);
			const result = await db.getSortedSetRangeByLex(&#039;sortedSetLexSearch&#039;, min, max, 0, -1);
			assert.deepStrictEqual(result, [&#039;baris:usakli:1&#039;]);
		});
	});

	describe(&#039;getSortedSetRevRangeByLex&#039;, () =&gt; {
		it(&#039;should return an array of all values reversed&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByLex(&#039;sortedSetLex&#039;, &#039;+&#039;, &#039;-&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;d&#039;, &#039;c&#039;, &#039;b&#039;, &#039;a&#039;]);
				done();
			});
		});

		it(&#039;should return an array with an inclusive range by default reversed&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByLex(&#039;sortedSetLex&#039;, &#039;d&#039;, &#039;a&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;d&#039;, &#039;c&#039;, &#039;b&#039;, &#039;a&#039;]);
				done();
			});
		});

		it(&#039;should return an array with an inclusive range reversed&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByLex(&#039;sortedSetLex&#039;, &#039;[d&#039;, &#039;[a&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;d&#039;, &#039;c&#039;, &#039;b&#039;, &#039;a&#039;]);
				done();
			});
		});

		it(&#039;should return an array with an exclusive range reversed&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByLex(&#039;sortedSetLex&#039;, &#039;(d&#039;, &#039;(a&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;c&#039;, &#039;b&#039;]);
				done();
			});
		});

		it(&#039;should return an array limited to the first two values reversed&#039;, (done) =&gt; {
			db.getSortedSetRevRangeByLex(&#039;sortedSetLex&#039;, &#039;+&#039;, &#039;-&#039;, 0, 2, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, [&#039;d&#039;, &#039;c&#039;]);
				done();
			});
		});
	});

	describe(&#039;sortedSetLexCount&#039;, () =&gt; {
		it(&#039;should return the count of all values&#039;, (done) =&gt; {
			db.sortedSetLexCount(&#039;sortedSetLex&#039;, &#039;-&#039;, &#039;+&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(data, 4);
				done();
			});
		});

		it(&#039;should return the count with an inclusive range by default&#039;, (done) =&gt; {
			db.sortedSetLexCount(&#039;sortedSetLex&#039;, &#039;a&#039;, &#039;d&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(data, 4);
				done();
			});
		});

		it(&#039;should return the count with an inclusive range&#039;, (done) =&gt; {
			db.sortedSetLexCount(&#039;sortedSetLex&#039;, &#039;[a&#039;, &#039;[d&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(data, 4);
				done();
			});
		});

		it(&#039;should return the count with an exclusive range&#039;, (done) =&gt; {
			db.sortedSetLexCount(&#039;sortedSetLex&#039;, &#039;(a&#039;, &#039;(d&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.strictEqual(data, 2);
				done();
			});
		});
	});

	describe(&#039;sortedSetRemoveRangeByLex&#039;, () =&gt; {
		before((done) =&gt; {
			db.sortedSetAdd(&#039;sortedSetLex2&#039;, [0, 0, 0, 0, 0, 0, 0], [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;, &#039;g&#039;], done);
		});

		it(&#039;should remove an inclusive range by default&#039;, (done) =&gt; {
			db.sortedSetRemoveRangeByLex(&#039;sortedSetLex2&#039;, &#039;a&#039;, &#039;b&#039;, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex(&#039;sortedSetLex2&#039;, &#039;-&#039;, &#039;+&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepEqual(data, [&#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;, &#039;g&#039;]);
					done();
				});
			});
		});

		it(&#039;should remove an inclusive range&#039;, (done) =&gt; {
			db.sortedSetRemoveRangeByLex(&#039;sortedSetLex2&#039;, &#039;[c&#039;, &#039;[d&#039;, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex(&#039;sortedSetLex2&#039;, &#039;-&#039;, &#039;+&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepEqual(data, [&#039;e&#039;, &#039;f&#039;, &#039;g&#039;]);
					done();
				});
			});
		});

		it(&#039;should remove an exclusive range&#039;, (done) =&gt; {
			db.sortedSetRemoveRangeByLex(&#039;sortedSetLex2&#039;, &#039;(e&#039;, &#039;(g&#039;, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex(&#039;sortedSetLex2&#039;, &#039;-&#039;, &#039;+&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepEqual(data, [&#039;e&#039;, &#039;g&#039;]);
					done();
				});
			});
		});

		it(&#039;should remove all values&#039;, (done) =&gt; {
			db.sortedSetRemoveRangeByLex(&#039;sortedSetLex2&#039;, &#039;-&#039;, &#039;+&#039;, function (err) {
				assert.ifError(err);
				assert.equal(arguments.length, 1);
				db.getSortedSetRangeByLex(&#039;sortedSetLex2&#039;, &#039;-&#039;, &#039;+&#039;, (err, data) =&gt; {
					assert.ifError(err);
					assert.deepEqual(data, []);
					done();
				});
			});
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
