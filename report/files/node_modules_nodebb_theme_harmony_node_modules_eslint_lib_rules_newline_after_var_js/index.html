<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/newline-after-var.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/newline-after-var.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">308</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">28.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.39</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to check empty newline after &quot;var&quot; statement
 * @author Gopal Venkatesan
 * @deprecated in ESLint v4.0.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;layout&quot;,

		docs: {
			description:
				&quot;Require or disallow an empty line after variable declarations&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/newline-after-var&quot;,
		},
		schema: [
			{
				enum: [&quot;never&quot;, &quot;always&quot;],
			},
		],
		fixable: &quot;whitespace&quot;,
		messages: {
			expected: &quot;Expected blank line after variable declarations.&quot;,
			unexpected: &quot;Unexpected blank line after variable declarations.&quot;,
		},

		deprecated: {
			message: &quot;The rule was replaced with a more general rule.&quot;,
			url: &quot;https://eslint.org/blog/2017/06/eslint-v4.0.0-released/&quot;,
			deprecatedSince: &quot;4.0.0&quot;,
			availableUntil: null,
			replacedBy: [
				{
					message: &quot;The new rule moved to a plugin.&quot;,
					url: &quot;https://eslint.org/docs/latest/rules/padding-line-between-statements#examples&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin-js&quot;,
						url: &quot;https://eslint.style/packages/js&quot;,
					},
					rule: {
						name: &quot;padding-line-between-statements&quot;,
						url: &quot;https://eslint.style/rules/js/padding-line-between-statements&quot;,
					},
				},
			],
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		// Default `mode` to &quot;always&quot;.
		const mode = context.options[0] === &quot;never&quot; ? &quot;never&quot; : &quot;always&quot;;

		// Cache starting and ending line numbers of comments for faster lookup
		const commentEndLine = sourceCode
			.getAllComments()
			.reduce((result, token) =&gt; {
				result[token.loc.start.line] = token.loc.end.line;
				return result;
			}, {});

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		/**
		 * Gets a token from the given node to compare line to the next statement.
		 *
		 * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.
		 *
		 * - The last token is semicolon.
		 * - The semicolon is on a different line from the previous token of the semicolon.
		 *
		 * This behavior would address semicolon-less style code. e.g.:
		 *
		 *     var foo = 1
		 *
		 *     ;(a || b).doSomething()
		 * @param {ASTNode} node The node to get.
		 * @returns {Token} The token to compare line to the next statement.
		 */
		function getLastToken(node) {
			const lastToken = sourceCode.getLastToken(node);

			if (lastToken.type === &quot;Punctuator&quot; &amp;&amp; lastToken.value === &quot;;&quot;) {
				const prevToken = sourceCode.getTokenBefore(lastToken);

				if (prevToken.loc.end.line !== lastToken.loc.start.line) {
					return prevToken;
				}
			}

			return lastToken;
		}

		/**
		 * Determine if provided keyword is a variable declaration
		 * @private
		 * @param {string} keyword keyword to test
		 * @returns {boolean} True if `keyword` is a type of var
		 */
		function isVar(keyword) {
			return (
				keyword === &quot;var&quot; || keyword === &quot;let&quot; || keyword === &quot;const&quot;
			);
		}

		/**
		 * Determine if provided keyword is a variant of for specifiers
		 * @private
		 * @param {string} keyword keyword to test
		 * @returns {boolean} True if `keyword` is a variant of for specifier
		 */
		function isForTypeSpecifier(keyword) {
			return (
				keyword === &quot;ForStatement&quot; ||
				keyword === &quot;ForInStatement&quot; ||
				keyword === &quot;ForOfStatement&quot;
			);
		}

		/**
		 * Determine if provided keyword is an export specifiers
		 * @private
		 * @param {string} nodeType nodeType to test
		 * @returns {boolean} True if `nodeType` is an export specifier
		 */
		function isExportSpecifier(nodeType) {
			return (
				nodeType === &quot;ExportNamedDeclaration&quot; ||
				nodeType === &quot;ExportSpecifier&quot; ||
				nodeType === &quot;ExportDefaultDeclaration&quot; ||
				nodeType === &quot;ExportAllDeclaration&quot;
			);
		}

		/**
		 * Determine if provided node is the last of their parent block.
		 * @private
		 * @param {ASTNode} node node to test
		 * @returns {boolean} True if `node` is last of their parent block.
		 */
		function isLastNode(node) {
			const token = sourceCode.getTokenAfter(node);

			return (
				!token || (token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;}&quot;)
			);
		}

		/**
		 * Gets the last line of a group of consecutive comments
		 * @param {number} commentStartLine The starting line of the group
		 * @returns {number} The number of the last comment line of the group
		 */
		function getLastCommentLineOfBlock(commentStartLine) {
			const currentCommentEnd = commentEndLine[commentStartLine];

			return commentEndLine[currentCommentEnd + 1]
				? getLastCommentLineOfBlock(currentCommentEnd + 1)
				: currentCommentEnd;
		}

		/**
		 * Determine if a token starts more than one line after a comment ends
		 * @param {token} token The token being checked
		 * @param {integer} commentStartLine The line number on which the comment starts
		 * @returns {boolean} True if `token` does not start immediately after a comment
		 */
		function hasBlankLineAfterComment(token, commentStartLine) {
			return (
				token.loc.start.line &gt;
				getLastCommentLineOfBlock(commentStartLine) + 1
			);
		}

		/**
		 * Checks that a blank line exists after a variable declaration when mode is
		 * set to &quot;always&quot;, or checks that there is no blank line when mode is set
		 * to &quot;never&quot;
		 * @private
		 * @param {ASTNode} node `VariableDeclaration` node to test
		 * @returns {void}
		 */
		function checkForBlankLine(node) {
			/*
			 * lastToken is the last token on the node&#039;s line. It will usually also be the last token of the node, but it will
			 * sometimes be second-last if there is a semicolon on a different line.
			 */
			const lastToken = getLastToken(node),
				/*
				 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken
				 * is the last token of the node.
				 */
				nextToken =
					lastToken === sourceCode.getLastToken(node)
						? sourceCode.getTokenAfter(node)
						: sourceCode.getLastToken(node),
				nextLineNum = lastToken.loc.end.line + 1;

			// Ignore if there is no following statement
			if (!nextToken) {
				return;
			}

			// Ignore if parent of node is a for variant
			if (isForTypeSpecifier(node.parent.type)) {
				return;
			}

			// Ignore if parent of node is an export specifier
			if (isExportSpecifier(node.parent.type)) {
				return;
			}

			/*
			 * Some coding styles use multiple `var` statements, so do nothing if
			 * the next token is a `var` statement.
			 */
			if (nextToken.type === &quot;Keyword&quot; &amp;&amp; isVar(nextToken.value)) {
				return;
			}

			// Ignore if it is last statement in a block
			if (isLastNode(node)) {
				return;
			}

			// Next statement is not a `var`...
			const noNextLineToken = nextToken.loc.start.line &gt; nextLineNum;
			const hasNextLineComment =
				typeof commentEndLine[nextLineNum] !== &quot;undefined&quot;;

			if (mode === &quot;never&quot; &amp;&amp; noNextLineToken &amp;&amp; !hasNextLineComment) {
				context.report({
					node,
					messageId: &quot;unexpected&quot;,
					fix(fixer) {
						const linesBetween = sourceCode
							.getText()
							.slice(lastToken.range[1], nextToken.range[0])
							.split(astUtils.LINEBREAK_MATCHER);

						return fixer.replaceTextRange(
							[lastToken.range[1], nextToken.range[0]],
							`${linesBetween.slice(0, -1).join(&quot;&quot;)}\n${linesBetween.at(-1)}`,
						);
					},
				});
			}

			// Token on the next line, or comment without blank line
			if (
				mode === &quot;always&quot; &amp;&amp;
				(!noNextLineToken ||
					(hasNextLineComment &amp;&amp;
						!hasBlankLineAfterComment(nextToken, nextLineNum)))
			) {
				context.report({
					node,
					messageId: &quot;expected&quot;,
					fix(fixer) {
						if (
							(noNextLineToken
								? getLastCommentLineOfBlock(nextLineNum)
								: lastToken.loc.end.line) ===
							nextToken.loc.start.line
						) {
							return fixer.insertTextBefore(nextToken, &quot;\n\n&quot;);
						}

						return fixer.insertTextBeforeRange(
							[
								nextToken.range[0] - nextToken.loc.start.column,
								nextToken.range[1],
							],
							&quot;\n&quot;,
						);
					},
				});
			}
		}

		//--------------------------------------------------------------------------
		// Public
		//--------------------------------------------------------------------------

		return {
			VariableDeclaration: checkForBlankLine,
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
