<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/redisearch/lib/redis-search.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/redisearch/lib/redis-search.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">264</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">78.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.72</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const redis = require(&#039;ioredis&#039;);
const natural = require(&#039;natural&#039;);
const metaphone = natural.Metaphone.process;
const stem = natural.PorterStemmer.stem;
const stopwords = natural.stopwords;
let redisClient;

const commands = {
  and: &#039;zinterstore&#039;,
  or: &#039;zunionstore&#039;
};

exports.createSearch = function(namespace, client) {
  if (!namespace) {
    throw new Error(&#039;createSearch requires a namespace&#039;);
  }
  return new Search(namespace, client);
};

function Search(namespace, client) {
  this.namespace = namespace;
  redisClient = client || redis.createClient();
}

Search.prototype.index = async function(data, id) {
  var namespace = this.namespace;
  if (!namespace) {
    throw new Error(&#039;index needs a namespace&#039;);
  }

  await indexData(namespace, data, id);
};

Search.prototype.query = async function (data, start, stop) {
  var namespace = this.namespace;
  start = start || 0;
  stop = stop || -1;

  var keyMap = getKeys(namespace, data.query);
  var cmds = [];
  var tmpKeys = [];

  for(var index in keyMap) {
    if (keyMap.hasOwnProperty(index)) {
      var keys = keyMap[index];
      if (Array.isArray(keys)) {
        if (keys.length === 1) {
          tmpKeys.push(keys[0]);
        } else if (keys.length &gt; 1) {
          var tmpKeyName = namespace + &#039;:&#039; + index + &#039;:temp&#039;;
          tmpKeys.push(tmpKeyName);
          var command = commands.or;
          if (index === &#039;content&#039;) {
            command = commands.and;
            if (data.matchWords === &#039;any&#039;) {
              command = commands.or;
            }
          }
          cmds.push([command, tmpKeyName, keys.length].concat(keys));
        }
      }
    }
  }

  if (!tmpKeys.length) {
    return [];
  }

  var finalKey = namespace + &#039;:tempFinal&#039;;
  if (tmpKeys.length === 1) {
    finalKey = tmpKeys[0];
  } else {
    cmds.push([commands.and, finalKey, tmpKeys.length].concat(tmpKeys));
  }

  var resultIndex = cmds.length;
  cmds.push([&#039;zrevrange&#039;, finalKey, start, stop]);

  tmpKeys = tmpKeys.concat([finalKey]);
  tmpKeys.forEach(function(tmpKey) {
    if (tmpKey.indexOf(&#039;:temp&#039;) !== -1) {
      cmds.push([&#039;zremrangebyrank&#039;, tmpKey, start, stop]);
    }
  });

  const ids = await redisClient.multi(cmds).exec();
  const errRes = ids[resultIndex];
  if (errRes[0]) {
    throw new Error(String(errRes[0]));
  }
  return errRes[1];
};

Search.prototype.count = async function (namespace) {
  return await redisClient.scard(`${namespace}:ids`);
};

function getKeys(namespace, data) {
  var keys = {};
  for (var index in data) {
    if (data.hasOwnProperty(index)) {
      keys[index] = indexToSets(namespace, index, data);
    }
  }
  return keys;
}

function indexToSets(namespace, index, data) {
  var sets = [];
  if (index === &#039;content&#039;) {
    if (!data.content) {
      return keys;
    }
    var words = toStem(stripStopWords(toWords(data.content)));
    var keys = metaphoneKeys(namespace, index, words);
    sets = sets.concat(keys);
  } else {
    if (Array.isArray(data[index])) {
      data[index].forEach(function(indexValue) {
        sets.push(namespace + &#039;:&#039; + index + &#039;:&#039; + indexValue + &#039;:id&#039;);
      });
    } else {
      sets.push(namespace + &#039;:&#039; + index + &#039;:&#039; + data[index] + &#039;:id&#039;);
    }
  }

  return sets;
}

Search.prototype.remove = async function(id) {
  var namespace = this.namespace;

  const indices = await getIndices(namespace, id);
  await Promise.all(indices.map(index =&gt; removeIndex(namespace, id, index)));
  await redisClient.del(namespace + &#039;:id:&#039; + id + &#039;:indices&#039;);
  return this;
};

async function removeIndex(namespace, id, index) {
  const indexValues = await redisClient.smembers(namespace + &#039;:id:&#039; + id + &#039;:&#039; + index);
  var multi = redisClient.multi();
  multi.del(namespace + &#039;:id:&#039; + id + &#039;:&#039; + index);

  indexValues.forEach(function(indexValue) {
    multi.zrem(namespace + &#039;:&#039; + index + &#039;:&#039; + indexValue + &#039;:id&#039;, id);
  });

  return await multi.exec();
}

async function getIndices(namespace, id) {
  return await redisClient.smembers(namespace + &#039;:id:&#039; + id + &#039;:indices&#039;);
}

async function indexData(namespace, data, id) {
  var cmds = [];
  for(var index in data) {
    if (data.hasOwnProperty(index)) {
      addIndexCommands(cmds, namespace, index, data[index], id);
    }
  }
  return await redisClient.multi(cmds).exec();
}

function addIndexCommands(cmds, namespace, index, indexValue, id) {
  if (!indexValue || !index || !id) {
    return;
  }
  if (index === &#039;content&#039;) {
    var words = toStem(stripStopWords(toWords(indexValue)));
    var counts = countWords(words);
    var map = metaphoneMap(words);
    var keys = Object.keys(map);

    keys.forEach(function(word) {
      cmds.push([&#039;zadd&#039;, namespace + &#039;:&#039; + index + &#039;:&#039; + map[word] + &#039;:id&#039;, counts[word], id]);
      cmds.push([&#039;sadd&#039;, namespace + &#039;:id:&#039; + id + &#039;:&#039; + index, map[word]]);
    });
  } else {
    cmds.push([&#039;zadd&#039;, namespace + &#039;:&#039; + index + &#039;:&#039; + indexValue + &#039;:id&#039;, indexValue, id]);
    cmds.push([&#039;sadd&#039;, namespace + &#039;:id:&#039; + id + &#039;:&#039; + index, indexValue]);
  }
  cmds.push([&#039;sadd&#039;, namespace + &#039;:id:&#039; + id + &#039;:indices&#039;, index]);
  cmds.push([&#039;sadd&#039;, namespace + &#039;:ids&#039;, id]);
}

function toWords(content) {
  return String(content).match(/[\p{L}_]+/ug);
}

function metaphoneKeys(key, index, words) {
  return metaphoneArray(words).map(function(c) {
    return key + &#039;:&#039; + index + &#039;:&#039; + c + &#039;:id&#039;;
  });
}

function metaphoneArray(words) {
  var arr = [];
  var constant;

  if (!words) {
    return arr;
  }

  for (var i = 0, len = words.length; i &lt; len; ++i) {
    constant = metaphone(words[i]);
    if (!~arr.indexOf(constant)) {
      arr.push(constant);
    }
  }

  return arr;
}

function metaphoneMap(words) {
  var obj = {};
  if (!words) {
    return obj;
  }
  for (var i = 0, len = words.length; i &lt; len; ++i) {
    obj[words[i]] = metaphone(words[i]);
  }
  return obj;
}

function toStem(words) {
  var ret = [];
  if (!words) {
    return ret;
  }
  for (var i = 0, len = words.length; i &lt; len; ++i) {
    ret.push(stem(words[i]));
  }
  return ret;
}

function stripStopWords(words){
  var ret = [];
  if (!words) {
    return ret;
  }
  for (var i = 0, len = words.length; i &lt; len; ++i) {
    if (stopwords.indexOf(words[i]) !== -1) {
      continue;
    }
    ret.push(words[i]);
  }
  return ret;
}

function countWords(words) {
  var obj = {};
  if (!words) {
    return obj;
  }
  for (var i = 0, len = words.length; i &lt; len; ++i) {
    obj[words[i]] = (obj[words[i]] || 0) + 1;
  }
  return obj;
}

</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
