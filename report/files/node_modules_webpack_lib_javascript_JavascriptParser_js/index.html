<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/javascript/JavascriptParser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/javascript/JavascriptParser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">5093</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">271.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">48.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { Parser: AcornParser, tokTypes } = require(&quot;acorn&quot;);
const { SyncBailHook, HookMap } = require(&quot;tapable&quot;);
const vm = require(&quot;vm&quot;);
const Parser = require(&quot;../Parser&quot;);
const StackedMap = require(&quot;../util/StackedMap&quot;);
const binarySearchBounds = require(&quot;../util/binarySearchBounds&quot;);
const {
	webpackCommentRegExp,
	createMagicCommentContext
} = require(&quot;../util/magicComment&quot;);
const memoize = require(&quot;../util/memoize&quot;);
const BasicEvaluatedExpression = require(&quot;./BasicEvaluatedExpression&quot;);

/** @typedef {import(&quot;acorn&quot;).Options} AcornOptions */
/** @typedef {import(&quot;estree&quot;).AssignmentExpression} AssignmentExpression */
/** @typedef {import(&quot;estree&quot;).BinaryExpression} BinaryExpression */
/** @typedef {import(&quot;estree&quot;).BlockStatement} BlockStatement */
/** @typedef {import(&quot;estree&quot;).SequenceExpression} SequenceExpression */
/** @typedef {import(&quot;estree&quot;).CallExpression} CallExpression */
/** @typedef {import(&quot;estree&quot;).BaseCallExpression} BaseCallExpression */
/** @typedef {import(&quot;estree&quot;).StaticBlock} StaticBlock */
/** @typedef {import(&quot;estree&quot;).ClassDeclaration} ClassDeclaration */
/** @typedef {import(&quot;estree&quot;).ForStatement} ForStatement */
/** @typedef {import(&quot;estree&quot;).SwitchStatement} SwitchStatement */
/** @typedef {import(&quot;estree&quot;).ClassExpression} ClassExpression */
/** @typedef {import(&quot;estree&quot;).Comment} Comment */
/** @typedef {import(&quot;estree&quot;).ConditionalExpression} ConditionalExpression */
/** @typedef {import(&quot;estree&quot;).Declaration} Declaration */
/** @typedef {import(&quot;estree&quot;).PrivateIdentifier} PrivateIdentifier */
/** @typedef {import(&quot;estree&quot;).PropertyDefinition} PropertyDefinition */
/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;estree&quot;).Identifier} Identifier */
/** @typedef {import(&quot;estree&quot;).VariableDeclaration} VariableDeclaration */
/** @typedef {import(&quot;estree&quot;).IfStatement} IfStatement */
/** @typedef {import(&quot;estree&quot;).LabeledStatement} LabeledStatement */
/** @typedef {import(&quot;estree&quot;).Literal} Literal */
/** @typedef {import(&quot;estree&quot;).LogicalExpression} LogicalExpression */
/** @typedef {import(&quot;estree&quot;).ChainExpression} ChainExpression */
/** @typedef {import(&quot;estree&quot;).MemberExpression} MemberExpression */
/** @typedef {import(&quot;estree&quot;).YieldExpression} YieldExpression */
/** @typedef {import(&quot;estree&quot;).MetaProperty} MetaProperty */
/** @typedef {import(&quot;estree&quot;).Property} Property */
/** @typedef {import(&quot;estree&quot;).AssignmentPattern} AssignmentPattern */
/** @typedef {import(&quot;estree&quot;).ChainElement} ChainElement */
/** @typedef {import(&quot;estree&quot;).Pattern} Pattern */
/** @typedef {import(&quot;estree&quot;).UpdateExpression} UpdateExpression */
/** @typedef {import(&quot;estree&quot;).ObjectExpression} ObjectExpression */
/** @typedef {import(&quot;estree&quot;).UnaryExpression} UnaryExpression */
/** @typedef {import(&quot;estree&quot;).ArrayExpression} ArrayExpression */
/** @typedef {import(&quot;estree&quot;).ArrayPattern} ArrayPattern */
/** @typedef {import(&quot;estree&quot;).AwaitExpression} AwaitExpression */
/** @typedef {import(&quot;estree&quot;).ThisExpression} ThisExpression */
/** @typedef {import(&quot;estree&quot;).RestElement} RestElement */
/** @typedef {import(&quot;estree&quot;).ObjectPattern} ObjectPattern */
/** @typedef {import(&quot;estree&quot;).SwitchCase} SwitchCase */
/** @typedef {import(&quot;estree&quot;).CatchClause} CatchClause */
/** @typedef {import(&quot;estree&quot;).VariableDeclarator} VariableDeclarator */
/** @typedef {import(&quot;estree&quot;).ForInStatement} ForInStatement */
/** @typedef {import(&quot;estree&quot;).ForOfStatement} ForOfStatement */
/** @typedef {import(&quot;estree&quot;).ReturnStatement} ReturnStatement */
/** @typedef {import(&quot;estree&quot;).WithStatement} WithStatement */
/** @typedef {import(&quot;estree&quot;).ThrowStatement} ThrowStatement */
/** @typedef {import(&quot;estree&quot;).MethodDefinition} MethodDefinition */
/** @typedef {import(&quot;estree&quot;).NewExpression} NewExpression */
/** @typedef {import(&quot;estree&quot;).SpreadElement} SpreadElement */
/** @typedef {import(&quot;estree&quot;).FunctionExpression} FunctionExpression */
/** @typedef {import(&quot;estree&quot;).WhileStatement} WhileStatement */
/** @typedef {import(&quot;estree&quot;).ArrowFunctionExpression} ArrowFunctionExpression */
/** @typedef {import(&quot;estree&quot;).ExpressionStatement} ExpressionStatement */
/** @typedef {import(&quot;estree&quot;).FunctionDeclaration} FunctionDeclaration */
/** @typedef {import(&quot;estree&quot;).DoWhileStatement} DoWhileStatement */
/** @typedef {import(&quot;estree&quot;).TryStatement} TryStatement */
/** @typedef {import(&quot;estree&quot;).Node} Node */
/** @typedef {import(&quot;estree&quot;).Program} Program */
/** @typedef {import(&quot;estree&quot;).Directive} Directive */
/** @typedef {import(&quot;estree&quot;).Statement} Statement */
/** @typedef {import(&quot;estree&quot;).ExportDefaultDeclaration} ExportDefaultDeclaration */
/** @typedef {import(&quot;estree&quot;).Super} Super */
/** @typedef {import(&quot;estree&quot;).TaggedTemplateExpression} TaggedTemplateExpression */
/** @typedef {import(&quot;estree&quot;).TemplateLiteral} TemplateLiteral */
/** @typedef {import(&quot;estree&quot;).AssignmentProperty} AssignmentProperty */
/** @typedef {import(&quot;estree&quot;).MaybeNamedFunctionDeclaration} MaybeNamedFunctionDeclaration */
/** @typedef {import(&quot;estree&quot;).MaybeNamedClassDeclaration} MaybeNamedClassDeclaration */
/**
 * @template T
 * @typedef {import(&quot;tapable&quot;).AsArray&lt;T&gt;} AsArray&lt;T&gt;
 */
/** @typedef {import(&quot;../Parser&quot;).ParserState} ParserState */
/** @typedef {import(&quot;../Parser&quot;).PreparsedAst} PreparsedAst */
/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () =&gt; string[], getMembersOptionals: () =&gt; boolean[], getMemberRanges: () =&gt; Range[] }} GetInfoResult */
/** @typedef {Statement | ModuleDeclaration | Expression | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration} StatementPathItem */
/** @typedef {(ident: string) =&gt; void} OnIdentString */
/** @typedef {(ident: string, identifier: Identifier) =&gt; void} OnIdent */
/** @typedef {StatementPathItem[]} StatementPath */

// TODO remove cast when @types/estree has been updated to import assertions
/** @typedef {import(&quot;estree&quot;).BaseNode &amp; { type: &quot;ImportAttribute&quot;, key: Identifier | Literal, value: Literal }} ImportAttribute */
/** @typedef {import(&quot;estree&quot;).ImportDeclaration &amp; { attributes?: Array&lt;ImportAttribute&gt; }} ImportDeclaration */
/** @typedef {import(&quot;estree&quot;).ExportNamedDeclaration &amp; { attributes?: Array&lt;ImportAttribute&gt; }} ExportNamedDeclaration */
/** @typedef {import(&quot;estree&quot;).ExportAllDeclaration &amp; { attributes?: Array&lt;ImportAttribute&gt; }} ExportAllDeclaration */
/** @typedef {import(&quot;estree&quot;).ImportExpression &amp; { options?: Expression | null }} ImportExpression */
/** @typedef {ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration} ModuleDeclaration */

/** @type {string[]} */
const EMPTY_ARRAY = [];
const ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;
const ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;
const ALLOWED_MEMBER_TYPES_ALL = 0b11;

const LEGACY_ASSERT_ATTRIBUTES = Symbol(&quot;assert&quot;);

/** @type {(BaseParser: typeof AcornParser) =&gt; typeof AcornParser} */
const importAssertions = Parser =&gt;
	class extends Parser {
		/**
		 * @this {TODO}
		 * @returns {ImportAttribute[]} import attributes
		 */
		parseWithClause() {
			/** @type {ImportAttribute[]} */
			const nodes = [];

			const isAssertLegacy = this.value === &quot;assert&quot;;

			if (isAssertLegacy) {
				if (!this.eat(tokTypes.name)) {
					return nodes;
				}
			} else if (!this.eat(tokTypes._with)) {
				return nodes;
			}

			this.expect(tokTypes.braceL);

			/** @type {Record&lt;string, boolean&gt;} */
			const attributeKeys = {};
			let first = true;

			while (!this.eat(tokTypes.braceR)) {
				if (!first) {
					this.expect(tokTypes.comma);
					if (this.afterTrailingComma(tokTypes.braceR)) {
						break;
					}
				} else {
					first = false;
				}

				const attr =
					/** @type {ImportAttribute} */
					this.parseImportAttribute();
				const keyName =
					attr.key.type === &quot;Identifier&quot; ? attr.key.name : attr.key.value;

				if (Object.prototype.hasOwnProperty.call(attributeKeys, keyName)) {
					this.raiseRecoverable(
						attr.key.start,
						`Duplicate attribute key &#039;${keyName}&#039;`
					);
				}

				attributeKeys[keyName] = true;
				nodes.push(attr);
			}

			if (isAssertLegacy) {
				/** @type {EXPECTED_ANY} */
				(nodes)[LEGACY_ASSERT_ATTRIBUTES] = true;
			}

			return nodes;
		}
	};

// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API
const parser = AcornParser.extend(importAssertions);

/** @typedef {Record&lt;string, string&gt; &amp; { _isLegacyAssert?: boolean }} ImportAttributes */

/**
 * @param {ImportDeclaration | ExportNamedDeclaration | ExportAllDeclaration | ImportExpression} node node with assertions
 * @returns {ImportAttributes | undefined} import attributes
 */
const getImportAttributes = node =&gt; {
	if (node.type === &quot;ImportExpression&quot;) {
		if (
			node.options &amp;&amp;
			node.options.type === &quot;ObjectExpression&quot; &amp;&amp;
			node.options.properties[0] &amp;&amp;
			node.options.properties[0].type === &quot;Property&quot; &amp;&amp;
			node.options.properties[0].key.type === &quot;Identifier&quot; &amp;&amp;
			(node.options.properties[0].key.name === &quot;with&quot; ||
				node.options.properties[0].key.name === &quot;assert&quot;) &amp;&amp;
			node.options.properties[0].value.type === &quot;ObjectExpression&quot; &amp;&amp;
			node.options.properties[0].value.properties.length &gt; 0
		) {
			const properties =
				/** @type {Property[]} */
				(node.options.properties[0].value.properties);
			const result = /** @type {ImportAttributes} */ ({});
			for (const property of properties) {
				const key =
					/** @type {string} */
					(
						property.key.type === &quot;Identifier&quot;
							? property.key.name
							: /** @type {Literal} */ (property.key).value
					);
				result[key] =
					/** @type {string} */
					(/** @type {Literal} */ (property.value).value);
			}
			const key =
				node.options.properties[0].key.type === &quot;Identifier&quot;
					? node.options.properties[0].key.name
					: /** @type {Literal} */ (node.options.properties[0].key).value;

			if (key === &quot;assert&quot;) {
				result._isLegacyAssert = true;
			}

			return result;
		}

		return;
	}

	if (node.attributes === undefined || node.attributes.length === 0) {
		return;
	}

	const result = /** @type {ImportAttributes} */ ({});

	for (const attribute of node.attributes) {
		const key =
			/** @type {string} */
			(
				attribute.key.type === &quot;Identifier&quot;
					? attribute.key.name
					: attribute.key.value
			);

		result[key] = /** @type {string} */ (attribute.value.value);
	}

	if (/** @type {EXPECTED_ANY} */ (node.attributes)[LEGACY_ASSERT_ATTRIBUTES]) {
		result._isLegacyAssert = true;
	}

	return result;
};

class VariableInfo {
	/**
	 * @param {ScopeInfo} declaredScope scope in which the variable is declared
	 * @param {string | true | undefined} freeName which free name the variable aliases, or true when none
	 * @param {TagInfo | undefined} tagInfo info about tags
	 */
	constructor(declaredScope, freeName, tagInfo) {
		this.declaredScope = declaredScope;
		this.freeName = freeName;
		this.tagInfo = tagInfo;
	}
}

/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */
/** @typedef {Literal | string | null | undefined} ImportSource */
/** @typedef {Omit&lt;AcornOptions, &quot;sourceType&quot; | &quot;ecmaVersion&quot;&gt; &amp; { sourceType: &quot;module&quot; | &quot;script&quot; | &quot;auto&quot;, ecmaVersion?: AcornOptions[&quot;ecmaVersion&quot;] }} ParseOptions */

/** @typedef {symbol} Tag */
/** @typedef {Record&lt;string, TODO&gt;} TagData */

/**
 * @typedef {object} TagInfo
 * @property {Tag} tag
 * @property {TagData=} data
 * @property {TagInfo | undefined} next
 */

const SCOPE_INFO_TERMINATED_RETURN = 1;
const SCOPE_INFO_TERMINATED_THROW = 2;

/**
 * @typedef {object} ScopeInfo
 * @property {StackedMap&lt;string, VariableInfo | ScopeInfo&gt;} definitions
 * @property {boolean | &quot;arrow&quot;} topLevelScope
 * @property {boolean | string} inShorthand
 * @property {boolean} inTaggedTemplateTag
 * @property {boolean} inTry
 * @property {boolean} isStrict
 * @property {boolean} isAsmJs
 * @property {undefined | 1 | 2} terminated
 */

/** @typedef {[number, number]} Range */

/**
 * @typedef {object} DestructuringAssignmentProperty
 * @property {string} id
 * @property {Range | undefined=} range
 * @property {boolean | string} shorthand
 */

/**
 * Helper function for joining two ranges into a single range. This is useful
 * when working with AST nodes, as it allows you to combine the ranges of child nodes
 * to create the range of the _parent node_.
 * @param {Range} startRange start range to join
 * @param {Range} endRange end range to join
 * @returns {Range} joined range
 * @example
 * ```js
 * 	const startRange = [0, 5];
 * 	const endRange = [10, 15];
 * 	const joinedRange = joinRanges(startRange, endRange);
 * 	console.log(joinedRange); // [0, 15]
 * ```
 */
const joinRanges = (startRange, endRange) =&gt; {
	if (!endRange) return startRange;
	if (!startRange) return endRange;
	return [startRange[0], endRange[1]];
};

/**
 * Helper function used to generate a string representation of a
 * [member expression](https://github.com/estree/estree/blob/master/es5.md#memberexpression).
 * @param {string} object object to name
 * @param {string[]} membersReversed reversed list of members
 * @returns {string} member expression as a string
 * @example
 * ```js
 * const membersReversed = [&quot;property1&quot;, &quot;property2&quot;, &quot;property3&quot;]; // Members parsed from the AST
 * const name = objectAndMembersToName(&quot;myObject&quot;, membersReversed);
 *
 * console.log(name); // &quot;myObject.property1.property2.property3&quot;
 * ```
 */
const objectAndMembersToName = (object, membersReversed) =&gt; {
	let name = object;
	for (let i = membersReversed.length - 1; i &gt;= 0; i--) {
		name = `${name}.${membersReversed[i]}`;
	}
	return name;
};

/**
 * Grabs the name of a given expression and returns it as a string or undefined. Has particular
 * handling for [Identifiers](https://github.com/estree/estree/blob/master/es5.md#identifier),
 * [ThisExpressions](https://github.com/estree/estree/blob/master/es5.md#identifier), and
 * [MetaProperties](https://github.com/estree/estree/blob/master/es2015.md#metaproperty) which is
 * specifically for handling the `new.target` meta property.
 * @param {Expression | SpreadElement | Super} expression expression
 * @returns {string | &quot;this&quot; | undefined} name or variable info
 */
const getRootName = expression =&gt; {
	switch (expression.type) {
		case &quot;Identifier&quot;:
			return expression.name;
		case &quot;ThisExpression&quot;:
			return &quot;this&quot;;
		case &quot;MetaProperty&quot;:
			return `${expression.meta.name}.${expression.property.name}`;
		default:
			return undefined;
	}
};

/** @type {AcornOptions} */
const defaultParserOptions = {
	ranges: true,
	locations: true,
	ecmaVersion: &quot;latest&quot;,
	sourceType: &quot;module&quot;,
	// https://github.com/tc39/proposal-hashbang
	allowHashBang: true,
	onComment: undefined
};

const EMPTY_COMMENT_OPTIONS = {
	options: null,
	errors: null
};

const CLASS_NAME = &quot;JavascriptParser&quot;;

class JavascriptParser extends Parser {
	/**
	 * @param {&quot;module&quot; | &quot;script&quot; | &quot;auto&quot;} sourceType default source type
	 */
	constructor(sourceType = &quot;auto&quot;) {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap&lt;SyncBailHook&lt;[UnaryExpression], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluateTypeof: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression | SpreadElement | PrivateIdentifier | Super], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluate: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluateIdentifier: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluateDefinedIdentifier: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[NewExpression], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluateNewExpression: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[CallExpression], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluateCallExpression: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[CallExpression, BasicEvaluatedExpression], BasicEvaluatedExpression | null | undefined&gt;&gt;} */
			evaluateCallExpressionMember: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;, &quot;param&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression | Declaration | PrivateIdentifier | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration, number], boolean | void&gt;&gt;} */
			isPure: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;, &quot;commentsStartPosition&quot;])
			),
			/** @type {SyncBailHook&lt;[Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration], boolean | void&gt;} */
			preStatement: new SyncBailHook([&quot;statement&quot;]),

			/** @type {SyncBailHook&lt;[Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration], boolean | void&gt;} */
			blockPreStatement: new SyncBailHook([&quot;declaration&quot;]),
			/** @type {SyncBailHook&lt;[Statement | ModuleDeclaration | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration], boolean | void&gt;} */
			statement: new SyncBailHook([&quot;statement&quot;]),
			/** @type {SyncBailHook&lt;[IfStatement], boolean | void&gt;} */
			statementIf: new SyncBailHook([&quot;statement&quot;]),
			/** @type {SyncBailHook&lt;[Expression, ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration], boolean | void&gt;} */
			classExtendsExpression: new SyncBailHook([
				&quot;expression&quot;,
				&quot;classDefinition&quot;
			]),
			/** @type {SyncBailHook&lt;[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration], boolean | void&gt;} */
			classBodyElement: new SyncBailHook([&quot;element&quot;, &quot;classDefinition&quot;]),
			/** @type {SyncBailHook&lt;[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration], boolean | void&gt;} */
			classBodyValue: new SyncBailHook([
				&quot;expression&quot;,
				&quot;element&quot;,
				&quot;classDefinition&quot;
			]),
			/** @type {HookMap&lt;SyncBailHook&lt;[LabeledStatement], boolean | void&gt;&gt;} */
			label: new HookMap(() =&gt; new SyncBailHook([&quot;statement&quot;])),
			/** @type {SyncBailHook&lt;[ImportDeclaration, ImportSource], boolean | void&gt;} */
			import: new SyncBailHook([&quot;statement&quot;, &quot;source&quot;]),
			/** @type {SyncBailHook&lt;[ImportDeclaration, ImportSource, string | null, string], boolean | void&gt;} */
			importSpecifier: new SyncBailHook([
				&quot;statement&quot;,
				&quot;source&quot;,
				&quot;exportName&quot;,
				&quot;identifierName&quot;
			]),
			/** @type {SyncBailHook&lt;[ExportDefaultDeclaration | ExportNamedDeclaration], boolean | void&gt;} */
			export: new SyncBailHook([&quot;statement&quot;]),
			/** @type {SyncBailHook&lt;[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void&gt;} */
			exportImport: new SyncBailHook([&quot;statement&quot;, &quot;source&quot;]),
			/** @type {SyncBailHook&lt;[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void&gt;} */
			exportDeclaration: new SyncBailHook([&quot;statement&quot;, &quot;declaration&quot;]),
			/** @type {SyncBailHook&lt;[ExportDefaultDeclaration, MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | Expression], boolean | void&gt;} */
			exportExpression: new SyncBailHook([&quot;statement&quot;, &quot;node&quot;]),
			/** @type {SyncBailHook&lt;[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void&gt;} */
			exportSpecifier: new SyncBailHook([
				&quot;statement&quot;,
				&quot;identifierName&quot;,
				&quot;exportName&quot;,
				&quot;index&quot;
			]),
			/** @type {SyncBailHook&lt;[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string | null, string | null, number | undefined], boolean | void&gt;} */
			exportImportSpecifier: new SyncBailHook([
				&quot;statement&quot;,
				&quot;source&quot;,
				&quot;identifierName&quot;,
				&quot;exportName&quot;,
				&quot;index&quot;
			]),
			/** @type {SyncBailHook&lt;[VariableDeclarator, Statement], boolean | void&gt;} */
			preDeclarator: new SyncBailHook([&quot;declarator&quot;, &quot;statement&quot;]),
			/** @type {SyncBailHook&lt;[VariableDeclarator, Statement], boolean | void&gt;} */
			declarator: new SyncBailHook([&quot;declarator&quot;, &quot;statement&quot;]),
			/** @type {HookMap&lt;SyncBailHook&lt;[Declaration], boolean | void&gt;&gt;} */
			varDeclaration: new HookMap(() =&gt; new SyncBailHook([&quot;declaration&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Declaration], boolean | void&gt;&gt;} */
			varDeclarationLet: new HookMap(() =&gt; new SyncBailHook([&quot;declaration&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Declaration], boolean | void&gt;&gt;} */
			varDeclarationConst: new HookMap(() =&gt; new SyncBailHook([&quot;declaration&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Declaration], boolean | void&gt;&gt;} */
			varDeclarationVar: new HookMap(() =&gt; new SyncBailHook([&quot;declaration&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Identifier], boolean | void&gt;&gt;} */
			pattern: new HookMap(() =&gt; new SyncBailHook([&quot;pattern&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression], boolean | void&gt;&gt;} */
			canRename: new HookMap(() =&gt; new SyncBailHook([&quot;initExpression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression], boolean | void&gt;&gt;} */
			rename: new HookMap(() =&gt; new SyncBailHook([&quot;initExpression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[AssignmentExpression], boolean | void&gt;&gt;} */
			assign: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[AssignmentExpression, string[]], boolean | void&gt;&gt;} */
			assignMemberChain: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;, &quot;members&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression], boolean | void&gt;&gt;} */
			typeof: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {SyncBailHook&lt;[ImportExpression], boolean | void&gt;} */
			importCall: new SyncBailHook([&quot;expression&quot;]),
			/** @type {SyncBailHook&lt;[Expression | ForOfStatement], boolean | void&gt;} */
			topLevelAwait: new SyncBailHook([&quot;expression&quot;]),
			/** @type {HookMap&lt;SyncBailHook&lt;[CallExpression], boolean | void&gt;&gt;} */
			call: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** Something like &quot;a.b()&quot; */
			/** @type {HookMap&lt;SyncBailHook&lt;[CallExpression, string[], boolean[], Range[]], boolean | void&gt;&gt;} */
			callMemberChain: new HookMap(
				() =&gt;
					new SyncBailHook([
						&quot;expression&quot;,
						&quot;members&quot;,
						&quot;membersOptionals&quot;,
						&quot;memberRanges&quot;
					])
			),
			/** Something like &quot;a.b().c.d&quot; */
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression, string[], CallExpression, string[], Range[]], boolean | void&gt;&gt;} */
			memberChainOfCallMemberChain: new HookMap(
				() =&gt;
					new SyncBailHook([
						&quot;expression&quot;,
						&quot;calleeMembers&quot;,
						&quot;callExpression&quot;,
						&quot;members&quot;,
						&quot;memberRanges&quot;
					])
			),
			/** Something like &quot;a.b().c.d()&quot;&quot; */
			/** @type {HookMap&lt;SyncBailHook&lt;[CallExpression, string[], CallExpression, string[], Range[]], boolean | void&gt;&gt;} */
			callMemberChainOfCallMemberChain: new HookMap(
				() =&gt;
					new SyncBailHook([
						&quot;expression&quot;,
						&quot;calleeMembers&quot;,
						&quot;innerCallExpression&quot;,
						&quot;members&quot;,
						&quot;memberRanges&quot;
					])
			),
			/** @type {SyncBailHook&lt;[ChainExpression], boolean | void&gt;} */
			optionalChaining: new SyncBailHook([&quot;optionalChaining&quot;]),
			/** @type {HookMap&lt;SyncBailHook&lt;[NewExpression], boolean | void&gt;&gt;} */
			new: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {SyncBailHook&lt;[BinaryExpression], boolean | void&gt;} */
			binaryExpression: new SyncBailHook([&quot;binaryExpression&quot;]),
			/** @type {HookMap&lt;SyncBailHook&lt;[Expression], boolean | void&gt;&gt;} */
			expression: new HookMap(() =&gt; new SyncBailHook([&quot;expression&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[MemberExpression, string[], boolean[], Range[]], boolean | void&gt;&gt;} */
			expressionMemberChain: new HookMap(
				() =&gt;
					new SyncBailHook([
						&quot;expression&quot;,
						&quot;members&quot;,
						&quot;membersOptionals&quot;,
						&quot;memberRanges&quot;
					])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[MemberExpression, string[]], boolean | void&gt;&gt;} */
			unhandledExpressionMemberChain: new HookMap(
				() =&gt; new SyncBailHook([&quot;expression&quot;, &quot;members&quot;])
			),
			/** @type {SyncBailHook&lt;[ConditionalExpression], boolean | void&gt;} */
			expressionConditionalOperator: new SyncBailHook([&quot;expression&quot;]),
			/** @type {SyncBailHook&lt;[LogicalExpression], boolean | void&gt;} */
			expressionLogicalOperator: new SyncBailHook([&quot;expression&quot;]),
			/** @type {SyncBailHook&lt;[Program, Comment[]], boolean | void&gt;} */
			program: new SyncBailHook([&quot;ast&quot;, &quot;comments&quot;]),
			/** @type {SyncBailHook&lt;[ThrowStatement | ReturnStatement], boolean | void&gt;} */
			terminate: new SyncBailHook([&quot;statement&quot;]),
			/** @type {SyncBailHook&lt;[Program, Comment[]], boolean | void&gt;} */
			finish: new SyncBailHook([&quot;ast&quot;, &quot;comments&quot;])
		});
		this.sourceType = sourceType;
		/** @type {ScopeInfo} */
		this.scope = /** @type {TODO} */ (undefined);
		/** @type {ParserState} */
		this.state = /** @type {TODO} */ (undefined);
		/** @type {Comment[] | undefined} */
		this.comments = undefined;
		/** @type {Set&lt;number&gt; | undefined} */
		this.semicolons = undefined;
		/** @type {StatementPath | undefined} */
		this.statementPath = undefined;
		/** @type {Statement | ModuleDeclaration | Expression | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | undefined} */
		this.prevStatement = undefined;
		/** @type {WeakMap&lt;Expression, Set&lt;DestructuringAssignmentProperty&gt;&gt; | undefined} */
		this.destructuringAssignmentProperties = undefined;
		/** @type {TagData | undefined} */
		this.currentTagData = undefined;
		this.magicCommentContext = createMagicCommentContext();
		this._initializeEvaluating();
	}

	_initializeEvaluating() {
		this.hooks.evaluate.for(&quot;Literal&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {Literal} */ (_expr);

			switch (typeof expr.value) {
				case &quot;number&quot;:
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(/** @type {Range} */ (expr.range));
				case &quot;bigint&quot;:
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(/** @type {Range} */ (expr.range));
				case &quot;string&quot;:
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(/** @type {Range} */ (expr.range));
				case &quot;boolean&quot;:
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(/** @type {Range} */ (expr.range));
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression()
					.setNull()
					.setRange(/** @type {Range} */ (expr.range));
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(/** @type {Range} */ (expr.range));
			}
		});
		this.hooks.evaluate.for(&quot;NewExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {NewExpression} */ (_expr);
			const callee = expr.callee;
			if (callee.type !== &quot;Identifier&quot;) return;
			if (callee.name !== &quot;RegExp&quot;) {
				return this.callHooksForName(
					this.hooks.evaluateNewExpression,
					callee.name,
					expr
				);
			} else if (
				expr.arguments.length &gt; 2 ||
				this.getVariableInfo(&quot;RegExp&quot;) !== &quot;RegExp&quot;
			)
				return;

			let regExp;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === &quot;SpreadElement&quot;) return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			} else {
				return (
					new BasicEvaluatedExpression()
						// eslint-disable-next-line prefer-regex-literals
						.setRegExp(new RegExp(&quot;&quot;))
						.setRange(/** @type {Range} */ (expr.range))
				);
			}

			let flags;
			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === &quot;SpreadElement&quot;) return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				}
			}

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(/** @type {Range} */ (expr.range));
		});
		this.hooks.evaluate.for(&quot;LogicalExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {LogicalExpression} */ (_expr);

			const left = this.evaluateExpression(expr.left);
			let returnRight = false;
			/** @type {boolean | undefined} */
			let allowedRight;
			if (expr.operator === &quot;&amp;&amp;&quot;) {
				const leftAsBool = left.asBool();
				if (leftAsBool === false)
					return left.setRange(/** @type {Range} */ (expr.range));
				returnRight = leftAsBool === true;
				allowedRight = false;
			} else if (expr.operator === &quot;||&quot;) {
				const leftAsBool = left.asBool();
				if (leftAsBool === true)
					return left.setRange(/** @type {Range} */ (expr.range));
				returnRight = leftAsBool === false;
				allowedRight = true;
			} else if (expr.operator === &quot;??&quot;) {
				const leftAsNullish = left.asNullish();
				if (leftAsNullish === false)
					return left.setRange(/** @type {Range} */ (expr.range));
				if (leftAsNullish !== true) return;
				returnRight = true;
			} else return;
			const right = this.evaluateExpression(expr.right);
			if (returnRight) {
				if (left.couldHaveSideEffects()) right.setSideEffects();
				return right.setRange(/** @type {Range} */ (expr.range));
			}

			const asBool = right.asBool();

			if (allowedRight === true &amp;&amp; asBool === true) {
				return new BasicEvaluatedExpression()
					.setRange(/** @type {Range} */ (expr.range))
					.setTruthy();
			} else if (allowedRight === false &amp;&amp; asBool === false) {
				return new BasicEvaluatedExpression()
					.setRange(/** @type {Range} */ (expr.range))
					.setFalsy();
			}
		});

		/**
		 * In simple logical cases, we can use valueAsExpression to assist us in evaluating the expression on
		 * either side of a [BinaryExpression](https://github.com/estree/estree/blob/master/es5.md#binaryexpression).
		 * This supports scenarios in webpack like conditionally `import()`&#039;ing modules based on some simple evaluation:
		 *
		 * ```js
		 * if (1 === 3) {
		 *  import(&quot;./moduleA&quot;); // webpack will auto evaluate this and not import the modules
		 * }
		 * ```
		 *
		 * Additional scenarios include evaluation of strings inside of dynamic import statements:
		 *
		 * ```js
		 * const foo = &quot;foo&quot;;
		 * const bar = &quot;bar&quot;;
		 *
		 * import(&quot;./&quot; + foo + bar); // webpack will auto evaluate this into import(&quot;./foobar&quot;)
		 * ```
		 * @param {boolean | number | bigint | string} value the value to convert to an expression
		 * @param {BinaryExpression | UnaryExpression} expr the expression being evaluated
		 * @param {boolean} sideEffects whether the expression has side effects
		 * @returns {BasicEvaluatedExpression | undefined} the evaluated expression
		 * @example
		 *
		 * ```js
		 * const binaryExpr = new BinaryExpression(&quot;+&quot;,
		 * 	{ type: &quot;Literal&quot;, value: 2 },
		 * 	{ type: &quot;Literal&quot;, value: 3 }
		 * );
		 *
		 * const leftValue = 2;
		 * const rightValue = 3;
		 *
		 * const leftExpr = valueAsExpression(leftValue, binaryExpr.left, false);
		 * const rightExpr = valueAsExpression(rightValue, binaryExpr.right, false);
		 * const result = new BasicEvaluatedExpression()
		 * 	.setNumber(leftExpr.number + rightExpr.number)
		 * 	.setRange(binaryExpr.range);
		 *
		 * console.log(result.number); // Output: 5
		 * ```
		 */
		const valueAsExpression = (value, expr, sideEffects) =&gt; {
			switch (typeof value) {
				case &quot;boolean&quot;:
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range} */ (expr.range));
				case &quot;number&quot;:
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range} */ (expr.range));
				case &quot;bigint&quot;:
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range} */ (expr.range));
				case &quot;string&quot;:
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range} */ (expr.range));
			}
		};

		this.hooks.evaluate.for(&quot;BinaryExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {BinaryExpression} */ (_expr);

			/**
			 * Evaluates a binary expression if and only if it is a const operation (e.g. 1 + 2, &quot;a&quot; + &quot;b&quot;, etc.).
			 * @template T
			 * @param {(leftOperand: T, rightOperand: T) =&gt; boolean | number | bigint | string} operandHandler the handler for the operation (e.g. (a, b) =&gt; a + b)
			 * @returns {BasicEvaluatedExpression | undefined} the evaluated expression
			 */
			const handleConstOperation = operandHandler =&gt; {
				const left = this.evaluateExpression(expr.left);
				if (!left.isCompileTimeValue()) return;

				const right = this.evaluateExpression(expr.right);
				if (!right.isCompileTimeValue()) return;

				const result = operandHandler(
					/** @type {T} */ (left.asCompileTimeValue()),
					/** @type {T} */ (right.asCompileTimeValue())
				);
				return valueAsExpression(
					result,
					expr,
					left.couldHaveSideEffects() || right.couldHaveSideEffects()
				);
			};

			/**
			 * Helper function to determine if two booleans are always different. This is used in `handleStrictEqualityComparison`
			 * to determine if an expressions boolean or nullish conversion is equal or not.
			 * @param {boolean} a first boolean to compare
			 * @param {boolean} b second boolean to compare
			 * @returns {boolean} true if the two booleans are always different, false otherwise
			 */
			const isAlwaysDifferent = (a, b) =&gt;
				(a === true &amp;&amp; b === false) || (a === false &amp;&amp; b === true);

			/**
			 * @param {BasicEvaluatedExpression} left left
			 * @param {BasicEvaluatedExpression} right right
			 * @param {BasicEvaluatedExpression} res res
			 * @param {boolean} eql true for &quot;===&quot; and false for &quot;!==&quot;
			 * @returns {BasicEvaluatedExpression | undefined} result
			 */
			const handleTemplateStringCompare = (left, right, res, eql) =&gt; {
				/**
				 * @param {BasicEvaluatedExpression[]} parts parts
				 * @returns {string} value
				 */
				const getPrefix = parts =&gt; {
					let value = &quot;&quot;;
					for (const p of parts) {
						const v = p.asString();
						if (v !== undefined) value += v;
						else break;
					}
					return value;
				};
				/**
				 * @param {BasicEvaluatedExpression[]} parts parts
				 * @returns {string} value
				 */
				const getSuffix = parts =&gt; {
					let value = &quot;&quot;;
					for (let i = parts.length - 1; i &gt;= 0; i--) {
						const v = parts[i].asString();
						if (v !== undefined) value = v + value;
						else break;
					}
					return value;
				};
				const leftPrefix = getPrefix(
					/** @type {BasicEvaluatedExpression[]} */ (left.parts)
				);
				const rightPrefix = getPrefix(
					/** @type {BasicEvaluatedExpression[]} */ (right.parts)
				);
				const leftSuffix = getSuffix(
					/** @type {BasicEvaluatedExpression[]} */ (left.parts)
				);
				const rightSuffix = getSuffix(
					/** @type {BasicEvaluatedExpression[]} */ (right.parts)
				);
				const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
				const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
				const prefixMismatch =
					lenPrefix &gt; 0 &amp;&amp;
					leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix);
				const suffixMismatch =
					lenSuffix &gt; 0 &amp;&amp;
					leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix);
				if (prefixMismatch || suffixMismatch) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				}
			};

			/**
			 * Helper function to handle BinaryExpressions using strict equality comparisons (e.g. &quot;===&quot; and &quot;!==&quot;).
			 * @param {boolean} eql true for &quot;===&quot; and false for &quot;!==&quot;
			 * @returns {BasicEvaluatedExpression | undefined} the evaluated expression
			 */
			const handleStrictEqualityComparison = eql =&gt; {
				const left = this.evaluateExpression(expr.left);
				const right = this.evaluateExpression(expr.right);
				const res = new BasicEvaluatedExpression();
				res.setRange(/** @type {Range} */ (expr.range));

				const leftConst = left.isCompileTimeValue();
				const rightConst = right.isCompileTimeValue();

				if (leftConst &amp;&amp; rightConst) {
					return res
						.setBoolean(
							eql === (left.asCompileTimeValue() === right.asCompileTimeValue())
						)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				}

				if (left.isArray() &amp;&amp; right.isArray()) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				}
				if (left.isTemplateString() &amp;&amp; right.isTemplateString()) {
					return handleTemplateStringCompare(left, right, res, eql);
				}

				const leftPrimitive = left.isPrimitiveType();
				const rightPrimitive = right.isPrimitiveType();

				if (
					// Primitive !== Object or
					// compile-time object types are never equal to something at runtime
					(leftPrimitive === false &amp;&amp; (leftConst || rightPrimitive === true)) ||
					(rightPrimitive === false &amp;&amp;
						(rightConst || leftPrimitive === true)) ||
					// Different nullish or boolish status also means not equal
					isAlwaysDifferent(
						/** @type {boolean} */ (left.asBool()),
						/** @type {boolean} */ (right.asBool())
					) ||
					isAlwaysDifferent(
						/** @type {boolean} */ (left.asNullish()),
						/** @type {boolean} */ (right.asNullish())
					)
				) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				}
			};

			/**
			 * Helper function to handle BinaryExpressions using abstract equality comparisons (e.g. &quot;==&quot; and &quot;!=&quot;).
			 * @param {boolean} eql true for &quot;==&quot; and false for &quot;!=&quot;
			 * @returns {BasicEvaluatedExpression | undefined} the evaluated expression
			 */
			const handleAbstractEqualityComparison = eql =&gt; {
				const left = this.evaluateExpression(expr.left);
				const right = this.evaluateExpression(expr.right);
				const res = new BasicEvaluatedExpression();
				res.setRange(/** @type {Range} */ (expr.range));

				const leftConst = left.isCompileTimeValue();
				const rightConst = right.isCompileTimeValue();

				if (leftConst &amp;&amp; rightConst) {
					return res
						.setBoolean(
							eql ===
								// eslint-disable-next-line eqeqeq
								(left.asCompileTimeValue() == right.asCompileTimeValue())
						)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				}

				if (left.isArray() &amp;&amp; right.isArray()) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				}
				if (left.isTemplateString() &amp;&amp; right.isTemplateString()) {
					return handleTemplateStringCompare(left, right, res, eql);
				}
			};

			if (expr.operator === &quot;+&quot;) {
				const left = this.evaluateExpression(expr.left);
				const right = this.evaluateExpression(expr.right);
				const res = new BasicEvaluatedExpression();
				if (left.isString()) {
					if (right.isString()) {
						res.setString(
							/** @type {string} */ (left.string) +
								/** @type {string} */ (right.string)
						);
					} else if (right.isNumber()) {
						res.setString(/** @type {string} */ (left.string) + right.number);
					} else if (
						right.isWrapped() &amp;&amp;
						right.prefix &amp;&amp;
						right.prefix.isString()
					) {
						// &quot;left&quot; + (&quot;prefix&quot; + inner + &quot;postfix&quot;)
						// =&gt; (&quot;leftPrefix&quot; + inner + &quot;postfix&quot;)
						res.setWrapped(
							new BasicEvaluatedExpression()
								.setString(
									/** @type {string} */ (left.string) +
										/** @type {string} */ (right.prefix.string)
								)
								.setRange(
									joinRanges(
										/** @type {Range} */ (left.range),
										/** @type {Range} */ (right.prefix.range)
									)
								),
							right.postfix,
							right.wrappedInnerExpressions
						);
					} else if (right.isWrapped()) {
						// &quot;left&quot; + ([null] + inner + &quot;postfix&quot;)
						// =&gt; (&quot;left&quot; + inner + &quot;postfix&quot;)
						res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);
					} else {
						// &quot;left&quot; + expr
						// =&gt; (&quot;left&quot; + expr + &quot;&quot;)
						res.setWrapped(left, null, [right]);
					}
				} else if (left.isNumber()) {
					if (right.isString()) {
						res.setString(left.number + /** @type {string} */ (right.string));
					} else if (right.isNumber()) {
						res.setNumber(
							/** @type {number} */ (left.number) +
								/** @type {number} */ (right.number)
						);
					} else {
						return;
					}
				} else if (left.isBigInt()) {
					if (right.isBigInt()) {
						res.setBigInt(
							/** @type {bigint} */ (left.bigint) +
								/** @type {bigint} */ (right.bigint)
						);
					}
				} else if (left.isWrapped()) {
					if (left.postfix &amp;&amp; left.postfix.isString() &amp;&amp; right.isString()) {
						// (&quot;prefix&quot; + inner + &quot;postfix&quot;) + &quot;right&quot;
						// =&gt; (&quot;prefix&quot; + inner + &quot;postfixRight&quot;)
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(
									/** @type {string} */ (left.postfix.string) +
										/** @type {string} */ (right.string)
								)
								.setRange(
									joinRanges(
										/** @type {Range} */ (left.postfix.range),
										/** @type {Range} */ (right.range)
									)
								),
							left.wrappedInnerExpressions
						);
					} else if (
						left.postfix &amp;&amp;
						left.postfix.isString() &amp;&amp;
						right.isNumber()
					) {
						// (&quot;prefix&quot; + inner + &quot;postfix&quot;) + 123
						// =&gt; (&quot;prefix&quot; + inner + &quot;postfix123&quot;)
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(
									/** @type {string} */ (left.postfix.string) +
										/** @type {number} */ (right.number)
								)
								.setRange(
									joinRanges(
										/** @type {Range} */ (left.postfix.range),
										/** @type {Range} */ (right.range)
									)
								),
							left.wrappedInnerExpressions
						);
					} else if (right.isString()) {
						// (&quot;prefix&quot; + inner + [null]) + &quot;right&quot;
						// =&gt; (&quot;prefix&quot; + inner + &quot;right&quot;)
						res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
					} else if (right.isNumber()) {
						// (&quot;prefix&quot; + inner + [null]) + 123
						// =&gt; (&quot;prefix&quot; + inner + &quot;123&quot;)
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(String(right.number))
								.setRange(/** @type {Range} */ (right.range)),
							left.wrappedInnerExpressions
						);
					} else if (right.isWrapped()) {
						// (&quot;prefix1&quot; + inner1 + &quot;postfix1&quot;) + (&quot;prefix2&quot; + inner2 + &quot;postfix2&quot;)
						// (&quot;prefix1&quot; + inner1 + &quot;postfix1&quot; + &quot;prefix2&quot; + inner2 + &quot;postfix2&quot;)
						res.setWrapped(
							left.prefix,
							right.postfix,
							left.wrappedInnerExpressions &amp;&amp;
								right.wrappedInnerExpressions &amp;&amp;
								left.wrappedInnerExpressions
									.concat(left.postfix ? [left.postfix] : [])
									.concat(right.prefix ? [right.prefix] : [])
									.concat(right.wrappedInnerExpressions)
						);
					} else {
						// (&quot;prefix&quot; + inner + postfix) + expr
						// =&gt; (&quot;prefix&quot; + inner + postfix + expr + [null])
						res.setWrapped(
							left.prefix,
							null,
							left.wrappedInnerExpressions &amp;&amp;
								left.wrappedInnerExpressions.concat(
									left.postfix ? [left.postfix, right] : [right]
								)
						);
					}
				} else if (right.isString()) {
					// left + &quot;right&quot;
					// =&gt; ([null] + left + &quot;right&quot;)
					res.setWrapped(null, right, [left]);
				} else if (right.isWrapped()) {
					// left + (prefix + inner + &quot;postfix&quot;)
					// =&gt; ([null] + left + prefix + inner + &quot;postfix&quot;)
					res.setWrapped(
						null,
						right.postfix,
						right.wrappedInnerExpressions &amp;&amp;
							(right.prefix ? [left, right.prefix] : [left]).concat(
								right.wrappedInnerExpressions
							)
					);
				} else {
					return;
				}
				if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
					res.setSideEffects();
				res.setRange(/** @type {Range} */ (expr.range));
				return res;
			} else if (expr.operator === &quot;-&quot;) {
				return handleConstOperation((l, r) =&gt; l - r);
			} else if (expr.operator === &quot;*&quot;) {
				return handleConstOperation((l, r) =&gt; l * r);
			} else if (expr.operator === &quot;/&quot;) {
				return handleConstOperation((l, r) =&gt; l / r);
			} else if (expr.operator === &quot;**&quot;) {
				return handleConstOperation((l, r) =&gt; l ** r);
			} else if (expr.operator === &quot;===&quot;) {
				return handleStrictEqualityComparison(true);
			} else if (expr.operator === &quot;==&quot;) {
				return handleAbstractEqualityComparison(true);
			} else if (expr.operator === &quot;!==&quot;) {
				return handleStrictEqualityComparison(false);
			} else if (expr.operator === &quot;!=&quot;) {
				return handleAbstractEqualityComparison(false);
			} else if (expr.operator === &quot;&amp;&quot;) {
				return handleConstOperation((l, r) =&gt; l &amp; r);
			} else if (expr.operator === &quot;|&quot;) {
				return handleConstOperation((l, r) =&gt; l | r);
			} else if (expr.operator === &quot;^&quot;) {
				return handleConstOperation((l, r) =&gt; l ^ r);
			} else if (expr.operator === &quot;&gt;&gt;&gt;&quot;) {
				return handleConstOperation((l, r) =&gt; l &gt;&gt;&gt; r);
			} else if (expr.operator === &quot;&gt;&gt;&quot;) {
				return handleConstOperation((l, r) =&gt; l &gt;&gt; r);
			} else if (expr.operator === &quot;&lt;&lt;&quot;) {
				return handleConstOperation((l, r) =&gt; l &lt;&lt; r);
			} else if (expr.operator === &quot;&lt;&quot;) {
				return handleConstOperation((l, r) =&gt; l &lt; r);
			} else if (expr.operator === &quot;&gt;&quot;) {
				return handleConstOperation((l, r) =&gt; l &gt; r);
			} else if (expr.operator === &quot;&lt;=&quot;) {
				return handleConstOperation((l, r) =&gt; l &lt;= r);
			} else if (expr.operator === &quot;&gt;=&quot;) {
				return handleConstOperation((l, r) =&gt; l &gt;= r);
			}
		});
		this.hooks.evaluate.for(&quot;UnaryExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {UnaryExpression} */ (_expr);

			/**
			 * Evaluates a UnaryExpression if and only if it is a basic const operator (e.g. +a, -a, ~a).
			 * @template T
			 * @param {(operand: T) =&gt; boolean | number | bigint | string} operandHandler handler for the operand
			 * @returns {BasicEvaluatedExpression | undefined} evaluated expression
			 */
			const handleConstOperation = operandHandler =&gt; {
				const argument = this.evaluateExpression(expr.argument);
				if (!argument.isCompileTimeValue()) return;
				const result = operandHandler(
					/** @type {T} */ (argument.asCompileTimeValue())
				);
				return valueAsExpression(result, expr, argument.couldHaveSideEffects());
			};

			if (expr.operator === &quot;typeof&quot;) {
				switch (expr.argument.type) {
					case &quot;Identifier&quot;: {
						const res = this.callHooksForName(
							this.hooks.evaluateTypeof,
							expr.argument.name,
							expr
						);
						if (res !== undefined) return res;
						break;
					}
					case &quot;MetaProperty&quot;: {
						const res = this.callHooksForName(
							this.hooks.evaluateTypeof,
							/** @type {string} */
							(getRootName(expr.argument)),
							expr
						);
						if (res !== undefined) return res;
						break;
					}
					case &quot;MemberExpression&quot;: {
						const res = this.callHooksForExpression(
							this.hooks.evaluateTypeof,
							expr.argument,
							expr
						);
						if (res !== undefined) return res;
						break;
					}
					case &quot;ChainExpression&quot;: {
						const res = this.callHooksForExpression(
							this.hooks.evaluateTypeof,
							expr.argument.expression,
							expr
						);
						if (res !== undefined) return res;
						break;
					}
					case &quot;FunctionExpression&quot;: {
						return new BasicEvaluatedExpression()
							.setString(&quot;function&quot;)
							.setRange(/** @type {Range} */ (expr.range));
					}
				}
				const arg = this.evaluateExpression(expr.argument);
				if (arg.isUnknown()) return;
				if (arg.isString()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;string&quot;)
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isWrapped()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;string&quot;)
						.setSideEffects()
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isUndefined()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;undefined&quot;)
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isNumber()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;number&quot;)
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isBigInt()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;bigint&quot;)
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isBoolean()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;boolean&quot;)
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;object&quot;)
						.setRange(/** @type {Range} */ (expr.range));
				}
				if (arg.isArray()) {
					return new BasicEvaluatedExpression()
						.setString(&quot;object&quot;)
						.setSideEffects(arg.couldHaveSideEffects())
						.setRange(/** @type {Range} */ (expr.range));
				}
			} else if (expr.operator === &quot;!&quot;) {
				const argument = this.evaluateExpression(expr.argument);
				const bool = argument.asBool();
				if (typeof bool !== &quot;boolean&quot;) return;
				return new BasicEvaluatedExpression()
					.setBoolean(!bool)
					.setSideEffects(argument.couldHaveSideEffects())
					.setRange(/** @type {Range} */ (expr.range));
			} else if (expr.operator === &quot;~&quot;) {
				return handleConstOperation(v =&gt; ~v);
			} else if (expr.operator === &quot;+&quot;) {
				// eslint-disable-next-line no-implicit-coercion
				return handleConstOperation(v =&gt; +v);
			} else if (expr.operator === &quot;-&quot;) {
				return handleConstOperation(v =&gt; -v);
			}
		});
		this.hooks.evaluateTypeof
			.for(&quot;undefined&quot;)
			.tap(CLASS_NAME, expr =&gt;
				new BasicEvaluatedExpression()
					.setString(&quot;undefined&quot;)
					.setRange(/** @type {Range} */ (expr.range))
			);
		this.hooks.evaluate.for(&quot;Identifier&quot;).tap(CLASS_NAME, expr =&gt; {
			if (/** @type {Identifier} */ (expr).name === &quot;undefined&quot;) {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(/** @type {Range} */ (expr.range));
			}
		});
		/**
		 * @param {&quot;Identifier&quot; | &quot;ThisExpression&quot; | &quot;MemberExpression&quot;} exprType expression type name
		 * @param {(node: Expression | SpreadElement) =&gt; GetInfoResult | undefined} getInfo get info
		 * @returns {void}
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) =&gt; {
			/** @type {Expression | undefined} */
			let cachedExpression;
			/** @type {GetInfoResult | undefined} */
			let cachedInfo;
			this.hooks.evaluate.for(exprType).tap(CLASS_NAME, expr =&gt; {
				const expression =
					/** @type {Identifier | ThisExpression | MemberExpression} */ (expr);

				const info = getInfo(expression);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name =&gt; {
							cachedExpression = expression;
							cachedInfo = info;
						},
						name =&gt; {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							}
						},
						expression
					);
				}
			});
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: CLASS_NAME, stage: 100 }, expr =&gt; {
					const expression =
						/** @type {Identifier | ThisExpression | MemberExpression} */
						(expr);
					const info =
						cachedExpression === expression ? cachedInfo : getInfo(expression);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(
								info.name,
								info.rootInfo,
								info.getMembers,
								info.getMembersOptionals,
								info.getMemberRanges
							)
							.setRange(/** @type {Range} */ (expression.range));
					}
				});
			this.hooks.finish.tap(CLASS_NAME, () =&gt; {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			});
		};
		tapEvaluateWithVariableInfo(&quot;Identifier&quot;, expr =&gt; {
			const info = this.getVariableInfo(/** @type {Identifier} */ (expr).name);
			if (
				typeof info === &quot;string&quot; ||
				(info instanceof VariableInfo &amp;&amp; typeof info.freeName === &quot;string&quot;)
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () =&gt; [],
					getMembersOptionals: () =&gt; [],
					getMemberRanges: () =&gt; []
				};
			}
		});
		tapEvaluateWithVariableInfo(&quot;ThisExpression&quot;, expr =&gt; {
			const info = this.getVariableInfo(&quot;this&quot;);
			if (
				typeof info === &quot;string&quot; ||
				(info instanceof VariableInfo &amp;&amp; typeof info.freeName === &quot;string&quot;)
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () =&gt; [],
					getMembersOptionals: () =&gt; [],
					getMemberRanges: () =&gt; []
				};
			}
		});
		this.hooks.evaluate.for(&quot;MetaProperty&quot;).tap(CLASS_NAME, expr =&gt; {
			const metaProperty = /** @type {MetaProperty} */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				/** @type {string} */
				(getRootName(metaProperty)),
				metaProperty
			);
		});
		tapEvaluateWithVariableInfo(&quot;MemberExpression&quot;, expr =&gt;
			this.getMemberExpressionInfo(
				/** @type {MemberExpression} */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for(&quot;CallExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {CallExpression} */ (_expr);
			if (
				expr.callee.type === &quot;MemberExpression&quot; &amp;&amp;
				expr.callee.property.type ===
					(expr.callee.computed ? &quot;Literal&quot; : &quot;Identifier&quot;)
			) {
				// type Super also possible here
				const param = this.evaluateExpression(
					/** @type {Expression} */ (expr.callee.object)
				);
				const property =
					expr.callee.property.type === &quot;Literal&quot;
						? `${expr.callee.property.value}`
						: expr.callee.property.name;
				const hook = this.hooks.evaluateCallExpressionMember.get(property);
				if (hook !== undefined) {
					return hook.call(expr, param);
				}
			} else if (expr.callee.type === &quot;Identifier&quot;) {
				return this.callHooksForName(
					this.hooks.evaluateCallExpression,
					expr.callee.name,
					expr
				);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for(&quot;indexOf&quot;)
			.tap(CLASS_NAME, (expr, param) =&gt; {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === &quot;SpreadElement&quot;) return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = /** @type {string} */ (arg1Eval.string);

				let result;
				if (arg2) {
					if (arg2.type === &quot;SpreadElement&quot;) return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = /** @type {string} */ (param.string).indexOf(
						arg1Value,
						arg2Eval.number
					);
				} else {
					result = /** @type {string} */ (param.string).indexOf(arg1Value);
				}
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(/** @type {Range} */ (expr.range));
			});
		this.hooks.evaluateCallExpressionMember
			.for(&quot;replace&quot;)
			.tap(CLASS_NAME, (expr, param) =&gt; {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === &quot;SpreadElement&quot;) return;
				if (expr.arguments[1].type === &quot;SpreadElement&quot;) return;
				const arg1 = this.evaluateExpression(expr.arguments[0]);
				const arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() &amp;&amp; !arg1.isRegExp()) return;
				const arg1Value = /** @type {string | RegExp} */ (
					arg1.regExp || arg1.string
				);
				if (!arg2.isString()) return;
				const arg2Value = /** @type {string} */ (arg2.string);
				return new BasicEvaluatedExpression()
					.setString(
						/** @type {string} */ (param.string).replace(arg1Value, arg2Value)
					)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(/** @type {Range} */ (expr.range));
			});
		for (const fn of [&quot;substr&quot;, &quot;substring&quot;, &quot;slice&quot;]) {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap(CLASS_NAME, (expr, param) =&gt; {
					if (!param.isString()) return;
					let arg1;
					let result;
					const str = /** @type {string} */ (param.string);
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === &quot;SpreadElement&quot;) return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[
								/** @type {&quot;substr&quot; | &quot;substring&quot; | &quot;slice&quot;} */ (fn)
							](/** @type {number} */ (arg1.number));
							break;
						case 2: {
							if (expr.arguments[0].type === &quot;SpreadElement&quot;) return;
							if (expr.arguments[1].type === &quot;SpreadElement&quot;) return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[
								/** @type {&quot;substr&quot; | &quot;substring&quot; | &quot;slice&quot;} */ (fn)
							](
								/** @type {number} */ (arg1.number),
								/** @type {number} */ (arg2.number)
							);
							break;
						}
						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(/** @type {Range} */ (expr.range));
				});
		}

		/**
		 * @param {&quot;cooked&quot; | &quot;raw&quot;} kind kind of values to get
		 * @param {TemplateLiteral} templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) =&gt; {
			/** @type {BasicEvaluatedExpression[]} */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]} */
			const parts = [];

			for (let i = 0; i &lt; templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i &gt; 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === &quot;string&quot; &amp;&amp;
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([
							/** @type {Range} */ (prevExpr.range)[0],
							/** @type {Range} */ (quasiExpr.range)[1]
						]);
						// We unset the expression as it doesn&#039;t match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(/** @type {string} */ (quasi))
					.setRange(/** @type {Range} */ (quasiExpr.range))
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate.for(&quot;TemplateLiteral&quot;).tap(CLASS_NAME, _node =&gt; {
			const node = /** @type {TemplateLiteral} */ (_node);

			const { quasis, parts } = getSimplifiedTemplateResult(&quot;cooked&quot;, node);
			if (parts.length === 1) {
				return parts[0].setRange(/** @type {Range} */ (node.range));
			}
			return new BasicEvaluatedExpression()
				.setTemplateString(quasis, parts, &quot;cooked&quot;)
				.setRange(/** @type {Range} */ (node.range));
		});
		this.hooks.evaluate
			.for(&quot;TaggedTemplateExpression&quot;)
			.tap(CLASS_NAME, _node =&gt; {
				const node = /** @type {TaggedTemplateExpression} */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() &amp;&amp; tag.identifier === &quot;String.raw&quot;) {
					const { quasis, parts } = getSimplifiedTemplateResult(
						&quot;raw&quot;,
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, &quot;raw&quot;)
						.setRange(/** @type {Range} */ (node.range));
				}
			});

		this.hooks.evaluateCallExpressionMember
			.for(&quot;concat&quot;)
			.tap(CLASS_NAME, (expr, param) =&gt; {
				if (!param.isString() &amp;&amp; !param.isWrapped()) return;
				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i &gt;= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === &quot;SpreadElement&quot;) return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() &amp;&amp; !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					}

					const value = argExpr.isString()
						? /** @type {string} */ (argExpr.string)
						: String(argExpr.number);

					/** @type {string} */
					const newString =
						value +
						(stringSuffix ? /** @type {string} */ (stringSuffix.string) : &quot;&quot;);
					const newRange = /** @type {Range} */ ([
						/** @type {Range} */ (argExpr.range)[0],
						/** @type {Range} */ ((stringSuffix || argExpr).range)[1]
					]);
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix &amp;&amp; stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() &amp;&amp; param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(/** @type {Range} */ (expr.range));
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(/** @type {Range} */ (expr.range));
				}
				const newString =
					/** @type {string} */ (param.string) +
					(stringSuffix ? stringSuffix.string : &quot;&quot;);
				return new BasicEvaluatedExpression()
					.setString(newString)
					.setSideEffects(
						(stringSuffix &amp;&amp; stringSuffix.couldHaveSideEffects()) ||
							param.couldHaveSideEffects()
					)
					.setRange(/** @type {Range} */ (expr.range));
			});
		this.hooks.evaluateCallExpressionMember
			.for(&quot;split&quot;)
			.tap(CLASS_NAME, (expr, param) =&gt; {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === &quot;SpreadElement&quot;) return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result =
						/** @type {string} */
						(param.string).split(/** @type {string} */ (arg.string));
				} else if (arg.isRegExp()) {
					result = /** @type {string} */ (param.string).split(
						/** @type {RegExp} */ (arg.regExp)
					);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(/** @type {Range} */ (expr.range));
			});
		this.hooks.evaluate.for(&quot;ConditionalExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {ConditionalExpression} */ (_expr);

			const condition = this.evaluateExpression(expr.test);
			const conditionValue = condition.asBool();
			let res;
			if (conditionValue === undefined) {
				const consequent = this.evaluateExpression(expr.consequent);
				const alternate = this.evaluateExpression(expr.alternate);
				res = new BasicEvaluatedExpression();
				if (consequent.isConditional()) {
					res.setOptions(
						/** @type {BasicEvaluatedExpression[]} */ (consequent.options)
					);
				} else {
					res.setOptions([consequent]);
				}
				if (alternate.isConditional()) {
					res.addOptions(
						/** @type {BasicEvaluatedExpression[]} */ (alternate.options)
					);
				} else {
					res.addOptions([alternate]);
				}
			} else {
				res = this.evaluateExpression(
					conditionValue ? expr.consequent : expr.alternate
				);
				if (condition.couldHaveSideEffects()) res.setSideEffects();
			}
			res.setRange(/** @type {Range} */ (expr.range));
			return res;
		});
		this.hooks.evaluate.for(&quot;ArrayExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {ArrayExpression} */ (_expr);

			const items = expr.elements.map(
				element =&gt;
					element !== null &amp;&amp;
					element.type !== &quot;SpreadElement&quot; &amp;&amp;
					this.evaluateExpression(element)
			);
			if (!items.every(Boolean)) return;
			return new BasicEvaluatedExpression()
				.setItems(/** @type {BasicEvaluatedExpression[]} */ (items))
				.setRange(/** @type {Range} */ (expr.range));
		});
		this.hooks.evaluate.for(&quot;ChainExpression&quot;).tap(CLASS_NAME, _expr =&gt; {
			const expr = /** @type {ChainExpression} */ (_expr);
			/** @type {Expression[]} */
			const optionalExpressionsStack = [];
			/** @type {Expression|Super} */
			let next = expr.expression;

			while (
				next.type === &quot;MemberExpression&quot; ||
				next.type === &quot;CallExpression&quot;
			) {
				if (next.type === &quot;MemberExpression&quot;) {
					if (next.optional) {
						// SuperNode can not be optional
						optionalExpressionsStack.push(
							/** @type {Expression} */ (next.object)
						);
					}
					next = next.object;
				} else {
					if (next.optional) {
						// SuperNode can not be optional
						optionalExpressionsStack.push(
							/** @type {Expression} */ (next.callee)
						);
					}
					next = next.callee;
				}
			}

			while (optionalExpressionsStack.length &gt; 0) {
				const expression =
					/** @type {Expression} */
					(optionalExpressionsStack.pop());
				const evaluated = this.evaluateExpression(expression);

				if (evaluated.asNullish()) {
					return evaluated.setRange(/** @type {Range} */ (_expr.range));
				}
			}
			return this.evaluateExpression(expr.expression);
		});
	}

	/**
	 * @param {Expression} node node
	 * @returns {Set&lt;DestructuringAssignmentProperty&gt; | undefined} destructured identifiers
	 */
	destructuringAssignmentPropertiesFor(node) {
		if (!this.destructuringAssignmentProperties) return;
		return this.destructuringAssignmentProperties.get(node);
	}

	/**
	 * @param {Expression | SpreadElement} expr expression
	 * @returns {string | VariableInfo | undefined} identifier
	 */
	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result.isIdentifier()) {
			return result.identifier;
		}
	}

	/**
	 * @param {ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration} classy a class node
	 * @returns {void}
	 */
	walkClass(classy) {
		if (
			classy.superClass &amp;&amp;
			!this.hooks.classExtendsExpression.call(classy.superClass, classy)
		) {
			this.walkExpression(classy.superClass);
		}
		if (classy.body &amp;&amp; classy.body.type === &quot;ClassBody&quot;) {
			const scopeParams = [];
			// Add class name in scope for recursive calls
			if (classy.id) {
				scopeParams.push(classy.id);
			}
			this.inClassScope(true, scopeParams, () =&gt; {
				for (const classElement of /** @type {TODO} */ (classy.body.body)) {
					if (!this.hooks.classBodyElement.call(classElement, classy)) {
						if (classElement.computed &amp;&amp; classElement.key) {
							this.walkExpression(classElement.key);
						}
						if (classElement.value) {
							if (
								!this.hooks.classBodyValue.call(
									classElement.value,
									classElement,
									classy
								)
							) {
								const wasTopLevel = this.scope.topLevelScope;
								this.scope.topLevelScope = false;
								this.walkExpression(classElement.value);
								this.scope.topLevelScope = wasTopLevel;
							}
						} else if (classElement.type === &quot;StaticBlock&quot;) {
							const wasTopLevel = this.scope.topLevelScope;
							this.scope.topLevelScope = false;
							this.walkBlockStatement(classElement);
							this.scope.topLevelScope = wasTopLevel;
						}
					}
				}
			});
		}
	}

	/**
	 * Pre walking iterates the scope for variable declarations
	 * @param {(Statement | ModuleDeclaration)[]} statements statements
	 */
	preWalkStatements(statements) {
		for (let index = 0, len = statements.length; index &lt; len; index++) {
			const statement = statements[index];
			this.preWalkStatement(statement);
		}
	}

	/**
	 * Block pre walking iterates the scope for block variable declarations
	 * @param {(Statement | ModuleDeclaration)[]} statements statements
	 */
	blockPreWalkStatements(statements) {
		for (let index = 0, len = statements.length; index &lt; len; index++) {
			const statement = statements[index];
			this.blockPreWalkStatement(statement);
		}
	}

	/**
	 * Walking iterates the statements and expressions and processes them
	 * @param {(Statement | ModuleDeclaration)[]} statements statements
	 */
	walkStatements(statements) {
		let onlyFunctionDeclaration = false;

		for (let index = 0, len = statements.length; index &lt; len; index++) {
			const statement = statements[index];

			if (onlyFunctionDeclaration &amp;&amp; statement.type !== &quot;FunctionDeclaration&quot;)
				continue;

			this.walkStatement(statement);

			if (this.scope.terminated) {
				onlyFunctionDeclaration = true;
			}
		}
	}

	/**
	 * Walking iterates the statements and expressions and processes them
	 * @param {Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration} statement statement
	 */
	preWalkStatement(statement) {
		/** @type {StatementPath} */
		(this.statementPath).push(statement);
		if (this.hooks.preStatement.call(statement)) {
			this.prevStatement =
				/** @type {StatementPath} */
				(this.statementPath).pop();
			return;
		}
		switch (statement.type) {
			case &quot;BlockStatement&quot;:
				this.preWalkBlockStatement(statement);
				break;
			case &quot;DoWhileStatement&quot;:
				this.preWalkDoWhileStatement(statement);
				break;
			case &quot;ForInStatement&quot;:
				this.preWalkForInStatement(statement);
				break;
			case &quot;ForOfStatement&quot;:
				this.preWalkForOfStatement(statement);
				break;
			case &quot;ForStatement&quot;:
				this.preWalkForStatement(statement);
				break;
			case &quot;FunctionDeclaration&quot;:
				this.preWalkFunctionDeclaration(statement);
				break;
			case &quot;IfStatement&quot;:
				this.preWalkIfStatement(statement);
				break;
			case &quot;LabeledStatement&quot;:
				this.preWalkLabeledStatement(statement);
				break;
			case &quot;SwitchStatement&quot;:
				this.preWalkSwitchStatement(statement);
				break;
			case &quot;TryStatement&quot;:
				this.preWalkTryStatement(statement);
				break;
			case &quot;VariableDeclaration&quot;:
				this.preWalkVariableDeclaration(statement);
				break;
			case &quot;WhileStatement&quot;:
				this.preWalkWhileStatement(statement);
				break;
			case &quot;WithStatement&quot;:
				this.preWalkWithStatement(statement);
				break;
		}
		this.prevStatement =
			/** @type {StatementPath} */
			(this.statementPath).pop();
	}

	/**
	 * @param {Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration} statement statement
	 */
	blockPreWalkStatement(statement) {
		/** @type {StatementPath} */
		(this.statementPath).push(statement);
		if (this.hooks.blockPreStatement.call(statement)) {
			this.prevStatement =
				/** @type {StatementPath} */
				(this.statementPath).pop();
			return;
		}
		switch (statement.type) {
			case &quot;ImportDeclaration&quot;:
				this.blockPreWalkImportDeclaration(statement);
				break;
			case &quot;ExportAllDeclaration&quot;:
				this.blockPreWalkExportAllDeclaration(statement);
				break;
			case &quot;ExportDefaultDeclaration&quot;:
				this.blockPreWalkExportDefaultDeclaration(statement);
				break;
			case &quot;ExportNamedDeclaration&quot;:
				this.blockPreWalkExportNamedDeclaration(statement);
				break;
			case &quot;VariableDeclaration&quot;:
				this.blockPreWalkVariableDeclaration(statement);
				break;
			case &quot;ClassDeclaration&quot;:
				this.blockPreWalkClassDeclaration(statement);
				break;
			case &quot;ExpressionStatement&quot;:
				this.blockPreWalkExpressionStatement(statement);
		}
		this.prevStatement =
			/** @type {StatementPath} */
			(this.statementPath).pop();
	}

	/**
	 * @param {Statement | ModuleDeclaration | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration} statement statement
	 */
	walkStatement(statement) {
		/** @type {StatementPath} */
		(this.statementPath).push(statement);
		if (this.hooks.statement.call(statement) !== undefined) {
			this.prevStatement =
				/** @type {StatementPath} */
				(this.statementPath).pop();
			return;
		}
		switch (statement.type) {
			case &quot;BlockStatement&quot;:
				this.walkBlockStatement(statement);
				break;
			case &quot;ClassDeclaration&quot;:
				this.walkClassDeclaration(statement);
				break;
			case &quot;DoWhileStatement&quot;:
				this.walkDoWhileStatement(statement);
				break;
			case &quot;ExportDefaultDeclaration&quot;:
				this.walkExportDefaultDeclaration(statement);
				break;
			case &quot;ExportNamedDeclaration&quot;:
				this.walkExportNamedDeclaration(statement);
				break;
			case &quot;ExpressionStatement&quot;:
				this.walkExpressionStatement(statement);
				break;
			case &quot;ForInStatement&quot;:
				this.walkForInStatement(statement);
				break;
			case &quot;ForOfStatement&quot;:
				this.walkForOfStatement(statement);
				break;
			case &quot;ForStatement&quot;:
				this.walkForStatement(statement);
				break;
			case &quot;FunctionDeclaration&quot;:
				this.walkFunctionDeclaration(statement);
				break;
			case &quot;IfStatement&quot;:
				this.walkIfStatement(statement);
				break;
			case &quot;LabeledStatement&quot;:
				this.walkLabeledStatement(statement);
				break;
			case &quot;ReturnStatement&quot;:
				this.walkReturnStatement(statement);
				break;
			case &quot;SwitchStatement&quot;:
				this.walkSwitchStatement(statement);
				break;
			case &quot;ThrowStatement&quot;:
				this.walkThrowStatement(statement);
				break;
			case &quot;TryStatement&quot;:
				this.walkTryStatement(statement);
				break;
			case &quot;VariableDeclaration&quot;:
				this.walkVariableDeclaration(statement);
				break;
			case &quot;WhileStatement&quot;:
				this.walkWhileStatement(statement);
				break;
			case &quot;WithStatement&quot;:
				this.walkWithStatement(statement);
				break;
		}
		this.prevStatement =
			/** @type {StatementPath} */
			(this.statementPath).pop();
	}

	/**
	 * Walks a statements that is nested within a parent statement
	 * and can potentially be a non-block statement.
	 * This enforces the nested statement to never be in ASI position.
	 * @param {Statement} statement the nested statement
	 */
	walkNestedStatement(statement) {
		this.prevStatement = undefined;
		this.walkStatement(statement);
	}

	// Real Statements
	/**
	 * @param {BlockStatement} statement block statement
	 */
	preWalkBlockStatement(statement) {
		this.preWalkStatements(statement.body);
	}

	/**
	 * @param {BlockStatement} statement block statement
	 */
	walkBlockStatement(statement) {
		this.inBlockScope(() =&gt; {
			const body = statement.body;
			const prev = this.prevStatement;
			this.blockPreWalkStatements(body);
			this.prevStatement = prev;
			this.walkStatements(body);
		}, true);
	}

	/**
	 * @param {ExpressionStatement} statement expression statement
	 */
	walkExpressionStatement(statement) {
		this.walkExpression(statement.expression);
	}

	/**
	 * @param {IfStatement} statement if statement
	 */
	preWalkIfStatement(statement) {
		this.preWalkStatement(statement.consequent);
		if (statement.alternate) {
			this.preWalkStatement(statement.alternate);
		}
	}

	/**
	 * @param {IfStatement} statement if statement
	 */
	walkIfStatement(statement) {
		const result = this.hooks.statementIf.call(statement);
		if (result === undefined) {
			this.walkExpression(statement.test);
			this.walkNestedStatement(statement.consequent);

			const consequentTerminated = this.scope.terminated;
			this.scope.terminated = undefined;

			if (statement.alternate) {
				this.walkNestedStatement(statement.alternate);
			}

			const alternateTerminated = this.scope.terminated;

			this.scope.terminated =
				consequentTerminated &amp;&amp; alternateTerminated
					? alternateTerminated
					: undefined;
		} else if (result) {
			this.walkNestedStatement(statement.consequent);
		} else if (statement.alternate) {
			this.walkNestedStatement(statement.alternate);
		}
	}

	/**
	 * @param {LabeledStatement} statement with statement
	 */
	preWalkLabeledStatement(statement) {
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {LabeledStatement} statement with statement
	 */
	walkLabeledStatement(statement) {
		const hook = this.hooks.label.get(statement.label.name);
		if (hook !== undefined) {
			const result = hook.call(statement);
			if (result === true) return;
		}
		this.inBlockScope(() =&gt; {
			this.walkNestedStatement(statement.body);
		});
	}

	/**
	 * @param {WithStatement} statement with statement
	 */
	preWalkWithStatement(statement) {
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {WithStatement} statement with statement
	 */
	walkWithStatement(statement) {
		this.inBlockScope(() =&gt; {
			this.walkExpression(statement.object);
			this.walkNestedStatement(statement.body);
		});
	}

	/**
	 * @param {SwitchStatement} statement switch statement
	 */
	preWalkSwitchStatement(statement) {
		this.preWalkSwitchCases(statement.cases);
	}

	/**
	 * @param {SwitchStatement} statement switch statement
	 */
	walkSwitchStatement(statement) {
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	}

	/**
	 * @param {ReturnStatement | ThrowStatement} statement return or throw statement
	 */
	walkTerminatingStatement(statement) {
		if (statement.argument) this.walkExpression(statement.argument);
		// Skip top level scope because to handle `export` and `module.exports` after terminate
		if (this.scope.topLevelScope === true) return;
		if (this.hooks.terminate.call(statement)) {
			this.scope.terminated =
				statement.type === &quot;ReturnStatement&quot;
					? SCOPE_INFO_TERMINATED_RETURN
					: SCOPE_INFO_TERMINATED_THROW;
		}
	}

	/**
	 * @param {ReturnStatement} statement return statement
	 */
	walkReturnStatement(statement) {
		this.walkTerminatingStatement(statement);
	}

	/**
	 * @param {ThrowStatement} statement return statement
	 */
	walkThrowStatement(statement) {
		this.walkTerminatingStatement(statement);
	}

	/**
	 * @param {TryStatement} statement try statement
	 */
	preWalkTryStatement(statement) {
		this.preWalkStatement(statement.block);
		if (statement.handler) this.preWalkCatchClause(statement.handler);
		if (statement.finalizer) this.preWalkStatement(statement.finalizer);
	}

	/**
	 * @param {TryStatement} statement try statement
	 */
	walkTryStatement(statement) {
		if (this.scope.inTry) {
			this.walkStatement(statement.block);
		} else {
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		}

		const tryTerminated = this.scope.terminated;
		this.scope.terminated = undefined;

		if (statement.handler) this.walkCatchClause(statement.handler);

		const handlerTerminated = this.scope.terminated;
		this.scope.terminated = undefined;

		if (statement.finalizer) {
			this.walkStatement(statement.finalizer);
		}

		const finalizerTerminated = this.scope.terminated;
		this.scope.terminated = undefined;

		if (finalizerTerminated) {
			this.scope.terminated = finalizerTerminated;
		} else if (
			tryTerminated &amp;&amp;
			(statement.handler ? handlerTerminated : true)
		) {
			this.scope.terminated = handlerTerminated || tryTerminated;
		}
	}

	/**
	 * @param {WhileStatement} statement while statement
	 */
	preWalkWhileStatement(statement) {
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {WhileStatement} statement while statement
	 */
	walkWhileStatement(statement) {
		this.inBlockScope(() =&gt; {
			this.walkExpression(statement.test);
			this.walkNestedStatement(statement.body);
		});
	}

	/**
	 * @param {DoWhileStatement} statement do while statement
	 */
	preWalkDoWhileStatement(statement) {
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {DoWhileStatement} statement do while statement
	 */
	walkDoWhileStatement(statement) {
		this.inBlockScope(() =&gt; {
			this.walkNestedStatement(statement.body);
			this.walkExpression(statement.test);
		});
	}

	/**
	 * @param {ForStatement} statement for statement
	 */
	preWalkForStatement(statement) {
		if (statement.init &amp;&amp; statement.init.type === &quot;VariableDeclaration&quot;) {
			this.preWalkStatement(statement.init);
		}
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {ForStatement} statement for statement
	 */
	walkForStatement(statement) {
		this.inBlockScope(() =&gt; {
			if (statement.init) {
				if (statement.init.type === &quot;VariableDeclaration&quot;) {
					this.blockPreWalkVariableDeclaration(statement.init);
					this.prevStatement = undefined;
					this.walkStatement(statement.init);
				} else {
					this.walkExpression(statement.init);
				}
			}
			if (statement.test) {
				this.walkExpression(statement.test);
			}
			if (statement.update) {
				this.walkExpression(statement.update);
			}

			const body = statement.body;

			if (body.type === &quot;BlockStatement&quot;) {
				// no need to add additional scope
				const prev = this.prevStatement;
				this.blockPreWalkStatements(body.body);
				this.prevStatement = prev;
				this.walkStatements(body.body);
			} else {
				this.walkNestedStatement(body);
			}
		});
	}

	/**
	 * @param {ForInStatement} statement for statement
	 */
	preWalkForInStatement(statement) {
		if (statement.left.type === &quot;VariableDeclaration&quot;) {
			this.preWalkVariableDeclaration(statement.left);
		}
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {ForInStatement} statement for statement
	 */
	walkForInStatement(statement) {
		this.inBlockScope(() =&gt; {
			if (statement.left.type === &quot;VariableDeclaration&quot;) {
				this.blockPreWalkVariableDeclaration(statement.left);
				this.walkVariableDeclaration(statement.left);
			} else {
				this.walkPattern(statement.left);
			}

			this.walkExpression(statement.right);

			const body = statement.body;

			if (body.type === &quot;BlockStatement&quot;) {
				// no need to add additional scope
				const prev = this.prevStatement;
				this.blockPreWalkStatements(body.body);
				this.prevStatement = prev;
				this.walkStatements(body.body);
			} else {
				this.walkNestedStatement(body);
			}
		});
	}

	/**
	 * @param {ForOfStatement} statement statement
	 */
	preWalkForOfStatement(statement) {
		if (statement.await &amp;&amp; this.scope.topLevelScope === true) {
			this.hooks.topLevelAwait.call(statement);
		}
		if (statement.left.type === &quot;VariableDeclaration&quot;) {
			this.preWalkVariableDeclaration(statement.left);
		}
		this.preWalkStatement(statement.body);
	}

	/**
	 * @param {ForOfStatement} statement for statement
	 */
	walkForOfStatement(statement) {
		this.inBlockScope(() =&gt; {
			if (statement.left.type === &quot;VariableDeclaration&quot;) {
				this.blockPreWalkVariableDeclaration(statement.left);
				this.walkVariableDeclaration(statement.left);
			} else {
				this.walkPattern(statement.left);
			}

			this.walkExpression(statement.right);

			const body = statement.body;

			if (body.type === &quot;BlockStatement&quot;) {
				// no need to add additional scope
				const prev = this.prevStatement;
				this.blockPreWalkStatements(body.body);
				this.prevStatement = prev;
				this.walkStatements(body.body);
			} else {
				this.walkNestedStatement(body);
			}
		});
	}

	/**
	 * @param {FunctionDeclaration | MaybeNamedFunctionDeclaration} statement function declaration
	 */
	preWalkFunctionDeclaration(statement) {
		if (statement.id) {
			this.defineVariable(statement.id.name);
		}
	}

	/**
	 * @param {FunctionDeclaration | MaybeNamedFunctionDeclaration} statement function declaration
	 */
	walkFunctionDeclaration(statement) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		this.inFunctionScope(true, statement.params, () =&gt; {
			for (const param of statement.params) {
				this.walkPattern(param);
			}

			this.detectMode(statement.body.body);

			const prev = this.prevStatement;

			this.preWalkStatement(statement.body);
			this.prevStatement = prev;
			this.walkStatement(statement.body);
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	/**
	 * @param {ExpressionStatement} statement expression statement
	 */
	blockPreWalkExpressionStatement(statement) {
		const expression = statement.expression;
		switch (expression.type) {
			case &quot;AssignmentExpression&quot;:
				this.preWalkAssignmentExpression(expression);
		}
	}

	/**
	 * @param {AssignmentExpression} expression assignment expression
	 */
	preWalkAssignmentExpression(expression) {
		if (
			expression.left.type !== &quot;ObjectPattern&quot; ||
			!this.destructuringAssignmentProperties
		)
			return;
		const keys = this._preWalkObjectPattern(expression.left);
		if (!keys) return;

		// check multiple assignments
		if (this.destructuringAssignmentProperties.has(expression)) {
			const set =
				/** @type {Set&lt;DestructuringAssignmentProperty&gt;} */
				(this.destructuringAssignmentProperties.get(expression));
			this.destructuringAssignmentProperties.delete(expression);
			for (const id of set) keys.add(id);
		}

		this.destructuringAssignmentProperties.set(
			expression.right.type === &quot;AwaitExpression&quot;
				? expression.right.argument
				: expression.right,
			keys
		);

		if (expression.right.type === &quot;AssignmentExpression&quot;) {
			this.preWalkAssignmentExpression(expression.right);
		}
	}

	/**
	 * @param {ImportDeclaration} statement statement
	 */
	blockPreWalkImportDeclaration(statement) {
		const source = /** @type {ImportSource} */ (statement.source.value);
		this.hooks.import.call(statement, source);
		for (const specifier of statement.specifiers) {
			const name = specifier.local.name;
			switch (specifier.type) {
				case &quot;ImportDefaultSpecifier&quot;:
					if (
						!this.hooks.importSpecifier.call(statement, source, &quot;default&quot;, name)
					) {
						this.defineVariable(name);
					}
					break;
				case &quot;ImportSpecifier&quot;:
					if (
						!this.hooks.importSpecifier.call(
							statement,
							source,
							/** @type {Identifier} */
							(specifier.imported).name ||
								/** @type {string} */
								(
									/** @type {Literal} */
									(specifier.imported).value
								),
							name
						)
					) {
						this.defineVariable(name);
					}
					break;
				case &quot;ImportNamespaceSpecifier&quot;:
					if (!this.hooks.importSpecifier.call(statement, source, null, name)) {
						this.defineVariable(name);
					}
					break;
				default:
					this.defineVariable(name);
			}
		}
	}

	/**
	 * @param {Declaration} declaration declaration
	 * @param {OnIdent} onIdent on ident callback
	 */
	enterDeclaration(declaration, onIdent) {
		switch (declaration.type) {
			case &quot;VariableDeclaration&quot;:
				for (const declarator of declaration.declarations) {
					switch (declarator.type) {
						case &quot;VariableDeclarator&quot;: {
							this.enterPattern(declarator.id, onIdent);
							break;
						}
					}
				}
				break;
			case &quot;FunctionDeclaration&quot;:
				this.enterPattern(declaration.id, onIdent);
				break;
			case &quot;ClassDeclaration&quot;:
				this.enterPattern(declaration.id, onIdent);
				break;
		}
	}

	/**
	 * @param {ExportNamedDeclaration} statement statement
	 */
	blockPreWalkExportNamedDeclaration(statement) {
		let source;
		if (statement.source) {
			source = /** @type {ImportSource} */ (statement.source.value);
			this.hooks.exportImport.call(statement, source);
		} else {
			this.hooks.export.call(statement);
		}
		if (
			statement.declaration &amp;&amp;
			!this.hooks.exportDeclaration.call(statement, statement.declaration)
		) {
			const prev = this.prevStatement;
			this.preWalkStatement(statement.declaration);
			this.prevStatement = prev;
			this.blockPreWalkStatement(statement.declaration);
			let index = 0;
			this.enterDeclaration(statement.declaration, def =&gt; {
				this.hooks.exportSpecifier.call(statement, def, def, index++);
			});
		}
		if (statement.specifiers) {
			for (
				let specifierIndex = 0;
				specifierIndex &lt; statement.specifiers.length;
				specifierIndex++
			) {
				const specifier = statement.specifiers[specifierIndex];
				switch (specifier.type) {
					case &quot;ExportSpecifier&quot;: {
						const localName =
							/** @type {Identifier} */ (specifier.local).name ||
							/** @type {string} */ (
								/** @type {Literal} */ (specifier.local).value
							);
						const name =
							/** @type {Identifier} */
							(specifier.exported).name ||
							/** @type {string} */
							(/** @type {Literal} */ (specifier.exported).value);
						if (source) {
							this.hooks.exportImportSpecifier.call(
								statement,
								source,
								localName,
								name,
								specifierIndex
							);
						} else {
							this.hooks.exportSpecifier.call(
								statement,
								localName,
								name,
								specifierIndex
							);
						}
						break;
					}
				}
			}
		}
	}

	/**
	 * @param {ExportNamedDeclaration} statement the statement
	 */
	walkExportNamedDeclaration(statement) {
		if (statement.declaration) {
			this.walkStatement(statement.declaration);
		}
	}

	/**
	 * @param {ExportDefaultDeclaration} statement statement
	 */
	blockPreWalkExportDefaultDeclaration(statement) {
		const prev = this.prevStatement;

		this.preWalkStatement(/** @type {TODO} */ (statement.declaration));
		this.prevStatement = prev;
		this.blockPreWalkStatement(/** @type {TODO} */ (statement.declaration));

		if (
			/** @type {MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration} */
			(statement.declaration).id &amp;&amp;
			statement.declaration.type !== &quot;FunctionExpression&quot; &amp;&amp;
			statement.declaration.type !== &quot;ClassExpression&quot;
		) {
			const declaration =
				/** @type {MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration} */
				(statement.declaration);

			this.hooks.exportSpecifier.call(
				statement,
				/** @type {Identifier} */
				(declaration.id).name,
				&quot;default&quot;,
				undefined
			);
		}
	}

	/**
	 * @param {ExportDefaultDeclaration} statement statement
	 */
	walkExportDefaultDeclaration(statement) {
		this.hooks.export.call(statement);
		if (
			/** @type {FunctionDeclaration | ClassDeclaration} */
			(statement.declaration).id &amp;&amp;
			statement.declaration.type !== &quot;FunctionExpression&quot; &amp;&amp;
			statement.declaration.type !== &quot;ClassExpression&quot;
		) {
			const declaration =
				/** @type {FunctionDeclaration | ClassDeclaration} */
				(statement.declaration);
			if (!this.hooks.exportDeclaration.call(statement, declaration)) {
				this.walkStatement(declaration);
			}
		} else {
			// Acorn parses `export default function() {}` as `FunctionDeclaration` and
			// `export default class {}` as `ClassDeclaration`, both with `id = null`.
			// These nodes must be treated as expressions.
			if (
				statement.declaration.type === &quot;FunctionDeclaration&quot; ||
				statement.declaration.type === &quot;ClassDeclaration&quot;
			) {
				this.walkStatement(statement.declaration);
			} else {
				this.walkExpression(statement.declaration);
			}

			if (!this.hooks.exportExpression.call(statement, statement.declaration)) {
				this.hooks.exportSpecifier.call(
					statement,
					/** @type {TODO} */
					(statement.declaration),
					&quot;default&quot;,
					undefined
				);
			}
		}
	}

	/**
	 * @param {ExportAllDeclaration} statement statement
	 */
	blockPreWalkExportAllDeclaration(statement) {
		const source = /** @type {ImportSource} */ (statement.source.value);
		const name = statement.exported
			? /** @type {Identifier} */
				(statement.exported).name ||
				/** @type {string} */
				(/** @type {Literal} */ (statement.exported).value)
			: null;
		this.hooks.exportImport.call(statement, source);
		this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);
	}

	/**
	 * @param {VariableDeclaration} statement variable declaration
	 */
	preWalkVariableDeclaration(statement) {
		if (statement.kind !== &quot;var&quot;) return;
		this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);
	}

	/**
	 * @param {VariableDeclaration} statement variable declaration
	 */
	blockPreWalkVariableDeclaration(statement) {
		if (statement.kind === &quot;var&quot;) return;
		const hookMap =
			statement.kind === &quot;const&quot;
				? this.hooks.varDeclarationConst
				: this.hooks.varDeclarationLet;
		this._preWalkVariableDeclaration(statement, hookMap);
	}

	/**
	 * @param {VariableDeclaration} statement variable declaration
	 * @param {TODO} hookMap map of hooks
	 */
	_preWalkVariableDeclaration(statement, hookMap) {
		for (const declarator of statement.declarations) {
			switch (declarator.type) {
				case &quot;VariableDeclarator&quot;: {
					this.preWalkVariableDeclarator(declarator);
					if (!this.hooks.preDeclarator.call(declarator, statement)) {
						this.enterPattern(declarator.id, (name, decl) =&gt; {
							let hook = hookMap.get(name);
							if (hook === undefined || !hook.call(decl)) {
								hook = this.hooks.varDeclaration.get(name);
								if (hook === undefined || !hook.call(decl)) {
									this.defineVariable(name);
								}
							}
						});
					}
					break;
				}
			}
		}
	}

	/**
	 * @param {ObjectPattern} objectPattern object pattern
	 * @returns {Set&lt;DestructuringAssignmentProperty&gt; | undefined} set of names or undefined if not all keys are identifiers
	 */
	_preWalkObjectPattern(objectPattern) {
		/** @type {Set&lt;DestructuringAssignmentProperty&gt;} */
		const props = new Set();
		const properties = objectPattern.properties;
		for (let i = 0; i &lt; properties.length; i++) {
			const property = properties[i];
			if (property.type !== &quot;Property&quot;) return;
			if (property.shorthand &amp;&amp; property.value.type === &quot;Identifier&quot;) {
				this.scope.inShorthand = property.value.name;
			}
			const key = property.key;
			if (key.type === &quot;Identifier&quot;) {
				props.add({
					id: key.name,
					range: key.range,
					shorthand: this.scope.inShorthand
				});
			} else {
				const id = this.evaluateExpression(key);
				const str = id.asString();
				if (str) {
					props.add({
						id: str,
						range: key.range,
						shorthand: this.scope.inShorthand
					});
				} else {
					// could not evaluate key
					return;
				}
			}
			this.scope.inShorthand = false;
		}

		return props;
	}

	/**
	 * @param {VariableDeclarator} declarator variable declarator
	 */
	preWalkVariableDeclarator(declarator) {
		if (
			!declarator.init ||
			declarator.id.type !== &quot;ObjectPattern&quot; ||
			!this.destructuringAssignmentProperties
		)
			return;
		const keys = this._preWalkObjectPattern(declarator.id);

		if (!keys) return;
		this.destructuringAssignmentProperties.set(
			declarator.init.type === &quot;AwaitExpression&quot;
				? declarator.init.argument
				: declarator.init,
			keys
		);

		if (declarator.init.type === &quot;AssignmentExpression&quot;) {
			this.preWalkAssignmentExpression(declarator.init);
		}
	}

	/**
	 * @param {VariableDeclaration} statement variable declaration
	 */
	walkVariableDeclaration(statement) {
		for (const declarator of statement.declarations) {
			switch (declarator.type) {
				case &quot;VariableDeclarator&quot;: {
					const renameIdentifier =
						declarator.init &amp;&amp; this.getRenameIdentifier(declarator.init);
					if (renameIdentifier &amp;&amp; declarator.id.type === &quot;Identifier&quot;) {
						const hook = this.hooks.canRename.get(renameIdentifier);
						if (
							hook !== undefined &amp;&amp;
							hook.call(/** @type {Expression} */ (declarator.init))
						) {
							// renaming with &quot;var a = b;&quot;
							const hook = this.hooks.rename.get(renameIdentifier);
							if (
								hook === undefined ||
								!hook.call(/** @type {Expression} */ (declarator.init))
							) {
								this.setVariable(declarator.id.name, renameIdentifier);
							}
							break;
						}
					}
					if (!this.hooks.declarator.call(declarator, statement)) {
						this.walkPattern(declarator.id);
						if (declarator.init) this.walkExpression(declarator.init);
					}
					break;
				}
			}
		}
	}

	/**
	 * @param {ClassDeclaration | MaybeNamedClassDeclaration} statement class declaration
	 */
	blockPreWalkClassDeclaration(statement) {
		if (statement.id) {
			this.defineVariable(statement.id.name);
		}
	}

	/**
	 * @param {ClassDeclaration | MaybeNamedClassDeclaration} statement class declaration
	 */
	walkClassDeclaration(statement) {
		this.walkClass(statement);
	}

	/**
	 * @param {SwitchCase[]} switchCases switch statement
	 */
	preWalkSwitchCases(switchCases) {
		for (let index = 0, len = switchCases.length; index &lt; len; index++) {
			const switchCase = switchCases[index];
			this.preWalkStatements(switchCase.consequent);
		}
	}

	/**
	 * @param {SwitchCase[]} switchCases switch statement
	 */
	walkSwitchCases(switchCases) {
		this.inBlockScope(() =&gt; {
			const len = switchCases.length;

			// we need to pre walk all statements first since we can have invalid code
			// import A from &quot;module&quot;;
			// switch(1) {
			//    case 1:
			//      console.log(A); // should fail at runtime
			//    case 2:
			//      const A = 1;
			// }
			for (let index = 0; index &lt; len; index++) {
				const switchCase = switchCases[index];

				if (switchCase.consequent.length &gt; 0) {
					const prev = this.prevStatement;
					this.blockPreWalkStatements(switchCase.consequent);
					this.prevStatement = prev;
				}
			}

			for (let index = 0; index &lt; len; index++) {
				const switchCase = switchCases[index];

				if (switchCase.test) {
					this.walkExpression(switchCase.test);
				}

				if (switchCase.consequent.length &gt; 0) {
					this.walkStatements(switchCase.consequent);
					this.scope.terminated = undefined;
				}
			}
		});
	}

	/**
	 * @param {CatchClause} catchClause catch clause
	 */
	preWalkCatchClause(catchClause) {
		this.preWalkStatement(catchClause.body);
	}

	/**
	 * @param {CatchClause} catchClause catch clause
	 */
	walkCatchClause(catchClause) {
		this.inBlockScope(() =&gt; {
			// Error binding is optional in catch clause since ECMAScript 2019
			if (catchClause.param !== null) {
				this.enterPattern(catchClause.param, ident =&gt; {
					this.defineVariable(ident);
				});
				this.walkPattern(catchClause.param);
			}
			const prev = this.prevStatement;
			this.blockPreWalkStatement(catchClause.body);
			this.prevStatement = prev;
			this.walkStatement(catchClause.body);
		}, true);
	}

	/**
	 * @param {Pattern} pattern pattern
	 */
	walkPattern(pattern) {
		switch (pattern.type) {
			case &quot;ArrayPattern&quot;:
				this.walkArrayPattern(pattern);
				break;
			case &quot;AssignmentPattern&quot;:
				this.walkAssignmentPattern(pattern);
				break;
			case &quot;MemberExpression&quot;:
				this.walkMemberExpression(pattern);
				break;
			case &quot;ObjectPattern&quot;:
				this.walkObjectPattern(pattern);
				break;
			case &quot;RestElement&quot;:
				this.walkRestElement(pattern);
				break;
		}
	}

	/**
	 * @param {AssignmentPattern} pattern assignment pattern
	 */
	walkAssignmentPattern(pattern) {
		this.walkExpression(pattern.right);
		this.walkPattern(pattern.left);
	}

	/**
	 * @param {ObjectPattern} pattern pattern
	 */
	walkObjectPattern(pattern) {
		for (let i = 0, len = pattern.properties.length; i &lt; len; i++) {
			const prop = pattern.properties[i];
			if (prop) {
				if (prop.type === &quot;RestElement&quot;) {
					continue;
				}
				if (prop.computed) this.walkExpression(prop.key);
				if (prop.value) this.walkPattern(prop.value);
			}
		}
	}

	/**
	 * @param {ArrayPattern} pattern array pattern
	 */
	walkArrayPattern(pattern) {
		for (let i = 0, len = pattern.elements.length; i &lt; len; i++) {
			const element = pattern.elements[i];
			if (element) this.walkPattern(element);
		}
	}

	/**
	 * @param {RestElement} pattern rest element
	 */
	walkRestElement(pattern) {
		this.walkPattern(pattern.argument);
	}

	/**
	 * @param {(Expression | SpreadElement | null)[]} expressions expressions
	 */
	walkExpressions(expressions) {
		for (const expression of expressions) {
			if (expression) {
				this.walkExpression(expression);
			}
		}
	}

	/**
	 * @param {Expression | SpreadElement | PrivateIdentifier | Super} expression expression
	 */
	walkExpression(expression) {
		switch (expression.type) {
			case &quot;ArrayExpression&quot;:
				this.walkArrayExpression(expression);
				break;
			case &quot;ArrowFunctionExpression&quot;:
				this.walkArrowFunctionExpression(expression);
				break;
			case &quot;AssignmentExpression&quot;:
				this.walkAssignmentExpression(expression);
				break;
			case &quot;AwaitExpression&quot;:
				this.walkAwaitExpression(expression);
				break;
			case &quot;BinaryExpression&quot;:
				this.walkBinaryExpression(expression);
				break;
			case &quot;CallExpression&quot;:
				this.walkCallExpression(expression);
				break;
			case &quot;ChainExpression&quot;:
				this.walkChainExpression(expression);
				break;
			case &quot;ClassExpression&quot;:
				this.walkClassExpression(expression);
				break;
			case &quot;ConditionalExpression&quot;:
				this.walkConditionalExpression(expression);
				break;
			case &quot;FunctionExpression&quot;:
				this.walkFunctionExpression(expression);
				break;
			case &quot;Identifier&quot;:
				this.walkIdentifier(expression);
				break;
			case &quot;ImportExpression&quot;:
				this.walkImportExpression(expression);
				break;
			case &quot;LogicalExpression&quot;:
				this.walkLogicalExpression(expression);
				break;
			case &quot;MetaProperty&quot;:
				this.walkMetaProperty(expression);
				break;
			case &quot;MemberExpression&quot;:
				this.walkMemberExpression(expression);
				break;
			case &quot;NewExpression&quot;:
				this.walkNewExpression(expression);
				break;
			case &quot;ObjectExpression&quot;:
				this.walkObjectExpression(expression);
				break;
			case &quot;SequenceExpression&quot;:
				this.walkSequenceExpression(expression);
				break;
			case &quot;SpreadElement&quot;:
				this.walkSpreadElement(expression);
				break;
			case &quot;TaggedTemplateExpression&quot;:
				this.walkTaggedTemplateExpression(expression);
				break;
			case &quot;TemplateLiteral&quot;:
				this.walkTemplateLiteral(expression);
				break;
			case &quot;ThisExpression&quot;:
				this.walkThisExpression(expression);
				break;
			case &quot;UnaryExpression&quot;:
				this.walkUnaryExpression(expression);
				break;
			case &quot;UpdateExpression&quot;:
				this.walkUpdateExpression(expression);
				break;
			case &quot;YieldExpression&quot;:
				this.walkYieldExpression(expression);
				break;
		}
	}

	/**
	 * @param {AwaitExpression} expression await expression
	 */
	walkAwaitExpression(expression) {
		if (this.scope.topLevelScope === true)
			this.hooks.topLevelAwait.call(expression);
		this.walkExpression(expression.argument);
	}

	/**
	 * @param {ArrayExpression} expression array expression
	 */
	walkArrayExpression(expression) {
		if (expression.elements) {
			this.walkExpressions(expression.elements);
		}
	}

	/**
	 * @param {SpreadElement} expression spread element
	 */
	walkSpreadElement(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		}
	}

	/**
	 * @param {ObjectExpression} expression object expression
	 */
	walkObjectExpression(expression) {
		for (
			let propIndex = 0, len = expression.properties.length;
			propIndex &lt; len;
			propIndex++
		) {
			const prop = expression.properties[propIndex];
			this.walkProperty(prop);
		}
	}

	/**
	 * @param {Property | SpreadElement} prop property or spread element
	 */
	walkProperty(prop) {
		if (prop.type === &quot;SpreadElement&quot;) {
			this.walkExpression(prop.argument);
			return;
		}
		if (prop.computed) {
			this.walkExpression(prop.key);
		}
		if (prop.shorthand &amp;&amp; prop.value &amp;&amp; prop.value.type === &quot;Identifier&quot;) {
			this.scope.inShorthand = prop.value.name;
			this.walkIdentifier(prop.value);
			this.scope.inShorthand = false;
		} else {
			this.walkExpression(
				/** @type {Exclude&lt;Property[&quot;value&quot;], AssignmentPattern | ObjectPattern | ArrayPattern | RestElement&gt;} */
				(prop.value)
			);
		}
	}

	/**
	 * @param {FunctionExpression} expression arrow function expression
	 */
	walkFunctionExpression(expression) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		const scopeParams = [...expression.params];

		// Add function name in scope for recursive calls
		if (expression.id) {
			scopeParams.push(expression.id);
		}

		this.inFunctionScope(true, scopeParams, () =&gt; {
			for (const param of expression.params) {
				this.walkPattern(param);
			}

			this.detectMode(expression.body.body);

			const prev = this.prevStatement;

			this.preWalkStatement(expression.body);
			this.prevStatement = prev;
			this.walkStatement(expression.body);
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	/**
	 * @param {ArrowFunctionExpression} expression arrow function expression
	 */
	walkArrowFunctionExpression(expression) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = wasTopLevel ? &quot;arrow&quot; : false;
		this.inFunctionScope(false, expression.params, () =&gt; {
			for (const param of expression.params) {
				this.walkPattern(param);
			}
			if (expression.body.type === &quot;BlockStatement&quot;) {
				this.detectMode(expression.body.body);
				const prev = this.prevStatement;
				this.preWalkStatement(expression.body);
				this.prevStatement = prev;
				this.walkStatement(expression.body);
			} else {
				this.walkExpression(expression.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	/**
	 * @param {SequenceExpression} expression the sequence
	 */
	walkSequenceExpression(expression) {
		if (!expression.expressions) return;
		// We treat sequence expressions like statements when they are one statement level
		// This has some benefits for optimizations that only work on statement level
		const currentStatement =
			/** @type {StatementPath} */
			(this.statementPath)[
				/** @type {StatementPath} */
				(this.statementPath).length - 1
			];
		if (
			currentStatement === expression ||
			(currentStatement.type === &quot;ExpressionStatement&quot; &amp;&amp;
				currentStatement.expression === expression)
		) {
			const old =
				/** @type {StatementPathItem} */
				(/** @type {StatementPath} */ (this.statementPath).pop());
			const prev = this.prevStatement;
			for (const expr of expression.expressions) {
				/** @type {StatementPath} */
				(this.statementPath).push(expr);
				this.walkExpression(expr);
				this.prevStatement =
					/** @type {StatementPath} */
					(this.statementPath).pop();
			}
			this.prevStatement = prev;
			/** @type {StatementPath} */
			(this.statementPath).push(old);
		} else {
			this.walkExpressions(expression.expressions);
		}
	}

	/**
	 * @param {UpdateExpression} expression the update expression
	 */
	walkUpdateExpression(expression) {
		this.walkExpression(expression.argument);
	}

	/**
	 * @param {UnaryExpression} expression the unary expression
	 */
	walkUnaryExpression(expression) {
		if (expression.operator === &quot;typeof&quot;) {
			const result = this.callHooksForExpression(
				this.hooks.typeof,
				expression.argument,
				expression
			);
			if (result === true) return;
			if (expression.argument.type === &quot;ChainExpression&quot;) {
				const result = this.callHooksForExpression(
					this.hooks.typeof,
					expression.argument.expression,
					expression
				);
				if (result === true) return;
			}
		}
		this.walkExpression(expression.argument);
	}

	/**
	 * @param {LogicalExpression | BinaryExpression} expression the expression
	 */
	walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}

	/**
	 * @param {BinaryExpression} expression the binary expression
	 */
	walkBinaryExpression(expression) {
		if (this.hooks.binaryExpression.call(expression) === undefined) {
			this.walkLeftRightExpression(expression);
		}
	}

	/**
	 * @param {LogicalExpression} expression the logical expression
	 */
	walkLogicalExpression(expression) {
		const result = this.hooks.expressionLogicalOperator.call(expression);
		if (result === undefined) {
			this.walkLeftRightExpression(expression);
		} else if (result) {
			this.walkExpression(expression.right);
		}
	}

	/**
	 * @param {AssignmentExpression} expression assignment expression
	 */
	walkAssignmentExpression(expression) {
		if (expression.left.type === &quot;Identifier&quot;) {
			const renameIdentifier = this.getRenameIdentifier(expression.right);
			if (
				renameIdentifier &amp;&amp;
				this.callHooksForInfo(
					this.hooks.canRename,
					renameIdentifier,
					expression.right
				)
			) {
				// renaming &quot;a = b;&quot;
				if (
					!this.callHooksForInfo(
						this.hooks.rename,
						renameIdentifier,
						expression.right
					)
				) {
					this.setVariable(
						expression.left.name,
						typeof renameIdentifier === &quot;string&quot;
							? this.getVariableInfo(renameIdentifier)
							: renameIdentifier
					);
				}
				return;
			}
			this.walkExpression(expression.right);
			this.enterPattern(expression.left, (name, decl) =&gt; {
				if (!this.callHooksForName(this.hooks.assign, name, expression)) {
					this.walkExpression(
						/** @type {MemberExpression} */
						(expression.left)
					);
				}
			});
		} else if (expression.left.type.endsWith(&quot;Pattern&quot;)) {
			this.walkExpression(expression.right);
			this.enterPattern(expression.left, (name, decl) =&gt; {
				if (!this.callHooksForName(this.hooks.assign, name, expression)) {
					this.defineVariable(name);
				}
			});
			this.walkPattern(expression.left);
		} else if (expression.left.type === &quot;MemberExpression&quot;) {
			const exprName = this.getMemberExpressionInfo(
				expression.left,
				ALLOWED_MEMBER_TYPES_EXPRESSION
			);
			if (
				exprName &amp;&amp;
				this.callHooksForInfo(
					this.hooks.assignMemberChain,
					exprName.rootInfo,
					expression,
					exprName.getMembers()
				)
			) {
				return;
			}
			this.walkExpression(expression.right);
			this.walkExpression(expression.left);
		} else {
			this.walkExpression(expression.right);
			this.walkExpression(
				/** @type {Exclude&lt;AssignmentExpression[&quot;left&quot;], Identifier | RestElement | MemberExpression | ObjectPattern | ArrayPattern | AssignmentPattern&gt;} */
				(expression.left)
			);
		}
	}

	/**
	 * @param {ConditionalExpression} expression conditional expression
	 */
	walkConditionalExpression(expression) {
		const result = this.hooks.expressionConditionalOperator.call(expression);
		if (result === undefined) {
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);

			if (expression.alternate) {
				this.walkExpression(expression.alternate);
			}
		} else if (result) {
			this.walkExpression(expression.consequent);
		} else if (expression.alternate) {
			this.walkExpression(expression.alternate);
		}
	}

	/**
	 * @param {NewExpression} expression new expression
	 */
	walkNewExpression(expression) {
		const result = this.callHooksForExpression(
			this.hooks.new,
			expression.callee,
			expression
		);
		if (result === true) return;
		this.walkExpression(expression.callee);
		if (expression.arguments) {
			this.walkExpressions(expression.arguments);
		}
	}

	/**
	 * @param {YieldExpression} expression yield expression
	 */
	walkYieldExpression(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		}
	}

	/**
	 * @param {TemplateLiteral} expression template literal
	 */
	walkTemplateLiteral(expression) {
		if (expression.expressions) {
			this.walkExpressions(expression.expressions);
		}
	}

	/**
	 * @param {TaggedTemplateExpression} expression tagged template expression
	 */
	walkTaggedTemplateExpression(expression) {
		if (expression.tag) {
			this.scope.inTaggedTemplateTag = true;
			this.walkExpression(expression.tag);
			this.scope.inTaggedTemplateTag = false;
		}
		if (expression.quasi &amp;&amp; expression.quasi.expressions) {
			this.walkExpressions(expression.quasi.expressions);
		}
	}

	/**
	 * @param {ClassExpression} expression the class expression
	 */
	walkClassExpression(expression) {
		this.walkClass(expression);
	}

	/**
	 * @param {ChainExpression} expression expression
	 */
	walkChainExpression(expression) {
		const result = this.hooks.optionalChaining.call(expression);

		if (result === undefined) {
			if (expression.expression.type === &quot;CallExpression&quot;) {
				this.walkCallExpression(expression.expression);
			} else {
				this.walkMemberExpression(expression.expression);
			}
		}
	}

	/**
	 * @private
	 * @param {FunctionExpression | ArrowFunctionExpression} functionExpression function expression
	 * @param {(Expression | SpreadElement)[]} options options
	 * @param {Expression | SpreadElement | null} currentThis current this
	 */
	_walkIIFE(functionExpression, options, currentThis) {
		/**
		 * @param {Expression | SpreadElement} argOrThis arg or this
		 * @returns {string | VariableInfo | undefined} var info
		 */
		const getVarInfo = argOrThis =&gt; {
			const renameIdentifier = this.getRenameIdentifier(argOrThis);
			if (
				renameIdentifier &amp;&amp;
				this.callHooksForInfo(
					this.hooks.canRename,
					renameIdentifier,
					/** @type {Expression} */
					(argOrThis)
				) &amp;&amp;
				!this.callHooksForInfo(
					this.hooks.rename,
					renameIdentifier,
					/** @type {Expression} */
					(argOrThis)
				)
			) {
				return typeof renameIdentifier === &quot;string&quot;
					? /** @type {string} */ (this.getVariableInfo(renameIdentifier))
					: renameIdentifier;
			}
			this.walkExpression(argOrThis);
		};
		const { params, type } = functionExpression;
		const arrow = type === &quot;ArrowFunctionExpression&quot;;
		const renameThis = currentThis ? getVarInfo(currentThis) : null;
		const varInfoForArgs = options.map(getVarInfo);
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = wasTopLevel &amp;&amp; arrow ? &quot;arrow&quot; : false;
		const scopeParams =
			/** @type {(Identifier | string)[]} */
			(params.filter((identifier, idx) =&gt; !varInfoForArgs[idx]));

		// Add function name in scope for recursive calls
		if (
			functionExpression.type === &quot;FunctionExpression&quot; &amp;&amp;
			functionExpression.id
		) {
			scopeParams.push(functionExpression.id.name);
		}

		this.inFunctionScope(true, scopeParams, () =&gt; {
			if (renameThis &amp;&amp; !arrow) {
				this.setVariable(&quot;this&quot;, renameThis);
			}
			for (let i = 0; i &lt; varInfoForArgs.length; i++) {
				const varInfo = varInfoForArgs[i];
				if (!varInfo) continue;
				if (!params[i] || params[i].type !== &quot;Identifier&quot;) continue;
				this.setVariable(/** @type {Identifier} */ (params[i]).name, varInfo);
			}
			if (functionExpression.body.type === &quot;BlockStatement&quot;) {
				this.detectMode(functionExpression.body.body);
				const prev = this.prevStatement;
				this.preWalkStatement(functionExpression.body);
				this.prevStatement = prev;
				this.walkStatement(functionExpression.body);
			} else {
				this.walkExpression(functionExpression.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	/**
	 * @param {ImportExpression} expression import expression
	 */
	walkImportExpression(expression) {
		const result = this.hooks.importCall.call(expression);
		if (result === true) return;

		this.walkExpression(expression.source);
	}

	/**
	 * @param {CallExpression} expression expression
	 */
	walkCallExpression(expression) {
		/**
		 * @param {FunctionExpression | ArrowFunctionExpression} fn function
		 * @returns {boolean} true when simple function
		 */
		const isSimpleFunction = fn =&gt;
			fn.params.every(p =&gt; p.type === &quot;Identifier&quot;);
		if (
			expression.callee.type === &quot;MemberExpression&quot; &amp;&amp;
			expression.callee.object.type.endsWith(&quot;FunctionExpression&quot;) &amp;&amp;
			!expression.callee.computed &amp;&amp;
			/** @type {boolean} */
			(
				/** @type {Identifier} */
				(expression.callee.property).name === &quot;call&quot; ||
					/** @type {Identifier} */
					(expression.callee.property).name === &quot;bind&quot;
			) &amp;&amp;
			expression.arguments.length &gt; 0 &amp;&amp;
			isSimpleFunction(
				/** @type {FunctionExpression | ArrowFunctionExpression} */
				(expression.callee.object)
			)
		) {
			// (function() { }.call/bind(?, ))
			this._walkIIFE(
				/** @type {FunctionExpression | ArrowFunctionExpression} */
				(expression.callee.object),
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		} else if (
			expression.callee.type.endsWith(&quot;FunctionExpression&quot;) &amp;&amp;
			isSimpleFunction(
				/** @type {FunctionExpression | ArrowFunctionExpression} */
				(expression.callee)
			)
		) {
			// (function() { }())
			this._walkIIFE(
				/** @type {FunctionExpression | ArrowFunctionExpression} */
				(expression.callee),
				expression.arguments,
				null
			);
		} else {
			if (expression.callee.type === &quot;MemberExpression&quot;) {
				const exprInfo = this.getMemberExpressionInfo(
					expression.callee,
					ALLOWED_MEMBER_TYPES_CALL_EXPRESSION
				);
				if (exprInfo &amp;&amp; exprInfo.type === &quot;call&quot;) {
					const result = this.callHooksForInfo(
						this.hooks.callMemberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers(),
						exprInfo.getMemberRanges()
					);
					if (result === true) return;
				}
			}
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const result1 = this.callHooksForInfo(
					this.hooks.callMemberChain,
					/** @type {NonNullable&lt;BasicEvaluatedExpression[&quot;rootInfo&quot;]&gt;} */
					(callee.rootInfo),
					expression,
					/** @type {NonNullable&lt;BasicEvaluatedExpression[&quot;getMembers&quot;]&gt;} */
					(callee.getMembers)(),
					callee.getMembersOptionals
						? callee.getMembersOptionals()
						: /** @type {NonNullable&lt;BasicEvaluatedExpression[&quot;getMembers&quot;]&gt;} */
							(callee.getMembers)().map(() =&gt; false),
					callee.getMemberRanges ? callee.getMemberRanges() : []
				);
				if (result1 === true) return;
				const result2 = this.callHooksForInfo(
					this.hooks.call,
					/** @type {NonNullable&lt;BasicEvaluatedExpression[&quot;identifier&quot;]&gt;} */
					(callee.identifier),
					expression
				);
				if (result2 === true) return;
			}

			if (expression.callee) {
				if (expression.callee.type === &quot;MemberExpression&quot;) {
					// because of call context we need to walk the call context as expression
					this.walkExpression(expression.callee.object);
					if (expression.callee.computed === true)
						this.walkExpression(expression.callee.property);
				} else {
					this.walkExpression(expression.callee);
				}
			}
			if (expression.arguments) this.walkExpressions(expression.arguments);
		}
	}

	/**
	 * @param {MemberExpression} expression member expression
	 */
	walkMemberExpression(expression) {
		const exprInfo = this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_ALL
		);
		if (exprInfo) {
			switch (exprInfo.type) {
				case &quot;expression&quot;: {
					const result1 = this.callHooksForInfo(
						this.hooks.expression,
						exprInfo.name,
						expression
					);
					if (result1 === true) return;
					const members = exprInfo.getMembers();
					const membersOptionals = exprInfo.getMembersOptionals();
					const memberRanges = exprInfo.getMemberRanges();
					const result2 = this.callHooksForInfo(
						this.hooks.expressionMemberChain,
						exprInfo.rootInfo,
						expression,
						members,
						membersOptionals,
						memberRanges
					);
					if (result2 === true) return;
					this.walkMemberExpressionWithExpressionName(
						expression,
						exprInfo.name,
						exprInfo.rootInfo,
						members.slice(),
						() =&gt;
							this.callHooksForInfo(
								this.hooks.unhandledExpressionMemberChain,
								exprInfo.rootInfo,
								expression,
								members
							)
					);
					return;
				}
				case &quot;call&quot;: {
					const result = this.callHooksForInfo(
						this.hooks.memberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers(),
						exprInfo.getMemberRanges()
					);
					if (result === true) return;
					// Fast skip over the member chain as we already called memberChainOfCallMemberChain
					// and call computed property are literals anyway
					this.walkExpression(exprInfo.call);
					return;
				}
			}
		}
		this.walkExpression(expression.object);
		if (expression.computed === true) this.walkExpression(expression.property);
	}

	/**
	 * @template R
	 * @param {MemberExpression} expression member expression
	 * @param {string} name name
	 * @param {string | VariableInfo} rootInfo root info
	 * @param {string[]} members members
	 * @param {() =&gt; R | undefined} onUnhandled on unhandled callback
	 */
	walkMemberExpressionWithExpressionName(
		expression,
		name,
		rootInfo,
		members,
		onUnhandled
	) {
		if (expression.object.type === &quot;MemberExpression&quot;) {
			// optimize the case where expression.object is a MemberExpression too.
			// we can keep info here when calling walkMemberExpression directly
			const property =
				/** @type {Identifier} */
				(expression.property).name ||
				`${/** @type {Literal} */ (expression.property).value}`;
			name = name.slice(0, -property.length - 1);
			members.pop();
			const result = this.callHooksForInfo(
				this.hooks.expression,
				name,
				expression.object
			);
			if (result === true) return;
			this.walkMemberExpressionWithExpressionName(
				expression.object,
				name,
				rootInfo,
				members,
				onUnhandled
			);
		} else if (!onUnhandled || !onUnhandled()) {
			this.walkExpression(expression.object);
		}
		if (expression.computed === true) this.walkExpression(expression.property);
	}

	/**
	 * @param {ThisExpression} expression this expression
	 */
	walkThisExpression(expression) {
		this.callHooksForName(this.hooks.expression, &quot;this&quot;, expression);
	}

	/**
	 * @param {Identifier} expression identifier
	 */
	walkIdentifier(expression) {
		this.callHooksForName(this.hooks.expression, expression.name, expression);
	}

	/**
	 * @param {MetaProperty} metaProperty meta property
	 */
	walkMetaProperty(metaProperty) {
		this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);
	}

	/**
	 * @template T
	 * @template R
	 * @param {HookMap&lt;SyncBailHook&lt;T, R&gt;&gt;} hookMap hooks the should be called
	 * @param {Expression | Super} expr expression
	 * @param {AsArray&lt;T&gt;} args args for the hook
	 * @returns {R | undefined} result of hook
	 */
	callHooksForExpression(hookMap, expr, ...args) {
		return this.callHooksForExpressionWithFallback(
			hookMap,
			expr,
			undefined,
			undefined,
			...args
		);
	}

	/**
	 * @template T
	 * @template R
	 * @param {HookMap&lt;SyncBailHook&lt;T, R&gt;&gt;} hookMap hooks the should be called
	 * @param {Expression | Super} expr expression info
	 * @param {((name: string, rootInfo: string | ScopeInfo | VariableInfo, getMembers: () =&gt; string[]) =&gt; TODO) | undefined} fallback callback when variable in not handled by hooks
	 * @param {((result?: string) =&gt; R | undefined) | undefined} defined callback when variable is defined
	 * @param {AsArray&lt;T&gt;} args args for the hook
	 * @returns {R | undefined} result of hook
	 */
	callHooksForExpressionWithFallback(
		hookMap,
		expr,
		fallback,
		defined,
		...args
	) {
		const exprName = this.getMemberExpressionInfo(
			expr,
			ALLOWED_MEMBER_TYPES_EXPRESSION
		);
		if (exprName !== undefined) {
			const members = exprName.getMembers();
			return this.callHooksForInfoWithFallback(
				hookMap,
				members.length === 0 ? exprName.rootInfo : exprName.name,
				fallback &amp;&amp;
					(name =&gt; fallback(name, exprName.rootInfo, exprName.getMembers)),
				defined &amp;&amp; (() =&gt; defined(exprName.name)),
				...args
			);
		}
	}

	/**
	 * @template T
	 * @template R
	 * @param {HookMap&lt;SyncBailHook&lt;T, R&gt;&gt;} hookMap hooks the should be called
	 * @param {string} name key in map
	 * @param {AsArray&lt;T&gt;} args args for the hook
	 * @returns {R | undefined} result of hook
	 */
	callHooksForName(hookMap, name, ...args) {
		return this.callHooksForNameWithFallback(
			hookMap,
			name,
			undefined,
			undefined,
			...args
		);
	}

	/**
	 * @template T
	 * @template R
	 * @param {HookMap&lt;SyncBailHook&lt;T, R&gt;&gt;} hookMap hooks that should be called
	 * @param {ExportedVariableInfo} info variable info
	 * @param {AsArray&lt;T&gt;} args args for the hook
	 * @returns {R | undefined} result of hook
	 */
	callHooksForInfo(hookMap, info, ...args) {
		return this.callHooksForInfoWithFallback(
			hookMap,
			info,
			undefined,
			undefined,
			...args
		);
	}

	/**
	 * @template T
	 * @template R
	 * @param {HookMap&lt;SyncBailHook&lt;T, R&gt;&gt;} hookMap hooks the should be called
	 * @param {ExportedVariableInfo} info variable info
	 * @param {((name: string) =&gt; TODO) | undefined} fallback callback when variable in not handled by hooks
	 * @param {((result?: string) =&gt; TODO) | undefined} defined callback when variable is defined
	 * @param {AsArray&lt;T&gt;} args args for the hook
	 * @returns {R | undefined} result of hook
	 */
	callHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {
		let name;
		if (typeof info === &quot;string&quot;) {
			name = info;
		} else {
			if (!(info instanceof VariableInfo)) {
				if (defined !== undefined) {
					return defined();
				}
				return;
			}
			let tagInfo = info.tagInfo;
			while (tagInfo !== undefined) {
				const hook = hookMap.get(tagInfo.tag);
				if (hook !== undefined) {
					this.currentTagData = tagInfo.data;
					const result = hook.call(...args);
					this.currentTagData = undefined;
					if (result !== undefined) return result;
				}
				tagInfo = tagInfo.next;
			}
			if (info.freeName === true) {
				if (defined !== undefined) {
					return defined();
				}
				return;
			}
			name = info.freeName;
		}
		const hook = hookMap.get(name);
		if (hook !== undefined) {
			const result = hook.call(...args);
			if (result !== undefined) return result;
		}
		if (fallback !== undefined) {
			return fallback(/** @type {string} */ (name));
		}
	}

	/**
	 * @template T
	 * @template R
	 * @param {HookMap&lt;SyncBailHook&lt;T, R&gt;&gt;} hookMap hooks the should be called
	 * @param {string} name key in map
	 * @param {((value: string) =&gt; R | undefined) | undefined} fallback callback when variable in not handled by hooks
	 * @param {(() =&gt; R) | undefined} defined callback when variable is defined
	 * @param {AsArray&lt;T&gt;} args args for the hook
	 * @returns {R | undefined} result of hook
	 */
	callHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {
		return this.callHooksForInfoWithFallback(
			hookMap,
			this.getVariableInfo(name),
			fallback,
			defined,
			...args
		);
	}

	/**
	 * @deprecated
	 * @param {(string | Pattern | Property)[]} params scope params
	 * @param {() =&gt; void} fn inner function
	 * @returns {void}
	 */
	inScope(params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: undefined,
			definitions: oldScope.definitions.createChild()
		};

		this.undefineVariable(&quot;this&quot;);

		this.enterPatterns(params, ident =&gt; {
			this.defineVariable(ident);
		});

		fn();

		this.scope = oldScope;
	}

	/**
	 * @param {boolean} hasThis true, when this is defined
	 * @param {Identifier[]} params scope params
	 * @param {() =&gt; void} fn inner function
	 * @returns {void}
	 */
	inClassScope(hasThis, params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: undefined,
			definitions: oldScope.definitions.createChild()
		};

		if (hasThis) {
			this.undefineVariable(&quot;this&quot;);
		}

		this.enterPatterns(params, ident =&gt; {
			this.defineVariable(ident);
		});

		fn();

		this.scope = oldScope;
	}

	/**
	 * @param {boolean} hasThis true, when this is defined
	 * @param {(Pattern | string)[]} params scope params
	 * @param {() =&gt; void} fn inner function
	 * @returns {void}
	 */
	inFunctionScope(hasThis, params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: undefined,
			definitions: oldScope.definitions.createChild()
		};

		if (hasThis) {
			this.undefineVariable(&quot;this&quot;);
		}

		this.enterPatterns(params, ident =&gt; {
			this.defineVariable(ident);
		});

		fn();

		this.scope = oldScope;
	}

	/**
	 * @param {() =&gt; void} fn inner function
	 * @param {boolean} inExecutedPath executed state
	 * @returns {void}
	 */
	inBlockScope(fn, inExecutedPath = false) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: oldScope.inTry,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: oldScope.terminated,
			definitions: oldScope.definitions.createChild()
		};

		fn();

		const terminated = this.scope.terminated;

		if (inExecutedPath &amp;&amp; terminated) {
			oldScope.terminated = terminated;
		}

		this.scope = oldScope;
	}

	/**
	 * @param {Array&lt;Directive | Statement | ModuleDeclaration&gt;} statements statements
	 */
	detectMode(statements) {
		const isLiteral =
			statements.length &gt;= 1 &amp;&amp;
			statements[0].type === &quot;ExpressionStatement&quot; &amp;&amp;
			statements[0].expression.type === &quot;Literal&quot;;
		if (
			isLiteral &amp;&amp;
			/** @type {Literal} */
			(/** @type {ExpressionStatement} */ (statements[0]).expression).value ===
				&quot;use strict&quot;
		) {
			this.scope.isStrict = true;
		}
		if (
			isLiteral &amp;&amp;
			/** @type {Literal} */
			(/** @type {ExpressionStatement} */ (statements[0]).expression).value ===
				&quot;use asm&quot;
		) {
			this.scope.isAsmJs = true;
		}
	}

	/**
	 * @param {(string | Pattern | Property)[]} patterns patterns
	 * @param {OnIdentString} onIdent on ident callback
	 */
	enterPatterns(patterns, onIdent) {
		for (const pattern of patterns) {
			if (typeof pattern !== &quot;string&quot;) {
				this.enterPattern(pattern, onIdent);
			} else if (pattern) {
				onIdent(pattern);
			}
		}
	}

	/**
	 * @param {Pattern | Property} pattern pattern
	 * @param {OnIdent} onIdent on ident callback
	 */
	enterPattern(pattern, onIdent) {
		if (!pattern) return;
		switch (pattern.type) {
			case &quot;ArrayPattern&quot;:
				this.enterArrayPattern(pattern, onIdent);
				break;
			case &quot;AssignmentPattern&quot;:
				this.enterAssignmentPattern(pattern, onIdent);
				break;
			case &quot;Identifier&quot;:
				this.enterIdentifier(pattern, onIdent);
				break;
			case &quot;ObjectPattern&quot;:
				this.enterObjectPattern(pattern, onIdent);
				break;
			case &quot;RestElement&quot;:
				this.enterRestElement(pattern, onIdent);
				break;
			case &quot;Property&quot;:
				if (pattern.shorthand &amp;&amp; pattern.value.type === &quot;Identifier&quot;) {
					this.scope.inShorthand = pattern.value.name;
					this.enterIdentifier(pattern.value, onIdent);
					this.scope.inShorthand = false;
				} else {
					this.enterPattern(/** @type {Pattern} */ (pattern.value), onIdent);
				}
				break;
		}
	}

	/**
	 * @param {Identifier} pattern identifier pattern
	 * @param {OnIdent} onIdent callback
	 */
	enterIdentifier(pattern, onIdent) {
		if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {
			onIdent(pattern.name, pattern);
		}
	}

	/**
	 * @param {ObjectPattern} pattern object pattern
	 * @param {OnIdent} onIdent callback
	 */
	enterObjectPattern(pattern, onIdent) {
		for (
			let propIndex = 0, len = pattern.properties.length;
			propIndex &lt; len;
			propIndex++
		) {
			const prop = pattern.properties[propIndex];
			this.enterPattern(prop, onIdent);
		}
	}

	/**
	 * @param {ArrayPattern} pattern object pattern
	 * @param {OnIdent} onIdent callback
	 */
	enterArrayPattern(pattern, onIdent) {
		for (
			let elementIndex = 0, len = pattern.elements.length;
			elementIndex &lt; len;
			elementIndex++
		) {
			const element = pattern.elements[elementIndex];

			if (element) {
				this.enterPattern(element, onIdent);
			}
		}
	}

	/**
	 * @param {RestElement} pattern object pattern
	 * @param {OnIdent} onIdent callback
	 */
	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	}

	/**
	 * @param {AssignmentPattern} pattern object pattern
	 * @param {OnIdent} onIdent callback
	 */
	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	}

	/**
	 * @param {Expression | SpreadElement | PrivateIdentifier | Super} expression expression node
	 * @returns {BasicEvaluatedExpression} evaluation result
	 */
	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result !== undefined &amp;&amp; result !== null) {
					result.setExpression(expression);
					return result;
				}
			}
		} catch (err) {
			// eslint-disable-next-line no-console
			console.warn(err);
			// ignore error
		}
		return new BasicEvaluatedExpression()
			.setRange(/** @type {Range} */ (expression.range))
			.setExpression(expression);
	}

	/**
	 * @param {Expression} expression expression
	 * @returns {string} parsed string
	 */
	parseString(expression) {
		switch (expression.type) {
			case &quot;BinaryExpression&quot;:
				if (expression.operator === &quot;+&quot;) {
					return (
						this.parseString(/** @type {Expression} */ (expression.left)) +
						this.parseString(expression.right)
					);
				}
				break;
			case &quot;Literal&quot;:
				return String(expression.value);
		}
		throw new Error(
			`${expression.type} is not supported as parameter for require`
		);
	}

	/**
	 * @param {Expression} expression expression
	 * @returns {{ range?: Range, value: string, code: boolean, conditional: boolean | TODO }} result
	 */
	parseCalculatedString(expression) {
		switch (expression.type) {
			case &quot;BinaryExpression&quot;:
				if (expression.operator === &quot;+&quot;) {
					const left = this.parseCalculatedString(
						/** @type {Expression} */
						(expression.left)
					);
					const right = this.parseCalculatedString(expression.right);
					if (left.code) {
						return {
							range: left.range,
							value: left.value,
							code: true,
							conditional: false
						};
					} else if (right.code) {
						return {
							range: [
								/** @type {Range} */
								(left.range)[0],
								right.range
									? right.range[1]
									: /** @type {Range} */ (left.range)[1]
							],
							value: left.value + right.value,
							code: true,
							conditional: false
						};
					}
					return {
						range: [
							/** @type {Range} */
							(left.range)[0],
							/** @type {Range} */
							(right.range)[1]
						],
						value: left.value + right.value,
						code: false,
						conditional: false
					};
				}
				break;
			case &quot;ConditionalExpression&quot;: {
				const consequent = this.parseCalculatedString(expression.consequent);
				const alternate = this.parseCalculatedString(expression.alternate);
				const items = [];
				if (consequent.conditional) {
					items.push(...consequent.conditional);
				} else if (!consequent.code) {
					items.push(consequent);
				} else {
					break;
				}
				if (alternate.conditional) {
					items.push(...alternate.conditional);
				} else if (!alternate.code) {
					items.push(alternate);
				} else {
					break;
				}
				return {
					range: undefined,
					value: &quot;&quot;,
					code: true,
					conditional: items
				};
			}
			case &quot;Literal&quot;:
				return {
					range: expression.range,
					value: String(expression.value),
					code: false,
					conditional: false
				};
		}
		return {
			range: undefined,
			value: &quot;&quot;,
			code: true,
			conditional: false
		};
	}

	/**
	 * @param {string | Buffer | PreparsedAst} source the source to parse
	 * @param {ParserState} state the parser state
	 * @returns {ParserState} the parser state
	 */
	parse(source, state) {
		let ast;
		/** @type {import(&quot;acorn&quot;).Comment[]} */
		let comments;
		const semicolons = new Set();
		if (source === null) {
			throw new Error(&quot;source must not be null&quot;);
		}
		if (Buffer.isBuffer(source)) {
			source = source.toString(&quot;utf-8&quot;);
		}
		if (typeof source === &quot;object&quot;) {
			ast = /** @type {Program} */ (source);
			comments = source.comments;
			if (source.semicolons) {
				// Forward semicolon information from the preparsed AST if present
				// This ensures the output is consistent with that of a fresh AST
				for (const pos of source.semicolons) {
					semicolons.add(pos);
				}
			}
		} else {
			comments = [];
			ast = JavascriptParser._parse(source, {
				sourceType: this.sourceType,
				onComment: comments,
				onInsertedSemicolon: pos =&gt; semicolons.add(pos)
			});
		}

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		const oldSemicolons = this.semicolons;
		const oldStatementPath = this.statementPath;
		const oldPrevStatement = this.prevStatement;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: false,
			isAsmJs: false,
			terminated: undefined,
			definitions: new StackedMap()
		};
		this.state = /** @type {ParserState} */ (state);
		this.comments = comments;
		this.semicolons = semicolons;
		this.statementPath = [];
		this.prevStatement = undefined;
		if (this.hooks.program.call(ast, comments) === undefined) {
			this.destructuringAssignmentProperties = new WeakMap();
			this.detectMode(ast.body);
			this.preWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.blockPreWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.walkStatements(ast.body);
			this.destructuringAssignmentProperties = undefined;
		}
		this.hooks.finish.call(ast, comments);
		this.scope = oldScope;
		this.state = oldState;
		this.comments = oldComments;
		this.semicolons = oldSemicolons;
		this.statementPath = oldStatementPath;
		this.prevStatement = oldPrevStatement;
		return state;
	}

	/**
	 * @param {string} source source code
	 * @returns {BasicEvaluatedExpression} evaluation result
	 */
	evaluate(source) {
		const ast = JavascriptParser._parse(`(${source})`, {
			sourceType: this.sourceType,
			locations: false
		});
		if (ast.body.length !== 1 || ast.body[0].type !== &quot;ExpressionStatement&quot;) {
			throw new Error(&quot;evaluate: Source is not a expression&quot;);
		}
		return this.evaluateExpression(ast.body[0].expression);
	}

	/**
	 * @param {Expression | Declaration | PrivateIdentifier | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | null | undefined} expr an expression
	 * @param {number} commentsStartPos source position from which annotation comments are checked
	 * @returns {boolean} true, when the expression is pure
	 */
	isPure(expr, commentsStartPos) {
		if (!expr) return true;
		const result = this.hooks.isPure
			.for(expr.type)
			.call(expr, commentsStartPos);
		if (typeof result === &quot;boolean&quot;) return result;
		switch (expr.type) {
			// TODO handle more cases
			case &quot;ClassDeclaration&quot;:
			case &quot;ClassExpression&quot;: {
				if (expr.body.type !== &quot;ClassBody&quot;) return false;
				if (
					expr.superClass &amp;&amp;
					!this.isPure(expr.superClass, /** @type {Range} */ (expr.range)[0])
				) {
					return false;
				}
				const items =
					/** @type {TODO[]} */
					(expr.body.body);
				return items.every(item =&gt; {
					if (
						item.computed &amp;&amp;
						item.key &amp;&amp;
						!this.isPure(item.key, item.range[0])
					) {
						return false;
					}

					if (
						item.static &amp;&amp;
						item.value &amp;&amp;
						!this.isPure(
							item.value,
							item.key ? item.key.range[1] : item.range[0]
						)
					) {
						return false;
					}

					if (item.type === &quot;StaticBlock&quot;) {
						return false;
					}

					if (
						expr.superClass &amp;&amp;
						item.type === &quot;MethodDefinition&quot; &amp;&amp;
						item.kind === &quot;constructor&quot;
					) {
						return false;
					}

					return true;
				});
			}

			case &quot;FunctionDeclaration&quot;:
			case &quot;FunctionExpression&quot;:
			case &quot;ArrowFunctionExpression&quot;:
			case &quot;ThisExpression&quot;:
			case &quot;Literal&quot;:
			case &quot;TemplateLiteral&quot;:
			case &quot;Identifier&quot;:
			case &quot;PrivateIdentifier&quot;:
				return true;

			case &quot;VariableDeclaration&quot;:
				return expr.declarations.every(decl =&gt;
					this.isPure(decl.init, /** @type {Range} */ (decl.range)[0])
				);

			case &quot;ConditionalExpression&quot;:
				return (
					this.isPure(expr.test, commentsStartPos) &amp;&amp;
					this.isPure(
						expr.consequent,
						/** @type {Range} */ (expr.test.range)[1]
					) &amp;&amp;
					this.isPure(
						expr.alternate,
						/** @type {Range} */ (expr.consequent.range)[1]
					)
				);

			case &quot;LogicalExpression&quot;:
				return (
					this.isPure(expr.left, commentsStartPos) &amp;&amp;
					this.isPure(expr.right, /** @type {Range} */ (expr.left.range)[1])
				);

			case &quot;SequenceExpression&quot;:
				return expr.expressions.every(expr =&gt; {
					const pureFlag = this.isPure(expr, commentsStartPos);
					commentsStartPos = /** @type {Range} */ (expr.range)[1];
					return pureFlag;
				});

			case &quot;CallExpression&quot;: {
				const pureFlag =
					/** @type {Range} */ (expr.range)[0] - commentsStartPos &gt; 12 &amp;&amp;
					this.getComments([
						commentsStartPos,
						/** @type {Range} */ (expr.range)[0]
					]).some(
						comment =&gt;
							comment.type === &quot;Block&quot; &amp;&amp;
							/^\s*(#|@)__PURE__\s*$/.test(comment.value)
					);
				if (!pureFlag) return false;
				commentsStartPos = /** @type {Range} */ (expr.callee.range)[1];
				return expr.arguments.every(arg =&gt; {
					if (arg.type === &quot;SpreadElement&quot;) return false;
					const pureFlag = this.isPure(arg, commentsStartPos);
					commentsStartPos = /** @type {Range} */ (arg.range)[1];
					return pureFlag;
				});
			}
		}
		const evaluated = this.evaluateExpression(expr);
		return !evaluated.couldHaveSideEffects();
	}

	/**
	 * @param {Range} range range
	 * @returns {Comment[]} comments in the range
	 */
	getComments(range) {
		const [rangeStart, rangeEnd] = range;
		/**
		 * @param {Comment} comment comment
		 * @param {number} needle needle
		 * @returns {number} compared
		 */
		const compare = (comment, needle) =&gt;
			/** @type {Range} */ (comment.range)[0] - needle;
		const comments = /** @type {Comment[]} */ (this.comments);
		let idx = binarySearchBounds.ge(comments, rangeStart, compare);
		/** @type {Comment[]} */
		const commentsInRange = [];
		while (
			comments[idx] &amp;&amp;
			/** @type {Range} */ (comments[idx].range)[1] &lt;= rangeEnd
		) {
			commentsInRange.push(comments[idx]);
			idx++;
		}

		return commentsInRange;
	}

	/**
	 * @param {number} pos source code position
	 * @returns {boolean} true when a semicolon has been inserted before this position, false if not
	 */
	isAsiPosition(pos) {
		const currentStatement =
			/** @type {StatementPath} */
			(this.statementPath)[
				/** @type {StatementPath} */
				(this.statementPath).length - 1
			];
		if (currentStatement === undefined) throw new Error(&quot;Not in statement&quot;);
		const range = /** @type {Range} */ (currentStatement.range);

		return (
			// Either asking directly for the end position of the current statement
			(range[1] === pos &amp;&amp;
				/** @type {Set&lt;number&gt;} */ (this.semicolons).has(pos)) ||
			// Or asking for the start position of the current statement,
			// here we have to check multiple things
			(range[0] === pos &amp;&amp;
				// is there a previous statement which might be relevant?
				this.prevStatement !== undefined &amp;&amp;
				// is the end position of the previous statement an ASI position?
				/** @type {Set&lt;number&gt;} */ (this.semicolons).has(
					/** @type {Range} */ (this.prevStatement.range)[1]
				))
		);
	}

	/**
	 * @param {number} pos source code position
	 * @returns {void}
	 */
	setAsiPosition(pos) {
		/** @type {Set&lt;number&gt;} */ (this.semicolons).add(pos);
	}

	/**
	 * @param {number} pos source code position
	 * @returns {void}
	 */
	unsetAsiPosition(pos) {
		/** @type {Set&lt;number&gt;} */ (this.semicolons).delete(pos);
	}

	/**
	 * @param {Expression} expr expression
	 * @returns {boolean} true, when the expression is a statement level expression
	 */
	isStatementLevelExpression(expr) {
		const currentStatement =
			/** @type {StatementPath} */
			(this.statementPath)[
				/** @type {StatementPath} */
				(this.statementPath).length - 1
			];
		return (
			expr === currentStatement ||
			(currentStatement.type === &quot;ExpressionStatement&quot; &amp;&amp;
				currentStatement.expression === expr)
		);
	}

	/**
	 * @param {string} name name
	 * @param {Tag} tag tag info
	 * @returns {TagData | undefined} tag data
	 */
	getTagData(name, tag) {
		const info = this.scope.definitions.get(name);
		if (info instanceof VariableInfo) {
			let tagInfo = info.tagInfo;
			while (tagInfo !== undefined) {
				if (tagInfo.tag === tag) return tagInfo.data;
				tagInfo = tagInfo.next;
			}
		}
	}

	/**
	 * @param {string} name name
	 * @param {Tag} tag tag info
	 * @param {TagData=} data data
	 */
	tagVariable(name, tag, data) {
		const oldInfo = this.scope.definitions.get(name);
		/** @type {VariableInfo} */
		let newInfo;
		if (oldInfo === undefined) {
			newInfo = new VariableInfo(this.scope, name, {
				tag,
				data,
				next: undefined
			});
		} else if (oldInfo instanceof VariableInfo) {
			newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {
				tag,
				data,
				next: oldInfo.tagInfo
			});
		} else {
			newInfo = new VariableInfo(oldInfo, true, {
				tag,
				data,
				next: undefined
			});
		}
		this.scope.definitions.set(name, newInfo);
	}

	/**
	 * @param {string} name variable name
	 */
	defineVariable(name) {
		const oldInfo = this.scope.definitions.get(name);
		// Don&#039;t redefine variable in same scope to keep existing tags
		if (oldInfo instanceof VariableInfo &amp;&amp; oldInfo.declaredScope === this.scope)
			return;
		this.scope.definitions.set(name, this.scope);
	}

	/**
	 * @param {string} name variable name
	 */
	undefineVariable(name) {
		this.scope.definitions.delete(name);
	}

	/**
	 * @param {string} name variable name
	 * @returns {boolean} true, when variable is defined
	 */
	isVariableDefined(name) {
		const info = this.scope.definitions.get(name);
		if (info === undefined) return false;
		if (info instanceof VariableInfo) {
			return info.freeName === true;
		}
		return true;
	}

	/**
	 * @param {string} name variable name
	 * @returns {string | ExportedVariableInfo} info for this variable
	 */
	getVariableInfo(name) {
		const value = this.scope.definitions.get(name);
		if (value === undefined) {
			return name;
		}
		return value;
	}

	/**
	 * @param {string} name variable name
	 * @param {string | ExportedVariableInfo} variableInfo new info for this variable
	 * @returns {void}
	 */
	setVariable(name, variableInfo) {
		if (typeof variableInfo === &quot;string&quot;) {
			if (variableInfo === name) {
				this.scope.definitions.delete(name);
			} else {
				this.scope.definitions.set(
					name,
					new VariableInfo(this.scope, variableInfo, undefined)
				);
			}
		} else {
			this.scope.definitions.set(name, variableInfo);
		}
	}

	/**
	 * @param {TagInfo} tagInfo tag info
	 * @returns {VariableInfo} variable info
	 */
	evaluatedVariable(tagInfo) {
		return new VariableInfo(this.scope, undefined, tagInfo);
	}

	/**
	 * @param {Range} range range of the comment
	 * @returns {{ options: Record&lt;string, EXPECTED_ANY&gt; | null, errors: (Error &amp; { comment: Comment })[] | null }} result
	 */
	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		}
		/** @type {Record&lt;string, EXPECTED_ANY&gt; } */
		const options = {};
		/** @type {(Error &amp; { comment: Comment })[]} */
		const errors = [];
		for (const comment of comments) {
			const { value } = comment;
			if (value &amp;&amp; webpackCommentRegExp.test(value)) {
				// try compile only if webpack options comment is present
				try {
					for (let [key, val] of Object.entries(
						vm.runInContext(
							`(function(){return {${value}};})()`,
							this.magicCommentContext
						)
					)) {
						if (typeof val === &quot;object&quot; &amp;&amp; val !== null) {
							val =
								val.constructor.name === &quot;RegExp&quot;
									? new RegExp(val)
									: JSON.parse(JSON.stringify(val));
						}
						options[key] = val;
					}
				} catch (err) {
					const newErr = new Error(String(/** @type {Error} */ (err).message));
					newErr.stack = String(/** @type {Error} */ (err).stack);
					Object.assign(newErr, { comment });
					errors.push(/** @type {(Error &amp; { comment: Comment })} */ (newErr));
				}
			}
		}
		return { options, errors };
	}

	/**
	 * @param {Expression | Super} expression a member expression
	 * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] }} member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {Node} */
		let expr = expression;
		const members = [];
		const membersOptionals = [];
		const memberRanges = [];
		while (expr.type === &quot;MemberExpression&quot;) {
			if (expr.computed) {
				if (expr.property.type !== &quot;Literal&quot;) break;
				members.push(`${expr.property.value}`); // the literal
				memberRanges.push(/** @type {Range} */ (expr.object.range)); // the range of the expression fragment before the literal
			} else {
				if (expr.property.type !== &quot;Identifier&quot;) break;
				members.push(expr.property.name); // the identifier
				memberRanges.push(/** @type {Range} */ (expr.object.range)); // the range of the expression fragment before the identifier
			}
			membersOptionals.push(expr.optional);
			expr = expr.object;
		}

		return {
			members,
			membersOptionals,
			memberRanges,
			object: expr
		};
	}

	/**
	 * @param {string} varName variable name
	 * @returns {{name: string, info: VariableInfo | string} | undefined} name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== &quot;string&quot;) return;
		} else if (typeof info !== &quot;string&quot;) {
			return;
		} else {
			name = info;
		}
		return { info, name };
	}

	/** @typedef {{ type: &quot;call&quot;, call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () =&gt; string[], name: string, getMembers: () =&gt; string[], getMembersOptionals: () =&gt; boolean[], getMemberRanges: () =&gt; Range[]}} CallExpressionInfo */
	/** @typedef {{ type: &quot;expression&quot;, rootInfo: string | VariableInfo, name: string, getMembers: () =&gt; string[], getMembersOptionals: () =&gt; boolean[], getMemberRanges: () =&gt; Range[]}} ExpressionExpressionInfo */

	/**
	 * @param {Expression | Super} expression a member expression
	 * @param {number} allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members, membersOptionals, memberRanges } =
			this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case &quot;CallExpression&quot;: {
				if ((allowedTypes &amp; ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === &quot;MemberExpression&quot;) {
					({ object: callee, members: rootMembers } =
						this.extractMemberExpressionChain(callee));
				}
				const rootName = getRootName(callee);
				if (!rootName) return;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return;
				const { info: rootInfo, name: resolvedRoot } = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: &quot;call&quot;,
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() =&gt; rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName}()`, members),
					getMembers: memoize(() =&gt; members.reverse()),
					getMembersOptionals: memoize(() =&gt; membersOptionals.reverse()),
					getMemberRanges: memoize(() =&gt; memberRanges.reverse())
				};
			}
			case &quot;Identifier&quot;:
			case &quot;MetaProperty&quot;:
			case &quot;ThisExpression&quot;: {
				if ((allowedTypes &amp; ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return;
				const rootName = getRootName(object);
				if (!rootName) return;

				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return;
				const { info: rootInfo, name: resolvedRoot } = result;
				return {
					type: &quot;expression&quot;,
					name: objectAndMembersToName(resolvedRoot, members),
					rootInfo,
					getMembers: memoize(() =&gt; members.reverse()),
					getMembersOptionals: memoize(() =&gt; membersOptionals.reverse()),
					getMemberRanges: memoize(() =&gt; memberRanges.reverse())
				};
			}
		}
	}

	/**
	 * @param {MemberExpression} expression an expression
	 * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () =&gt; string[]} | undefined} name info
	 */
	getNameForExpression(expression) {
		return this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_EXPRESSION
		);
	}

	/**
	 * @param {string} code source code
	 * @param {ParseOptions} options parsing options
	 * @returns {Program} parsed ast
	 */
	static _parse(code, options) {
		const type = options ? options.sourceType : &quot;module&quot;;
		/** @type {AcornOptions} */
		const parserOptions = {
			...defaultParserOptions,
			allowReturnOutsideFunction: type === &quot;script&quot;,
			...options,
			sourceType: type === &quot;auto&quot; ? &quot;module&quot; : type
		};

		/** @type {import(&quot;acorn&quot;).Program | undefined} */
		let ast;
		let error;
		let threw = false;
		try {
			ast = parser.parse(code, parserOptions);
		} catch (err) {
			error = err;
			threw = true;
		}

		if (threw &amp;&amp; type === &quot;auto&quot;) {
			parserOptions.sourceType = &quot;script&quot;;
			if (!(&quot;allowReturnOutsideFunction&quot; in options)) {
				parserOptions.allowReturnOutsideFunction = true;
			}
			if (Array.isArray(parserOptions.onComment)) {
				parserOptions.onComment.length = 0;
			}
			try {
				ast = parser.parse(code, parserOptions);
				threw = false;
			} catch (_err) {
				// we use the error from first parse try
				// so nothing to do here
			}
		}

		if (threw) {
			throw error;
		}

		return /** @type {Program} */ (ast);
	}
}

module.exports = JavascriptParser;
module.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;
module.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =
	ALLOWED_MEMBER_TYPES_EXPRESSION;
module.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =
	ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;
module.exports.getImportAttributes = getImportAttributes;
module.exports.VariableInfo = VariableInfo;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
