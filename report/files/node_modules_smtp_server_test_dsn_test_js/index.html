<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/smtp-server/test/dsn-test.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/smtp-server/test/dsn-test.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">463</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">39.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.58</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */

&#039;use strict&#039;;

const chai = require(&#039;chai&#039;);
const SMTPServer = require(&#039;../lib/smtp-server&#039;).SMTPServer;
const SMTPConnection = require(&#039;../lib/smtp-connection&#039;).SMTPConnection;

const expect = chai.expect;

chai.config.includeStack = true;

describe(&#039;DSN (Delivery Status Notification) Support&#039;, function () {
    this.timeout(10 * 1000); // eslint-disable-line no-invalid-this

    describe(&#039;Unit Tests for DSN Parameter Parsing&#039;, function () {
        it(&#039;should parse DSN parameters in _parseAddressCommand&#039;, function () {
            let conn = new SMTPConnection(
                {
                    options: {}
                },
                {}
            );

            // Test MAIL FROM with DSN parameters
            expect(conn._parseAddressCommand(&#039;MAIL FROM&#039;, &#039;MAIL FROM:&lt;sender@example.com&gt; RET=FULL ENVID=test123&#039;)).to.deep.equal({
                address: &#039;sender@example.com&#039;,
                args: {
                    RET: &#039;FULL&#039;,
                    ENVID: &#039;test123&#039;
                }
            });

            // Test RCPT TO with DSN parameters
            expect(conn._parseAddressCommand(&#039;RCPT TO&#039;, &#039;RCPT TO:&lt;recipient@example.com&gt; NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;original@example.com&#039;)).to.deep.equal({
                address: &#039;recipient@example.com&#039;,
                args: {
                    NOTIFY: &#039;SUCCESS,FAILURE&#039;,
                    ORCPT: &#039;rfc822;original@example.com&#039;
                }
            });

            // Test mixed parameters
            expect(conn._parseAddressCommand(&#039;MAIL FROM&#039;, &#039;MAIL FROM:&lt;sender@example.com&gt; SIZE=12345 RET=HDRS ENVID=env456&#039;)).to.deep.equal({
                address: &#039;sender@example.com&#039;,
                args: {
                    SIZE: &#039;12345&#039;,
                    RET: &#039;HDRS&#039;,
                    ENVID: &#039;env456&#039;
                }
            });
        });
    });

    describe(&#039;DSN Session Data Structure&#039;, function () {
        it(&#039;should initialize DSN data in session envelope&#039;, function () {
            let conn = new SMTPConnection(
                {
                    options: {}
                },
                {
                    on() {},
                    write() {},
                    end() {}
                }
            );

            conn._resetSession();

            expect(conn.session.envelope.dsn).to.exist;
            expect(conn.session.envelope.dsn.ret).to.be.null;
            expect(conn.session.envelope.dsn.envid).to.be.null;
        });
    });

    describe(&#039;EHLO Response&#039;, function () {
        it(&#039;should include ENHANCEDSTATUSCODES and DSN in features list&#039;, function (done) {
            let server = new SMTPServer({
                disabledCommands: [&#039;AUTH&#039;],
                hideENHANCEDSTATUSCODES: false,
                hideDSN: false
            });

            // Mock connection for testing EHLO handler
            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection.clientHostname = &#039;test.example.com&#039;;
            mockConnection.name = &#039;test-server&#039;;

            // Mock the send method to capture the response
            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            // Test EHLO handler
            mockConnection.handler_EHLO(&#039;EHLO test.example.com&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                expect(sentResponse.message).to.be.an(&#039;array&#039;);

                // Check if ENHANCEDSTATUSCODES and DSN is in the features
                const features = sentResponse.message.slice(1); // Skip the greeting
                expect(features).to.include(&#039;ENHANCEDSTATUSCODES&#039;);
                expect(features).to.include(&#039;DSN&#039;);

                done();
            });
        });

        it(&#039;should hide ENHANCEDSTATUSCODES when hideENHANCEDSTATUSCODES is true&#039;, function (done) {
            let server = new SMTPServer({
                disabledCommands: [&#039;AUTH&#039;],
                hideENHANCEDSTATUSCODES: true
            });

            // Mock connection for testing EHLO handler
            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection.clientHostname = &#039;test.example.com&#039;;
            mockConnection.name = &#039;test-server&#039;;

            // Mock the send method to capture the response
            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            // Test EHLO handler
            mockConnection.handler_EHLO(&#039;EHLO test.example.com&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                expect(sentResponse.message).to.be.an(&#039;array&#039;);

                // Check if ENHANCEDSTATUSCODES is NOT in the features
                const features = sentResponse.message.slice(1); // Skip the greeting
                expect(features).to.not.include(&#039;ENHANCEDSTATUSCODES&#039;);

                done();
            });
        });

        it(&#039;should hide DSN when hideDSN is true&#039;, function (done) {
            let server = new SMTPServer({
                disabledCommands: [&#039;AUTH&#039;],
                hideDSN: true
            });

            // Mock connection for testing EHLO handler
            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection.clientHostname = &#039;test.example.com&#039;;
            mockConnection.name = &#039;test-server&#039;;

            // Mock the send method to capture the response
            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            // Test EHLO handler
            mockConnection.handler_EHLO(&#039;EHLO test.example.com&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                expect(sentResponse.message).to.be.an(&#039;array&#039;);

                // Check if DSN is NOT in the features
                const features = sentResponse.message.slice(1); // Skip the greeting
                expect(features).to.not.include(&#039;DSN&#039;);

                done();
            });
        });
    });

    describe(&#039;MAIL FROM DSN Parameter Validation&#039;, function () {
        it(&#039;should accept valid RET=FULL parameter&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    expect(session.envelope.dsn.ret).to.equal(&#039;FULL&#039;);
                    expect(address.args.RET).to.equal(&#039;FULL&#039;);
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_MAIL(&#039;MAIL FROM:&lt;test@example.com&gt; RET=FULL&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                done();
            });
        });

        it(&#039;should reject invalid RET parameter&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_MAIL(&#039;MAIL FROM:&lt;test@example.com&gt; RET=INVALID&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(501);
                expect(sentResponse.message).to.include(&#039;RET parameter must be FULL or HDRS&#039;);
                done();
            });
        });

        it(&#039;should accept ENVID parameter&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    expect(session.envelope.dsn.envid).to.equal(&#039;test-envelope-123&#039;);
                    expect(address.args.ENVID).to.equal(&#039;test-envelope-123&#039;);
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_MAIL(&#039;MAIL FROM:&lt;test@example.com&gt; ENVID=test-envelope-123&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                done();
            });
        });
    });

    describe(&#039;RCPT TO DSN Parameter Validation&#039;, function () {
        it(&#039;should accept valid NOTIFY=SUCCESS parameter&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    callback();
                },
                onRcptTo(address, session, callback) {
                    expect(address.dsn.notify).to.deep.equal([&#039;SUCCESS&#039;]);
                    expect(address.args.NOTIFY).to.equal(&#039;SUCCESS&#039;);
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;
            mockConnection.session.envelope.mailFrom = { address: &#039;test@example.com&#039; };

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_RCPT(&#039;RCPT TO:&lt;recipient@example.com&gt; NOTIFY=SUCCESS&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                done();
            });
        });

        it(&#039;should reject invalid NOTIFY parameter&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    callback();
                },
                onRcptTo(address, session, callback) {
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;
            mockConnection.session.envelope.mailFrom = { address: &#039;test@example.com&#039; };

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_RCPT(&#039;RCPT TO:&lt;recipient@example.com&gt; NOTIFY=INVALID&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(501);
                expect(sentResponse.message).to.include(&#039;NOTIFY parameter must be NEVER, SUCCESS, FAILURE, or DELAY&#039;);
                done();
            });
        });

        it(&#039;should reject NOTIFY=NEVER combined with other values&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    callback();
                },
                onRcptTo(address, session, callback) {
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;
            mockConnection.session.envelope.mailFrom = { address: &#039;test@example.com&#039; };

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_RCPT(&#039;RCPT TO:&lt;recipient@example.com&gt; NOTIFY=NEVER,SUCCESS&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(501);
                expect(sentResponse.message).to.include(&#039;NOTIFY=NEVER cannot be combined with other values&#039;);
                done();
            });
        });

        it(&#039;should accept ORCPT parameter&#039;, function (done) {
            let server = new SMTPServer({
                hideDSN: false,
                onMailFrom(address, session, callback) {
                    callback();
                },
                onRcptTo(address, session, callback) {
                    expect(address.dsn.orcpt).to.equal(&#039;rfc822;original@example.com&#039;);
                    expect(address.args.ORCPT).to.equal(&#039;rfc822;original@example.com&#039;);
                    callback();
                }
            });

            let mockConnection = new SMTPConnection(server, {
                on() {},
                write() {},
                end() {},
                localAddress: &#039;127.0.0.1&#039;,
                localPort: 25,
                remoteAddress: &#039;127.0.0.1&#039;,
                remotePort: 12345
            });

            mockConnection._resetSession();
            mockConnection.openingCommand = &#039;EHLO&#039;;
            mockConnection.session.envelope.mailFrom = { address: &#039;test@example.com&#039; };

            let sentResponse = null;
            mockConnection.send = function (code, message) {
                sentResponse = { code, message };
            };

            mockConnection.handler_RCPT(&#039;RCPT TO:&lt;recipient@example.com&gt; ORCPT=rfc822;original@example.com&#039;, function () {
                expect(sentResponse).to.exist;
                expect(sentResponse.code).to.equal(250);
                done();
            });
        });
    });
});

</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
