<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@bufbuild/protobuf/dist/esm/to-json.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@bufbuild/protobuf/dist/esm/to-json.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">383</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">85.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.44</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ScalarType, } from &quot;./descriptors.js&quot;;
import { protoCamelCase } from &quot;./reflect/names.js&quot;;
import { reflect } from &quot;./reflect/reflect.js&quot;;
import { anyUnpack } from &quot;./wkt/index.js&quot;;
import { isWrapperDesc } from &quot;./wkt/wrappers.js&quot;;
import { base64Encode } from &quot;./wire/index.js&quot;;
import { createExtensionContainer, getExtension } from &quot;./extensions.js&quot;;
import { checkField, formatVal } from &quot;./reflect/reflect-check.js&quot;;
// bootstrap-inject google.protobuf.FeatureSet.FieldPresence.LEGACY_REQUIRED: const $name: FeatureSet_FieldPresence.$localName = $number;
const LEGACY_REQUIRED = 3;
// bootstrap-inject google.protobuf.FeatureSet.FieldPresence.IMPLICIT: const $name: FeatureSet_FieldPresence.$localName = $number;
const IMPLICIT = 2;
// Default options for serializing to JSON.
const jsonWriteDefaults = {
    alwaysEmitImplicit: false,
    enumAsInteger: false,
    useProtoFieldName: false,
};
function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
/**
 * Serialize the message to a JSON value, a JavaScript value that can be
 * passed to JSON.stringify().
 */
export function toJson(schema, message, options) {
    return reflectToJson(reflect(schema, message), makeWriteOptions(options));
}
/**
 * Serialize the message to a JSON string.
 */
export function toJsonString(schema, message, options) {
    var _a;
    const jsonValue = toJson(schema, message, options);
    return JSON.stringify(jsonValue, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null &amp;&amp; _a !== void 0 ? _a : 0);
}
/**
 * Serialize a single enum value to JSON.
 */
export function enumToJson(descEnum, value) {
    var _a;
    if (descEnum.typeName == &quot;google.protobuf.NullValue&quot;) {
        return null;
    }
    const name = (_a = descEnum.value[value]) === null || _a === void 0 ? void 0 : _a.name;
    if (name === undefined) {
        throw new Error(`${value} is not a value in ${descEnum}`);
    }
    return name;
}
function reflectToJson(msg, opts) {
    var _a;
    const wktJson = tryWktToJson(msg, opts);
    if (wktJson !== undefined)
        return wktJson;
    const json = {};
    for (const f of msg.sortedFields) {
        if (!msg.isSet(f)) {
            if (f.presence == LEGACY_REQUIRED) {
                throw new Error(`cannot encode ${f} to JSON: required field not set`);
            }
            if (!opts.alwaysEmitImplicit || f.presence !== IMPLICIT) {
                // Fields with implicit presence omit zero values (e.g. empty string) by default
                continue;
            }
        }
        const jsonValue = fieldToJson(f, msg.get(f), opts);
        if (jsonValue !== undefined) {
            json[jsonName(f, opts)] = jsonValue;
        }
    }
    if (opts.registry) {
        const tagSeen = new Set();
        for (const { no } of (_a = msg.getUnknown()) !== null &amp;&amp; _a !== void 0 ? _a : []) {
            // Same tag can appear multiple times, so we
            // keep track and skip identical ones.
            if (!tagSeen.has(no)) {
                tagSeen.add(no);
                const extension = opts.registry.getExtensionFor(msg.desc, no);
                if (!extension) {
                    continue;
                }
                const value = getExtension(msg.message, extension);
                const [container, field] = createExtensionContainer(extension, value);
                const jsonValue = fieldToJson(field, container.get(field), opts);
                if (jsonValue !== undefined) {
                    json[extension.jsonName] = jsonValue;
                }
            }
        }
    }
    return json;
}
function fieldToJson(f, val, opts) {
    switch (f.fieldKind) {
        case &quot;scalar&quot;:
            return scalarToJson(f, val);
        case &quot;message&quot;:
            return reflectToJson(val, opts);
        case &quot;enum&quot;:
            return enumToJsonInternal(f.enum, val, opts.enumAsInteger);
        case &quot;list&quot;:
            return listToJson(val, opts);
        case &quot;map&quot;:
            return mapToJson(val, opts);
    }
}
function mapToJson(map, opts) {
    const f = map.field();
    const jsonObj = {};
    switch (f.mapKind) {
        case &quot;scalar&quot;:
            for (const [entryKey, entryValue] of map) {
                jsonObj[entryKey] = scalarToJson(f, entryValue);
            }
            break;
        case &quot;message&quot;:
            for (const [entryKey, entryValue] of map) {
                jsonObj[entryKey] = reflectToJson(entryValue, opts);
            }
            break;
        case &quot;enum&quot;:
            for (const [entryKey, entryValue] of map) {
                jsonObj[entryKey] = enumToJsonInternal(f.enum, entryValue, opts.enumAsInteger);
            }
            break;
    }
    return opts.alwaysEmitImplicit || map.size &gt; 0 ? jsonObj : undefined;
}
function listToJson(list, opts) {
    const f = list.field();
    const jsonArr = [];
    switch (f.listKind) {
        case &quot;scalar&quot;:
            for (const item of list) {
                jsonArr.push(scalarToJson(f, item));
            }
            break;
        case &quot;enum&quot;:
            for (const item of list) {
                jsonArr.push(enumToJsonInternal(f.enum, item, opts.enumAsInteger));
            }
            break;
        case &quot;message&quot;:
            for (const item of list) {
                jsonArr.push(reflectToJson(item, opts));
            }
            break;
    }
    return opts.alwaysEmitImplicit || jsonArr.length &gt; 0 ? jsonArr : undefined;
}
function enumToJsonInternal(desc, value, enumAsInteger) {
    var _a;
    if (typeof value != &quot;number&quot;) {
        throw new Error(`cannot encode ${desc} to JSON: expected number, got ${formatVal(value)}`);
    }
    if (desc.typeName == &quot;google.protobuf.NullValue&quot;) {
        return null;
    }
    if (enumAsInteger) {
        return value;
    }
    const val = desc.value[value];
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null &amp;&amp; _a !== void 0 ? _a : value; // if we don&#039;t know the enum value, just return the number
}
function scalarToJson(field, value) {
    var _a, _b, _c, _d, _e, _f;
    switch (field.scalar) {
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ScalarType.INT32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.FIXED32:
        case ScalarType.UINT32:
            if (typeof value != &quot;number&quot;) {
                throw new Error(`cannot encode ${field} to JSON: ${(_a = checkField(field, value)) === null || _a === void 0 ? void 0 : _a.message}`);
            }
            return value;
        // float, double: JSON value will be a number or one of the special string values &quot;NaN&quot;, &quot;Infinity&quot;, and &quot;-Infinity&quot;.
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ScalarType.FLOAT:
        case ScalarType.DOUBLE: // eslint-disable-line no-fallthrough
            if (typeof value != &quot;number&quot;) {
                throw new Error(`cannot encode ${field} to JSON: ${(_b = checkField(field, value)) === null || _b === void 0 ? void 0 : _b.message}`);
            }
            if (Number.isNaN(value))
                return &quot;NaN&quot;;
            if (value === Number.POSITIVE_INFINITY)
                return &quot;Infinity&quot;;
            if (value === Number.NEGATIVE_INFINITY)
                return &quot;-Infinity&quot;;
            return value;
        // string:
        case ScalarType.STRING:
            if (typeof value != &quot;string&quot;) {
                throw new Error(`cannot encode ${field} to JSON: ${(_c = checkField(field, value)) === null || _c === void 0 ? void 0 : _c.message}`);
            }
            return value;
        // bool:
        case ScalarType.BOOL:
            if (typeof value != &quot;boolean&quot;) {
                throw new Error(`cannot encode ${field} to JSON: ${(_d = checkField(field, value)) === null || _d === void 0 ? void 0 : _d.message}`);
            }
            return value;
        // JSON value will be a decimal string. Either numbers or strings are accepted.
        case ScalarType.UINT64:
        case ScalarType.FIXED64:
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
            if (typeof value != &quot;bigint&quot; &amp;&amp; typeof value != &quot;string&quot;) {
                throw new Error(`cannot encode ${field} to JSON: ${(_e = checkField(field, value)) === null || _e === void 0 ? void 0 : _e.message}`);
            }
            return value.toString();
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ScalarType.BYTES:
            if (value instanceof Uint8Array) {
                return base64Encode(value);
            }
            throw new Error(`cannot encode ${field} to JSON: ${(_f = checkField(field, value)) === null || _f === void 0 ? void 0 : _f.message}`);
    }
}
function jsonName(f, opts) {
    return opts.useProtoFieldName ? f.name : f.jsonName;
}
// returns a json value if wkt, otherwise returns undefined.
function tryWktToJson(msg, opts) {
    if (!msg.desc.typeName.startsWith(&quot;google.protobuf.&quot;)) {
        return undefined;
    }
    switch (msg.desc.typeName) {
        case &quot;google.protobuf.Any&quot;:
            return anyToJson(msg.message, opts);
        case &quot;google.protobuf.Timestamp&quot;:
            return timestampToJson(msg.message);
        case &quot;google.protobuf.Duration&quot;:
            return durationToJson(msg.message);
        case &quot;google.protobuf.FieldMask&quot;:
            return fieldMaskToJson(msg.message);
        case &quot;google.protobuf.Struct&quot;:
            return structToJson(msg.message);
        case &quot;google.protobuf.Value&quot;:
            return valueToJson(msg.message);
        case &quot;google.protobuf.ListValue&quot;:
            return listValueToJson(msg.message);
        default:
            if (isWrapperDesc(msg.desc)) {
                const valueField = msg.desc.fields[0];
                return scalarToJson(valueField, msg.get(valueField));
            }
            return undefined;
    }
}
function anyToJson(val, opts) {
    if (val.typeUrl === &quot;&quot;) {
        return {};
    }
    const { registry } = opts;
    let message;
    let desc;
    if (registry) {
        message = anyUnpack(val, registry);
        if (message) {
            desc = registry.getMessage(message.$typeName);
        }
    }
    if (!desc || !message) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: &quot;${val.typeUrl}&quot; is not in the type registry`);
    }
    let json = reflectToJson(reflect(desc, message), opts);
    if (desc.typeName.startsWith(&quot;google.protobuf.&quot;) ||
        json === null ||
        Array.isArray(json) ||
        typeof json !== &quot;object&quot;) {
        json = { value: json };
    }
    json[&quot;@type&quot;] = val.typeUrl;
    return json;
}
function durationToJson(val) {
    if (Number(val.seconds) &gt; 315576000000 ||
        Number(val.seconds) &lt; -315576000000) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: value out of range`);
    }
    let text = val.seconds.toString();
    if (val.nanos !== 0) {
        let nanosStr = Math.abs(val.nanos).toString();
        nanosStr = &quot;0&quot;.repeat(9 - nanosStr.length) + nanosStr;
        if (nanosStr.substring(3) === &quot;000000&quot;) {
            nanosStr = nanosStr.substring(0, 3);
        }
        else if (nanosStr.substring(6) === &quot;000&quot;) {
            nanosStr = nanosStr.substring(0, 6);
        }
        text += &quot;.&quot; + nanosStr;
        if (val.nanos &lt; 0 &amp;&amp; Number(val.seconds) == 0) {
            text = &quot;-&quot; + text;
        }
    }
    return text + &quot;s&quot;;
}
function fieldMaskToJson(val) {
    return val.paths
        .map((p) =&gt; {
        if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
            throw new Error(`cannot encode message ${val.$typeName} to JSON: lowerCamelCase of path name &quot;` +
                p +
                &#039;&quot; is irreversible&#039;);
        }
        return protoCamelCase(p);
    })
        .join(&quot;,&quot;);
}
function structToJson(val) {
    const json = {};
    for (const [k, v] of Object.entries(val.fields)) {
        json[k] = valueToJson(v);
    }
    return json;
}
function valueToJson(val) {
    switch (val.kind.case) {
        case &quot;nullValue&quot;:
            return null;
        case &quot;numberValue&quot;:
            if (!Number.isFinite(val.kind.value)) {
                throw new Error(`${val.$typeName} cannot be NaN or Infinity`);
            }
            return val.kind.value;
        case &quot;boolValue&quot;:
            return val.kind.value;
        case &quot;stringValue&quot;:
            return val.kind.value;
        case &quot;structValue&quot;:
            return structToJson(val.kind.value);
        case &quot;listValue&quot;:
            return listValueToJson(val.kind.value);
        default:
            throw new Error(`${val.$typeName} must have a value`);
    }
}
function listValueToJson(val) {
    return val.values.map(valueToJson);
}
function timestampToJson(val) {
    const ms = Number(val.seconds) * 1000;
    if (ms &lt; Date.parse(&quot;0001-01-01T00:00:00Z&quot;) ||
        ms &gt; Date.parse(&quot;9999-12-31T23:59:59Z&quot;)) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    if (val.nanos &lt; 0) {
        throw new Error(`cannot encode message ${val.$typeName} to JSON: nanos must not be negative`);
    }
    let z = &quot;Z&quot;;
    if (val.nanos &gt; 0) {
        const nanosStr = (val.nanos + 1000000000).toString().substring(1);
        if (nanosStr.substring(3) === &quot;000000&quot;) {
            z = &quot;.&quot; + nanosStr.substring(0, 3) + &quot;Z&quot;;
        }
        else if (nanosStr.substring(6) === &quot;000&quot;) {
            z = &quot;.&quot; + nanosStr.substring(0, 6) + &quot;Z&quot;;
        }
        else {
            z = &quot;.&quot; + nanosStr + &quot;Z&quot;;
        }
    }
    return new Date(ms).toISOString().replace(&quot;.000Z&quot;, z);
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
