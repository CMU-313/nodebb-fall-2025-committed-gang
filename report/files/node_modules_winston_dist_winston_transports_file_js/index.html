<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/winston/dist/winston/transports/file.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/winston/dist/winston/transports/file.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">788</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">96.84</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint-disable complexity,max-statements */
/**
 * file.js: Transport for outputting to a local log file.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

&#039;use strict&#039;;

function _readOnlyError(r) { throw new TypeError(&#039;&quot;&#039; + r + &#039;&quot; is read-only&#039;); }
function _typeof(o) { &quot;@babel/helpers - typeof&quot;; return _typeof = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? &quot;symbol&quot; : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(&quot;Cannot call a class as a function&quot;); }
function _defineProperties(e, r) { for (var t = 0; t &lt; r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, &quot;value&quot; in o &amp;&amp; (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r &amp;&amp; _defineProperties(e.prototype, r), t &amp;&amp; _defineProperties(e, t), Object.defineProperty(e, &quot;prototype&quot;, { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, &quot;string&quot;); return &quot;symbol&quot; == _typeof(i) ? i : i + &quot;&quot;; }
function _toPrimitive(t, r) { if (&quot;object&quot; != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || &quot;default&quot;); if (&quot;object&quot; != _typeof(i)) return i; throw new TypeError(&quot;@@toPrimitive must return a primitive value.&quot;); } return (&quot;string&quot; === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e &amp;&amp; (&quot;object&quot; == _typeof(e) || &quot;function&quot; == typeof e)) return e; if (void 0 !== e) throw new TypeError(&quot;Derived constructors may only return object or undefined&quot;); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(&quot;this hasn&#039;t been initialised - super() hasn&#039;t been called&quot;); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if (&quot;function&quot; != typeof e &amp;&amp; null !== e) throw new TypeError(&quot;Super expression must either be null or a function&quot;); t.prototype = Object.create(e &amp;&amp; e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, &quot;prototype&quot;, { writable: !1 }), e &amp;&amp; _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var fs = require(&#039;fs&#039;);
var path = require(&#039;path&#039;);
var asyncSeries = require(&#039;async/series&#039;);
var zlib = require(&#039;zlib&#039;);
var _require = require(&#039;triple-beam&#039;),
  MESSAGE = _require.MESSAGE;
var _require2 = require(&#039;readable-stream&#039;),
  Stream = _require2.Stream,
  PassThrough = _require2.PassThrough;
var TransportStream = require(&#039;winston-transport&#039;);
var debug = require(&#039;@dabh/diagnostics&#039;)(&#039;winston:file&#039;);
var os = require(&#039;os&#039;);
var tailFile = require(&#039;../tail-file&#039;);

/**
 * Transport for outputting to a local log file.
 * @type {File}
 * @extends {TransportStream}
 */
module.exports = /*#__PURE__*/function (_TransportStream) {
  /**
   * Constructor function for the File transport object responsible for
   * persisting log messages and metadata to one or more files.
   * @param {Object} options - Options for this instance.
   */
  function File() {
    var _this;
    var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, File);
    _this = _callSuper(this, File, [options]);

    // Expose the name of this Transport on the prototype.
    _this.name = options.name || &#039;file&#039;;

    // Helper function which throws an `Error` in the event that any of the
    // rest of the arguments is present in `options`.
    function throwIf(target) {
      for (var _len = arguments.length, args = new Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      args.slice(1).forEach(function (name) {
        if (options[name]) {
          throw new Error(&quot;Cannot set &quot;.concat(name, &quot; and &quot;).concat(target, &quot; together&quot;));
        }
      });
    }

    // Setup the base stream that always gets piped to to handle buffering.
    _this._stream = new PassThrough();
    _this._stream.setMaxListeners(30);

    // Bind this context for listener methods.
    _this._onError = _this._onError.bind(_this);
    if (options.filename || options.dirname) {
      throwIf(&#039;filename or dirname&#039;, &#039;stream&#039;);
      _this._basename = _this.filename = options.filename ? path.basename(options.filename) : &#039;winston.log&#039;;
      _this.dirname = options.dirname || path.dirname(options.filename);
      _this.options = options.options || {
        flags: &#039;a&#039;
      };
    } else if (options.stream) {
      // eslint-disable-next-line no-console
      console.warn(&#039;options.stream will be removed in winston@4. Use winston.transports.Stream&#039;);
      throwIf(&#039;stream&#039;, &#039;filename&#039;, &#039;maxsize&#039;);
      _this._dest = _this._stream.pipe(_this._setupStream(options.stream));
      _this.dirname = path.dirname(_this._dest.path);
      // We need to listen for drain events when write() returns false. This
      // can make node mad at times.
    } else {
      throw new Error(&#039;Cannot log to file without filename or stream.&#039;);
    }
    _this.maxsize = options.maxsize || null;
    _this.rotationFormat = options.rotationFormat || false;
    _this.zippedArchive = options.zippedArchive || false;
    _this.maxFiles = options.maxFiles || null;
    _this.eol = typeof options.eol === &#039;string&#039; ? options.eol : os.EOL;
    _this.tailable = options.tailable || false;
    _this.lazy = options.lazy || false;

    // Internal state variables representing the number of files this instance
    // has created and the current size (in bytes) of the current logfile.
    _this._size = 0;
    _this._pendingSize = 0;
    _this._created = 0;
    _this._drain = false;
    _this._opening = false;
    _this._ending = false;
    _this._fileExist = false;
    if (_this.dirname) _this._createLogDirIfNotExist(_this.dirname);
    if (!_this.lazy) _this.open();
    return _this;
  }
  _inherits(File, _TransportStream);
  return _createClass(File, [{
    key: &quot;finishIfEnding&quot;,
    value: function finishIfEnding() {
      var _this2 = this;
      if (this._ending) {
        if (this._opening) {
          this.once(&#039;open&#039;, function () {
            _this2._stream.once(&#039;finish&#039;, function () {
              return _this2.emit(&#039;finish&#039;);
            });
            setImmediate(function () {
              return _this2._stream.end();
            });
          });
        } else {
          this._stream.once(&#039;finish&#039;, function () {
            return _this2.emit(&#039;finish&#039;);
          });
          setImmediate(function () {
            return _this2._stream.end();
          });
        }
      }
    }

    /**
     * Core logging method exposed to Winston. Metadata is optional.
     * @param {Object} info - TODO: add param description.
     * @param {Function} callback - TODO: add param description.
     * @returns {undefined}
     */
  }, {
    key: &quot;log&quot;,
    value: function log(info) {
      var _this3 = this;
      var callback = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : function () {};
      // Remark: (jcrugzz) What is necessary about this callback(null, true) now
      // when thinking about 3.x? Should silent be handled in the base
      // TransportStream _write method?
      if (this.silent) {
        callback();
        return true;
      }

      // Output stream buffer is full and has asked us to wait for the drain event
      if (this._drain) {
        this._stream.once(&#039;drain&#039;, function () {
          _this3._drain = false;
          _this3.log(info, callback);
        });
        return;
      }
      if (this._rotate) {
        this._stream.once(&#039;rotate&#039;, function () {
          _this3._rotate = false;
          _this3.log(info, callback);
        });
        return;
      }
      if (this.lazy) {
        if (!this._fileExist) {
          if (!this._opening) {
            this.open();
          }
          this.once(&#039;open&#039;, function () {
            _this3._fileExist = true;
            _this3.log(info, callback);
            return;
          });
          return;
        }
        if (this._needsNewFile(this._pendingSize)) {
          this._dest.once(&#039;close&#039;, function () {
            if (!_this3._opening) {
              _this3.open();
            }
            _this3.once(&#039;open&#039;, function () {
              _this3.log(info, callback);
              return;
            });
            return;
          });
          return;
        }
      }

      // Grab the raw string and append the expected EOL.
      var output = &quot;&quot;.concat(info[MESSAGE]).concat(this.eol);
      var bytes = Buffer.byteLength(output);

      // After we have written to the PassThrough check to see if we need
      // to rotate to the next file.
      //
      // Remark: This gets called too early and does not depict when data
      // has been actually flushed to disk.
      function logged() {
        var _this4 = this;
        this._size += bytes;
        this._pendingSize -= bytes;
        debug(&#039;logged %s %s&#039;, this._size, output);
        this.emit(&#039;logged&#039;, info);

        // Do not attempt to rotate files while rotating
        if (this._rotate) {
          return;
        }

        // Do not attempt to rotate files while opening
        if (this._opening) {
          return;
        }

        // Check to see if we need to end the stream and create a new one.
        if (!this._needsNewFile()) {
          return;
        }
        if (this.lazy) {
          this._endStream(function () {
            _this4.emit(&#039;fileclosed&#039;);
          });
          return;
        }

        // End the current stream, ensure it flushes and create a new one.
        // This could potentially be optimized to not run a stat call but its
        // the safest way since we are supporting `maxFiles`.
        this._rotate = true;
        this._endStream(function () {
          return _this4._rotateFile();
        });
      }

      // Keep track of the pending bytes being written while files are opening
      // in order to properly rotate the PassThrough this._stream when the file
      // eventually does open.
      this._pendingSize += bytes;
      if (this._opening &amp;&amp; !this.rotatedWhileOpening &amp;&amp; this._needsNewFile(this._size + this._pendingSize)) {
        this.rotatedWhileOpening = true;
      }
      var written = this._stream.write(output, logged.bind(this));
      if (!written) {
        this._drain = true;
        this._stream.once(&#039;drain&#039;, function () {
          _this3._drain = false;
          callback();
        });
      } else {
        callback(); // eslint-disable-line callback-return
      }
      debug(&#039;written&#039;, written, this._drain);
      this.finishIfEnding();
      return written;
    }

    /**
     * Query the transport. Options object is optional.
     * @param {Object} options - Loggly-like query options for this instance.
     * @param {function} callback - Continuation to respond to when complete.
     * TODO: Refactor me.
     */
  }, {
    key: &quot;query&quot;,
    value: function query(options, callback) {
      if (typeof options === &#039;function&#039;) {
        callback = options;
        options = {};
      }
      options = normalizeQuery(options);
      var file = path.join(this.dirname, this.filename);
      var buff = &#039;&#039;;
      var results = [];
      var row = 0;
      var stream = fs.createReadStream(file, {
        encoding: &#039;utf8&#039;
      });
      stream.on(&#039;error&#039;, function (err) {
        if (stream.readable) {
          stream.destroy();
        }
        if (!callback) {
          return;
        }
        return err.code !== &#039;ENOENT&#039; ? callback(err) : callback(null, results);
      });
      stream.on(&#039;data&#039;, function (data) {
        data = (buff + data).split(/\n+/);
        var l = data.length - 1;
        var i = 0;
        for (; i &lt; l; i++) {
          if (!options.start || row &gt;= options.start) {
            add(data[i]);
          }
          row++;
        }
        buff = data[l];
      });
      stream.on(&#039;close&#039;, function () {
        if (buff) {
          add(buff, true);
        }
        if (options.order === &#039;desc&#039;) {
          results = results.reverse();
        }

        // eslint-disable-next-line callback-return
        if (callback) callback(null, results);
      });
      function add(buff, attempt) {
        try {
          var log = JSON.parse(buff);
          if (check(log)) {
            push(log);
          }
        } catch (e) {
          if (!attempt) {
            stream.emit(&#039;error&#039;, e);
          }
        }
      }
      function push(log) {
        if (options.rows &amp;&amp; results.length &gt;= options.rows &amp;&amp; options.order !== &#039;desc&#039;) {
          if (stream.readable) {
            stream.destroy();
          }
          return;
        }
        if (options.fields) {
          log = options.fields.reduce(function (obj, key) {
            obj[key] = log[key];
            return obj;
          }, {});
        }
        if (options.order === &#039;desc&#039;) {
          if (results.length &gt;= options.rows) {
            results.shift();
          }
        }
        results.push(log);
      }
      function check(log) {
        if (!log) {
          return;
        }
        if (_typeof(log) !== &#039;object&#039;) {
          return;
        }
        var time = new Date(log.timestamp);
        if (options.from &amp;&amp; time &lt; options.from || options.until &amp;&amp; time &gt; options.until || options.level &amp;&amp; options.level !== log.level) {
          return;
        }
        return true;
      }
      function normalizeQuery(options) {
        options = options || {};

        // limit
        options.rows = options.rows || options.limit || 10;

        // starting row offset
        options.start = options.start || 0;

        // now
        options.until = options.until || new Date();
        if (_typeof(options.until) !== &#039;object&#039;) {
          options.until = new Date(options.until);
        }

        // now - 24
        options.from = options.from || options.until - 24 * 60 * 60 * 1000;
        if (_typeof(options.from) !== &#039;object&#039;) {
          options.from = new Date(options.from);
        }

        // &#039;asc&#039; or &#039;desc&#039;
        options.order = options.order || &#039;desc&#039;;
        return options;
      }
    }

    /**
     * Returns a log stream for this transport. Options object is optional.
     * @param {Object} options - Stream options for this instance.
     * @returns {Stream} - TODO: add return description.
     * TODO: Refactor me.
     */
  }, {
    key: &quot;stream&quot;,
    value: function stream() {
      var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
      var file = path.join(this.dirname, this.filename);
      var stream = new Stream();
      var tail = {
        file: file,
        start: options.start
      };
      stream.destroy = tailFile(tail, function (err, line) {
        if (err) {
          return stream.emit(&#039;error&#039;, err);
        }
        try {
          stream.emit(&#039;data&#039;, line);
          line = JSON.parse(line);
          stream.emit(&#039;log&#039;, line);
        } catch (e) {
          stream.emit(&#039;error&#039;, e);
        }
      });
      return stream;
    }

    /**
     * Checks to see the filesize of.
     * @returns {undefined}
     */
  }, {
    key: &quot;open&quot;,
    value: function open() {
      var _this5 = this;
      // If we do not have a filename then we were passed a stream and
      // don&#039;t need to keep track of size.
      if (!this.filename) return;
      if (this._opening) return;
      this._opening = true;

      // Stat the target file to get the size and create the stream.
      this.stat(function (err, size) {
        if (err) {
          return _this5.emit(&#039;error&#039;, err);
        }
        debug(&#039;stat done: %s { size: %s }&#039;, _this5.filename, size);
        _this5._size = size;
        _this5._dest = _this5._createStream(_this5._stream);
        _this5._opening = false;
        _this5.once(&#039;open&#039;, function () {
          if (!_this5._stream.emit(&#039;rotate&#039;)) {
            _this5._rotate = false;
          }
        });
      });
    }

    /**
     * Stat the file and assess information in order to create the proper stream.
     * @param {function} callback - TODO: add param description.
     * @returns {undefined}
     */
  }, {
    key: &quot;stat&quot;,
    value: function stat(callback) {
      var _this6 = this;
      var target = this._getFile();
      var fullpath = path.join(this.dirname, target);
      fs.stat(fullpath, function (err, stat) {
        if (err &amp;&amp; err.code === &#039;ENOENT&#039;) {
          debug(&#039;ENOENT ok&#039;, fullpath);
          // Update internally tracked filename with the new target name.
          _this6.filename = target;
          return callback(null, 0);
        }
        if (err) {
          debug(&quot;err &quot;.concat(err.code, &quot; &quot;).concat(fullpath));
          return callback(err);
        }
        if (!stat || _this6._needsNewFile(stat.size)) {
          // If `stats.size` is greater than the `maxsize` for this
          // instance then try again.
          return _this6._incFile(function () {
            return _this6.stat(callback);
          });
        }

        // Once we have figured out what the filename is, set it
        // and return the size.
        _this6.filename = target;
        callback(null, stat.size);
      });
    }

    /**
     * Closes the stream associated with this instance.
     * @param {function} cb - TODO: add param description.
     * @returns {undefined}
     */
  }, {
    key: &quot;close&quot;,
    value: function close(cb) {
      var _this7 = this;
      if (!this._stream) {
        return;
      }
      this._stream.end(function () {
        if (cb) {
          cb(); // eslint-disable-line callback-return
        }
        _this7.emit(&#039;flush&#039;);
        _this7.emit(&#039;closed&#039;);
      });
    }

    /**
     * TODO: add method description.
     * @param {number} size - TODO: add param description.
     * @returns {undefined}
     */
  }, {
    key: &quot;_needsNewFile&quot;,
    value: function _needsNewFile(size) {
      size = size || this._size;
      return this.maxsize &amp;&amp; size &gt;= this.maxsize;
    }

    /**
     * TODO: add method description.
     * @param {Error} err - TODO: add param description.
     * @returns {undefined}
     */
  }, {
    key: &quot;_onError&quot;,
    value: function _onError(err) {
      this.emit(&#039;error&#039;, err);
    }

    /**
     * TODO: add method description.
     * @param {Stream} stream - TODO: add param description.
     * @returns {mixed} - TODO: add return description.
     */
  }, {
    key: &quot;_setupStream&quot;,
    value: function _setupStream(stream) {
      stream.on(&#039;error&#039;, this._onError);
      return stream;
    }

    /**
     * TODO: add method description.
     * @param {Stream} stream - TODO: add param description.
     * @returns {mixed} - TODO: add return description.
     */
  }, {
    key: &quot;_cleanupStream&quot;,
    value: function _cleanupStream(stream) {
      stream.removeListener(&#039;error&#039;, this._onError);
      stream.destroy();
      return stream;
    }

    /**
     * TODO: add method description.
     */
  }, {
    key: &quot;_rotateFile&quot;,
    value: function _rotateFile() {
      var _this8 = this;
      this._incFile(function () {
        return _this8.open();
      });
    }

    /**
     * Unpipe from the stream that has been marked as full and end it so it
     * flushes to disk.
     *
     * @param {function} callback - Callback for when the current file has closed.
     * @private
     */
  }, {
    key: &quot;_endStream&quot;,
    value: function _endStream() {
      var _this9 = this;
      var callback = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : function () {};
      if (this._dest) {
        this._stream.unpipe(this._dest);
        this._dest.end(function () {
          _this9._cleanupStream(_this9._dest);
          callback();
        });
      } else {
        callback(); // eslint-disable-line callback-return
      }
    }

    /**
     * Returns the WritableStream for the active file on this instance. If we
     * should gzip the file then a zlib stream is returned.
     *
     * @param {ReadableStream} source –PassThrough to pipe to the file when open.
     * @returns {WritableStream} Stream that writes to disk for the active file.
     */
  }, {
    key: &quot;_createStream&quot;,
    value: function _createStream(source) {
      var _this10 = this;
      var fullpath = path.join(this.dirname, this.filename);
      debug(&#039;create stream start&#039;, fullpath, this.options);
      var dest = fs.createWriteStream(fullpath, this.options)
      // TODO: What should we do with errors here?
      .on(&#039;error&#039;, function (err) {
        return debug(err);
      }).on(&#039;close&#039;, function () {
        return debug(&#039;close&#039;, dest.path, dest.bytesWritten);
      }).on(&#039;open&#039;, function () {
        debug(&#039;file open ok&#039;, fullpath);
        _this10.emit(&#039;open&#039;, fullpath);
        source.pipe(dest);

        // If rotation occured during the open operation then we immediately
        // start writing to a new PassThrough, begin opening the next file
        // and cleanup the previous source and dest once the source has drained.
        if (_this10.rotatedWhileOpening) {
          _this10._stream = new PassThrough();
          _this10._stream.setMaxListeners(30);
          _this10._rotateFile();
          _this10.rotatedWhileOpening = false;
          _this10._cleanupStream(dest);
          source.end();
        }
      });
      debug(&#039;create stream ok&#039;, fullpath);
      return dest;
    }

    /**
     * TODO: add method description.
     * @param {function} callback - TODO: add param description.
     * @returns {undefined}
     */
  }, {
    key: &quot;_incFile&quot;,
    value: function _incFile(callback) {
      debug(&#039;_incFile&#039;, this.filename);
      var ext = path.extname(this._basename);
      var basename = path.basename(this._basename, ext);
      var tasks = [];
      if (this.zippedArchive) {
        tasks.push(function (cb) {
          var num = this._created &gt; 0 &amp;&amp; !this.tailable ? this._created : &#039;&#039;;
          this._compressFile(path.join(this.dirname, &quot;&quot;.concat(basename).concat(num).concat(ext)), path.join(this.dirname, &quot;&quot;.concat(basename).concat(num).concat(ext, &quot;.gz&quot;)), cb);
        }.bind(this));
      }
      tasks.push(function (cb) {
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, cb);
        } else {
          this._checkMaxFilesTailable(ext, basename, cb);
        }
      }.bind(this));
      asyncSeries(tasks, callback);
    }

    /**
     * Gets the next filename to use for this instance in the case that log
     * filesizes are being capped.
     * @returns {string} - TODO: add return description.
     * @private
     */
  }, {
    key: &quot;_getFile&quot;,
    value: function _getFile() {
      var ext = path.extname(this._basename);
      var basename = path.basename(this._basename, ext);
      var isRotation = this.rotationFormat ? this.rotationFormat() : this._created;

      // Caveat emptor (indexzero): rotationFormat() was broken by design When
      // combined with max files because the set of files to unlink is never
      // stored.
      return !this.tailable &amp;&amp; this._created ? &quot;&quot;.concat(basename).concat(isRotation).concat(ext) : &quot;&quot;.concat(basename).concat(ext);
    }

    /**
     * Increment the number of files created or checked by this instance.
     * @param {mixed} ext - TODO: add param description.
     * @param {mixed} basename - TODO: add param description.
     * @param {mixed} callback - TODO: add param description.
     * @returns {undefined}
     * @private
     */
  }, {
    key: &quot;_checkMaxFilesIncrementing&quot;,
    value: function _checkMaxFilesIncrementing(ext, basename, callback) {
      // Check for maxFiles option and delete file.
      if (!this.maxFiles || this._created &lt; this.maxFiles) {
        return setImmediate(callback);
      }
      var oldest = this._created - this.maxFiles;
      var isOldest = oldest !== 0 ? oldest : &#039;&#039;;
      var isZipped = this.zippedArchive ? &#039;.gz&#039; : &#039;&#039;;
      var filePath = &quot;&quot;.concat(basename).concat(isOldest).concat(ext).concat(isZipped);
      var target = path.join(this.dirname, filePath);
      fs.unlink(target, callback);
    }

    /**
     * Roll files forward based on integer, up to maxFiles. e.g. if base if
     * file.log and it becomes oversized, roll to file1.log, and allow file.log
     * to be re-used. If file is oversized again, roll file1.log to file2.log,
     * roll file.log to file1.log, and so on.
     * @param {mixed} ext - TODO: add param description.
     * @param {mixed} basename - TODO: add param description.
     * @param {mixed} callback - TODO: add param description.
     * @returns {undefined}
     * @private
     */
  }, {
    key: &quot;_checkMaxFilesTailable&quot;,
    value: function _checkMaxFilesTailable(ext, basename, callback) {
      var _this12 = this;
      var tasks = [];
      if (!this.maxFiles) {
        return;
      }

      // const isZipped = this.zippedArchive ? &#039;.gz&#039; : &#039;&#039;;
      var isZipped = this.zippedArchive ? &#039;.gz&#039; : &#039;&#039;;
      for (var x = this.maxFiles - 1; x &gt; 1; x--) {
        tasks.push(function (i, cb) {
          var _this11 = this;
          var fileName = &quot;&quot;.concat(basename).concat(i - 1).concat(ext).concat(isZipped);
          var tmppath = path.join(this.dirname, fileName);
          fs.exists(tmppath, function (exists) {
            if (!exists) {
              return cb(null);
            }
            fileName = &quot;&quot;.concat(basename).concat(i).concat(ext).concat(isZipped);
            fs.rename(tmppath, path.join(_this11.dirname, fileName), cb);
          });
        }.bind(this, x));
      }
      asyncSeries(tasks, function () {
        fs.rename(path.join(_this12.dirname, &quot;&quot;.concat(basename).concat(ext).concat(isZipped)), path.join(_this12.dirname, &quot;&quot;.concat(basename, &quot;1&quot;).concat(ext).concat(isZipped)), callback);
      });
    }

    /**
     * Compresses src to dest with gzip and unlinks src
     * @param {string} src - path to source file.
     * @param {string} dest - path to zipped destination file.
     * @param {Function} callback - callback called after file has been compressed.
     * @returns {undefined}
     * @private
     */
  }, {
    key: &quot;_compressFile&quot;,
    value: function _compressFile(src, dest, callback) {
      fs.access(src, fs.F_OK, function (err) {
        if (err) {
          return callback();
        }
        var gzip = zlib.createGzip();
        var inp = fs.createReadStream(src);
        var out = fs.createWriteStream(dest);
        out.on(&#039;finish&#039;, function () {
          fs.unlink(src, callback);
        });
        inp.pipe(gzip).pipe(out);
      });
    }
  }, {
    key: &quot;_createLogDirIfNotExist&quot;,
    value: function _createLogDirIfNotExist(dirPath) {
      /* eslint-disable no-sync */
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, {
          recursive: true
        });
      }
      /* eslint-enable no-sync */
    }
  }]);
}(TransportStream);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
