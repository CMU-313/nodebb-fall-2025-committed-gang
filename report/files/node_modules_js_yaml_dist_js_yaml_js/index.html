<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/js-yaml/dist/js-yaml.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/js-yaml/dist/js-yaml.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3990</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">217.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">47.44</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*! js-yaml 3.14.1 https://github.com/nodeca/js-yaml */(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.jsyaml = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
&#039;use strict&#039;;


var loader = require(&#039;./js-yaml/loader&#039;);
var dumper = require(&#039;./js-yaml/dumper&#039;);


function deprecated(name) {
  return function () {
    throw new Error(&#039;Function &#039; + name + &#039; is deprecated and cannot be used.&#039;);
  };
}


module.exports.Type                = require(&#039;./js-yaml/type&#039;);
module.exports.Schema              = require(&#039;./js-yaml/schema&#039;);
module.exports.FAILSAFE_SCHEMA     = require(&#039;./js-yaml/schema/failsafe&#039;);
module.exports.JSON_SCHEMA         = require(&#039;./js-yaml/schema/json&#039;);
module.exports.CORE_SCHEMA         = require(&#039;./js-yaml/schema/core&#039;);
module.exports.DEFAULT_SAFE_SCHEMA = require(&#039;./js-yaml/schema/default_safe&#039;);
module.exports.DEFAULT_FULL_SCHEMA = require(&#039;./js-yaml/schema/default_full&#039;);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require(&#039;./js-yaml/exception&#039;);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require(&#039;./js-yaml/schema/failsafe&#039;);
module.exports.SAFE_SCHEMA    = require(&#039;./js-yaml/schema/default_safe&#039;);
module.exports.DEFAULT_SCHEMA = require(&#039;./js-yaml/schema/default_full&#039;);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated(&#039;scan&#039;);
module.exports.parse          = deprecated(&#039;parse&#039;);
module.exports.compose        = deprecated(&#039;compose&#039;);
module.exports.addConstructor = deprecated(&#039;addConstructor&#039;);

},{&quot;./js-yaml/dumper&quot;:3,&quot;./js-yaml/exception&quot;:4,&quot;./js-yaml/loader&quot;:5,&quot;./js-yaml/schema&quot;:7,&quot;./js-yaml/schema/core&quot;:8,&quot;./js-yaml/schema/default_full&quot;:9,&quot;./js-yaml/schema/default_safe&quot;:10,&quot;./js-yaml/schema/failsafe&quot;:11,&quot;./js-yaml/schema/json&quot;:12,&quot;./js-yaml/type&quot;:13}],2:[function(require,module,exports){
&#039;use strict&#039;;


function isNothing(subject) {
  return (typeof subject === &#039;undefined&#039;) || (subject === null);
}


function isObject(subject) {
  return (typeof subject === &#039;object&#039;) &amp;&amp; (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index &lt; length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = &#039;&#039;, cycle;

  for (cycle = 0; cycle &lt; count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) &amp;&amp; (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],3:[function(require,module,exports){
&#039;use strict&#039;;

/*eslint-disable no-use-before-define*/

var common              = require(&#039;./common&#039;);
var YAMLException       = require(&#039;./exception&#039;);
var DEFAULT_FULL_SCHEMA = require(&#039;./schema/default_full&#039;);
var DEFAULT_SAFE_SCHEMA = require(&#039;./schema/default_safe&#039;);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* &quot; */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* &amp; */
var CHAR_SINGLE_QUOTE         = 0x27; /* &#039; */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* &gt; */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = &#039;\\0&#039;;
ESCAPE_SEQUENCES[0x07]   = &#039;\\a&#039;;
ESCAPE_SEQUENCES[0x08]   = &#039;\\b&#039;;
ESCAPE_SEQUENCES[0x09]   = &#039;\\t&#039;;
ESCAPE_SEQUENCES[0x0A]   = &#039;\\n&#039;;
ESCAPE_SEQUENCES[0x0B]   = &#039;\\v&#039;;
ESCAPE_SEQUENCES[0x0C]   = &#039;\\f&#039;;
ESCAPE_SEQUENCES[0x0D]   = &#039;\\r&#039;;
ESCAPE_SEQUENCES[0x1B]   = &#039;\\e&#039;;
ESCAPE_SEQUENCES[0x22]   = &#039;\\&quot;&#039;;
ESCAPE_SEQUENCES[0x5C]   = &#039;\\\\&#039;;
ESCAPE_SEQUENCES[0x85]   = &#039;\\N&#039;;
ESCAPE_SEQUENCES[0xA0]   = &#039;\\_&#039;;
ESCAPE_SEQUENCES[0x2028] = &#039;\\L&#039;;
ESCAPE_SEQUENCES[0x2029] = &#039;\\P&#039;;

var DEPRECATED_BOOLEANS_SYNTAX = [
  &#039;y&#039;, &#039;Y&#039;, &#039;yes&#039;, &#039;Yes&#039;, &#039;YES&#039;, &#039;on&#039;, &#039;On&#039;, &#039;ON&#039;,
  &#039;n&#039;, &#039;N&#039;, &#039;no&#039;, &#039;No&#039;, &#039;NO&#039;, &#039;off&#039;, &#039;Off&#039;, &#039;OFF&#039;
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index &lt; length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === &#039;!!&#039;) {
      tag = &#039;tag:yaml.org,2002:&#039; + tag.slice(2);
    }
    type = schema.compiledTypeMap[&#039;fallback&#039;][tag];

    if (type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character &lt;= 0xFF) {
    handle = &#039;x&#039;;
    length = 2;
  } else if (character &lt;= 0xFFFF) {
    handle = &#039;u&#039;;
    length = 4;
  } else if (character &lt;= 0xFFFFFFFF) {
    handle = &#039;U&#039;;
    length = 8;
  } else {
    throw new YAMLException(&#039;code point within a string may not be greater than 0xFFFFFFFF&#039;);
  }

  return &#039;\\&#039; + handle + common.repeat(&#039;0&#039;, length - string.length) + string;
}

function State(options) {
  this.schema        = options[&#039;schema&#039;] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options[&#039;indent&#039;] || 2));
  this.noArrayIndent = options[&#039;noArrayIndent&#039;] || false;
  this.skipInvalid   = options[&#039;skipInvalid&#039;] || false;
  this.flowLevel     = (common.isNothing(options[&#039;flowLevel&#039;]) ? -1 : options[&#039;flowLevel&#039;]);
  this.styleMap      = compileStyleMap(this.schema, options[&#039;styles&#039;] || null);
  this.sortKeys      = options[&#039;sortKeys&#039;] || false;
  this.lineWidth     = options[&#039;lineWidth&#039;] || 80;
  this.noRefs        = options[&#039;noRefs&#039;] || false;
  this.noCompatMode  = options[&#039;noCompatMode&#039;] || false;
  this.condenseFlow  = options[&#039;condenseFlow&#039;] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = &#039;&#039;;

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(&#039; &#039;, spaces),
      position = 0,
      next = -1,
      result = &#039;&#039;,
      line,
      length = string.length;

  while (position &lt; length) {
    next = string.indexOf(&#039;\n&#039;, position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length &amp;&amp; line !== &#039;\n&#039;) result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return &#039;\n&#039; + common.repeat(&#039; &#039;, state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index &lt; length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: &quot;any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory&quot;
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 &lt;= c &amp;&amp; c &lt;= 0x00007E)
      || ((0x000A1 &lt;= c &amp;&amp; c &lt;= 0x00D7FF) &amp;&amp; c !== 0x2028 &amp;&amp; c !== 0x2029)
      || ((0x0E000 &lt;= c &amp;&amp; c &lt;= 0x00FFFD) &amp;&amp; c !== 0xFEFF /* BOM */)
      ||  (0x10000 &lt;= c &amp;&amp; c &lt;= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) &amp;&amp; !isWhitespace(c)
    // byte-order-mark
    &amp;&amp; c !== 0xFEFF
    // b-char
    &amp;&amp; c !== CHAR_CARRIAGE_RETURN
    &amp;&amp; c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - &quot;:&quot; - &quot;#&quot;
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) &amp;&amp; c !== 0xFEFF
    // - c-flow-indicator
    &amp;&amp; c !== CHAR_COMMA
    &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    // - &quot;:&quot; - &quot;#&quot;
    // /* An ns-char preceding */ &quot;#&quot;
    &amp;&amp; c !== CHAR_COLON
    &amp;&amp; ((c !== CHAR_SHARP) || (prev &amp;&amp; isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) &amp;&amp; c !== 0xFEFF
    &amp;&amp; !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    &amp;&amp; c !== CHAR_MINUS
    &amp;&amp; c !== CHAR_QUESTION
    &amp;&amp; c !== CHAR_COLON
    &amp;&amp; c !== CHAR_COMMA
    &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&amp;” | “*” | “!” | “|” | “=” | “&gt;” | “&#039;” | “&quot;”
    &amp;&amp; c !== CHAR_SHARP
    &amp;&amp; c !== CHAR_AMPERSAND
    &amp;&amp; c !== CHAR_ASTERISK
    &amp;&amp; c !== CHAR_EXCLAMATION
    &amp;&amp; c !== CHAR_VERTICAL_LINE
    &amp;&amp; c !== CHAR_EQUALS
    &amp;&amp; c !== CHAR_GREATER_THAN
    &amp;&amp; c !== CHAR_SINGLE_QUOTE
    &amp;&amp; c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    &amp;&amp; c !== CHAR_PERCENT
    &amp;&amp; c !== CHAR_COMMERCIAL_AT
    &amp;&amp; c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 =&gt; no limit.
// Pre-conditions: str.length &gt; 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.
//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          &amp;&amp; !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i &lt; string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i &gt; 0 ? string.charCodeAt(i - 1) : null;
      plain = plain &amp;&amp; isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i &lt; string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
             string[previousLineBreak + 1] !== &#039; &#039;);
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i &gt; 0 ? string.charCodeAt(i - 1) : null;
      plain = plain &amp;&amp; isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;
      (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
       string[previousLineBreak + 1] !== &#039; &#039;));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they&#039;re more readable and they don&#039;t add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak &amp;&amp; !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string &#039;true&#039; vs. the boolean true.
    return plain &amp;&amp; !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel &gt; 9 &amp;&amp; needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.
//    • Ending newline    =&gt; removed then restored.
//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return &quot;&#039;&#039;&quot;;
    }
    if (!state.noCompatMode &amp;&amp;
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return &quot;&#039;&quot; + string + &quot;&#039;&quot;;
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel &gt; -1 &amp;&amp; level &gt;= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return &quot;&#039;&quot; + string.replace(/&#039;/g, &quot;&#039;&#039;&quot;) + &quot;&#039;&quot;;
      case STYLE_LITERAL:
        return &#039;|&#039; + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return &#039;&gt;&#039; + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return &#039;&quot;&#039; + escapeString(string, lineWidth) + &#039;&quot;&#039;;
      default:
        throw new YAMLException(&#039;impossible error: invalid scalar style&#039;);
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : &#039;&#039;;

  // note the special case: the string &#039;\n&#039; counts as a &quot;trailing&quot; empty line.
  var clip =          string[string.length - 1] === &#039;\n&#039;;
  var keep = clip &amp;&amp; (string[string.length - 2] === &#039;\n&#039; || string === &#039;\n&#039;);
  var chomp = keep ? &#039;+&#039; : (clip ? &#039;&#039; : &#039;-&#039;);

  return indentIndicator + chomp + &#039;\n&#039;;
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === &#039;\n&#039; ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they&#039;re before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf(&#039;\n&#039;);
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven&#039;t reached the first content line yet, don&#039;t add an extra \n.
  var prevMoreIndented = string[0] === &#039;\n&#039; || string[0] === &#039; &#039;;
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === &#039; &#039;);
    result += prefix
      + (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== &#039;&#039;
        ? &#039;\n&#039; : &#039;&#039;)
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === &#039;&#039; || line[0] === &#039; &#039;) return line;

  // Since a more-indented line adds a \n, breaks can&#039;t be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be &lt;= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = &#039;&#039;;

  // Invariants: 0 &lt;= start &lt;= length-1.
  //   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.
  // Inside the loop:
  //   A match implies length &gt;= 2, so curr and next are &lt;= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start &lt;= width
    if (next - start &gt; width) {
      end = (curr &gt; start) ? curr : next; // derive end &lt;= length-2
      result += &#039;\n&#039; + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start &lt;= length-1
    }
    curr = next;
  }

  // By the invariants, start &lt;= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += &#039;\n&#039;;
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start &gt; width &amp;&amp; curr &gt; start) {
    result += line.slice(start, curr) + &#039;\n&#039; + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = &#039;&#039;;
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i &lt; string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section &quot;3.7 Surrogates&quot;).
    if (char &gt;= 0xD800 &amp;&amp; char &lt;= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar &gt;= 0xDC00 &amp;&amp; nextChar &lt;= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq &amp;&amp; isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = &#039;&#039;,
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += &#039;,&#039; + (!state.condenseFlow ? &#039; &#039; : &#039;&#039;);
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = &#039;[&#039; + _result + &#039;]&#039;;
}

function writeBlockSequence(state, level, object, compact) {
  var _result = &#039;&#039;,
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += &#039;-&#039;;
      } else {
        _result += &#039;- &#039;;
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || &#039;[]&#039;; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = &#039;&#039;,
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {

    pairBuffer = &#039;&#039;;
    if (index !== 0) pairBuffer += &#039;, &#039;;

    if (state.condenseFlow) pairBuffer += &#039;&quot;&#039;;

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length &gt; 1024) pairBuffer += &#039;? &#039;;

    pairBuffer += state.dump + (state.condenseFlow ? &#039;&quot;&#039; : &#039;&#039;) + &#039;:&#039; + (state.condenseFlow ? &#039;&#039; : &#039; &#039;);

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = &#039;{&#039; + _result + &#039;}&#039;;
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = &#039;&#039;,
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === &#039;function&#039;) {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException(&#039;sortKeys must be a boolean or a function&#039;);
  }

  for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
    pairBuffer = &#039;&#039;;

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) ||
                   (state.dump &amp;&amp; state.dump.length &gt; 1024);

    if (explicitPair) {
      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += &#039;?&#039;;
      } else {
        pairBuffer += &#039;? &#039;;
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += &#039;:&#039;;
    } else {
      pairBuffer += &#039;: &#039;;
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || &#039;{}&#039;; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index &lt; length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &amp;&amp;
        (!type.instanceOf || ((typeof object === &#039;object&#039;) &amp;&amp; (object instanceof type.instanceOf))) &amp;&amp;
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : &#039;?&#039;;

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === &#039;[object Function]&#039;) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException(&#039;!&lt;&#039; + type.tag + &#039;&gt; tag resolver accepts not &quot;&#039; + style + &#039;&quot; style&#039;);
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel &lt; 0 || state.flowLevel &gt; level);
  }

  var objectOrArray = type === &#039;[object Object]&#039; || type === &#039;[object Array]&#039;,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) || duplicate || (state.indent !== 2 &amp;&amp; level &gt; 0)) {
    compact = false;
  }

  if (duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {
    state.dump = &#039;*ref_&#039; + duplicateIndex;
  } else {
    if (objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === &#039;[object Object]&#039;) {
      if (block &amp;&amp; (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
        }
      }
    } else if (type === &#039;[object Array]&#039;) {
      var arrayLevel = (state.noArrayIndent &amp;&amp; (level &gt; 0)) ? level - 1 : level;
      if (block &amp;&amp; (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
        }
      }
    } else if (type === &#039;[object String]&#039;) {
      if (state.tag !== &#039;?&#039;) {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException(&#039;unacceptable kind of an object to dump &#039; + type);
    }

    if (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) {
      state.dump = &#039;!&lt;&#039; + state.tag + &#039;&gt; &#039; + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index &lt; length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null &amp;&amp; typeof object === &#039;object&#039;) {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index &lt; length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + &#039;\n&#039;;

  return &#039;&#039;;
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{&quot;./common&quot;:2,&quot;./exception&quot;:4,&quot;./schema/default_full&quot;:9,&quot;./schema/default_safe&quot;:10}],4:[function(require,module,exports){
// YAML error class. http://stackoverflow.com/questions/8458984
//
&#039;use strict&#039;;

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = &#039;YAMLException&#039;;
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || &#039;(unknown reason)&#039;) + (this.mark ? &#039; &#039; + this.mark.toString() : &#039;&#039;);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || &#039;&#039;;
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + &#039;: &#039;;

  result += this.reason || &#039;(unknown reason)&#039;;

  if (!compact &amp;&amp; this.mark) {
    result += &#039; &#039; + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],5:[function(require,module,exports){
&#039;use strict&#039;;

/*eslint-disable max-len,no-use-before-define*/

var common              = require(&#039;./common&#039;);
var YAMLException       = require(&#039;./exception&#039;);
var Mark                = require(&#039;./mark&#039;);
var DEFAULT_SAFE_SCHEMA = require(&#039;./schema/default_safe&#039;);
var DEFAULT_FULL_SCHEMA = require(&#039;./schema/default_full&#039;);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&amp;=\+\$,_\.!~\*&#039;\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ &lt;= lc) &amp;&amp; (lc &lt;= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? &#039;\x00&#039; :
        (c === 0x61/* a */) ? &#039;\x07&#039; :
        (c === 0x62/* b */) ? &#039;\x08&#039; :
        (c === 0x74/* t */) ? &#039;\x09&#039; :
        (c === 0x09/* Tab */) ? &#039;\x09&#039; :
        (c === 0x6E/* n */) ? &#039;\x0A&#039; :
        (c === 0x76/* v */) ? &#039;\x0B&#039; :
        (c === 0x66/* f */) ? &#039;\x0C&#039; :
        (c === 0x72/* r */) ? &#039;\x0D&#039; :
        (c === 0x65/* e */) ? &#039;\x1B&#039; :
        (c === 0x20/* Space */) ? &#039; &#039; :
        (c === 0x22/* &quot; */) ? &#039;\x22&#039; :
        (c === 0x2F/* / */) ? &#039;/&#039; :
        (c === 0x5C/* \ */) ? &#039;\x5C&#039; :
        (c === 0x4E/* N */) ? &#039;\x85&#039; :
        (c === 0x5F/* _ */) ? &#039;\xA0&#039; :
        (c === 0x4C/* L */) ? &#039;\u2028&#039; :
        (c === 0x50/* P */) ? &#039;\u2029&#039; : &#039;&#039;;
}

function charFromCodepoint(c) {
  if (c &lt;= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) &gt;&gt; 10) + 0xD800,
    ((c - 0x010000) &amp; 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i &lt; 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options[&#039;filename&#039;]  || null;
  this.schema    = options[&#039;schema&#039;]    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options[&#039;onWarning&#039;] || null;
  this.legacy    = options[&#039;legacy&#039;]    || false;
  this.json      = options[&#039;json&#039;]      || false;
  this.listener  = options[&#039;listener&#039;]  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, &#039;duplication of %YAML directive&#039;);
    }

    if (args.length !== 1) {
      throwError(state, &#039;YAML directive accepts exactly one argument&#039;);
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, &#039;ill-formed argument of the YAML directive&#039;);
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, &#039;unacceptable YAML version of the document&#039;);
    }

    state.version = args[0];
    state.checkLineBreaks = (minor &lt; 2);

    if (minor !== 1 &amp;&amp; minor !== 2) {
      throwWarning(state, &#039;unsupported YAML version of the document&#039;);
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, &#039;TAG directive accepts exactly two arguments&#039;);
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, &#039;ill-formed tag handle (first argument) of the TAG directive&#039;);
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, &#039;there is a previously declared suffix for &quot;&#039; + handle + &#039;&quot; tag handle&#039;);
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, &#039;ill-formed tag prefix (second argument) of the TAG directive&#039;);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start &lt; end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position &lt; _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 &lt;= _character &amp;&amp; _character &lt;= 0x10FFFF))) {
          throwError(state, &#039;expected valid JSON character&#039;);
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, &#039;the stream contains non-printable characters&#039;);
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, &#039;cannot merge mappings; the provided source object is unacceptable&#039;);
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index &lt; quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index &lt; quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, &#039;nested arrays are not supported inside keys&#039;);
      }

      if (typeof keyNode === &#039;object&#039; &amp;&amp; _class(keyNode[index]) === &#039;[object Object]&#039;) {
        keyNode[index] = &#039;[object Object]&#039;;
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === &#039;object&#039; &amp;&amp; _class(keyNode) === &#039;[object Object]&#039;) {
    keyNode = &#039;[object Object]&#039;;
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === &#039;tag:yaml.org,2002:merge&#039;) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index &lt; quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &amp;&amp;
        !_hasOwnProperty.call(overridableKeys, keyNode) &amp;&amp;
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, &#039;duplicated mapping key&#039;);
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, &#039;a line break is expected&#039;);
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments &amp;&amp; ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ &amp;&amp; ch !== 0x0D/* CR */ &amp;&amp; ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 &amp;&amp; lineBreaks !== 0 &amp;&amp; state.lineIndent &lt; checkIndent) {
    throwWarning(state, &#039;deficient indentation&#039;);
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &amp;&amp;
      ch === state.input.charCodeAt(_position + 1) &amp;&amp;
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += &#039; &#039;;
  } else if (count &gt; 1) {
    state.result += common.repeat(&#039;\n&#039;, count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* &amp; */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* &gt; */    ||
      ch === 0x27/* &#039; */    ||
      ch === 0x22/* &quot; */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) ||
               withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent &gt;= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* &#039; */) {
    return false;
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* &#039; */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* &#039; */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
      throwError(state, &#039;unexpected end of the document within a single quoted scalar&#039;);

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, &#039;unexpected end of the stream within a single quoted scalar&#039;);
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* &quot; */) {
    return false;
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* &quot; */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch &lt; 256 &amp;&amp; simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) &gt; 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength &gt; 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) &gt;= 0) {
            hexResult = (hexResult &lt;&lt; 4) + tmp;

          } else {
            throwError(state, &#039;expected hexadecimal character&#039;);
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, &#039;unknown escape sequence&#039;);
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
      throwError(state, &#039;unexpected end of the document within a double quoted scalar&#039;);

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, &#039;unexpected end of the stream within a double quoted scalar&#039;);
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? &#039;mapping&#039; : &#039;sequence&#039;;
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, &#039;missed comma between flow collection entries&#039;);
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) &amp;&amp; ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, &#039;unexpected end of the stream within a flow collection&#039;);
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* &gt; */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, &#039;repeat of a chomping mode identifier&#039;);
      }

    } else if ((tmp = fromDecimalCode(ch)) &gt;= 0) {
      if (tmp === 0) {
        throwError(state, &#039;bad explicit indentation width of a block scalar; it cannot be less than one&#039;);
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, &#039;repeat of an indentation width identifier&#039;);
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) &amp;&amp; (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent &lt; textIndent) &amp;&amp;
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent &amp;&amp; state.lineIndent &gt; textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent &lt; textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += &#039;\n&#039;;
        }
      }

      // Break this `while` cycle and go to the funciton&#039;s epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat(&#039;\n&#039;, emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += &#039; &#039;;
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat(&#039;\n&#039;, emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) &amp;&amp; (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent &lt;= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== 0)) {
      throwError(state, &#039;bad indentation of a sequence entry&#039;);
    } else if (state.lineIndent &lt; nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = &#039;sequence&#039;;
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by &quot;?&quot;) and second for the value (denoted by &quot;:&quot;)
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) &amp;&amp; is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, &#039;incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line&#039;);
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then &quot;:&quot;, and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, &#039;a whitespace character is expected after the key-value separator within a block mapping&#039;);
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, &#039;can not read an implicit mapping pair; a colon is missed&#039;);

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, &#039;can not read a block mapping entry; a multiline key may not be an implicit key&#039;);

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent &gt; nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent &gt; nodeIndent &amp;&amp; (ch !== 0)) {
      throwError(state, &#039;bad indentation of a mapping entry&#039;);
    } else if (state.lineIndent &lt; nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping&#039;s node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = &#039;mapping&#039;;
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, &#039;duplication of a tag property&#039;);
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* &lt; */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = &#039;!!&#039;;
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = &#039;!&#039;;
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 &amp;&amp; ch !== 0x3E/* &gt; */);

    if (state.position &lt; state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, &#039;unexpected end of the stream within a verbatim tag&#039;);
    }
  } else {
    while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, &#039;named tag handle cannot contain such characters&#039;);
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, &#039;tag suffix cannot contain exclamation marks&#039;);
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, &#039;tag suffix cannot contain flow indicator characters&#039;);
    }
  }

  if (tagName &amp;&amp; !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, &#039;tag name cannot contain such characters: &#039; + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === &#039;!&#039;) {
    state.tag = &#039;!&#039; + tagName;

  } else if (tagHandle === &#039;!!&#039;) {
    state.tag = &#039;tag:yaml.org,2002:&#039; + tagName;

  } else {
    throwError(state, &#039;undeclared tag handle &quot;&#039; + tagHandle + &#039;&quot;&#039;);
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* &amp; */) return false;

  if (state.anchor !== null) {
    throwError(state, &#039;duplication of an anchor property&#039;);
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, &#039;name of an anchor node must contain at least one character&#039;);
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, &#039;name of an alias node must contain at least one character&#039;);
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty.call(state.anchorMap, alias)) {
    throwError(state, &#039;unidentified alias &quot;&#039; + alias + &#039;&quot;&#039;);
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this&gt;parent, 0: this=parent, -1: this&lt;parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener(&#039;open&#039;, state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent &gt; parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent &lt; parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent &gt; parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent &lt; parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &amp;&amp;
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars &amp;&amp; readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, &#039;alias node should not have any properties&#039;);
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = &#039;?&#039;;
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections &amp;&amp; readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null &amp;&amp; state.tag !== &#039;!&#039;) {
    if (state.tag === &#039;?&#039;) {
      // Implicit resolving is not allowed for non-scalar types, and &#039;?&#039;
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns &#039;?&#039;
      // tag, for example like this: &quot;!&lt;?&gt; [0]&quot;
      //
      if (state.result !== null &amp;&amp; state.kind !== &#039;scalar&#039;) {
        throwError(state, &#039;unacceptable node kind for !&lt;?&gt; tag; it should be &quot;scalar&quot;, not &quot;&#039; + state.kind + &#039;&quot;&#039;);
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex &lt; typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || &#039;fallback&#039;], state.tag)) {
      type = state.typeMap[state.kind || &#039;fallback&#039;][state.tag];

      if (state.result !== null &amp;&amp; type.kind !== state.kind) {
        throwError(state, &#039;unacceptable node kind for !&lt;&#039; + state.tag + &#039;&gt; tag; it should be &quot;&#039; + type.kind + &#039;&quot;, not &quot;&#039; + state.kind + &#039;&quot;&#039;);
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, &#039;cannot resolve a node with !&lt;&#039; + state.tag + &#039;&gt; explicit tag&#039;);
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, &#039;unknown tag !&lt;&#039; + state.tag + &#039;&gt;&#039;);
    }
  }

  if (state.listener !== null) {
    state.listener(&#039;close&#039;, state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent &gt; 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length &lt; 1) {
      throwError(state, &#039;directive name must not be less than one character in length&#039;);
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 &amp;&amp; !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, &#039;unknown document directive &quot;&#039; + directiveName + &#039;&quot;&#039;);
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &amp;&amp;
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &amp;&amp;
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &amp;&amp;
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, &#039;directives end mark is expected&#039;);
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &amp;&amp;
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, &#039;non-ASCII line breaks are interpreted as content&#039;);
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position &lt; (state.length - 1)) {
    throwError(state, &#039;end of the stream or a document separator is expected&#039;);
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &amp;&amp;
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += &#039;\n&#039;;
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf(&#039;\0&#039;);

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, &#039;null byte is not allowed in input&#039;);
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += &#039;\0&#039;;

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position &lt; (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null &amp;&amp; typeof iterator === &#039;object&#039; &amp;&amp; typeof options === &#039;undefined&#039;) {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== &#039;function&#039;) {
    return documents;
  }

  for (var index = 0, length = documents.length; index &lt; length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException(&#039;expected a single document in the stream, but found more&#039;);
}


function safeLoadAll(input, iterator, options) {
  if (typeof iterator === &#039;object&#039; &amp;&amp; iterator !== null &amp;&amp; typeof options === &#039;undefined&#039;) {
    options = iterator;
    iterator = null;
  }

  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{&quot;./common&quot;:2,&quot;./exception&quot;:4,&quot;./mark&quot;:6,&quot;./schema/default_full&quot;:9,&quot;./schema/default_safe&quot;:10}],6:[function(require,module,exports){
&#039;use strict&#039;;


var common = require(&#039;./common&#039;);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = &#039;&#039;;
  start = this.position;

  while (start &gt; 0 &amp;&amp; &#039;\x00\r\n\x85\u2028\u2029&#039;.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start &gt; (maxLength / 2 - 1)) {
      head = &#039; ... &#039;;
      start += 5;
      break;
    }
  }

  tail = &#039;&#039;;
  end = this.position;

  while (end &lt; this.buffer.length &amp;&amp; &#039;\x00\r\n\x85\u2028\u2029&#039;.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position &gt; (maxLength / 2 - 1)) {
      tail = &#039; ... &#039;;
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(&#039; &#039;, indent) + head + snippet + tail + &#039;\n&#039; +
         common.repeat(&#039; &#039;, indent + this.position - start + head.length) + &#039;^&#039;;
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = &#039;&#039;;

  if (this.name) {
    where += &#039;in &quot;&#039; + this.name + &#039;&quot; &#039;;
  }

  where += &#039;at line &#039; + (this.line + 1) + &#039;, column &#039; + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += &#039;:\n&#039; + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{&quot;./common&quot;:2}],7:[function(require,module,exports){
&#039;use strict&#039;;

/*eslint-disable max-len*/

var common        = require(&#039;./common&#039;);
var YAMLException = require(&#039;./exception&#039;);
var Type          = require(&#039;./type&#039;);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &amp;&amp; previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result[&#039;fallback&#039;][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index &lt; length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind &amp;&amp; type.loadKind !== &#039;scalar&#039;) {
      throw new YAMLException(&#039;There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.&#039;);
    }
  });

  this.compiledImplicit = compileList(this, &#039;implicit&#039;, []);
  this.compiledExplicit = compileList(this, &#039;explicit&#039;, []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException(&#039;Wrong number of arguments for Schema.create function&#039;);
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException(&#039;Specified list of super schemas (or a single Schema object) contains a non-Schema object.&#039;);
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException(&#039;Specified list of YAML types (or a single Type object) contains a non-Type object.&#039;);
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{&quot;./common&quot;:2,&quot;./exception&quot;:4,&quot;./type&quot;:13}],8:[function(require,module,exports){
// Standard YAML&#039;s Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  include: [
    require(&#039;./json&#039;)
  ]
});

},{&quot;../schema&quot;:7,&quot;./json&quot;:12}],9:[function(require,module,exports){
// JS-YAML&#039;s default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML&#039;s default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require(&#039;./default_safe&#039;)
  ],
  explicit: [
    require(&#039;../type/js/undefined&#039;),
    require(&#039;../type/js/regexp&#039;),
    require(&#039;../type/js/function&#039;)
  ]
});

},{&quot;../schema&quot;:7,&quot;../type/js/function&quot;:18,&quot;../type/js/regexp&quot;:19,&quot;../type/js/undefined&quot;:20,&quot;./default_safe&quot;:10}],10:[function(require,module,exports){
// JS-YAML&#039;s default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML&#039;s Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  include: [
    require(&#039;./core&#039;)
  ],
  implicit: [
    require(&#039;../type/timestamp&#039;),
    require(&#039;../type/merge&#039;)
  ],
  explicit: [
    require(&#039;../type/binary&#039;),
    require(&#039;../type/omap&#039;),
    require(&#039;../type/pairs&#039;),
    require(&#039;../type/set&#039;)
  ]
});

},{&quot;../schema&quot;:7,&quot;../type/binary&quot;:14,&quot;../type/merge&quot;:22,&quot;../type/omap&quot;:24,&quot;../type/pairs&quot;:25,&quot;../type/set&quot;:27,&quot;../type/timestamp&quot;:29,&quot;./core&quot;:8}],11:[function(require,module,exports){
// Standard YAML&#039;s Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  explicit: [
    require(&#039;../type/str&#039;),
    require(&#039;../type/seq&#039;),
    require(&#039;../type/map&#039;)
  ]
});

},{&quot;../schema&quot;:7,&quot;../type/map&quot;:21,&quot;../type/seq&quot;:26,&quot;../type/str&quot;:28}],12:[function(require,module,exports){
// Standard YAML&#039;s JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  include: [
    require(&#039;./failsafe&#039;)
  ],
  implicit: [
    require(&#039;../type/null&#039;),
    require(&#039;../type/bool&#039;),
    require(&#039;../type/int&#039;),
    require(&#039;../type/float&#039;)
  ]
});

},{&quot;../schema&quot;:7,&quot;../type/bool&quot;:15,&quot;../type/float&quot;:16,&quot;../type/int&quot;:17,&quot;../type/null&quot;:23,&quot;./failsafe&quot;:11}],13:[function(require,module,exports){
&#039;use strict&#039;;

var YAMLException = require(&#039;./exception&#039;);

var TYPE_CONSTRUCTOR_OPTIONS = [
  &#039;kind&#039;,
  &#039;resolve&#039;,
  &#039;construct&#039;,
  &#039;instanceOf&#039;,
  &#039;predicate&#039;,
  &#039;represent&#039;,
  &#039;defaultStyle&#039;,
  &#039;styleAliases&#039;
];

var YAML_NODE_KINDS = [
  &#039;scalar&#039;,
  &#039;sequence&#039;,
  &#039;mapping&#039;
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException(&#039;Unknown option &quot;&#039; + name + &#039;&quot; is met in definition of &quot;&#039; + tag + &#039;&quot; YAML type.&#039;);
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options[&#039;kind&#039;]         || null;
  this.resolve      = options[&#039;resolve&#039;]      || function () { return true; };
  this.construct    = options[&#039;construct&#039;]    || function (data) { return data; };
  this.instanceOf   = options[&#039;instanceOf&#039;]   || null;
  this.predicate    = options[&#039;predicate&#039;]    || null;
  this.represent    = options[&#039;represent&#039;]    || null;
  this.defaultStyle = options[&#039;defaultStyle&#039;] || null;
  this.styleAliases = compileStyleAliases(options[&#039;styleAliases&#039;] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException(&#039;Unknown kind &quot;&#039; + this.kind + &#039;&quot; is specified for &quot;&#039; + tag + &#039;&quot; YAML type.&#039;);
  }
}

module.exports = Type;

},{&quot;./exception&quot;:4}],14:[function(require,module,exports){
&#039;use strict&#039;;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = _require(&#039;buffer&#039;).Buffer;
} catch (__) {}

var Type       = require(&#039;../type&#039;);


// [ 64, 65, 66 ] -&gt; [ padding, CR, LF ]
var BASE64_MAP = &#039;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r&#039;;


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx &lt; max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code &gt; 64) continue;

    // Fail on illegal characters
    if (code &lt; 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, &#039;&#039;), // remove CR/LF &amp; padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx &lt; max; idx++) {
    if ((idx % 4 === 0) &amp;&amp; idx) {
      result.push((bits &gt;&gt; 16) &amp; 0xFF);
      result.push((bits &gt;&gt; 8) &amp; 0xFF);
      result.push(bits &amp; 0xFF);
    }

    bits = (bits &lt;&lt; 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits &gt;&gt; 16) &amp; 0xFF);
    result.push((bits &gt;&gt; 8) &amp; 0xFF);
    result.push(bits &amp; 0xFF);
  } else if (tailbits === 18) {
    result.push((bits &gt;&gt; 10) &amp; 0xFF);
    result.push((bits &gt;&gt; 2) &amp; 0xFF);
  } else if (tailbits === 12) {
    result.push((bits &gt;&gt; 4) &amp; 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = &#039;&#039;, bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx &lt; max; idx++) {
    if ((idx % 3 === 0) &amp;&amp; idx) {
      result += map[(bits &gt;&gt; 18) &amp; 0x3F];
      result += map[(bits &gt;&gt; 12) &amp; 0x3F];
      result += map[(bits &gt;&gt; 6) &amp; 0x3F];
      result += map[bits &amp; 0x3F];
    }

    bits = (bits &lt;&lt; 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits &gt;&gt; 18) &amp; 0x3F];
    result += map[(bits &gt;&gt; 12) &amp; 0x3F];
    result += map[(bits &gt;&gt; 6) &amp; 0x3F];
    result += map[bits &amp; 0x3F];
  } else if (tail === 2) {
    result += map[(bits &gt;&gt; 10) &amp; 0x3F];
    result += map[(bits &gt;&gt; 4) &amp; 0x3F];
    result += map[(bits &lt;&lt; 2) &amp; 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits &gt;&gt; 2) &amp; 0x3F];
    result += map[(bits &lt;&lt; 4) &amp; 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer &amp;&amp; NodeBuffer.isBuffer(object);
}

module.exports = new Type(&#039;tag:yaml.org,2002:binary&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{&quot;../type&quot;:13}],15:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 &amp;&amp; (data === &#039;true&#039; || data === &#039;True&#039; || data === &#039;TRUE&#039;)) ||
         (max === 5 &amp;&amp; (data === &#039;false&#039; || data === &#039;False&#039; || data === &#039;FALSE&#039;));
}

function constructYamlBoolean(data) {
  return data === &#039;true&#039; ||
         data === &#039;True&#039; ||
         data === &#039;TRUE&#039;;
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === &#039;[object Boolean]&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:bool&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? &#039;true&#039; : &#039;false&#039;; },
    uppercase: function (object) { return object ? &#039;TRUE&#039; : &#039;FALSE&#039;; },
    camelcase: function (object) { return object ? &#039;True&#039; : &#039;False&#039;; }
  },
  defaultStyle: &#039;lowercase&#039;
});

},{&quot;../type&quot;:13}],16:[function(require,module,exports){
&#039;use strict&#039;;

var common = require(&#039;../common&#039;);
var Type   = require(&#039;../type&#039;);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  &#039;^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?&#039; +
  // .2e4, .2
  // special case, seems not from spec
  &#039;|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?&#039; +
  // 20:59
  &#039;|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*&#039; +
  // .inf
  &#039;|[-+]?\\.(?:inf|Inf|INF)&#039; +
  // .nan
  &#039;|\\.(?:nan|NaN|NAN))$&#039;);

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp &amp; check speed
      data[data.length - 1] === &#039;_&#039;) {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, &#039;&#039;).toLowerCase();
  sign   = value[0] === &#039;-&#039; ? -1 : 1;
  digits = [];

  if (&#039;+-&#039;.indexOf(value[0]) &gt;= 0) {
    value = value.slice(1);
  }

  if (value === &#039;.inf&#039;) {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === &#039;.nan&#039;) {
    return NaN;

  } else if (value.indexOf(&#039;:&#039;) &gt;= 0) {
    value.split(&#039;:&#039;).forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case &#039;lowercase&#039;: return &#039;.nan&#039;;
      case &#039;uppercase&#039;: return &#039;.NAN&#039;;
      case &#039;camelcase&#039;: return &#039;.NaN&#039;;
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case &#039;lowercase&#039;: return &#039;.inf&#039;;
      case &#039;uppercase&#039;: return &#039;.INF&#039;;
      case &#039;camelcase&#039;: return &#039;.Inf&#039;;
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case &#039;lowercase&#039;: return &#039;-.inf&#039;;
      case &#039;uppercase&#039;: return &#039;-.INF&#039;;
      case &#039;camelcase&#039;: return &#039;-.Inf&#039;;
    }
  } else if (common.isNegativeZero(object)) {
    return &#039;-0.0&#039;;
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(&#039;e&#039;, &#039;.e&#039;) : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === &#039;[object Number]&#039;) &amp;&amp;
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type(&#039;tag:yaml.org,2002:float&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: &#039;lowercase&#039;
});

},{&quot;../common&quot;:2,&quot;../type&quot;:13}],17:[function(require,module,exports){
&#039;use strict&#039;;

var common = require(&#039;../common&#039;);
var Type   = require(&#039;../type&#039;);

function isHexCode(c) {
  return ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) ||
         ((0x41/* A */ &lt;= c) &amp;&amp; (c &lt;= 0x46/* F */)) ||
         ((0x61/* a */ &lt;= c) &amp;&amp; (c &lt;= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
    ch = data[++index];
  }

  if (ch === &#039;0&#039;) {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === &#039;b&#039;) {
      // base 2
      index++;

      for (; index &lt; max; index++) {
        ch = data[index];
        if (ch === &#039;_&#039;) continue;
        if (ch !== &#039;0&#039; &amp;&amp; ch !== &#039;1&#039;) return false;
        hasDigits = true;
      }
      return hasDigits &amp;&amp; ch !== &#039;_&#039;;
    }


    if (ch === &#039;x&#039;) {
      // base 16
      index++;

      for (; index &lt; max; index++) {
        ch = data[index];
        if (ch === &#039;_&#039;) continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits &amp;&amp; ch !== &#039;_&#039;;
    }

    // base 8
    for (; index &lt; max; index++) {
      ch = data[index];
      if (ch === &#039;_&#039;) continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits &amp;&amp; ch !== &#039;_&#039;;
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === &#039;_&#039;) return false;

  for (; index &lt; max; index++) {
    ch = data[index];
    if (ch === &#039;_&#039;) continue;
    if (ch === &#039;:&#039;) break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === &#039;_&#039;) return false;

  // if !base60 - done;
  if (ch !== &#039;:&#039;) return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf(&#039;_&#039;) !== -1) {
    value = value.replace(/_/g, &#039;&#039;);
  }

  ch = value[0];

  if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
    if (ch === &#039;-&#039;) sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === &#039;0&#039;) return 0;

  if (ch === &#039;0&#039;) {
    if (value[1] === &#039;b&#039;) return sign * parseInt(value.slice(2), 2);
    if (value[1] === &#039;x&#039;) return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(&#039;:&#039;) !== -1) {
    value.split(&#039;:&#039;).forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === &#039;[object Number]&#039; &amp;&amp;
         (object % 1 === 0 &amp;&amp; !common.isNegativeZero(object));
}

module.exports = new Type(&#039;tag:yaml.org,2002:int&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj &gt;= 0 ? &#039;0b&#039; + obj.toString(2) : &#039;-0b&#039; + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj &gt;= 0 ? &#039;0&#039;  + obj.toString(8) : &#039;-0&#039;  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj &gt;= 0 ? &#039;0x&#039; + obj.toString(16).toUpperCase() :  &#039;-0x&#039; + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: &#039;decimal&#039;,
  styleAliases: {
    binary:      [ 2,  &#039;bin&#039; ],
    octal:       [ 8,  &#039;oct&#039; ],
    decimal:     [ 10, &#039;dec&#039; ],
    hexadecimal: [ 16, &#039;hex&#039; ]
  }
});

},{&quot;../common&quot;:2,&quot;../type&quot;:13}],18:[function(require,module,exports){
&#039;use strict&#039;;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = _require(&#039;esprima&#039;);
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== &#039;undefined&#039;) esprima = window.esprima;
}

var Type = require(&#039;../../type&#039;);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = &#039;(&#039; + data + &#039;)&#039;,
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== &#039;Program&#039;             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== &#039;ExpressionStatement&#039; ||
        (ast.body[0].expression.type !== &#039;ArrowFunctionExpression&#039; &amp;&amp;
          ast.body[0].expression.type !== &#039;FunctionExpression&#039;)) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = &#039;(&#039; + data + &#039;)&#039;,
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== &#039;Program&#039;             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== &#039;ExpressionStatement&#039; ||
      (ast.body[0].expression.type !== &#039;ArrowFunctionExpression&#039; &amp;&amp;
        ast.body[0].expression.type !== &#039;FunctionExpression&#039;)) {
    throw new Error(&#039;Failed to resolve function&#039;);
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima&#039;s ranges include the first &#039;{&#039; and the last &#039;}&#039; characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === &#039;BlockStatement&#039;) {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, &#039;return &#039; + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === &#039;[object Function]&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:js/function&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{&quot;../../type&quot;:13}],19:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../../type&#039;);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = &#039;&#039;;

  // if regexp starts with &#039;/&#039; it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === &#039;/&#039;) {
    if (tail) modifiers = tail[1];

    if (modifiers.length &gt; 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== &#039;/&#039;) return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = &#039;&#039;;

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === &#039;/&#039;) {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = &#039;/&#039; + object.source + &#039;/&#039;;

  if (object.global) result += &#039;g&#039;;
  if (object.multiline) result += &#039;m&#039;;
  if (object.ignoreCase) result += &#039;i&#039;;

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === &#039;[object RegExp]&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:js/regexp&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{&quot;../../type&quot;:13}],20:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../../type&#039;);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return &#039;&#039;;
}

function isUndefined(object) {
  return typeof object === &#039;undefined&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:js/undefined&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{&quot;../../type&quot;:13}],21:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

module.exports = new Type(&#039;tag:yaml.org,2002:map&#039;, {
  kind: &#039;mapping&#039;,
  construct: function (data) { return data !== null ? data : {}; }
});

},{&quot;../type&quot;:13}],22:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

function resolveYamlMerge(data) {
  return data === &#039;&lt;&lt;&#039; || data === null;
}

module.exports = new Type(&#039;tag:yaml.org,2002:merge&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlMerge
});

},{&quot;../type&quot;:13}],23:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 &amp;&amp; data === &#039;~&#039;) ||
         (max === 4 &amp;&amp; (data === &#039;null&#039; || data === &#039;Null&#039; || data === &#039;NULL&#039;));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type(&#039;tag:yaml.org,2002:null&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return &#039;~&#039;;    },
    lowercase: function () { return &#039;null&#039;; },
    uppercase: function () { return &#039;NULL&#039;; },
    camelcase: function () { return &#039;Null&#039;; }
  },
  defaultStyle: &#039;lowercase&#039;
});

},{&quot;../type&quot;:13}],24:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== &#039;[object Object]&#039;) return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type(&#039;tag:yaml.org,2002:omap&#039;, {
  kind: &#039;sequence&#039;,
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{&quot;../type&quot;:13}],25:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== &#039;[object Object]&#039;) return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type(&#039;tag:yaml.org,2002:pairs&#039;, {
  kind: &#039;sequence&#039;,
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{&quot;../type&quot;:13}],26:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

module.exports = new Type(&#039;tag:yaml.org,2002:seq&#039;, {
  kind: &#039;sequence&#039;,
  construct: function (data) { return data !== null ? data : []; }
});

},{&quot;../type&quot;:13}],27:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type(&#039;tag:yaml.org,2002:set&#039;, {
  kind: &#039;mapping&#039;,
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{&quot;../type&quot;:13}],28:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

module.exports = new Type(&#039;tag:yaml.org,2002:str&#039;, {
  kind: &#039;scalar&#039;,
  construct: function (data) { return data !== null ? data : &#039;&#039;; }
});

},{&quot;../type&quot;:13}],29:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var YAML_DATE_REGEXP = new RegExp(
  &#039;^([0-9][0-9][0-9][0-9])&#039;          + // [1] year
  &#039;-([0-9][0-9])&#039;                    + // [2] month
  &#039;-([0-9][0-9])$&#039;);                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  &#039;^([0-9][0-9][0-9][0-9])&#039;          + // [1] year
  &#039;-([0-9][0-9]?)&#039;                   + // [2] month
  &#039;-([0-9][0-9]?)&#039;                   + // [3] day
  &#039;(?:[Tt]|[ \\t]+)&#039;                 + // ...
  &#039;([0-9][0-9]?)&#039;                    + // [4] hour
  &#039;:([0-9][0-9])&#039;                    + // [5] minute
  &#039;:([0-9][0-9])&#039;                    + // [6] second
  &#039;(?:\\.([0-9]*))?&#039;                 + // [7] fraction
  &#039;(?:[ \\t]*(Z|([-+])([0-9][0-9]?)&#039; + // [8] tz [9] tz_sign [10] tz_hour
  &#039;(?::([0-9][0-9]))?))?$&#039;);           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error(&#039;Date resolve error&#039;);

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length &lt; 3) { // milli-seconds
      fraction += &#039;0&#039;;
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === &#039;-&#039;) delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type(&#039;tag:yaml.org,2002:timestamp&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{&quot;../type&quot;:13}],&quot;/&quot;:[function(require,module,exports){
&#039;use strict&#039;;


var yaml = require(&#039;./lib/js-yaml.js&#039;);


module.exports = yaml;

},{&quot;./lib/js-yaml.js&quot;:1}]},{},[])(&quot;/&quot;)
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
