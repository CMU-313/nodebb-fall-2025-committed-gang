<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jquery-ui/ui/widgets/menu.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jquery-ui/ui/widgets/menu.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">713</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">69.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.19</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * jQuery UI Menu 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//&gt;&gt;label: Menu
//&gt;&gt;group: Widgets
//&gt;&gt;description: Creates nestable menus.
//&gt;&gt;docs: https://api.jqueryui.com/menu/
//&gt;&gt;demos: https://jqueryui.com/menu/
//&gt;&gt;css.structure: ../../themes/base/core.css
//&gt;&gt;css.structure: ../../themes/base/menu.css
//&gt;&gt;css.theme: ../../themes/base/theme.css

( function( factory ) {
	&quot;use strict&quot;;

	if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {

		// AMD. Register as an anonymous module.
		define( [
			&quot;jquery&quot;,
			&quot;../keycode&quot;,
			&quot;../position&quot;,
			&quot;../unique-id&quot;,
			&quot;../version&quot;,
			&quot;../widget&quot;
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
} )( function( $ ) {
&quot;use strict&quot;;

return $.widget( &quot;ui.menu&quot;, {
	version: &quot;1.14.1&quot;,
	defaultElement: &quot;&lt;ul&gt;&quot;,
	delay: 300,
	options: {
		icons: {
			submenu: &quot;ui-icon-caret-1-e&quot;
		},
		items: &quot;&gt; *&quot;,
		menus: &quot;ul&quot;,
		position: {
			my: &quot;left top&quot;,
			at: &quot;right top&quot;
		},
		role: &quot;menu&quot;,

		// Callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.lastMousePosition = { x: null, y: null };
		this.element
			.uniqueId()
			.attr( {
				role: this.options.role,
				tabIndex: 0
			} );

		this._addClass( &quot;ui-menu&quot;, &quot;ui-widget ui-widget-content&quot; );
		this._on( {

			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			&quot;mousedown .ui-menu-item&quot;: function( event ) {
				event.preventDefault();

				this._activateItem( event );
			},
			&quot;click .ui-menu-item&quot;: function( event ) {
				var target = $( event.target );
				var active = $( this.document[ 0 ].activeElement );
				if ( !this.mouseHandled &amp;&amp; target.not( &quot;.ui-state-disabled&quot; ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( &quot;.ui-menu&quot; ).length ) {
						this.expand( event );
					} else if ( !this.element.is( &quot;:focus&quot; ) &amp;&amp;
							active.closest( &quot;.ui-menu&quot; ).length ) {

						// Redirect focus to the menu
						this.element.trigger( &quot;focus&quot;, [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active &amp;&amp; this.active.parents( &quot;.ui-menu&quot; ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			&quot;mouseenter .ui-menu-item&quot;: &quot;_activateItem&quot;,
			&quot;mousemove .ui-menu-item&quot;: &quot;_activateItem&quot;,
			mouseleave: &quot;collapseAll&quot;,
			&quot;mouseleave .ui-menu&quot;: &quot;collapseAll&quot;,
			focus: function( event, keepActiveItem ) {

				// If there&#039;s already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this._menuItems().first();

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay( function() {
					var notContained = !$.contains(
						this.element[ 0 ],
						this.document[ 0 ].activeElement
					);
					if ( notContained ) {
						this.collapseAll( event );
					}
				} );
			},
			keydown: &quot;_keydown&quot;
		} );

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event, true );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		} );
	},

	_activateItem: function( event ) {

		// Ignore mouse events while typeahead is active, see #10458.
		// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
		// is over an item in the menu
		if ( this.previousFilter ) {
			return;
		}

		// If the mouse didn&#039;t actually move, but the page was scrolled, ignore the event (#9356)
		if ( event.clientX === this.lastMousePosition.x &amp;&amp;
				event.clientY === this.lastMousePosition.y ) {
			return;
		}

		this.lastMousePosition = {
			x: event.clientX,
			y: event.clientY
		};

		var actualTarget = $( event.target ).closest( &quot;.ui-menu-item&quot; ),
			target = $( event.currentTarget );

		// Ignore bubbled events on parent items, see #11641
		if ( actualTarget[ 0 ] !== target[ 0 ] ) {
			return;
		}

		// If the item is already active, there&#039;s nothing to do
		if ( target.is( &quot;.ui-state-active&quot; ) ) {
			return;
		}

		// Remove ui-state-active class from siblings of the newly focused menu item
		// to avoid a jump caused by adjacent elements both having a class with a border
		this._removeClass( target.siblings().children( &quot;.ui-state-active&quot; ),
			null, &quot;ui-state-active&quot; );
		this.focus( event, target );
	},

	_destroy: function() {
		var items = this.element.find( &quot;.ui-menu-item&quot; )
				.removeAttr( &quot;role aria-disabled&quot; ),
			submenus = items.children( &quot;.ui-menu-item-wrapper&quot; )
				.removeUniqueId()
				.removeAttr( &quot;tabIndex role aria-haspopup&quot; );

		// Destroy (sub)menus
		this.element
			.removeAttr( &quot;aria-activedescendant&quot; )
			.find( &quot;.ui-menu&quot; ).addBack()
				.removeAttr( &quot;role aria-labelledby aria-expanded aria-hidden aria-disabled &quot; +
					&quot;tabIndex&quot; )
				.removeUniqueId()
				.show();

		submenus.children().each( function() {
			var elem = $( this );
			if ( elem.data( &quot;ui-menu-submenu-caret&quot; ) ) {
				elem.remove();
			}
		} );
	},

	_keydown: function( event ) {
		var match, prev, character, skip,
			preventDefault = true;

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( &quot;first&quot;, &quot;first&quot;, event );
			break;
		case $.ui.keyCode.END:
			this._move( &quot;last&quot;, &quot;last&quot;, event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active &amp;&amp; !this.active.is( &quot;.ui-state-disabled&quot; ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || &quot;&quot;;
			skip = false;

			// Support number pad values
			character = event.keyCode &gt;= 96 &amp;&amp; event.keyCode &lt;= 105 ?
				( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			match = this._filterMenuItems( character );
			match = skip &amp;&amp; match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( &quot;.ui-menu-item&quot; ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				match = this._filterMenuItems( character );
			}

			if ( match.length ) {
				this.focus( event, match );
				this.previousFilter = character;
				this.filterTimer = this._delay( function() {
					delete this.previousFilter;
				}, 1000 );
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( this.active &amp;&amp; !this.active.is( &quot;.ui-state-disabled&quot; ) ) {
			if ( this.active.children( &quot;[aria-haspopup=&#039;true&#039;]&quot; ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items, newSubmenus, newItems, newWrappers,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this._toggleClass( &quot;ui-menu-icons&quot;, null, !!this.element.find( &quot;.ui-icon&quot; ).length );

		// Initialize nested menus
		newSubmenus = submenus.filter( &quot;:not(.ui-menu)&quot; )
			.hide()
			.attr( {
				role: this.options.role,
				&quot;aria-hidden&quot;: &quot;true&quot;,
				&quot;aria-expanded&quot;: &quot;false&quot;
			} )
			.each( function() {
				var menu = $( this ),
					item = menu.prev(),
					submenuCaret = $( &quot;&lt;span&gt;&quot; ).data( &quot;ui-menu-submenu-caret&quot;, true );

				that._addClass( submenuCaret, &quot;ui-menu-icon&quot;, &quot;ui-icon &quot; + icon );
				item
					.attr( &quot;aria-haspopup&quot;, &quot;true&quot; )
					.prepend( submenuCaret );
				menu.attr( &quot;aria-labelledby&quot;, item.attr( &quot;id&quot; ) );
			} );

		this._addClass( newSubmenus, &quot;ui-menu&quot;, &quot;ui-widget ui-widget-content ui-front&quot; );

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( &quot;.ui-menu-item&quot; ).each( function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				that._addClass( item, &quot;ui-menu-divider&quot;, &quot;ui-widget-content&quot; );
			}
		} );

		// Don&#039;t refresh list items that are already adapted
		newItems = items.not( &quot;.ui-menu-item, .ui-menu-divider&quot; );
		newWrappers = newItems.children()
			.not( &quot;.ui-menu&quot; )
				.uniqueId()
				.attr( {
					tabIndex: -1,
					role: this._itemRole()
				} );
		this._addClass( newItems, &quot;ui-menu-item&quot; )
			._addClass( newWrappers, &quot;ui-menu-item-wrapper&quot; );

		// Add aria-disabled attribute to any disabled menu item
		items.filter( &quot;.ui-state-disabled&quot; ).attr( &quot;aria-disabled&quot;, &quot;true&quot; );

		// If the active item has been removed, blur the menu
		if ( this.active &amp;&amp; !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: &quot;menuitem&quot;,
			listbox: &quot;option&quot;
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === &quot;icons&quot; ) {
			var icons = this.element.find( &quot;.ui-menu-icon&quot; );
			this._removeClass( icons, null, this.options.icons.submenu )
				._addClass( icons, null, value.submenu );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( &quot;aria-disabled&quot;, String( value ) );
		this._toggleClass( null, &quot;ui-state-disabled&quot;, !!value );
	},

	focus: function( event, item ) {
		var nested, focused, activeParent;
		this.blur( event, event &amp;&amp; event.type === &quot;focus&quot; );

		this._scrollIntoView( item );

		this.active = item.first();

		focused = this.active.children( &quot;.ui-menu-item-wrapper&quot; );
		this._addClass( focused, null, &quot;ui-state-active&quot; );

		// Only update aria-activedescendant if there&#039;s a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( &quot;aria-activedescendant&quot;, focused.attr( &quot;id&quot; ) );
		}

		// Highlight active parent menu item, if any
		activeParent = this.active
			.parent()
				.closest( &quot;.ui-menu-item&quot; )
					.children( &quot;.ui-menu-item-wrapper&quot; );
		this._addClass( activeParent, null, &quot;ui-state-active&quot; );

		if ( event &amp;&amp; event.type === &quot;keydown&quot; ) {
			this._close();
		} else {
			this.timer = this._delay( function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( &quot;.ui-menu&quot; );
		if ( nested.length &amp;&amp; event &amp;&amp; ( /^mouse/.test( event.type ) ) ) {
			this._startOpening( nested );
		}
		this.activeMenu = item.parent();

		this._trigger( &quot;focus&quot;, event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[ 0 ], &quot;borderTopWidth&quot; ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], &quot;paddingTop&quot; ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset &lt; 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight &gt; elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this._removeClass( this.active.children( &quot;.ui-menu-item-wrapper&quot; ),
			null, &quot;ui-state-active&quot; );

		this._trigger( &quot;blur&quot;, event, { item: this.active } );
		this.active = null;
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don&#039;t open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the caret icon
		if ( submenu.attr( &quot;aria-hidden&quot; ) !== &quot;true&quot; ) {
			return;
		}

		this.timer = this._delay( function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend( {
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( &quot;.ui-menu&quot; ).not( submenu.parents( &quot;.ui-menu&quot; ) )
			.hide()
			.attr( &quot;aria-hidden&quot;, &quot;true&quot; );

		submenu
			.show()
			.removeAttr( &quot;aria-hidden&quot; )
			.attr( &quot;aria-expanded&quot;, &quot;true&quot; )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay( function() {

			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event &amp;&amp; event.target ).closest( this.element.find( &quot;.ui-menu&quot; ) );

			// If we found no valid submenu ancestor, use the main menu to close all
			// sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );

			// Work around active item staying active after menu is blurred
			this._removeClass( currentMenu.find( &quot;.ui-state-active&quot; ), null, &quot;ui-state-active&quot; );

			this.activeMenu = currentMenu;
		}, all ? 0 : this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu.find( &quot;.ui-menu&quot; )
			.hide()
			.attr( &quot;aria-hidden&quot;, &quot;true&quot; )
			.attr( &quot;aria-expanded&quot;, &quot;false&quot; );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( &quot;.ui-menu&quot; ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &amp;&amp;
			this.active.parent().closest( &quot;.ui-menu-item&quot;, this.element );
		if ( newItem &amp;&amp; newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &amp;&amp; this._menuItems( this.active.children( &quot;.ui-menu&quot; ) ).first();

		if ( newItem &amp;&amp; newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay( function() {
				this.focus( event, newItem );
			} );
		}
	},

	next: function( event ) {
		this._move( &quot;next&quot;, &quot;first&quot;, event );
	},

	previous: function( event ) {
		this._move( &quot;prev&quot;, &quot;last&quot;, event );
	},

	isFirstItem: function() {
		return this.active &amp;&amp; !this.active.prevAll( &quot;.ui-menu-item&quot; ).length;
	},

	isLastItem: function() {
		return this.active &amp;&amp; !this.active.nextAll( &quot;.ui-menu-item&quot; ).length;
	},

	_menuItems: function( menu ) {
		return ( menu || this.element )
			.find( this.options.items )
			.filter( &quot;.ui-menu-item&quot; );
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === &quot;first&quot; || direction === &quot;last&quot; ) {
				next = this.active
					[ direction === &quot;first&quot; ? &quot;prevAll&quot; : &quot;nextAll&quot; ]( &quot;.ui-menu-item&quot; )
					.last();
			} else {
				next = this.active
					[ direction + &quot;All&quot; ]( &quot;.ui-menu-item&quot; )
					.first();
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this._menuItems( this.activeMenu )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.innerHeight();

			// jQuery 3.2 doesn&#039;t include scrollbars in innerHeight, add it back.
			if ( $.fn.jquery.indexOf( &quot;3.2.&quot; ) === 0 ) {
				height += this.element[ 0 ].offsetHeight - this.element.outerHeight();
			}

			this.active.nextAll( &quot;.ui-menu-item&quot; ).each( function() {
				item = $( this );
				return item.offset().top - base - height &lt; 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this._menuItems( this.activeMenu )
				[ !this.active ? &quot;first&quot; : &quot;last&quot; ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.innerHeight();

			// jQuery 3.2 doesn&#039;t include scrollbars in innerHeight, add it back.
			if ( $.fn.jquery.indexOf( &quot;3.2.&quot; ) === 0 ) {
				height += this.element[ 0 ].offsetHeight - this.element.outerHeight();
			}

			this.active.prevAll( &quot;.ui-menu-item&quot; ).each( function() {
				item = $( this );
				return item.offset().top - base + height &gt; 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this._menuItems( this.activeMenu ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() &lt; this.element.prop( &quot;scrollHeight&quot; );
	},

	select: function( event ) {

		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don&#039;t trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( &quot;.ui-menu-item&quot; );
		var ui = { item: this.active };
		if ( !this.active.has( &quot;.ui-menu&quot; ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( &quot;select&quot;, event, ui );
	},

	_filterMenuItems: function( character ) {
		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, &quot;\\$&amp;&quot; ),
			regex = new RegExp( &quot;^&quot; + escapedCharacter, &quot;i&quot; );

		return this.activeMenu
			.find( this.options.items )

				// Only match on items, not dividers or other content (#10571)
				.filter( &quot;.ui-menu-item&quot; )
					.filter( function() {
						return regex.test(
							String.prototype.trim.call(
								$( this ).children( &quot;.ui-menu-item-wrapper&quot; ).text() ) );
					} );
	}
} );

} );
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
