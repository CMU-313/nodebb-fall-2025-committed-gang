<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/request/node_modules/qs/dist/qs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/request/node_modules/qs/dist/qs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.64</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">649</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">143.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.Qs = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
&#039;use strict&#039;;

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    &#039;default&#039;: &#039;RFC3986&#039;,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, &#039;+&#039;);
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: &#039;RFC1738&#039;,
    RFC3986: &#039;RFC3986&#039;
};

},{}],2:[function(require,module,exports){
&#039;use strict&#039;;

var stringify = require(&#039;./stringify&#039;);
var parse = require(&#039;./parse&#039;);
var formats = require(&#039;./formats&#039;);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{&quot;./formats&quot;:1,&quot;./parse&quot;:3,&quot;./stringify&quot;:4}],3:[function(require,module,exports){
&#039;use strict&#039;;

var utils = require(&#039;./utils&#039;);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: &#039;&amp;&#039;,
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, &#039;&#039;) : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i &lt; parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(&#039;]=&#039;);
        var pos = bracketEqualsPos === -1 ? part.indexOf(&#039;=&#039;) : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : &#039;&#039;;
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i &gt;= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === &#039;[]&#039; &amp;&amp; options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === &#039;[&#039; &amp;&amp; root.charAt(root.length - 1) === &#039;]&#039; ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays &amp;&amp; cleanRoot === &#039;&#039;) {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                &amp;&amp; root !== cleanRoot
                &amp;&amp; String(index) === cleanRoot
                &amp;&amp; index &gt;= 0
                &amp;&amp; (options.parseArrays &amp;&amp; index &lt;= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== &#039;__proto__&#039;) {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, &#039;[$1]&#039;) : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren&#039;t using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects &amp;&amp; has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null &amp;&amp; i &lt; options.depth) {
        i += 1;
        if (!options.plainObjects &amp;&amp; has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there&#039;s a remainder, just add whatever is left

    if (segment) {
        keys.push(&#039;[&#039; + key.slice(segment.index) + &#039;]&#039;);
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null &amp;&amp; options.decoder !== undefined &amp;&amp; typeof options.decoder !== &#039;function&#039;) {
        throw new TypeError(&#039;Decoder has to be a function.&#039;);
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === &#039;string&#039; || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === &#039;number&#039; ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === &#039;number&#039; ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === &#039;function&#039; ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === &#039;boolean&#039; ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === &#039;boolean&#039; ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === &#039;boolean&#039; ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === &#039;number&#039; ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === &#039;boolean&#039; ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === &#039;&#039; || str === null || typeof str === &#039;undefined&#039;) {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === &#039;string&#039; ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i &lt; keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{&quot;./utils&quot;:5}],4:[function(require,module,exports){
&#039;use strict&#039;;

var utils = require(&#039;./utils&#039;);
var formats = require(&#039;./formats&#039;);

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + &#039;[]&#039;;
    },
    indices: function indices(prefix, key) {
        return prefix + &#039;[&#039; + key + &#039;]&#039;;
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: &#039;&amp;&#039;,
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === &#039;function&#039;) {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder &amp;&amp; !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = &#039;&#039;;
    }

    if (typeof obj === &#039;string&#039; || typeof obj === &#039;number&#039; || typeof obj === &#039;boolean&#039; || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + &#039;=&#039; + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + &#039;=&#039; + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === &#039;undefined&#039;) {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i &lt; objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls &amp;&amp; obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? &#039;.&#039; + key : &#039;[&#039; + key + &#039;]&#039;),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null &amp;&amp; typeof options.encoder !== &#039;undefined&#039; &amp;&amp; typeof options.encoder !== &#039;function&#039;) {
        throw new TypeError(&#039;Encoder has to be a function.&#039;);
    }

    var delimiter = typeof options.delimiter === &#039;undefined&#039; ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === &#039;boolean&#039; ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === &#039;boolean&#039; ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === &#039;boolean&#039; ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === &#039;function&#039; ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === &#039;function&#039; ? options.sort : null;
    var allowDots = typeof options.allowDots === &#039;undefined&#039; ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === &#039;function&#039; ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === &#039;boolean&#039; ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === &#039;undefined&#039;) {
        options.format = formats[&#039;default&#039;];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError(&#039;Unknown format option provided.&#039;);
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === &#039;function&#039;) {
        filter = options.filter;
        obj = filter(&#039;&#039;, obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== &#039;object&#039; || obj === null) {
        return &#039;&#039;;
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if (&#039;indices&#039; in options) {
        arrayFormat = options.indices ? &#039;indices&#039; : &#039;repeat&#039;;
    } else {
        arrayFormat = &#039;indices&#039;;
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i &lt; objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls &amp;&amp; obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? &#039;?&#039; : &#039;&#039;;

    return joined.length &gt; 0 ? prefix + joined : &#039;&#039;;
};

},{&quot;./formats&quot;:1,&quot;./utils&quot;:5}],5:[function(require,module,exports){
&#039;use strict&#039;;

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i &lt; 256; ++i) {
        array.push(&#039;%&#039; + ((i &lt; 16 ? &#039;0&#039; : &#039;&#039;) + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j &lt; obj.length; ++j) {
                if (typeof obj[j] !== &#039;undefined&#039;) {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options &amp;&amp; options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i &lt; source.length; ++i) {
        if (typeof source[i] !== &#039;undefined&#039;) {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== &#039;object&#039;) {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (target &amp;&amp; typeof target === &#039;object&#039;) {
            if ((options &amp;&amp; (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== &#039;object&#039;) {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) &amp;&amp; !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) &amp;&amp; Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem &amp;&amp; typeof targetItem === &#039;object&#039; &amp;&amp; item &amp;&amp; typeof item === &#039;object&#039;) {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, &#039; &#039;));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === &#039;string&#039; ? str : String(str);

    var out = &#039;&#039;;
    for (var i = 0; i &lt; string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c &gt;= 0x30 &amp;&amp; c &lt;= 0x39) // 0-9
            || (c &gt;= 0x41 &amp;&amp; c &lt;= 0x5A) // a-z
            || (c &gt;= 0x61 &amp;&amp; c &lt;= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c &lt; 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c &lt; 0x800) {
            out = out + (hexTable[0xC0 | (c &gt;&gt; 6)] + hexTable[0x80 | (c &amp; 0x3F)]);
            continue;
        }

        if (c &lt; 0xD800 || c &gt;= 0xE000) {
            out = out + (hexTable[0xE0 | (c &gt;&gt; 12)] + hexTable[0x80 | ((c &gt;&gt; 6) &amp; 0x3F)] + hexTable[0x80 | (c &amp; 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c &amp; 0x3FF) &lt;&lt; 10) | (string.charCodeAt(i) &amp; 0x3FF));
        /* eslint operator-linebreak: [2, &quot;before&quot;] */
        out += hexTable[0xF0 | (c &gt;&gt; 18)]
            + hexTable[0x80 | ((c &gt;&gt; 12) &amp; 0x3F)]
            + hexTable[0x80 | ((c &gt;&gt; 6) &amp; 0x3F)]
            + hexTable[0x80 | (c &amp; 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: &#039;o&#039; }];
    var refs = [];

    for (var i = 0; i &lt; queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j &lt; keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === &#039;object&#039; &amp;&amp; val !== null &amp;&amp; refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === &#039;[object RegExp]&#039;;
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === &#039;undefined&#039;) {
        return false;
    }

    return !!(obj.constructor &amp;&amp; obj.constructor.isBuffer &amp;&amp; obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};

},{}]},{},[2])(2)
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
