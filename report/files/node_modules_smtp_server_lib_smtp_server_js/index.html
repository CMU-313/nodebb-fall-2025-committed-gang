<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/smtp-server/lib/smtp-server.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/smtp-server/lib/smtp-server.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">528</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.61</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const net = require(&#039;net&#039;);
const tls = require(&#039;tls&#039;);
const SMTPConnection = require(&#039;./smtp-connection&#039;).SMTPConnection;
const tlsOptions = require(&#039;./tls-options&#039;);
const EventEmitter = require(&#039;events&#039;);
const shared = require(&#039;nodemailer/lib/shared&#039;);
const punycode = require(&#039;punycode.js&#039;);
const crypto = require(&#039;crypto&#039;);
const base32 = require(&#039;base32.js&#039;);

const CLOSE_TIMEOUT = 30 * 1000; // how much to wait until pending connections are terminated

/**
 * Creates a SMTP server instance.
 *
 * @constructor
 * @param {Object} options Connection and SMTP options≈æ
 */
class SMTPServer extends EventEmitter {
    constructor(options) {
        super();

        this.options = options || {};

        this.updateSecureContext();

        // setup disabled commands list
        this.options.disabledCommands = [].concat(this.options.disabledCommands || []).map(command =&gt; (command || &#039;&#039;).toString().toUpperCase().trim());

        // setup allowed auth methods
        this.options.authMethods = [].concat(this.options.authMethods || []).map(method =&gt; (method || &#039;&#039;).toString().toUpperCase().trim());

        if (!this.options.authMethods.length) {
            this.options.authMethods = [&#039;LOGIN&#039;, &#039;PLAIN&#039;];
        }

        // set default value for hideENHANCEDSTATUSCODES to true (disable enhanced status codes by default)
        if (this.options.hideENHANCEDSTATUSCODES === undefined) {
            this.options.hideENHANCEDSTATUSCODES = true;
        }

        // set default value for hideDSN to true (disable delivery status notifications by default)
        if (this.options.hideDSN === undefined) {
            this.options.hideDSN = true;
        }

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || &#039;smtp-server&#039;
        });

        // apply shorthand handlers
        [&#039;onConnect&#039;, &#039;onSecure&#039;, &#039;onAuth&#039;, &#039;onMailFrom&#039;, &#039;onRcptTo&#039;, &#039;onData&#039;, &#039;onClose&#039;].forEach(handler =&gt; {
            if (typeof this.options[handler] === &#039;function&#039;) {
                this[handler] = this.options[handler];
            }
        });

        /**
         * Timeout after close has been called until pending connections are forcibly closed
         */
        this._closeTimeout = false;

        /**
         * A set of all currently open connections
         */
        this.connections = new Set();

        // setup server listener and connection handler
        if (this.options.secure &amp;&amp; !this.options.needsUpgrade) {
            this.server = net.createServer(this.options, socket =&gt; {
                this._handleProxy(socket, (err, socketOptions) =&gt; {
                    if (err) {
                        // ignore, should not happen
                    }
                    if (this.options.secured) {
                        return this.connect(socket, socketOptions);
                    }
                    this._upgrade(socket, (err, tlsSocket) =&gt; {
                        if (err) {
                            return this._onError(err);
                        }
                        this.connect(tlsSocket, socketOptions);
                    });
                });
            });
        } else {
            this.server = net.createServer(this.options, socket =&gt;
                this._handleProxy(socket, (err, socketOptions) =&gt; {
                    if (err) {
                        // ignore, should not happen
                    }
                    this.connect(socket, socketOptions);
                })
            );
        }

        this._setListeners();
    }

    connect(socket, socketOptions) {
        let connection = new SMTPConnection(this, socket, socketOptions);
        this.connections.add(connection);
        connection.on(&#039;error&#039;, err =&gt; this._onError(err));
        connection.on(&#039;connect&#039;, data =&gt; this._onClientConnect(data));
        connection.init();
    }

    /**
     * Start listening on selected port and interface
     */
    listen(...args) {
        return this.server.listen(...args);
    }

    /**
     * Closes the server
     *
     * @param {Function} callback Callback to run once the server is fully closed
     */
    close(callback) {
        let connections = this.connections.size;
        let timeout = this.options.closeTimeout || CLOSE_TIMEOUT;

        // stop accepting new connections
        this.server.close(() =&gt; {
            clearTimeout(this._closeTimeout);
            if (typeof callback === &#039;function&#039;) {
                return callback();
            }
        });

        // close active connections
        if (connections) {
            this.logger.info(
                {
                    tnx: &#039;close&#039;
                },
                &#039;Server closing with %s pending connection%s, waiting %s seconds before terminating&#039;,
                connections,
                connections !== 1 ? &#039;s&#039; : &#039;&#039;,
                timeout / 1000
            );
        }

        this._closeTimeout = setTimeout(() =&gt; {
            connections = this.connections.size;
            if (connections) {
                this.logger.info(
                    {
                        tnx: &#039;close&#039;
                    },
                    &#039;Closing %s pending connection%s to close the server&#039;,
                    connections,
                    connections !== 1 ? &#039;s&#039; : &#039;&#039;
                );

                this.connections.forEach(connection =&gt; {
                    connection.send(421, &#039;Server shutting down&#039;);
                    connection.close();
                });
            }
            if (typeof callback === &#039;function&#039;) {
                const realCallback = callback;
                callback = null;
                return realCallback();
            }
        }, timeout);
    }

    /**
     * Authentication handler. Override this
     *
     * @param {Object} auth Authentication options
     * @param {Function} callback Callback to run once the user is authenticated
     */
    onAuth(auth, session, callback) {
        if (auth.method === &#039;XOAUTH2&#039;) {
            return callback(null, {
                data: {
                    status: &#039;401&#039;,
                    schemes: &#039;bearer mac&#039;,
                    scope: &#039;https://mail.google.com/&#039;
                }
            });
        }

        if (auth.method === &#039;XCLIENT&#039;) {
            return callback(); // pass through
        }

        return callback(null, {
            message: &#039;Authentication not implemented&#039;
        });
    }

    onConnect(session, callback) {
        setImmediate(callback);
    }

    onMailFrom(address, session, callback) {
        setImmediate(callback);
    }

    onRcptTo(address, session, callback) {
        setImmediate(callback);
    }
    onSecure(socket, session, callback) {
        setImmediate(callback);
    }
    onData(stream, session, callback) {
        let chunklen = 0;

        stream.on(&#039;data&#039;, chunk =&gt; {
            chunklen += chunk.length;
        });

        stream.on(&#039;end&#039;, () =&gt; {
            this.logger.info(
                {
                    tnx: &#039;message&#039;,
                    size: chunklen
                },
                &#039;&lt;received %s bytes&gt;&#039;,
                chunklen
            );
            callback();
        });
    }

    onClose(/* session */) {
        // do nothing
    }

    updateSecureContext(options) {
        Object.keys(options || {}).forEach(key =&gt; {
            this.options[key] = options[key];
        });

        let defaultTlsOptions = tlsOptions(this.options);

        this.secureContext = new Map();
        this.secureContext.set(&#039;*&#039;, tls.createSecureContext(defaultTlsOptions));

        let ctxMap = this.options.sniOptions || {};
        // sniOptions is either an object or a Map with domain names as keys and TLS option objects as values
        if (typeof ctxMap.get === &#039;function&#039;) {
            ctxMap.forEach((ctx, servername) =&gt; {
                this.secureContext.set(this._normalizeHostname(servername), tls.createSecureContext(tlsOptions(ctx)));
            });
        } else {
            Object.keys(ctxMap).forEach(servername =&gt; {
                this.secureContext.set(this._normalizeHostname(servername), tls.createSecureContext(tlsOptions(ctxMap[servername])));
            });
        }

        if (this.options.secure) {
            // appy changes

            Object.keys(defaultTlsOptions || {}).forEach(key =&gt; {
                if (!(key in this.options)) {
                    this.options[key] = defaultTlsOptions[key];
                }
            });

            // ensure SNICallback method
            if (typeof this.options.SNICallback !== &#039;function&#039;) {
                // create default SNI handler
                this.options.SNICallback = (servername, cb) =&gt; {
                    cb(null, this.secureContext.get(servername));
                };
            }
        }
    }

    // PRIVATE METHODS

    /**
     * Setup server event handlers
     */
    _setListeners() {
        let server = this.server;
        server.once(&#039;listening&#039;, (...args) =&gt; this._onListening(...args));
        server.once(&#039;close&#039;, (...args) =&gt; this._onClose(server, ...args));
        server.on(&#039;error&#039;, (...args) =&gt; this._onError(...args));
    }

    /**
     * Called when server started listening
     *
     * @event
     */
    _onListening() {
        let address = this.server.address();

        // address will be null if listener is using Unix socket
        if (address === null) {
            address = { address: null, port: null, family: null };
        }

        this.logger.info(
            //
            {
                tnx: &#039;listen&#039;,
                host: address.address,
                port: address.port,
                secure: !!this.options.secure,
                protocol: this.options.lmtp ? &#039;LMTP&#039; : &#039;SMTP&#039;
            },
            &#039;%s%s Server listening on %s:%s&#039;,
            this.options.secure ? &#039;Secure &#039; : &#039;&#039;,
            this.options.lmtp ? &#039;LMTP&#039; : &#039;SMTP&#039;,
            address.family === &#039;IPv4&#039; ? address.address : &#039;[&#039; + address.address + &#039;]&#039;,
            address.port
        );
    }

    /**
     * Called when server is closed
     *
     * @event
     */
    _onClose(server) {
        this.logger.info(
            {
                tnx: &#039;closed&#039;
            },
            (this.options.lmtp ? &#039;LMTP&#039; : &#039;SMTP&#039;) + &#039; Server closed&#039;
        );
        if (server !== this.server) {
            // older instance was closed
            return;
        }
        this.emit(&#039;close&#039;);
    }

    /**
     * Called when an error occurs with the server
     *
     * @event
     */
    _onError(err) {
        this.emit(&#039;error&#039;, err);
    }

    _handleProxy(socket, callback) {
        let socketOptions = {
            id: base32.encode(crypto.randomBytes(10)).toLowerCase()
        };

        if (
            !this.options.useProxy ||
            (Array.isArray(this.options.useProxy) &amp;&amp; !this.options.useProxy.includes(socket.remoteAddress) &amp;&amp; !this.options.useProxy.includes(&#039;*&#039;))
        ) {
            socketOptions.ignore = this.options.ignoredHosts &amp;&amp; this.options.ignoredHosts.includes(socket.remoteAddress);
            return setImmediate(() =&gt; callback(null, socketOptions));
        }

        let chunks = [];
        let chunklen = 0;
        let socketReader = () =&gt; {
            let chunk;
            while ((chunk = socket.read()) !== null) {
                for (let i = 0, len = chunk.length; i &lt; len; i++) {
                    let chr = chunk[i];
                    if (chr === 0x0a) {
                        socket.removeListener(&#039;readable&#039;, socketReader);
                        chunks.push(chunk.slice(0, i + 1));
                        chunklen += i + 1;
                        let remainder = chunk.slice(i + 1);
                        if (remainder.length) {
                            socket.unshift(remainder);
                        }

                        let header = Buffer.concat(chunks, chunklen).toString().trim();

                        let params = (header || &#039;&#039;).toString().split(&#039; &#039;);
                        let commandName = params.shift().toUpperCase();
                        if (commandName !== &#039;PROXY&#039;) {
                            try {
                                socket.end(&#039;* BAD Invalid PROXY header\r\n&#039;);
                            } catch (E) {
                                // ignore
                            }
                            return;
                        }

                        if (params[1]) {
                            socketOptions.remoteAddress = params[1].trim().toLowerCase();

                            socketOptions.ignore = this.options.ignoredHosts &amp;&amp; this.options.ignoredHosts.includes(socketOptions.remoteAddress);

                            try {
                                if (!socketOptions.ignore) {
                                    this.logger.info(
                                        {
                                            tnx: &#039;proxy&#039;,
                                            cid: socketOptions.id,
                                            proxy: params[1].trim().toLowerCase()
                                        },
                                        &#039;[%s] PROXY from %s through %s (%s)&#039;,
                                        socketOptions.id,
                                        params[1].trim().toLowerCase(),
                                        params[2].trim().toLowerCase(),
                                        JSON.stringify(params)
                                    );
                                }
                            } catch (E) {
                                socket.end(&#039;* BAD Invalid PROXY header\r\n&#039;);
                                return;
                            }

                            if (params[3]) {
                                socketOptions.remotePort = Number(params[3].trim()) || socketOptions.remotePort;
                            }
                        }

                        return callback(null, socketOptions);
                    }
                }
                chunks.push(chunk);
                chunklen += chunk.length;
            }
        };
        socket.on(&#039;readable&#039;, socketReader);
    }

    /**
     * Called when a new connection is established. This might not be the same time the socket is opened
     *
     * @event
     */
    _onClientConnect(data) {
        this.emit(&#039;connect&#039;, data);
    }

    /**
     * Normalize hostname
     *
     * @event
     */
    _normalizeHostname(hostname) {
        try {
            hostname = punycode.toUnicode((hostname || &#039;&#039;).toString().trim()).toLowerCase();
        } catch (E) {
            this.logger.error(
                {
                    tnx: &#039;punycode&#039;
                },
                &#039;Failed to process punycode domain &quot;%s&quot;. error=%s&#039;,
                hostname,
                E.message
            );
        }

        return hostname;
    }

    _upgrade(socket, callback) {
        let socketOptions = {
            secureContext: this.secureContext.get(&#039;*&#039;),
            isServer: true,
            server: this.server,
            SNICallback: (servername, cb) =&gt; {
                // eslint-disable-next-line new-cap
                this.options.SNICallback(this._normalizeHostname(servername), (err, context) =&gt; {
                    if (err) {
                        this.logger.error(
                            {
                                tnx: &#039;sni&#039;,
                                servername,
                                err
                            },
                            &#039;Failed to fetch SNI context for servername %s&#039;,
                            servername
                        );
                    }
                    return cb(null, context || this.secureContext.get(&#039;*&#039;));
                });
            }
        };

        let returned = false;
        let onError = err =&gt; {
            if (returned) {
                return;
            }
            returned = true;
            callback(err || new Error(&#039;Socket closed unexpectedly&#039;));
        };

        // remove all listeners from the original socket besides the error handler
        socket.once(&#039;error&#039;, onError);

        // upgrade connection
        let tlsSocket = new tls.TLSSocket(socket, socketOptions);

        tlsSocket.once(&#039;close&#039;, onError);
        tlsSocket.once(&#039;error&#039;, onError);
        tlsSocket.once(&#039;_tlsError&#039;, onError);
        tlsSocket.once(&#039;clientError&#039;, onError);
        tlsSocket.once(&#039;tlsClientError&#039;, onError);

        tlsSocket.on(&#039;secure&#039;, () =&gt; {
            socket.removeListener(&#039;error&#039;, onError);
            tlsSocket.removeListener(&#039;close&#039;, onError);
            tlsSocket.removeListener(&#039;error&#039;, onError);
            tlsSocket.removeListener(&#039;_tlsError&#039;, onError);
            tlsSocket.removeListener(&#039;clientError&#039;, onError);
            tlsSocket.removeListener(&#039;tlsClientError&#039;, onError);
            if (returned) {
                try {
                    tlsSocket.end();
                } catch (E) {
                    //
                }
                return;
            }
            returned = true;
            return callback(null, tlsSocket);
        });
    }
}

// Expose to the world
module.exports.SMTPServer = SMTPServer;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
