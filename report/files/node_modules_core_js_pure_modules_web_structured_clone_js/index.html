<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/core-js-pure/modules/web.structured-clone.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/core-js-pure/modules/web.structured-clone.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">536</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;
var IS_PURE = require(&#039;../internals/is-pure&#039;);
var $ = require(&#039;../internals/export&#039;);
var globalThis = require(&#039;../internals/global-this&#039;);
var getBuiltIn = require(&#039;../internals/get-built-in&#039;);
var uncurryThis = require(&#039;../internals/function-uncurry-this&#039;);
var fails = require(&#039;../internals/fails&#039;);
var uid = require(&#039;../internals/uid&#039;);
var isCallable = require(&#039;../internals/is-callable&#039;);
var isConstructor = require(&#039;../internals/is-constructor&#039;);
var isNullOrUndefined = require(&#039;../internals/is-null-or-undefined&#039;);
var isObject = require(&#039;../internals/is-object&#039;);
var isSymbol = require(&#039;../internals/is-symbol&#039;);
var iterate = require(&#039;../internals/iterate&#039;);
var anObject = require(&#039;../internals/an-object&#039;);
var classof = require(&#039;../internals/classof&#039;);
var hasOwn = require(&#039;../internals/has-own-property&#039;);
var createProperty = require(&#039;../internals/create-property&#039;);
var createNonEnumerableProperty = require(&#039;../internals/create-non-enumerable-property&#039;);
var lengthOfArrayLike = require(&#039;../internals/length-of-array-like&#039;);
var validateArgumentsLength = require(&#039;../internals/validate-arguments-length&#039;);
var getRegExpFlags = require(&#039;../internals/regexp-get-flags&#039;);
var MapHelpers = require(&#039;../internals/map-helpers&#039;);
var SetHelpers = require(&#039;../internals/set-helpers&#039;);
var setIterate = require(&#039;../internals/set-iterate&#039;);
var detachTransferable = require(&#039;../internals/detach-transferable&#039;);
var ERROR_STACK_INSTALLABLE = require(&#039;../internals/error-stack-installable&#039;);
var PROPER_STRUCTURED_CLONE_TRANSFER = require(&#039;../internals/structured-clone-proper-transfer&#039;);

var Object = globalThis.Object;
var Array = globalThis.Array;
var Date = globalThis.Date;
var Error = globalThis.Error;
var TypeError = globalThis.TypeError;
var PerformanceMark = globalThis.PerformanceMark;
var DOMException = getBuiltIn(&#039;DOMException&#039;);
var Map = MapHelpers.Map;
var mapHas = MapHelpers.has;
var mapGet = MapHelpers.get;
var mapSet = MapHelpers.set;
var Set = SetHelpers.Set;
var setAdd = SetHelpers.add;
var setHas = SetHelpers.has;
var objectKeys = getBuiltIn(&#039;Object&#039;, &#039;keys&#039;);
var push = uncurryThis([].push);
var thisBooleanValue = uncurryThis(true.valueOf);
var thisNumberValue = uncurryThis(1.1.valueOf);
var thisStringValue = uncurryThis(&#039;&#039;.valueOf);
var thisTimeValue = uncurryThis(Date.prototype.getTime);
var PERFORMANCE_MARK = uid(&#039;structuredClone&#039;);
var DATA_CLONE_ERROR = &#039;DataCloneError&#039;;
var TRANSFERRING = &#039;Transferring&#039;;

var checkBasicSemantic = function (structuredCloneImplementation) {
  return !fails(function () {
    var set1 = new globalThis.Set([7]);
    var set2 = structuredCloneImplementation(set1);
    var number = structuredCloneImplementation(Object(7));
    return set2 === set1 || !set2.has(7) || !isObject(number) || +number !== 7;
  }) &amp;&amp; structuredCloneImplementation;
};

var checkErrorsCloning = function (structuredCloneImplementation, $Error) {
  return !fails(function () {
    var error = new $Error();
    var test = structuredCloneImplementation({ a: error, b: error });
    return !(test &amp;&amp; test.a === test.b &amp;&amp; test.a instanceof $Error &amp;&amp; test.a.stack === error.stack);
  });
};

// https://github.com/whatwg/html/pull/5749
var checkNewErrorsCloningSemantic = function (structuredCloneImplementation) {
  return !fails(function () {
    var test = structuredCloneImplementation(new globalThis.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
    return test.name !== &#039;AggregateError&#039; || test.errors[0] !== 1 || test.message !== PERFORMANCE_MARK || test.cause !== 3;
  });
};

// FF94+, Safari 15.4+, Chrome 98+, NodeJS 17.0+, Deno 1.13+
// FF&lt;103 and Safari implementations can&#039;t clone errors
// https://bugzilla.mozilla.org/show_bug.cgi?id=1556604
// FF103 can clone errors, but `.stack` of clone is an empty string
// https://bugzilla.mozilla.org/show_bug.cgi?id=1778762
// FF104+ fixed it on usual errors, but not on DOMExceptions
// https://bugzilla.mozilla.org/show_bug.cgi?id=1777321
// Chrome &lt;102 returns `null` if cloned object contains multiple references to one error
// https://bugs.chromium.org/p/v8/issues/detail?id=12542
// NodeJS implementation can&#039;t clone DOMExceptions
// https://github.com/nodejs/node/issues/41038
// only FF103+ supports new (html/5749) error cloning semantic
var nativeStructuredClone = globalThis.structuredClone;

var FORCED_REPLACEMENT = IS_PURE
  || !checkErrorsCloning(nativeStructuredClone, Error)
  || !checkErrorsCloning(nativeStructuredClone, DOMException)
  || !checkNewErrorsCloningSemantic(nativeStructuredClone);

// Chrome 82+, Safari 14.1+, Deno 1.11+
// Chrome 78-81 implementation swaps `.name` and `.message` of cloned `DOMException`
// Chrome returns `null` if cloned object contains multiple references to one error
// Safari 14.1 implementation doesn&#039;t clone some `RegExp` flags, so requires a workaround
// Safari implementation can&#039;t clone errors
// Deno 1.2-1.10 implementations too naive
// NodeJS 16.0+ does not have `PerformanceMark` constructor
// NodeJS &lt;17.2 structured cloning implementation from `performance.mark` is too naive
// and can&#039;t clone, for example, `RegExp` or some boxed primitives
// https://github.com/nodejs/node/issues/40840
// no one of those implementations supports new (html/5749) error cloning semantic
var structuredCloneFromMark = !nativeStructuredClone &amp;&amp; checkBasicSemantic(function (value) {
  return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
});

var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;

var throwUncloneable = function (type) {
  throw new DOMException(&#039;Uncloneable type: &#039; + type, DATA_CLONE_ERROR);
};

var throwUnpolyfillable = function (type, action) {
  throw new DOMException((action || &#039;Cloning&#039;) + &#039; of &#039; + type + &#039; cannot be properly polyfilled in this engine&#039;, DATA_CLONE_ERROR);
};

var tryNativeRestrictedStructuredClone = function (value, type) {
  if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
  return nativeRestrictedStructuredClone(value);
};

var createDataTransfer = function () {
  var dataTransfer;
  try {
    dataTransfer = new globalThis.DataTransfer();
  } catch (error) {
    try {
      dataTransfer = new globalThis.ClipboardEvent(&#039;&#039;).clipboardData;
    } catch (error2) { /* empty */ }
  }
  return dataTransfer &amp;&amp; dataTransfer.items &amp;&amp; dataTransfer.files ? dataTransfer : null;
};

var cloneBuffer = function (value, map, $type) {
  if (mapHas(map, value)) return mapGet(map, value);

  var type = $type || classof(value);
  var clone, length, options, source, target, i;

  if (type === &#039;SharedArrayBuffer&#039;) {
    if (nativeRestrictedStructuredClone) clone = nativeRestrictedStructuredClone(value);
    // SharedArrayBuffer should use shared memory, we can&#039;t polyfill it, so return the original
    else clone = value;
  } else {
    var DataView = globalThis.DataView;

    // `ArrayBuffer#slice` is not available in IE10
    // `ArrayBuffer#slice` and `DataView` are not available in old FF
    if (!DataView &amp;&amp; !isCallable(value.slice)) throwUnpolyfillable(&#039;ArrayBuffer&#039;);
    // detached buffers throws in `DataView` and `.slice`
    try {
      if (isCallable(value.slice) &amp;&amp; !value.resizable) {
        clone = value.slice(0);
      } else {
        length = value.byteLength;
        options = &#039;maxByteLength&#039; in value ? { maxByteLength: value.maxByteLength } : undefined;
        // eslint-disable-next-line es/no-resizable-and-growable-arraybuffers -- safe
        clone = new ArrayBuffer(length, options);
        source = new DataView(value);
        target = new DataView(clone);
        for (i = 0; i &lt; length; i++) {
          target.setUint8(i, source.getUint8(i));
        }
      }
    } catch (error) {
      throw new DOMException(&#039;ArrayBuffer is detached&#039;, DATA_CLONE_ERROR);
    }
  }

  mapSet(map, value, clone);

  return clone;
};

var cloneView = function (value, type, offset, length, map) {
  var C = globalThis[type];
  // in some old engines like Safari 9, typeof C is &#039;object&#039;
  // on Uint8ClampedArray or some other constructors
  if (!isObject(C)) throwUnpolyfillable(type);
  return new C(cloneBuffer(value.buffer, map), offset, length);
};

var structuredCloneInternal = function (value, map) {
  if (isSymbol(value)) throwUncloneable(&#039;Symbol&#039;);
  if (!isObject(value)) return value;
  // effectively preserves circular references
  if (map) {
    if (mapHas(map, value)) return mapGet(map, value);
  } else map = new Map();

  var type = classof(value);
  var C, name, cloned, dataTransfer, i, length, keys, key;

  switch (type) {
    case &#039;Array&#039;:
      cloned = Array(lengthOfArrayLike(value));
      break;
    case &#039;Object&#039;:
      cloned = {};
      break;
    case &#039;Map&#039;:
      cloned = new Map();
      break;
    case &#039;Set&#039;:
      cloned = new Set();
      break;
    case &#039;RegExp&#039;:
      // in this block because of a Safari 14.1 bug
      // old FF does not clone regexes passed to the constructor, so get the source and flags directly
      cloned = new RegExp(value.source, getRegExpFlags(value));
      break;
    case &#039;Error&#039;:
      name = value.name;
      switch (name) {
        case &#039;AggregateError&#039;:
          cloned = new (getBuiltIn(name))([]);
          break;
        case &#039;EvalError&#039;:
        case &#039;RangeError&#039;:
        case &#039;ReferenceError&#039;:
        case &#039;SuppressedError&#039;:
        case &#039;SyntaxError&#039;:
        case &#039;TypeError&#039;:
        case &#039;URIError&#039;:
          cloned = new (getBuiltIn(name))();
          break;
        case &#039;CompileError&#039;:
        case &#039;LinkError&#039;:
        case &#039;RuntimeError&#039;:
          cloned = new (getBuiltIn(&#039;WebAssembly&#039;, name))();
          break;
        default:
          cloned = new Error();
      }
      break;
    case &#039;DOMException&#039;:
      cloned = new DOMException(value.message, value.name);
      break;
    case &#039;ArrayBuffer&#039;:
    case &#039;SharedArrayBuffer&#039;:
      cloned = cloneBuffer(value, map, type);
      break;
    case &#039;DataView&#039;:
    case &#039;Int8Array&#039;:
    case &#039;Uint8Array&#039;:
    case &#039;Uint8ClampedArray&#039;:
    case &#039;Int16Array&#039;:
    case &#039;Uint16Array&#039;:
    case &#039;Int32Array&#039;:
    case &#039;Uint32Array&#039;:
    case &#039;Float16Array&#039;:
    case &#039;Float32Array&#039;:
    case &#039;Float64Array&#039;:
    case &#039;BigInt64Array&#039;:
    case &#039;BigUint64Array&#039;:
      length = type === &#039;DataView&#039; ? value.byteLength : value.length;
      cloned = cloneView(value, type, value.byteOffset, length, map);
      break;
    case &#039;DOMQuad&#039;:
      try {
        cloned = new DOMQuad(
          structuredCloneInternal(value.p1, map),
          structuredCloneInternal(value.p2, map),
          structuredCloneInternal(value.p3, map),
          structuredCloneInternal(value.p4, map)
        );
      } catch (error) {
        cloned = tryNativeRestrictedStructuredClone(value, type);
      }
      break;
    case &#039;File&#039;:
      if (nativeRestrictedStructuredClone) try {
        cloned = nativeRestrictedStructuredClone(value);
        // NodeJS 20.0.0 bug, https://github.com/nodejs/node/issues/47612
        if (classof(cloned) !== type) cloned = undefined;
      } catch (error) { /* empty */ }
      if (!cloned) try {
        cloned = new File([value], value.name, value);
      } catch (error) { /* empty */ }
      if (!cloned) throwUnpolyfillable(type);
      break;
    case &#039;FileList&#039;:
      dataTransfer = createDataTransfer();
      if (dataTransfer) {
        for (i = 0, length = lengthOfArrayLike(value); i &lt; length; i++) {
          dataTransfer.items.add(structuredCloneInternal(value[i], map));
        }
        cloned = dataTransfer.files;
      } else cloned = tryNativeRestrictedStructuredClone(value, type);
      break;
    case &#039;ImageData&#039;:
      // Safari 9 ImageData is a constructor, but typeof ImageData is &#039;object&#039;
      try {
        cloned = new ImageData(
          structuredCloneInternal(value.data, map),
          value.width,
          value.height,
          { colorSpace: value.colorSpace }
        );
      } catch (error) {
        cloned = tryNativeRestrictedStructuredClone(value, type);
      } break;
    default:
      if (nativeRestrictedStructuredClone) {
        cloned = nativeRestrictedStructuredClone(value);
      } else switch (type) {
        case &#039;BigInt&#039;:
          // can be a 3rd party polyfill
          cloned = Object(value.valueOf());
          break;
        case &#039;Boolean&#039;:
          cloned = Object(thisBooleanValue(value));
          break;
        case &#039;Number&#039;:
          cloned = Object(thisNumberValue(value));
          break;
        case &#039;String&#039;:
          cloned = Object(thisStringValue(value));
          break;
        case &#039;Date&#039;:
          cloned = new Date(thisTimeValue(value));
          break;
        case &#039;Blob&#039;:
          try {
            cloned = value.slice(0, value.size, value.type);
          } catch (error) {
            throwUnpolyfillable(type);
          } break;
        case &#039;DOMPoint&#039;:
        case &#039;DOMPointReadOnly&#039;:
          C = globalThis[type];
          try {
            cloned = C.fromPoint
              ? C.fromPoint(value)
              : new C(value.x, value.y, value.z, value.w);
          } catch (error) {
            throwUnpolyfillable(type);
          } break;
        case &#039;DOMRect&#039;:
        case &#039;DOMRectReadOnly&#039;:
          C = globalThis[type];
          try {
            cloned = C.fromRect
              ? C.fromRect(value)
              : new C(value.x, value.y, value.width, value.height);
          } catch (error) {
            throwUnpolyfillable(type);
          } break;
        case &#039;DOMMatrix&#039;:
        case &#039;DOMMatrixReadOnly&#039;:
          C = globalThis[type];
          try {
            cloned = C.fromMatrix
              ? C.fromMatrix(value)
              : new C(value);
          } catch (error) {
            throwUnpolyfillable(type);
          } break;
        case &#039;AudioData&#039;:
        case &#039;VideoFrame&#039;:
          if (!isCallable(value.clone)) throwUnpolyfillable(type);
          try {
            cloned = value.clone();
          } catch (error) {
            throwUncloneable(type);
          } break;
        case &#039;CropTarget&#039;:
        case &#039;CryptoKey&#039;:
        case &#039;FileSystemDirectoryHandle&#039;:
        case &#039;FileSystemFileHandle&#039;:
        case &#039;FileSystemHandle&#039;:
        case &#039;GPUCompilationInfo&#039;:
        case &#039;GPUCompilationMessage&#039;:
        case &#039;ImageBitmap&#039;:
        case &#039;RTCCertificate&#039;:
        case &#039;WebAssembly.Module&#039;:
          throwUnpolyfillable(type);
          // break omitted
        default:
          throwUncloneable(type);
      }
  }

  mapSet(map, value, cloned);

  switch (type) {
    case &#039;Array&#039;:
    case &#039;Object&#039;:
      keys = objectKeys(value);
      for (i = 0, length = lengthOfArrayLike(keys); i &lt; length; i++) {
        key = keys[i];
        createProperty(cloned, key, structuredCloneInternal(value[key], map));
      } break;
    case &#039;Map&#039;:
      value.forEach(function (v, k) {
        mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
      });
      break;
    case &#039;Set&#039;:
      value.forEach(function (v) {
        setAdd(cloned, structuredCloneInternal(v, map));
      });
      break;
    case &#039;Error&#039;:
      createNonEnumerableProperty(cloned, &#039;message&#039;, structuredCloneInternal(value.message, map));
      if (hasOwn(value, &#039;cause&#039;)) {
        createNonEnumerableProperty(cloned, &#039;cause&#039;, structuredCloneInternal(value.cause, map));
      }
      if (name === &#039;AggregateError&#039;) {
        cloned.errors = structuredCloneInternal(value.errors, map);
      } else if (name === &#039;SuppressedError&#039;) {
        cloned.error = structuredCloneInternal(value.error, map);
        cloned.suppressed = structuredCloneInternal(value.suppressed, map);
      } // break omitted
    case &#039;DOMException&#039;:
      if (ERROR_STACK_INSTALLABLE) {
        createNonEnumerableProperty(cloned, &#039;stack&#039;, structuredCloneInternal(value.stack, map));
      }
  }

  return cloned;
};

var tryToTransfer = function (rawTransfer, map) {
  if (!isObject(rawTransfer)) throw new TypeError(&#039;Transfer option cannot be converted to a sequence&#039;);

  var transfer = [];

  iterate(rawTransfer, function (value) {
    push(transfer, anObject(value));
  });

  var i = 0;
  var length = lengthOfArrayLike(transfer);
  var buffers = new Set();
  var value, type, C, transferred, canvas, context;

  while (i &lt; length) {
    value = transfer[i++];

    type = classof(value);

    if (type === &#039;ArrayBuffer&#039; ? setHas(buffers, value) : mapHas(map, value)) {
      throw new DOMException(&#039;Duplicate transferable&#039;, DATA_CLONE_ERROR);
    }

    if (type === &#039;ArrayBuffer&#039;) {
      setAdd(buffers, value);
      continue;
    }

    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      transferred = nativeStructuredClone(value, { transfer: [value] });
    } else switch (type) {
      case &#039;ImageBitmap&#039;:
        C = globalThis.OffscreenCanvas;
        if (!isConstructor(C)) throwUnpolyfillable(type, TRANSFERRING);
        try {
          canvas = new C(value.width, value.height);
          context = canvas.getContext(&#039;bitmaprenderer&#039;);
          context.transferFromImageBitmap(value);
          transferred = canvas.transferToImageBitmap();
        } catch (error) { /* empty */ }
        break;
      case &#039;AudioData&#039;:
      case &#039;VideoFrame&#039;:
        if (!isCallable(value.clone) || !isCallable(value.close)) throwUnpolyfillable(type, TRANSFERRING);
        try {
          transferred = value.clone();
          value.close();
        } catch (error) { /* empty */ }
        break;
      case &#039;MediaSourceHandle&#039;:
      case &#039;MessagePort&#039;:
      case &#039;MIDIAccess&#039;:
      case &#039;OffscreenCanvas&#039;:
      case &#039;ReadableStream&#039;:
      case &#039;RTCDataChannel&#039;:
      case &#039;TransformStream&#039;:
      case &#039;WebTransportReceiveStream&#039;:
      case &#039;WebTransportSendStream&#039;:
      case &#039;WritableStream&#039;:
        throwUnpolyfillable(type, TRANSFERRING);
    }

    if (transferred === undefined) throw new DOMException(&#039;This object cannot be transferred: &#039; + type, DATA_CLONE_ERROR);

    mapSet(map, value, transferred);
  }

  return buffers;
};

var detachBuffers = function (buffers) {
  setIterate(buffers, function (buffer) {
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      nativeRestrictedStructuredClone(buffer, { transfer: [buffer] });
    } else if (isCallable(buffer.transfer)) {
      buffer.transfer();
    } else if (detachTransferable) {
      detachTransferable(buffer);
    } else {
      throwUnpolyfillable(&#039;ArrayBuffer&#039;, TRANSFERRING);
    }
  });
};

// `structuredClone` method
// https://html.spec.whatwg.org/multipage/structured-data.html#dom-structuredclone
$({ global: true, enumerable: true, sham: !PROPER_STRUCTURED_CLONE_TRANSFER, forced: FORCED_REPLACEMENT }, {
  structuredClone: function structuredClone(value /* , { transfer } */) {
    var options = validateArgumentsLength(arguments.length, 1) &gt; 1 &amp;&amp; !isNullOrUndefined(arguments[1]) ? anObject(arguments[1]) : undefined;
    var transfer = options ? options.transfer : undefined;
    var map, buffers;

    if (transfer !== undefined) {
      map = new Map();
      buffers = tryToTransfer(transfer, map);
    }

    var clone = structuredCloneInternal(value, map);

    // since of an issue with cloning views of transferred buffers, we a forced to detach them later
    // https://github.com/zloirock/core-js/issues/1265
    if (buffers) detachBuffers(buffers);

    return clone;
  }
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
