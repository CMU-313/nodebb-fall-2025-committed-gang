<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sanitize-html/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sanitize-html/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">957</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.88</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">const htmlparser = require(&#039;htmlparser2&#039;);
const escapeStringRegexp = require(&#039;escape-string-regexp&#039;);
const { isPlainObject } = require(&#039;is-plain-object&#039;);
const deepmerge = require(&#039;deepmerge&#039;);
const parseSrcset = require(&#039;parse-srcset&#039;);
const { parse: postcssParse } = require(&#039;postcss&#039;);
// Tags that can conceivably represent stand-alone media.
const mediaTags = [
  &#039;img&#039;, &#039;audio&#039;, &#039;video&#039;, &#039;picture&#039;, &#039;svg&#039;,
  &#039;object&#039;, &#039;map&#039;, &#039;iframe&#039;, &#039;embed&#039;
];
// Tags that are inherently vulnerable to being used in XSS attacks.
const vulnerableTags = [ &#039;script&#039;, &#039;style&#039; ];

function each(obj, cb) {
  if (obj) {
    Object.keys(obj).forEach(function (key) {
      cb(obj[key], key);
    });
  }
}

// Avoid false positives with .__proto__, .hasOwnProperty, etc.
function has(obj, key) {
  return ({}).hasOwnProperty.call(obj, key);
}

// Returns those elements of `a` for which `cb(a)` returns truthy
function filter(a, cb) {
  const n = [];
  each(a, function(v) {
    if (cb(v)) {
      n.push(v);
    }
  });
  return n;
}

function isEmptyObject(obj) {
  for (const key in obj) {
    if (has(obj, key)) {
      return false;
    }
  }
  return true;
}

function stringifySrcset(parsedSrcset) {
  return parsedSrcset.map(function(part) {
    if (!part.url) {
      throw new Error(&#039;URL missing&#039;);
    }

    return (
      part.url +
      (part.w ? ` ${part.w}w` : &#039;&#039;) +
      (part.h ? ` ${part.h}h` : &#039;&#039;) +
      (part.d ? ` ${part.d}x` : &#039;&#039;)
    );
  }).join(&#039;, &#039;);
}

module.exports = sanitizeHtml;

// A valid attribute name.
// We use a tolerant definition based on the set of strings defined by
// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .
// The characters accepted are ones which can be appended to the attribute
// name buffer without triggering a parse error:
//   * unexpected-equals-sign-before-attribute-name
//   * unexpected-null-character
//   * unexpected-character-in-attribute-name
// We exclude the empty string because it&#039;s impossible to get to the after
// attribute name state with an empty attribute name buffer.
const VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /&lt;=&gt;]+$/;

// Ignore the _recursing flag; it&#039;s there for recursive
// invocation as a guard against this exploit:
// https://github.com/fb55/htmlparser2/issues/105

function sanitizeHtml(html, options, _recursing) {
  if (html == null) {
    return &#039;&#039;;
  }
  if (typeof html === &#039;number&#039;) {
    html = html.toString();
  }

  let result = &#039;&#039;;
  // Used for hot swapping the result variable with an empty string in order to &quot;capture&quot; the text written to it.
  let tempResult = &#039;&#039;;

  function Frame(tag, attribs) {
    const that = this;
    this.tag = tag;
    this.attribs = attribs || {};
    this.tagPosition = result.length;
    this.text = &#039;&#039;; // Node inner text
    this.openingTagLength = 0;
    this.mediaChildren = [];

    this.updateParentNodeText = function() {
      if (stack.length) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.text += that.text;
      }
    };

    this.updateParentNodeMediaChildren = function() {
      if (stack.length &amp;&amp; mediaTags.includes(this.tag)) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.mediaChildren.push(this.tag);
      }
    };
  }

  options = Object.assign({}, sanitizeHtml.defaults, options);
  options.parser = Object.assign({}, htmlParserDefaults, options.parser);

  const tagAllowed = function (name) {
    return options.allowedTags === false || (options.allowedTags || []).indexOf(name) &gt; -1;
  };

  // vulnerableTags
  vulnerableTags.forEach(function (tag) {
    if (tagAllowed(tag) &amp;&amp; !options.allowVulnerableTags) {
      console.warn(`\n\n⚠️ Your \`allowedTags\` option includes, \`${tag}\`, which is inherently\nvulnerable to XSS attacks. Please remove it from \`allowedTags\`.\nOr, to disable this warning, add the \`allowVulnerableTags\` option\nand ensure you are accounting for this risk.\n\n`);
    }
  });

  // Tags that contain something other than HTML, or where discarding
  // the text when the tag is disallowed makes sense for other reasons.
  // If we are not allowing these tags, we should drop their content too.
  // For other tags you would drop the tag but keep its content.
  const nonTextTagsArray = options.nonTextTags || [
    &#039;script&#039;,
    &#039;style&#039;,
    &#039;textarea&#039;,
    &#039;option&#039;
  ];
  let allowedAttributesMap;
  let allowedAttributesGlobMap;
  if (options.allowedAttributes) {
    allowedAttributesMap = {};
    allowedAttributesGlobMap = {};
    each(options.allowedAttributes, function(attributes, tag) {
      allowedAttributesMap[tag] = [];
      const globRegex = [];
      attributes.forEach(function(obj) {
        if (typeof obj === &#039;string&#039; &amp;&amp; obj.indexOf(&#039;*&#039;) &gt;= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, &#039;.*&#039;));
        } else {
          allowedAttributesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedAttributesGlobMap[tag] = new RegExp(&#039;^(&#039; + globRegex.join(&#039;|&#039;) + &#039;)$&#039;);
      }
    });
  }
  const allowedClassesMap = {};
  const allowedClassesGlobMap = {};
  const allowedClassesRegexMap = {};
  each(options.allowedClasses, function(classes, tag) {
    // Implicitly allows the class attribute
    if (allowedAttributesMap) {
      if (!has(allowedAttributesMap, tag)) {
        allowedAttributesMap[tag] = [];
      }
      allowedAttributesMap[tag].push(&#039;class&#039;);
    }

    allowedClassesMap[tag] = classes;

    if (Array.isArray(classes)) {
      const globRegex = [];
      allowedClassesMap[tag] = [];
      allowedClassesRegexMap[tag] = [];
      classes.forEach(function(obj) {
        if (typeof obj === &#039;string&#039; &amp;&amp; obj.indexOf(&#039;*&#039;) &gt;= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, &#039;.*&#039;));
        } else if (obj instanceof RegExp) {
          allowedClassesRegexMap[tag].push(obj);
        } else {
          allowedClassesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedClassesGlobMap[tag] = new RegExp(&#039;^(&#039; + globRegex.join(&#039;|&#039;) + &#039;)$&#039;);
      }
    }
  });

  const transformTagsMap = {};
  let transformTagsAll;
  each(options.transformTags, function(transform, tag) {
    let transFun;
    if (typeof transform === &#039;function&#039;) {
      transFun = transform;
    } else if (typeof transform === &#039;string&#039;) {
      transFun = sanitizeHtml.simpleTransform(transform);
    }
    if (tag === &#039;*&#039;) {
      transformTagsAll = transFun;
    } else {
      transformTagsMap[tag] = transFun;
    }
  });

  let depth;
  let stack;
  let skipMap;
  let transformMap;
  let skipText;
  let skipTextDepth;
  let addedText = false;

  initializeState();

  const parser = new htmlparser.Parser({
    onopentag: function(name, attribs) {
      if (options.onOpenTag) {
        options.onOpenTag(name, attribs);
      }

      // If `enforceHtmlBoundary` is `true` and this has found the opening
      // `html` tag, reset the state.
      if (options.enforceHtmlBoundary &amp;&amp; name === &#039;html&#039;) {
        initializeState();
      }

      if (skipText) {
        skipTextDepth++;
        return;
      }
      const frame = new Frame(name, attribs);
      stack.push(frame);

      let skip = false;
      const hasText = !!frame.text;
      let transformedTag;
      if (has(transformTagsMap, name)) {
        transformedTag = transformTagsMap[name](name, attribs);

        frame.attribs = attribs = transformedTag.attribs;

        if (transformedTag.text !== undefined) {
          frame.innerText = transformedTag.text;
        }

        if (name !== transformedTag.tagName) {
          frame.name = name = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }
      if (transformTagsAll) {
        transformedTag = transformTagsAll(name, attribs);

        frame.attribs = attribs = transformedTag.attribs;
        if (name !== transformedTag.tagName) {
          frame.name = name = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }

      if (!tagAllowed(name) || (options.disallowedTagsMode === &#039;recursiveEscape&#039; &amp;&amp; !isEmptyObject(skipMap)) || (options.nestingLimit != null &amp;&amp; depth &gt;= options.nestingLimit)) {
        skip = true;
        skipMap[depth] = true;
        if (options.disallowedTagsMode === &#039;discard&#039; || options.disallowedTagsMode === &#039;completelyDiscard&#039;) {
          if (nonTextTagsArray.indexOf(name) !== -1) {
            skipText = true;
            skipTextDepth = 1;
          }
        }
      }
      depth++;
      if (skip) {
        if (options.disallowedTagsMode === &#039;discard&#039; || options.disallowedTagsMode === &#039;completelyDiscard&#039;) {
          // We want the contents but not this tag
          if (frame.innerText &amp;&amp; !hasText) {
            const escaped = escapeHtml(frame.innerText);
            if (options.textFilter) {
              result += options.textFilter(escaped, name);
            } else {
              result += escaped;
            }
            addedText = true;
          }
          return;
        }
        tempResult = result;
        result = &#039;&#039;;
      }
      result += &#039;&lt;&#039; + name;

      if (name === &#039;script&#039;) {
        if (options.allowedScriptHostnames || options.allowedScriptDomains) {
          frame.innerText = &#039;&#039;;
        }
      }

      const isBeingEscaped = skip &amp;&amp; (options.disallowedTagsMode === &#039;escape&#039; || options.disallowedTagsMode === &#039;recursiveEscape&#039;);
      const shouldPreserveEscapedAttributes = isBeingEscaped &amp;&amp; options.preserveEscapedAttributes;

      if (shouldPreserveEscapedAttributes) {
        each(attribs, function(value, a) {
          result += &#039; &#039; + a + &#039;=&quot;&#039; + escapeHtml((value || &#039;&#039;), true) + &#039;&quot;&#039;;
        });
      } else if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap[&#039;*&#039;]) {
        each(attribs, function(value, a) {
          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
            // This prevents part of an attribute name in the output from being
            // interpreted as the end of an attribute, or end of a tag.
            delete frame.attribs[a];
            return;
          }
          // If the value is empty, check if the attribute is in the allowedEmptyAttributes array.
          // If it is not in the allowedEmptyAttributes array, and it is a known non-boolean attribute, delete it
          // List taken from https://html.spec.whatwg.org/multipage/indices.html#attributes-3
          if (value === &#039;&#039; &amp;&amp; (!options.allowedEmptyAttributes.includes(a)) &amp;&amp;
            (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes(&#039;*&#039;))) {
            delete frame.attribs[a];
            return;
          }
          // check allowedAttributesMap for the element and attribute and modify the value
          // as necessary if there are specific values defined.
          let passedAllowedAttributesMapCheck = false;
          if (!allowedAttributesMap ||
            (has(allowedAttributesMap, name) &amp;&amp; allowedAttributesMap[name].indexOf(a) !== -1) ||
            (allowedAttributesMap[&#039;*&#039;] &amp;&amp; allowedAttributesMap[&#039;*&#039;].indexOf(a) !== -1) ||
            (has(allowedAttributesGlobMap, name) &amp;&amp; allowedAttributesGlobMap[name].test(a)) ||
            (allowedAttributesGlobMap[&#039;*&#039;] &amp;&amp; allowedAttributesGlobMap[&#039;*&#039;].test(a))) {
            passedAllowedAttributesMapCheck = true;
          } else if (allowedAttributesMap &amp;&amp; allowedAttributesMap[name]) {
            for (const o of allowedAttributesMap[name]) {
              if (isPlainObject(o) &amp;&amp; o.name &amp;&amp; (o.name === a)) {
                passedAllowedAttributesMapCheck = true;
                let newValue = &#039;&#039;;
                if (o.multiple === true) {
                  // verify the values that are allowed
                  const splitStrArray = value.split(&#039; &#039;);
                  for (const s of splitStrArray) {
                    if (o.values.indexOf(s) !== -1) {
                      if (newValue === &#039;&#039;) {
                        newValue = s;
                      } else {
                        newValue += &#039; &#039; + s;
                      }
                    }
                  }
                } else if (o.values.indexOf(value) &gt;= 0) {
                  // verified an allowed value matches the entire attribute value
                  newValue = value;
                }
                value = newValue;
              }
            }
          }
          if (passedAllowedAttributesMapCheck) {
            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
              if (naughtyHref(name, value)) {
                delete frame.attribs[a];
                return;
              }
            }

            if (name === &#039;script&#039; &amp;&amp; a === &#039;src&#039;) {

              let allowed = true;

              try {
                const parsed = parseUrl(value);

                if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {
                    return hostname === parsed.url.hostname;
                  });
                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                allowed = false;
              }

              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }

            if (name === &#039;iframe&#039; &amp;&amp; a === &#039;src&#039;) {
              let allowed = true;
              try {
                const parsed = parseUrl(value);

                if (parsed.isRelativeUrl) {
                  // default value of allowIframeRelativeUrls is true
                  // unless allowedIframeHostnames or allowedIframeDomains specified
                  allowed = has(options, &#039;allowIframeRelativeUrls&#039;)
                    ? options.allowIframeRelativeUrls
                    : (!options.allowedIframeHostnames &amp;&amp; !options.allowedIframeDomains);
                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {
                    return hostname === parsed.url.hostname;
                  });
                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                // Unparseable iframe src
                allowed = false;
              }
              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === &#039;srcset&#039;) {
              try {
                let parsed = parseSrcset(value);
                parsed.forEach(function(value) {
                  if (naughtyHref(&#039;srcset&#039;, value.url)) {
                    value.evil = true;
                  }
                });
                parsed = filter(parsed, function(v) {
                  return !v.evil;
                });
                if (!parsed.length) {
                  delete frame.attribs[a];
                  return;
                } else {
                  value = stringifySrcset(filter(parsed, function(v) {
                    return !v.evil;
                  }));
                  frame.attribs[a] = value;
                }
              } catch (e) {
                // Unparseable srcset
                delete frame.attribs[a];
                return;
              }
            }
            if (a === &#039;class&#039;) {
              const allowedSpecificClasses = allowedClassesMap[name];
              const allowedWildcardClasses = allowedClassesMap[&#039;*&#039;];
              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
              const allowedWildcardClassesRegex = allowedClassesRegexMap[&#039;*&#039;];
              const allowedWildcardClassesGlob = allowedClassesGlobMap[&#039;*&#039;];
              const allowedClassesGlobs = [
                allowedSpecificClassesGlob,
                allowedWildcardClassesGlob
              ]
                .concat(allowedSpecificClassesRegex, allowedWildcardClassesRegex)
                .filter(function (t) {
                  return t;
                });
              if (allowedSpecificClasses &amp;&amp; allowedWildcardClasses) {
                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
              } else {
                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
              }
              if (!value.length) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === &#039;style&#039;) {
              if (options.parseStyleAttributes) {
                try {
                  const abstractSyntaxTree = postcssParse(name + &#039; {&#039; + value + &#039;}&#039;, { map: false });
                  const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);

                  value = stringifyStyleAttributes(filteredAST);

                  if (value.length === 0) {
                    delete frame.attribs[a];
                    return;
                  }
                } catch (e) {
                  if (typeof window !== &#039;undefined&#039;) {
                    console.warn(&#039;Failed to parse &quot;&#039; + name + &#039; {&#039; + value + &#039;}&#039; + &#039;&quot;, If you\&#039;re running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547&#039;);
                  }
                  delete frame.attribs[a];
                  return;
                }
              } else if (options.allowedStyles) {
                throw new Error(&#039;allowedStyles option cannot be used together with parseStyleAttributes: false.&#039;);
              }
            }
            result += &#039; &#039; + a;
            if (value &amp;&amp; value.length) {
              result += &#039;=&quot;&#039; + escapeHtml(value, true) + &#039;&quot;&#039;;
            } else if (options.allowedEmptyAttributes.includes(a)) {
              result += &#039;=&quot;&quot;&#039;;
            }
          } else {
            delete frame.attribs[a];
          }
        });
      }
      if (options.selfClosing.indexOf(name) !== -1) {
        result += &#039; /&gt;&#039;;
      } else {
        result += &#039;&gt;&#039;;
        if (frame.innerText &amp;&amp; !hasText &amp;&amp; !options.textFilter) {
          result += escapeHtml(frame.innerText);
          addedText = true;
        }
      }
      if (skip) {
        result = tempResult + escapeHtml(result);
        tempResult = &#039;&#039;;
      }
      frame.openingTagLength = result.length - frame.tagPosition;
    },
    ontext: function(text) {
      if (skipText) {
        return;
      }
      const lastFrame = stack[stack.length - 1];
      let tag;

      if (lastFrame) {
        tag = lastFrame.tag;
        // If inner text was set by transform function then let&#039;s use it
        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;
      }

      if (options.disallowedTagsMode === &#039;completelyDiscard&#039; &amp;&amp; !tagAllowed(tag)) {
        text = &#039;&#039;;
      } else if ((options.disallowedTagsMode === &#039;discard&#039; || options.disallowedTagsMode === &#039;completelyDiscard&#039;) &amp;&amp; ((tag === &#039;script&#039;) || (tag === &#039;style&#039;))) {
        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing
        // script tags is, by definition, game over for XSS protection, so if that&#039;s
        // your concern, don&#039;t allow them. The same is essentially true for style tags
        // which have their own collection of XSS vectors.
        result += text;
      } else if (!addedText) {
        const escaped = escapeHtml(text, false);
        if (options.textFilter) {
          result += options.textFilter(escaped, tag);
        } else {
          result += escaped;
        }
      }
      if (stack.length) {
        const frame = stack[stack.length - 1];
        frame.text += text;
      }
    },
    onclosetag: function(name, isImplied) {
      if (options.onCloseTag) {
        options.onCloseTag(name, isImplied);
      }

      if (skipText) {
        skipTextDepth--;
        if (!skipTextDepth) {
          skipText = false;
        } else {
          return;
        }
      }

      const frame = stack.pop();
      if (!frame) {
        // Do not crash on bad markup
        return;
      }

      if (frame.tag !== name) {
        // Another case of bad markup.
        // Push to stack, so that it will be used in future closing tags.
        stack.push(frame);
        return;
      }

      skipText = options.enforceHtmlBoundary ? name === &#039;html&#039; : false;
      depth--;
      const skip = skipMap[depth];
      if (skip) {
        delete skipMap[depth];
        if (options.disallowedTagsMode === &#039;discard&#039; || options.disallowedTagsMode === &#039;completelyDiscard&#039;) {
          frame.updateParentNodeText();
          return;
        }
        tempResult = result;
        result = &#039;&#039;;
      }

      if (transformMap[depth]) {
        name = transformMap[depth];
        delete transformMap[depth];
      }

      if (options.exclusiveFilter) {
        const filterResult = options.exclusiveFilter(frame);
        if (filterResult === &#039;excludeTag&#039;) {
          if (skip) {
            // no longer escaping the tag since it&#039;s not added at all
            result = tempResult;
            tempResult = &#039;&#039;;
          }
          // remove the opening tag from the result
          result = result.substring(0, frame.tagPosition) + result.substring(frame.tagPosition + frame.openingTagLength);
          return;
        } else if (filterResult) {
          result = result.substring(0, frame.tagPosition);
          return;
        }
      }

      frame.updateParentNodeMediaChildren();
      frame.updateParentNodeText();

      if (
        // Already output /&gt;
        options.selfClosing.indexOf(name) !== -1 ||
        // Escaped tag, closing tag is implied
        (isImplied &amp;&amp; !tagAllowed(name) &amp;&amp; [ &#039;escape&#039;, &#039;recursiveEscape&#039; ].indexOf(options.disallowedTagsMode) &gt;= 0)
      ) {
        if (skip) {
          result = tempResult;
          tempResult = &#039;&#039;;
        }
        return;
      }

      result += &#039;&lt;/&#039; + name + &#039;&gt;&#039;;
      if (skip) {
        result = tempResult + escapeHtml(result);
        tempResult = &#039;&#039;;
      }
      addedText = false;
    }
  }, options.parser);
  parser.write(html);
  parser.end();

  return result;

  function initializeState() {
    result = &#039;&#039;;
    depth = 0;
    stack = [];
    skipMap = {};
    transformMap = {};
    skipText = false;
    skipTextDepth = 0;
  }

  function escapeHtml(s, quote) {
    if (typeof (s) !== &#039;string&#039;) {
      s = s + &#039;&#039;;
    }
    if (options.parser.decodeEntities) {
      s = s.replace(/&amp;/g, &#039;&amp;amp;&#039;).replace(/&lt;/g, &#039;&amp;lt;&#039;).replace(/&gt;/g, &#039;&amp;gt;&#039;);
      if (quote) {
        s = s.replace(/&quot;/g, &#039;&amp;quot;&#039;);
      }
    }
    // TODO: this is inadequate because it will pass `&amp;0;`. This approach
    // will not work, each &amp; must be considered with regard to whether it
    // is followed by a 100% syntactically valid entity or not, and escaped
    // if it is not. If this bothers you, don&#039;t set parser.decodeEntities
    // to false. (The default is true.)
    s = s.replace(/&amp;(?![a-zA-Z0-9#]{1,20};)/g, &#039;&amp;amp;&#039;) // Match ampersands not part of existing HTML entity
      .replace(/&lt;/g, &#039;&amp;lt;&#039;)
      .replace(/&gt;/g, &#039;&amp;gt;&#039;);
    if (quote) {
      s = s.replace(/&quot;/g, &#039;&amp;quot;&#039;);
    }
    return s;
  }

  function naughtyHref(name, href) {
    // Browsers ignore character codes of 32 (space) and below in a surprising
    // number of situations. Start reading here:
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab
    // eslint-disable-next-line no-control-regex
    href = href.replace(/[\x00-\x20]+/g, &#039;&#039;);
    // Clobber any comments in URLs, which the browser might
    // interpret inside an XML data island, allowing
    // a javascript: URL to be snuck through
    while (true) {
      const firstIndex = href.indexOf(&#039;&lt;!--&#039;);
      if (firstIndex === -1) {
        break;
      }
      const lastIndex = href.indexOf(&#039;--&gt;&#039;, firstIndex + 4);
      if (lastIndex === -1) {
        break;
      }
      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
    }
    // Case insensitive so we don&#039;t get faked out by JAVASCRIPT #1
    // Allow more characters after the first so we don&#039;t get faked
    // out by certain schemes browsers accept
    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!matches) {
      // Protocol-relative URL starting with any combination of &#039;/&#039; and &#039;\&#039;
      if (href.match(/^[/\\]{2}/)) {
        return !options.allowProtocolRelative;
      }

      // No scheme
      return false;
    }
    const scheme = matches[1].toLowerCase();

    if (has(options.allowedSchemesByTag, name)) {
      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
    }

    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
  }

  function parseUrl(value) {
    value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, &#039;$1//&#039;);
    if (value.startsWith(&#039;relative:&#039;)) {
      // An attempt to exploit our workaround for base URLs being
      // mandatory for relative URL validation in the WHATWG
      // URL parser, reject it
      throw new Error(&#039;relative: exploit attempt&#039;);
    }
    // naughtyHref is in charge of whether protocol relative URLs
    // are cool. Here we are concerned just with allowed hostnames and
    // whether to allow relative URLs.
    //
    // Build a placeholder &quot;base URL&quot; against which any reasonable
    // relative URL may be parsed successfully
    let base = &#039;relative://relative-site&#039;;
    for (let i = 0; (i &lt; 100); i++) {
      base += `/${i}`;
    }

    const parsed = new URL(value, base);

    const isRelativeUrl = parsed &amp;&amp; parsed.hostname === &#039;relative-site&#039; &amp;&amp; parsed.protocol === &#039;relative:&#039;;
    return {
      isRelativeUrl,
      url: parsed
    };
  }
  /**
   * Filters user input css properties by allowlisted regex attributes.
   * Modifies the abstractSyntaxTree object.
   *
   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.
   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: &#039;color&#039;, value: &#039;red&#039; }.
   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).
   * @return {object}                    - The modified tree.
   */
  function filterCss(abstractSyntaxTree, allowedStyles) {
    if (!allowedStyles) {
      return abstractSyntaxTree;
    }

    const astRules = abstractSyntaxTree.nodes[0];
    let selectedRule;

    // Merge global and tag-specific styles into new AST.
    if (allowedStyles[astRules.selector] &amp;&amp; allowedStyles[&#039;*&#039;]) {
      selectedRule = deepmerge(
        allowedStyles[astRules.selector],
        allowedStyles[&#039;*&#039;]
      );
    } else {
      selectedRule = allowedStyles[astRules.selector] || allowedStyles[&#039;*&#039;];
    }

    if (selectedRule) {
      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
    }

    return abstractSyntaxTree;
  }

  /**
   * Extracts the style attributes from an AbstractSyntaxTree and formats those
   * values in the inline style attribute format.
   *
   * @param  {AbstractSyntaxTree} filteredAST
   * @return {string}             - Example: &quot;color:yellow;text-align:center !important;font-family:helvetica;&quot;
   */
  function stringifyStyleAttributes(filteredAST) {
    return filteredAST.nodes[0].nodes
      .reduce(function(extractedAttributes, attrObject) {
        extractedAttributes.push(
          `${attrObject.prop}:${attrObject.value}${attrObject.important ? &#039; !important&#039; : &#039;&#039;}`
        );
        return extractedAttributes;
      }, [])
      .join(&#039;;&#039;);
  }

  /**
    * Filters the existing attributes for the given property. Discards any attributes
    * which don&#039;t match the allowlist.
    *
    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }
    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.
    * @param  {object} attributeObject          - Object representing the current css property.
    * @property {string} attributeObject.type   - Typically &#039;declaration&#039;.
    * @property {string} attributeObject.prop   - The CSS property, i.e &#039;color&#039;.
    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e &#039;red&#039;.
    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects
    */
  function filterDeclarations(selectedRule) {
    return function (allowedDeclarationsList, attributeObject) {
      // If this property is allowlisted...
      if (has(selectedRule, attributeObject.prop)) {
        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
          return regularExpression.test(attributeObject.value);
        });

        if (matchesRegex) {
          allowedDeclarationsList.push(attributeObject);
        }
      }
      return allowedDeclarationsList;
    };
  }

  function filterClasses(classes, allowed, allowedGlobs) {
    if (!allowed) {
      // The class attribute is allowed without filtering on this tag
      return classes;
    }
    classes = classes.split(/\s+/);
    return classes.filter(function(clss) {
      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
        return glob.test(clss);
      });
    }).join(&#039; &#039;);
  }
}

// Defaults are accessible to you so that you can use them as a starting point
// programmatically if you wish

const htmlParserDefaults = {
  decodeEntities: true
};
sanitizeHtml.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    &#039;address&#039;, &#039;article&#039;, &#039;aside&#039;, &#039;footer&#039;, &#039;header&#039;,
    &#039;h1&#039;, &#039;h2&#039;, &#039;h3&#039;, &#039;h4&#039;, &#039;h5&#039;, &#039;h6&#039;, &#039;hgroup&#039;,
    &#039;main&#039;, &#039;nav&#039;, &#039;section&#039;,
    // Text content
    &#039;blockquote&#039;, &#039;dd&#039;, &#039;div&#039;, &#039;dl&#039;, &#039;dt&#039;, &#039;figcaption&#039;, &#039;figure&#039;,
    &#039;hr&#039;, &#039;li&#039;, &#039;menu&#039;, &#039;ol&#039;, &#039;p&#039;, &#039;pre&#039;, &#039;ul&#039;,
    // Inline text semantics
    &#039;a&#039;, &#039;abbr&#039;, &#039;b&#039;, &#039;bdi&#039;, &#039;bdo&#039;, &#039;br&#039;, &#039;cite&#039;, &#039;code&#039;, &#039;data&#039;, &#039;dfn&#039;,
    &#039;em&#039;, &#039;i&#039;, &#039;kbd&#039;, &#039;mark&#039;, &#039;q&#039;,
    &#039;rb&#039;, &#039;rp&#039;, &#039;rt&#039;, &#039;rtc&#039;, &#039;ruby&#039;,
    &#039;s&#039;, &#039;samp&#039;, &#039;small&#039;, &#039;span&#039;, &#039;strong&#039;, &#039;sub&#039;, &#039;sup&#039;, &#039;time&#039;, &#039;u&#039;, &#039;var&#039;, &#039;wbr&#039;,
    // Table content
    &#039;caption&#039;, &#039;col&#039;, &#039;colgroup&#039;, &#039;table&#039;, &#039;tbody&#039;, &#039;td&#039;, &#039;tfoot&#039;, &#039;th&#039;,
    &#039;thead&#039;, &#039;tr&#039;
  ],
  // Tags that cannot be boolean
  nonBooleanAttributes: [
    &#039;abbr&#039;, &#039;accept&#039;, &#039;accept-charset&#039;, &#039;accesskey&#039;, &#039;action&#039;,
    &#039;allow&#039;, &#039;alt&#039;, &#039;as&#039;, &#039;autocapitalize&#039;, &#039;autocomplete&#039;,
    &#039;blocking&#039;, &#039;charset&#039;, &#039;cite&#039;, &#039;class&#039;, &#039;color&#039;, &#039;cols&#039;,
    &#039;colspan&#039;, &#039;content&#039;, &#039;contenteditable&#039;, &#039;coords&#039;, &#039;crossorigin&#039;,
    &#039;data&#039;, &#039;datetime&#039;, &#039;decoding&#039;, &#039;dir&#039;, &#039;dirname&#039;, &#039;download&#039;,
    &#039;draggable&#039;, &#039;enctype&#039;, &#039;enterkeyhint&#039;, &#039;fetchpriority&#039;, &#039;for&#039;,
    &#039;form&#039;, &#039;formaction&#039;, &#039;formenctype&#039;, &#039;formmethod&#039;, &#039;formtarget&#039;,
    &#039;headers&#039;, &#039;height&#039;, &#039;hidden&#039;, &#039;high&#039;, &#039;href&#039;, &#039;hreflang&#039;,
    &#039;http-equiv&#039;, &#039;id&#039;, &#039;imagesizes&#039;, &#039;imagesrcset&#039;, &#039;inputmode&#039;,
    &#039;integrity&#039;, &#039;is&#039;, &#039;itemid&#039;, &#039;itemprop&#039;, &#039;itemref&#039;, &#039;itemtype&#039;,
    &#039;kind&#039;, &#039;label&#039;, &#039;lang&#039;, &#039;list&#039;, &#039;loading&#039;, &#039;low&#039;, &#039;max&#039;,
    &#039;maxlength&#039;, &#039;media&#039;, &#039;method&#039;, &#039;min&#039;, &#039;minlength&#039;, &#039;name&#039;,
    &#039;nonce&#039;, &#039;optimum&#039;, &#039;pattern&#039;, &#039;ping&#039;, &#039;placeholder&#039;, &#039;popover&#039;,
    &#039;popovertarget&#039;, &#039;popovertargetaction&#039;, &#039;poster&#039;, &#039;preload&#039;,
    &#039;referrerpolicy&#039;, &#039;rel&#039;, &#039;rows&#039;, &#039;rowspan&#039;, &#039;sandbox&#039;, &#039;scope&#039;,
    &#039;shape&#039;, &#039;size&#039;, &#039;sizes&#039;, &#039;slot&#039;, &#039;span&#039;, &#039;spellcheck&#039;, &#039;src&#039;,
    &#039;srcdoc&#039;, &#039;srclang&#039;, &#039;srcset&#039;, &#039;start&#039;, &#039;step&#039;, &#039;style&#039;,
    &#039;tabindex&#039;, &#039;target&#039;, &#039;title&#039;, &#039;translate&#039;, &#039;type&#039;, &#039;usemap&#039;,
    &#039;value&#039;, &#039;width&#039;, &#039;wrap&#039;,
    // Event handlers
    &#039;onauxclick&#039;, &#039;onafterprint&#039;, &#039;onbeforematch&#039;, &#039;onbeforeprint&#039;,
    &#039;onbeforeunload&#039;, &#039;onbeforetoggle&#039;, &#039;onblur&#039;, &#039;oncancel&#039;,
    &#039;oncanplay&#039;, &#039;oncanplaythrough&#039;, &#039;onchange&#039;, &#039;onclick&#039;, &#039;onclose&#039;,
    &#039;oncontextlost&#039;, &#039;oncontextmenu&#039;, &#039;oncontextrestored&#039;, &#039;oncopy&#039;,
    &#039;oncuechange&#039;, &#039;oncut&#039;, &#039;ondblclick&#039;, &#039;ondrag&#039;, &#039;ondragend&#039;,
    &#039;ondragenter&#039;, &#039;ondragleave&#039;, &#039;ondragover&#039;, &#039;ondragstart&#039;,
    &#039;ondrop&#039;, &#039;ondurationchange&#039;, &#039;onemptied&#039;, &#039;onended&#039;,
    &#039;onerror&#039;, &#039;onfocus&#039;, &#039;onformdata&#039;, &#039;onhashchange&#039;, &#039;oninput&#039;,
    &#039;oninvalid&#039;, &#039;onkeydown&#039;, &#039;onkeypress&#039;, &#039;onkeyup&#039;,
    &#039;onlanguagechange&#039;, &#039;onload&#039;, &#039;onloadeddata&#039;, &#039;onloadedmetadata&#039;,
    &#039;onloadstart&#039;, &#039;onmessage&#039;, &#039;onmessageerror&#039;, &#039;onmousedown&#039;,
    &#039;onmouseenter&#039;, &#039;onmouseleave&#039;, &#039;onmousemove&#039;, &#039;onmouseout&#039;,
    &#039;onmouseover&#039;, &#039;onmouseup&#039;, &#039;onoffline&#039;, &#039;ononline&#039;, &#039;onpagehide&#039;,
    &#039;onpageshow&#039;, &#039;onpaste&#039;, &#039;onpause&#039;, &#039;onplay&#039;, &#039;onplaying&#039;,
    &#039;onpopstate&#039;, &#039;onprogress&#039;, &#039;onratechange&#039;, &#039;onreset&#039;, &#039;onresize&#039;,
    &#039;onrejectionhandled&#039;, &#039;onscroll&#039;, &#039;onscrollend&#039;,
    &#039;onsecuritypolicyviolation&#039;, &#039;onseeked&#039;, &#039;onseeking&#039;, &#039;onselect&#039;,
    &#039;onslotchange&#039;, &#039;onstalled&#039;, &#039;onstorage&#039;, &#039;onsubmit&#039;, &#039;onsuspend&#039;,
    &#039;ontimeupdate&#039;, &#039;ontoggle&#039;, &#039;onunhandledrejection&#039;, &#039;onunload&#039;,
    &#039;onvolumechange&#039;, &#039;onwaiting&#039;, &#039;onwheel&#039;
  ],
  disallowedTagsMode: &#039;discard&#039;,
  allowedAttributes: {
    a: [ &#039;href&#039;, &#039;name&#039;, &#039;target&#039; ],
    // We don&#039;t currently allow img itself by default, but
    // these attributes would make sense if we did.
    img: [ &#039;src&#039;, &#039;srcset&#039;, &#039;alt&#039;, &#039;title&#039;, &#039;width&#039;, &#039;height&#039;, &#039;loading&#039; ]
  },
  allowedEmptyAttributes: [
    &#039;alt&#039;
  ],
  // Lots of these won&#039;t come up by default because we don&#039;t allow them
  selfClosing: [ &#039;img&#039;, &#039;br&#039;, &#039;hr&#039;, &#039;area&#039;, &#039;base&#039;, &#039;basefont&#039;, &#039;input&#039;, &#039;link&#039;, &#039;meta&#039; ],
  // URL schemes we permit
  allowedSchemes: [ &#039;http&#039;, &#039;https&#039;, &#039;ftp&#039;, &#039;mailto&#039;, &#039;tel&#039; ],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: [ &#039;href&#039;, &#039;src&#039;, &#039;cite&#039; ],
  allowProtocolRelative: true,
  enforceHtmlBoundary: false,
  parseStyleAttributes: true,
  preserveEscapedAttributes: false
};

sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
  merge = (merge === undefined) ? true : merge;
  newAttribs = newAttribs || {};

  return function(tagName, attribs) {
    let attrib;
    if (merge) {
      for (attrib in newAttribs) {
        attribs[attrib] = newAttribs[attrib];
      }
    } else {
      attribs = newAttribs;
    }

    return {
      tagName: newTagName,
      attribs: attribs
    };
  };
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
