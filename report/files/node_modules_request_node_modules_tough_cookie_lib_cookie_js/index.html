<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/request/node_modules/tough-cookie/lib/cookie.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/request/node_modules/tough-cookie/lib/cookie.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1483</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">124.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.73</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
&#039;use strict&#039;;
var net = require(&#039;net&#039;);
var urlParse = require(&#039;url&#039;).parse;
var util = require(&#039;util&#039;);
var pubsuffix = require(&#039;./pubsuffix-psl&#039;);
var Store = require(&#039;./store&#039;).Store;
var MemoryCookieStore = require(&#039;./memstore&#039;).MemoryCookieStore;
var pathMatch = require(&#039;./pathMatch&#039;).pathMatch;
var VERSION = require(&#039;./version&#039;);

var punycode;
try {
  punycode = require(&#039;punycode&#039;);
} catch(e) {
  console.warn(&quot;tough-cookie: can&#039;t load punycode; won&#039;t use punycode for domain normalization&quot;);
}

// From RFC6265 S4.1.1
// note that it excludes \x3B &quot;;&quot;
var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;

var CONTROL_CHARS = /[\x00-\x1F]/;

// From Chromium // &#039;\r&#039;, &#039;\n&#039; and &#039;\0&#039; should be treated as a terminator in
// the &quot;relaxed&quot; mode, see:
// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
var TERMINATORS = [&#039;\n&#039;, &#039;\r&#039;, &#039;\0&#039;];

// RFC6265 S4.1.1 defines path value as &#039;any CHAR except CTLs or &quot;;&quot;&#039;
// Note &#039;;&#039; is \x3B
var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

// date-time parsing constants (RFC6265 S5.1.1)

var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

var MONTH_TO_NUM = {
  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
};
var NUM_TO_MONTH = [
  &#039;Jan&#039;,&#039;Feb&#039;,&#039;Mar&#039;,&#039;Apr&#039;,&#039;May&#039;,&#039;Jun&#039;,&#039;Jul&#039;,&#039;Aug&#039;,&#039;Sep&#039;,&#039;Oct&#039;,&#039;Nov&#039;,&#039;Dec&#039;
];
var NUM_TO_DAY = [
  &#039;Sun&#039;,&#039;Mon&#039;,&#039;Tue&#039;,&#039;Wed&#039;,&#039;Thu&#039;,&#039;Fri&#039;,&#039;Sat&#039;
];

var MAX_TIME = 2147483647000; // 31-bit max
var MIN_TIME = 0; // 31-bit min

/*
 * Parses a Natural number (i.e., non-negative integer) with either the
 *    &lt;min&gt;*&lt;max&gt;DIGIT ( non-digit *OCTET )
 * or
 *    &lt;min&gt;*&lt;max&gt;DIGIT
 * grammar (RFC6265 S5.1.1).
 *
 * The &quot;trailingOK&quot; boolean controls if the grammar accepts a
 * &quot;( non-digit *OCTET )&quot; trailer.
 */
function parseDigits(token, minDigits, maxDigits, trailingOK) {
  var count = 0;
  while (count &lt; token.length) {
    var c = token.charCodeAt(count);
    // &quot;non-digit = %x00-2F / %x3A-FF&quot;
    if (c &lt;= 0x2F || c &gt;= 0x3A) {
      break;
    }
    count++;
  }

  // constrain to a minimum and maximum number of digits.
  if (count &lt; minDigits || count &gt; maxDigits) {
    return null;
  }

  if (!trailingOK &amp;&amp; count != token.length) {
    return null;
  }

  return parseInt(token.substr(0,count), 10);
}

function parseTime(token) {
  var parts = token.split(&#039;:&#039;);
  var result = [0,0,0];

  /* RF6256 S5.1.1:
   *      time            = hms-time ( non-digit *OCTET )
   *      hms-time        = time-field &quot;:&quot; time-field &quot;:&quot; time-field
   *      time-field      = 1*2DIGIT
   */

  if (parts.length !== 3) {
    return null;
  }

  for (var i = 0; i &lt; 3; i++) {
    // &quot;time-field&quot; must be strictly &quot;1*2DIGIT&quot;, HOWEVER, &quot;hms-time&quot; can be
    // followed by &quot;( non-digit *OCTET )&quot; so therefore the last time-field can
    // have a trailer
    var trailingOK = (i == 2);
    var num = parseDigits(parts[i], 1, 2, trailingOK);
    if (num === null) {
      return null;
    }
    result[i] = num;
  }

  return result;
}

function parseMonth(token) {
  token = String(token).substr(0,3).toLowerCase();
  var num = MONTH_TO_NUM[token];
  return num &gt;= 0 ? num : null;
}

/*
 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
 */
function parseDate(str) {
  if (!str) {
    return;
  }

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  var tokens = str.split(DATE_DELIM);
  if (!tokens) {
    return;
  }

  var hour = null;
  var minute = null;
  var second = null;
  var dayOfMonth = null;
  var month = null;
  var year = null;

  for (var i=0; i&lt;tokens.length; i++) {
    var token = tokens[i].trim();
    if (!token.length) {
      continue;
    }

    var result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (second === null) {
      result = parseTime(token);
      if (result) {
        hour = result[0];
        minute = result[1];
        second = result[2];
        continue;
      }
    }

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (dayOfMonth === null) {
      // &quot;day-of-month = 1*2DIGIT ( non-digit *OCTET )&quot;
      result = parseDigits(token, 1, 2, true);
      if (result !== null) {
        dayOfMonth = result;
        continue;
      }
    }

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (month === null) {
      result = parseMonth(token);
      if (result !== null) {
        month = result;
        continue;
      }
    }

    /* 2.4. If the found-year flag is not set and the date-token matches the
     * year production, set the found-year flag and set the year-value to the
     * number denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (year === null) {
      // &quot;year = 2*4DIGIT ( non-digit *OCTET )&quot;
      result = parseDigits(token, 2, 4, true);
      if (result !== null) {
        year = result;
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (year &gt;= 70 &amp;&amp; year &lt;= 99) {
          year += 1900;
        } else if (year &gt;= 0 &amp;&amp; year &lt;= 69) {
          year += 2000;
        }
      }
    }
  }

  /* RFC 6265 S5.1.1
   * &quot;5. Abort these steps and fail to parse the cookie-date if:
   *     *  at least one of the found-day-of-month, found-month, found-
   *        year, or found-time flags is not set,
   *     *  the day-of-month-value is less than 1 or greater than 31,
   *     *  the year-value is less than 1601,
   *     *  the hour-value is greater than 23,
   *     *  the minute-value is greater than 59, or
   *     *  the second-value is greater than 59.
   *     (Note that leap seconds cannot be represented in this syntax.)&quot;
   *
   * So, in order as above:
   */
  if (
    dayOfMonth === null || month === null || year === null || second === null ||
    dayOfMonth &lt; 1 || dayOfMonth &gt; 31 ||
    year &lt; 1601 ||
    hour &gt; 23 ||
    minute &gt; 59 ||
    second &gt; 59
  ) {
    return;
  }

  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}

function formatDate(date) {
  var d = date.getUTCDate(); d = d &gt;= 10 ? d : &#039;0&#039;+d;
  var h = date.getUTCHours(); h = h &gt;= 10 ? h : &#039;0&#039;+h;
  var m = date.getUTCMinutes(); m = m &gt;= 10 ? m : &#039;0&#039;+m;
  var s = date.getUTCSeconds(); s = s &gt;= 10 ? s : &#039;0&#039;+s;
  return NUM_TO_DAY[date.getUTCDay()] + &#039;, &#039; +
    d+&#039; &#039;+ NUM_TO_MONTH[date.getUTCMonth()] +&#039; &#039;+ date.getUTCFullYear() +&#039; &#039;+
    h+&#039;:&#039;+m+&#039;:&#039;+s+&#039; GMT&#039;;
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str) {
  if (str == null) {
    return null;
  }
  str = str.trim().replace(/^\./,&#039;&#039;); // S4.1.2.3 &amp; S5.2.3: ignore leading .

  // convert to IDN if any non-ASCII characters
  if (punycode &amp;&amp; /[^\u0001-\u007f]/.test(str)) {
    str = punycode.toASCII(str);
  }

  return str.toLowerCase();
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) {
    return null;
  }
  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  /*
   * &quot;The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point)&quot;
   */
  if (str == domStr) {
    return true;
  }

  /* &quot;All of the following [three] conditions hold:&quot; (order adjusted from the RFC) */

  /* &quot;* The string is a host name (i.e., not an IP address).&quot; */
  if (net.isIP(str)) {
    return false;
  }

  /* &quot;* The domain string is a suffix of the string&quot; */
  var idx = str.indexOf(domStr);
  if (idx &lt;= 0) {
    return false; // it&#039;s a non-match (-1) or prefix (0)
  }

  // e.g &quot;a.b.c&quot;.indexOf(&quot;b.c&quot;) === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx) { // it&#039;s not a suffix
    return false;
  }

  /* &quot;* The last character of the string that is not included in the domain
  * string is a %x2E (&quot;.&quot;) character.&quot; */
  if (str.substr(idx-1,1) !== &#039;.&#039;) {
    return false;
  }

  return true;
}


// RFC6265 S5.1.4 Paths and Path-Match

/*
 * &quot;The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:&quot;
 *
 * Assumption: the path (and not query part or absolute uri) is passed in.
 */
function defaultPath(path) {
  // &quot;2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F (&quot;/&quot;) character, output %x2F (&quot;/&quot;) and skip the remaining steps.
  if (!path || path.substr(0,1) !== &quot;/&quot;) {
    return &quot;/&quot;;
  }

  // &quot;3. If the uri-path contains no more than one %x2F (&quot;/&quot;) character, output
  // %x2F (&quot;/&quot;) and skip the remaining step.&quot;
  if (path === &quot;/&quot;) {
    return path;
  }

  var rightSlash = path.lastIndexOf(&quot;/&quot;);
  if (rightSlash === 0) {
    return &quot;/&quot;;
  }

  // &quot;4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F (&quot;/&quot;).&quot;
  return path.slice(0, rightSlash);
}

function trimTerminator(str) {
  for (var t = 0; t &lt; TERMINATORS.length; t++) {
    var terminatorIdx = str.indexOf(TERMINATORS[t]);
    if (terminatorIdx !== -1) {
      str = str.substr(0,terminatorIdx);
    }
  }

  return str;
}

function parseCookiePair(cookiePair, looseMode) {
  cookiePair = trimTerminator(cookiePair);

  var firstEq = cookiePair.indexOf(&#039;=&#039;);
  if (looseMode) {
    if (firstEq === 0) { // &#039;=&#039; is immediately at start
      cookiePair = cookiePair.substr(1);
      firstEq = cookiePair.indexOf(&#039;=&#039;); // might still need to split on &#039;=&#039;
    }
  } else { // non-loose mode
    if (firstEq &lt;= 0) { // no &#039;=&#039; or is at start
      return; // needs to have non-empty &quot;cookie-name&quot;
    }
  }

  var cookieName, cookieValue;
  if (firstEq &lt;= 0) {
    cookieName = &quot;&quot;;
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.substr(0, firstEq).trim();
    cookieValue = cookiePair.substr(firstEq+1).trim();
  }

  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    return;
  }

  var c = new Cookie();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}

function parse(str, options) {
  if (!options || typeof options !== &#039;object&#039;) {
    options = {};
  }
  str = str.trim();

  // We use a regex to parse the &quot;name-value-pair&quot; part of S5.2
  var firstSemi = str.indexOf(&#039;;&#039;); // S5.2 step 1
  var cookiePair = (firstSemi === -1) ? str : str.substr(0, firstSemi);
  var c = parseCookiePair(cookiePair, !!options.loose);
  if (!c) {
    return;
  }

  if (firstSemi === -1) {
    return c;
  }

  // S5.2.3 &quot;unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (&quot;;&quot;) in question).&quot; plus later on in the same section
  // &quot;discard the first &quot;;&quot; and trim&quot;.
  var unparsed = str.slice(firstSemi + 1).trim();

  // &quot;If the unparsed-attributes string is empty, skip the rest of these
  // steps.&quot;
  if (unparsed.length === 0) {
    return c;
  }

  /*
   * S5.2 says that when looping over the items &quot;[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections&quot; for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the &quot;attribute-value of the last attribute in the
   * cookie-attribute-list&quot;.  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  var cookie_avs = unparsed.split(&#039;;&#039;);
  while (cookie_avs.length) {
    var av = cookie_avs.shift().trim();
    if (av.length === 0) { // happens if &quot;;;&quot; appears
      continue;
    }
    var av_sep = av.indexOf(&#039;=&#039;);
    var av_key, av_value;

    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0,av_sep);
      av_value = av.substr(av_sep+1);
    }

    av_key = av_key.trim().toLowerCase();

    if (av_value) {
      av_value = av_value.trim();
    }

    switch(av_key) {
    case &#039;expires&#039;: // S5.2.1
      if (av_value) {
        var exp = parseDate(av_value);
        // &quot;If the attribute-value failed to parse as a cookie date, ignore the
        // cookie-av.&quot;
        if (exp) {
          // over and underflow not realistically a concern: V8&#039;s getTime() seems to
          // store something larger than a 32-bit time_t (even with 32-bit node)
          c.expires = exp;
        }
      }
      break;

    case &#039;max-age&#039;: // S5.2.2
      if (av_value) {
        // &quot;If the first character of the attribute-value is not a DIGIT or a &quot;-&quot;
        // character ...[or]... If the remainder of attribute-value contains a
        // non-DIGIT character, ignore the cookie-av.&quot;
        if (/^-?[0-9]+$/.test(av_value)) {
          var delta = parseInt(av_value, 10);
          // &quot;If delta-seconds is less than or equal to zero (0), let expiry-time
          // be the earliest representable date and time.&quot;
          c.setMaxAge(delta);
        }
      }
      break;

    case &#039;domain&#039;: // S5.2.3
      // &quot;If the attribute-value is empty, the behavior is undefined.  However,
      // the user agent SHOULD ignore the cookie-av entirely.&quot;
      if (av_value) {
        // S5.2.3 &quot;Let cookie-domain be the attribute-value without the leading %x2E
        // (&quot;.&quot;) character.&quot;
        var domain = av_value.trim().replace(/^\./, &#039;&#039;);
        if (domain) {
          // &quot;Convert the cookie-domain to lower case.&quot;
          c.domain = domain.toLowerCase();
        }
      }
      break;

    case &#039;path&#039;: // S5.2.4
      /*
       * &quot;If the attribute-value is empty or if the first character of the
       * attribute-value is not %x2F (&quot;/&quot;):
       *   Let cookie-path be the default-path.
       * Otherwise:
       *   Let cookie-path be the attribute-value.&quot;
       *
       * We&#039;ll represent the default-path as null since it depends on the
       * context of the parsing.
       */
      c.path = av_value &amp;&amp; av_value[0] === &quot;/&quot; ? av_value : null;
      break;

    case &#039;secure&#039;: // S5.2.5
      /*
       * &quot;If the attribute-name case-insensitively matches the string &quot;Secure&quot;,
       * the user agent MUST append an attribute to the cookie-attribute-list
       * with an attribute-name of Secure and an empty attribute-value.&quot;
       */
      c.secure = true;
      break;

    case &#039;httponly&#039;: // S5.2.6 -- effectively the same as &#039;secure&#039;
      c.httpOnly = true;
      break;

    default:
      c.extensions = c.extensions || [];
      c.extensions.push(av);
      break;
    }
  }

  return c;
}

// avoid the V8 deoptimization monster!
function jsonParse(str) {
  var obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return e;
  }
  return obj;
}

function fromJSON(str) {
  if (!str) {
    return null;
  }

  var obj;
  if (typeof str === &#039;string&#039;) {
    obj = jsonParse(str);
    if (obj instanceof Error) {
      return null;
    }
  } else {
    // assume it&#039;s an Object
    obj = str;
  }

  var c = new Cookie();
  for (var i=0; i&lt;Cookie.serializableProperties.length; i++) {
    var prop = Cookie.serializableProperties[i];
    if (obj[prop] === undefined ||
        obj[prop] === Cookie.prototype[prop])
    {
      continue; // leave as prototype default
    }

    if (prop === &#039;expires&#039; ||
        prop === &#039;creation&#039; ||
        prop === &#039;lastAccessed&#039;)
    {
      if (obj[prop] === null) {
        c[prop] = null;
      } else {
        c[prop] = obj[prop] == &quot;Infinity&quot; ?
          &quot;Infinity&quot; : new Date(obj[prop]);
      }
    } else {
      c[prop] = obj[prop];
    }
  }

  return c;
}

/* Section 5.4 part 2:
 * &quot;*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times.&quot;
 */

function cookieCompare(a,b) {
  var cmp = 0;

  // descending for length: b CMP a
  var aPathLen = a.path ? a.path.length : 0;
  var bPathLen = b.path ? b.path.length : 0;
  cmp = bPathLen - aPathLen;
  if (cmp !== 0) {
    return cmp;
  }

  // ascending for time: a CMP b
  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
  cmp = aTime - bTime;
  if (cmp !== 0) {
    return cmp;
  }

  // break ties for the same millisecond (precision of JavaScript&#039;s clock)
  cmp = a.creationIndex - b.creationIndex;

  return cmp;
}

// Gives the permutation of all possible pathMatch()es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path) {
  if (path === &#039;/&#039;) {
    return [&#039;/&#039;];
  }
  if (path.lastIndexOf(&#039;/&#039;) === path.length-1) {
    path = path.substr(0,path.length-1);
  }
  var permutations = [path];
  while (path.length &gt; 1) {
    var lindex = path.lastIndexOf(&#039;/&#039;);
    if (lindex === 0) {
      break;
    }
    path = path.substr(0,lindex);
    permutations.push(path);
  }
  permutations.push(&#039;/&#039;);
  return permutations;
}

function getCookieContext(url) {
  if (url instanceof Object) {
    return url;
  }
  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
  // Therefore, we will just skip decoding for such URIs.
  try {
    url = decodeURI(url);
  }
  catch(err) {
    // Silently swallow error
  }

  return urlParse(url);
}

function Cookie(options) {
  options = options || {};

  Object.keys(options).forEach(function(prop) {
    if (Cookie.prototype.hasOwnProperty(prop) &amp;&amp;
        Cookie.prototype[prop] !== options[prop] &amp;&amp;
        prop.substr(0,1) !== &#039;_&#039;)
    {
      this[prop] = options[prop];
    }
  }, this);

  this.creation = this.creation || new Date();

  // used to break creation ties in cookieCompare():
  Object.defineProperty(this, &#039;creationIndex&#039;, {
    configurable: false,
    enumerable: false, // important for assert.deepEqual checks
    writable: true,
    value: ++Cookie.cookiesCreated
  });
}

Cookie.cookiesCreated = 0; // incremented each time a cookie is created

Cookie.parse = parse;
Cookie.fromJSON = fromJSON;

Cookie.prototype.key = &quot;&quot;;
Cookie.prototype.value = &quot;&quot;;

// the order in which the RFC has them:
Cookie.prototype.expires = &quot;Infinity&quot;; // coerces to literal Infinity
Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
Cookie.prototype.domain = null;
Cookie.prototype.path = null;
Cookie.prototype.secure = false;
Cookie.prototype.httpOnly = false;
Cookie.prototype.extensions = null;

// set by the CookieJar:
Cookie.prototype.hostOnly = null; // boolean when set
Cookie.prototype.pathIsDefault = null; // boolean when set
Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
Cookie.prototype.lastAccessed = null; // Date when set
Object.defineProperty(Cookie.prototype, &#039;creationIndex&#039;, {
  configurable: true,
  enumerable: false,
  writable: true,
  value: 0
});

Cookie.serializableProperties = Object.keys(Cookie.prototype)
  .filter(function(prop) {
    return !(
      Cookie.prototype[prop] instanceof Function ||
      prop === &#039;creationIndex&#039; ||
      prop.substr(0,1) === &#039;_&#039;
    );
  });

Cookie.prototype.inspect = function inspect() {
  var now = Date.now();
  return &#039;Cookie=&quot;&#039;+this.toString() +
    &#039;; hostOnly=&#039;+(this.hostOnly != null ? this.hostOnly : &#039;?&#039;) +
    &#039;; aAge=&#039;+(this.lastAccessed ? (now-this.lastAccessed.getTime())+&#039;ms&#039; : &#039;?&#039;) +
    &#039;; cAge=&#039;+(this.creation ? (now-this.creation.getTime())+&#039;ms&#039; : &#039;?&#039;) +
    &#039;&quot;&#039;;
};

// Use the new custom inspection symbol to add the custom inspect function if
// available.
if (util.inspect.custom) {
  Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
}

Cookie.prototype.toJSON = function() {
  var obj = {};

  var props = Cookie.serializableProperties;
  for (var i=0; i&lt;props.length; i++) {
    var prop = props[i];
    if (this[prop] === Cookie.prototype[prop]) {
      continue; // leave as prototype default
    }

    if (prop === &#039;expires&#039; ||
        prop === &#039;creation&#039; ||
        prop === &#039;lastAccessed&#039;)
    {
      if (this[prop] === null) {
        obj[prop] = null;
      } else {
        obj[prop] = this[prop] == &quot;Infinity&quot; ? // intentionally not ===
          &quot;Infinity&quot; : this[prop].toISOString();
      }
    } else if (prop === &#039;maxAge&#039;) {
      if (this[prop] !== null) {
        // again, intentionally not ===
        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
          this[prop].toString() : this[prop];
      }
    } else {
      if (this[prop] !== Cookie.prototype[prop]) {
        obj[prop] = this[prop];
      }
    }
  }

  return obj;
};

Cookie.prototype.clone = function() {
  return fromJSON(this.toJSON());
};

Cookie.prototype.validate = function validate() {
  if (!COOKIE_OCTETS.test(this.value)) {
    return false;
  }
  if (this.expires != Infinity &amp;&amp; !(this.expires instanceof Date) &amp;&amp; !parseDate(this.expires)) {
    return false;
  }
  if (this.maxAge != null &amp;&amp; this.maxAge &lt;= 0) {
    return false; // &quot;Max-Age=&quot; non-zero-digit *DIGIT
  }
  if (this.path != null &amp;&amp; !PATH_VALUE.test(this.path)) {
    return false;
  }

  var cdomain = this.cdomain();
  if (cdomain) {
    if (cdomain.match(/\.$/)) {
      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
    }
    var suffix = pubsuffix.getPublicSuffix(cdomain);
    if (suffix == null) { // it&#039;s a public suffix
      return false;
    }
  }
  return true;
};

Cookie.prototype.setExpires = function setExpires(exp) {
  if (exp instanceof Date) {
    this.expires = exp;
  } else {
    this.expires = parseDate(exp) || &quot;Infinity&quot;;
  }
};

Cookie.prototype.setMaxAge = function setMaxAge(age) {
  if (age === Infinity || age === -Infinity) {
    this.maxAge = age.toString(); // so JSON.stringify() works
  } else {
    this.maxAge = age;
  }
};

// gives Cookie header format
Cookie.prototype.cookieString = function cookieString() {
  var val = this.value;
  if (val == null) {
    val = &#039;&#039;;
  }
  if (this.key === &#039;&#039;) {
    return val;
  }
  return this.key+&#039;=&#039;+val;
};

// gives Set-Cookie header format
Cookie.prototype.toString = function toString() {
  var str = this.cookieString();

  if (this.expires != Infinity) {
    if (this.expires instanceof Date) {
      str += &#039;; Expires=&#039;+formatDate(this.expires);
    } else {
      str += &#039;; Expires=&#039;+this.expires;
    }
  }

  if (this.maxAge != null &amp;&amp; this.maxAge != Infinity) {
    str += &#039;; Max-Age=&#039;+this.maxAge;
  }

  if (this.domain &amp;&amp; !this.hostOnly) {
    str += &#039;; Domain=&#039;+this.domain;
  }
  if (this.path) {
    str += &#039;; Path=&#039;+this.path;
  }

  if (this.secure) {
    str += &#039;; Secure&#039;;
  }
  if (this.httpOnly) {
    str += &#039;; HttpOnly&#039;;
  }
  if (this.extensions) {
    this.extensions.forEach(function(ext) {
      str += &#039;; &#039;+ext;
    });
  }

  return str;
};

// TTL() partially replaces the &quot;expiry-time&quot; parts of S5.3 step 3 (setCookie()
// elsewhere)
// S5.3 says to give the &quot;latest representable date&quot; for which we use Infinity
// For &quot;expired&quot; we use 0
Cookie.prototype.TTL = function TTL(now) {
  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
   * attribute, the Max-Age attribute has precedence and controls the
   * expiration date of the cookie.
   * (Concurs with S5.3 step 3)
   */
  if (this.maxAge != null) {
    return this.maxAge&lt;=0 ? 0 : this.maxAge*1000;
  }

  var expires = this.expires;
  if (expires != Infinity) {
    if (!(expires instanceof Date)) {
      expires = parseDate(expires) || Infinity;
    }

    if (expires == Infinity) {
      return Infinity;
    }

    return expires.getTime() - (now || Date.now());
  }

  return Infinity;
};

// expiryTime() replaces the &quot;expiry-time&quot; parts of S5.3 step 3 (setCookie()
// elsewhere)
Cookie.prototype.expiryTime = function expiryTime(now) {
  if (this.maxAge != null) {
    var relativeTo = now || this.creation || new Date();
    var age = (this.maxAge &lt;= 0) ? -Infinity : this.maxAge*1000;
    return relativeTo.getTime() + age;
  }

  if (this.expires == Infinity) {
    return Infinity;
  }
  return this.expires.getTime();
};

// expiryDate() replaces the &quot;expiry-time&quot; parts of S5.3 step 3 (setCookie()
// elsewhere), except it returns a Date
Cookie.prototype.expiryDate = function expiryDate(now) {
  var millisec = this.expiryTime(now);
  if (millisec == Infinity) {
    return new Date(MAX_TIME);
  } else if (millisec == -Infinity) {
    return new Date(MIN_TIME);
  } else {
    return new Date(millisec);
  }
};

// This replaces the &quot;persistent-flag&quot; parts of S5.3 step 3
Cookie.prototype.isPersistent = function isPersistent() {
  return (this.maxAge != null || this.expires != Infinity);
};

// Mostly S5.1.2 and S5.2.3:
Cookie.prototype.cdomain =
Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
  if (this.domain == null) {
    return null;
  }
  return canonicalDomain(this.domain);
};

function CookieJar(store, options) {
  if (typeof options === &quot;boolean&quot;) {
    options = {rejectPublicSuffixes: options};
  } else if (options == null) {
    options = {};
  }
  if (options.rejectPublicSuffixes != null) {
    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
  }
  if (options.looseMode != null) {
    this.enableLooseMode = options.looseMode;
  }

  if (!store) {
    store = new MemoryCookieStore();
  }
  this.store = store;
}
CookieJar.prototype.store = null;
CookieJar.prototype.rejectPublicSuffixes = true;
CookieJar.prototype.enableLooseMode = false;
var CAN_BE_SYNC = [];

CAN_BE_SYNC.push(&#039;setCookie&#039;);
CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
  var err;
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var loose = this.enableLooseMode;
  if (options.loose != null) {
    loose = options.loose;
  }

  // S5.3 step 1
  if (!(cookie instanceof Cookie)) {
    cookie = Cookie.parse(cookie, { loose: loose });
  }
  if (!cookie) {
    err = new Error(&quot;Cookie failed to parse&quot;);
    return cb(options.ignoreError ? null : err);
  }

  // S5.3 step 2
  var now = options.now || new Date(); // will assign later to save effort in the face of errors

  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

  // S5.3 step 4: NOOP; domain is null by default

  // S5.3 step 5: public suffixes
  if (this.rejectPublicSuffixes &amp;&amp; cookie.domain) {
    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
    if (suffix == null) { // e.g. &quot;com&quot;
      err = new Error(&quot;Cookie has domain set to a public suffix&quot;);
      return cb(options.ignoreError ? null : err);
    }
  }

  // S5.3 step 6:
  if (cookie.domain) {
    if (!domainMatch(host, cookie.cdomain(), false)) {
      err = new Error(&quot;Cookie not in this host&#039;s domain. Cookie:&quot;+cookie.cdomain()+&quot; Request:&quot;+host);
      return cb(options.ignoreError ? null : err);
    }

    if (cookie.hostOnly == null) { // don&#039;t reset if already set
      cookie.hostOnly = false;
    }

  } else {
    cookie.hostOnly = true;
    cookie.domain = host;
  }

  //S5.2.4 If the attribute-value is empty or if the first character of the
  //attribute-value is not %x2F (&quot;/&quot;):
  //Let cookie-path be the default-path.
  if (!cookie.path || cookie.path[0] !== &#039;/&#039;) {
    cookie.path = defaultPath(context.pathname);
    cookie.pathIsDefault = true;
  }

  // S5.3 step 8: NOOP; secure attribute
  // S5.3 step 9: NOOP; httpOnly attribute

  // S5.3 step 10
  if (options.http === false &amp;&amp; cookie.httpOnly) {
    err = new Error(&quot;Cookie is HttpOnly and this isn&#039;t an HTTP API&quot;);
    return cb(options.ignoreError ? null : err);
  }

  var store = this.store;

  if (!store.updateCookie) {
    store.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
  }

  function withCookie(err, oldCookie) {
    if (err) {
      return cb(err);
    }

    var next = function(err) {
      if (err) {
        return cb(err);
      } else {
        cb(null, cookie);
      }
    };

    if (oldCookie) {
      // S5.3 step 11 - &quot;If the cookie store contains a cookie with the same name,
      // domain, and path as the newly created cookie:&quot;
      if (options.http === false &amp;&amp; oldCookie.httpOnly) { // step 11.2
        err = new Error(&quot;old Cookie is HttpOnly and this isn&#039;t an HTTP API&quot;);
        return cb(options.ignoreError ? null : err);
      }
      cookie.creation = oldCookie.creation; // step 11.3
      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
      cookie.lastAccessed = now;
      // Step 11.4 (delete cookie) is implied by just setting the new one:
      store.updateCookie(oldCookie, cookie, next); // step 12

    } else {
      cookie.creation = cookie.lastAccessed = now;
      store.putCookie(cookie, next); // step 12
    }
  }

  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
};

// RFC6365 S5.4
CAN_BE_SYNC.push(&#039;getCookies&#039;);
CookieJar.prototype.getCookies = function(url, options, cb) {
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var path = context.pathname || &#039;/&#039;;

  var secure = options.secure;
  if (secure == null &amp;&amp; context.protocol &amp;&amp;
      (context.protocol == &#039;https:&#039; || context.protocol == &#039;wss:&#039;))
  {
    secure = true;
  }

  var http = options.http;
  if (http == null) {
    http = true;
  }

  var now = options.now || Date.now();
  var expireCheck = options.expire !== false;
  var allPaths = !!options.allPaths;
  var store = this.store;

  function matchingCookie(c) {
    // &quot;Either:
    //   The cookie&#039;s host-only-flag is true and the canonicalized
    //   request-host is identical to the cookie&#039;s domain.
    // Or:
    //   The cookie&#039;s host-only-flag is false and the canonicalized
    //   request-host domain-matches the cookie&#039;s domain.&quot;
    if (c.hostOnly) {
      if (c.domain != host) {
        return false;
      }
    } else {
      if (!domainMatch(host, c.domain, false)) {
        return false;
      }
    }

    // &quot;The request-uri&#039;s path path-matches the cookie&#039;s path.&quot;
    if (!allPaths &amp;&amp; !pathMatch(path, c.path)) {
      return false;
    }

    // &quot;If the cookie&#039;s secure-only-flag is true, then the request-uri&#039;s
    // scheme must denote a &quot;secure&quot; protocol&quot;
    if (c.secure &amp;&amp; !secure) {
      return false;
    }

    // &quot;If the cookie&#039;s http-only-flag is true, then exclude the cookie if the
    // cookie-string is being generated for a &quot;non-HTTP&quot; API&quot;
    if (c.httpOnly &amp;&amp; !http) {
      return false;
    }

    // deferred from S5.3
    // non-RFC: allow retention of expired cookies by choice
    if (expireCheck &amp;&amp; c.expiryTime() &lt;= now) {
      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
      return false;
    }

    return true;
  }

  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
    if (err) {
      return cb(err);
    }

    cookies = cookies.filter(matchingCookie);

    // sorting of S5.4 part 2
    if (options.sort !== false) {
      cookies = cookies.sort(cookieCompare);
    }

    // S5.4 part 3
    var now = new Date();
    cookies.forEach(function(c) {
      c.lastAccessed = now;
    });
    // TODO persist lastAccessed

    cb(null,cookies);
  });
};

CAN_BE_SYNC.push(&#039;getCookieString&#039;);
CookieJar.prototype.getCookieString = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies
        .sort(cookieCompare)
        .map(function(c){
          return c.cookieString();
        })
        .join(&#039;; &#039;));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push(&#039;getSetCookieStrings&#039;);
CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies.map(function(c){
        return c.toString();
      }));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push(&#039;serialize&#039;);
CookieJar.prototype.serialize = function(cb) {
  var type = this.store.constructor.name;
  if (type === &#039;Object&#039;) {
    type = null;
  }

  // update README.md &quot;Serialization Format&quot; if you change this, please!
  var serialized = {
    // The version of tough-cookie that serialized this jar. Generally a good
    // practice since future versions can make data import decisions based on
    // known past behavior. When/if this matters, use `semver`.
    version: &#039;tough-cookie@&#039;+VERSION,

    // add the store type, to make humans happy:
    storeType: type,

    // CookieJar configuration:
    rejectPublicSuffixes: !!this.rejectPublicSuffixes,

    // this gets filled from getAllCookies:
    cookies: []
  };

  if (!(this.store.getAllCookies &amp;&amp;
        typeof this.store.getAllCookies === &#039;function&#039;))
  {
    return cb(new Error(&#039;store does not support getAllCookies and cannot be serialized&#039;));
  }

  this.store.getAllCookies(function(err,cookies) {
    if (err) {
      return cb(err);
    }

    serialized.cookies = cookies.map(function(cookie) {
      // convert to serialized &#039;raw&#039; cookies
      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;

      // Remove the index so new ones get assigned during deserialization
      delete cookie.creationIndex;

      return cookie;
    });

    return cb(null, serialized);
  });
};

// well-known name that JSON.stringify calls
CookieJar.prototype.toJSON = function() {
  return this.serializeSync();
};

// use the class method CookieJar.deserialize instead of calling this directly
CAN_BE_SYNC.push(&#039;_importCookies&#039;);
CookieJar.prototype._importCookies = function(serialized, cb) {
  var jar = this;
  var cookies = serialized.cookies;
  if (!cookies || !Array.isArray(cookies)) {
    return cb(new Error(&#039;serialized jar has no cookies array&#039;));
  }
  cookies = cookies.slice(); // do not modify the original

  function putNext(err) {
    if (err) {
      return cb(err);
    }

    if (!cookies.length) {
      return cb(err, jar);
    }

    var cookie;
    try {
      cookie = fromJSON(cookies.shift());
    } catch (e) {
      return cb(e);
    }

    if (cookie === null) {
      return putNext(null); // skip this cookie
    }

    jar.store.putCookie(cookie, putNext);
  }

  putNext();
};

CookieJar.deserialize = function(strOrObj, store, cb) {
  if (arguments.length !== 3) {
    // store is optional
    cb = store;
    store = null;
  }

  var serialized;
  if (typeof strOrObj === &#039;string&#039;) {
    serialized = jsonParse(strOrObj);
    if (serialized instanceof Error) {
      return cb(serialized);
    }
  } else {
    serialized = strOrObj;
  }

  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
  jar._importCookies(serialized, function(err) {
    if (err) {
      return cb(err);
    }
    cb(null, jar);
  });
};

CookieJar.deserializeSync = function(strOrObj, store) {
  var serialized = typeof strOrObj === &#039;string&#039; ?
    JSON.parse(strOrObj) : strOrObj;
  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);

  // catch this mistake early:
  if (!jar.store.synchronous) {
    throw new Error(&#039;CookieJar store is not synchronous; use async API instead.&#039;);
  }

  jar._importCookiesSync(serialized);
  return jar;
};
CookieJar.fromJSON = CookieJar.deserializeSync;

CookieJar.prototype.clone = function(newStore, cb) {
  if (arguments.length === 1) {
    cb = newStore;
    newStore = null;
  }

  this.serialize(function(err,serialized) {
    if (err) {
      return cb(err);
    }
    CookieJar.deserialize(serialized, newStore, cb);
  });
};

CAN_BE_SYNC.push(&#039;removeAllCookies&#039;);
CookieJar.prototype.removeAllCookies = function(cb) {
  var store = this.store;

  // Check that the store implements its own removeAllCookies(). The default
  // implementation in Store will immediately call the callback with a &quot;not
  // implemented&quot; Error.
  if (store.removeAllCookies instanceof Function &amp;&amp;
      store.removeAllCookies !== Store.prototype.removeAllCookies)
  {
    return store.removeAllCookies(cb);
  }

  store.getAllCookies(function(err, cookies) {
    if (err) {
      return cb(err);
    }

    if (cookies.length === 0) {
      return cb(null);
    }

    var completedCount = 0;
    var removeErrors = [];

    function removeCookieCb(removeErr) {
      if (removeErr) {
        removeErrors.push(removeErr);
      }

      completedCount++;

      if (completedCount === cookies.length) {
        return cb(removeErrors.length ? removeErrors[0] : null);
      }
    }

    cookies.forEach(function(cookie) {
      store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
    });
  });
};

CookieJar.prototype._cloneSync = syncWrap(&#039;clone&#039;);
CookieJar.prototype.cloneSync = function(newStore) {
  if (!newStore.synchronous) {
    throw new Error(&#039;CookieJar clone destination store is not synchronous; use async API instead.&#039;);
  }
  return this._cloneSync(newStore);
};

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method) {
  return function() {
    if (!this.store.synchronous) {
      throw new Error(&#039;CookieJar store is not synchronous; use async API instead.&#039;);
    }

    var args = Array.prototype.slice.call(arguments);
    var syncErr, syncResult;
    args.push(function syncCb(err, result) {
      syncErr = err;
      syncResult = result;
    });
    this[method].apply(this, args);

    if (syncErr) {
      throw syncErr;
    }
    return syncResult;
  };
}

// wrap all declared CAN_BE_SYNC methods in the sync wrapper
CAN_BE_SYNC.forEach(function(method) {
  CookieJar.prototype[method+&#039;Sync&#039;] = syncWrap(method);
});

exports.version = VERSION;
exports.CookieJar = CookieJar;
exports.Cookie = Cookie;
exports.Store = Store;
exports.MemoryCookieStore = MemoryCookieStore;
exports.parseDate = parseDate;
exports.formatDate = formatDate;
exports.parse = parse;
exports.fromJSON = fromJSON;
exports.domainMatch = domainMatch;
exports.defaultPath = defaultPath;
exports.pathMatch = pathMatch;
exports.getPublicSuffix = pubsuffix.getPublicSuffix;
exports.cookieCompare = cookieCompare;
exports.permuteDomain = require(&#039;./permuteDomain&#039;).permuteDomain;
exports.permutePath = permutePath;
exports.canonicalDomain = canonicalDomain;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
