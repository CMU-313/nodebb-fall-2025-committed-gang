<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsesc/jsesc.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsesc/jsesc.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">338</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">44.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const object = {};
const hasOwnProperty = object.hasOwnProperty;
const forOwn = (object, callback) =&gt; {
	for (const key in object) {
		if (hasOwnProperty.call(object, key)) {
			callback(key, object[key]);
		}
	}
};

const extend = (destination, source) =&gt; {
	if (!source) {
		return destination;
	}
	forOwn(source, (key, value) =&gt; {
		destination[key] = value;
	});
	return destination;
};

const forEach = (array, callback) =&gt; {
	const length = array.length;
	let index = -1;
	while (++index &lt; length) {
		callback(array[index]);
	}
};

const fourHexEscape = (hex) =&gt; {
	return &#039;\\u&#039; + (&#039;0000&#039; + hex).slice(-4);
}

const hexadecimal = (code, lowercase) =&gt; {
	let hexadecimal = code.toString(16);
	if (lowercase) return hexadecimal;
	return hexadecimal.toUpperCase();
};

const toString = object.toString;
const isArray = Array.isArray;
const isBuffer = (value) =&gt; {
	return typeof Buffer === &#039;function&#039; &amp;&amp; Buffer.isBuffer(value);
};
const isObject = (value) =&gt; {
	// This is a very simple check, but it’s good enough for what we need.
	return toString.call(value) == &#039;[object Object]&#039;;
};
const isString = (value) =&gt; {
	return typeof value == &#039;string&#039; ||
		toString.call(value) == &#039;[object String]&#039;;
};
const isNumber = (value) =&gt; {
	return typeof value == &#039;number&#039; ||
		toString.call(value) == &#039;[object Number]&#039;;
};
const isBigInt = (value) =&gt; {
  return typeof value == &#039;bigint&#039;;
};
const isFunction = (value) =&gt; {
	return typeof value == &#039;function&#039;;
};
const isMap = (value) =&gt; {
	return toString.call(value) == &#039;[object Map]&#039;;
};
const isSet = (value) =&gt; {
	return toString.call(value) == &#039;[object Set]&#039;;
};

/*--------------------------------------------------------------------------*/

// https://mathiasbynens.be/notes/javascript-escapes#single
const singleEscapes = {
	&#039;\\&#039;: &#039;\\\\&#039;,
	&#039;\b&#039;: &#039;\\b&#039;,
	&#039;\f&#039;: &#039;\\f&#039;,
	&#039;\n&#039;: &#039;\\n&#039;,
	&#039;\r&#039;: &#039;\\r&#039;,
	&#039;\t&#039;: &#039;\\t&#039;
	// `\v` is omitted intentionally, because in IE &lt; 9, &#039;\v&#039; == &#039;v&#039;.
	// &#039;\v&#039;: &#039;\\x0B&#039;
};
const regexSingleEscape = /[\\\b\f\n\r\t]/;

const regexDigit = /[0-9]/;
const regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

const escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|([&#039;&quot;`])|[^]/g;
const escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|([&#039;&quot;`])|[^ !#-&amp;\(-\[\]-_a-~]/g;

const jsesc = (argument, options) =&gt; {
	const increaseIndentation = () =&gt; {
		oldIndent = indent;
		++options.indentLevel;
		indent = options.indent.repeat(options.indentLevel)
	};
	// Handle options
	const defaults = {
		&#039;escapeEverything&#039;: false,
		&#039;minimal&#039;: false,
		&#039;isScriptContext&#039;: false,
		&#039;quotes&#039;: &#039;single&#039;,
		&#039;wrap&#039;: false,
		&#039;es6&#039;: false,
		&#039;json&#039;: false,
		&#039;compact&#039;: true,
		&#039;lowercaseHex&#039;: false,
		&#039;numbers&#039;: &#039;decimal&#039;,
		&#039;indent&#039;: &#039;\t&#039;,
		&#039;indentLevel&#039;: 0,
		&#039;__inline1__&#039;: false,
		&#039;__inline2__&#039;: false
	};
	const json = options &amp;&amp; options.json;
	if (json) {
		defaults.quotes = &#039;double&#039;;
		defaults.wrap = true;
	}
	options = extend(defaults, options);
	if (
		options.quotes != &#039;single&#039; &amp;&amp;
		options.quotes != &#039;double&#039; &amp;&amp;
		options.quotes != &#039;backtick&#039;
	) {
		options.quotes = &#039;single&#039;;
	}
	const quote = options.quotes == &#039;double&#039; ?
		&#039;&quot;&#039; :
		(options.quotes == &#039;backtick&#039; ?
			&#039;`&#039; :
			&#039;\&#039;&#039;
		);
	const compact = options.compact;
	const lowercaseHex = options.lowercaseHex;
	let indent = options.indent.repeat(options.indentLevel);
	let oldIndent = &#039;&#039;;
	const inline1 = options.__inline1__;
	const inline2 = options.__inline2__;
	const newLine = compact ? &#039;&#039; : &#039;\n&#039;;
	let result;
	let isEmpty = true;
	const useBinNumbers = options.numbers == &#039;binary&#039;;
	const useOctNumbers = options.numbers == &#039;octal&#039;;
	const useDecNumbers = options.numbers == &#039;decimal&#039;;
	const useHexNumbers = options.numbers == &#039;hexadecimal&#039;;

	if (json &amp;&amp; argument &amp;&amp; isFunction(argument.toJSON)) {
		argument = argument.toJSON();
	}

	if (!isString(argument)) {
		if (isMap(argument)) {
			if (argument.size == 0) {
				return &#039;new Map()&#039;;
			}
			if (!compact) {
				options.__inline1__ = true;
				options.__inline2__ = false;
			}
			return &#039;new Map(&#039; + jsesc(Array.from(argument), options) + &#039;)&#039;;
		}
		if (isSet(argument)) {
			if (argument.size == 0) {
				return &#039;new Set()&#039;;
			}
			return &#039;new Set(&#039; + jsesc(Array.from(argument), options) + &#039;)&#039;;
		}
		if (isBuffer(argument)) {
			if (argument.length == 0) {
				return &#039;Buffer.from([])&#039;;
			}
			return &#039;Buffer.from(&#039; + jsesc(Array.from(argument), options) + &#039;)&#039;;
		}
		if (isArray(argument)) {
			result = [];
			options.wrap = true;
			if (inline1) {
				options.__inline1__ = false;
				options.__inline2__ = true;
			}
			if (!inline2) {
				increaseIndentation();
			}
			forEach(argument, (value) =&gt; {
				isEmpty = false;
				if (inline2) {
					options.__inline2__ = false;
				}
				result.push(
					(compact || inline2 ? &#039;&#039; : indent) +
					jsesc(value, options)
				);
			});
			if (isEmpty) {
				return &#039;[]&#039;;
			}
			if (inline2) {
				return &#039;[&#039; + result.join(&#039;, &#039;) + &#039;]&#039;;
			}
			return &#039;[&#039; + newLine + result.join(&#039;,&#039; + newLine) + newLine +
				(compact ? &#039;&#039; : oldIndent) + &#039;]&#039;;
		} else if (isNumber(argument) || isBigInt(argument)) {
			if (json) {
				// Some number values (e.g. `Infinity`) cannot be represented in JSON.
				// `BigInt` values less than `-Number.MAX_VALUE` or greater than
        // `Number.MAX_VALUE` cannot be represented in JSON so they will become
        // `-Infinity` or `Infinity`, respectively, and then become `null` when
        // stringified.
				return JSON.stringify(Number(argument));
			}

      let result;
			if (useDecNumbers) {
				result = String(argument);
			} else if (useHexNumbers) {
				let hexadecimal = argument.toString(16);
				if (!lowercaseHex) {
					hexadecimal = hexadecimal.toUpperCase();
				}
				result = &#039;0x&#039; + hexadecimal;
			} else if (useBinNumbers) {
				result = &#039;0b&#039; + argument.toString(2);
			} else if (useOctNumbers) {
				result = &#039;0o&#039; + argument.toString(8);
			}

      if (isBigInt(argument)) {
        return result + &#039;n&#039;;
      }
      return result;
		} else if (isBigInt(argument)) {
			if (json) {
				// `BigInt` values less than `-Number.MAX_VALUE` or greater than
        // `Number.MAX_VALUE` will become `-Infinity` or `Infinity`,
        // respectively, and cannot be represented in JSON.
				return JSON.stringify(Number(argument));
			}
      return argument + &#039;n&#039;;
    } else if (!isObject(argument)) {
			if (json) {
				// For some values (e.g. `undefined`, `function` objects),
				// `JSON.stringify(value)` returns `undefined` (which isn’t valid
				// JSON) instead of `&#039;null&#039;`.
				return JSON.stringify(argument) || &#039;null&#039;;
			}
			return String(argument);
		} else { // it’s an object
			result = [];
			options.wrap = true;
			increaseIndentation();
			forOwn(argument, (key, value) =&gt; {
				isEmpty = false;
				result.push(
					(compact ? &#039;&#039; : indent) +
					jsesc(key, options) + &#039;:&#039; +
					(compact ? &#039;&#039; : &#039; &#039;) +
					jsesc(value, options)
				);
			});
			if (isEmpty) {
				return &#039;{}&#039;;
			}
			return &#039;{&#039; + newLine + result.join(&#039;,&#039; + newLine) + newLine +
				(compact ? &#039;&#039; : oldIndent) + &#039;}&#039;;
		}
	}

	const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
	result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) =&gt; {
		if (pair) {
			if (options.minimal) return pair;
			const first = pair.charCodeAt(0);
			const second = pair.charCodeAt(1);
			if (options.es6) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				const codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
				const hex = hexadecimal(codePoint, lowercaseHex);
				return &#039;\\u{&#039; + hex + &#039;}&#039;;
			}
			return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
		}

		if (lone) {
			return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
		}

		if (
			char == &#039;\0&#039; &amp;&amp;
			!json &amp;&amp;
			!regexDigit.test(string.charAt(index + 1))
		) {
			return &#039;\\0&#039;;
		}

		if (quoteChar) {
			if (quoteChar == quote || options.escapeEverything) {
				return &#039;\\&#039; + quoteChar;
			}
			return quoteChar;
		}

		if (regexSingleEscape.test(char)) {
			// no need for a `hasOwnProperty` check here
			return singleEscapes[char];
		}

		if (options.minimal &amp;&amp; !regexWhitespace.test(char)) {
			return char;
		}

		const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
		if (json || hex.length &gt; 2) {
			return fourHexEscape(hex);
		}

		return &#039;\\x&#039; + (&#039;00&#039; + hex).slice(-2);
	});

	if (quote == &#039;`&#039;) {
		result = result.replace(/\$\{/g, &#039;\\${&#039;);
	}
	if (options.isScriptContext) {
		// https://mathiasbynens.be/notes/etago
		result = result
			.replace(/&lt;\/(script|style)/gi, &#039;&lt;\\/$1&#039;)
			.replace(/&lt;!--/g, json ? &#039;\\u003C!--&#039; : &#039;\\x3C!--&#039;);
	}
	if (options.wrap) {
		result = quote + result + quote;
	}
	return result;
};

jsesc.version = &#039;3.0.2&#039;;

module.exports = jsesc;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
