<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/util/runtime.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/util/runtime.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">696</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">150.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.58</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const SortableSet = require(&quot;./SortableSet&quot;);

/** @typedef {import(&quot;../Compilation&quot;)} Compilation */
/** @typedef {import(&quot;../Entrypoint&quot;).EntryOptions} EntryOptions */

/** @typedef {string | SortableSet&lt;string&gt; | undefined} RuntimeSpec */
/** @typedef {RuntimeSpec | boolean} RuntimeCondition */

/**
 * @param {Compilation} compilation the compilation
 * @param {string} name name of the entry
 * @param {EntryOptions=} options optionally already received entry options
 * @returns {RuntimeSpec} runtime
 */
module.exports.getEntryRuntime = (compilation, name, options) =&gt; {
	let dependOn;
	let runtime;
	if (options) {
		({ dependOn, runtime } = options);
	} else {
		const entry = compilation.entries.get(name);
		if (!entry) return name;
		({ dependOn, runtime } = entry.options);
	}
	if (dependOn) {
		/** @type {RuntimeSpec} */
		let result;
		const queue = new Set(dependOn);
		for (const name of queue) {
			const dep = compilation.entries.get(name);
			if (!dep) continue;
			const { dependOn, runtime } = dep.options;
			if (dependOn) {
				for (const name of dependOn) {
					queue.add(name);
				}
			} else {
				result = mergeRuntimeOwned(result, runtime || name);
			}
		}
		return result || name;
	}
	return runtime || name;
};

/**
 * @param {RuntimeSpec} runtime runtime
 * @param {(runtime: string | undefined) =&gt; void} fn functor
 * @param {boolean} deterministicOrder enforce a deterministic order
 * @returns {void}
 */
const forEachRuntime = (runtime, fn, deterministicOrder = false) =&gt; {
	if (runtime === undefined) {
		fn(undefined);
	} else if (typeof runtime === &quot;string&quot;) {
		fn(runtime);
	} else {
		if (deterministicOrder) runtime.sort();
		for (const r of runtime) {
			fn(r);
		}
	}
};
module.exports.forEachRuntime = forEachRuntime;

/**
 * @template T
 * @param {SortableSet&lt;T&gt;} set set
 * @returns {string} runtime key
 */
const getRuntimesKey = set =&gt; {
	set.sort();
	return Array.from(set).join(&quot;\n&quot;);
};

/**
 * @param {RuntimeSpec} runtime runtime(s)
 * @returns {string} key of runtimes
 */
const getRuntimeKey = runtime =&gt; {
	if (runtime === undefined) return &quot;*&quot;;
	if (typeof runtime === &quot;string&quot;) return runtime;
	return runtime.getFromUnorderedCache(getRuntimesKey);
};
module.exports.getRuntimeKey = getRuntimeKey;

/**
 * @param {string} key key of runtimes
 * @returns {RuntimeSpec} runtime(s)
 */
const keyToRuntime = key =&gt; {
	if (key === &quot;*&quot;) return;
	const items = key.split(&quot;\n&quot;);
	if (items.length === 1) return items[0];
	return new SortableSet(items);
};
module.exports.keyToRuntime = keyToRuntime;

/**
 * @template T
 * @param {SortableSet&lt;T&gt;} set set
 * @returns {string} runtime string
 */
const getRuntimesString = set =&gt; {
	set.sort();
	return Array.from(set).join(&quot;+&quot;);
};

/**
 * @param {RuntimeSpec} runtime runtime(s)
 * @returns {string} readable version
 */
const runtimeToString = runtime =&gt; {
	if (runtime === undefined) return &quot;*&quot;;
	if (typeof runtime === &quot;string&quot;) return runtime;
	return runtime.getFromUnorderedCache(getRuntimesString);
};
module.exports.runtimeToString = runtimeToString;

/**
 * @param {RuntimeCondition} runtimeCondition runtime condition
 * @returns {string} readable version
 */
module.exports.runtimeConditionToString = runtimeCondition =&gt; {
	if (runtimeCondition === true) return &quot;true&quot;;
	if (runtimeCondition === false) return &quot;false&quot;;
	return runtimeToString(runtimeCondition);
};

/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {boolean} true, when they are equal
 */
const runtimeEqual = (a, b) =&gt; {
	if (a === b) {
		return true;
	} else if (
		a === undefined ||
		b === undefined ||
		typeof a === &quot;string&quot; ||
		typeof b === &quot;string&quot;
	) {
		return false;
	} else if (a.size !== b.size) {
		return false;
	}
	a.sort();
	b.sort();
	const aIt = a[Symbol.iterator]();
	const bIt = b[Symbol.iterator]();
	for (;;) {
		const aV = aIt.next();
		if (aV.done) return true;
		const bV = bIt.next();
		if (aV.value !== bV.value) return false;
	}
};
module.exports.runtimeEqual = runtimeEqual;

/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {-1|0|1} compare
 */
module.exports.compareRuntime = (a, b) =&gt; {
	if (a === b) {
		return 0;
	} else if (a === undefined) {
		return -1;
	} else if (b === undefined) {
		return 1;
	}
	const aKey = getRuntimeKey(a);
	const bKey = getRuntimeKey(b);
	if (aKey &lt; bKey) return -1;
	if (aKey &gt; bKey) return 1;
	return 0;
};

/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} merged
 */
const mergeRuntime = (a, b) =&gt; {
	if (a === undefined) {
		return b;
	} else if (b === undefined) {
		return a;
	} else if (a === b) {
		return a;
	} else if (typeof a === &quot;string&quot;) {
		if (typeof b === &quot;string&quot;) {
			const set = new SortableSet();
			set.add(a);
			set.add(b);
			return set;
		} else if (b.has(a)) {
			return b;
		}
		const set = new SortableSet(b);
		set.add(a);
		return set;
	}
	if (typeof b === &quot;string&quot;) {
		if (a.has(b)) return a;
		const set = new SortableSet(a);
		set.add(b);
		return set;
	}
	const set = new SortableSet(a);
	for (const item of b) set.add(item);
	if (set.size === a.size) return a;
	return set;
};
module.exports.mergeRuntime = mergeRuntime;

/**
 * @param {RuntimeCondition} a first
 * @param {RuntimeCondition} b second
 * @param {RuntimeSpec} runtime full runtime
 * @returns {RuntimeCondition} result
 */
module.exports.mergeRuntimeCondition = (a, b, runtime) =&gt; {
	if (a === false) return b;
	if (b === false) return a;
	if (a === true || b === true) return true;
	const merged = mergeRuntime(a, b);
	if (merged === undefined) return;
	if (typeof merged === &quot;string&quot;) {
		if (typeof runtime === &quot;string&quot; &amp;&amp; merged === runtime) return true;
		return merged;
	}
	if (typeof runtime === &quot;string&quot; || runtime === undefined) return merged;
	if (merged.size === runtime.size) return true;
	return merged;
};

/**
 * @param {RuntimeSpec | true} a first
 * @param {RuntimeSpec | true} b second
 * @param {RuntimeSpec} runtime full runtime
 * @returns {RuntimeSpec | true} result
 */
module.exports.mergeRuntimeConditionNonFalse = (a, b, runtime) =&gt; {
	if (a === true || b === true) return true;
	const merged = mergeRuntime(a, b);
	if (merged === undefined) return;
	if (typeof merged === &quot;string&quot;) {
		if (typeof runtime === &quot;string&quot; &amp;&amp; merged === runtime) return true;
		return merged;
	}
	if (typeof runtime === &quot;string&quot; || runtime === undefined) return merged;
	if (merged.size === runtime.size) return true;
	return merged;
};

/**
 * @param {RuntimeSpec} a first (may be modified)
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} merged
 */
const mergeRuntimeOwned = (a, b) =&gt; {
	if (b === undefined) {
		return a;
	} else if (a === b) {
		return a;
	} else if (a === undefined) {
		if (typeof b === &quot;string&quot;) {
			return b;
		}
		return new SortableSet(b);
	} else if (typeof a === &quot;string&quot;) {
		if (typeof b === &quot;string&quot;) {
			const set = new SortableSet();
			set.add(a);
			set.add(b);
			return set;
		}
		const set = new SortableSet(b);
		set.add(a);
		return set;
	}
	if (typeof b === &quot;string&quot;) {
		a.add(b);
		return a;
	}
	for (const item of b) a.add(item);
	return a;
};
module.exports.mergeRuntimeOwned = mergeRuntimeOwned;

/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} merged
 */
module.exports.intersectRuntime = (a, b) =&gt; {
	if (a === undefined) {
		return b;
	} else if (b === undefined) {
		return a;
	} else if (a === b) {
		return a;
	} else if (typeof a === &quot;string&quot;) {
		if (typeof b === &quot;string&quot;) {
			return;
		} else if (b.has(a)) {
			return a;
		}
		return;
	}
	if (typeof b === &quot;string&quot;) {
		if (a.has(b)) return b;
		return;
	}
	const set = new SortableSet();
	for (const item of b) {
		if (a.has(item)) set.add(item);
	}
	if (set.size === 0) return;
	if (set.size === 1) {
		const [item] = set;
		return item;
	}
	return set;
};

/**
 * @param {RuntimeSpec} a first
 * @param {RuntimeSpec} b second
 * @returns {RuntimeSpec} result
 */
const subtractRuntime = (a, b) =&gt; {
	if (a === undefined) {
		return;
	} else if (b === undefined) {
		return a;
	} else if (a === b) {
		return;
	} else if (typeof a === &quot;string&quot;) {
		if (typeof b === &quot;string&quot;) {
			return a;
		} else if (b.has(a)) {
			return;
		}
		return a;
	}
	if (typeof b === &quot;string&quot;) {
		if (!a.has(b)) return a;
		if (a.size === 2) {
			for (const item of a) {
				if (item !== b) return item;
			}
		}
		const set = new SortableSet(a);
		set.delete(b);
		return set;
	}
	const set = new SortableSet();
	for (const item of a) {
		if (!b.has(item)) set.add(item);
	}
	if (set.size === 0) return;
	if (set.size === 1) {
		const [item] = set;
		return item;
	}
	return set;
};
module.exports.subtractRuntime = subtractRuntime;

/**
 * @param {RuntimeCondition} a first
 * @param {RuntimeCondition} b second
 * @param {RuntimeSpec} runtime runtime
 * @returns {RuntimeCondition} result
 */
module.exports.subtractRuntimeCondition = (a, b, runtime) =&gt; {
	if (b === true) return false;
	if (b === false) return a;
	if (a === false) return false;
	const result = subtractRuntime(a === true ? runtime : a, b);
	return result === undefined ? false : result;
};

/**
 * @param {RuntimeSpec} runtime runtime
 * @param {(runtime?: RuntimeSpec) =&gt; boolean} filter filter function
 * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active
 */
module.exports.filterRuntime = (runtime, filter) =&gt; {
	if (runtime === undefined) return filter();
	if (typeof runtime === &quot;string&quot;) return filter(runtime);
	let some = false;
	let every = true;
	let result;
	for (const r of runtime) {
		const v = filter(r);
		if (v) {
			some = true;
			result = mergeRuntimeOwned(result, r);
		} else {
			every = false;
		}
	}
	if (!some) return false;
	if (every) return true;
	return result;
};

/**
 * @template T
 * @typedef {Map&lt;string, T&gt;} RuntimeSpecMapInnerMap
 */

/**
 * @template T
 * @template [R=T]
 */
class RuntimeSpecMap {
	/**
	 * @param {RuntimeSpecMap&lt;T, R&gt;=} clone copy form this
	 */
	constructor(clone) {
		/** @type {0 | 1 | 2} */
		this._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map
		/** @type {RuntimeSpec} */
		this._singleRuntime = clone ? clone._singleRuntime : undefined;
		/** @type {R | undefined} */
		this._singleValue = clone ? clone._singleValue : undefined;
		/** @type {RuntimeSpecMapInnerMap&lt;R&gt; | undefined} */
		this._map = clone &amp;&amp; clone._map ? new Map(clone._map) : undefined;
	}

	/**
	 * @param {RuntimeSpec} runtime the runtimes
	 * @returns {R | undefined} value
	 */
	get(runtime) {
		switch (this._mode) {
			case 0:
				return;
			case 1:
				return runtimeEqual(this._singleRuntime, runtime)
					? this._singleValue
					: undefined;
			default:
				return /** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */ (this._map).get(
					getRuntimeKey(runtime)
				);
		}
	}

	/**
	 * @param {RuntimeSpec} runtime the runtimes
	 * @returns {boolean} true, when the runtime is stored
	 */
	has(runtime) {
		switch (this._mode) {
			case 0:
				return false;
			case 1:
				return runtimeEqual(this._singleRuntime, runtime);
			default:
				return /** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */ (this._map).has(
					getRuntimeKey(runtime)
				);
		}
	}

	/**
	 * @param {RuntimeSpec} runtime the runtimes
	 * @param {R} value the value
	 */
	set(runtime, value) {
		switch (this._mode) {
			case 0:
				this._mode = 1;
				this._singleRuntime = runtime;
				this._singleValue = value;
				break;
			case 1:
				if (runtimeEqual(this._singleRuntime, runtime)) {
					this._singleValue = value;
					break;
				}
				this._mode = 2;
				this._map = new Map();
				this._map.set(
					getRuntimeKey(this._singleRuntime),
					/** @type {R} */ (this._singleValue)
				);
				this._singleRuntime = undefined;
				this._singleValue = undefined;
			/* falls through */
			default:
				/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
				(this._map).set(getRuntimeKey(runtime), value);
		}
	}

	/**
	 * @param {RuntimeSpec} runtime the runtimes
	 * @param {() =&gt; R} computer function to compute the value
	 * @returns {R} the new value
	 */
	provide(runtime, computer) {
		switch (this._mode) {
			case 0:
				this._mode = 1;
				this._singleRuntime = runtime;
				return (this._singleValue = computer());
			case 1: {
				if (runtimeEqual(this._singleRuntime, runtime)) {
					return /** @type {R} */ (this._singleValue);
				}
				this._mode = 2;
				this._map = new Map();
				this._map.set(
					getRuntimeKey(this._singleRuntime),
					/** @type {R} */
					(this._singleValue)
				);
				this._singleRuntime = undefined;
				this._singleValue = undefined;
				const newValue = computer();
				this._map.set(getRuntimeKey(runtime), newValue);
				return newValue;
			}
			default: {
				const key = getRuntimeKey(runtime);
				const value =
					/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
					(this._map).get(key);
				if (value !== undefined) return value;
				const newValue = computer();
				/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
				(this._map).set(key, newValue);
				return newValue;
			}
		}
	}

	/**
	 * @param {RuntimeSpec} runtime the runtimes
	 */
	delete(runtime) {
		switch (this._mode) {
			case 0:
				return;
			case 1:
				if (runtimeEqual(this._singleRuntime, runtime)) {
					this._mode = 0;
					this._singleRuntime = undefined;
					this._singleValue = undefined;
				}
				return;
			default:
				/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
				(this._map).delete(getRuntimeKey(runtime));
		}
	}

	/**
	 * @param {RuntimeSpec} runtime the runtimes
	 * @param {(value: R | undefined) =&gt; R} fn function to update the value
	 */
	update(runtime, fn) {
		switch (this._mode) {
			case 0:
				throw new Error(&quot;runtime passed to update must exist&quot;);
			case 1: {
				if (runtimeEqual(this._singleRuntime, runtime)) {
					this._singleValue = fn(this._singleValue);
					break;
				}
				const newValue = fn(undefined);
				if (newValue !== undefined) {
					this._mode = 2;
					this._map = new Map();
					this._map.set(
						getRuntimeKey(this._singleRuntime),
						/** @type {R} */
						(this._singleValue)
					);
					this._singleRuntime = undefined;
					this._singleValue = undefined;
					this._map.set(getRuntimeKey(runtime), newValue);
				}
				break;
			}
			default: {
				const key = getRuntimeKey(runtime);
				const oldValue =
					/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
					(this._map).get(key);
				const newValue = fn(oldValue);
				if (newValue !== oldValue)
					/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
					(this._map).set(key, newValue);
			}
		}
	}

	keys() {
		switch (this._mode) {
			case 0:
				return [];
			case 1:
				return [this._singleRuntime];
			default:
				return Array.from(
					/** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */
					(this._map).keys(),
					keyToRuntime
				);
		}
	}

	/**
	 * @returns {IterableIterator&lt;R&gt;} values
	 */
	values() {
		switch (this._mode) {
			case 0:
				return [][Symbol.iterator]();
			case 1:
				return [/** @type {R} */ (this._singleValue)][Symbol.iterator]();
			default:
				return /** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */ (this._map).values();
		}
	}

	get size() {
		if (/** @type {number} */ (this._mode) &lt;= 1) {
			return /** @type {number} */ (this._mode);
		}

		return /** @type {RuntimeSpecMapInnerMap&lt;R&gt;} */ (this._map).size;
	}
}

module.exports.RuntimeSpecMap = RuntimeSpecMap;

class RuntimeSpecSet {
	/**
	 * @param {Iterable&lt;RuntimeSpec&gt;=} iterable iterable
	 */
	constructor(iterable) {
		/** @type {Map&lt;string, RuntimeSpec&gt;} */
		this._map = new Map();
		if (iterable) {
			for (const item of iterable) {
				this.add(item);
			}
		}
	}

	/**
	 * @param {RuntimeSpec} runtime runtime
	 */
	add(runtime) {
		this._map.set(getRuntimeKey(runtime), runtime);
	}

	/**
	 * @param {RuntimeSpec} runtime runtime
	 * @returns {boolean} true, when the runtime exists
	 */
	has(runtime) {
		return this._map.has(getRuntimeKey(runtime));
	}

	/**
	 * @returns {IterableIterator&lt;RuntimeSpec&gt;} iterable iterator
	 */
	[Symbol.iterator]() {
		return this._map.values();
	}

	get size() {
		return this._map.size;
	}
}

module.exports.RuntimeSpecSet = RuntimeSpecSet;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
