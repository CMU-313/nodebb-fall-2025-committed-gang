<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rule-tester/rule-tester.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rule-tester/rule-tester.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1580</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">89.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Mocha/Jest test wrapper
 * @author Ilya Volodin
 */
&quot;use strict&quot;;

/* globals describe, it -- Mocha globals */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const assert = require(&quot;node:assert&quot;),
	util = require(&quot;node:util&quot;),
	path = require(&quot;node:path&quot;),
	equal = require(&quot;fast-deep-equal&quot;),
	Traverser = require(&quot;../shared/traverser&quot;),
	{ Config } = require(&quot;../config/config&quot;),
	{ Linter, SourceCodeFixer } = require(&quot;../linter&quot;),
	{ interpolate, getPlaceholderMatcher } = require(&quot;../linter/interpolate&quot;),
	stringify = require(&quot;json-stable-stringify-without-jsonify&quot;);

const { FlatConfigArray } = require(&quot;../config/flat-config-array&quot;);
const {
	defaultConfig,
	defaultRuleTesterConfig,
} = require(&quot;../config/default-config&quot;);

const ajv = require(&quot;../shared/ajv&quot;)({ strictDefaults: true });

const parserSymbol = Symbol.for(&quot;eslint.RuleTester.parser&quot;);
const { ConfigArraySymbol } = require(&quot;@eslint/config-array&quot;);
const { isSerializable } = require(&quot;../shared/serialization&quot;);

const jslang = require(&quot;../languages/js&quot;);
const { SourceCode } = require(&quot;../languages/js/source-code&quot;);

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @import { LanguageOptions, RuleDefinition } from &quot;@eslint/core&quot; */

/** @typedef {import(&quot;../types&quot;).Linter.Parser} Parser */

/**
 * A test case that is expected to pass lint.
 * @typedef {Object} ValidTestCase
 * @property {string} [name] Name for the test case.
 * @property {string} code Code for the test case.
 * @property {any[]} [options] Options for the test case.
 * @property {Function} [before] Function to execute before testing the case.
 * @property {Function} [after] Function to execute after testing the case regardless of its result.
 * @property {LanguageOptions} [languageOptions] The language options to use in the test case.
 * @property {{ [name: string]: any }} [settings] Settings for the test case.
 * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.
 * @property {boolean} [only] Run only this test case or the subset of test cases with this property.
 */

/**
 * A test case that is expected to fail lint.
 * @typedef {Object} InvalidTestCase
 * @property {string} [name] Name for the test case.
 * @property {string} code Code for the test case.
 * @property {number | Array&lt;TestCaseError | string | RegExp&gt;} errors Expected errors.
 * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.
 * @property {any[]} [options] Options for the test case.
 * @property {Function} [before] Function to execute before testing the case.
 * @property {Function} [after] Function to execute after testing the case regardless of its result.
 * @property {{ [name: string]: any }} [settings] Settings for the test case.
 * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.
 * @property {LanguageOptions} [languageOptions] The language options to use in the test case.
 * @property {boolean} [only] Run only this test case or the subset of test cases with this property.
 */

/**
 * A description of a reported error used in a rule tester test.
 * @typedef {Object} TestCaseError
 * @property {string | RegExp} [message] Message.
 * @property {string} [messageId] Message ID.
 * @property {string} [type] The type of the reported AST node.
 * @property {{ [name: string]: string }} [data] The data used to fill the message template.
 * @property {number} [line] The 1-based line number of the reported start location.
 * @property {number} [column] The 1-based column number of the reported start location.
 * @property {number} [endLine] The 1-based line number of the reported end location.
 * @property {number} [endColumn] The 1-based column number of the reported end location.
 */

//------------------------------------------------------------------------------
// Private Members
//------------------------------------------------------------------------------

/*
 * testerDefaultConfig must not be modified as it allows to reset the tester to
 * the initial default configuration
 */
const testerDefaultConfig = { rules: {} };

/*
 * RuleTester uses this config as its default. This can be overwritten via
 * setDefaultConfig().
 */
let sharedDefaultConfig = { rules: {} };

/*
 * List every parameters possible on a test case that are not related to eslint
 * configuration
 */
const RuleTesterParameters = [
	&quot;name&quot;,
	&quot;code&quot;,
	&quot;filename&quot;,
	&quot;options&quot;,
	&quot;before&quot;,
	&quot;after&quot;,
	&quot;errors&quot;,
	&quot;output&quot;,
	&quot;only&quot;,
];

/*
 * All allowed property names in error objects.
 */
const errorObjectParameters = new Set([
	&quot;message&quot;,
	&quot;messageId&quot;,
	&quot;data&quot;,
	&quot;type&quot;,
	&quot;line&quot;,
	&quot;column&quot;,
	&quot;endLine&quot;,
	&quot;endColumn&quot;,
	&quot;suggestions&quot;,
]);
const friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key =&gt; `&#039;${key}&#039;`).join(&quot;, &quot;)}]`;

/*
 * All allowed property names in suggestion objects.
 */
const suggestionObjectParameters = new Set([
	&quot;desc&quot;,
	&quot;messageId&quot;,
	&quot;data&quot;,
	&quot;output&quot;,
]);
const friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key =&gt; `&#039;${key}&#039;`).join(&quot;, &quot;)}]`;

/*
 * Ignored test case properties when checking for test case duplicates.
 */
const duplicationIgnoredParameters = new Set([&quot;name&quot;, &quot;errors&quot;, &quot;output&quot;]);

const forbiddenMethods = [
	&quot;applyInlineConfig&quot;,
	&quot;applyLanguageOptions&quot;,
	&quot;finalize&quot;,
];

/** @type {Map&lt;string,WeakSet&gt;} */
const forbiddenMethodCalls = new Map(
	forbiddenMethods.map(methodName =&gt; [methodName, new WeakSet()]),
);

const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);

/**
 * Clones a given value deeply.
 * Note: This ignores `parent` property.
 * @param {any} x A value to clone.
 * @returns {any} A cloned value.
 */
function cloneDeeplyExcludesParent(x) {
	if (typeof x === &quot;object&quot; &amp;&amp; x !== null) {
		if (Array.isArray(x)) {
			return x.map(cloneDeeplyExcludesParent);
		}

		const retv = {};

		for (const key in x) {
			if (key !== &quot;parent&quot; &amp;&amp; hasOwnProperty(x, key)) {
				retv[key] = cloneDeeplyExcludesParent(x[key]);
			}
		}

		return retv;
	}

	return x;
}

/**
 * Freezes a given value deeply.
 * @param {any} x A value to freeze.
 * @param {Set&lt;Object&gt;} seenObjects Objects already seen during the traversal.
 * @returns {void}
 */
function freezeDeeply(x, seenObjects = new Set()) {
	if (typeof x === &quot;object&quot; &amp;&amp; x !== null) {
		if (seenObjects.has(x)) {
			return; // skip to avoid infinite recursion
		}
		seenObjects.add(x);

		if (Array.isArray(x)) {
			x.forEach(element =&gt; {
				freezeDeeply(element, seenObjects);
			});
		} else {
			for (const key in x) {
				if (key !== &quot;parent&quot; &amp;&amp; hasOwnProperty(x, key)) {
					freezeDeeply(x[key], seenObjects);
				}
			}
		}
		Object.freeze(x);
	}
}

/**
 * Replace control characters by `\u00xx` form.
 * @param {string} text The text to sanitize.
 * @returns {string} The sanitized text.
 */
function sanitize(text) {
	if (typeof text !== &quot;string&quot;) {
		return &quot;&quot;;
	}
	return text.replace(
		/[\u0000-\u0009\u000b-\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls
		c =&gt; `\\u${c.codePointAt(0).toString(16).padStart(4, &quot;0&quot;)}`,
	);
}

/**
 * Define `start`/`end` properties as throwing error.
 * @param {string} objName Object name used for error messages.
 * @param {ASTNode} node The node to define.
 * @returns {void}
 */
function defineStartEndAsError(objName, node) {
	Object.defineProperties(node, {
		start: {
			get() {
				throw new Error(
					`Use ${objName}.range[0] instead of ${objName}.start`,
				);
			},
			configurable: true,
			enumerable: false,
		},
		end: {
			get() {
				throw new Error(
					`Use ${objName}.range[1] instead of ${objName}.end`,
				);
			},
			configurable: true,
			enumerable: false,
		},
	});
}

/**
 * Define `start`/`end` properties of all nodes of the given AST as throwing error.
 * @param {ASTNode} ast The root node to errorize `start`/`end` properties.
 * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.
 * @returns {void}
 */
function defineStartEndAsErrorInTree(ast, visitorKeys) {
	Traverser.traverse(ast, {
		visitorKeys,
		enter: defineStartEndAsError.bind(null, &quot;node&quot;),
	});
	ast.tokens.forEach(defineStartEndAsError.bind(null, &quot;token&quot;));
	ast.comments.forEach(defineStartEndAsError.bind(null, &quot;token&quot;));
}

/**
 * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.
 * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.
 * @param {Parser} parser Parser object.
 * @returns {Parser} Wrapped parser object.
 */
function wrapParser(parser) {
	if (typeof parser.parseForESLint === &quot;function&quot;) {
		return {
			[parserSymbol]: parser,
			parseForESLint(...args) {
				const ret = parser.parseForESLint(...args);

				defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);
				return ret;
			},
		};
	}

	return {
		[parserSymbol]: parser,
		parse(...args) {
			const ast = parser.parse(...args);

			defineStartEndAsErrorInTree(ast);
			return ast;
		},
	};
}

/**
 * Function to replace forbidden `SourceCode` methods. Allows just one call per method.
 * @param {string} methodName The name of the method to forbid.
 * @param {Function} prototype The prototype with the original method to call.
 * @returns {Function} The function that throws the error.
 */
function throwForbiddenMethodError(methodName, prototype) {
	const original = prototype[methodName];

	return function (...args) {
		const called = forbiddenMethodCalls.get(methodName);

		/* eslint-disable no-invalid-this -- needed to operate as a method. */
		if (!called.has(this)) {
			called.add(this);

			return original.apply(this, args);
		}
		/* eslint-enable no-invalid-this -- not needed past this point */

		throw new Error(
			`\`SourceCode#${methodName}()\` cannot be called inside a rule.`,
		);
	};
}

/**
 * Extracts names of {{ placeholders }} from the reported message.
 * @param   {string} message Reported message
 * @returns {string[]} Array of placeholder names
 */
function getMessagePlaceholders(message) {
	const matcher = getPlaceholderMatcher();

	return Array.from(message.matchAll(matcher), ([, name]) =&gt; name.trim());
}

/**
 * Returns the placeholders in the reported messages but
 * only includes the placeholders available in the raw message and not in the provided data.
 * @param {string} message The reported message
 * @param {string} raw The raw message specified in the rule meta.messages
 * @param {undefined|Record&lt;unknown, unknown&gt;} data The passed
 * @returns {string[]} Missing placeholder names
 */
function getUnsubstitutedMessagePlaceholders(message, raw, data = {}) {
	const unsubstituted = getMessagePlaceholders(message);

	if (unsubstituted.length === 0) {
		return [];
	}

	// Remove false positives by only counting placeholders in the raw message, which were not provided in the data matcher or added with a data property
	const known = getMessagePlaceholders(raw);
	const provided = Object.keys(data);

	return unsubstituted.filter(
		name =&gt; known.includes(name) &amp;&amp; !provided.includes(name),
	);
}

const metaSchemaDescription = `
\t- If the rule has options, set \`meta.schema\` to an array or non-empty object to enable options validation.
\t- If the rule doesn&#039;t have options, omit \`meta.schema\` to enforce that no options can be passed to the rule.
\t- You can also set \`meta.schema\` to \`false\` to opt-out of options validation (not recommended).

\thttps://eslint.org/docs/latest/extend/custom-rules#options-schemas
`;

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

// default separators for testing
const DESCRIBE = Symbol(&quot;describe&quot;);
const IT = Symbol(&quot;it&quot;);
const IT_ONLY = Symbol(&quot;itOnly&quot;);

/**
 * This is `it` default handler if `it` don&#039;t exist.
 * @this {Mocha}
 * @param {string} text The description of the test case.
 * @param {Function} method The logic of the test case.
 * @throws {Error} Any error upon execution of `method`.
 * @returns {any} Returned value of `method`.
 */
function itDefaultHandler(text, method) {
	try {
		return method.call(this);
	} catch (err) {
		if (err instanceof assert.AssertionError) {
			err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;
		}
		throw err;
	}
}

/**
 * This is `describe` default handler if `describe` don&#039;t exist.
 * @this {Mocha}
 * @param {string} text The description of the test case.
 * @param {Function} method The logic of the test case.
 * @returns {any} Returned value of `method`.
 */
function describeDefaultHandler(text, method) {
	return method.call(this);
}

/**
 * Mocha test wrapper.
 */
class RuleTester {
	/**
	 * Creates a new instance of RuleTester.
	 * @param {Object} [testerConfig] Optional, extra configuration for the tester
	 */
	constructor(testerConfig = {}) {
		/**
		 * The configuration to use for this tester. Combination of the tester
		 * configuration and the default configuration.
		 * @type {Object}
		 */
		this.testerConfig = [
			sharedDefaultConfig,
			testerConfig,
			{ rules: { &quot;rule-tester/validate-ast&quot;: &quot;error&quot; } },
		];

		this.linter = new Linter({ configType: &quot;flat&quot; });
	}

	/**
	 * Set the configuration to use for all future tests
	 * @param {Object} config the configuration to use.
	 * @throws {TypeError} If non-object config.
	 * @returns {void}
	 */
	static setDefaultConfig(config) {
		if (typeof config !== &quot;object&quot; || config === null) {
			throw new TypeError(
				&quot;RuleTester.setDefaultConfig: config must be an object&quot;,
			);
		}
		sharedDefaultConfig = config;

		// Make sure the rules object exists since it is assumed to exist later
		sharedDefaultConfig.rules = sharedDefaultConfig.rules || {};
	}

	/**
	 * Get the current configuration used for all tests
	 * @returns {Object} the current configuration
	 */
	static getDefaultConfig() {
		return sharedDefaultConfig;
	}

	/**
	 * Reset the configuration to the initial configuration of the tester removing
	 * any changes made until now.
	 * @returns {void}
	 */
	static resetDefaultConfig() {
		sharedDefaultConfig = {
			rules: {
				...testerDefaultConfig.rules,
			},
		};
	}

	/*
	 * If people use `mocha test.js --watch` command, `describe` and `it` function
	 * instances are different for each execution. So `describe` and `it` should get fresh instance
	 * always.
	 */
	static get describe() {
		return (
			this[DESCRIBE] ||
			(typeof describe === &quot;function&quot; ? describe : describeDefaultHandler)
		);
	}

	static set describe(value) {
		this[DESCRIBE] = value;
	}

	static get it() {
		return this[IT] || (typeof it === &quot;function&quot; ? it : itDefaultHandler);
	}

	static set it(value) {
		this[IT] = value;
	}

	/**
	 * Adds the `only` property to a test to run it in isolation.
	 * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.
	 * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.
	 */
	static only(item) {
		if (typeof item === &quot;string&quot;) {
			return { code: item, only: true };
		}

		return { ...item, only: true };
	}

	static get itOnly() {
		if (typeof this[IT_ONLY] === &quot;function&quot;) {
			return this[IT_ONLY];
		}
		if (
			typeof this[IT] === &quot;function&quot; &amp;&amp;
			typeof this[IT].only === &quot;function&quot;
		) {
			return Function.bind.call(this[IT].only, this[IT]);
		}
		if (typeof it === &quot;function&quot; &amp;&amp; typeof it.only === &quot;function&quot;) {
			return Function.bind.call(it.only, it);
		}

		if (
			typeof this[DESCRIBE] === &quot;function&quot; ||
			typeof this[IT] === &quot;function&quot;
		) {
			throw new Error(
				&quot;Set `RuleTester.itOnly` to use `only` with a custom test framework.\n&quot; +
					&quot;See https://eslint.org/docs/latest/integrate/nodejs-api#customizing-ruletester for more.&quot;,
			);
		}
		if (typeof it === &quot;function&quot;) {
			throw new Error(
				&quot;The current test framework does not support exclusive tests with `only`.&quot;,
			);
		}
		throw new Error(
			&quot;To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.&quot;,
		);
	}

	static set itOnly(value) {
		this[IT_ONLY] = value;
	}

	/**
	 * Adds a new rule test to execute.
	 * @param {string} ruleName The name of the rule to run.
	 * @param {RuleDefinition} rule The rule to test.
	 * @param {{
	 *   valid: (ValidTestCase | string)[],
	 *   invalid: InvalidTestCase[]
	 * }} test The collection of tests to run.
	 * @throws {TypeError|Error} If `rule` is not an object with a `create` method,
	 * or if non-object `test`, or if a required scenario of the given type is missing.
	 * @returns {void}
	 */
	run(ruleName, rule, test) {
		const testerConfig = this.testerConfig,
			requiredScenarios = [&quot;valid&quot;, &quot;invalid&quot;],
			scenarioErrors = [],
			linter = this.linter,
			ruleId = `rule-to-test/${ruleName}`;

		const seenValidTestCases = new Set();
		const seenInvalidTestCases = new Set();

		if (
			!rule ||
			typeof rule !== &quot;object&quot; ||
			typeof rule.create !== &quot;function&quot;
		) {
			throw new TypeError(
				&quot;Rule must be an object with a `create` method&quot;,
			);
		}

		if (!test || typeof test !== &quot;object&quot;) {
			throw new TypeError(
				`Test Scenarios for rule ${ruleName} : Could not find test scenario object`,
			);
		}

		requiredScenarios.forEach(scenarioType =&gt; {
			if (!test[scenarioType]) {
				scenarioErrors.push(
					`Could not find any ${scenarioType} test scenarios`,
				);
			}
		});

		if (scenarioErrors.length &gt; 0) {
			throw new Error(
				[`Test Scenarios for rule ${ruleName} is invalid:`]
					.concat(scenarioErrors)
					.join(&quot;\n&quot;),
			);
		}

		const baseConfig = [
			{
				plugins: {
					// copy root plugin over
					&quot;@&quot;: {
						/*
						 * Parsers are wrapped to detect more errors, so this needs
						 * to be a new object for each call to run(), otherwise the
						 * parsers will be wrapped multiple times.
						 */
						parsers: {
							...defaultConfig[0].plugins[&quot;@&quot;].parsers,
						},

						/*
						 * The rules key on the default plugin is a proxy to lazy-load
						 * just the rules that are needed. So, don&#039;t create a new object
						 * here, just use the default one to keep that performance
						 * enhancement.
						 */
						rules: defaultConfig[0].plugins[&quot;@&quot;].rules,
						languages: defaultConfig[0].plugins[&quot;@&quot;].languages,
					},
					&quot;rule-to-test&quot;: {
						rules: {
							[ruleName]: Object.assign({}, rule, {
								// Create a wrapper rule that freezes the `context` properties.
								create(context) {
									freezeDeeply(context.options);
									freezeDeeply(context.settings);
									freezeDeeply(context.parserOptions);

									// freezeDeeply(context.languageOptions);

									return rule.create(context);
								},
							}),
						},
					},
				},
				language: defaultConfig[0].language,
			},
			...defaultRuleTesterConfig,
		];

		/**
		 * Runs a hook on the given item when it&#039;s assigned to the given property
		 * @param {string|Object} item Item to run the hook on
		 * @param {string} prop The property having the hook assigned to
		 * @throws {Error} If the property is not a function or that function throws an error
		 * @returns {void}
		 * @private
		 */
		function runHook(item, prop) {
			if (typeof item === &quot;object&quot; &amp;&amp; hasOwnProperty(item, prop)) {
				assert.strictEqual(
					typeof item[prop],
					&quot;function&quot;,
					`Optional test case property &#039;${prop}&#039; must be a function`,
				);
				item[prop]();
			}
		}

		/**
		 * Run the rule for the given item
		 * @param {string|Object} item Item to run the rule against
		 * @throws {Error} If an invalid schema.
		 * @returns {Object} Eslint run result
		 * @private
		 */
		function runRuleForItem(item) {
			const flatConfigArrayOptions = {
				baseConfig,
			};

			if (item.filename) {
				flatConfigArrayOptions.basePath =
					path.parse(item.filename).root || void 0;
			}

			const configs = new FlatConfigArray(
				testerConfig,
				flatConfigArrayOptions,
			);

			/*
			 * Modify the returned config so that the parser is wrapped to catch
			 * access of the start/end properties. This method is called just
			 * once per code snippet being tested, so each test case gets a clean
			 * parser.
			 */
			configs[ConfigArraySymbol.finalizeConfig] = function (...args) {
				// can&#039;t do super here :(
				const proto = Object.getPrototypeOf(this);
				const calculatedConfig = proto[
					ConfigArraySymbol.finalizeConfig
				].apply(this, args);

				// wrap the parser to catch start/end property access
				if (calculatedConfig.language === jslang) {
					calculatedConfig.languageOptions.parser = wrapParser(
						calculatedConfig.languageOptions.parser,
					);
				}

				return calculatedConfig;
			};

			let code, filename, output, beforeAST, afterAST;

			if (typeof item === &quot;string&quot;) {
				code = item;
			} else {
				code = item.code;

				/*
				 * Assumes everything on the item is a config except for the
				 * parameters used by this tester
				 */
				const itemConfig = { ...item };

				for (const parameter of RuleTesterParameters) {
					delete itemConfig[parameter];
				}

				/*
				 * Create the config object from the tester config and this item
				 * specific configurations.
				 */
				configs.push(itemConfig);
			}

			if (hasOwnProperty(item, &quot;only&quot;)) {
				assert.ok(
					typeof item.only === &quot;boolean&quot;,
					&quot;Optional test case property &#039;only&#039; must be a boolean&quot;,
				);
			}
			if (hasOwnProperty(item, &quot;filename&quot;)) {
				assert.ok(
					typeof item.filename === &quot;string&quot;,
					&quot;Optional test case property &#039;filename&#039; must be a string&quot;,
				);
				filename = item.filename;
			}

			let ruleConfig = 1;

			if (hasOwnProperty(item, &quot;options&quot;)) {
				assert(Array.isArray(item.options), &quot;options must be an array&quot;);
				ruleConfig = [1, ...item.options];
			}

			configs.push({
				rules: {
					[ruleId]: ruleConfig,
				},
			});

			let schema;

			try {
				schema = Config.getRuleOptionsSchema(rule);
			} catch (err) {
				err.message += metaSchemaDescription;
				throw err;
			}

			/*
			 * Check and throw an error if the schema is an empty object (`schema:{}`), because such schema
			 * doesn&#039;t validate or enforce anything and is therefore considered a possible error. If the intent
			 * was to skip options validation, `schema:false` should be set instead (explicit opt-out).
			 *
			 * For this purpose, a schema object is considered empty if it doesn&#039;t have any own enumerable string-keyed
			 * properties. While `ajv.compile()` does use enumerable properties from the prototype chain as well,
			 * it caches compiled schemas by serializing only own enumerable properties, so it&#039;s generally not a good idea
			 * to use inherited properties in schemas because schemas that differ only in inherited properties would end up
			 * having the same cache entry that would be correct for only one of them.
			 *
			 * At this point, `schema` can only be an object or `null`.
			 */
			if (schema &amp;&amp; Object.keys(schema).length === 0) {
				throw new Error(
					`\`schema: {}\` is a no-op${metaSchemaDescription}`,
				);
			}

			/*
			 * Setup AST getters.
			 * The goal is to check whether or not AST was modified when
			 * running the rule under test.
			 */
			configs.push({
				plugins: {
					&quot;rule-tester&quot;: {
						rules: {
							&quot;validate-ast&quot;: {
								create() {
									return {
										Program(node) {
											beforeAST =
												cloneDeeplyExcludesParent(node);
										},
										&quot;Program:exit&quot;(node) {
											afterAST = node;
										},
									};
								},
							},
						},
					},
				},
			});

			if (schema) {
				ajv.validateSchema(schema);

				if (ajv.errors) {
					const errors = ajv.errors
						.map(error =&gt; {
							const field =
								error.dataPath[0] === &quot;.&quot;
									? error.dataPath.slice(1)
									: error.dataPath;

							return `\t${field}: ${error.message}`;
						})
						.join(&quot;\n&quot;);

					throw new Error([
						`Schema for rule ${ruleName} is invalid:`,
						errors,
					]);
				}

				/*
				 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a &quot;meta-schema&quot;),
				 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling
				 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,
				 * the schema is compiled here separately from checking for `validateSchema` errors.
				 */
				try {
					ajv.compile(schema);
				} catch (err) {
					throw new Error(
						`Schema for rule ${ruleName} is invalid: ${err.message}`,
						{
							cause: err,
						},
					);
				}
			}

			// check for validation errors
			try {
				configs.normalizeSync();
				configs.getConfig(&quot;test.js&quot;);
			} catch (error) {
				error.message = `ESLint configuration in rule-tester is invalid: ${error.message}`;
				throw error;
			}

			// Verify the code.
			const { applyLanguageOptions, applyInlineConfig, finalize } =
				SourceCode.prototype;
			let messages;

			try {
				forbiddenMethods.forEach(methodName =&gt; {
					SourceCode.prototype[methodName] =
						throwForbiddenMethodError(
							methodName,
							SourceCode.prototype,
						);
				});

				messages = linter.verify(code, configs, filename);
			} finally {
				SourceCode.prototype.applyInlineConfig = applyInlineConfig;
				SourceCode.prototype.applyLanguageOptions =
					applyLanguageOptions;
				SourceCode.prototype.finalize = finalize;
			}

			const fatalErrorMessage = messages.find(m =&gt; m.fatal);

			assert(
				!fatalErrorMessage,
				`A fatal parsing error occurred: ${fatalErrorMessage &amp;&amp; fatalErrorMessage.message}`,
			);

			// Verify if autofix makes a syntax error or not.
			if (messages.some(m =&gt; m.fix)) {
				output = SourceCodeFixer.applyFixes(code, messages).output;
				const errorMessageInFix = linter
					.verify(output, configs, filename)
					.find(m =&gt; m.fatal);

				assert(
					!errorMessageInFix,
					[
						&quot;A fatal parsing error occurred in autofix.&quot;,
						`Error: ${errorMessageInFix &amp;&amp; errorMessageInFix.message}`,
						&quot;Autofix output:&quot;,
						output,
					].join(&quot;\n&quot;),
				);
			} else {
				output = code;
			}

			return {
				messages,
				output,
				beforeAST,
				afterAST: cloneDeeplyExcludesParent(afterAST),
				configs,
				filename,
			};
		}

		/**
		 * Check if the AST was changed
		 * @param {ASTNode} beforeAST AST node before running
		 * @param {ASTNode} afterAST AST node after running
		 * @returns {void}
		 * @private
		 */
		function assertASTDidntChange(beforeAST, afterAST) {
			if (!equal(beforeAST, afterAST)) {
				assert.fail(&quot;Rule should not modify AST.&quot;);
			}
		}

		/**
		 * Check if this test case is a duplicate of one we have seen before.
		 * @param {string|Object} item test case object
		 * @param {Set&lt;string&gt;} seenTestCases set of serialized test cases we have seen so far (managed by this function)
		 * @returns {void}
		 * @private
		 */
		function checkDuplicateTestCase(item, seenTestCases) {
			if (!isSerializable(item)) {
				/*
				 * If we can&#039;t serialize a test case (because it contains a function, RegExp, etc), skip the check.
				 * This might happen with properties like: options, plugins, settings, languageOptions.parser, languageOptions.parserOptions.
				 */
				return;
			}

			const normalizedItem =
				typeof item === &quot;string&quot; ? { code: item } : item;
			const serializedTestCase = stringify(normalizedItem, {
				replacer(key, value) {
					// &quot;this&quot; is the currently stringified object --&gt; only ignore top-level properties
					return normalizedItem !== this ||
						!duplicationIgnoredParameters.has(key)
						? value
						: void 0;
				},
			});

			assert(
				!seenTestCases.has(serializedTestCase),
				&quot;detected duplicate test case&quot;,
			);
			seenTestCases.add(serializedTestCase);
		}

		/**
		 * Check if the template is valid or not
		 * all valid cases go through this
		 * @param {string|Object} item Item to run the rule against
		 * @returns {void}
		 * @private
		 */
		function testValidTemplate(item) {
			const code = typeof item === &quot;object&quot; ? item.code : item;

			assert.ok(
				typeof code === &quot;string&quot;,
				&quot;Test case must specify a string value for &#039;code&#039;&quot;,
			);
			if (item.name) {
				assert.ok(
					typeof item.name === &quot;string&quot;,
					&quot;Optional test case property &#039;name&#039; must be a string&quot;,
				);
			}

			checkDuplicateTestCase(item, seenValidTestCases);

			const result = runRuleForItem(item);
			const messages = result.messages;

			assert.strictEqual(
				messages.length,
				0,
				util.format(
					&quot;Should have no errors but had %d: %s&quot;,
					messages.length,
					util.inspect(messages),
				),
			);

			assertASTDidntChange(result.beforeAST, result.afterAST);
		}

		/**
		 * Asserts that the message matches its expected value. If the expected
		 * value is a regular expression, it is checked against the actual
		 * value.
		 * @param {string} actual Actual value
		 * @param {string|RegExp} expected Expected value
		 * @returns {void}
		 * @private
		 */
		function assertMessageMatches(actual, expected) {
			if (expected instanceof RegExp) {
				// assert.js doesn&#039;t have a built-in RegExp match function
				assert.ok(
					expected.test(actual),
					`Expected &#039;${actual}&#039; to match ${expected}`,
				);
			} else {
				assert.strictEqual(actual, expected);
			}
		}

		/**
		 * Check if the template is invalid or not
		 * all invalid cases go through this.
		 * @param {string|Object} item Item to run the rule against
		 * @returns {void}
		 * @private
		 */
		function testInvalidTemplate(item) {
			assert.ok(
				typeof item.code === &quot;string&quot;,
				&quot;Test case must specify a string value for &#039;code&#039;&quot;,
			);
			if (item.name) {
				assert.ok(
					typeof item.name === &quot;string&quot;,
					&quot;Optional test case property &#039;name&#039; must be a string&quot;,
				);
			}
			assert.ok(
				item.errors || item.errors === 0,
				`Did not specify errors for an invalid test of ${ruleName}`,
			);

			if (Array.isArray(item.errors) &amp;&amp; item.errors.length === 0) {
				assert.fail(&quot;Invalid cases must have at least one error&quot;);
			}

			checkDuplicateTestCase(item, seenInvalidTestCases);

			const ruleHasMetaMessages =
				hasOwnProperty(rule, &quot;meta&quot;) &amp;&amp;
				hasOwnProperty(rule.meta, &quot;messages&quot;);
			const friendlyIDList = ruleHasMetaMessages
				? `[${Object.keys(rule.meta.messages)
						.map(key =&gt; `&#039;${key}&#039;`)
						.join(&quot;, &quot;)}]`
				: null;

			const result = runRuleForItem(item);
			const messages = result.messages;

			for (const message of messages) {
				if (hasOwnProperty(message, &quot;suggestions&quot;)) {
					/** @type {Map&lt;string, number&gt;} */
					const seenMessageIndices = new Map();

					for (let i = 0; i &lt; message.suggestions.length; i += 1) {
						const suggestionMessage = message.suggestions[i].desc;
						const previous =
							seenMessageIndices.get(suggestionMessage);

						assert.ok(
							!seenMessageIndices.has(suggestionMessage),
							`Suggestion message &#039;${suggestionMessage}&#039; reported from suggestion ${i} was previously reported by suggestion ${previous}. Suggestion messages should be unique within an error.`,
						);
						seenMessageIndices.set(suggestionMessage, i);
					}
				}
			}

			if (typeof item.errors === &quot;number&quot;) {
				if (item.errors === 0) {
					assert.fail(
						&quot;Invalid cases must have &#039;error&#039; value greater than 0&quot;,
					);
				}

				assert.strictEqual(
					messages.length,
					item.errors,
					util.format(
						&quot;Should have %d error%s but had %d: %s&quot;,
						item.errors,
						item.errors === 1 ? &quot;&quot; : &quot;s&quot;,
						messages.length,
						util.inspect(messages),
					),
				);
			} else {
				assert.strictEqual(
					messages.length,
					item.errors.length,
					util.format(
						&quot;Should have %d error%s but had %d: %s&quot;,
						item.errors.length,
						item.errors.length === 1 ? &quot;&quot; : &quot;s&quot;,
						messages.length,
						util.inspect(messages),
					),
				);

				const hasMessageOfThisRule = messages.some(
					m =&gt; m.ruleId === ruleId,
				);

				for (let i = 0, l = item.errors.length; i &lt; l; i++) {
					const error = item.errors[i];
					const message = messages[i];

					assert(
						hasMessageOfThisRule,
						&quot;Error rule name should be the same as the name of the rule being tested&quot;,
					);

					if (typeof error === &quot;string&quot; || error instanceof RegExp) {
						// Just an error message.
						assertMessageMatches(message.message, error);
						assert.ok(
							message.suggestions === void 0,
							`Error at index ${i} has suggestions. Please convert the test error into an object and specify &#039;suggestions&#039; property on it to test suggestions.`,
						);
					} else if (typeof error === &quot;object&quot; &amp;&amp; error !== null) {
						/*
						 * Error object.
						 * This may have a message, messageId, data, node type, line, and/or
						 * column.
						 */

						Object.keys(error).forEach(propertyName =&gt; {
							assert.ok(
								errorObjectParameters.has(propertyName),
								`Invalid error property name &#039;${propertyName}&#039;. Expected one of ${friendlyErrorObjectParameterList}.`,
							);
						});

						if (hasOwnProperty(error, &quot;message&quot;)) {
							assert.ok(
								!hasOwnProperty(error, &quot;messageId&quot;),
								&quot;Error should not specify both &#039;message&#039; and a &#039;messageId&#039;.&quot;,
							);
							assert.ok(
								!hasOwnProperty(error, &quot;data&quot;),
								&quot;Error should not specify both &#039;data&#039; and &#039;message&#039;.&quot;,
							);
							assertMessageMatches(
								message.message,
								error.message,
							);
						} else if (hasOwnProperty(error, &quot;messageId&quot;)) {
							assert.ok(
								ruleHasMetaMessages,
								&quot;Error can not use &#039;messageId&#039; if rule under test doesn&#039;t define &#039;meta.messages&#039;.&quot;,
							);
							if (
								!hasOwnProperty(
									rule.meta.messages,
									error.messageId,
								)
							) {
								assert(
									false,
									`Invalid messageId &#039;${error.messageId}&#039;. Expected one of ${friendlyIDList}.`,
								);
							}
							assert.strictEqual(
								message.messageId,
								error.messageId,
								`messageId &#039;${message.messageId}&#039; does not match expected messageId &#039;${error.messageId}&#039;.`,
							);

							const unsubstitutedPlaceholders =
								getUnsubstitutedMessagePlaceholders(
									message.message,
									rule.meta.messages[message.messageId],
									error.data,
								);

							assert.ok(
								unsubstitutedPlaceholders.length === 0,
								`The reported message has ${unsubstitutedPlaceholders.length &gt; 1 ? `unsubstituted placeholders: ${unsubstitutedPlaceholders.map(name =&gt; `&#039;${name}&#039;`).join(&quot;, &quot;)}` : `an unsubstituted placeholder &#039;${unsubstitutedPlaceholders[0]}&#039;`}. Please provide the missing ${unsubstitutedPlaceholders.length &gt; 1 ? &quot;values&quot; : &quot;value&quot;} via the &#039;data&#039; property in the context.report() call.`,
							);

							if (hasOwnProperty(error, &quot;data&quot;)) {
								/*
								 *  if data was provided, then directly compare the returned message to a synthetic
								 *  interpolated message using the same message ID and data provided in the test.
								 *  See https://github.com/eslint/eslint/issues/9890 for context.
								 */
								const unformattedOriginalMessage =
									rule.meta.messages[error.messageId];
								const rehydratedMessage = interpolate(
									unformattedOriginalMessage,
									error.data,
								);

								assert.strictEqual(
									message.message,
									rehydratedMessage,
									`Hydrated message &quot;${rehydratedMessage}&quot; does not match &quot;${message.message}&quot;`,
								);
							}
						} else {
							assert.fail(
								&quot;Test error must specify either a &#039;messageId&#039; or &#039;message&#039;.&quot;,
							);
						}

						if (error.type) {
							assert.strictEqual(
								message.nodeType,
								error.type,
								`Error type should be ${error.type}, found ${message.nodeType}`,
							);
						}

						const actualLocation = {};
						const expectedLocation = {};

						if (hasOwnProperty(error, &quot;line&quot;)) {
							actualLocation.line = message.line;
							expectedLocation.line = error.line;
						}

						if (hasOwnProperty(error, &quot;column&quot;)) {
							actualLocation.column = message.column;
							expectedLocation.column = error.column;
						}

						if (hasOwnProperty(error, &quot;endLine&quot;)) {
							actualLocation.endLine = message.endLine;
							expectedLocation.endLine = error.endLine;
						}

						if (hasOwnProperty(error, &quot;endColumn&quot;)) {
							actualLocation.endColumn = message.endColumn;
							expectedLocation.endColumn = error.endColumn;
						}

						if (Object.keys(expectedLocation).length &gt; 0) {
							assert.deepStrictEqual(
								actualLocation,
								expectedLocation,
								&quot;Actual error location does not match expected error location.&quot;,
							);
						}

						assert.ok(
							!message.suggestions ||
								hasOwnProperty(error, &quot;suggestions&quot;),
							`Error at index ${i} has suggestions. Please specify &#039;suggestions&#039; property on the test error object.`,
						);
						if (hasOwnProperty(error, &quot;suggestions&quot;)) {
							// Support asserting there are no suggestions
							const expectsSuggestions = Array.isArray(
								error.suggestions,
							)
								? error.suggestions.length &gt; 0
								: Boolean(error.suggestions);
							const hasSuggestions =
								message.suggestions !== void 0;

							if (!hasSuggestions &amp;&amp; expectsSuggestions) {
								assert.ok(
									!error.suggestions,
									`Error should have suggestions on error with message: &quot;${message.message}&quot;`,
								);
							} else if (hasSuggestions) {
								assert.ok(
									expectsSuggestions,
									`Error should have no suggestions on error with message: &quot;${message.message}&quot;`,
								);
								if (typeof error.suggestions === &quot;number&quot;) {
									assert.strictEqual(
										message.suggestions.length,
										error.suggestions,
										`Error should have ${error.suggestions} suggestions. Instead found ${message.suggestions.length} suggestions`,
									);
								} else if (Array.isArray(error.suggestions)) {
									assert.strictEqual(
										message.suggestions.length,
										error.suggestions.length,
										`Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`,
									);

									error.suggestions.forEach(
										(expectedSuggestion, index) =&gt; {
											assert.ok(
												typeof expectedSuggestion ===
													&quot;object&quot; &amp;&amp;
													expectedSuggestion !== null,
												&quot;Test suggestion in &#039;suggestions&#039; array must be an object.&quot;,
											);
											Object.keys(
												expectedSuggestion,
											).forEach(propertyName =&gt; {
												assert.ok(
													suggestionObjectParameters.has(
														propertyName,
													),
													`Invalid suggestion property name &#039;${propertyName}&#039;. Expected one of ${friendlySuggestionObjectParameterList}.`,
												);
											});

											const actualSuggestion =
												message.suggestions[index];
											const suggestionPrefix = `Error Suggestion at index ${index}:`;

											if (
												hasOwnProperty(
													expectedSuggestion,
													&quot;desc&quot;,
												)
											) {
												assert.ok(
													!hasOwnProperty(
														expectedSuggestion,
														&quot;data&quot;,
													),
													`${suggestionPrefix} Test should not specify both &#039;desc&#039; and &#039;data&#039;.`,
												);
												assert.ok(
													!hasOwnProperty(
														expectedSuggestion,
														&quot;messageId&quot;,
													),
													`${suggestionPrefix} Test should not specify both &#039;desc&#039; and &#039;messageId&#039;.`,
												);
												assert.strictEqual(
													actualSuggestion.desc,
													expectedSuggestion.desc,
													`${suggestionPrefix} desc should be &quot;${expectedSuggestion.desc}&quot; but got &quot;${actualSuggestion.desc}&quot; instead.`,
												);
											} else if (
												hasOwnProperty(
													expectedSuggestion,
													&quot;messageId&quot;,
												)
											) {
												assert.ok(
													ruleHasMetaMessages,
													`${suggestionPrefix} Test can not use &#039;messageId&#039; if rule under test doesn&#039;t define &#039;meta.messages&#039;.`,
												);
												assert.ok(
													hasOwnProperty(
														rule.meta.messages,
														expectedSuggestion.messageId,
													),
													`${suggestionPrefix} Test has invalid messageId &#039;${expectedSuggestion.messageId}&#039;, the rule under test allows only one of ${friendlyIDList}.`,
												);
												assert.strictEqual(
													actualSuggestion.messageId,
													expectedSuggestion.messageId,
													`${suggestionPrefix} messageId should be &#039;${expectedSuggestion.messageId}&#039; but got &#039;${actualSuggestion.messageId}&#039; instead.`,
												);

												const unsubstitutedPlaceholders =
													getUnsubstitutedMessagePlaceholders(
														actualSuggestion.desc,
														rule.meta.messages[
															expectedSuggestion
																.messageId
														],
														expectedSuggestion.data,
													);

												assert.ok(
													unsubstitutedPlaceholders.length ===
														0,
													`The message of the suggestion has ${unsubstitutedPlaceholders.length &gt; 1 ? `unsubstituted placeholders: ${unsubstitutedPlaceholders.map(name =&gt; `&#039;${name}&#039;`).join(&quot;, &quot;)}` : `an unsubstituted placeholder &#039;${unsubstitutedPlaceholders[0]}&#039;`}. Please provide the missing ${unsubstitutedPlaceholders.length &gt; 1 ? &quot;values&quot; : &quot;value&quot;} via the &#039;data&#039; property for the suggestion in the context.report() call.`,
												);

												if (
													hasOwnProperty(
														expectedSuggestion,
														&quot;data&quot;,
													)
												) {
													const unformattedMetaMessage =
														rule.meta.messages[
															expectedSuggestion
																.messageId
														];
													const rehydratedDesc =
														interpolate(
															unformattedMetaMessage,
															expectedSuggestion.data,
														);

													assert.strictEqual(
														actualSuggestion.desc,
														rehydratedDesc,
														`${suggestionPrefix} Hydrated test desc &quot;${rehydratedDesc}&quot; does not match received desc &quot;${actualSuggestion.desc}&quot;.`,
													);
												}
											} else if (
												hasOwnProperty(
													expectedSuggestion,
													&quot;data&quot;,
												)
											) {
												assert.fail(
													`${suggestionPrefix} Test must specify &#039;messageId&#039; if &#039;data&#039; is used.`,
												);
											} else {
												assert.fail(
													`${suggestionPrefix} Test must specify either &#039;messageId&#039; or &#039;desc&#039;.`,
												);
											}

											assert.ok(
												hasOwnProperty(
													expectedSuggestion,
													&quot;output&quot;,
												),
												`${suggestionPrefix} The &quot;output&quot; property is required.`,
											);
											const codeWithAppliedSuggestion =
												SourceCodeFixer.applyFixes(
													item.code,
													[actualSuggestion],
												).output;

											// Verify if suggestion fix makes a syntax error or not.
											const errorMessageInSuggestion =
												linter
													.verify(
														codeWithAppliedSuggestion,
														result.configs,
														result.filename,
													)
													.find(m =&gt; m.fatal);

											assert(
												!errorMessageInSuggestion,
												[
													&quot;A fatal parsing error occurred in suggestion fix.&quot;,
													`Error: ${errorMessageInSuggestion &amp;&amp; errorMessageInSuggestion.message}`,
													&quot;Suggestion output:&quot;,
													codeWithAppliedSuggestion,
												].join(&quot;\n&quot;),
											);

											assert.strictEqual(
												codeWithAppliedSuggestion,
												expectedSuggestion.output,
												`Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: &quot;${message.message}&quot;`,
											);
											assert.notStrictEqual(
												expectedSuggestion.output,
												item.code,
												`The output of a suggestion should differ from the original source code for suggestion at index: ${index} on error with message: &quot;${message.message}&quot;`,
											);
										},
									);
								} else {
									assert.fail(
										&quot;Test error object property &#039;suggestions&#039; should be an array or a number&quot;,
									);
								}
							}
						}
					} else {
						// Message was an unexpected type
						assert.fail(
							`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`,
						);
					}
				}
			}

			if (hasOwnProperty(item, &quot;output&quot;)) {
				if (item.output === null) {
					assert.strictEqual(
						result.output,
						item.code,
						&quot;Expected no autofixes to be suggested&quot;,
					);
				} else {
					assert.strictEqual(
						result.output,
						item.output,
						&quot;Output is incorrect.&quot;,
					);
					assert.notStrictEqual(
						item.code,
						item.output,
						&quot;Test property &#039;output&#039; matches &#039;code&#039;. If no autofix is expected, then omit the &#039;output&#039; property or set it to null.&quot;,
					);
				}
			} else {
				assert.strictEqual(
					result.output,
					item.code,
					&quot;The rule fixed the code. Please add &#039;output&#039; property.&quot;,
				);
			}

			assertASTDidntChange(result.beforeAST, result.afterAST);
		}

		/*
		 * This creates a mocha test suite and pipes all supplied info through
		 * one of the templates above.
		 * The test suites for valid/invalid are created conditionally as
		 * test runners (eg. vitest) fail for empty test suites.
		 */
		this.constructor.describe(ruleName, () =&gt; {
			if (test.valid.length &gt; 0) {
				this.constructor.describe(&quot;valid&quot;, () =&gt; {
					test.valid.forEach(valid =&gt; {
						this.constructor[valid.only ? &quot;itOnly&quot; : &quot;it&quot;](
							sanitize(
								typeof valid === &quot;object&quot;
									? valid.name || valid.code
									: valid,
							),
							() =&gt; {
								try {
									runHook(valid, &quot;before&quot;);
									testValidTemplate(valid);
								} finally {
									runHook(valid, &quot;after&quot;);
								}
							},
						);
					});
				});
			}

			if (test.invalid.length &gt; 0) {
				this.constructor.describe(&quot;invalid&quot;, () =&gt; {
					test.invalid.forEach(invalid =&gt; {
						this.constructor[invalid.only ? &quot;itOnly&quot; : &quot;it&quot;](
							sanitize(invalid.name || invalid.code),
							() =&gt; {
								try {
									runHook(invalid, &quot;before&quot;);
									testInvalidTemplate(invalid);
								} finally {
									runHook(invalid, &quot;after&quot;);
								}
							},
						);
					});
				});
			}
		});
	}
}

RuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = null;

module.exports = RuleTester;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
