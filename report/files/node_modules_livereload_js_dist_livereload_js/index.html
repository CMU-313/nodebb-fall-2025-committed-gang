<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/livereload-js/dist/livereload.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/livereload-js/dist/livereload.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1205</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">137.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function() {
  var Connector, PROTOCOL_6, PROTOCOL_7, Parser, Version, ref;

  ref = require(&#039;./protocol&#039;), Parser = ref.Parser, PROTOCOL_6 = ref.PROTOCOL_6, PROTOCOL_7 = ref.PROTOCOL_7;

  Version = &quot;2.4.0&quot;;

  exports.Connector = Connector = (function() {
    function Connector(options, WebSocket, Timer, handlers) {
      var path;
      this.options = options;
      this.WebSocket = WebSocket;
      this.Timer = Timer;
      this.handlers = handlers;
      path = this.options.path ? &quot;&quot; + this.options.path : &quot;livereload&quot;;
      this._uri = &quot;ws&quot; + (this.options.https ? &quot;s&quot; : &quot;&quot;) + &quot;://&quot; + this.options.host + &quot;:&quot; + this.options.port + &quot;/&quot; + path;
      this._nextDelay = this.options.mindelay;
      this._connectionDesired = false;
      this.protocol = 0;
      this.protocolParser = new Parser({
        connected: (function(_this) {
          return function(protocol) {
            _this.protocol = protocol;
            _this._handshakeTimeout.stop();
            _this._nextDelay = _this.options.mindelay;
            _this._disconnectionReason = &#039;broken&#039;;
            return _this.handlers.connected(_this.protocol);
          };
        })(this),
        error: (function(_this) {
          return function(e) {
            _this.handlers.error(e);
            return _this._closeOnError();
          };
        })(this),
        message: (function(_this) {
          return function(message) {
            return _this.handlers.message(message);
          };
        })(this)
      });
      this._handshakeTimeout = new this.Timer((function(_this) {
        return function() {
          if (!_this._isSocketConnected()) {
            return;
          }
          _this._disconnectionReason = &#039;handshake-timeout&#039;;
          return _this.socket.close();
        };
      })(this));
      this._reconnectTimer = new this.Timer((function(_this) {
        return function() {
          if (!_this._connectionDesired) {
            return;
          }
          return _this.connect();
        };
      })(this));
      this.connect();
    }

    Connector.prototype._isSocketConnected = function() {
      return this.socket &amp;&amp; this.socket.readyState === this.WebSocket.OPEN;
    };

    Connector.prototype.connect = function() {
      this._connectionDesired = true;
      if (this._isSocketConnected()) {
        return;
      }
      this._reconnectTimer.stop();
      this._disconnectionReason = &#039;cannot-connect&#039;;
      this.protocolParser.reset();
      this.handlers.connecting();
      this.socket = new this.WebSocket(this._uri);
      this.socket.onopen = (function(_this) {
        return function(e) {
          return _this._onopen(e);
        };
      })(this);
      this.socket.onclose = (function(_this) {
        return function(e) {
          return _this._onclose(e);
        };
      })(this);
      this.socket.onmessage = (function(_this) {
        return function(e) {
          return _this._onmessage(e);
        };
      })(this);
      return this.socket.onerror = (function(_this) {
        return function(e) {
          return _this._onerror(e);
        };
      })(this);
    };

    Connector.prototype.disconnect = function() {
      this._connectionDesired = false;
      this._reconnectTimer.stop();
      if (!this._isSocketConnected()) {
        return;
      }
      this._disconnectionReason = &#039;manual&#039;;
      return this.socket.close();
    };

    Connector.prototype._scheduleReconnection = function() {
      if (!this._connectionDesired) {
        return;
      }
      if (!this._reconnectTimer.running) {
        this._reconnectTimer.start(this._nextDelay);
        return this._nextDelay = Math.min(this.options.maxdelay, this._nextDelay * 2);
      }
    };

    Connector.prototype.sendCommand = function(command) {
      if (this.protocol == null) {
        return;
      }
      return this._sendCommand(command);
    };

    Connector.prototype._sendCommand = function(command) {
      return this.socket.send(JSON.stringify(command));
    };

    Connector.prototype._closeOnError = function() {
      this._handshakeTimeout.stop();
      this._disconnectionReason = &#039;error&#039;;
      return this.socket.close();
    };

    Connector.prototype._onopen = function(e) {
      var hello;
      this.handlers.socketConnected();
      this._disconnectionReason = &#039;handshake-failed&#039;;
      hello = {
        command: &#039;hello&#039;,
        protocols: [PROTOCOL_6, PROTOCOL_7]
      };
      hello.ver = Version;
      if (this.options.ext) {
        hello.ext = this.options.ext;
      }
      if (this.options.extver) {
        hello.extver = this.options.extver;
      }
      if (this.options.snipver) {
        hello.snipver = this.options.snipver;
      }
      this._sendCommand(hello);
      return this._handshakeTimeout.start(this.options.handshake_timeout);
    };

    Connector.prototype._onclose = function(e) {
      this.protocol = 0;
      this.handlers.disconnected(this._disconnectionReason, this._nextDelay);
      return this._scheduleReconnection();
    };

    Connector.prototype._onerror = function(e) {};

    Connector.prototype._onmessage = function(e) {
      return this.protocolParser.process(e.data);
    };

    return Connector;

  })();

}).call(this);

},{&quot;./protocol&quot;:6}],2:[function(require,module,exports){
(function() {
  var CustomEvents;

  CustomEvents = {
    bind: function(element, eventName, handler) {
      if (element.addEventListener) {
        return element.addEventListener(eventName, handler, false);
      } else if (element.attachEvent) {
        element[eventName] = 1;
        return element.attachEvent(&#039;onpropertychange&#039;, function(event) {
          if (event.propertyName === eventName) {
            return handler();
          }
        });
      } else {
        throw new Error(&quot;Attempt to attach custom event &quot; + eventName + &quot; to something which isn&#039;t a DOMElement&quot;);
      }
    },
    fire: function(element, eventName) {
      var event;
      if (element.addEventListener) {
        event = document.createEvent(&#039;HTMLEvents&#039;);
        event.initEvent(eventName, true, true);
        return document.dispatchEvent(event);
      } else if (element.attachEvent) {
        if (element[eventName]) {
          return element[eventName]++;
        }
      } else {
        throw new Error(&quot;Attempt to fire custom event &quot; + eventName + &quot; on something which isn&#039;t a DOMElement&quot;);
      }
    }
  };

  exports.bind = CustomEvents.bind;

  exports.fire = CustomEvents.fire;

}).call(this);

},{}],3:[function(require,module,exports){
(function() {
  var LessPlugin;

  module.exports = LessPlugin = (function() {
    LessPlugin.identifier = &#039;less&#039;;

    LessPlugin.version = &#039;1.0&#039;;

    function LessPlugin(window, host) {
      this.window = window;
      this.host = host;
    }

    LessPlugin.prototype.reload = function(path, options) {
      if (this.window.less &amp;&amp; this.window.less.refresh) {
        if (path.match(/\.less$/i)) {
          return this.reloadLess(path);
        }
        if (options.originalPath.match(/\.less$/i)) {
          return this.reloadLess(options.originalPath);
        }
      }
      return false;
    };

    LessPlugin.prototype.reloadLess = function(path) {
      var i, len, link, links;
      links = (function() {
        var i, len, ref, results;
        ref = document.getElementsByTagName(&#039;link&#039;);
        results = [];
        for (i = 0, len = ref.length; i &lt; len; i++) {
          link = ref[i];
          if (link.href &amp;&amp; link.rel.match(/^stylesheet\/less$/i) || (link.rel.match(/stylesheet/i) &amp;&amp; link.type.match(/^text\/(x-)?less$/i))) {
            results.push(link);
          }
        }
        return results;
      })();
      if (links.length === 0) {
        return false;
      }
      for (i = 0, len = links.length; i &lt; len; i++) {
        link = links[i];
        link.href = this.host.generateCacheBustUrl(link.href);
      }
      this.host.console.log(&quot;LiveReload is asking LESS to recompile all stylesheets&quot;);
      this.window.less.refresh(true);
      return true;
    };

    LessPlugin.prototype.analyze = function() {
      return {
        disable: !!(this.window.less &amp;&amp; this.window.less.refresh)
      };
    };

    return LessPlugin;

  })();

}).call(this);

},{}],4:[function(require,module,exports){
(function() {
  var Connector, LiveReload, Options, ProtocolError, Reloader, Timer,
    hasProp = {}.hasOwnProperty;

  Connector = require(&#039;./connector&#039;).Connector;

  Timer = require(&#039;./timer&#039;).Timer;

  Options = require(&#039;./options&#039;).Options;

  Reloader = require(&#039;./reloader&#039;).Reloader;

  ProtocolError = require(&#039;./protocol&#039;).ProtocolError;

  exports.LiveReload = LiveReload = (function() {
    function LiveReload(window1) {
      var k, ref, v;
      this.window = window1;
      this.listeners = {};
      this.plugins = [];
      this.pluginIdentifiers = {};
      this.console = this.window.console &amp;&amp; this.window.console.log &amp;&amp; this.window.console.error ? this.window.location.href.match(/LR-verbose/) ? this.window.console : {
        log: function() {},
        error: this.window.console.error.bind(this.window.console)
      } : {
        log: function() {},
        error: function() {}
      };
      if (!(this.WebSocket = this.window.WebSocket || this.window.MozWebSocket)) {
        this.console.error(&quot;LiveReload disabled because the browser does not seem to support web sockets&quot;);
        return;
      }
      if (&#039;LiveReloadOptions&#039; in window) {
        this.options = new Options();
        ref = window[&#039;LiveReloadOptions&#039;];
        for (k in ref) {
          if (!hasProp.call(ref, k)) continue;
          v = ref[k];
          this.options.set(k, v);
        }
      } else {
        this.options = Options.extract(this.window.document);
        if (!this.options) {
          this.console.error(&quot;LiveReload disabled because it could not find its own &lt;SCRIPT&gt; tag&quot;);
          return;
        }
      }
      this.reloader = new Reloader(this.window, this.console, Timer);
      this.connector = new Connector(this.options, this.WebSocket, Timer, {
        connecting: (function(_this) {
          return function() {};
        })(this),
        socketConnected: (function(_this) {
          return function() {};
        })(this),
        connected: (function(_this) {
          return function(protocol) {
            var base;
            if (typeof (base = _this.listeners).connect === &quot;function&quot;) {
              base.connect();
            }
            _this.log(&quot;LiveReload is connected to &quot; + _this.options.host + &quot;:&quot; + _this.options.port + &quot; (protocol v&quot; + protocol + &quot;).&quot;);
            return _this.analyze();
          };
        })(this),
        error: (function(_this) {
          return function(e) {
            if (e instanceof ProtocolError) {
              if (typeof console !== &quot;undefined&quot; &amp;&amp; console !== null) {
                return console.log(e.message + &quot;.&quot;);
              }
            } else {
              if (typeof console !== &quot;undefined&quot; &amp;&amp; console !== null) {
                return console.log(&quot;LiveReload internal error: &quot; + e.message);
              }
            }
          };
        })(this),
        disconnected: (function(_this) {
          return function(reason, nextDelay) {
            var base;
            if (typeof (base = _this.listeners).disconnect === &quot;function&quot;) {
              base.disconnect();
            }
            switch (reason) {
              case &#039;cannot-connect&#039;:
                return _this.log(&quot;LiveReload cannot connect to &quot; + _this.options.host + &quot;:&quot; + _this.options.port + &quot;, will retry in &quot; + nextDelay + &quot; sec.&quot;);
              case &#039;broken&#039;:
                return _this.log(&quot;LiveReload disconnected from &quot; + _this.options.host + &quot;:&quot; + _this.options.port + &quot;, reconnecting in &quot; + nextDelay + &quot; sec.&quot;);
              case &#039;handshake-timeout&#039;:
                return _this.log(&quot;LiveReload cannot connect to &quot; + _this.options.host + &quot;:&quot; + _this.options.port + &quot; (handshake timeout), will retry in &quot; + nextDelay + &quot; sec.&quot;);
              case &#039;handshake-failed&#039;:
                return _this.log(&quot;LiveReload cannot connect to &quot; + _this.options.host + &quot;:&quot; + _this.options.port + &quot; (handshake failed), will retry in &quot; + nextDelay + &quot; sec.&quot;);
              case &#039;manual&#039;:
                break;
              case &#039;error&#039;:
                break;
              default:
                return _this.log(&quot;LiveReload disconnected from &quot; + _this.options.host + &quot;:&quot; + _this.options.port + &quot; (&quot; + reason + &quot;), reconnecting in &quot; + nextDelay + &quot; sec.&quot;);
            }
          };
        })(this),
        message: (function(_this) {
          return function(message) {
            switch (message.command) {
              case &#039;reload&#039;:
                return _this.performReload(message);
              case &#039;alert&#039;:
                return _this.performAlert(message);
            }
          };
        })(this)
      });
      this.initialized = true;
    }

    LiveReload.prototype.on = function(eventName, handler) {
      return this.listeners[eventName] = handler;
    };

    LiveReload.prototype.log = function(message) {
      return this.console.log(&quot;&quot; + message);
    };

    LiveReload.prototype.performReload = function(message) {
      var ref, ref1, ref2;
      this.log(&quot;LiveReload received reload request: &quot; + (JSON.stringify(message, null, 2)));
      return this.reloader.reload(message.path, {
        liveCSS: (ref = message.liveCSS) != null ? ref : true,
        liveImg: (ref1 = message.liveImg) != null ? ref1 : true,
        reloadMissingCSS: (ref2 = message.reloadMissingCSS) != null ? ref2 : true,
        originalPath: message.originalPath || &#039;&#039;,
        overrideURL: message.overrideURL || &#039;&#039;,
        serverURL: &quot;http://&quot; + this.options.host + &quot;:&quot; + this.options.port
      });
    };

    LiveReload.prototype.performAlert = function(message) {
      return alert(message.message);
    };

    LiveReload.prototype.shutDown = function() {
      var base;
      if (!this.initialized) {
        return;
      }
      this.connector.disconnect();
      this.log(&quot;LiveReload disconnected.&quot;);
      return typeof (base = this.listeners).shutdown === &quot;function&quot; ? base.shutdown() : void 0;
    };

    LiveReload.prototype.hasPlugin = function(identifier) {
      return !!this.pluginIdentifiers[identifier];
    };

    LiveReload.prototype.addPlugin = function(pluginClass) {
      var plugin;
      if (!this.initialized) {
        return;
      }
      if (this.hasPlugin(pluginClass.identifier)) {
        return;
      }
      this.pluginIdentifiers[pluginClass.identifier] = true;
      plugin = new pluginClass(this.window, {
        _livereload: this,
        _reloader: this.reloader,
        _connector: this.connector,
        console: this.console,
        Timer: Timer,
        generateCacheBustUrl: (function(_this) {
          return function(url) {
            return _this.reloader.generateCacheBustUrl(url);
          };
        })(this)
      });
      this.plugins.push(plugin);
      this.reloader.addPlugin(plugin);
    };

    LiveReload.prototype.analyze = function() {
      var i, len, plugin, pluginData, pluginsData, ref;
      if (!this.initialized) {
        return;
      }
      if (!(this.connector.protocol &gt;= 7)) {
        return;
      }
      pluginsData = {};
      ref = this.plugins;
      for (i = 0, len = ref.length; i &lt; len; i++) {
        plugin = ref[i];
        pluginsData[plugin.constructor.identifier] = pluginData = (typeof plugin.analyze === &quot;function&quot; ? plugin.analyze() : void 0) || {};
        pluginData.version = plugin.constructor.version;
      }
      this.connector.sendCommand({
        command: &#039;info&#039;,
        plugins: pluginsData,
        url: this.window.location.href
      });
    };

    return LiveReload;

  })();

}).call(this);

},{&quot;./connector&quot;:1,&quot;./options&quot;:5,&quot;./protocol&quot;:6,&quot;./reloader&quot;:7,&quot;./timer&quot;:9}],5:[function(require,module,exports){
(function() {
  var Options;

  exports.Options = Options = (function() {
    function Options() {
      this.https = false;
      this.host = null;
      this.port = 35729;
      this.snipver = null;
      this.ext = null;
      this.extver = null;
      this.mindelay = 1000;
      this.maxdelay = 60000;
      this.handshake_timeout = 5000;
    }

    Options.prototype.set = function(name, value) {
      if (typeof value === &#039;undefined&#039;) {
        return;
      }
      if (!isNaN(+value)) {
        value = +value;
      }
      return this[name] = value;
    };

    return Options;

  })();

  Options.extract = function(document) {
    var element, i, j, keyAndValue, len, len1, m, mm, options, pair, ref, ref1, src;
    ref = document.getElementsByTagName(&#039;script&#039;);
    for (i = 0, len = ref.length; i &lt; len; i++) {
      element = ref[i];
      if ((src = element.src) &amp;&amp; (m = src.match(/^[^:]+:\/\/(.*)\/z?livereload\.js(?:\?(.*))?$/))) {
        options = new Options();
        options.https = src.indexOf(&quot;https&quot;) === 0;
        if (mm = m[1].match(/^([^\/:]+)(?::(\d+))?(\/+.*)?$/)) {
          options.host = mm[1];
          if (mm[2]) {
            options.port = parseInt(mm[2], 10);
          }
        }
        if (m[2]) {
          ref1 = m[2].split(&#039;&amp;&#039;);
          for (j = 0, len1 = ref1.length; j &lt; len1; j++) {
            pair = ref1[j];
            if ((keyAndValue = pair.split(&#039;=&#039;)).length &gt; 1) {
              options.set(keyAndValue[0].replace(/-/g, &#039;_&#039;), keyAndValue.slice(1).join(&#039;=&#039;));
            }
          }
        }
        return options;
      }
    }
    return null;
  };

}).call(this);

},{}],6:[function(require,module,exports){
(function() {
  var PROTOCOL_6, PROTOCOL_7, Parser, ProtocolError,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };

  exports.PROTOCOL_6 = PROTOCOL_6 = &#039;http://livereload.com/protocols/official-6&#039;;

  exports.PROTOCOL_7 = PROTOCOL_7 = &#039;http://livereload.com/protocols/official-7&#039;;

  exports.ProtocolError = ProtocolError = (function() {
    function ProtocolError(reason, data) {
      this.message = &quot;LiveReload protocol error (&quot; + reason + &quot;) after receiving data: \&quot;&quot; + data + &quot;\&quot;.&quot;;
    }

    return ProtocolError;

  })();

  exports.Parser = Parser = (function() {
    function Parser(handlers) {
      this.handlers = handlers;
      this.reset();
    }

    Parser.prototype.reset = function() {
      return this.protocol = null;
    };

    Parser.prototype.process = function(data) {
      var command, e, error, message, options, ref;
      try {
        if (this.protocol == null) {
          if (data.match(/^!!ver:([\d.]+)$/)) {
            this.protocol = 6;
          } else if (message = this._parseMessage(data, [&#039;hello&#039;])) {
            if (!message.protocols.length) {
              throw new ProtocolError(&quot;no protocols specified in handshake message&quot;);
            } else if (indexOf.call(message.protocols, PROTOCOL_7) &gt;= 0) {
              this.protocol = 7;
            } else if (indexOf.call(message.protocols, PROTOCOL_6) &gt;= 0) {
              this.protocol = 6;
            } else {
              throw new ProtocolError(&quot;no supported protocols found&quot;);
            }
          }
          return this.handlers.connected(this.protocol);
        } else if (this.protocol === 6) {
          message = JSON.parse(data);
          if (!message.length) {
            throw new ProtocolError(&quot;protocol 6 messages must be arrays&quot;);
          }
          command = message[0], options = message[1];
          if (command !== &#039;refresh&#039;) {
            throw new ProtocolError(&quot;unknown protocol 6 command&quot;);
          }
          return this.handlers.message({
            command: &#039;reload&#039;,
            path: options.path,
            liveCSS: (ref = options.apply_css_live) != null ? ref : true
          });
        } else {
          message = this._parseMessage(data, [&#039;reload&#039;, &#039;alert&#039;]);
          return this.handlers.message(message);
        }
      } catch (error) {
        e = error;
        if (e instanceof ProtocolError) {
          return this.handlers.error(e);
        } else {
          throw e;
        }
      }
    };

    Parser.prototype._parseMessage = function(data, validCommands) {
      var e, error, message, ref;
      try {
        message = JSON.parse(data);
      } catch (error) {
        e = error;
        throw new ProtocolError(&#039;unparsable JSON&#039;, data);
      }
      if (!message.command) {
        throw new ProtocolError(&#039;missing &quot;command&quot; key&#039;, data);
      }
      if (ref = message.command, indexOf.call(validCommands, ref) &lt; 0) {
        throw new ProtocolError(&quot;invalid command &#039;&quot; + message.command + &quot;&#039;, only valid commands are: &quot; + (validCommands.join(&#039;, &#039;)) + &quot;)&quot;, data);
      }
      return message;
    };

    return Parser;

  })();

}).call(this);

},{}],7:[function(require,module,exports){
(function() {
  var IMAGE_STYLES, Reloader, numberOfMatchingSegments, pathFromUrl, pathsMatch, pickBestMatch, splitUrl;

  splitUrl = function(url) {
    var comboSign, hash, index, params;
    if ((index = url.indexOf(&#039;#&#039;)) &gt;= 0) {
      hash = url.slice(index);
      url = url.slice(0, index);
    } else {
      hash = &#039;&#039;;
    }
    comboSign = url.indexOf(&#039;??&#039;);
    if (comboSign &gt;= 0) {
      if (comboSign + 1 !== url.lastIndexOf(&#039;?&#039;)) {
        index = url.lastIndexOf(&#039;?&#039;);
      }
    } else {
      index = url.indexOf(&#039;?&#039;);
    }
    if (index &gt;= 0) {
      params = url.slice(index);
      url = url.slice(0, index);
    } else {
      params = &#039;&#039;;
    }
    return {
      url: url,
      params: params,
      hash: hash
    };
  };

  pathFromUrl = function(url) {
    var path;
    url = splitUrl(url).url;
    if (url.indexOf(&#039;file://&#039;) === 0) {
      path = url.replace(/^file:\/\/(localhost)?/, &#039;&#039;);
    } else {
      path = url.replace(/^([^:]+:)?\/\/([^:\/]+)(:\d*)?\//, &#039;/&#039;);
    }
    return decodeURIComponent(path);
  };

  pickBestMatch = function(path, objects, pathFunc) {
    var bestMatch, i, len1, object, score;
    bestMatch = {
      score: 0
    };
    for (i = 0, len1 = objects.length; i &lt; len1; i++) {
      object = objects[i];
      score = numberOfMatchingSegments(path, pathFunc(object));
      if (score &gt; bestMatch.score) {
        bestMatch = {
          object: object,
          score: score
        };
      }
    }
    if (bestMatch.score &gt; 0) {
      return bestMatch;
    } else {
      return null;
    }
  };

  numberOfMatchingSegments = function(path1, path2) {
    var comps1, comps2, eqCount, len;
    path1 = path1.replace(/^\/+/, &#039;&#039;).toLowerCase();
    path2 = path2.replace(/^\/+/, &#039;&#039;).toLowerCase();
    if (path1 === path2) {
      return 10000;
    }
    comps1 = path1.split(&#039;/&#039;).reverse();
    comps2 = path2.split(&#039;/&#039;).reverse();
    len = Math.min(comps1.length, comps2.length);
    eqCount = 0;
    while (eqCount &lt; len &amp;&amp; comps1[eqCount] === comps2[eqCount]) {
      ++eqCount;
    }
    return eqCount;
  };

  pathsMatch = function(path1, path2) {
    return numberOfMatchingSegments(path1, path2) &gt; 0;
  };

  IMAGE_STYLES = [
    {
      selector: &#039;background&#039;,
      styleNames: [&#039;backgroundImage&#039;]
    }, {
      selector: &#039;border&#039;,
      styleNames: [&#039;borderImage&#039;, &#039;webkitBorderImage&#039;, &#039;MozBorderImage&#039;]
    }
  ];

  exports.Reloader = Reloader = (function() {
    function Reloader(window, console, Timer) {
      this.window = window;
      this.console = console;
      this.Timer = Timer;
      this.document = this.window.document;
      this.importCacheWaitPeriod = 200;
      this.plugins = [];
    }

    Reloader.prototype.addPlugin = function(plugin) {
      return this.plugins.push(plugin);
    };

    Reloader.prototype.analyze = function(callback) {
      return results;
    };

    Reloader.prototype.reload = function(path, options) {
      var base, i, len1, plugin, ref;
      this.options = options;
      if ((base = this.options).stylesheetReloadTimeout == null) {
        base.stylesheetReloadTimeout = 15000;
      }
      ref = this.plugins;
      for (i = 0, len1 = ref.length; i &lt; len1; i++) {
        plugin = ref[i];
        if (plugin.reload &amp;&amp; plugin.reload(path, options)) {
          return;
        }
      }
      if (options.liveCSS &amp;&amp; path.match(/\.css(?:\.map)?$/i)) {
        if (this.reloadStylesheet(path)) {
          return;
        }
      }
      if (options.liveImg &amp;&amp; path.match(/\.(jpe?g|png|gif)$/i)) {
        this.reloadImages(path);
        return;
      }
      if (options.isChromeExtension) {
        this.reloadChromeExtension();
        return;
      }
      return this.reloadPage();
    };

    Reloader.prototype.reloadPage = function() {
      return this.window.document.location.reload();
    };

    Reloader.prototype.reloadChromeExtension = function() {
      return this.window.chrome.runtime.reload();
    };

    Reloader.prototype.reloadImages = function(path) {
      var expando, i, img, j, k, len1, len2, len3, len4, m, ref, ref1, ref2, ref3, results1, selector, styleNames, styleSheet;
      expando = this.generateUniqueString();
      ref = this.document.images;
      for (i = 0, len1 = ref.length; i &lt; len1; i++) {
        img = ref[i];
        if (pathsMatch(path, pathFromUrl(img.src))) {
          img.src = this.generateCacheBustUrl(img.src, expando);
        }
      }
      if (this.document.querySelectorAll) {
        for (j = 0, len2 = IMAGE_STYLES.length; j &lt; len2; j++) {
          ref1 = IMAGE_STYLES[j], selector = ref1.selector, styleNames = ref1.styleNames;
          ref2 = this.document.querySelectorAll(&quot;[style*=&quot; + selector + &quot;]&quot;);
          for (k = 0, len3 = ref2.length; k &lt; len3; k++) {
            img = ref2[k];
            this.reloadStyleImages(img.style, styleNames, path, expando);
          }
        }
      }
      if (this.document.styleSheets) {
        ref3 = this.document.styleSheets;
        results1 = [];
        for (m = 0, len4 = ref3.length; m &lt; len4; m++) {
          styleSheet = ref3[m];
          results1.push(this.reloadStylesheetImages(styleSheet, path, expando));
        }
        return results1;
      }
    };

    Reloader.prototype.reloadStylesheetImages = function(styleSheet, path, expando) {
      var e, error, i, j, len1, len2, rule, rules, styleNames;
      try {
        rules = styleSheet != null ? styleSheet.cssRules : void 0;
      } catch (error) {
        e = error;
      }
      if (!rules) {
        return;
      }
      for (i = 0, len1 = rules.length; i &lt; len1; i++) {
        rule = rules[i];
        switch (rule.type) {
          case CSSRule.IMPORT_RULE:
            this.reloadStylesheetImages(rule.styleSheet, path, expando);
            break;
          case CSSRule.STYLE_RULE:
            for (j = 0, len2 = IMAGE_STYLES.length; j &lt; len2; j++) {
              styleNames = IMAGE_STYLES[j].styleNames;
              this.reloadStyleImages(rule.style, styleNames, path, expando);
            }
            break;
          case CSSRule.MEDIA_RULE:
            this.reloadStylesheetImages(rule, path, expando);
        }
      }
    };

    Reloader.prototype.reloadStyleImages = function(style, styleNames, path, expando) {
      var i, len1, newValue, styleName, value;
      for (i = 0, len1 = styleNames.length; i &lt; len1; i++) {
        styleName = styleNames[i];
        value = style[styleName];
        if (typeof value === &#039;string&#039;) {
          newValue = value.replace(/\burl\s*\(([^)]*)\)/, (function(_this) {
            return function(match, src) {
              if (pathsMatch(path, pathFromUrl(src))) {
                return &quot;url(&quot; + (_this.generateCacheBustUrl(src, expando)) + &quot;)&quot;;
              } else {
                return match;
              }
            };
          })(this));
          if (newValue !== value) {
            style[styleName] = newValue;
          }
        }
      }
    };

    Reloader.prototype.reloadStylesheet = function(path) {
      var i, imported, j, k, len1, len2, len3, len4, link, links, m, match, ref, ref1, style;
      links = (function() {
        var i, len1, ref, results1;
        ref = this.document.getElementsByTagName(&#039;link&#039;);
        results1 = [];
        for (i = 0, len1 = ref.length; i &lt; len1; i++) {
          link = ref[i];
          if (link.rel.match(/^stylesheet$/i) &amp;&amp; !link.__LiveReload_pendingRemoval) {
            results1.push(link);
          }
        }
        return results1;
      }).call(this);
      imported = [];
      ref = this.document.getElementsByTagName(&#039;style&#039;);
      for (i = 0, len1 = ref.length; i &lt; len1; i++) {
        style = ref[i];
        if (style.sheet) {
          this.collectImportedStylesheets(style, style.sheet, imported);
        }
      }
      for (j = 0, len2 = links.length; j &lt; len2; j++) {
        link = links[j];
        this.collectImportedStylesheets(link, link.sheet, imported);
      }
      if (this.window.StyleFix &amp;&amp; this.document.querySelectorAll) {
        ref1 = this.document.querySelectorAll(&#039;style[data-href]&#039;);
        for (k = 0, len3 = ref1.length; k &lt; len3; k++) {
          style = ref1[k];
          links.push(style);
        }
      }
      this.console.log(&quot;LiveReload found &quot; + links.length + &quot; LINKed stylesheets, &quot; + imported.length + &quot; @imported stylesheets&quot;);
      match = pickBestMatch(path, links.concat(imported), (function(_this) {
        return function(l) {
          return pathFromUrl(_this.linkHref(l));
        };
      })(this));
      if (match) {
        if (match.object.rule) {
          this.console.log(&quot;LiveReload is reloading imported stylesheet: &quot; + match.object.href);
          this.reattachImportedRule(match.object);
        } else {
          this.console.log(&quot;LiveReload is reloading stylesheet: &quot; + (this.linkHref(match.object)));
          this.reattachStylesheetLink(match.object);
        }
      } else {
        if (this.options.reloadMissingCSS) {
          this.console.log(&quot;LiveReload will reload all stylesheets because path &#039;&quot; + path + &quot;&#039; did not match any specific one. To disable this behavior, set &#039;options.reloadMissingCSS&#039; to &#039;false&#039;.&quot;);
          for (m = 0, len4 = links.length; m &lt; len4; m++) {
            link = links[m];
            this.reattachStylesheetLink(link);
          }
        } else {
          this.console.log(&quot;LiveReload will not reload path &#039;&quot; + path + &quot;&#039; because the stylesheet was not found on the page and &#039;options.reloadMissingCSS&#039; was set to &#039;false&#039;.&quot;);
        }
      }
      return true;
    };

    Reloader.prototype.collectImportedStylesheets = function(link, styleSheet, result) {
      var e, error, i, index, len1, rule, rules;
      try {
        rules = styleSheet != null ? styleSheet.cssRules : void 0;
      } catch (error) {
        e = error;
      }
      if (rules &amp;&amp; rules.length) {
        for (index = i = 0, len1 = rules.length; i &lt; len1; index = ++i) {
          rule = rules[index];
          switch (rule.type) {
            case CSSRule.CHARSET_RULE:
              continue;
            case CSSRule.IMPORT_RULE:
              result.push({
                link: link,
                rule: rule,
                index: index,
                href: rule.href
              });
              this.collectImportedStylesheets(link, rule.styleSheet, result);
              break;
            default:
              break;
          }
        }
      }
    };

    Reloader.prototype.waitUntilCssLoads = function(clone, func) {
      var callbackExecuted, executeCallback, poll;
      callbackExecuted = false;
      executeCallback = (function(_this) {
        return function() {
          if (callbackExecuted) {
            return;
          }
          callbackExecuted = true;
          return func();
        };
      })(this);
      clone.onload = (function(_this) {
        return function() {
          _this.console.log(&quot;LiveReload: the new stylesheet has finished loading&quot;);
          _this.knownToSupportCssOnLoad = true;
          return executeCallback();
        };
      })(this);
      if (!this.knownToSupportCssOnLoad) {
        (poll = (function(_this) {
          return function() {
            if (clone.sheet) {
              _this.console.log(&quot;LiveReload is polling until the new CSS finishes loading...&quot;);
              return executeCallback();
            } else {
              return _this.Timer.start(50, poll);
            }
          };
        })(this))();
      }
      return this.Timer.start(this.options.stylesheetReloadTimeout, executeCallback);
    };

    Reloader.prototype.linkHref = function(link) {
      return link.href || link.getAttribute(&#039;data-href&#039;);
    };

    Reloader.prototype.reattachStylesheetLink = function(link) {
      var clone, parent;
      if (link.__LiveReload_pendingRemoval) {
        return;
      }
      link.__LiveReload_pendingRemoval = true;
      if (link.tagName === &#039;STYLE&#039;) {
        clone = this.document.createElement(&#039;link&#039;);
        clone.rel = &#039;stylesheet&#039;;
        clone.media = link.media;
        clone.disabled = link.disabled;
      } else {
        clone = link.cloneNode(false);
      }
      clone.href = this.generateCacheBustUrl(this.linkHref(link));
      parent = link.parentNode;
      if (parent.lastChild === link) {
        parent.appendChild(clone);
      } else {
        parent.insertBefore(clone, link.nextSibling);
      }
      return this.waitUntilCssLoads(clone, (function(_this) {
        return function() {
          var additionalWaitingTime;
          if (/AppleWebKit/.test(navigator.userAgent)) {
            additionalWaitingTime = 5;
          } else {
            additionalWaitingTime = 200;
          }
          return _this.Timer.start(additionalWaitingTime, function() {
            var ref;
            if (!link.parentNode) {
              return;
            }
            link.parentNode.removeChild(link);
            clone.onreadystatechange = null;
            return (ref = _this.window.StyleFix) != null ? ref.link(clone) : void 0;
          });
        };
      })(this));
    };

    Reloader.prototype.reattachImportedRule = function(arg) {
      var href, index, link, media, newRule, parent, rule, tempLink;
      rule = arg.rule, index = arg.index, link = arg.link;
      parent = rule.parentStyleSheet;
      href = this.generateCacheBustUrl(rule.href);
      media = rule.media.length ? [].join.call(rule.media, &#039;, &#039;) : &#039;&#039;;
      newRule = &quot;@import url(\&quot;&quot; + href + &quot;\&quot;) &quot; + media + &quot;;&quot;;
      rule.__LiveReload_newHref = href;
      tempLink = this.document.createElement(&quot;link&quot;);
      tempLink.rel = &#039;stylesheet&#039;;
      tempLink.href = href;
      tempLink.__LiveReload_pendingRemoval = true;
      if (link.parentNode) {
        link.parentNode.insertBefore(tempLink, link);
      }
      return this.Timer.start(this.importCacheWaitPeriod, (function(_this) {
        return function() {
          if (tempLink.parentNode) {
            tempLink.parentNode.removeChild(tempLink);
          }
          if (rule.__LiveReload_newHref !== href) {
            return;
          }
          parent.insertRule(newRule, index);
          parent.deleteRule(index + 1);
          rule = parent.cssRules[index];
          rule.__LiveReload_newHref = href;
          return _this.Timer.start(_this.importCacheWaitPeriod, function() {
            if (rule.__LiveReload_newHref !== href) {
              return;
            }
            parent.insertRule(newRule, index);
            return parent.deleteRule(index + 1);
          });
        };
      })(this));
    };

    Reloader.prototype.generateUniqueString = function() {
      return &#039;livereload=&#039; + Date.now();
    };

    Reloader.prototype.generateCacheBustUrl = function(url, expando) {
      var hash, oldParams, originalUrl, params, ref;
      if (expando == null) {
        expando = this.generateUniqueString();
      }
      ref = splitUrl(url), url = ref.url, hash = ref.hash, oldParams = ref.params;
      if (this.options.overrideURL) {
        if (url.indexOf(this.options.serverURL) &lt; 0) {
          originalUrl = url;
          url = this.options.serverURL + this.options.overrideURL + &quot;?url=&quot; + encodeURIComponent(url);
          this.console.log(&quot;LiveReload is overriding source URL &quot; + originalUrl + &quot; with &quot; + url);
        }
      }
      params = oldParams.replace(/(\?|&amp;)livereload=(\d+)/, function(match, sep) {
        return &quot;&quot; + sep + expando;
      });
      if (params === oldParams) {
        if (oldParams.length === 0) {
          params = &quot;?&quot; + expando;
        } else {
          params = oldParams + &quot;&amp;&quot; + expando;
        }
      }
      return url + params + hash;
    };

    return Reloader;

  })();

}).call(this);

},{}],8:[function(require,module,exports){
(function() {
  var CustomEvents, LiveReload, k;

  CustomEvents = require(&#039;./customevents&#039;);

  LiveReload = window.LiveReload = new (require(&#039;./livereload&#039;).LiveReload)(window);

  for (k in window) {
    if (k.match(/^LiveReloadPlugin/)) {
      LiveReload.addPlugin(window[k]);
    }
  }

  LiveReload.addPlugin(require(&#039;./less&#039;));

  LiveReload.on(&#039;shutdown&#039;, function() {
    return delete window.LiveReload;
  });

  LiveReload.on(&#039;connect&#039;, function() {
    return CustomEvents.fire(document, &#039;LiveReloadConnect&#039;);
  });

  LiveReload.on(&#039;disconnect&#039;, function() {
    return CustomEvents.fire(document, &#039;LiveReloadDisconnect&#039;);
  });

  CustomEvents.bind(document, &#039;LiveReloadShutDown&#039;, function() {
    return LiveReload.shutDown();
  });

}).call(this);

},{&quot;./customevents&quot;:2,&quot;./less&quot;:3,&quot;./livereload&quot;:4}],9:[function(require,module,exports){
(function() {
  var Timer;

  exports.Timer = Timer = (function() {
    function Timer(func1) {
      this.func = func1;
      this.running = false;
      this.id = null;
      this._handler = (function(_this) {
        return function() {
          _this.running = false;
          _this.id = null;
          return _this.func();
        };
      })(this);
    }

    Timer.prototype.start = function(timeout) {
      if (this.running) {
        clearTimeout(this.id);
      }
      this.id = setTimeout(this._handler, timeout);
      return this.running = true;
    };

    Timer.prototype.stop = function() {
      if (this.running) {
        clearTimeout(this.id);
        this.running = false;
        return this.id = null;
      }
    };

    return Timer;

  })();

  Timer.start = function(timeout, func) {
    return setTimeout(func, timeout);
  };

}).call(this);

},{}]},{},[8]);
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
