<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/cache/ResolverCachePlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/cache/ResolverCachePlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">449</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const LazySet = require(&quot;../util/LazySet&quot;);
const makeSerializable = require(&quot;../util/makeSerializable&quot;);

/** @typedef {import(&quot;enhanced-resolve&quot;).ResolveContext} ResolveContext */
/** @typedef {import(&quot;enhanced-resolve&quot;).ResolveOptions} ResolveOptions */
/** @typedef {import(&quot;enhanced-resolve&quot;).ResolveRequest} ResolveRequest */
/** @typedef {import(&quot;enhanced-resolve&quot;).Resolver} Resolver */
/** @typedef {import(&quot;../CacheFacade&quot;).ItemCacheFacade} ItemCacheFacade */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../FileSystemInfo&quot;)} FileSystemInfo */
/** @typedef {import(&quot;../FileSystemInfo&quot;).Snapshot} Snapshot */
/** @typedef {import(&quot;../FileSystemInfo&quot;).SnapshotOptions} SnapshotOptions */
/** @typedef {import(&quot;../ResolverFactory&quot;).ResolveOptionsWithDependencyType} ResolveOptionsWithDependencyType */
/** @typedef {import(&quot;../serialization/ObjectMiddleware&quot;).ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import(&quot;../serialization/ObjectMiddleware&quot;).ObjectSerializerContext} ObjectSerializerContext */

/**
 * @template T
 * @typedef {import(&quot;tapable&quot;).SyncHook&lt;T&gt;} SyncHook
 */

/**
 * @template H
 * @typedef {import(&quot;tapable&quot;).HookMapInterceptor&lt;H&gt;} HookMapInterceptor
 */

class CacheEntry {
	/**
	 * @param {ResolveRequest} result result
	 * @param {Snapshot} snapshot snapshot
	 */
	constructor(result, snapshot) {
		this.result = result;
		this.snapshot = snapshot;
	}

	/**
	 * @param {ObjectSerializerContext} context context
	 */
	serialize({ write }) {
		write(this.result);
		write(this.snapshot);
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 */
	deserialize({ read }) {
		this.result = read();
		this.snapshot = read();
	}
}

makeSerializable(CacheEntry, &quot;webpack/lib/cache/ResolverCachePlugin&quot;);

/**
 * @template T
 * @param {Set&lt;T&gt; | LazySet&lt;T&gt;} set set to add items to
 * @param {Set&lt;T&gt; | LazySet&lt;T&gt; | Iterable&lt;T&gt;} otherSet set to add items from
 * @returns {void}
 */
const addAllToSet = (set, otherSet) =&gt; {
	if (set instanceof LazySet) {
		set.addAll(otherSet);
	} else {
		for (const item of otherSet) {
			set.add(item);
		}
	}
};

/**
 * @template {object} T
 * @param {T} object an object
 * @param {boolean} excludeContext if true, context is not included in string
 * @returns {string} stringified version
 */
const objectToString = (object, excludeContext) =&gt; {
	let str = &quot;&quot;;
	for (const key in object) {
		if (excludeContext &amp;&amp; key === &quot;context&quot;) continue;
		const value = object[key];
		str +=
			typeof value === &quot;object&quot; &amp;&amp; value !== null
				? `|${key}=[${objectToString(value, false)}|]`
				: `|${key}=|${value}`;
	}
	return str;
};

/** @typedef {NonNullable&lt;ResolveContext[&quot;yield&quot;]&gt;} Yield */

const PLUGIN_NAME = &quot;ResolverCachePlugin&quot;;

class ResolverCachePlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		const cache = compiler.getCache(PLUGIN_NAME);
		/** @type {FileSystemInfo} */
		let fileSystemInfo;
		/** @type {SnapshotOptions | undefined} */
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation =&gt; {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap(PLUGIN_NAME, () =&gt; {
				if (realResolves + cachedResolves &gt; 0) {
					const logger = compilation.getLogger(`webpack.${PLUGIN_NAME}`);
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				}
			});
		});

		/** @typedef {(err?: Error | null, resolveRequest?: ResolveRequest | null) =&gt; void} Callback */
		/** @typedef {ResolveRequest &amp; { _ResolverCachePluginCacheMiss: true }} ResolveRequestWithCacheMiss */

		/**
		 * @param {ItemCacheFacade} itemCache cache
		 * @param {Resolver} resolver the resolver
		 * @param {ResolveContext} resolveContext context for resolving meta info
		 * @param {ResolveRequest} request the request info object
		 * @param {Callback} callback callback function
		 * @returns {void}
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) =&gt; {
			realResolves++;
			const newRequest =
				/** @type {ResolveRequestWithCacheMiss} */
				({
					_ResolverCachePluginCacheMiss: true,
					...request
				});
			/** @type {ResolveContext} */
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				/** @type {LazySet&lt;string&gt;} */
				missingDependencies: new LazySet(),
				/** @type {LazySet&lt;string&gt;} */
				fileDependencies: new LazySet(),
				/** @type {LazySet&lt;string&gt;} */
				contextDependencies: new LazySet()
			};
			/** @type {ResolveRequest[] | undefined} */
			let yieldResult;
			let withYield = false;
			if (typeof newResolveContext.yield === &quot;function&quot;) {
				yieldResult = [];
				withYield = true;
				newResolveContext.yield = obj =&gt;
					/** @type {ResolveRequest[]} */
					(yieldResult).push(obj);
			}
			/**
			 * @param {&quot;fileDependencies&quot; | &quot;contextDependencies&quot; | &quot;missingDependencies&quot;} key key
			 */
			const propagate = key =&gt; {
				if (resolveContext[key]) {
					addAllToSet(
						/** @type {Set&lt;string&gt;} */ (resolveContext[key]),
						/** @type {Set&lt;string&gt;} */ (newResolveContext[key])
					);
				}
			};
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				&quot;Cache miss&quot;,
				newResolveContext,
				(err, result) =&gt; {
					propagate(&quot;fileDependencies&quot;);
					propagate(&quot;contextDependencies&quot;);
					propagate(&quot;missingDependencies&quot;);
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						/** @type {Set&lt;string&gt;} */
						(fileDependencies),
						/** @type {Set&lt;string&gt;} */
						(contextDependencies),
						/** @type {Set&lt;string&gt;} */
						(missingDependencies),
						snapshotOptions,
						(err, snapshot) =&gt; {
							if (err) return callback(err);
							const resolveResult = withYield ? yieldResult : result;
							// since we intercept resolve hook
							// we still can get result in callback
							if (withYield &amp;&amp; result)
								/** @type {ResolveRequest[]} */ (yieldResult).push(result);
							if (!snapshot) {
								if (resolveResult)
									return callback(
										null,
										/** @type {ResolveRequest} */
										(resolveResult)
									);
								return callback();
							}
							itemCache.store(
								new CacheEntry(
									/** @type {ResolveRequest} */
									(resolveResult),
									snapshot
								),
								storeErr =&gt; {
									if (storeErr) return callback(storeErr);
									if (resolveResult)
										return callback(
											null,
											/** @type {ResolveRequest} */
											(resolveResult)
										);
									callback();
								}
							);
						}
					);
				}
			);
		};
		compiler.resolverFactory.hooks.resolver.intercept({
			factory(type, _hook) {
				/** @typedef {(err?: Error, resolveRequest?: ResolveRequest) =&gt; void} ActiveRequest */
				/** @type {Map&lt;string, ActiveRequest[]&gt;} */
				const activeRequests = new Map();
				/** @type {Map&lt;string, [ActiveRequest[], Yield[]]&gt;} */
				const activeRequestsWithYield = new Map();
				const hook =
					/** @type {SyncHook&lt;[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]&gt;} */
					(_hook);
				hook.tap(PLUGIN_NAME, (resolver, options, userOptions) =&gt; {
					if (
						/** @type {ResolveOptions &amp; { cache: boolean }} */
						(options).cache !== true
					)
						return;
					const optionsIdent = objectToString(userOptions, false);
					const cacheWithContext =
						options.cacheWithContext !== undefined
							? options.cacheWithContext
							: false;
					resolver.hooks.resolve.tapAsync(
						{
							name: PLUGIN_NAME,
							stage: -100
						},
						(request, resolveContext, callback) =&gt; {
							if (
								/** @type {ResolveRequestWithCacheMiss} */
								(request)._ResolverCachePluginCacheMiss ||
								!fileSystemInfo
							) {
								return callback();
							}
							const withYield = typeof resolveContext.yield === &quot;function&quot;;
							const identifier = `${type}${
								withYield ? &quot;|yield&quot; : &quot;|default&quot;
							}${optionsIdent}${objectToString(request, !cacheWithContext)}`;

							if (withYield) {
								const activeRequest = activeRequestsWithYield.get(identifier);
								if (activeRequest) {
									activeRequest[0].push(callback);
									activeRequest[1].push(
										/** @type {Yield} */
										(resolveContext.yield)
									);
									return;
								}
							} else {
								const activeRequest = activeRequests.get(identifier);
								if (activeRequest) {
									activeRequest.push(callback);
									return;
								}
							}
							const itemCache = cache.getItemCache(identifier, null);
							/** @type {Callback[] | false | undefined} */
							let callbacks;
							/** @type {Yield[] | undefined} */
							let yields;

							/**
							 * @type {(err?: Error | null, result?: ResolveRequest | ResolveRequest[] | null) =&gt; void}
							 */
							const done = withYield
								? (err, result) =&gt; {
										if (callbacks === undefined) {
											if (err) {
												callback(err);
											} else {
												if (result)
													for (const r of /** @type {ResolveRequest[]} */ (
														result
													)) {
														/** @type {Yield} */
														(resolveContext.yield)(r);
													}
												callback(null, null);
											}
											yields = undefined;
											callbacks = false;
										} else {
											const definedCallbacks =
												/** @type {Callback[]} */
												(callbacks);

											if (err) {
												for (const cb of definedCallbacks) cb(err);
											} else {
												for (let i = 0; i &lt; definedCallbacks.length; i++) {
													const cb = definedCallbacks[i];
													const yield_ = /** @type {Yield[]} */ (yields)[i];
													if (result)
														for (const r of /** @type {ResolveRequest[]} */ (
															result
														))
															yield_(r);
													cb(null, null);
												}
											}
											activeRequestsWithYield.delete(identifier);
											yields = undefined;
											callbacks = false;
										}
									}
								: (err, result) =&gt; {
										if (callbacks === undefined) {
											callback(err, /** @type {ResolveRequest} */ (result));
											callbacks = false;
										} else {
											for (const callback of /** @type {Callback[]} */ (
												callbacks
											)) {
												callback(err, /** @type {ResolveRequest} */ (result));
											}
											activeRequests.delete(identifier);
											callbacks = false;
										}
									};
							/**
							 * @param {(Error | null)=} err error if any
							 * @param {(CacheEntry | null)=} cacheEntry cache entry
							 * @returns {void}
							 */
							const processCacheResult = (err, cacheEntry) =&gt; {
								if (err) return done(err);

								if (cacheEntry) {
									const { snapshot, result } = cacheEntry;
									fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) =&gt; {
										if (err || !valid) {
											cacheInvalidResolves++;
											return doRealResolve(
												itemCache,
												resolver,
												resolveContext,
												request,
												done
											);
										}
										cachedResolves++;
										if (resolveContext.missingDependencies) {
											addAllToSet(
												/** @type {Set&lt;string&gt;} */
												(resolveContext.missingDependencies),
												snapshot.getMissingIterable()
											);
										}
										if (resolveContext.fileDependencies) {
											addAllToSet(
												/** @type {Set&lt;string&gt;} */
												(resolveContext.fileDependencies),
												snapshot.getFileIterable()
											);
										}
										if (resolveContext.contextDependencies) {
											addAllToSet(
												/** @type {Set&lt;string&gt;} */
												(resolveContext.contextDependencies),
												snapshot.getContextIterable()
											);
										}
										done(null, result);
									});
								} else {
									doRealResolve(
										itemCache,
										resolver,
										resolveContext,
										request,
										done
									);
								}
							};
							itemCache.get(processCacheResult);
							if (withYield &amp;&amp; callbacks === undefined) {
								callbacks = [callback];
								yields = [/** @type {Yield} */ (resolveContext.yield)];
								activeRequestsWithYield.set(identifier, [callbacks, yields]);
							} else if (callbacks === undefined) {
								callbacks = [callback];
								activeRequests.set(identifier, callbacks);
							}
						}
					);
				});
				return hook;
			}
		});
	}
}

module.exports = ResolverCachePlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
