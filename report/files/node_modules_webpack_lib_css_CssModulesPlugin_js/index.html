<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/css/CssModulesPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/css/CssModulesPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">922</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">87.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.10</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { SyncWaterfallHook, SyncHook } = require(&quot;tapable&quot;);
const {
	ConcatSource,
	PrefixSource,
	ReplaceSource,
	CachedSource,
	RawSource
} = require(&quot;webpack-sources&quot;);
const Compilation = require(&quot;../Compilation&quot;);
const CssModule = require(&quot;../CssModule&quot;);
const { tryRunOrWebpackError } = require(&quot;../HookWebpackError&quot;);
const HotUpdateChunk = require(&quot;../HotUpdateChunk&quot;);
const {
	CSS_MODULE_TYPE,
	CSS_MODULE_TYPE_GLOBAL,
	CSS_MODULE_TYPE_MODULE,
	CSS_MODULE_TYPE_AUTO
} = require(&quot;../ModuleTypeConstants&quot;);
const NormalModule = require(&quot;../NormalModule&quot;);
const RuntimeGlobals = require(&quot;../RuntimeGlobals&quot;);
const SelfModuleFactory = require(&quot;../SelfModuleFactory&quot;);
const Template = require(&quot;../Template&quot;);
const WebpackError = require(&quot;../WebpackError&quot;);
const CssIcssExportDependency = require(&quot;../dependencies/CssIcssExportDependency&quot;);
const CssIcssImportDependency = require(&quot;../dependencies/CssIcssImportDependency&quot;);
const CssIcssSymbolDependency = require(&quot;../dependencies/CssIcssSymbolDependency&quot;);
const CssImportDependency = require(&quot;../dependencies/CssImportDependency&quot;);
const CssLocalIdentifierDependency = require(&quot;../dependencies/CssLocalIdentifierDependency&quot;);
const CssSelfLocalIdentifierDependency = require(&quot;../dependencies/CssSelfLocalIdentifierDependency&quot;);
const CssUrlDependency = require(&quot;../dependencies/CssUrlDependency&quot;);
const StaticExportsDependency = require(&quot;../dependencies/StaticExportsDependency&quot;);
const JavascriptModulesPlugin = require(&quot;../javascript/JavascriptModulesPlugin&quot;);
const { compareModulesByIdOrIdentifier } = require(&quot;../util/comparators&quot;);
const createSchemaValidation = require(&quot;../util/create-schema-validation&quot;);
const createHash = require(&quot;../util/createHash&quot;);
const { getUndoPath } = require(&quot;../util/identifier&quot;);
const memoize = require(&quot;../util/memoize&quot;);
const nonNumericOnlyHash = require(&quot;../util/nonNumericOnlyHash&quot;);
const removeBOM = require(&quot;../util/removeBOM&quot;);
const CssGenerator = require(&quot;./CssGenerator&quot;);
const CssParser = require(&quot;./CssParser&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).HashFunction} HashFunction */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).OutputNormalized} OutputOptions */
/** @typedef {import(&quot;../Chunk&quot;)} Chunk */
/** @typedef {import(&quot;../ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;../CodeGenerationResults&quot;)} CodeGenerationResults */
/** @typedef {import(&quot;../Compilation&quot;).ChunkHashContext} ChunkHashContext */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../CssModule&quot;).Inheritance} Inheritance */
/** @typedef {import(&quot;../Module&quot;)} Module */
/** @typedef {import(&quot;../Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;../Template&quot;).RuntimeTemplate} RuntimeTemplate */
/** @typedef {import(&quot;../TemplatedPathPlugin&quot;).TemplatePath} TemplatePath */
/** @typedef {import(&quot;../util/Hash&quot;)} Hash */
/** @typedef {import(&quot;../util/memoize&quot;)} Memoize */

/**
 * @typedef {object} RenderContext
 * @property {Chunk} chunk the chunk
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {string} uniqueName the unique name
 * @property {string} undoPath undo path to css file
 * @property {CssModule[]} modules modules
 */

/**
 * @typedef {object} ChunkRenderContext
 * @property {Chunk} chunk the chunk
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {CodeGenerationResults} codeGenerationResults results of code generation
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {string} undoPath undo path to css file
 */

/**
 * @typedef {object} CompilationHooks
 * @property {SyncWaterfallHook&lt;[Source, Module, ChunkRenderContext]&gt;} renderModulePackage
 * @property {SyncHook&lt;[Chunk, Hash, ChunkHashContext]&gt;} chunkHash
 */

const getCssLoadingRuntimeModule = memoize(() =&gt;
	require(&quot;./CssLoadingRuntimeModule&quot;)
);

/**
 * @param {string} name name
 * @returns {{ oneOf: [{ $ref: string }], definitions: import(&quot;../../schemas/WebpackOptions.json&quot;)[&quot;definitions&quot;] }} schema
 */
const getSchema = name =&gt; {
	const { definitions } = require(&quot;../../schemas/WebpackOptions.json&quot;);
	return {
		definitions,
		oneOf: [{ $ref: `#/definitions/${name}` }]
	};
};

const generatorValidationOptions = {
	name: &quot;Css Modules Plugin&quot;,
	baseDataPath: &quot;generator&quot;
};
const validateGeneratorOptions = {
	css: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssGeneratorOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssGeneratorOptions&quot;),
		generatorValidationOptions
	),
	&quot;css/auto&quot;: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssAutoGeneratorOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssAutoGeneratorOptions&quot;),
		generatorValidationOptions
	),
	&quot;css/module&quot;: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssModuleGeneratorOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssModuleGeneratorOptions&quot;),
		generatorValidationOptions
	),
	&quot;css/global&quot;: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssGlobalGeneratorOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssGlobalGeneratorOptions&quot;),
		generatorValidationOptions
	)
};

const parserValidationOptions = {
	name: &quot;Css Modules Plugin&quot;,
	baseDataPath: &quot;parser&quot;
};
const validateParserOptions = {
	css: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssParserOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssParserOptions&quot;),
		parserValidationOptions
	),
	&quot;css/auto&quot;: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssAutoParserOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssAutoParserOptions&quot;),
		parserValidationOptions
	),
	&quot;css/module&quot;: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssModuleParserOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssModuleParserOptions&quot;),
		parserValidationOptions
	),
	&quot;css/global&quot;: createSchemaValidation(
		require(&quot;../../schemas/plugins/css/CssGlobalParserOptions.check.js&quot;),
		() =&gt; getSchema(&quot;CssGlobalParserOptions&quot;),
		parserValidationOptions
	)
};

/** @type {WeakMap&lt;Compilation, CompilationHooks&gt;} */
const compilationHooksMap = new WeakMap();

const PLUGIN_NAME = &quot;CssModulesPlugin&quot;;

class CssModulesPlugin {
	/**
	 * @param {Compilation} compilation the compilation
	 * @returns {CompilationHooks} the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				&quot;The &#039;compilation&#039; argument must be an instance of Compilation&quot;
			);
		}
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				renderModulePackage: new SyncWaterfallHook([
					&quot;source&quot;,
					&quot;module&quot;,
					&quot;renderContext&quot;
				]),
				chunkHash: new SyncHook([&quot;chunk&quot;, &quot;hash&quot;, &quot;context&quot;])
			};
			compilationHooksMap.set(compilation, hooks);
		}
		return hooks;
	}

	constructor() {
		/** @type {WeakMap&lt;Source, { undoPath: string, inheritance: Inheritance, source: CachedSource }&gt;} */
		this._moduleFactoryCache = new WeakMap();
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory }) =&gt; {
				const hooks = CssModulesPlugin.getCompilationHooks(compilation);
				const selfFactory = new SelfModuleFactory(compilation.moduleGraph);
				compilation.dependencyFactories.set(
					CssImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CssImportDependency,
					new CssImportDependency.Template()
				);
				compilation.dependencyFactories.set(
					CssUrlDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CssUrlDependency,
					new CssUrlDependency.Template()
				);
				compilation.dependencyTemplates.set(
					CssLocalIdentifierDependency,
					new CssLocalIdentifierDependency.Template()
				);
				compilation.dependencyFactories.set(
					CssSelfLocalIdentifierDependency,
					selfFactory
				);
				compilation.dependencyTemplates.set(
					CssSelfLocalIdentifierDependency,
					new CssSelfLocalIdentifierDependency.Template()
				);
				compilation.dependencyFactories.set(
					CssIcssImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CssIcssImportDependency,
					new CssIcssImportDependency.Template()
				);
				compilation.dependencyTemplates.set(
					CssIcssExportDependency,
					new CssIcssExportDependency.Template()
				);
				compilation.dependencyTemplates.set(
					CssIcssSymbolDependency,
					new CssIcssSymbolDependency.Template()
				);
				compilation.dependencyTemplates.set(
					StaticExportsDependency,
					new StaticExportsDependency.Template()
				);
				for (const type of [
					CSS_MODULE_TYPE,
					CSS_MODULE_TYPE_GLOBAL,
					CSS_MODULE_TYPE_MODULE,
					CSS_MODULE_TYPE_AUTO
				]) {
					normalModuleFactory.hooks.createParser
						.for(type)
						.tap(PLUGIN_NAME, parserOptions =&gt; {
							validateParserOptions[type](parserOptions);
							const { url, import: importOption, namedExports } = parserOptions;

							switch (type) {
								case CSS_MODULE_TYPE:
									return new CssParser({
										importOption,
										url,
										namedExports
									});
								case CSS_MODULE_TYPE_GLOBAL:
									return new CssParser({
										defaultMode: &quot;global&quot;,
										importOption,
										url,
										namedExports
									});
								case CSS_MODULE_TYPE_MODULE:
									return new CssParser({
										defaultMode: &quot;local&quot;,
										importOption,
										url,
										namedExports
									});
								case CSS_MODULE_TYPE_AUTO:
									return new CssParser({
										defaultMode: &quot;auto&quot;,
										importOption,
										url,
										namedExports
									});
							}
						});
					normalModuleFactory.hooks.createGenerator
						.for(type)
						.tap(PLUGIN_NAME, generatorOptions =&gt; {
							validateGeneratorOptions[type](generatorOptions);

							return new CssGenerator(
								generatorOptions,
								compilation.moduleGraph
							);
						});
					normalModuleFactory.hooks.createModuleClass
						.for(type)
						.tap(PLUGIN_NAME, (createData, resolveData) =&gt; {
							if (resolveData.dependencies.length &gt; 0) {
								// When CSS is imported from CSS there is only one dependency
								const dependency = resolveData.dependencies[0];

								if (dependency instanceof CssImportDependency) {
									const parent =
										/** @type {CssModule} */
										(compilation.moduleGraph.getParentModule(dependency));

									if (parent instanceof CssModule) {
										/** @type {import(&quot;../CssModule&quot;).Inheritance | undefined} */
										let inheritance;

										if (
											parent.cssLayer !== undefined ||
											parent.supports ||
											parent.media
										) {
											if (!inheritance) {
												inheritance = [];
											}

											inheritance.push([
												parent.cssLayer,
												parent.supports,
												parent.media
											]);
										}

										if (parent.inheritance) {
											if (!inheritance) {
												inheritance = [];
											}

											inheritance.push(...parent.inheritance);
										}

										return new CssModule({
											...createData,
											cssLayer: dependency.layer,
											supports: dependency.supports,
											media: dependency.media,
											inheritance
										});
									}

									return new CssModule({
										...createData,
										cssLayer: dependency.layer,
										supports: dependency.supports,
										media: dependency.media
									});
								}
							}

							return new CssModule(createData);
						});

					NormalModule.getCompilationHooks(compilation).processResult.tap(
						PLUGIN_NAME,
						(result, module) =&gt; {
							if (module.type === type) {
								const [source, ...rest] = result;

								return [removeBOM(source), ...rest];
							}

							return result;
						}
					);
				}

				JavascriptModulesPlugin.getCompilationHooks(
					compilation
				).renderModuleContent.tap(PLUGIN_NAME, (source, module) =&gt; {
					if (module instanceof CssModule &amp;&amp; module.hot) {
						const cssData = /** @type {BuildInfo} */ (module.buildInfo).cssData;
						if (!cssData) {
							return source;
						}
						const exports = cssData.exports;
						const stringifiedExports = JSON.stringify(
							JSON.stringify(
								Array.from(exports).reduce((obj, [key, value]) =&gt; {
									obj[key] = value;
									return obj;
								}, /** @type {Record&lt;string, string&gt;} */ ({}))
							)
						);

						const hmrCode = Template.asString([
							&quot;&quot;,
							`var __webpack_css_exports__ = ${stringifiedExports};`,
							&quot;// only invalidate when locals change&quot;,
							&quot;if (module.hot.data &amp;&amp; module.hot.data.__webpack_css_exports__ &amp;&amp; module.hot.data.__webpack_css_exports__ != __webpack_css_exports__) {&quot;,
							Template.indent(&quot;module.hot.invalidate();&quot;),
							&quot;} else {&quot;,
							Template.indent(&quot;module.hot.accept();&quot;),
							&quot;}&quot;,
							&quot;module.hot.dispose(function(data) { data.__webpack_css_exports__ = __webpack_css_exports__; });&quot;
						]);

						return new ConcatSource(source, &quot;\n&quot;, new RawSource(hmrCode));
					}

					return source;
				});
				const orderedCssModulesPerChunk = new WeakMap();
				compilation.hooks.afterCodeGeneration.tap(PLUGIN_NAME, () =&gt; {
					const { chunkGraph } = compilation;
					for (const chunk of compilation.chunks) {
						if (CssModulesPlugin.chunkHasCss(chunk, chunkGraph)) {
							orderedCssModulesPerChunk.set(
								chunk,
								this.getOrderedChunkCssModules(chunk, chunkGraph, compilation)
							);
						}
					}
				});
				compilation.hooks.chunkHash.tap(PLUGIN_NAME, (chunk, hash, context) =&gt; {
					hooks.chunkHash.call(chunk, hash, context);
				});
				compilation.hooks.contentHash.tap(PLUGIN_NAME, chunk =&gt; {
					const {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						}
					} = compilation;
					const hash = createHash(/** @type {HashFunction} */ (hashFunction));
					if (hashSalt) hash.update(hashSalt);
					hooks.chunkHash.call(chunk, hash, {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate
					});
					const modules = orderedCssModulesPerChunk.get(chunk);
					if (modules) {
						for (const module of modules) {
							hash.update(chunkGraph.getModuleHash(module, chunk.runtime));
						}
					}
					const digest = /** @type {string} */ (hash.digest(hashDigest));
					chunk.contentHash.css = nonNumericOnlyHash(
						digest,
						/** @type {number} */
						(hashDigestLength)
					);
				});
				compilation.hooks.renderManifest.tap(PLUGIN_NAME, (result, options) =&gt; {
					const { chunkGraph } = compilation;
					const { hash, chunk, codeGenerationResults, runtimeTemplate } =
						options;

					if (chunk instanceof HotUpdateChunk) return result;

					/** @type {CssModule[] | undefined} */
					const modules = orderedCssModulesPerChunk.get(chunk);
					if (modules !== undefined) {
						const { path: filename, info } = compilation.getPathWithInfo(
							CssModulesPlugin.getChunkFilenameTemplate(
								chunk,
								compilation.outputOptions
							),
							{
								hash,
								runtime: chunk.runtime,
								chunk,
								contentHashType: &quot;css&quot;
							}
						);
						const undoPath = getUndoPath(
							filename,
							/** @type {string} */
							(compilation.outputOptions.path),
							false
						);
						result.push({
							render: () =&gt;
								this.renderChunk(
									{
										chunk,
										chunkGraph,
										codeGenerationResults,
										uniqueName:
											/** @type {string} */
											(compilation.outputOptions.uniqueName),
										undoPath,
										modules,
										runtimeTemplate
									},
									hooks
								),
							filename,
							info,
							identifier: `css${chunk.id}`,
							hash: chunk.contentHash.css
						});
					}
					return result;
				});
				const globalChunkLoading = compilation.outputOptions.chunkLoading;
				/**
				 * @param {Chunk} chunk the chunk
				 * @returns {boolean} true, when enabled
				 */
				const isEnabledForChunk = chunk =&gt; {
					const options = chunk.getEntryOptions();
					const chunkLoading =
						options &amp;&amp; options.chunkLoading !== undefined
							? options.chunkLoading
							: globalChunkLoading;
					return chunkLoading === &quot;jsonp&quot; || chunkLoading === &quot;import&quot;;
				};
				const onceForChunkSet = new WeakSet();
				/**
				 * @param {Chunk} chunk chunk to check
				 * @param {Set&lt;string&gt;} set runtime requirements
				 */
				const handler = (chunk, set) =&gt; {
					if (onceForChunkSet.has(chunk)) return;
					onceForChunkSet.add(chunk);
					if (!isEnabledForChunk(chunk)) return;

					set.add(RuntimeGlobals.makeNamespaceObject);

					const CssLoadingRuntimeModule = getCssLoadingRuntimeModule();
					compilation.addRuntimeModule(chunk, new CssLoadingRuntimeModule(set));
				};
				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.hasCssModules)
					.tap(PLUGIN_NAME, handler);
				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.ensureChunkHandlers)
					.tap(PLUGIN_NAME, (chunk, set, { chunkGraph }) =&gt; {
						if (!isEnabledForChunk(chunk)) return;
						if (
							!chunkGraph.hasModuleInGraph(
								chunk,
								m =&gt;
									m.type === CSS_MODULE_TYPE ||
									m.type === CSS_MODULE_TYPE_GLOBAL ||
									m.type === CSS_MODULE_TYPE_MODULE ||
									m.type === CSS_MODULE_TYPE_AUTO
							)
						) {
							return;
						}

						set.add(RuntimeGlobals.hasOwnProperty);
						set.add(RuntimeGlobals.publicPath);
						set.add(RuntimeGlobals.getChunkCssFilename);
					});
				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.hmrDownloadUpdateHandlers)
					.tap(PLUGIN_NAME, (chunk, set, { chunkGraph }) =&gt; {
						if (!isEnabledForChunk(chunk)) return;
						if (
							!chunkGraph.hasModuleInGraph(
								chunk,
								m =&gt;
									m.type === CSS_MODULE_TYPE ||
									m.type === CSS_MODULE_TYPE_GLOBAL ||
									m.type === CSS_MODULE_TYPE_MODULE ||
									m.type === CSS_MODULE_TYPE_AUTO
							)
						) {
							return;
						}
						set.add(RuntimeGlobals.publicPath);
						set.add(RuntimeGlobals.getChunkCssFilename);
					});
			}
		);
	}

	/**
	 * @param {Chunk} chunk chunk
	 * @param {Iterable&lt;Module&gt;} modules unordered modules
	 * @param {Compilation} compilation compilation
	 * @returns {Module[]} ordered modules
	 */
	getModulesInOrder(chunk, modules, compilation) {
		if (!modules) return [];

		/** @type {Module[]} */
		const modulesList = [...modules];

		// Get ordered list of modules per chunk group
		// Lists are in reverse order to allow to use Array.pop()
		const modulesByChunkGroup = Array.from(chunk.groupsIterable, chunkGroup =&gt; {
			const sortedModules = modulesList
				.map(module =&gt; ({
					module,
					index: chunkGroup.getModulePostOrderIndex(module)
				}))
				.filter(item =&gt; item.index !== undefined)
				.sort(
					(a, b) =&gt;
						/** @type {number} */ (b.index) - /** @type {number} */ (a.index)
				)
				.map(item =&gt; item.module);

			return { list: sortedModules, set: new Set(sortedModules) };
		});

		if (modulesByChunkGroup.length === 1)
			return modulesByChunkGroup[0].list.reverse();

		const boundCompareModulesByIdOrIdentifier = compareModulesByIdOrIdentifier(
			compilation.chunkGraph
		);

		/**
		 * @param {{ list: Module[] }} a a
		 * @param {{ list: Module[] }} b b
		 * @returns {-1 | 0 | 1} result
		 */
		const compareModuleLists = ({ list: a }, { list: b }) =&gt; {
			if (a.length === 0) {
				return b.length === 0 ? 0 : 1;
			}
			if (b.length === 0) return -1;
			return boundCompareModulesByIdOrIdentifier(
				a[a.length - 1],
				b[b.length - 1]
			);
		};

		modulesByChunkGroup.sort(compareModuleLists);

		/** @type {Module[]} */
		const finalModules = [];

		for (;;) {
			const failedModules = new Set();
			const list = modulesByChunkGroup[0].list;
			if (list.length === 0) {
				// done, everything empty
				break;
			}
			/** @type {Module} */
			let selectedModule = list[list.length - 1];
			let hasFailed;
			outer: for (;;) {
				for (const { list, set } of modulesByChunkGroup) {
					if (list.length === 0) continue;
					const lastModule = list[list.length - 1];
					if (lastModule === selectedModule) continue;
					if (!set.has(selectedModule)) continue;
					failedModules.add(selectedModule);
					if (failedModules.has(lastModule)) {
						// There is a conflict, try other alternatives
						hasFailed = lastModule;
						continue;
					}
					selectedModule = lastModule;
					hasFailed = false;
					continue outer; // restart
				}
				break;
			}
			if (hasFailed) {
				// There is a not resolve-able conflict with the selectedModule
				// TODO print better warning
				compilation.warnings.push(
					new WebpackError(
						`chunk ${chunk.name || chunk.id}\nConflicting order between ${
							/** @type {Module} */
							(hasFailed).readableIdentifier(compilation.requestShortener)
						} and ${selectedModule.readableIdentifier(
							compilation.requestShortener
						)}`
					)
				);
				selectedModule = /** @type {Module} */ (hasFailed);
			}
			// Insert the selected module into the final modules list
			finalModules.push(selectedModule);
			// Remove the selected module from all lists
			for (const { list, set } of modulesByChunkGroup) {
				const lastModule = list[list.length - 1];
				if (lastModule === selectedModule) list.pop();
				else if (hasFailed &amp;&amp; set.has(selectedModule)) {
					const idx = list.indexOf(selectedModule);
					if (idx &gt;= 0) list.splice(idx, 1);
				}
			}
			modulesByChunkGroup.sort(compareModuleLists);
		}
		return finalModules;
	}

	/**
	 * @param {Chunk} chunk chunk
	 * @param {ChunkGraph} chunkGraph chunk graph
	 * @param {Compilation} compilation compilation
	 * @returns {Module[]} ordered css modules
	 */
	getOrderedChunkCssModules(chunk, chunkGraph, compilation) {
		return [
			...this.getModulesInOrder(
				chunk,
				/** @type {Iterable&lt;Module&gt;} */
				(
					chunkGraph.getOrderedChunkModulesIterableBySourceType(
						chunk,
						&quot;css-import&quot;,
						compareModulesByIdOrIdentifier(chunkGraph)
					)
				),
				compilation
			),
			...this.getModulesInOrder(
				chunk,
				/** @type {Iterable&lt;Module&gt;} */
				(
					chunkGraph.getOrderedChunkModulesIterableBySourceType(
						chunk,
						&quot;css&quot;,
						compareModulesByIdOrIdentifier(chunkGraph)
					)
				),
				compilation
			)
		];
	}

	/**
	 * @param {CssModule} module css module
	 * @param {ChunkRenderContext} renderContext options object
	 * @param {CompilationHooks} hooks hooks
	 * @returns {Source} css module source
	 */
	renderModule(module, renderContext, hooks) {
		const { codeGenerationResults, chunk, undoPath } = renderContext;
		const codeGenResult = codeGenerationResults.get(module, chunk.runtime);
		const moduleSourceContent =
			/** @type {Source} */
			(
				codeGenResult.sources.get(&quot;css&quot;) ||
					codeGenResult.sources.get(&quot;css-import&quot;)
			);
		const cacheEntry = this._moduleFactoryCache.get(moduleSourceContent);

		/** @type {Inheritance} */
		const inheritance = [[module.cssLayer, module.supports, module.media]];
		if (module.inheritance) {
			inheritance.push(...module.inheritance);
		}

		let source;
		if (
			cacheEntry &amp;&amp;
			cacheEntry.undoPath === undoPath &amp;&amp;
			cacheEntry.inheritance.every(([layer, supports, media], i) =&gt; {
				const item = inheritance[i];
				if (Array.isArray(item)) {
					return layer === item[0] &amp;&amp; supports === item[1] &amp;&amp; media === item[2];
				}
				return false;
			})
		) {
			source = cacheEntry.source;
		} else {
			const moduleSourceCode =
				/** @type {string} */
				(moduleSourceContent.source());
			const publicPathAutoRegex = new RegExp(
				CssUrlDependency.PUBLIC_PATH_AUTO,
				&quot;g&quot;
			);
			/** @type {Source} */
			let moduleSource = new ReplaceSource(moduleSourceContent);
			let match;
			while ((match = publicPathAutoRegex.exec(moduleSourceCode))) {
				/** @type {ReplaceSource} */ (moduleSource).replace(
					match.index,
					(match.index += match[0].length - 1),
					undoPath
				);
			}

			for (let i = 0; i &lt; inheritance.length; i++) {
				const layer = inheritance[i][0];
				const supports = inheritance[i][1];
				const media = inheritance[i][2];

				if (media) {
					moduleSource = new ConcatSource(
						`@media ${media} {\n`,
						new PrefixSource(&quot;\t&quot;, moduleSource),
						&quot;}\n&quot;
					);
				}

				if (supports) {
					moduleSource = new ConcatSource(
						`@supports (${supports}) {\n`,
						new PrefixSource(&quot;\t&quot;, moduleSource),
						&quot;}\n&quot;
					);
				}

				// Layer can be anonymous
				if (layer !== undefined &amp;&amp; layer !== null) {
					moduleSource = new ConcatSource(
						`@layer${layer ? ` ${layer}` : &quot;&quot;} {\n`,
						new PrefixSource(&quot;\t&quot;, moduleSource),
						&quot;}\n&quot;
					);
				}
			}

			if (moduleSource) {
				moduleSource = new ConcatSource(moduleSource, &quot;\n&quot;);
			}

			source = new CachedSource(moduleSource);
			this._moduleFactoryCache.set(moduleSourceContent, {
				inheritance,
				undoPath,
				source
			});
		}

		return tryRunOrWebpackError(
			() =&gt; hooks.renderModulePackage.call(source, module, renderContext),
			&quot;CssModulesPlugin.getCompilationHooks().renderModulePackage&quot;
		);
	}

	/**
	 * @param {RenderContext} renderContext the render context
	 * @param {CompilationHooks} hooks hooks
	 * @returns {Source} generated source
	 */
	renderChunk(
		{
			undoPath,
			chunk,
			chunkGraph,
			codeGenerationResults,
			modules,
			runtimeTemplate
		},
		hooks
	) {
		const source = new ConcatSource();
		for (const module of modules) {
			try {
				const moduleSource = this.renderModule(
					module,
					{
						undoPath,
						chunk,
						chunkGraph,
						codeGenerationResults,
						runtimeTemplate
					},
					hooks
				);
				source.add(moduleSource);
			} catch (err) {
				/** @type {Error} */
				(err).message += `\nduring rendering of css ${module.identifier()}`;
				throw err;
			}
		}
		chunk.rendered = true;
		return source;
	}

	/**
	 * @param {Chunk} chunk chunk
	 * @param {OutputOptions} outputOptions output options
	 * @returns {TemplatePath} used filename template
	 */
	static getChunkFilenameTemplate(chunk, outputOptions) {
		if (chunk.cssFilenameTemplate) {
			return chunk.cssFilenameTemplate;
		} else if (chunk.canBeInitial()) {
			return /** @type {TemplatePath} */ (outputOptions.cssFilename);
		}
		return /** @type {TemplatePath} */ (outputOptions.cssChunkFilename);
	}

	/**
	 * @param {Chunk} chunk chunk
	 * @param {ChunkGraph} chunkGraph chunk graph
	 * @returns {boolean} true, when the chunk has css
	 */
	static chunkHasCss(chunk, chunkGraph) {
		return (
			Boolean(chunkGraph.getChunkModulesIterableBySourceType(chunk, &quot;css&quot;)) ||
			Boolean(
				chunkGraph.getChunkModulesIterableBySourceType(chunk, &quot;css-import&quot;)
			)
		);
	}
}

module.exports = CssModulesPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
