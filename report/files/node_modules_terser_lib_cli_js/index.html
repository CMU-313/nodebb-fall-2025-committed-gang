<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/terser/lib/cli.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/terser/lib/cli.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">483</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">74.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.45</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { minify, _default_options } from &quot;../main.js&quot;;
import { parse } from &quot;./parse.js&quot;;
import {
    AST_Assign,
    AST_Array,
    AST_Constant,
    AST_Node,
    AST_PropAccess,
    AST_RegExp,
    AST_Sequence,
    AST_Symbol,
    AST_Token,
    walk
} from &quot;./ast.js&quot;;
import { OutputStream } from &quot;./output.js&quot;;

export async function run_cli({ program, packageJson, fs, path }) {
    const skip_keys = new Set([ &quot;cname&quot;, &quot;parent_scope&quot;, &quot;scope&quot;, &quot;uses_eval&quot;, &quot;uses_with&quot; ]);
    var files = {};
    var options = {
        compress: false,
        mangle: false
    };
    const default_options = await _default_options();
    program.version(packageJson.name + &quot; &quot; + packageJson.version);
    program.parseArgv = program.parse;
    program.parse = undefined;

    if (process.argv.includes(&quot;ast&quot;)) program.helpInformation = describe_ast;
    else if (process.argv.includes(&quot;options&quot;)) program.helpInformation = function() {
        var text = [];
        for (var option in default_options) {
            text.push(&quot;--&quot; + (option === &quot;sourceMap&quot; ? &quot;source-map&quot; : option) + &quot; options:&quot;);
            text.push(format_object(default_options[option]));
            text.push(&quot;&quot;);
        }
        return text.join(&quot;\n&quot;);
    };

    program.option(&quot;-p, --parse &lt;options&gt;&quot;, &quot;Specify parser options.&quot;, parse_js());
    program.option(&quot;-c, --compress [options]&quot;, &quot;Enable compressor/specify compressor options.&quot;, parse_js());
    program.option(&quot;-m, --mangle [options]&quot;, &quot;Mangle names/specify mangler options.&quot;, parse_js());
    program.option(&quot;--mangle-props [options]&quot;, &quot;Mangle properties/specify mangler options.&quot;, parse_js());
    program.option(&quot;-f, --format [options]&quot;, &quot;Format options.&quot;, parse_js());
    program.option(&quot;-b, --beautify [options]&quot;, &quot;Alias for --format.&quot;, parse_js());
    program.option(&quot;-o, --output &lt;file&gt;&quot;, &quot;Output file (default STDOUT).&quot;);
    program.option(&quot;--comments [filter]&quot;, &quot;Preserve copyright comments in the output.&quot;);
    program.option(&quot;--config-file &lt;file&gt;&quot;, &quot;Read minify() options from JSON file.&quot;);
    program.option(&quot;-d, --define &lt;expr&gt;[=value]&quot;, &quot;Global definitions.&quot;, parse_js(&quot;define&quot;));
    program.option(&quot;--ecma &lt;version&gt;&quot;, &quot;Specify ECMAScript release: 5, 2015, 2016 or 2017...&quot;);
    program.option(&quot;-e, --enclose [arg[,...][:value[,...]]]&quot;, &quot;Embed output in a big function with configurable arguments and values.&quot;);
    program.option(&quot;--ie8&quot;, &quot;Support non-standard Internet Explorer 8.&quot;);
    program.option(&quot;--keep-classnames&quot;, &quot;Do not mangle/drop class names.&quot;);
    program.option(&quot;--keep-fnames&quot;, &quot;Do not mangle/drop function names. Useful for code relying on Function.prototype.name.&quot;);
    program.option(&quot;--module&quot;, &quot;Input is an ES6 module&quot;);
    program.option(&quot;--name-cache &lt;file&gt;&quot;, &quot;File to hold mangled name mappings.&quot;);
    program.option(&quot;--rename&quot;, &quot;Force symbol expansion.&quot;);
    program.option(&quot;--no-rename&quot;, &quot;Disable symbol expansion.&quot;);
    program.option(&quot;--safari10&quot;, &quot;Support non-standard Safari 10.&quot;);
    program.option(&quot;--source-map [options]&quot;, &quot;Enable source map/specify source map options.&quot;, parse_js());
    program.option(&quot;--timings&quot;, &quot;Display operations run time on STDERR.&quot;);
    program.option(&quot;--toplevel&quot;, &quot;Compress and/or mangle variables in toplevel scope.&quot;);
    program.option(&quot;--wrap &lt;name&gt;&quot;, &quot;Embed everything as a function with “exports” corresponding to “name” globally.&quot;);
    program.arguments(&quot;[files...]&quot;).parseArgv(process.argv);
    if (program.configFile) {
        options = JSON.parse(read_file(program.configFile));
    }
    if (!program.output &amp;&amp; program.sourceMap &amp;&amp; program.sourceMap.url != &quot;inline&quot;) {
        fatal(&quot;ERROR: cannot write source map to STDOUT&quot;);
    }

    [
        &quot;compress&quot;,
        &quot;enclose&quot;,
        &quot;ie8&quot;,
        &quot;mangle&quot;,
        &quot;module&quot;,
        &quot;safari10&quot;,
        &quot;sourceMap&quot;,
        &quot;toplevel&quot;,
        &quot;wrap&quot;
    ].forEach(function(name) {
        if (name in program) {
            options[name] = program[name];
        }
    });

    if (&quot;ecma&quot; in program) {
        if (program.ecma != (program.ecma | 0)) fatal(&quot;ERROR: ecma must be an integer&quot;);
        const ecma = program.ecma | 0;
        if (ecma &gt; 5 &amp;&amp; ecma &lt; 2015)
            options.ecma = ecma + 2009;
        else
            options.ecma = ecma;
    }
    if (program.format || program.beautify) {
        const chosenOption = program.format || program.beautify;
        options.format = typeof chosenOption === &quot;object&quot; ? chosenOption : {};
    }
    if (program.comments) {
        if (typeof options.format != &quot;object&quot;) options.format = {};
        options.format.comments = typeof program.comments == &quot;string&quot; ? (program.comments == &quot;false&quot; ? false : program.comments) : &quot;some&quot;;
    }
    if (program.define) {
        if (typeof options.compress != &quot;object&quot;) options.compress = {};
        if (typeof options.compress.global_defs != &quot;object&quot;) options.compress.global_defs = {};
        for (var expr in program.define) {
            options.compress.global_defs[expr] = program.define[expr];
        }
    }
    if (program.keepClassnames) {
        options.keep_classnames = true;
    }
    if (program.keepFnames) {
        options.keep_fnames = true;
    }
    if (program.mangleProps) {
        if (program.mangleProps.domprops) {
            delete program.mangleProps.domprops;
        } else {
            if (typeof program.mangleProps != &quot;object&quot;) program.mangleProps = {};
            if (!Array.isArray(program.mangleProps.reserved)) program.mangleProps.reserved = [];
        }
        if (typeof options.mangle != &quot;object&quot;) options.mangle = {};
        options.mangle.properties = program.mangleProps;
    }
    if (program.nameCache) {
        options.nameCache = JSON.parse(read_file(program.nameCache, &quot;{}&quot;));
    }
    if (program.output == &quot;ast&quot;) {
        options.format = {
            ast: true,
            code: false
        };
    }
    if (program.parse) {
        if (!program.parse.acorn &amp;&amp; !program.parse.spidermonkey) {
            options.parse = program.parse;
        } else if (program.sourceMap &amp;&amp; program.sourceMap.content == &quot;inline&quot;) {
            fatal(&quot;ERROR: inline source map only works with built-in parser&quot;);
        }
    }
    if (~program.rawArgs.indexOf(&quot;--rename&quot;)) {
        options.rename = true;
    } else if (!program.rename) {
        options.rename = false;
    }

    let convert_path = name =&gt; name;
    if (typeof program.sourceMap == &quot;object&quot; &amp;&amp; &quot;base&quot; in program.sourceMap) {
        convert_path = function() {
            var base = program.sourceMap.base;
            delete options.sourceMap.base;
            return function(name) {
                return path.relative(base, name);
            };
        }();
    }

    let filesList;
    if (options.files &amp;&amp; options.files.length) {
        filesList = options.files;

        delete options.files;
    } else if (program.args.length) {
        filesList = program.args;
    }

    if (filesList) {
        simple_glob(filesList).forEach(function(name) {
            files[convert_path(name)] = read_file(name);
        });
    } else {
        await new Promise((resolve) =&gt; {
            var chunks = [];
            process.stdin.setEncoding(&quot;utf8&quot;);
            process.stdin.on(&quot;data&quot;, function(chunk) {
                chunks.push(chunk);
            }).on(&quot;end&quot;, function() {
                files = [ chunks.join(&quot;&quot;) ];
                resolve();
            });
            process.stdin.resume();
        });
    }

    await run_cli();

    function convert_ast(fn) {
        return AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
    }

    async function run_cli() {
        var content = program.sourceMap &amp;&amp; program.sourceMap.content;
        if (content &amp;&amp; content !== &quot;inline&quot;) {
            options.sourceMap.content = read_file(content, content);
        }
        if (program.timings) options.timings = true;

        try {
            if (program.parse) {
                if (program.parse.acorn) {
                    files = convert_ast(function(toplevel, name) {
                        return require(&quot;acorn&quot;).parse(files[name], {
                            ecmaVersion: 2024,
                            locations: true,
                            program: toplevel,
                            sourceFile: name,
                            sourceType: options.module || program.parse.module ? &quot;module&quot; : &quot;script&quot;
                        });
                    });
                } else if (program.parse.spidermonkey) {
                    files = convert_ast(function(toplevel, name) {
                        var obj = JSON.parse(files[name]);
                        if (!toplevel) return obj;
                        toplevel.body = toplevel.body.concat(obj.body);
                        return toplevel;
                    });
                }
            }
        } catch (ex) {
            fatal(ex);
        }

        let result;
        try {
            result = await minify(files, options, fs);
        } catch (ex) {
            if (ex.name == &quot;SyntaxError&quot;) {
                print_error(&quot;Parse error at &quot; + ex.filename + &quot;:&quot; + ex.line + &quot;,&quot; + ex.col);
                var col = ex.col;
                var lines = files[ex.filename].split(/\r?\n/);
                var line = lines[ex.line - 1];
                if (!line &amp;&amp; !col) {
                    line = lines[ex.line - 2];
                    col = line.length;
                }
                if (line) {
                    var limit = 70;
                    if (col &gt; limit) {
                        line = line.slice(col - limit);
                        col = limit;
                    }
                    print_error(line.slice(0, 80));
                    print_error(line.slice(0, col).replace(/\S/g, &quot; &quot;) + &quot;^&quot;);
                }
            }
            if (ex.defs) {
                print_error(&quot;Supported options:&quot;);
                print_error(format_object(ex.defs));
            }
            fatal(ex);
            return;
        }

        if (program.output == &quot;ast&quot;) {
            if (!options.compress &amp;&amp; !options.mangle) {
                result.ast.figure_out_scope({});
            }
            console.log(JSON.stringify(result.ast, function(key, value) {
                if (value) switch (key) {
                  case &quot;thedef&quot;:
                    return symdef(value);
                  case &quot;enclosed&quot;:
                    return value.length ? value.map(symdef) : undefined;
                  case &quot;variables&quot;:
                  case &quot;globals&quot;:
                    return value.size ? collect_from_map(value, symdef) : undefined;
                }
                if (skip_keys.has(key)) return;
                if (value instanceof AST_Token) return;
                if (value instanceof Map) return;
                if (value instanceof AST_Node) {
                    var result = {
                        _class: &quot;AST_&quot; + value.TYPE
                    };
                    if (value.block_scope) {
                        result.variables = value.block_scope.variables;
                        result.enclosed = value.block_scope.enclosed;
                    }
                    value.CTOR.PROPS.forEach(function(prop) {
                        if (prop !== &quot;block_scope&quot;) {
                            result[prop] = value[prop];
                        }
                    });
                    return result;
                }
                return value;
            }, 2));
        } else if (program.output == &quot;spidermonkey&quot;) {
            try {
                const minified = await minify(
                    result.code,
                    {
                        compress: false,
                        mangle: false,
                        format: {
                            ast: true,
                            code: false
                        }
                    },
                    fs
                );
                console.log(JSON.stringify(minified.ast.to_mozilla_ast(), null, 2));
            } catch (ex) {
                fatal(ex);
                return;
            }
        } else if (program.output) {
            fs.mkdirSync(path.dirname(program.output), { recursive: true });
            fs.writeFileSync(program.output, result.code);
            if (options.sourceMap &amp;&amp; options.sourceMap.url !== &quot;inline&quot; &amp;&amp; result.map) {
                fs.writeFileSync(program.output + &quot;.map&quot;, result.map);
            }
        } else {
            console.log(result.code);
        }
        if (program.nameCache) {
            fs.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));
        }
        if (result.timings) for (var phase in result.timings) {
            print_error(&quot;- &quot; + phase + &quot;: &quot; + result.timings[phase].toFixed(3) + &quot;s&quot;);
        }
    }

    function fatal(message) {
        if (message instanceof Error) message = message.stack.replace(/^\S*?Error:/, &quot;ERROR:&quot;);
        print_error(message);
        process.exit(1);
    }

    // A file glob function that only supports &quot;*&quot; and &quot;?&quot; wildcards in the basename.
    // Example: &quot;foo/bar/*baz??.*.js&quot;
    // Argument `glob` may be a string or an array of strings.
    // Returns an array of strings. Garbage in, garbage out.
    function simple_glob(glob) {
        if (Array.isArray(glob)) {
            return [].concat.apply([], glob.map(simple_glob));
        }
        if (glob &amp;&amp; glob.match(/[*?]/)) {
            var dir = path.dirname(glob);
            try {
                var entries = fs.readdirSync(dir);
            } catch (ex) {}
            if (entries) {
                var pattern = &quot;^&quot; + path.basename(glob)
                    .replace(/[.+^$[\]\\(){}]/g, &quot;\\$&amp;&quot;)
                    .replace(/\*/g, &quot;[^/\\\\]*&quot;)
                    .replace(/\?/g, &quot;[^/\\\\]&quot;) + &quot;$&quot;;
                var mod = process.platform === &quot;win32&quot; ? &quot;i&quot; : &quot;&quot;;
                var rx = new RegExp(pattern, mod);
                var results = entries.filter(function(name) {
                    return rx.test(name);
                }).map(function(name) {
                    return path.join(dir, name);
                });
                if (results.length) return results;
            }
        }
        return [ glob ];
    }

    function read_file(path, default_value) {
        try {
            return fs.readFileSync(path, &quot;utf8&quot;);
        } catch (ex) {
            if ((ex.code == &quot;ENOENT&quot; || ex.code == &quot;ENAMETOOLONG&quot;) &amp;&amp; default_value != null) return default_value;
            fatal(ex);
        }
    }

    function parse_js(flag) {
        return function(value, options) {
            options = options || {};
            try {
                walk(parse(value, { expression: true }), node =&gt; {
                    if (node instanceof AST_Assign) {
                        var name = node.left.print_to_string();
                        var value = node.right;
                        if (flag) {
                            options[name] = value;
                        } else if (value instanceof AST_Array) {
                            options[name] = value.elements.map(to_string);
                        } else if (value instanceof AST_RegExp) {
                            value = value.value;
                            options[name] = new RegExp(value.source, value.flags);
                        } else {
                            options[name] = to_string(value);
                        }
                        return true;
                    }
                    if (node instanceof AST_Symbol || node instanceof AST_PropAccess) {
                        var name = node.print_to_string();
                        options[name] = true;
                        return true;
                    }
                    if (!(node instanceof AST_Sequence)) throw node;

                    function to_string(value) {
                        return value instanceof AST_Constant ? value.getValue() : value.print_to_string({
                            quote_keys: true
                        });
                    }
                });
            } catch(ex) {
                if (flag) {
                    fatal(&quot;Error parsing arguments for &#039;&quot; + flag + &quot;&#039;: &quot; + value);
                } else {
                    options[value] = null;
                }
            }
            return options;
        };
    }

    function symdef(def) {
        var ret = (1e6 + def.id) + &quot; &quot; + def.name;
        if (def.mangled_name) ret += &quot; &quot; + def.mangled_name;
        return ret;
    }

    function collect_from_map(map, callback) {
        var result = [];
        map.forEach(function (def) {
            result.push(callback(def));
        });
        return result;
    }

    function format_object(obj) {
        var lines = [];
        var padding = &quot;&quot;;
        Object.keys(obj).map(function(name) {
            if (padding.length &lt; name.length) padding = Array(name.length + 1).join(&quot; &quot;);
            return [ name, JSON.stringify(obj[name]) ];
        }).forEach(function(tokens) {
            lines.push(&quot;  &quot; + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
        });
        return lines.join(&quot;\n&quot;);
    }

    function print_error(msg) {
        process.stderr.write(msg);
        process.stderr.write(&quot;\n&quot;);
    }

    function describe_ast() {
        var out = OutputStream({ beautify: true });
        function doitem(ctor) {
            out.print(&quot;AST_&quot; + ctor.TYPE);
            const props = ctor.SELF_PROPS.filter(prop =&gt; !/^\$/.test(prop));

            if (props.length &gt; 0) {
                out.space();
                out.with_parens(function() {
                    props.forEach(function(prop, i) {
                        if (i) out.space();
                        out.print(prop);
                    });
                });
            }

            if (ctor.documentation) {
                out.space();
                out.print_string(ctor.documentation);
            }

            if (ctor.SUBCLASSES.length &gt; 0) {
                out.space();
                out.with_block(function() {
                    ctor.SUBCLASSES.forEach(function(ctor) {
                        out.indent();
                        doitem(ctor);
                        out.newline();
                    });
                });
            }
        }
        doitem(AST_Node);
        return out + &quot;\n&quot;;
    }
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
