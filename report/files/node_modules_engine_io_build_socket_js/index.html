<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/engine.io/build/socket.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/engine.io/build/socket.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">461</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">71.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.90</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.Socket = void 0;
const events_1 = require(&quot;events&quot;);
const debug_1 = require(&quot;debug&quot;);
const timers_1 = require(&quot;timers&quot;);
const debug = (0, debug_1.default)(&quot;engine:socket&quot;);
class Socket extends events_1.EventEmitter {
    get readyState() {
        return this._readyState;
    }
    set readyState(state) {
        debug(&quot;readyState updated from %s to %s&quot;, this._readyState, state);
        this._readyState = state;
    }
    constructor(id, server, transport, req, protocol) {
        super();
        /**
         * The current state of the socket.
         */
        this._readyState = &quot;opening&quot;;
        /* private */ this.upgrading = false;
        /* private */ this.upgraded = false;
        this.writeBuffer = [];
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.cleanupFn = [];
        this.id = id;
        this.server = server;
        this.request = req;
        this.protocol = protocol;
        // Cache IP since it might not be in the req later
        if (req) {
            if (req.websocket &amp;&amp; req.websocket._socket) {
                this.remoteAddress = req.websocket._socket.remoteAddress;
            }
            else {
                this.remoteAddress = req.connection.remoteAddress;
            }
        }
        else {
            // TODO there is currently no way to get the IP address of the client when it connects with WebTransport
            //  see https://github.com/fails-components/webtransport/issues/114
        }
        this.pingTimeoutTimer = null;
        this.pingIntervalTimer = null;
        this.setTransport(transport);
        this.onOpen();
    }
    /**
     * Called upon transport considered open.
     *
     * @private
     */
    onOpen() {
        this.readyState = &quot;open&quot;;
        // sends an `open` packet
        this.transport.sid = this.id;
        this.sendPacket(&quot;open&quot;, JSON.stringify({
            sid: this.id,
            upgrades: this.getAvailableUpgrades(),
            pingInterval: this.server.opts.pingInterval,
            pingTimeout: this.server.opts.pingTimeout,
            maxPayload: this.server.opts.maxHttpBufferSize,
        }));
        if (this.server.opts.initialPacket) {
            this.sendPacket(&quot;message&quot;, this.server.opts.initialPacket);
        }
        this.emit(&quot;open&quot;);
        if (this.protocol === 3) {
            // in protocol v3, the client sends a ping, and the server answers with a pong
            this.resetPingTimeout();
        }
        else {
            // in protocol v4, the server sends a ping, and the client answers with a pong
            this.schedulePing();
        }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @private
     */
    onPacket(packet) {
        if (&quot;open&quot; !== this.readyState) {
            return debug(&quot;packet received with closed socket&quot;);
        }
        // export packet event
        debug(`received packet ${packet.type}`);
        this.emit(&quot;packet&quot;, packet);
        switch (packet.type) {
            case &quot;ping&quot;:
                if (this.transport.protocol !== 3) {
                    this.onError(new Error(&quot;invalid heartbeat direction&quot;));
                    return;
                }
                debug(&quot;got ping&quot;);
                this.pingTimeoutTimer.refresh();
                this.sendPacket(&quot;pong&quot;);
                this.emit(&quot;heartbeat&quot;);
                break;
            case &quot;pong&quot;:
                if (this.transport.protocol === 3) {
                    this.onError(new Error(&quot;invalid heartbeat direction&quot;));
                    return;
                }
                debug(&quot;got pong&quot;);
                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                this.pingIntervalTimer.refresh();
                this.emit(&quot;heartbeat&quot;);
                break;
            case &quot;error&quot;:
                this.onClose(&quot;parse error&quot;);
                break;
            case &quot;message&quot;:
                this.emit(&quot;data&quot;, packet.data);
                this.emit(&quot;message&quot;, packet.data);
                break;
        }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} err - error object
     * @private
     */
    onError(err) {
        debug(&quot;transport error&quot;);
        this.onClose(&quot;transport error&quot;, err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @private
     */
    schedulePing() {
        this.pingIntervalTimer = (0, timers_1.setTimeout)(() =&gt; {
            debug(&quot;writing ping packet - expecting pong within %sms&quot;, this.server.opts.pingTimeout);
            this.sendPacket(&quot;ping&quot;);
            this.resetPingTimeout();
        }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @private
     */
    resetPingTimeout() {
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() =&gt; {
            if (this.readyState === &quot;closed&quot;)
                return;
            this.onClose(&quot;ping timeout&quot;);
        }, this.protocol === 3
            ? this.server.opts.pingInterval + this.server.opts.pingTimeout
            : this.server.opts.pingTimeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @private
     */
    setTransport(transport) {
        const onError = this.onError.bind(this);
        const onReady = () =&gt; this.flush();
        const onPacket = this.onPacket.bind(this);
        const onDrain = this.onDrain.bind(this);
        const onClose = this.onClose.bind(this, &quot;transport close&quot;);
        this.transport = transport;
        this.transport.once(&quot;error&quot;, onError);
        this.transport.on(&quot;ready&quot;, onReady);
        this.transport.on(&quot;packet&quot;, onPacket);
        this.transport.on(&quot;drain&quot;, onDrain);
        this.transport.once(&quot;close&quot;, onClose);
        this.cleanupFn.push(function () {
            transport.removeListener(&quot;error&quot;, onError);
            transport.removeListener(&quot;ready&quot;, onReady);
            transport.removeListener(&quot;packet&quot;, onPacket);
            transport.removeListener(&quot;drain&quot;, onDrain);
            transport.removeListener(&quot;close&quot;, onClose);
        });
    }
    /**
     * Upon transport &quot;drain&quot; event
     *
     * @private
     */
    onDrain() {
        if (this.sentCallbackFn.length &gt; 0) {
            debug(&quot;executing batch send callback&quot;);
            const seqFn = this.sentCallbackFn.shift();
            if (seqFn) {
                for (let i = 0; i &lt; seqFn.length; i++) {
                    seqFn[i](this.transport);
                }
            }
        }
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @private
     */
    /* private */ _maybeUpgrade(transport) {
        debug(&#039;might upgrade socket transport from &quot;%s&quot; to &quot;%s&quot;&#039;, this.transport.name, transport.name);
        this.upgrading = true;
        // set transport upgrade timer
        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() =&gt; {
            debug(&quot;client did not complete upgrade - closing transport&quot;);
            cleanup();
            if (&quot;open&quot; === transport.readyState) {
                transport.close();
            }
        }, this.server.opts.upgradeTimeout);
        let checkIntervalTimer;
        const onPacket = (packet) =&gt; {
            if (&quot;ping&quot; === packet.type &amp;&amp; &quot;probe&quot; === packet.data) {
                debug(&quot;got probe ping packet, sending pong&quot;);
                transport.send([{ type: &quot;pong&quot;, data: &quot;probe&quot; }]);
                this.emit(&quot;upgrading&quot;, transport);
                clearInterval(checkIntervalTimer);
                checkIntervalTimer = setInterval(check, 100);
            }
            else if (&quot;upgrade&quot; === packet.type &amp;&amp; this.readyState !== &quot;closed&quot;) {
                debug(&quot;got upgrade packet - upgrading&quot;);
                cleanup();
                this.transport.discard();
                this.upgraded = true;
                this.clearTransport();
                this.setTransport(transport);
                this.emit(&quot;upgrade&quot;, transport);
                this.flush();
                if (this.readyState === &quot;closing&quot;) {
                    transport.close(() =&gt; {
                        this.onClose(&quot;forced close&quot;);
                    });
                }
            }
            else {
                cleanup();
                transport.close();
            }
        };
        // we force a polling cycle to ensure a fast upgrade
        const check = () =&gt; {
            if (&quot;polling&quot; === this.transport.name &amp;&amp; this.transport.writable) {
                debug(&quot;writing a noop packet to polling for fast upgrade&quot;);
                this.transport.send([{ type: &quot;noop&quot; }]);
            }
        };
        const cleanup = () =&gt; {
            this.upgrading = false;
            clearInterval(checkIntervalTimer);
            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
            transport.removeListener(&quot;packet&quot;, onPacket);
            transport.removeListener(&quot;close&quot;, onTransportClose);
            transport.removeListener(&quot;error&quot;, onError);
            this.removeListener(&quot;close&quot;, onClose);
        };
        const onError = (err) =&gt; {
            debug(&quot;client did not complete upgrade - %s&quot;, err);
            cleanup();
            transport.close();
            transport = null;
        };
        const onTransportClose = () =&gt; {
            onError(&quot;transport closed&quot;);
        };
        const onClose = () =&gt; {
            onError(&quot;socket closed&quot;);
        };
        transport.on(&quot;packet&quot;, onPacket);
        transport.once(&quot;close&quot;, onTransportClose);
        transport.once(&quot;error&quot;, onError);
        this.once(&quot;close&quot;, onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @private
     */
    clearTransport() {
        let cleanup;
        const toCleanUp = this.cleanupFn.length;
        for (let i = 0; i &lt; toCleanUp; i++) {
            cleanup = this.cleanupFn.shift();
            cleanup();
        }
        // silence further transport errors and prevent uncaught exceptions
        this.transport.on(&quot;error&quot;, function () {
            debug(&quot;error triggered by discarded transport&quot;);
        });
        // ensure transport won&#039;t stay open
        this.transport.close();
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */
    onClose(reason, description) {
        if (&quot;closed&quot; !== this.readyState) {
            this.readyState = &quot;closed&quot;;
            // clear timers
            (0, timers_1.clearTimeout)(this.pingIntervalTimer);
            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
            // clean writeBuffer in next tick, so developers can still
            // grab the writeBuffer on &#039;close&#039; event
            process.nextTick(() =&gt; {
                this.writeBuffer = [];
            });
            this.packetsFn = [];
            this.sentCallbackFn = [];
            this.clearTransport();
            this.emit(&quot;close&quot;, reason, description);
        }
    }
    /**
     * Sends a message packet.
     *
     * @param {Object} data
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     */
    send(data, options, callback) {
        this.sendPacket(&quot;message&quot;, data, options, callback);
        return this;
    }
    /**
     * Alias of {@link send}.
     *
     * @param data
     * @param options
     * @param callback
     */
    write(data, options, callback) {
        this.sendPacket(&quot;message&quot;, data, options, callback);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type - packet type
     * @param {String} data
     * @param {Object} options
     * @param {Function} callback
     *
     * @private
     */
    sendPacket(type, data, options = {}, callback) {
        if (&quot;function&quot; === typeof options) {
            callback = options;
            options = {};
        }
        if (&quot;closing&quot; !== this.readyState &amp;&amp; &quot;closed&quot; !== this.readyState) {
            debug(&#039;sending packet &quot;%s&quot; (%s)&#039;, type, data);
            // compression is enabled by default
            options.compress = options.compress !== false;
            const packet = {
                type,
                options: options,
            };
            if (data)
                packet.data = data;
            // exports packetCreate event
            this.emit(&quot;packetCreate&quot;, packet);
            this.writeBuffer.push(packet);
            // add send callback to object, if defined
            if (&quot;function&quot; === typeof callback)
                this.packetsFn.push(callback);
            this.flush();
        }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @private
     */
    flush() {
        if (&quot;closed&quot; !== this.readyState &amp;&amp;
            this.transport.writable &amp;&amp;
            this.writeBuffer.length) {
            debug(&quot;flushing buffer to transport&quot;);
            this.emit(&quot;flush&quot;, this.writeBuffer);
            this.server.emit(&quot;flush&quot;, this, this.writeBuffer);
            const wbuf = this.writeBuffer;
            this.writeBuffer = [];
            if (this.packetsFn.length) {
                this.sentCallbackFn.push(this.packetsFn);
                this.packetsFn = [];
            }
            else {
                this.sentCallbackFn.push(null);
            }
            this.transport.send(wbuf);
            this.emit(&quot;drain&quot;);
            this.server.emit(&quot;drain&quot;, this);
        }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @private
     */
    getAvailableUpgrades() {
        const availableUpgrades = [];
        const allUpgrades = this.server.upgrades(this.transport.name);
        for (let i = 0; i &lt; allUpgrades.length; ++i) {
            const upg = allUpgrades[i];
            if (this.server.opts.transports.indexOf(upg) !== -1) {
                availableUpgrades.push(upg);
            }
        }
        return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} discard - optional, discard the transport
     * @return {Socket} for chaining
     */
    close(discard) {
        if (discard &amp;&amp;
            (this.readyState === &quot;open&quot; || this.readyState === &quot;closing&quot;)) {
            return this.closeTransport(discard);
        }
        if (&quot;open&quot; !== this.readyState)
            return;
        this.readyState = &quot;closing&quot;;
        if (this.writeBuffer.length) {
            debug(&quot;there are %d remaining packets in the buffer, waiting for the &#039;drain&#039; event&quot;, this.writeBuffer.length);
            this.once(&quot;drain&quot;, () =&gt; {
                debug(&quot;all packets have been sent, closing the transport&quot;);
                this.closeTransport(discard);
            });
            return;
        }
        debug(&quot;the buffer is empty, closing the transport right away&quot;);
        this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @private
     */
    closeTransport(discard) {
        debug(&quot;closing the transport (discard? %s)&quot;, !!discard);
        if (discard)
            this.transport.discard();
        this.transport.close(this.onClose.bind(this, &quot;forced close&quot;));
    }
}
exports.Socket = Socket;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
