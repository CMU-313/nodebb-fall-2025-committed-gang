<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/categories.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/categories.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">868</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">47.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const nconf = require(&#039;nconf&#039;);

const request = require(&#039;../src/request&#039;);
const db = require(&#039;./mocks/databasemock&#039;);
const Categories = require(&#039;../src/categories&#039;);
const Topics = require(&#039;../src/topics&#039;);
const User = require(&#039;../src/user&#039;);
const groups = require(&#039;../src/groups&#039;);
const privileges = require(&#039;../src/privileges&#039;);

describe(&#039;Categories&#039;, () =&gt; {
	let categoryObj;
	let posterUid;
	let adminUid;

	before(async () =&gt; {
		posterUid = await User.create({ username: &#039;poster&#039; });
		adminUid = await User.create({ username: &#039;admin&#039; });
		await groups.join(&#039;administrators&#039;, adminUid);
	});


	it(&#039;should create a new category&#039;, (done) =&gt; {
		Categories.create({
			name: &#039;Test Category &amp; NodeBB&#039;,
			description: &#039;Test category created by testing script&#039;,
			icon: &#039;fa-check&#039;,
			blockclass: &#039;category-blue&#039;,
			order: &#039;5&#039;,
		}, (err, category) =&gt; {
			assert.ifError(err);

			categoryObj = category;
			done();
		});
	});

	it(&#039;should retrieve a newly created category by its ID&#039;, (done) =&gt; {
		Categories.getCategoryById({
			cid: categoryObj.cid,
			start: 0,
			stop: -1,
			uid: 0,
		}, (err, categoryData) =&gt; {
			assert.ifError(err);

			assert(categoryData);
			assert.equal(&#039;Test Category &amp;amp; NodeBB&#039;, categoryData.name);
			assert.equal(categoryObj.description, categoryData.description);
			assert.strictEqual(categoryObj.disabled, 0);
			done();
		});
	});

	it(&#039;should return null if category does not exist&#039;, (done) =&gt; {
		Categories.getCategoryById({
			cid: 123123123,
			start: 0,
			stop: -1,
		}, (err, categoryData) =&gt; {
			assert.ifError(err);
			assert.strictEqual(categoryData, null);
			done();
		});
	});

	it(&#039;should get all categories&#039;, (done) =&gt; {
		Categories.getAllCategories((err, data) =&gt; {
			assert.ifError(err);
			assert(Array.isArray(data));
			assert.equal(data[0].cid, categoryObj.cid);
			done();
		});
	});

	it(&#039;should load a category route&#039;, async () =&gt; {
		const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/category/${categoryObj.cid}/test-category`);
		assert.equal(response.statusCode, 200);
		assert.equal(body.name, &#039;Test Category &amp;amp; NodeBB&#039;);
		assert(body);
	});

	describe(&#039;Categories.getRecentTopicReplies&#039;, () =&gt; {
		it(&#039;should not throw&#039;, (done) =&gt; {
			Categories.getCategoryById({
				cid: categoryObj.cid,
				set: `cid:${categoryObj.cid}:tids`,
				reverse: true,
				start: 0,
				stop: -1,
				uid: 0,
			}, (err, categoryData) =&gt; {
				assert.ifError(err);
				Categories.getRecentTopicReplies(categoryData, 0, {}, (err) =&gt; {
					assert.ifError(err);
					done();
				});
			});
		});
	});

	describe(&#039;.getCategoryTopics&#039;, () =&gt; {
		it(&#039;should return a list of topics&#039;, (done) =&gt; {
			Categories.getCategoryTopics({
				cid: categoryObj.cid,
				start: 0,
				stop: 10,
				uid: 0,
				sort: &#039;oldest_to_newest&#039;,
			}, (err, result) =&gt; {
				assert.equal(err, null);

				assert(Array.isArray(result.topics));
				assert(result.topics.every(topic =&gt; topic instanceof Object));

				done();
			});
		});

		it(&#039;should return a list of topics by a specific user&#039;, (done) =&gt; {
			Categories.getCategoryTopics({
				cid: categoryObj.cid,
				start: 0,
				stop: 10,
				uid: 0,
				targetUid: 1,
				sort: &#039;oldest_to_newest&#039;,
			}, (err, result) =&gt; {
				assert.equal(err, null);
				assert(Array.isArray(result.topics));
				assert(result.topics.every(topic =&gt; topic instanceof Object &amp;&amp; topic.uid === &#039;1&#039;));

				done();
			});
		});
	});

	describe(&#039;Categories.moveRecentReplies&#039;, () =&gt; {
		let moveCid;
		let moveTid;
		before(async () =&gt; {
			const [category, topic] = await Promise.all([
				Categories.create({
					name: &#039;Test Category 2&#039;,
					description: &#039;Test category created by testing script&#039;,
				}),
				Topics.post({
					uid: posterUid,
					cid: categoryObj.cid,
					title: &#039;Test Topic Title&#039;,
					content: &#039;The content of test topic&#039;,
				}),
			]);
			moveCid = category.cid;
			moveTid = topic.topicData.tid;
			await Topics.reply({ uid: posterUid, content: &#039;test post&#039;, tid: moveTid });
		});

		it(&#039;should move posts from one category to another&#039;, (done) =&gt; {
			Categories.moveRecentReplies(moveTid, categoryObj.cid, moveCid, (err) =&gt; {
				assert.ifError(err);
				db.getSortedSetRange(`cid:${categoryObj.cid}:pids`, 0, -1, (err, pids) =&gt; {
					assert.ifError(err);
					assert.equal(pids.length, 0);
					db.getSortedSetRange(`cid:${moveCid}:pids`, 0, -1, (err, pids) =&gt; {
						assert.ifError(err);
						assert.equal(pids.length, 2);
						done();
					});
				});
			});
		});
	});

	describe(&#039;api/socket methods&#039;, () =&gt; {
		const socketCategories = require(&#039;../src/socket.io/categories&#039;);
		const apiCategories = require(&#039;../src/api/categories&#039;);
		before(async () =&gt; {
			await Topics.post({
				uid: posterUid,
				cid: categoryObj.cid,
				title: &#039;Test Topic Title&#039;,
				content: &#039;The content of test topic&#039;,
				tags: [&#039;nodebb&#039;],
			});
			const data = await Topics.post({
				uid: posterUid,
				cid: categoryObj.cid,
				title: &#039;will delete&#039;,
				content: &#039;The content of deleted topic&#039;,
			});
			await Topics.delete(data.topicData.tid, adminUid);
		});

		it(&#039;should get recent replies in category&#039;, (done) =&gt; {
			socketCategories.getRecentReplies({ uid: posterUid }, categoryObj.cid, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it(&#039;should get categories&#039;, (done) =&gt; {
			socketCategories.get({ uid: posterUid }, {}, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it(&#039;should get watched categories&#039;, (done) =&gt; {
			socketCategories.getWatchedCategories({ uid: posterUid }, {}, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it(&#039;should load more topics&#039;, (done) =&gt; {
			socketCategories.loadMore({ uid: posterUid }, {
				cid: categoryObj.cid,
				after: 0,
				query: {
					author: &#039;poster&#039;,
					tag: &#039;nodebb&#039;,
				},
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data.topics));
				assert.equal(data.topics[0].user.username, &#039;poster&#039;);
				assert.equal(data.topics[0].tags[0].value, &#039;nodebb&#039;);
				assert.equal(data.topics[0].category.cid, categoryObj.cid);
				done();
			});
		});

		it(&#039;should not show deleted topic titles&#039;, async () =&gt; {
			const data = await socketCategories.loadMore({ uid: 0 }, {
				cid: categoryObj.cid,
				after: 0,
			});

			assert.deepStrictEqual(
				data.topics.map(t =&gt; t.title),
				[&#039;[[topic:topic-is-deleted]]&#039;, &#039;Test Topic Title&#039;, &#039;Test Topic Title&#039;],
			);
		});

		it(&#039;should load topic count&#039;, (done) =&gt; {
			socketCategories.getTopicCount({ uid: posterUid }, categoryObj.cid, (err, topicCount) =&gt; {
				assert.ifError(err);
				assert.strictEqual(topicCount, 3);
				done();
			});
		});

		it(&#039;should load category by privilege&#039;, (done) =&gt; {
			socketCategories.getCategoriesByPrivilege({ uid: posterUid }, &#039;find&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it(&#039;should get move categories&#039;, (done) =&gt; {
			socketCategories.getMoveCategories({ uid: posterUid }, {}, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it(&#039;should ignore category&#039;, (done) =&gt; {
			socketCategories.ignore({ uid: posterUid }, { cid: categoryObj.cid }, (err) =&gt; {
				assert.ifError(err);
				Categories.isIgnored([categoryObj.cid], posterUid, (err, isIgnored) =&gt; {
					assert.ifError(err);
					assert.equal(isIgnored[0], true);
					Categories.getIgnorers(categoryObj.cid, 0, -1, (err, ignorers) =&gt; {
						assert.ifError(err);
						assert.deepEqual(ignorers, [posterUid]);
						done();
					});
				});
			});
		});

		it(&#039;should watch category&#039;, (done) =&gt; {
			socketCategories.watch({ uid: posterUid }, { cid: categoryObj.cid }, (err) =&gt; {
				assert.ifError(err);
				Categories.isIgnored([categoryObj.cid], posterUid, (err, isIgnored) =&gt; {
					assert.ifError(err);
					assert.equal(isIgnored[0], false);
					done();
				});
			});
		});

		it(&#039;should error if watch state does not exist&#039;, (done) =&gt; {
			socketCategories.setWatchState({ uid: posterUid }, { cid: categoryObj.cid, state: &#039;invalid-state&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-watch-state]]&#039;);
				done();
			});
		});

		it(&#039;should check if user is moderator&#039;, (done) =&gt; {
			socketCategories.isModerator({ uid: posterUid }, {}, (err, isModerator) =&gt; {
				assert.ifError(err);
				assert(!isModerator);
				done();
			});
		});

		it(&#039;should get category data&#039;, async () =&gt; {
			const data = await apiCategories.get({ uid: posterUid }, { cid: categoryObj.cid });
			assert.equal(categoryObj.cid, data.cid);
		});
	});

	describe(&#039;admin api/socket methods&#039;, () =&gt; {
		const socketCategories = require(&#039;../src/socket.io/admin/categories&#039;);
		const apiCategories = require(&#039;../src/api/categories&#039;);
		let cid;
		before(async () =&gt; {
			const category = await apiCategories.create({ uid: adminUid }, {
				name: &#039;update name&#039;,
				description: &#039;update description&#039;,
				parentCid: categoryObj.cid,
				icon: &#039;fa-check&#039;,
				order: &#039;5&#039;,
			});
			cid = category.cid;
		});

		it(&#039;should return error with invalid data&#039;, async () =&gt; {
			let err;
			try {
				await apiCategories.update({ uid: adminUid }, null);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:invalid-data]]&#039;);
		});

		it(&#039;should error if you try to set parent as self&#039;, async () =&gt; {
			const updateData = {
				cid,
				values: {
					parentCid: cid,
				},
			};
			let err;
			try {
				await apiCategories.update({ uid: adminUid }, updateData);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:cant-set-self-as-parent]]&#039;);
		});

		it(&#039;should error if you try to set child as parent&#039;, async () =&gt; {
			const parentCategory = await Categories.create({ name: &#039;parent 1&#039;, description: &#039;poor parent&#039; });
			const parentCid = parentCategory.cid;
			const childCategory = await Categories.create({ name: &#039;child1&#039;, description: &#039;wanna be parent&#039;, parentCid: parentCid });
			const child1Cid = childCategory.cid;
			const updateData = {
				cid: parentCid,
				values: {
					parentCid: child1Cid,
				},
			};
			let err;
			try {
				await apiCategories.update({ uid: adminUid }, updateData);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:cant-set-child-as-parent]]&#039;);
		});

		it(&#039;should update category data&#039;, async () =&gt; {
			const updateData = {
				cid,
				values: {
					name: &#039;new name&#039;,
					description: &#039;new description&#039;,
					parentCid: 0,
					order: 3,
					icon: &#039;fa-hammer&#039;,
				},
			};
			await apiCategories.update({ uid: adminUid }, updateData);

			const data = await Categories.getCategoryData(cid);
			assert.equal(data.name, updateData.values.name);
			assert.equal(data.description, updateData.values.description);
			assert.equal(data.parentCid, updateData.values.parentCid);
			assert.equal(data.order, updateData.values.order);
			assert.equal(data.icon, updateData.values.icon);
		});

		it(&#039;should properly order categories&#039;, async () =&gt; {
			const p1 = await Categories.create({ name: &#039;p1&#039;, description: &#039;d&#039;, parentCid: 0, order: 1 });
			const c1 = await Categories.create({ name: &#039;c1&#039;, description: &#039;d1&#039;, parentCid: p1.cid, order: 1 });
			const c2 = await Categories.create({ name: &#039;c2&#039;, description: &#039;d2&#039;, parentCid: p1.cid, order: 2 });
			const c3 = await Categories.create({ name: &#039;c3&#039;, description: &#039;d3&#039;, parentCid: p1.cid, order: 3 });
			// move c1 to second place
			await apiCategories.update({ uid: adminUid }, { cid: c1.cid, values: { order: 2 } });
			let cids = await db.getSortedSetRange(`cid:${p1.cid}:children`, 0, -1);
			assert.deepStrictEqual(cids.map(Number), [c2.cid, c1.cid, c3.cid]);

			// move c3 to front
			await apiCategories.update({ uid: adminUid }, { cid: c3.cid, values: { order: 1 } });
			cids = await db.getSortedSetRange(`cid:${p1.cid}:children`, 0, -1);
			assert.deepStrictEqual(cids.map(Number), [c3.cid, c2.cid, c1.cid]);
		});

		it(&#039;should not remove category from parent if parent is set again to same category&#039;, async () =&gt; {
			const parentCat = await Categories.create({ name: &#039;parent&#039;, description: &#039;poor parent&#039; });
			const updateData = {};
			updateData[cid] = {
				parentCid: parentCat.cid,
			};
			await Categories.update(updateData);
			let data = await Categories.getCategoryData(cid);
			assert.equal(data.parentCid, updateData[cid].parentCid);
			let childrenCids = await db.getSortedSetRange(`cid:${parentCat.cid}:children`, 0, -1);
			assert(childrenCids.includes(String(cid)));

			// update again to same parent
			await Categories.update(updateData);
			data = await Categories.getCategoryData(cid);
			assert.equal(data.parentCid, updateData[cid].parentCid);
			childrenCids = await db.getSortedSetRange(`cid:${parentCat.cid}:children`, 0, -1);
			assert(childrenCids.includes(String(cid)));
		});

		it(&#039;should purge category&#039;, async () =&gt; {
			const category = await Categories.create({
				name: &#039;purge me&#039;,
				description: &#039;update description&#039;,
			});
			await Topics.post({
				uid: posterUid,
				cid: category.cid,
				title: &#039;Test Topic Title&#039;,
				content: &#039;The content of test topic&#039;,
			});
			await apiCategories.delete({ uid: adminUid }, { cid: category.cid });
			const data = await Categories.getCategoryById(category.cid);
			assert.strictEqual(data, null);
		});

		it(&#039;should get all category names&#039;, (done) =&gt; {
			socketCategories.getNames({ uid: adminUid }, {}, (err, data) =&gt; {
				assert.ifError(err);
				assert(Array.isArray(data));
				done();
			});
		});

		it(&#039;should give privilege&#039;, async () =&gt; {
			await apiCategories.setPrivilege({ uid: adminUid }, { cid: categoryObj.cid, privilege: [&#039;groups:topics:delete&#039;], set: true, member: &#039;registered-users&#039; });
			const canDeleteTopics = await privileges.categories.can(&#039;topics:delete&#039;, categoryObj.cid, posterUid);
			assert(canDeleteTopics);
		});

		it(&#039;should remove privilege&#039;, async () =&gt; {
			await apiCategories.setPrivilege({ uid: adminUid }, { cid: categoryObj.cid, privilege: &#039;groups:topics:delete&#039;, set: false, member: &#039;registered-users&#039; });
			const canDeleteTopics = await privileges.categories.can(&#039;topics:delete&#039;, categoryObj.cid, posterUid);
			assert(!canDeleteTopics);
		});

		it(&#039;should get privilege settings&#039;, async () =&gt; {
			const data = await apiCategories.getPrivileges({ uid: adminUid }, categoryObj.cid);
			assert(data.labelData);
			assert(data.keys.users);
			assert(data.keys.groups);
			assert(data.users);
			assert(data.groups);
		});

		it(&#039;should copy privileges to children&#039;, async () =&gt; {
			const parentCategory = await Categories.create({ name: &#039;parent&#039; });
			const parentCid = parentCategory.cid;
			const child1 = await Categories.create({ name: &#039;child1&#039;, parentCid: parentCid });
			const child2 = await Categories.create({ name: &#039;child2&#039;, parentCid: child1.cid });
			await apiCategories.setPrivilege({ uid: adminUid }, {
				cid: parentCid,
				privilege: &#039;groups:topics:delete&#039;,
				set: true,
				member: &#039;registered-users&#039;,
			});
			await socketCategories.copyPrivilegesToChildren({ uid: adminUid }, { cid: parentCid, group: &#039;&#039; });
			const canDelete = await privileges.categories.can(&#039;topics:delete&#039;, child2.cid, posterUid);
			assert(canDelete);
		});

		it(&#039;should create category with settings from&#039;, async () =&gt; {
			const category = await Categories.create({ name: &#039;copy from&#039;, description: &#039;copy me&#039; });
			const parentCid = category.cid;
			const childCategory = await Categories.create({ name: &#039;child1&#039;, description: &#039;will be gone&#039;, cloneFromCid: parentCid });
			assert.equal(childCategory.description, &#039;copy me&#039;);
		});

		it(&#039;should copy settings from&#039;, async () =&gt; {
			const category = await Categories.create({ name: &#039;parent&#039;, description: &#039;copy me&#039; });
			const parentCid = category.cid;
			const childCategory = await Categories.create({ name: &#039;child1&#039; });
			const child1Cid = childCategory.cid;
			const destinationCategory = await socketCategories.copySettingsFrom(
				{ uid: adminUid },
				{ fromCid: parentCid, toCid: child1Cid, copyParent: true },
			);
			const description = await Categories.getCategoryField(child1Cid, &#039;description&#039;);
			assert.equal(description, &#039;copy me&#039;);
		});

		it(&#039;should copy privileges from another category&#039;, async () =&gt; {
			const parent = await Categories.create({ name: &#039;parent&#039;, description: &#039;copy me&#039; });
			const parentCid = parent.cid;
			const child1 = await Categories.create({ name: &#039;child1&#039; });
			await apiCategories.setPrivilege({ uid: adminUid }, {
				cid: parentCid,
				privilege: &#039;groups:topics:delete&#039;,
				set: true,
				member: &#039;registered-users&#039;,
			});
			await socketCategories.copyPrivilegesFrom({ uid: adminUid }, { fromCid: parentCid, toCid: child1.cid });
			const canDelete = await privileges.categories.can(&#039;topics:delete&#039;, child1.cid, posterUid);
			assert(canDelete);
		});

		it(&#039;should copy privileges from another category for a single group&#039;, async () =&gt; {
			const parent = await Categories.create({ name: &#039;parent&#039;, description: &#039;copy me&#039; });
			const parentCid = parent.cid;
			const child1 = await Categories.create({ name: &#039;child1&#039; });
			await apiCategories.setPrivilege({ uid: adminUid }, {
				cid: parentCid,
				privilege: &#039;groups:topics:delete&#039;,
				set: true,
				member: &#039;registered-users&#039;,
			});
			await socketCategories.copyPrivilegesFrom({ uid: adminUid }, { fromCid: parentCid, toCid: child1.cid, group: &#039;registered-users&#039; });
			const canDelete = await privileges.categories.can(&#039;topics:delete&#039;, child1.cid, 0);
			assert(!canDelete);
		});
	});

	it(&#039;should get active users&#039;, (done) =&gt; {
		Categories.create({
			name: &#039;test&#039;,
		}, (err, category) =&gt; {
			assert.ifError(err);
			Topics.post({
				uid: posterUid,
				cid: category.cid,
				title: &#039;Test Topic Title&#039;,
				content: &#039;The content of test topic&#039;,
			}, (err) =&gt; {
				assert.ifError(err);
				Categories.getActiveUsers(category.cid, (err, uids) =&gt; {
					assert.ifError(err);
					assert.equal(uids[0], posterUid);
					done();
				});
			});
		});
	});

	describe(&#039;tag whitelist&#039;, () =&gt; {
		let cid;
		const socketTopics = require(&#039;../src/socket.io/topics&#039;);
		before((done) =&gt; {
			Categories.create({
				name: &#039;test&#039;,
			}, (err, category) =&gt; {
				assert.ifError(err);
				cid = category.cid;
				done();
			});
		});

		it(&#039;should error if data is invalid&#039;, (done) =&gt; {
			socketTopics.isTagAllowed({ uid: posterUid }, null, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should return true if category whitelist is empty&#039;, (done) =&gt; {
			socketTopics.isTagAllowed({ uid: posterUid }, { tag: &#039;notallowed&#039;, cid: cid }, (err, allowed) =&gt; {
				assert.ifError(err);
				assert(allowed);
				done();
			});
		});

		it(&#039;should add tags to category whitelist&#039;, (done) =&gt; {
			const data = {};
			data[cid] = {
				tagWhitelist: &#039;nodebb,jquery,javascript&#039;,
			};
			Categories.update(data, (err) =&gt; {
				assert.ifError(err);
				db.getSortedSetRange(`cid:${cid}:tag:whitelist`, 0, -1, (err, tagWhitelist) =&gt; {
					assert.ifError(err);
					assert.deepEqual([&#039;nodebb&#039;, &#039;jquery&#039;, &#039;javascript&#039;], tagWhitelist);
					done();
				});
			});
		});

		it(&#039;should return false if category whitelist does not have tag&#039;, (done) =&gt; {
			socketTopics.isTagAllowed({ uid: posterUid }, { tag: &#039;notallowed&#039;, cid: cid }, (err, allowed) =&gt; {
				assert.ifError(err);
				assert(!allowed);
				done();
			});
		});

		it(&#039;should return true if category whitelist has tag&#039;, (done) =&gt; {
			socketTopics.isTagAllowed({ uid: posterUid }, { tag: &#039;nodebb&#039;, cid: cid }, (err, allowed) =&gt; {
				assert.ifError(err);
				assert(allowed);
				done();
			});
		});

		it(&#039;should post a topic with only allowed tags&#039;, (done) =&gt; {
			Topics.post({
				uid: posterUid,
				cid: cid,
				title: &#039;Test Topic Title&#039;,
				content: &#039;The content of test topic&#039;,
				tags: [&#039;nodebb&#039;, &#039;jquery&#039;, &#039;notallowed&#039;],
			}, (err, data) =&gt; {
				assert.ifError(err);
				assert.equal(data.topicData.tags.length, 2);
				done();
			});
		});
	});


	describe(&#039;privileges&#039;, () =&gt; {
		const privileges = require(&#039;../src/privileges&#039;);

		it(&#039;should return empty array if uids is empty array&#039;, (done) =&gt; {
			privileges.categories.filterUids(&#039;find&#039;, categoryObj.cid, [], (err, uids) =&gt; {
				assert.ifError(err);
				assert.equal(uids.length, 0);
				done();
			});
		});

		it(&#039;should filter uids by privilege&#039;, (done) =&gt; {
			privileges.categories.filterUids(&#039;find&#039;, categoryObj.cid, [1, 2, 3, 4], (err, uids) =&gt; {
				assert.ifError(err);
				assert.deepEqual(uids, [1, 2]);
				done();
			});
		});

		it(&#039;should load category user privileges&#039;, (done) =&gt; {
			privileges.categories.userPrivileges(categoryObj.cid, 1, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, {
					find: false,
					&#039;posts:delete&#039;: false,
					read: false,
					&#039;topics:reply&#039;: false,
					&#039;topics:read&#039;: false,
					&#039;topics:create&#039;: false,
					&#039;topics:tag&#039;: false,
					&#039;topics:delete&#039;: false,
					&#039;topics:schedule&#039;: false,
					&#039;posts:edit&#039;: false,
					&#039;posts:history&#039;: false,
					&#039;posts:upvote&#039;: false,
					&#039;posts:downvote&#039;: false,
					purge: false,
					&#039;posts:view_deleted&#039;: false,
					moderate: false,
				});

				done();
			});
		});

		it(&#039;should load global user privileges&#039;, (done) =&gt; {
			privileges.global.userPrivileges(1, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, {
					ban: false,
					mute: false,
					invite: false,
					chat: false,
					&#039;chat:privileged&#039;: false,
					&#039;search:content&#039;: false,
					&#039;search:users&#039;: false,
					&#039;search:tags&#039;: false,
					&#039;view:users:info&#039;: false,
					&#039;upload:post:image&#039;: false,
					&#039;upload:post:file&#039;: false,
					signature: false,
					&#039;local:login&#039;: false,
					&#039;group:create&#039;: false,
					&#039;view:users&#039;: false,
					&#039;view:tags&#039;: false,
					&#039;view:groups&#039;: false,
				});

				done();
			});
		});

		it(&#039;should load category group privileges&#039;, (done) =&gt; {
			privileges.categories.groupPrivileges(categoryObj.cid, &#039;registered-users&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, {
					&#039;groups:find&#039;: true,
					&#039;groups:posts:edit&#039;: true,
					&#039;groups:posts:history&#039;: true,
					&#039;groups:posts:upvote&#039;: true,
					&#039;groups:posts:downvote&#039;: true,
					&#039;groups:topics:delete&#039;: false,
					&#039;groups:topics:create&#039;: true,
					&#039;groups:topics:reply&#039;: true,
					&#039;groups:topics:tag&#039;: true,
					&#039;groups:topics:schedule&#039;: false,
					&#039;groups:posts:delete&#039;: true,
					&#039;groups:read&#039;: true,
					&#039;groups:topics:read&#039;: true,
					&#039;groups:purge&#039;: false,
					&#039;groups:posts:view_deleted&#039;: false,
					&#039;groups:moderate&#039;: false,
				});

				done();
			});
		});

		it(&#039;should load global group privileges&#039;, (done) =&gt; {
			privileges.global.groupPrivileges(&#039;registered-users&#039;, (err, data) =&gt; {
				assert.ifError(err);
				assert.deepEqual(data, {
					&#039;groups:ban&#039;: false,
					&#039;groups:mute&#039;: false,
					&#039;groups:invite&#039;: false,
					&#039;groups:chat&#039;: true,
					&#039;groups:chat:privileged&#039;: false,
					&#039;groups:search:content&#039;: true,
					&#039;groups:search:users&#039;: true,
					&#039;groups:search:tags&#039;: true,
					&#039;groups:view:users&#039;: true,
					&#039;groups:view:users:info&#039;: false,
					&#039;groups:view:tags&#039;: true,
					&#039;groups:view:groups&#039;: true,
					&#039;groups:upload:post:image&#039;: true,
					&#039;groups:upload:post:file&#039;: false,
					&#039;groups:signature&#039;: true,
					&#039;groups:local:login&#039;: true,
					&#039;groups:group:create&#039;: false,
				});

				done();
			});
		});

		it(&#039;should return false if cid is falsy&#039;, (done) =&gt; {
			privileges.categories.isUserAllowedTo(&#039;find&#039;, null, adminUid, (err, isAllowed) =&gt; {
				assert.ifError(err);
				assert.equal(isAllowed, false);
				done();
			});
		});

		describe(&#039;Categories.getModeratorUids&#039;, () =&gt; {
			let cid;

			before(async () =&gt; {
				({ cid } = await Categories.create({ name: &#039;foobar&#039; }));
				await groups.create({ name: &#039;testGroup&#039; });
				await groups.join(`cid:${cid}:privileges:groups:moderate`, &#039;testGroup&#039;);
				await groups.join(&#039;testGroup&#039;, 1);
			});

			it(&#039;should retrieve all users with moderator bit in category privilege&#039;, (done) =&gt; {
				Categories.getModeratorUids([cid, 2], (err, uids) =&gt; {
					assert.ifError(err);
					assert.strictEqual(uids.length, 2);
					assert(uids[0].includes(&#039;1&#039;));
					assert.strictEqual(uids[1].length, 0);
					done();
				});
			});

			it(&#039;should not fail when there are multiple groups&#039;, async () =&gt; {
				await groups.create({ name: &#039;testGroup2&#039; });
				await groups.join(&#039;cid:1:privileges:groups:moderate&#039;, &#039;testGroup2&#039;);
				await groups.join(&#039;testGroup2&#039;, 1);
				const uids = await Categories.getModeratorUids([cid, 2]);
				assert(uids[0].includes(&#039;1&#039;));
			});

			it(&#039;should not return moderators of disabled categories&#039;, async () =&gt; {
				const payload = {};
				payload[cid] = { disabled: 1 };
				await Categories.update(payload);
				const uids = await Categories.getModeratorUids([cid, 2]);
				assert(!uids[0].includes(&#039;1&#039;));
			});

			after(async () =&gt; {
				await groups.leave(`cid:${cid}:privileges:groups:moderate`, &#039;testGroup&#039;);
				await groups.leave(`cid:${cid}:privileges:groups:moderate`, &#039;testGroup2&#039;);
				await groups.destroy(&#039;testGroup&#039;);
				await groups.destroy(&#039;testGroup2&#039;);
			});
		});
	});


	describe(&#039;getTopicIds&#039;, () =&gt; {
		const plugins = require(&#039;../src/plugins&#039;);
		it(&#039;should get topic ids with filter&#039;, (done) =&gt; {
			function method(data, callback) {
				data.tids = [1, 2, 3];
				callback(null, data);
			}

			plugins.hooks.register(&#039;my-test-plugin&#039;, {
				hook: &#039;filter:categories.getTopicIds&#039;,
				method: method,
			});

			Categories.getTopicIds({
				cid: categoryObj.cid,
				start: 0,
				stop: 19,
			}, (err, tids) =&gt; {
				assert.ifError(err);
				assert.deepEqual(tids, [1, 2, 3]);
				plugins.hooks.unregister(&#039;my-test-plugin&#039;, &#039;filter:categories.getTopicIds&#039;, method);
				done();
			});
		});
	});

	it(&#039;should return nested children categories&#039;, async () =&gt; {
		const rootCategory = await Categories.create({ name: &#039;root&#039; });
		const child1 = await Categories.create({ name: &#039;child1&#039;, parentCid: rootCategory.cid });
		const child2 = await Categories.create({ name: &#039;child2&#039;, parentCid: child1.cid });
		const data = await Categories.getCategoryById({
			uid: 1,
			cid: rootCategory.cid,
			start: 0,
			stop: 19,
		});
		assert.strictEqual(child1.cid, data.children[0].cid);
		assert.strictEqual(child2.cid, data.children[0].children[0].cid);
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
