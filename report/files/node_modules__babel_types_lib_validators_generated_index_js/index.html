<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/types/lib/validators/generated/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/types/lib/validators/generated/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2798</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">98.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">37.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.isAccessor = isAccessor;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassAccessorProperty = isClassAccessorProperty;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParameter = isFunctionParameter;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportExpression = isImportExpression;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumBody = isTSEnumBody;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInstantiationExpression = isTSInstantiationExpression;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSTemplateLiteralType = isTSTemplateLiteralType;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidPattern = isVoidPattern;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require(&quot;../../utils/shallowEqual.js&quot;);
var _deprecationWarning = require(&quot;../../utils/deprecationWarning.js&quot;);
function isArrayExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ArrayExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAssignmentExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;AssignmentExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBinaryExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BinaryExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterpreterDirective(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;InterpreterDirective&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDirective(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Directive&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DirectiveLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlockStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BlockStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBreakStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BreakStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCallExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;CallExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCatchClause(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;CatchClause&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isConditionalExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ConditionalExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isContinueStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ContinueStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDebuggerStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DebuggerStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDoWhileStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DoWhileStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEmptyStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EmptyStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExpressionStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExpressionStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFile(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;File&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForInStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ForInStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ForStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;FunctionDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;FunctionExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIdentifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Identifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIfStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;IfStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLabeledStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;LabeledStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStringLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;StringLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumericLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NumericLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNullLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NullLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBooleanLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BooleanLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRegExpLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;RegExpLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLogicalExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;LogicalExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMemberExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;MemberExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNewExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NewExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isProgram(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Program&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectMethod(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectMethod&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRestElement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;RestElement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isReturnStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ReturnStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSequenceExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;SequenceExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ParenthesizedExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSwitchCase(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;SwitchCase&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSwitchStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;SwitchStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isThisExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ThisExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isThrowStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ThrowStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTryStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TryStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUnaryExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;UnaryExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUpdateExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;UpdateExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVariableDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;VariableDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVariableDeclarator(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;VariableDeclarator&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isWhileStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;WhileStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isWithStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;WithStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAssignmentPattern(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;AssignmentPattern&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArrayPattern(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ArrayPattern&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ArrowFunctionExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExportAllDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExportDefaultDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExportNamedDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportSpecifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExportSpecifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForOfStatement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ForOfStatement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ImportDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ImportDefaultSpecifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ImportNamespaceSpecifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportSpecifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ImportSpecifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ImportExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMetaProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;MetaProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassMethod(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassMethod&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectPattern(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectPattern&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSpreadElement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;SpreadElement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSuper(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Super&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TaggedTemplateExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTemplateElement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TemplateElement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTemplateLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TemplateLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isYieldExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;YieldExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAwaitExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;AwaitExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImport(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Import&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBigIntLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BigIntLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExportNamespaceSpecifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;OptionalMemberExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;OptionalCallExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassAccessorProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassAccessorProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassPrivateProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassPrivateMethod&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPrivateName(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;PrivateName&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStaticBlock(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;StaticBlock&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportAttribute(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ImportAttribute&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;AnyTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ArrayTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BooleanTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BooleanLiteralTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NullLiteralTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassImplements(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ClassImplements&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareClass(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareClass&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareFunction(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareFunction&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareInterface(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareInterface&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareModule(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareModule&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareModuleExports&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareTypeAlias&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareOpaqueType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareVariable(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareVariable&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareExportDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclareExportAllDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DeclaredPredicate&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExistsTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;FunctionTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;FunctionTypeParam&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;GenericTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInferredPredicate(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;InferredPredicate&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterfaceExtends(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;InterfaceExtends&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;InterfaceDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;InterfaceTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;IntersectionTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;MixedTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EmptyTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NullableTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NumberLiteralTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;NumberTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectTypeInternalSlot&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectTypeCallProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectTypeIndexer&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectTypeProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ObjectTypeSpreadProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOpaqueType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;OpaqueType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;QualifiedTypeIdentifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;StringLiteralTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;StringTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSymbolTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;SymbolTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ThisTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TupleTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeofTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeAlias(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeAlias&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeCastExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeCastExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeParameter(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeParameter&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeParameterDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TypeParameterInstantiation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;UnionTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVariance(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Variance&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;VoidTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumBooleanBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumNumberBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumNumberBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumStringBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumStringBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumSymbolBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumBooleanMember&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumNumberMember(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumNumberMember&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumStringMember(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumStringMember&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;EnumDefaultedMember&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIndexedAccessType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;IndexedAccessType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOptionalIndexedAccessType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;OptionalIndexedAccessType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXAttribute(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXAttribute&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXClosingElement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXClosingElement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXElement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXElement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXEmptyExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXExpressionContainer&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXSpreadChild&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXIdentifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXIdentifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXMemberExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXNamespacedName&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXOpeningElement&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXSpreadAttribute&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXText(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXText&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXFragment(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXFragment&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXOpeningFragment&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;JSXClosingFragment&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNoop(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Noop&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPlaceholder(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Placeholder&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;V8IntrinsicIdentifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ArgumentPlaceholder&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBindExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;BindExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDecorator(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;Decorator&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDoExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DoExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ExportDefaultSpecifier&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRecordExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;RecordExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTupleExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TupleExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDecimalLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;DecimalLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isModuleExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;ModuleExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTopicReference(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TopicReference&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;PipelineTopicExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;PipelineBareFunction&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;PipelinePrimaryTopicReference&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVoidPattern(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;VoidPattern&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSParameterProperty(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSParameterProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSDeclareFunction&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSDeclareMethod&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSQualifiedName(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSQualifiedName&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSCallSignatureDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSConstructSignatureDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSPropertySignature(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSPropertySignature&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSMethodSignature(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSMethodSignature&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIndexSignature(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSIndexSignature&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSAnyKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSBooleanKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSBigIntKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIntrinsicKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSIntrinsicKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSNeverKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNullKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSNullKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSNumberKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSObjectKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSStringKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSStringKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSSymbolKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSUndefinedKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSUnknownKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSVoidKeyword&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSThisType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSThisType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSFunctionType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSFunctionType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSConstructorType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSConstructorType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeReference(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeReference&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypePredicate(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypePredicate&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeQuery(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeQuery&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSArrayType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSArrayType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTupleType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTupleType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSOptionalType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSOptionalType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSRestType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSRestType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNamedTupleMember(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSNamedTupleMember&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSUnionType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSUnionType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIntersectionType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSIntersectionType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSConditionalType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSConditionalType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInferType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSInferType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSParenthesizedType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeOperator(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeOperator&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSIndexedAccessType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSMappedType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSMappedType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTemplateLiteralType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTemplateLiteralType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSLiteralType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSLiteralType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSExpressionWithTypeArguments&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSInterfaceDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSInterfaceBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeAliasDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInstantiationExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSInstantiationExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSAsExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSAsExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSSatisfiesExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSSatisfiesExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeAssertion&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEnumBody(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSEnumBody&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSEnumDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEnumMember(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSEnumMember&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSModuleDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSModuleBlock(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSModuleBlock&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSImportType(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSImportType&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSImportEqualsDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSExternalModuleReference&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSNonNullExpression&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSExportAssignment(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSExportAssignment&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSNamespaceExportDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeAnnotation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeParameterInstantiation&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeParameterDeclaration&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeParameter(node, opts) {
  if (!node) return false;
  if (node.type !== &quot;TSTypeParameter&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStandardized(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ArrayExpression&quot;:
    case &quot;AssignmentExpression&quot;:
    case &quot;BinaryExpression&quot;:
    case &quot;InterpreterDirective&quot;:
    case &quot;Directive&quot;:
    case &quot;DirectiveLiteral&quot;:
    case &quot;BlockStatement&quot;:
    case &quot;BreakStatement&quot;:
    case &quot;CallExpression&quot;:
    case &quot;CatchClause&quot;:
    case &quot;ConditionalExpression&quot;:
    case &quot;ContinueStatement&quot;:
    case &quot;DebuggerStatement&quot;:
    case &quot;DoWhileStatement&quot;:
    case &quot;EmptyStatement&quot;:
    case &quot;ExpressionStatement&quot;:
    case &quot;File&quot;:
    case &quot;ForInStatement&quot;:
    case &quot;ForStatement&quot;:
    case &quot;FunctionDeclaration&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;Identifier&quot;:
    case &quot;IfStatement&quot;:
    case &quot;LabeledStatement&quot;:
    case &quot;StringLiteral&quot;:
    case &quot;NumericLiteral&quot;:
    case &quot;NullLiteral&quot;:
    case &quot;BooleanLiteral&quot;:
    case &quot;RegExpLiteral&quot;:
    case &quot;LogicalExpression&quot;:
    case &quot;MemberExpression&quot;:
    case &quot;NewExpression&quot;:
    case &quot;Program&quot;:
    case &quot;ObjectExpression&quot;:
    case &quot;ObjectMethod&quot;:
    case &quot;ObjectProperty&quot;:
    case &quot;RestElement&quot;:
    case &quot;ReturnStatement&quot;:
    case &quot;SequenceExpression&quot;:
    case &quot;ParenthesizedExpression&quot;:
    case &quot;SwitchCase&quot;:
    case &quot;SwitchStatement&quot;:
    case &quot;ThisExpression&quot;:
    case &quot;ThrowStatement&quot;:
    case &quot;TryStatement&quot;:
    case &quot;UnaryExpression&quot;:
    case &quot;UpdateExpression&quot;:
    case &quot;VariableDeclaration&quot;:
    case &quot;VariableDeclarator&quot;:
    case &quot;WhileStatement&quot;:
    case &quot;WithStatement&quot;:
    case &quot;AssignmentPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;ClassBody&quot;:
    case &quot;ClassExpression&quot;:
    case &quot;ClassDeclaration&quot;:
    case &quot;ExportAllDeclaration&quot;:
    case &quot;ExportDefaultDeclaration&quot;:
    case &quot;ExportNamedDeclaration&quot;:
    case &quot;ExportSpecifier&quot;:
    case &quot;ForOfStatement&quot;:
    case &quot;ImportDeclaration&quot;:
    case &quot;ImportDefaultSpecifier&quot;:
    case &quot;ImportNamespaceSpecifier&quot;:
    case &quot;ImportSpecifier&quot;:
    case &quot;ImportExpression&quot;:
    case &quot;MetaProperty&quot;:
    case &quot;ClassMethod&quot;:
    case &quot;ObjectPattern&quot;:
    case &quot;SpreadElement&quot;:
    case &quot;Super&quot;:
    case &quot;TaggedTemplateExpression&quot;:
    case &quot;TemplateElement&quot;:
    case &quot;TemplateLiteral&quot;:
    case &quot;YieldExpression&quot;:
    case &quot;AwaitExpression&quot;:
    case &quot;Import&quot;:
    case &quot;BigIntLiteral&quot;:
    case &quot;ExportNamespaceSpecifier&quot;:
    case &quot;OptionalMemberExpression&quot;:
    case &quot;OptionalCallExpression&quot;:
    case &quot;ClassProperty&quot;:
    case &quot;ClassAccessorProperty&quot;:
    case &quot;ClassPrivateProperty&quot;:
    case &quot;ClassPrivateMethod&quot;:
    case &quot;PrivateName&quot;:
    case &quot;StaticBlock&quot;:
    case &quot;ImportAttribute&quot;:
      break;
    case &quot;Placeholder&quot;:
      switch (node.expectedNode) {
        case &quot;Identifier&quot;:
        case &quot;StringLiteral&quot;:
        case &quot;BlockStatement&quot;:
        case &quot;ClassBody&quot;:
          break;
        default:
          return false;
      }
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExpression(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ArrayExpression&quot;:
    case &quot;AssignmentExpression&quot;:
    case &quot;BinaryExpression&quot;:
    case &quot;CallExpression&quot;:
    case &quot;ConditionalExpression&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;Identifier&quot;:
    case &quot;StringLiteral&quot;:
    case &quot;NumericLiteral&quot;:
    case &quot;NullLiteral&quot;:
    case &quot;BooleanLiteral&quot;:
    case &quot;RegExpLiteral&quot;:
    case &quot;LogicalExpression&quot;:
    case &quot;MemberExpression&quot;:
    case &quot;NewExpression&quot;:
    case &quot;ObjectExpression&quot;:
    case &quot;SequenceExpression&quot;:
    case &quot;ParenthesizedExpression&quot;:
    case &quot;ThisExpression&quot;:
    case &quot;UnaryExpression&quot;:
    case &quot;UpdateExpression&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;ClassExpression&quot;:
    case &quot;ImportExpression&quot;:
    case &quot;MetaProperty&quot;:
    case &quot;Super&quot;:
    case &quot;TaggedTemplateExpression&quot;:
    case &quot;TemplateLiteral&quot;:
    case &quot;YieldExpression&quot;:
    case &quot;AwaitExpression&quot;:
    case &quot;Import&quot;:
    case &quot;BigIntLiteral&quot;:
    case &quot;OptionalMemberExpression&quot;:
    case &quot;OptionalCallExpression&quot;:
    case &quot;TypeCastExpression&quot;:
    case &quot;JSXElement&quot;:
    case &quot;JSXFragment&quot;:
    case &quot;BindExpression&quot;:
    case &quot;DoExpression&quot;:
    case &quot;RecordExpression&quot;:
    case &quot;TupleExpression&quot;:
    case &quot;DecimalLiteral&quot;:
    case &quot;ModuleExpression&quot;:
    case &quot;TopicReference&quot;:
    case &quot;PipelineTopicExpression&quot;:
    case &quot;PipelineBareFunction&quot;:
    case &quot;PipelinePrimaryTopicReference&quot;:
    case &quot;TSInstantiationExpression&quot;:
    case &quot;TSAsExpression&quot;:
    case &quot;TSSatisfiesExpression&quot;:
    case &quot;TSTypeAssertion&quot;:
    case &quot;TSNonNullExpression&quot;:
      break;
    case &quot;Placeholder&quot;:
      switch (node.expectedNode) {
        case &quot;Expression&quot;:
        case &quot;Identifier&quot;:
        case &quot;StringLiteral&quot;:
          break;
        default:
          return false;
      }
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBinary(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BinaryExpression&quot;:
    case &quot;LogicalExpression&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isScopable(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BlockStatement&quot;:
    case &quot;CatchClause&quot;:
    case &quot;DoWhileStatement&quot;:
    case &quot;ForInStatement&quot;:
    case &quot;ForStatement&quot;:
    case &quot;FunctionDeclaration&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;Program&quot;:
    case &quot;ObjectMethod&quot;:
    case &quot;SwitchStatement&quot;:
    case &quot;WhileStatement&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;ClassExpression&quot;:
    case &quot;ClassDeclaration&quot;:
    case &quot;ForOfStatement&quot;:
    case &quot;ClassMethod&quot;:
    case &quot;ClassPrivateMethod&quot;:
    case &quot;StaticBlock&quot;:
    case &quot;TSModuleBlock&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;BlockStatement&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlockParent(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BlockStatement&quot;:
    case &quot;CatchClause&quot;:
    case &quot;DoWhileStatement&quot;:
    case &quot;ForInStatement&quot;:
    case &quot;ForStatement&quot;:
    case &quot;FunctionDeclaration&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;Program&quot;:
    case &quot;ObjectMethod&quot;:
    case &quot;SwitchStatement&quot;:
    case &quot;WhileStatement&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;ForOfStatement&quot;:
    case &quot;ClassMethod&quot;:
    case &quot;ClassPrivateMethod&quot;:
    case &quot;StaticBlock&quot;:
    case &quot;TSModuleBlock&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;BlockStatement&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlock(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BlockStatement&quot;:
    case &quot;Program&quot;:
    case &quot;TSModuleBlock&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;BlockStatement&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStatement(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BlockStatement&quot;:
    case &quot;BreakStatement&quot;:
    case &quot;ContinueStatement&quot;:
    case &quot;DebuggerStatement&quot;:
    case &quot;DoWhileStatement&quot;:
    case &quot;EmptyStatement&quot;:
    case &quot;ExpressionStatement&quot;:
    case &quot;ForInStatement&quot;:
    case &quot;ForStatement&quot;:
    case &quot;FunctionDeclaration&quot;:
    case &quot;IfStatement&quot;:
    case &quot;LabeledStatement&quot;:
    case &quot;ReturnStatement&quot;:
    case &quot;SwitchStatement&quot;:
    case &quot;ThrowStatement&quot;:
    case &quot;TryStatement&quot;:
    case &quot;VariableDeclaration&quot;:
    case &quot;WhileStatement&quot;:
    case &quot;WithStatement&quot;:
    case &quot;ClassDeclaration&quot;:
    case &quot;ExportAllDeclaration&quot;:
    case &quot;ExportDefaultDeclaration&quot;:
    case &quot;ExportNamedDeclaration&quot;:
    case &quot;ForOfStatement&quot;:
    case &quot;ImportDeclaration&quot;:
    case &quot;DeclareClass&quot;:
    case &quot;DeclareFunction&quot;:
    case &quot;DeclareInterface&quot;:
    case &quot;DeclareModule&quot;:
    case &quot;DeclareModuleExports&quot;:
    case &quot;DeclareTypeAlias&quot;:
    case &quot;DeclareOpaqueType&quot;:
    case &quot;DeclareVariable&quot;:
    case &quot;DeclareExportDeclaration&quot;:
    case &quot;DeclareExportAllDeclaration&quot;:
    case &quot;InterfaceDeclaration&quot;:
    case &quot;OpaqueType&quot;:
    case &quot;TypeAlias&quot;:
    case &quot;EnumDeclaration&quot;:
    case &quot;TSDeclareFunction&quot;:
    case &quot;TSInterfaceDeclaration&quot;:
    case &quot;TSTypeAliasDeclaration&quot;:
    case &quot;TSEnumDeclaration&quot;:
    case &quot;TSModuleDeclaration&quot;:
    case &quot;TSImportEqualsDeclaration&quot;:
    case &quot;TSExportAssignment&quot;:
    case &quot;TSNamespaceExportDeclaration&quot;:
      break;
    case &quot;Placeholder&quot;:
      switch (node.expectedNode) {
        case &quot;Statement&quot;:
        case &quot;Declaration&quot;:
        case &quot;BlockStatement&quot;:
          break;
        default:
          return false;
      }
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTerminatorless(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BreakStatement&quot;:
    case &quot;ContinueStatement&quot;:
    case &quot;ReturnStatement&quot;:
    case &quot;ThrowStatement&quot;:
    case &quot;YieldExpression&quot;:
    case &quot;AwaitExpression&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCompletionStatement(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;BreakStatement&quot;:
    case &quot;ContinueStatement&quot;:
    case &quot;ReturnStatement&quot;:
    case &quot;ThrowStatement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isConditional(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ConditionalExpression&quot;:
    case &quot;IfStatement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLoop(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;DoWhileStatement&quot;:
    case &quot;ForInStatement&quot;:
    case &quot;ForStatement&quot;:
    case &quot;WhileStatement&quot;:
    case &quot;ForOfStatement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isWhile(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;DoWhileStatement&quot;:
    case &quot;WhileStatement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExpressionWrapper(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ExpressionStatement&quot;:
    case &quot;ParenthesizedExpression&quot;:
    case &quot;TypeCastExpression&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFor(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ForInStatement&quot;:
    case &quot;ForStatement&quot;:
    case &quot;ForOfStatement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForXStatement(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ForInStatement&quot;:
    case &quot;ForOfStatement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunction(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;FunctionDeclaration&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;ObjectMethod&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;ClassMethod&quot;:
    case &quot;ClassPrivateMethod&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionParent(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;FunctionDeclaration&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;ObjectMethod&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;ClassMethod&quot;:
    case &quot;ClassPrivateMethod&quot;:
    case &quot;StaticBlock&quot;:
    case &quot;TSModuleBlock&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPureish(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;FunctionDeclaration&quot;:
    case &quot;FunctionExpression&quot;:
    case &quot;StringLiteral&quot;:
    case &quot;NumericLiteral&quot;:
    case &quot;NullLiteral&quot;:
    case &quot;BooleanLiteral&quot;:
    case &quot;RegExpLiteral&quot;:
    case &quot;ArrowFunctionExpression&quot;:
    case &quot;BigIntLiteral&quot;:
    case &quot;DecimalLiteral&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;StringLiteral&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclaration(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;FunctionDeclaration&quot;:
    case &quot;VariableDeclaration&quot;:
    case &quot;ClassDeclaration&quot;:
    case &quot;ExportAllDeclaration&quot;:
    case &quot;ExportDefaultDeclaration&quot;:
    case &quot;ExportNamedDeclaration&quot;:
    case &quot;ImportDeclaration&quot;:
    case &quot;DeclareClass&quot;:
    case &quot;DeclareFunction&quot;:
    case &quot;DeclareInterface&quot;:
    case &quot;DeclareModule&quot;:
    case &quot;DeclareModuleExports&quot;:
    case &quot;DeclareTypeAlias&quot;:
    case &quot;DeclareOpaqueType&quot;:
    case &quot;DeclareVariable&quot;:
    case &quot;DeclareExportDeclaration&quot;:
    case &quot;DeclareExportAllDeclaration&quot;:
    case &quot;InterfaceDeclaration&quot;:
    case &quot;OpaqueType&quot;:
    case &quot;TypeAlias&quot;:
    case &quot;EnumDeclaration&quot;:
    case &quot;TSDeclareFunction&quot;:
    case &quot;TSInterfaceDeclaration&quot;:
    case &quot;TSTypeAliasDeclaration&quot;:
    case &quot;TSEnumDeclaration&quot;:
    case &quot;TSModuleDeclaration&quot;:
    case &quot;TSImportEqualsDeclaration&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;Declaration&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionParameter(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;Identifier&quot;:
    case &quot;RestElement&quot;:
    case &quot;AssignmentPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;ObjectPattern&quot;:
    case &quot;VoidPattern&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;Identifier&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPatternLike(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;Identifier&quot;:
    case &quot;MemberExpression&quot;:
    case &quot;RestElement&quot;:
    case &quot;AssignmentPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;ObjectPattern&quot;:
    case &quot;VoidPattern&quot;:
    case &quot;TSAsExpression&quot;:
    case &quot;TSSatisfiesExpression&quot;:
    case &quot;TSTypeAssertion&quot;:
    case &quot;TSNonNullExpression&quot;:
      break;
    case &quot;Placeholder&quot;:
      switch (node.expectedNode) {
        case &quot;Pattern&quot;:
        case &quot;Identifier&quot;:
          break;
        default:
          return false;
      }
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLVal(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;Identifier&quot;:
    case &quot;MemberExpression&quot;:
    case &quot;RestElement&quot;:
    case &quot;AssignmentPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;ObjectPattern&quot;:
    case &quot;TSParameterProperty&quot;:
    case &quot;TSAsExpression&quot;:
    case &quot;TSSatisfiesExpression&quot;:
    case &quot;TSTypeAssertion&quot;:
    case &quot;TSNonNullExpression&quot;:
      break;
    case &quot;Placeholder&quot;:
      switch (node.expectedNode) {
        case &quot;Pattern&quot;:
        case &quot;Identifier&quot;:
          break;
        default:
          return false;
      }
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEntityName(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;Identifier&quot;:
    case &quot;TSQualifiedName&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;Identifier&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLiteral(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;StringLiteral&quot;:
    case &quot;NumericLiteral&quot;:
    case &quot;NullLiteral&quot;:
    case &quot;BooleanLiteral&quot;:
    case &quot;RegExpLiteral&quot;:
    case &quot;TemplateLiteral&quot;:
    case &quot;BigIntLiteral&quot;:
    case &quot;DecimalLiteral&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;StringLiteral&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImmutable(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;StringLiteral&quot;:
    case &quot;NumericLiteral&quot;:
    case &quot;NullLiteral&quot;:
    case &quot;BooleanLiteral&quot;:
    case &quot;BigIntLiteral&quot;:
    case &quot;JSXAttribute&quot;:
    case &quot;JSXClosingElement&quot;:
    case &quot;JSXElement&quot;:
    case &quot;JSXExpressionContainer&quot;:
    case &quot;JSXSpreadChild&quot;:
    case &quot;JSXOpeningElement&quot;:
    case &quot;JSXText&quot;:
    case &quot;JSXFragment&quot;:
    case &quot;JSXOpeningFragment&quot;:
    case &quot;JSXClosingFragment&quot;:
    case &quot;DecimalLiteral&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;StringLiteral&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUserWhitespacable(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ObjectMethod&quot;:
    case &quot;ObjectProperty&quot;:
    case &quot;ObjectTypeInternalSlot&quot;:
    case &quot;ObjectTypeCallProperty&quot;:
    case &quot;ObjectTypeIndexer&quot;:
    case &quot;ObjectTypeProperty&quot;:
    case &quot;ObjectTypeSpreadProperty&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMethod(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ObjectMethod&quot;:
    case &quot;ClassMethod&quot;:
    case &quot;ClassPrivateMethod&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectMember(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ObjectMethod&quot;:
    case &quot;ObjectProperty&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isProperty(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ObjectProperty&quot;:
    case &quot;ClassProperty&quot;:
    case &quot;ClassAccessorProperty&quot;:
    case &quot;ClassPrivateProperty&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUnaryLike(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;UnaryExpression&quot;:
    case &quot;SpreadElement&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPattern(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;AssignmentPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;ObjectPattern&quot;:
    case &quot;VoidPattern&quot;:
      break;
    case &quot;Placeholder&quot;:
      if (node.expectedNode === &quot;Pattern&quot;) break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClass(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ClassExpression&quot;:
    case &quot;ClassDeclaration&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportOrExportDeclaration(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ExportAllDeclaration&quot;:
    case &quot;ExportDefaultDeclaration&quot;:
    case &quot;ExportNamedDeclaration&quot;:
    case &quot;ImportDeclaration&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportDeclaration(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ExportAllDeclaration&quot;:
    case &quot;ExportDefaultDeclaration&quot;:
    case &quot;ExportNamedDeclaration&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isModuleSpecifier(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ExportSpecifier&quot;:
    case &quot;ImportDefaultSpecifier&quot;:
    case &quot;ImportNamespaceSpecifier&quot;:
    case &quot;ImportSpecifier&quot;:
    case &quot;ExportNamespaceSpecifier&quot;:
    case &quot;ExportDefaultSpecifier&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAccessor(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ClassAccessorProperty&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPrivate(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;ClassPrivateProperty&quot;:
    case &quot;ClassPrivateMethod&quot;:
    case &quot;PrivateName&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlow(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;AnyTypeAnnotation&quot;:
    case &quot;ArrayTypeAnnotation&quot;:
    case &quot;BooleanTypeAnnotation&quot;:
    case &quot;BooleanLiteralTypeAnnotation&quot;:
    case &quot;NullLiteralTypeAnnotation&quot;:
    case &quot;ClassImplements&quot;:
    case &quot;DeclareClass&quot;:
    case &quot;DeclareFunction&quot;:
    case &quot;DeclareInterface&quot;:
    case &quot;DeclareModule&quot;:
    case &quot;DeclareModuleExports&quot;:
    case &quot;DeclareTypeAlias&quot;:
    case &quot;DeclareOpaqueType&quot;:
    case &quot;DeclareVariable&quot;:
    case &quot;DeclareExportDeclaration&quot;:
    case &quot;DeclareExportAllDeclaration&quot;:
    case &quot;DeclaredPredicate&quot;:
    case &quot;ExistsTypeAnnotation&quot;:
    case &quot;FunctionTypeAnnotation&quot;:
    case &quot;FunctionTypeParam&quot;:
    case &quot;GenericTypeAnnotation&quot;:
    case &quot;InferredPredicate&quot;:
    case &quot;InterfaceExtends&quot;:
    case &quot;InterfaceDeclaration&quot;:
    case &quot;InterfaceTypeAnnotation&quot;:
    case &quot;IntersectionTypeAnnotation&quot;:
    case &quot;MixedTypeAnnotation&quot;:
    case &quot;EmptyTypeAnnotation&quot;:
    case &quot;NullableTypeAnnotation&quot;:
    case &quot;NumberLiteralTypeAnnotation&quot;:
    case &quot;NumberTypeAnnotation&quot;:
    case &quot;ObjectTypeAnnotation&quot;:
    case &quot;ObjectTypeInternalSlot&quot;:
    case &quot;ObjectTypeCallProperty&quot;:
    case &quot;ObjectTypeIndexer&quot;:
    case &quot;ObjectTypeProperty&quot;:
    case &quot;ObjectTypeSpreadProperty&quot;:
    case &quot;OpaqueType&quot;:
    case &quot;QualifiedTypeIdentifier&quot;:
    case &quot;StringLiteralTypeAnnotation&quot;:
    case &quot;StringTypeAnnotation&quot;:
    case &quot;SymbolTypeAnnotation&quot;:
    case &quot;ThisTypeAnnotation&quot;:
    case &quot;TupleTypeAnnotation&quot;:
    case &quot;TypeofTypeAnnotation&quot;:
    case &quot;TypeAlias&quot;:
    case &quot;TypeAnnotation&quot;:
    case &quot;TypeCastExpression&quot;:
    case &quot;TypeParameter&quot;:
    case &quot;TypeParameterDeclaration&quot;:
    case &quot;TypeParameterInstantiation&quot;:
    case &quot;UnionTypeAnnotation&quot;:
    case &quot;Variance&quot;:
    case &quot;VoidTypeAnnotation&quot;:
    case &quot;EnumDeclaration&quot;:
    case &quot;EnumBooleanBody&quot;:
    case &quot;EnumNumberBody&quot;:
    case &quot;EnumStringBody&quot;:
    case &quot;EnumSymbolBody&quot;:
    case &quot;EnumBooleanMember&quot;:
    case &quot;EnumNumberMember&quot;:
    case &quot;EnumStringMember&quot;:
    case &quot;EnumDefaultedMember&quot;:
    case &quot;IndexedAccessType&quot;:
    case &quot;OptionalIndexedAccessType&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowType(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;AnyTypeAnnotation&quot;:
    case &quot;ArrayTypeAnnotation&quot;:
    case &quot;BooleanTypeAnnotation&quot;:
    case &quot;BooleanLiteralTypeAnnotation&quot;:
    case &quot;NullLiteralTypeAnnotation&quot;:
    case &quot;ExistsTypeAnnotation&quot;:
    case &quot;FunctionTypeAnnotation&quot;:
    case &quot;GenericTypeAnnotation&quot;:
    case &quot;InterfaceTypeAnnotation&quot;:
    case &quot;IntersectionTypeAnnotation&quot;:
    case &quot;MixedTypeAnnotation&quot;:
    case &quot;EmptyTypeAnnotation&quot;:
    case &quot;NullableTypeAnnotation&quot;:
    case &quot;NumberLiteralTypeAnnotation&quot;:
    case &quot;NumberTypeAnnotation&quot;:
    case &quot;ObjectTypeAnnotation&quot;:
    case &quot;StringLiteralTypeAnnotation&quot;:
    case &quot;StringTypeAnnotation&quot;:
    case &quot;SymbolTypeAnnotation&quot;:
    case &quot;ThisTypeAnnotation&quot;:
    case &quot;TupleTypeAnnotation&quot;:
    case &quot;TypeofTypeAnnotation&quot;:
    case &quot;UnionTypeAnnotation&quot;:
    case &quot;VoidTypeAnnotation&quot;:
    case &quot;IndexedAccessType&quot;:
    case &quot;OptionalIndexedAccessType&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;AnyTypeAnnotation&quot;:
    case &quot;BooleanTypeAnnotation&quot;:
    case &quot;NullLiteralTypeAnnotation&quot;:
    case &quot;MixedTypeAnnotation&quot;:
    case &quot;EmptyTypeAnnotation&quot;:
    case &quot;NumberTypeAnnotation&quot;:
    case &quot;StringTypeAnnotation&quot;:
    case &quot;SymbolTypeAnnotation&quot;:
    case &quot;ThisTypeAnnotation&quot;:
    case &quot;VoidTypeAnnotation&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowDeclaration(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;DeclareClass&quot;:
    case &quot;DeclareFunction&quot;:
    case &quot;DeclareInterface&quot;:
    case &quot;DeclareModule&quot;:
    case &quot;DeclareModuleExports&quot;:
    case &quot;DeclareTypeAlias&quot;:
    case &quot;DeclareOpaqueType&quot;:
    case &quot;DeclareVariable&quot;:
    case &quot;DeclareExportDeclaration&quot;:
    case &quot;DeclareExportAllDeclaration&quot;:
    case &quot;InterfaceDeclaration&quot;:
    case &quot;OpaqueType&quot;:
    case &quot;TypeAlias&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowPredicate(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;DeclaredPredicate&quot;:
    case &quot;InferredPredicate&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumBody(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;EnumBooleanBody&quot;:
    case &quot;EnumNumberBody&quot;:
    case &quot;EnumStringBody&quot;:
    case &quot;EnumSymbolBody&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumMember(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;EnumBooleanMember&quot;:
    case &quot;EnumNumberMember&quot;:
    case &quot;EnumStringMember&quot;:
    case &quot;EnumDefaultedMember&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSX(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;JSXAttribute&quot;:
    case &quot;JSXClosingElement&quot;:
    case &quot;JSXElement&quot;:
    case &quot;JSXEmptyExpression&quot;:
    case &quot;JSXExpressionContainer&quot;:
    case &quot;JSXSpreadChild&quot;:
    case &quot;JSXIdentifier&quot;:
    case &quot;JSXMemberExpression&quot;:
    case &quot;JSXNamespacedName&quot;:
    case &quot;JSXOpeningElement&quot;:
    case &quot;JSXSpreadAttribute&quot;:
    case &quot;JSXText&quot;:
    case &quot;JSXFragment&quot;:
    case &quot;JSXOpeningFragment&quot;:
    case &quot;JSXClosingFragment&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMiscellaneous(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;Noop&quot;:
    case &quot;Placeholder&quot;:
    case &quot;V8IntrinsicIdentifier&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeScript(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;TSParameterProperty&quot;:
    case &quot;TSDeclareFunction&quot;:
    case &quot;TSDeclareMethod&quot;:
    case &quot;TSQualifiedName&quot;:
    case &quot;TSCallSignatureDeclaration&quot;:
    case &quot;TSConstructSignatureDeclaration&quot;:
    case &quot;TSPropertySignature&quot;:
    case &quot;TSMethodSignature&quot;:
    case &quot;TSIndexSignature&quot;:
    case &quot;TSAnyKeyword&quot;:
    case &quot;TSBooleanKeyword&quot;:
    case &quot;TSBigIntKeyword&quot;:
    case &quot;TSIntrinsicKeyword&quot;:
    case &quot;TSNeverKeyword&quot;:
    case &quot;TSNullKeyword&quot;:
    case &quot;TSNumberKeyword&quot;:
    case &quot;TSObjectKeyword&quot;:
    case &quot;TSStringKeyword&quot;:
    case &quot;TSSymbolKeyword&quot;:
    case &quot;TSUndefinedKeyword&quot;:
    case &quot;TSUnknownKeyword&quot;:
    case &quot;TSVoidKeyword&quot;:
    case &quot;TSThisType&quot;:
    case &quot;TSFunctionType&quot;:
    case &quot;TSConstructorType&quot;:
    case &quot;TSTypeReference&quot;:
    case &quot;TSTypePredicate&quot;:
    case &quot;TSTypeQuery&quot;:
    case &quot;TSTypeLiteral&quot;:
    case &quot;TSArrayType&quot;:
    case &quot;TSTupleType&quot;:
    case &quot;TSOptionalType&quot;:
    case &quot;TSRestType&quot;:
    case &quot;TSNamedTupleMember&quot;:
    case &quot;TSUnionType&quot;:
    case &quot;TSIntersectionType&quot;:
    case &quot;TSConditionalType&quot;:
    case &quot;TSInferType&quot;:
    case &quot;TSParenthesizedType&quot;:
    case &quot;TSTypeOperator&quot;:
    case &quot;TSIndexedAccessType&quot;:
    case &quot;TSMappedType&quot;:
    case &quot;TSTemplateLiteralType&quot;:
    case &quot;TSLiteralType&quot;:
    case &quot;TSExpressionWithTypeArguments&quot;:
    case &quot;TSInterfaceDeclaration&quot;:
    case &quot;TSInterfaceBody&quot;:
    case &quot;TSTypeAliasDeclaration&quot;:
    case &quot;TSInstantiationExpression&quot;:
    case &quot;TSAsExpression&quot;:
    case &quot;TSSatisfiesExpression&quot;:
    case &quot;TSTypeAssertion&quot;:
    case &quot;TSEnumBody&quot;:
    case &quot;TSEnumDeclaration&quot;:
    case &quot;TSEnumMember&quot;:
    case &quot;TSModuleDeclaration&quot;:
    case &quot;TSModuleBlock&quot;:
    case &quot;TSImportType&quot;:
    case &quot;TSImportEqualsDeclaration&quot;:
    case &quot;TSExternalModuleReference&quot;:
    case &quot;TSNonNullExpression&quot;:
    case &quot;TSExportAssignment&quot;:
    case &quot;TSNamespaceExportDeclaration&quot;:
    case &quot;TSTypeAnnotation&quot;:
    case &quot;TSTypeParameterInstantiation&quot;:
    case &quot;TSTypeParameterDeclaration&quot;:
    case &quot;TSTypeParameter&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeElement(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;TSCallSignatureDeclaration&quot;:
    case &quot;TSConstructSignatureDeclaration&quot;:
    case &quot;TSPropertySignature&quot;:
    case &quot;TSMethodSignature&quot;:
    case &quot;TSIndexSignature&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSType(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;TSAnyKeyword&quot;:
    case &quot;TSBooleanKeyword&quot;:
    case &quot;TSBigIntKeyword&quot;:
    case &quot;TSIntrinsicKeyword&quot;:
    case &quot;TSNeverKeyword&quot;:
    case &quot;TSNullKeyword&quot;:
    case &quot;TSNumberKeyword&quot;:
    case &quot;TSObjectKeyword&quot;:
    case &quot;TSStringKeyword&quot;:
    case &quot;TSSymbolKeyword&quot;:
    case &quot;TSUndefinedKeyword&quot;:
    case &quot;TSUnknownKeyword&quot;:
    case &quot;TSVoidKeyword&quot;:
    case &quot;TSThisType&quot;:
    case &quot;TSFunctionType&quot;:
    case &quot;TSConstructorType&quot;:
    case &quot;TSTypeReference&quot;:
    case &quot;TSTypePredicate&quot;:
    case &quot;TSTypeQuery&quot;:
    case &quot;TSTypeLiteral&quot;:
    case &quot;TSArrayType&quot;:
    case &quot;TSTupleType&quot;:
    case &quot;TSOptionalType&quot;:
    case &quot;TSRestType&quot;:
    case &quot;TSUnionType&quot;:
    case &quot;TSIntersectionType&quot;:
    case &quot;TSConditionalType&quot;:
    case &quot;TSInferType&quot;:
    case &quot;TSParenthesizedType&quot;:
    case &quot;TSTypeOperator&quot;:
    case &quot;TSIndexedAccessType&quot;:
    case &quot;TSMappedType&quot;:
    case &quot;TSTemplateLiteralType&quot;:
    case &quot;TSLiteralType&quot;:
    case &quot;TSExpressionWithTypeArguments&quot;:
    case &quot;TSImportType&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSBaseType(node, opts) {
  if (!node) return false;
  switch (node.type) {
    case &quot;TSAnyKeyword&quot;:
    case &quot;TSBooleanKeyword&quot;:
    case &quot;TSBigIntKeyword&quot;:
    case &quot;TSIntrinsicKeyword&quot;:
    case &quot;TSNeverKeyword&quot;:
    case &quot;TSNullKeyword&quot;:
    case &quot;TSNumberKeyword&quot;:
    case &quot;TSObjectKeyword&quot;:
    case &quot;TSStringKeyword&quot;:
    case &quot;TSSymbolKeyword&quot;:
    case &quot;TSUndefinedKeyword&quot;:
    case &quot;TSUnknownKeyword&quot;:
    case &quot;TSVoidKeyword&quot;:
    case &quot;TSThisType&quot;:
    case &quot;TSTemplateLiteralType&quot;:
    case &quot;TSLiteralType&quot;:
      break;
    default:
      return false;
  }
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumberLiteral(node, opts) {
  (0, _deprecationWarning.default)(&quot;isNumberLiteral&quot;, &quot;isNumericLiteral&quot;);
  if (!node) return false;
  if (node.type !== &quot;NumberLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRegexLiteral(node, opts) {
  (0, _deprecationWarning.default)(&quot;isRegexLiteral&quot;, &quot;isRegExpLiteral&quot;);
  if (!node) return false;
  if (node.type !== &quot;RegexLiteral&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRestProperty(node, opts) {
  (0, _deprecationWarning.default)(&quot;isRestProperty&quot;, &quot;isRestElement&quot;);
  if (!node) return false;
  if (node.type !== &quot;RestProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSpreadProperty(node, opts) {
  (0, _deprecationWarning.default)(&quot;isSpreadProperty&quot;, &quot;isSpreadElement&quot;);
  if (!node) return false;
  if (node.type !== &quot;SpreadProperty&quot;) return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isModuleDeclaration(node, opts) {
  (0, _deprecationWarning.default)(&quot;isModuleDeclaration&quot;, &quot;isImportOrExportDeclaration&quot;);
  return isImportOrExportDeclaration(node, opts);
}

//# sourceMappingURL=index.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
