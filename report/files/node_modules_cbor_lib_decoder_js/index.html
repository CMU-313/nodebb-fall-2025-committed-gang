<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cbor/lib/decoder.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cbor/lib/decoder.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">575</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">129.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.85</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

const BinaryParseStream = require(&#039;../vendor/binary-parse-stream&#039;)
const Tagged = require(&#039;./tagged&#039;)
const Simple = require(&#039;./simple&#039;)
const utils = require(&#039;./utils&#039;)
const bignumber = require(&#039;bignumber.js&#039;).BigNumber
const NoFilter = require(&#039;nofilter&#039;)
const constants = require(&#039;./constants&#039;)
// Do not fix this if you want to support node v4
const MT = constants.MT
const NUMBYTES = constants.NUMBYTES
const SIMPLE = constants.SIMPLE
const SYMS = constants.SYMS

const NEG_ONE = new bignumber(-1)
const NEG_MAX = NEG_ONE.minus(
  new bignumber(Number.MAX_SAFE_INTEGER.toString(16), 16))
const COUNT = Symbol(&#039;count&#039;)
const PENDING_KEY = Symbol(&#039;pending_key&#039;)
const MAJOR = Symbol(&#039;major type&#039;)
const ERROR = Symbol(&#039;error&#039;)
const NOT_FOUND = Symbol(&#039;not found&#039;)

function parentArray(parent, typ, count) {
  const a = []
  a[COUNT] = count
  a[SYMS.PARENT] = parent
  a[MAJOR] = typ
  return a
}

function parentBufferStream(parent, typ) {
  const b = new NoFilter()
  b[COUNT] = -1
  b[SYMS.PARENT] = parent
  b[MAJOR] = typ
  return b
}

/**
 * @param {Buffer} v
 * @private
 */
function _tag_2(v) {
  return utils.bufferToBigInt(v)
}

/**
 * @param {BigInt} v
 * @private
 */
function _tag_3(v) {
  // avoid syntax error on old runtimes
  return BigInt(&#039;-1&#039;) - utils.bufferToBigInt(v)
}

/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends {BinaryParseStream}
 */
class Decoder extends BinaryParseStream {

  /**
   * Create a parsing stream.
   *
   * @param {object} [options={}]
   * @param {number} [options.max_depth=-1] - the maximum depth to parse.
   *   Use -1 for &quot;until you run out of memory&quot;.  Set this to a finite
   *   positive number for un-trusted inputs.  Most standard inputs won&#039;t nest
   *   more than 100 or so levels; I&#039;ve tested into the millions before
   *   running out of memory.
   * @param {object} [options.tags] - mapping from tag number to function(v),
   *   where v is the decoded value that comes after the tag, and where the
   *   function returns the correctly-created value for that tag.
   * @param {boolean} [options.bigint=false] generate JavaScript BigInt&#039;s
   *   instead of BigNumbers, when possible.  TODO: when BigInt&#039;s are
   *   more prevalent, change this to default to the value of cbor.hasBigInt.
   */
  constructor(options) {
    options = options || {}
    const tags = options.tags
    delete options.tags
    const max_depth = (options.max_depth != null) ? options.max_depth : -1
    delete options.max_depth
    const bigI = utils.hasBigInt ? (!!options.bigint) : false
    delete options.bigint
    super(options)

    this.running = true
    this.max_depth = max_depth
    this.tags = tags
    if (bigI) {
      if (this.tags == null) {
        this.tags = {}
      }
      this.tags[2] = _tag_2
      this.tags[3] = _tag_3
    }
  }

  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @static
   * @param {any} val - the value to check
   * @returns {any} the corrected value
   *
   * @example
   * myDecoder.on(&#039;data&#039;, function(val) {
   *   val = Decoder.nullcheck(val);
   *   ...
   * });
   */
  static nullcheck(val) {
    switch (val) {
      case SYMS.NULL:
        return null
      case SYMS.UNDEFINED:
        return undefined
      case NOT_FOUND:
        throw new Error(&#039;Value not found&#039;)
      default:
        return val
    }
  }

  /**
   * @typedef DecodeOptions
   * @property {string} [encoding=&#039;hex&#039;] - The encoding of the input.
   *   Ignored if input is a Buffer.
   */

  /**
   * Decode the first CBOR item in the input, synchronously.  This will throw an
   * exception if the input is not valid CBOR.
   *
   * @static
   * @param {string|Buffer} input
   * @param {DecodeOptions|string} [options] Options
   * @returns {any} - the decoded value
   */
  static decodeFirstSync(input, options) {
    options = options || { encoding: &#039;hex&#039; }
    let opts = {}
    let encod
    switch (typeof options) {
      case &#039;string&#039;:
        encod = options
        break
      case &#039;object&#039;:
        opts = utils.extend({}, options)
        encod = opts.encoding
        delete opts.encoding
        break
    }
    const c = new Decoder(opts)
    const s = new NoFilter(
      input,
      encod != null ? encod : utils.guessEncoding(input))
    const parser = c._parse()
    let state = parser.next()
    while (!state.done) {
      const b = s.read(state.value)
      if ((b == null) || (b.length !== state.value)) {
        throw new Error(&#039;Insufficient data&#039;)
      }
      state = parser.next(b)
    }
    return Decoder.nullcheck(state.value)
  }

  /**
   * Decode all of the CBOR items in the input into an array.  This will throw
   * an exception if the input is not valid CBOR; a zero-length input will
   * return an empty array.
   *
   * @static
   * @param {string|Buffer} input
   * @param {DecodeOptions|string} [options] Options or encoding string
   * @returns {Array} - Array of all found items
   */
  static decodeAllSync(input, options) {
    options = options || { encoding: &#039;hex&#039; }
    let opts = {}
    let encod
    switch (typeof options) {
      case &#039;string&#039;:
        encod = options
        break
      case &#039;object&#039;:
        opts = utils.extend({}, options)
        encod = opts.encoding
        delete opts.encoding
    }
    const c = new Decoder(opts)
    const s = new NoFilter(
      input,
      encod != null ? encod : utils.guessEncoding(input))
    const res = []
    while (s.length &gt; 0) {
      const parser = c._parse()
      let state = parser.next()
      while (!state.done) {
        const b = s.read(state.value)
        if ((b == null) || (b.length !== state.value)) {
          throw new Error(&#039;Insufficient data&#039;)
        }
        state = parser.next(b)
      }
      res.push(Decoder.nullcheck(state.value))
    }
    return res
  }

  /**
   * @callback decodeCallback
   * @param {Error} [error] - if one was generated
   * @param {any} [value] - the decoded value
   */

  /**
   * Decode the first CBOR item in the input.  This will error if there are more
   * bytes left over at the end, and optionally if there were no valid CBOR
   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback
   * if no data was found and the `required` option is false.
   *
   * @static
   * @param {string|Buffer} input - the input to parse
   * @param {DecodeOptions|decodeCallback|string} [options] - options
   * @param {decodeCallback} [cb]
   * @returns {Promise} if no cb specified
   */
  static decodeFirst(input, options, cb) {
    let opts = {}
    let required = false
    let encod = &#039;hex&#039;
    switch (typeof options) {
      case &#039;function&#039;:
        cb = options
        encod = utils.guessEncoding(input)
        break
      case &#039;string&#039;:
        encod = options
        break
      case &#039;object&#039;:
        opts = utils.extend({}, options)
        encod = (opts.encoding != null) ?
          opts.encoding : utils.guessEncoding(input)
        delete opts.encoding
        required = (opts.required != null) ? opts.required : false
        delete opts.required
    }
    const c = new Decoder(opts)
    let p
    let v = NOT_FOUND
    c.on(&#039;data&#039;, (val) =&gt; {
      v = Decoder.nullcheck(val)
      c.close()
    })
    if (typeof cb === &#039;function&#039;) {
      c.once(&#039;error&#039;, (er) =&gt; {
        const u = v
        v = ERROR
        c.close()
        return cb(er, u)
      })
      c.once(&#039;end&#039;, () =&gt; {
        switch (v) {
          case NOT_FOUND:
            if (required) {
              return cb(new Error(&#039;No CBOR found&#039;))
            } else {
              return cb(null, v)
            }
          case ERROR:
            return void 0
          default:
            return cb(null, v)
        }
      })
    } else {
      p = new Promise((resolve, reject) =&gt; {
        c.once(&#039;error&#039;, (er) =&gt; {
          v = ERROR
          c.close()
          return reject(er)
        })
        return c.once(&#039;end&#039;, () =&gt; {
          switch (v) {
            case NOT_FOUND:
              if (required) {
                return reject(new Error(&#039;No CBOR found&#039;))
              } else {
                return resolve(v)
              }
            case ERROR:
              return void 0
            default:
              return resolve(v)
          }
        })
      })
    }
    c.end(input, encod)
    return p
  }

  /**
   * @callback decodeAllCallback
   * @param {Error} error - if one was generated
   * @param {Array} value - all of the decoded values, wrapped in an Array
   */

  /**
   * Decode all of the CBOR items in the input.  This will error if there are
   * more bytes left over at the end.
   *
   * @static
   * @param {(string|Buffer)} input - the input to parse
   * @param {(string|Object)} options - Decoding options.
   *   If string, the input encoding.
   * @param {decodeAllCallback} cb
   * @returns {Promise} if no callback
   */
  static decodeAll(input, options, cb) {
    let opts = {}
    let encod = &#039;hex&#039;
    switch (typeof options) {
      case &#039;function&#039;:
        cb = options
        encod = utils.guessEncoding(input)
        break
      case &#039;string&#039;:
        encod = options
        break
      case &#039;object&#039;:
        opts = utils.extend({}, options)
        encod = (opts.encoding != null) ?
          opts.encoding : utils.guessEncoding(input)
        delete opts.encoding
    }
    const c = new Decoder(opts)
    let p
    const vals = []
    c.on(&#039;data&#039;, (val) =&gt; {
      return vals.push(Decoder.nullcheck(val))
    })
    if (typeof cb === &#039;function&#039;) {
      c.on(&#039;error&#039;, cb)
      c.on(&#039;end&#039;, () =&gt; cb(null, vals))
    } else {
      p = new Promise((resolve, reject) =&gt; {
        c.on(&#039;error&#039;, reject)
        c.on(&#039;end&#039;, () =&gt; resolve(vals))
      })
    }
    c.end(input, encod)
    return p
  }

  /**
   * Stop processing
   */
  close() {
    this.running = false
    this.__fresh = true
  }

  *_parse() {
    let parent = null
    let depth = 0
    let val = null
    while (true) {
      if ((this.max_depth &gt;= 0) &amp;&amp; (depth &gt; this.max_depth)) {
        throw new Error(&#039;Maximum depth &#039; + this.max_depth + &#039; exceeded&#039;)
      }
      const octet = (yield 1)[0]
      if (!this.running) {
        throw new Error(&#039;Unexpected data: 0x&#039; + (octet.toString(16)))
      }
      const mt = octet &gt;&gt; 5
      const ai = octet &amp; 0x1f
      const parent_major = (parent != null) ? parent[MAJOR] : undefined
      const parent_length = (parent != null) ? parent.length : undefined
      switch (ai) {
        case NUMBYTES.ONE:
          this.emit(&#039;more-bytes&#039;, mt, 1, parent_major, parent_length)
          val = (yield 1)[0]
          break
        case NUMBYTES.TWO:
        case NUMBYTES.FOUR:
        case NUMBYTES.EIGHT:
          const numbytes = 1 &lt;&lt; (ai - 24)
          this.emit(&#039;more-bytes&#039;, mt, numbytes, parent_major, parent_length)
          const buf = yield numbytes
          val = (mt === MT.SIMPLE_FLOAT) ? buf : utils.parseCBORint(ai, buf)
          break
        case 28:
        case 29:
        case 30:
          this.running = false
          throw new Error(&#039;Additional info not implemented: &#039; + ai)
        case NUMBYTES.INDEFINITE:
          switch (mt) {
            case MT.POS_INT:
            case MT.NEG_INT:
            case MT.TAG:
              throw new Error(`Invalid indefinite encoding for MT ${mt}`)
          }
          val = -1
          break
        default:
          val = ai
      }
      switch (mt) {
        case MT.POS_INT:
          // val already decoded
          break
        case MT.NEG_INT:
          if (val === Number.MAX_SAFE_INTEGER) {
            val = NEG_MAX
          } else if (val instanceof bignumber) {
            val = NEG_ONE.minus(val)
          } else {
            val = -1 - val
          }
          break
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          switch (val) {
            case 0:
              this.emit(&#039;start-string&#039;, mt, val, parent_major, parent_length)
              val = (mt === MT.BYTE_STRING) ? Buffer.allocUnsafe(0) : &#039;&#039;
              break
            case -1:
              this.emit(&#039;start&#039;, mt, SYMS.STREAM, parent_major, parent_length)
              parent = parentBufferStream(parent, mt)
              depth++
              continue
            default:
              this.emit(&#039;start-string&#039;, mt, val, parent_major, parent_length)
              val = yield val
              if (mt === MT.UTF8_STRING) {
                val = utils.utf8(val)
              }
          }
          break
        case MT.ARRAY:
        case MT.MAP:
          switch (val) {
            case 0:
              val = (mt === MT.MAP) ? {} : []
              break
            case -1:
              this.emit(&#039;start&#039;, mt, SYMS.STREAM, parent_major, parent_length)
              parent = parentArray(parent, mt, -1)
              depth++
              continue
            default:
              this.emit(&#039;start&#039;, mt, val, parent_major, parent_length)
              parent = parentArray(parent, mt, val * (mt - 3))
              depth++
              continue
          }
          break
        case MT.TAG:
          this.emit(&#039;start&#039;, mt, val, parent_major, parent_length)
          parent = parentArray(parent, mt, 1)
          parent.push(val)
          depth++
          continue
        case MT.SIMPLE_FLOAT:
          if (typeof val === &#039;number&#039;) {
            if ((ai === NUMBYTES.ONE) &amp;&amp; (val &lt; 32)) {
              throw new Error(
                `Invalid two-byte encoding of simple value ${val}`
              )
            }
            const hasParent = (parent != null)
            val = Simple.decode(val, hasParent, hasParent &amp;&amp; (parent[COUNT] &lt; 0))
          } else {
            val = utils.parseCBORfloat(val)
          }
      }
      this.emit(&#039;value&#039;, val, parent_major, parent_length, ai)
      let again = false
      while (parent != null) {
        switch (false) {
          case val !== SYMS.BREAK:
            parent[COUNT] = 1
            break
          case !Array.isArray(parent):
            parent.push(val)
            break
          case !(parent instanceof NoFilter):
            const pm = parent[MAJOR]
            if ((pm != null) &amp;&amp; (pm !== mt)) {
              this.running = false
              throw new Error(&#039;Invalid major type in indefinite encoding&#039;)
            }
            parent.write(val)
        }
        if ((--parent[COUNT]) !== 0) {
          again = true
          break
        }
        --depth
        delete parent[COUNT]
        this.emit(&#039;stop&#039;, parent[MAJOR])

        if (Array.isArray(parent)) {
          switch (parent[MAJOR]) {
            case MT.ARRAY:
              val = parent
              break
            case MT.MAP:
              let allstrings = true
              if ((parent.length % 2) !== 0) {
                throw new Error(&#039;Invalid map length: &#039; + parent.length)
              }
              for (let i = 0, len = parent.length; i &lt; len; i += 2) {
                if (typeof parent[i] !== &#039;string&#039;) {
                  allstrings = false
                  break
                }
              }
              if (allstrings) {
                val = {}
                for (let i = 0, len = parent.length; i &lt; len; i += 2) {
                  val[parent[i]] = parent[i + 1]
                }
              } else {
                val = new Map
                for (let i = 0, len = parent.length; i &lt; len; i += 2) {
                  val.set(parent[i], parent[i + 1])
                }
              }
              break
            case MT.TAG:
              const t = new Tagged(parent[0], parent[1])
              val = t.convert(this.tags)
              break
          }
        } else if (parent instanceof NoFilter) {
          switch (parent[MAJOR]) {
            case MT.BYTE_STRING:
              val = parent.slice()
              break
            case MT.UTF8_STRING:
              val = parent.toString(&#039;utf-8&#039;)
              break
          }
        }

        const old = parent
        parent = parent[SYMS.PARENT]
        delete old[SYMS.PARENT]
        delete old[MAJOR]
      }
      if (!again) {
        return val
      }
    }
  }
}

Decoder.NOT_FOUND = NOT_FOUND
module.exports = Decoder
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
