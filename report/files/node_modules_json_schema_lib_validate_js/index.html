<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/json-schema/lib/validate.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/json-schema/lib/validate.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">272</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">79.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
 *	(http://www.json.com/json-schema-proposal/)
 * Licensed under AFL-2.1 OR BSD-3-Clause
To use the validator call the validate function with an instance object and an optional schema object.
If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
that schema will be used to validate and the schema parameter is not necessary (if both exist,
both validations will occur).
The validate method will return an array of validation errors. If there are no errors, then an
empty list will be returned. A validation error will have two properties:
&quot;property&quot; which indicates which property had the error
&quot;message&quot; which indicates what the error was
 */
(function (root, factory) {
    if (typeof define === &#039;function&#039; &amp;&amp; define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory();
        });
    } else if (typeof module === &#039;object&#039; &amp;&amp; module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        root.jsonSchema = factory();
    }
}(this, function () {// setup primitive classes to be JSON Schema types
var exports = validate
exports.Integer = {type:&quot;integer&quot;};
var primitiveConstructors = {
	String: String,
	Boolean: Boolean,
	Number: Number,
	Object: Object,
	Array: Array,
	Date: Date
}
exports.validate = validate;
function validate(/*Any*/instance,/*Object*/schema) {
		// Summary:
		//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
		// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
		// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
		// 		both validations will occur).
		// 		The validate method will return an object with two properties:
		// 			valid: A boolean indicating if the instance is valid by the schema
		// 			errors: An array of validation errors. If there are no errors, then an
		// 					empty list will be returned. A validation error will have two properties:
		// 						property: which indicates which property had the error
		// 						message: which indicates what the error was
		//
		return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
	};
exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
		// Summary:
		// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
		// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
		// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
		// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
		// 		information.
		//
		return validate(value, schema, {changing: property || &quot;property&quot;});
	};
var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {

	if (!options) options = {};
	var _changing = options.changing;

	function getType(schema){
		return schema.type || (primitiveConstructors[schema.name] == schema &amp;&amp; schema.name.toLowerCase());
	}
	var errors = [];
	// validate a value against a property definition
	function checkProp(value, schema, path,i){

		var l;
		path += path ? typeof i == &#039;number&#039; ? &#039;[&#039; + i + &#039;]&#039; : typeof i == &#039;undefined&#039; ? &#039;&#039; : &#039;.&#039; + i : i;
		function addError(message){
			errors.push({property:path,message:message});
		}

		if((typeof schema != &#039;object&#039; || schema instanceof Array) &amp;&amp; (path || typeof schema != &#039;function&#039;) &amp;&amp; !(schema &amp;&amp; getType(schema))){
			if(typeof schema == &#039;function&#039;){
				if(!(value instanceof schema)){
					addError(&quot;is not an instance of the class/constructor &quot; + schema.name);
				}
			}else if(schema){
				addError(&quot;Invalid schema/property definition &quot; + schema);
			}
			return null;
		}
		if(_changing &amp;&amp; schema.readonly){
			addError(&quot;is a readonly field, it can not be changed&quot;);
		}
		if(schema[&#039;extends&#039;]){ // if it extends another schema, it must pass that schema as well
			checkProp(value,schema[&#039;extends&#039;],path,i);
		}
		// validate a value against a type definition
		function checkType(type,value){
			if(type){
				if(typeof type == &#039;string&#039; &amp;&amp; type != &#039;any&#039; &amp;&amp;
						(type == &#039;null&#039; ? value !== null : typeof value != type) &amp;&amp;
						!(value instanceof Array &amp;&amp; type == &#039;array&#039;) &amp;&amp;
						!(value instanceof Date &amp;&amp; type == &#039;date&#039;) &amp;&amp;
						!(type == &#039;integer&#039; &amp;&amp; value%1===0)){
					return [{property:path,message:value + &quot; - &quot; + (typeof value) + &quot; value found, but a &quot; + type + &quot; is required&quot;}];
				}
				if(type instanceof Array){
					var unionErrors=[];
					for(var j = 0; j &lt; type.length; j++){ // a union type
						if(!(unionErrors=checkType(type[j],value)).length){
							break;
						}
					}
					if(unionErrors.length){
						return unionErrors;
					}
				}else if(typeof type == &#039;object&#039;){
					var priorErrors = errors;
					errors = [];
					checkProp(value,type,path);
					var theseErrors = errors;
					errors = priorErrors;
					return theseErrors;
				}
			}
			return [];
		}
		if(value === undefined){
			if(schema.required){
				addError(&quot;is missing and it is required&quot;);
			}
		}else{
			errors = errors.concat(checkType(getType(schema),value));
			if(schema.disallow &amp;&amp; !checkType(schema.disallow,value).length){
				addError(&quot; disallowed value was matched&quot;);
			}
			if(value !== null){
				if(value instanceof Array){
					if(schema.items){
						var itemsIsArray = schema.items instanceof Array;
						var propDef = schema.items;
						for (i = 0, l = value.length; i &lt; l; i += 1) {
							if (itemsIsArray)
								propDef = schema.items[i];
							if (options.coerce)
								value[i] = options.coerce(value[i], propDef);
							errors.concat(checkProp(value[i],propDef,path,i));
						}
					}
					if(schema.minItems &amp;&amp; value.length &lt; schema.minItems){
						addError(&quot;There must be a minimum of &quot; + schema.minItems + &quot; in the array&quot;);
					}
					if(schema.maxItems &amp;&amp; value.length &gt; schema.maxItems){
						addError(&quot;There must be a maximum of &quot; + schema.maxItems + &quot; in the array&quot;);
					}
				}else if(schema.properties || schema.additionalProperties){
					errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
				}
				if(schema.pattern &amp;&amp; typeof value == &#039;string&#039; &amp;&amp; !value.match(schema.pattern)){
					addError(&quot;does not match the regex pattern &quot; + schema.pattern);
				}
				if(schema.maxLength &amp;&amp; typeof value == &#039;string&#039; &amp;&amp; value.length &gt; schema.maxLength){
					addError(&quot;may only be &quot; + schema.maxLength + &quot; characters long&quot;);
				}
				if(schema.minLength &amp;&amp; typeof value == &#039;string&#039; &amp;&amp; value.length &lt; schema.minLength){
					addError(&quot;must be at least &quot; + schema.minLength + &quot; characters long&quot;);
				}
				if(typeof schema.minimum !== &#039;undefined&#039; &amp;&amp; typeof value == typeof schema.minimum &amp;&amp;
						schema.minimum &gt; value){
					addError(&quot;must have a minimum value of &quot; + schema.minimum);
				}
				if(typeof schema.maximum !== &#039;undefined&#039; &amp;&amp; typeof value == typeof schema.maximum &amp;&amp;
						schema.maximum &lt; value){
					addError(&quot;must have a maximum value of &quot; + schema.maximum);
				}
				if(schema[&#039;enum&#039;]){
					var enumer = schema[&#039;enum&#039;];
					l = enumer.length;
					var found;
					for(var j = 0; j &lt; l; j++){
						if(enumer[j]===value){
							found=1;
							break;
						}
					}
					if(!found){
						addError(&quot;does not have a value in the enumeration &quot; + enumer.join(&quot;, &quot;));
					}
				}
				if(typeof schema.maxDecimal == &#039;number&#039; &amp;&amp;
					(value.toString().match(new RegExp(&quot;\\.[0-9]{&quot; + (schema.maxDecimal + 1) + &quot;,}&quot;)))){
					addError(&quot;may only have &quot; + schema.maxDecimal + &quot; digits of decimal places&quot;);
				}
			}
		}
		return null;
	}
	// validate an object against a schema
	function checkObj(instance,objTypeDef,path,additionalProp){

		if(typeof objTypeDef ==&#039;object&#039;){
			if(typeof instance != &#039;object&#039; || instance instanceof Array){
				errors.push({property:path,message:&quot;an object is required&quot;});
			}
			
			for(var i in objTypeDef){ 
				if(objTypeDef.hasOwnProperty(i) &amp;&amp; i != &#039;__proto__&#039; &amp;&amp; i != &#039;constructor&#039;){
					var value = instance.hasOwnProperty(i) ? instance[i] : undefined;
					// skip _not_ specified properties
					if (value === undefined &amp;&amp; options.existingOnly) continue;
					var propDef = objTypeDef[i];
					// set default
					if(value === undefined &amp;&amp; propDef[&quot;default&quot;]){
						value = instance[i] = propDef[&quot;default&quot;];
					}
					if(options.coerce &amp;&amp; i in instance){
						value = instance[i] = options.coerce(value, propDef);
					}
					checkProp(value,propDef,path,i);
				}
			}
		}
		for(i in instance){
			if(instance.hasOwnProperty(i) &amp;&amp; !(i.charAt(0) == &#039;_&#039; &amp;&amp; i.charAt(1) == &#039;_&#039;) &amp;&amp; objTypeDef &amp;&amp; !objTypeDef[i] &amp;&amp; additionalProp===false){
				if (options.filter) {
					delete instance[i];
					continue;
				} else {
					errors.push({property:path,message:&quot;The property &quot; + i +
						&quot; is not defined in the schema and the schema does not allow additional properties&quot;});
				}
			}
			var requires = objTypeDef &amp;&amp; objTypeDef[i] &amp;&amp; objTypeDef[i].requires;
			if(requires &amp;&amp; !(requires in instance)){
				errors.push({property:path,message:&quot;the presence of the property &quot; + i + &quot; requires that &quot; + requires + &quot; also be present&quot;});
			}
			value = instance[i];
			if(additionalProp &amp;&amp; (!(objTypeDef &amp;&amp; typeof objTypeDef == &#039;object&#039;) || !(i in objTypeDef))){
				if(options.coerce){
					value = instance[i] = options.coerce(value, additionalProp);
				}
				checkProp(value,additionalProp,path,i);
			}
			if(!_changing &amp;&amp; value &amp;&amp; value.$schema){
				errors = errors.concat(checkProp(value,value.$schema,path,i));
			}
		}
		return errors;
	}
	if(schema){
		checkProp(instance,schema,&#039;&#039;,_changing || &#039;&#039;);
	}
	if(!_changing &amp;&amp; instance &amp;&amp; instance.$schema){
		checkProp(instance,instance.$schema,&#039;&#039;,&#039;&#039;);
	}
	return {valid:!errors.length,errors:errors};
};
exports.mustBeValid = function(result){
	//	summary:
	//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
	// result: the result returned from checkPropertyChange or validate
	if(!result.valid){
		throw new TypeError(result.errors.map(function(error){return &quot;for property &quot; + error.property + &#039;: &#039; + error.message;}).join(&quot;, \n&quot;));
	}
}

return exports;
}));
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
