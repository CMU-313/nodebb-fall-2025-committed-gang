<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/plugin-transform-regenerator/lib/regenerator/visit.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/plugin-transform-regenerator/lib/regenerator/visit.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">222</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">57.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.56</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.getVisitor = void 0;
var _assert = require(&quot;assert&quot;);
var _hoist = require(&quot;./hoist.js&quot;);
var _emit = require(&quot;./emit.js&quot;);
var _replaceShorthandObjectMethod = require(&quot;./replaceShorthandObjectMethod.js&quot;);
var util = require(&quot;./util.js&quot;);
var _core = require(&quot;@babel/core&quot;);
const getVisitor = () =&gt; ({
  Method(path, state) {
    const node = path.node;
    if (!shouldRegenerate(node, state)) return;
    const container = _core.types.functionExpression(null, [], _core.types.cloneNode(node.body, false), node.generator, node.async);
    path.get(&quot;body&quot;).set(&quot;body&quot;, [_core.types.returnStatement(_core.types.callExpression(container, []))]);
    node.async = false;
    node.generator = false;
    path.get(&quot;body.body.0.argument.callee&quot;).unwrapFunctionEnvironment();
  },
  Function: {
    exit(path, state) {
      let node = path.node;
      if (!shouldRegenerate(node, state)) return;
      path = (0, _replaceShorthandObjectMethod.default)(path);
      node = path.node;
      const contextId = path.scope.generateUidIdentifier(&quot;context&quot;);
      const argsId = path.scope.generateUidIdentifier(&quot;args&quot;);
      path.ensureBlock();
      const bodyBlockPath = path.get(&quot;body&quot;);
      if (node.async) {
        bodyBlockPath.traverse(awaitVisitor, this);
      }
      bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId,
        pluginPass: this
      });
      const outerBody = [];
      const innerBody = [];
      bodyBlockPath.get(&quot;body&quot;).forEach(function (childPath) {
        const node = childPath.node;
        if (_core.types.isExpressionStatement(node) &amp;&amp; _core.types.isStringLiteral(node.expression)) {
          outerBody.push(node);
        } else if ((node == null ? void 0 : node._blockHoist) != null) {
          outerBody.push(node);
        } else {
          innerBody.push(node);
        }
      });
      if (outerBody.length &gt; 0) {
        bodyBlockPath.node.body = innerBody;
      }
      const outerFnExpr = getOuterFnExpr(this, path);
      _core.types.assertIdentifier(node.id);
      const vars = (0, _hoist.hoist)(path);
      const context = {
        usesThis: false,
        usesArguments: false,
        getArgsId: () =&gt; _core.types.cloneNode(argsId)
      };
      path.traverse(argumentsThisVisitor, context);
      if (context.usesArguments) {
        vars.push(_core.types.variableDeclarator(_core.types.cloneNode(argsId), _core.types.identifier(&quot;arguments&quot;)));
      }
      const emitter = new _emit.Emitter(contextId, path.scope, vars, this);
      emitter.explode(path.get(&quot;body&quot;));
      if (vars.length &gt; 0) {
        outerBody.push(_core.types.variableDeclaration(&quot;var&quot;, vars));
      }
      const wrapArgs = [emitter.getContextFunction()];
      const tryLocsList = emitter.getTryLocsList();
      if (node.generator) {
        wrapArgs.push(outerFnExpr);
      } else if (context.usesThis || tryLocsList || node.async) {
        wrapArgs.push(_core.types.nullLiteral());
      }
      if (context.usesThis) {
        wrapArgs.push(_core.types.thisExpression());
      } else if (tryLocsList || node.async) {
        wrapArgs.push(_core.types.nullLiteral());
      }
      if (tryLocsList) {
        wrapArgs.push(tryLocsList);
      } else if (node.async) {
        wrapArgs.push(_core.types.nullLiteral());
      }
      if (node.async) {
        let currentScope = path.scope;
        do {
          if (currentScope.hasOwnBinding(&quot;Promise&quot;)) currentScope.rename(&quot;Promise&quot;);
        } while (currentScope = currentScope.parent);
        wrapArgs.push(_core.types.identifier(&quot;Promise&quot;));
      }
      const wrapCall = _core.types.callExpression(util.newHelpersAvailable(this) ? !node.async ? _core.types.memberExpression(_core.types.callExpression(this.addHelper(&quot;regenerator&quot;), []), _core.types.identifier(&quot;w&quot;)) : node.generator ? this.addHelper(&quot;regeneratorAsyncGen&quot;) : this.addHelper(&quot;regeneratorAsync&quot;) : util.runtimeProperty(this, node.async ? &quot;async&quot; : &quot;wrap&quot;), wrapArgs);
      outerBody.push(_core.types.returnStatement(wrapCall));
      node.body = _core.types.blockStatement(outerBody);
      path.get(&quot;body.body&quot;).forEach(p =&gt; p.scope.registerDeclaration(p));
      const oldDirectives = bodyBlockPath.node.directives;
      if (oldDirectives) {
        node.body.directives = oldDirectives;
      }
      const wasGeneratorFunction = node.generator;
      if (wasGeneratorFunction) {
        node.generator = false;
      }
      if (node.async) {
        node.async = false;
      }
      if (wasGeneratorFunction &amp;&amp; _core.types.isExpression(node)) {
        path.replaceWith(_core.types.callExpression(util.newHelpersAvailable(this) ? _core.types.memberExpression(_core.types.callExpression(this.addHelper(&quot;regenerator&quot;), []), _core.types.identifier(&quot;m&quot;)) : util.runtimeProperty(this, &quot;mark&quot;), [node]));
        path.addComment(&quot;leading&quot;, &quot;#__PURE__&quot;);
      }
      const insertedLocs = emitter.getInsertedLocs();
      path.traverse({
        NumericLiteral(path) {
          if (!insertedLocs.has(path.node)) {
            return;
          }
          path.replaceWith(_core.types.numericLiteral(path.node.value));
        }
      });
      path.requeue();
    }
  }
});
exports.getVisitor = getVisitor;
function shouldRegenerate(node, state) {
  if (node.generator) {
    if (node.async) {
      return state.opts.asyncGenerators !== false;
    } else {
      return state.opts.generators !== false;
    }
  } else if (node.async) {
    return state.opts.async !== false;
  } else {
    return false;
  }
}
function getOuterFnExpr(state, funPath) {
  const node = funPath.node;
  _core.types.assertFunction(node);
  if (!node.id) {
    node.id = funPath.scope.parent.generateUidIdentifier(&quot;callee&quot;);
  }
  if (node.generator &amp;&amp; _core.types.isFunctionDeclaration(node)) {
    return getMarkedFunctionId(state, funPath);
  }
  return _core.types.cloneNode(node.id);
}
const markInfo = new WeakMap();
function getMarkInfo(node) {
  if (!markInfo.has(node)) {
    markInfo.set(node, {});
  }
  return markInfo.get(node);
}
function getMarkedFunctionId(state, funPath) {
  const node = funPath.node;
  _core.types.assertIdentifier(node.id);
  const blockPath = funPath.findParent(function (path) {
    return path.isProgram() || path.isBlockStatement();
  });
  if (!blockPath) {
    return node.id;
  }
  const block = blockPath.node;
  _assert.ok(Array.isArray(block.body));
  const info = getMarkInfo(block);
  if (!info.decl) {
    info.decl = _core.types.variableDeclaration(&quot;var&quot;, []);
    blockPath.unshiftContainer(&quot;body&quot;, info.decl);
    info.declPath = blockPath.get(&quot;body.0&quot;);
  }
  _assert.strictEqual(info.declPath.node, info.decl);
  const markedId = blockPath.scope.generateUidIdentifier(&quot;marked&quot;);
  const markCallExp = _core.types.callExpression(util.newHelpersAvailable(state) ? _core.types.memberExpression(_core.types.callExpression(state.addHelper(&quot;regenerator&quot;), []), _core.types.identifier(&quot;m&quot;)) : util.runtimeProperty(state, &quot;mark&quot;), [_core.types.cloneNode(node.id)]);
  const index = info.decl.declarations.push(_core.types.variableDeclarator(markedId, markCallExp)) - 1;
  const markCallExpPath = info.declPath.get(&quot;declarations.&quot; + index + &quot;.init&quot;);
  _assert.strictEqual(markCallExpPath.node, markCallExp);
  markCallExpPath.addComment(&quot;leading&quot;, &quot;#__PURE__&quot;);
  return _core.types.cloneNode(markedId);
}
const argumentsThisVisitor = {
  &quot;FunctionExpression|FunctionDeclaration|Method&quot;: function (path) {
    path.skip();
  },
  Identifier: function (path, state) {
    if (path.node.name === &quot;arguments&quot; &amp;&amp; util.isReference(path)) {
      path.replaceWith(state.getArgsId());
      state.usesArguments = true;
    }
  },
  ThisExpression: function (path, state) {
    state.usesThis = true;
  }
};
const functionSentVisitor = {
  MetaProperty(path, state) {
    const {
      node
    } = path;
    if (node.meta.name === &quot;function&quot; &amp;&amp; node.property.name === &quot;sent&quot;) {
      path.replaceWith(_core.types.memberExpression(_core.types.cloneNode(state.context), _core.types.identifier(util.newHelpersAvailable(state.pluginPass) ? &quot;v&quot; : &quot;_sent&quot;)));
    }
  }
};
const awaitVisitor = {
  Function: function (path) {
    path.skip();
  },
  AwaitExpression: function (path) {
    const argument = path.node.argument;
    const helper = util.newHelpersAvailable(this) ? this.addHelper(&quot;awaitAsyncGenerator&quot;) : util.runtimeProperty(this, &quot;awrap&quot;);
    path.replaceWith(_core.types.yieldExpression(_core.types.callExpression(helper, [argument]), false));
  }
};

//# sourceMappingURL=visit.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
