<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/micromatch/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/micromatch/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.99</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">475</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.19</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const util = require(&#039;util&#039;);
const braces = require(&#039;braces&#039;);
const picomatch = require(&#039;picomatch&#039;);
const utils = require(&#039;picomatch/lib/utils&#039;);

const isEmptyString = v =&gt; v === &#039;&#039; || v === &#039;./&#039;;
const hasBraces = v =&gt; {
  const index = v.indexOf(&#039;{&#039;);
  return index &gt; -1 &amp;&amp; v.indexOf(&#039;}&#039;, index) &gt; -1;
};

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm(list, patterns[, options]);
 *
 * console.log(mm([&#039;a.js&#039;, &#039;a.txt&#039;], [&#039;*.js&#039;]));
 * //=&gt; [ &#039;a.js&#039; ]
 * ```
 * @param {String|Array&lt;string&gt;} `list` List of strings to match.
 * @param {String|Array&lt;string&gt;} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) =&gt; {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state =&gt; {
    items.add(state.output);
    if (options &amp;&amp; options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i &lt; patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item =&gt; !omit.has(item));

  if (options &amp;&amp; matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for &quot;${patterns.join(&#039;, &#039;)}&quot;`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p =&gt; p.replace(/\\/g, &#039;&#039;)) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher(&#039;*.!(*a)&#039;);
 * console.log(isMatch(&#039;a.a&#039;)); //=&gt; false
 * console.log(isMatch(&#039;a.b&#039;)); //=&gt; true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) =&gt; picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch(&#039;a.a&#039;, [&#039;b.*&#039;, &#039;*.a&#039;])); //=&gt; true
 * console.log(mm.isMatch(&#039;a.a&#039;, &#039;b.*&#039;)); //=&gt; false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) =&gt; picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not([&#039;a.a&#039;, &#039;b.b&#039;, &#039;c.c&#039;], &#039;*.a&#039;));
 * //=&gt; [&#039;b.b&#039;, &#039;c.c&#039;]
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) =&gt; {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state =&gt; {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));

  for (let item of items) {
    if (!matches.has(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require(&#039;micromatch&#039;);
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains(&#039;aa/bb/cc&#039;, &#039;*b&#039;));
 * //=&gt; true
 * console.log(mm.contains(&#039;aa/bb/cc&#039;, &#039;*d&#039;));
 * //=&gt; false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) =&gt; {
  if (typeof str !== &#039;string&#039;) {
    throw new TypeError(`Expected a string: &quot;${util.inspect(str)}&quot;`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p =&gt; micromatch.contains(str, p, options));
  }

  if (typeof pattern === &#039;string&#039;) {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith(&#039;./&#039;) &amp;&amp; str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: &#039;a&#039;, ab: &#039;b&#039;, ac: &#039;c&#039; };
 * console.log(mm.matchKeys(obj, &#039;*b&#039;));
 * //=&gt; { ab: &#039;b&#039; }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) =&gt; {
  if (!utils.isObject(obj)) {
    throw new TypeError(&#039;Expected the first argument to be an object&#039;);
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));
 * // true
 * console.log(mm.some([&#039;foo.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch.some = (list, patterns, options) =&gt; {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item =&gt; isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every(&#039;foo.js&#039;, [&#039;foo.js&#039;]));
 * // true
 * console.log(mm.every([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;]));
 * // true
 * console.log(mm.every([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));
 * // false
 * console.log(mm.every([&#039;foo.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch.every = (list, patterns, options) =&gt; {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item =&gt; isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all(&#039;foo.js&#039;, [&#039;foo.js&#039;]));
 * // true
 *
 * console.log(mm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;!foo.js&#039;]));
 * // false
 *
 * console.log(mm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;foo.js&#039;]));
 * // true
 *
 * console.log(mm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;f*&#039;, &#039;*o*&#039;, &#039;*o.js&#039;]));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) =&gt; {
  if (typeof str !== &#039;string&#039;) {
    throw new TypeError(`Expected a string: &quot;${util.inspect(str)}&quot;`);
  }

  return [].concat(patterns).every(p =&gt; picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture(&#039;test/*.js&#039;, &#039;test/foo.js&#039;));
 * //=&gt; [&#039;foo&#039;]
 * console.log(mm.capture(&#039;test/*.js&#039;, &#039;foo/bar.css&#039;));
 * //=&gt; null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) =&gt; {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v =&gt; v === void 0 ? &#039;&#039; : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe(&#039;*.js&#039;));
 * //=&gt; /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) =&gt; picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) =&gt; picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require(&#039;micromatch&#039;);
 * const state = mm.parse(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) =&gt; {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require(&#039;micromatch&#039;);
 * console.log(braces(&#039;foo/{a,b,c}/bar&#039;));
 * //=&gt; [ &#039;foo/(a|b|c)/bar&#039; ]
 *
 * console.log(braces(&#039;foo/{a,b,c}/bar&#039;, { expand: true }));
 * //=&gt; [ &#039;foo/a/bar&#039;, &#039;foo/b/bar&#039;, &#039;foo/c/bar&#039; ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) =&gt; {
  if (typeof pattern !== &#039;string&#039;) throw new TypeError(&#039;Expected a string&#039;);
  if ((options &amp;&amp; options.nobrace === true) || !hasBraces(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) =&gt; {
  if (typeof pattern !== &#039;string&#039;) throw new TypeError(&#039;Expected a string&#039;);
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

// exposed for tests
micromatch.hasBraces = hasBraces;
module.exports = micromatch;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
