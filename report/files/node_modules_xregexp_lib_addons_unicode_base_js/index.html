<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/xregexp/lib/addons/unicode-base.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/xregexp/lib/addons/unicode-base.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">288</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.10</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

var _sliceInstanceProperty = require(&quot;@babel/runtime-corejs3/core-js-stable/instance/slice&quot;);
var _Array$from = require(&quot;@babel/runtime-corejs3/core-js-stable/array/from&quot;);
var _Symbol = require(&quot;@babel/runtime-corejs3/core-js-stable/symbol&quot;);
var _getIteratorMethod = require(&quot;@babel/runtime-corejs3/core-js/get-iterator-method&quot;);
var _Array$isArray = require(&quot;@babel/runtime-corejs3/core-js-stable/array/is-array&quot;);
var _Object$defineProperty = require(&quot;@babel/runtime-corejs3/core-js-stable/object/define-property&quot;);
var _interopRequireDefault = require(&quot;@babel/runtime-corejs3/helpers/interopRequireDefault&quot;);
_Object$defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports[&quot;default&quot;] = void 0;
var _slicedToArray2 = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/helpers/slicedToArray&quot;));
var _forEach = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/for-each&quot;));
var _concat = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/concat&quot;));
var _indexOf = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/index-of&quot;));
function _createForOfIteratorHelper(r, e) { var t = &quot;undefined&quot; != typeof _Symbol &amp;&amp; _getIteratorMethod(r) || r[&quot;@@iterator&quot;]; if (!t) { if (_Array$isArray(r) || (t = _unsupportedIterableToArray(r)) || e &amp;&amp; r &amp;&amp; &quot;number&quot; == typeof r.length) { t &amp;&amp; (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n &gt;= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(&quot;Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[&quot;return&quot;] || t[&quot;return&quot;](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { var _context4; if (&quot;string&quot; == typeof r) return _arrayLikeToArray(r, a); var t = _sliceInstanceProperty(_context4 = {}.toString.call(r)).call(_context4, 8, -1); return &quot;Object&quot; === t &amp;&amp; r.constructor &amp;&amp; (t = r.constructor.name), &quot;Map&quot; === t || &quot;Set&quot; === t ? _Array$from(r) : &quot;Arguments&quot; === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a &gt; r.length) &amp;&amp; (a = r.length); for (var e = 0, n = Array(a); e &lt; a; e++) n[e] = r[e]; return n; }
/*!
 * XRegExp Unicode Base 5.1.2
 * &lt;xregexp.com&gt;
 * Steven Levithan (c) 2008-present MIT License
 */
var _default = exports[&quot;default&quot;] = function _default(XRegExp) {
  /**
   * Adds base support for Unicode matching:
   * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
   *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
   *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
   * - Adds flag A (astral), which enables 21-bit Unicode support.
   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
   *
   * Unicode Base relies on externally provided Unicode character data. Official addons are
   * available to provide data for Unicode categories, scripts, and properties.
   *
   * @requires XRegExp
   */

  // ==--------------------------==
  // Private stuff
  // ==--------------------------==

  // Storage for Unicode data
  var unicode = {};
  var unicodeTypes = {};

  // Reuse utils
  var dec = XRegExp._dec;
  var hex = XRegExp._hex;
  var pad4 = XRegExp._pad4;

  // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
  function normalize(name) {
    return name.replace(/[- _]+/g, &#039;&#039;).toLowerCase();
  }

  // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
  function charCode(chr) {
    var esc = /^\\[xu](.+)/.exec(chr);
    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === &#039;\\&#039; ? 1 : 0);
  }

  // Inverts a list of ordered BMP characters and ranges
  function invertBmp(range) {
    var output = &#039;&#039;;
    var lastEnd = -1;
    (0, _forEach[&quot;default&quot;])(XRegExp).call(XRegExp, range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function (m) {
      var start = charCode(m[1]);
      if (start &gt; lastEnd + 1) {
        output += &quot;\\u&quot;.concat(pad4(hex(lastEnd + 1)));
        if (start &gt; lastEnd + 2) {
          output += &quot;-\\u&quot;.concat(pad4(hex(start - 1)));
        }
      }
      lastEnd = charCode(m[2] || m[1]);
    });
    if (lastEnd &lt; 0xFFFF) {
      output += &quot;\\u&quot;.concat(pad4(hex(lastEnd + 1)));
      if (lastEnd &lt; 0xFFFE) {
        output += &#039;-\\uFFFF&#039;;
      }
    }
    return output;
  }

  // Generates an inverted BMP range on first use
  function cacheInvertedBmp(slug) {
    var prop = &#039;b!&#039;;
    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
  }

  // Combines and optionally negates BMP and astral data
  function buildAstral(slug, isNegated) {
    var item = unicode[slug];
    var combined = &#039;&#039;;
    if (item.bmp &amp;&amp; !item.isBmpLast) {
      var _context;
      combined = (0, _concat[&quot;default&quot;])(_context = &quot;[&quot;.concat(item.bmp, &quot;]&quot;)).call(_context, item.astral ? &#039;|&#039; : &#039;&#039;);
    }
    if (item.astral) {
      combined += item.astral;
    }
    if (item.isBmpLast &amp;&amp; item.bmp) {
      var _context2;
      combined += (0, _concat[&quot;default&quot;])(_context2 = &quot;&quot;.concat(item.astral ? &#039;|&#039; : &#039;&#039;, &quot;[&quot;)).call(_context2, item.bmp, &quot;]&quot;);
    }

    // Astral Unicode tokens always match a code point, never a code unit
    return isNegated ? &quot;(?:(?!&quot;.concat(combined, &quot;)(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))&quot;) : &quot;(?:&quot;.concat(combined, &quot;)&quot;);
  }

  // Builds a complete astral pattern on first use
  function cacheAstral(slug, isNegated) {
    var prop = isNegated ? &#039;a!&#039; : &#039;a=&#039;;
    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
  }

  // ==--------------------------==
  // Core functionality
  // ==--------------------------==

  /*
   * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
   */
  XRegExp.addToken(
  // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
  /\\([pP])(?:{(\^?)(?:(\w+)=)?([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {
    var ERR_DOUBLE_NEG = &#039;Invalid double negation &#039;;
    var ERR_UNKNOWN_NAME = &#039;Unknown Unicode token &#039;;
    var ERR_UNKNOWN_REF = &#039;Unicode token missing data &#039;;
    var ERR_ASTRAL_ONLY = &#039;Astral mode required for Unicode token &#039;;
    var ERR_ASTRAL_IN_CLASS = &#039;Astral mode does not support Unicode tokens within character classes&#039;;
    var _match = (0, _slicedToArray2[&quot;default&quot;])(match, 6),
      fullToken = _match[0],
      pPrefix = _match[1],
      caretNegation = _match[2],
      typePrefix = _match[3],
      tokenName = _match[4],
      tokenSingleCharName = _match[5];
    // Negated via \P{..} or \p{^..}
    var isNegated = pPrefix === &#039;P&#039; || !!caretNegation;
    // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
    var isAstralMode = (0, _indexOf[&quot;default&quot;])(flags).call(flags, &#039;A&#039;) !== -1;
    // Token lookup name. Check `tokenSingleCharName` first to avoid passing `undefined`
    // via `\p{}`
    var slug = normalize(tokenSingleCharName || tokenName);
    // Token data object
    var item = unicode[slug];
    if (pPrefix === &#039;P&#039; &amp;&amp; caretNegation) {
      throw new SyntaxError(ERR_DOUBLE_NEG + fullToken);
    }
    if (!unicode.hasOwnProperty(slug)) {
      throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);
    }
    if (typePrefix) {
      if (!(unicodeTypes[typePrefix] &amp;&amp; unicodeTypes[typePrefix][slug])) {
        throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);
      }
    }

    // Switch to the negated form of the referenced Unicode token
    if (item.inverseOf) {
      slug = normalize(item.inverseOf);
      if (!unicode.hasOwnProperty(slug)) {
        var _context3;
        throw new ReferenceError((0, _concat[&quot;default&quot;])(_context3 = &quot;&quot;.concat(ERR_UNKNOWN_REF + fullToken, &quot; -&gt; &quot;)).call(_context3, item.inverseOf));
      }
      item = unicode[slug];
      isNegated = !isNegated;
    }
    if (!(item.bmp || isAstralMode)) {
      throw new SyntaxError(ERR_ASTRAL_ONLY + fullToken);
    }
    if (isAstralMode) {
      if (scope === &#039;class&#039;) {
        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
      }
      return cacheAstral(slug, isNegated);
    }
    return scope === &#039;class&#039; ? isNegated ? cacheInvertedBmp(slug) : item.bmp : &quot;&quot;.concat((isNegated ? &#039;[^&#039; : &#039;[&#039;) + item.bmp, &quot;]&quot;);
  }, {
    scope: &#039;all&#039;,
    optionalFlags: &#039;A&#039;,
    leadChar: &#039;\\&#039;
  });

  /**
   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
   *
   * @memberOf XRegExp
   * @param {Array} data Objects with named character ranges. Each object may have properties
   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
   *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
   *   character classes and alternation, and should use surrogate pairs to represent astral code
   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
   *   defined as the exact inverse of another token.
   * @param {String} [typePrefix] Enables optionally using this type as a prefix for all of the
   *   provided Unicode tokens, e.g. if given `&#039;Type&#039;`, then `\p{TokenName}` can also be written
   *   as `\p{Type=TokenName}`.
   * @example
   *
   * // Basic use
   * XRegExp.addUnicodeData([{
   *   name: &#039;XDigit&#039;,
   *   alias: &#039;Hexadecimal&#039;,
   *   bmp: &#039;0-9A-Fa-f&#039;
   * }]);
   * XRegExp(&#039;\\p{XDigit}:\\p{Hexadecimal}+&#039;).test(&#039;0:3D&#039;); // -&gt; true
   */
  XRegExp.addUnicodeData = function (data, typePrefix) {
    var ERR_NO_NAME = &#039;Unicode token requires name&#039;;
    var ERR_NO_DATA = &#039;Unicode token has no character data &#039;;
    if (typePrefix) {
      // Case sensitive to match ES2018
      unicodeTypes[typePrefix] = {};
    }
    var _iterator = _createForOfIteratorHelper(data),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;
        if (!item.name) {
          throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
          throw new Error(ERR_NO_DATA + item.name);
        }
        var normalizedName = normalize(item.name);
        unicode[normalizedName] = item;
        if (typePrefix) {
          unicodeTypes[typePrefix][normalizedName] = true;
        }
        if (item.alias) {
          var normalizedAlias = normalize(item.alias);
          unicode[normalizedAlias] = item;
          if (typePrefix) {
            unicodeTypes[typePrefix][normalizedAlias] = true;
          }
        }
      }

      // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
      // flags might now produce different results
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    XRegExp.cache.flush(&#039;patterns&#039;);
  };

  /**
   * @ignore
   *
   * Return a reference to the internal Unicode definition structure for the given Unicode
   * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
   * constructs.
   *
   * @memberOf XRegExp
   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),
   *   e.g. `&#039;N&#039;` or `&#039;Number&#039;`. The given name is matched against all registered Unicode
   *   Properties and Property Aliases.
   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.
   *
   * @note
   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.
   *
   * @note
   * This method is *not* part of the officially documented API and may change or be removed in
   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode
   * structures set up by XRegExp.
   */
  XRegExp._getUnicodeProperty = function (name) {
    var slug = normalize(name);
    return unicode[slug];
  };
};
module.exports = exports.default;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
