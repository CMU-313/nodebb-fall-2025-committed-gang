<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/authentication.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/authentication.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">560</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.48</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;


const assert = require(&#039;assert&#039;);
const url = require(&#039;url&#039;);
const nconf = require(&#039;nconf&#039;);

const request = require(&#039;../src/request&#039;);
const db = require(&#039;./mocks/databasemock&#039;);
const user = require(&#039;../src/user&#039;);
const utils = require(&#039;../src/utils&#039;);
const meta = require(&#039;../src/meta&#039;);
const plugins = require(&#039;../src/plugins&#039;);
const privileges = require(&#039;../src/privileges&#039;);
const api = require(&#039;../src/api&#039;);
const helpers = require(&#039;./helpers&#039;);

describe(&#039;authentication&#039;, () =&gt; {
	const jar = request.jar();
	let regularUid;
	const dummyEmailerHook = async (data) =&gt; {};

	before((done) =&gt; {
		// Attach an emailer hook so related requests do not error
		plugins.hooks.register(&#039;authentication-test&#039;, {
			hook: &#039;static:email.send&#039;,
			method: dummyEmailerHook,
		});

		user.create({ username: &#039;regular&#039;, password: &#039;regularpwd&#039;, email: &#039;regular@nodebb.org&#039; }, (err, uid) =&gt; {
			assert.ifError(err);
			regularUid = uid;
			assert.strictEqual(uid, 1);
			done();
		});
	});

	after(() =&gt; {
		plugins.hooks.unregister(&#039;authentication-test&#039;, &#039;static:email.send&#039;);
	});

	it(&#039;should allow login with email for uid 1&#039;, async () =&gt; {
		const oldValue = meta.config.allowLoginWith;
		meta.config.allowLoginWith = &#039;username-email&#039;;
		const { response } = await helpers.loginUser(&#039;regular@nodebb.org&#039;, &#039;regularpwd&#039;);
		assert.strictEqual(response.statusCode, 200);
		meta.config.allowLoginWith = oldValue;
	});

	it(&#039;second user should fail to login with email since email is not confirmed&#039;, async () =&gt; {
		const oldValue = meta.config.allowLoginWith;
		meta.config.allowLoginWith = &#039;username-email&#039;;
		const uid = await user.create({ username: &#039;2nduser&#039;, password: &#039;2ndpassword&#039;, email: &#039;2nduser@nodebb.org&#039; });
		const { response, body } = await helpers.loginUser(&#039;2nduser@nodebb.org&#039;, &#039;2ndpassword&#039;);
		assert.strictEqual(response.statusCode, 403);
		assert.strictEqual(body, &#039;[[error:invalid-login-credentials]]&#039;);
		meta.config.allowLoginWith = oldValue;
	});

	it(&#039;should fail to create user if username is too short&#039;, async () =&gt; {
		const { response, body } = await helpers.registerUser({
			username: &#039;a&#039;,
			password: &#039;123456&#039;,
		});
		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[error:username-too-short]]&#039;);
	});

	it(&#039;should fail to create user if userslug is too short&#039;, async () =&gt; {
		const { response, body } = await helpers.registerUser({
			username: &#039;----a-----&#039;,
			password: &#039;123456&#039;,
		});
		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[error:username-too-short]]&#039;);
	});

	it(&#039;should fail to create user if userslug is too short&#039;, async () =&gt; {
		const { response, body } = await helpers.registerUser({
			username: &#039;     a&#039;,
			password: &#039;123456&#039;,
		});
		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[error:username-too-short]]&#039;);
	});

	it(&#039;should fail to create user if userslug is too short&#039;, async () =&gt; {
		const { response, body } = await helpers.registerUser({
			username: &#039;a      &#039;,
			password: &#039;123456&#039;,
		});
		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[error:username-too-short]]&#039;);
	});

	it(&#039;should register and login a user&#039;, async () =&gt; {
		const jar = request.jar();
		const csrf_token = await helpers.getCsrfToken(jar);

		const { body } = await request.post(`${nconf.get(&#039;url&#039;)}/register`, {
			jar,
			body: {
				email: &#039;admin@nodebb.org&#039;,
				username: &#039;admin&#039;,
				password: &#039;adminpwd&#039;,
				&#039;password-confirm&#039;: &#039;adminpwd&#039;,
				userLang: &#039;it&#039;,
				gdpr_consent: true,
			},
			headers: {
				&#039;x-csrf-token&#039;: csrf_token,
			},
		});

		const validationPending = await user.email.isValidationPending(body.uid, &#039;admin@nodebb.org&#039;);
		assert.strictEqual(validationPending, true);

		assert(body);
		assert(body.hasOwnProperty(&#039;uid&#039;) &amp;&amp; body.uid &gt; 0);
		const newUid = body.uid;
		const { body: self } = await request.get(`${nconf.get(&#039;url&#039;)}/api/self`, {
			jar,
		});
		assert(self);
		assert.equal(self.username, &#039;admin&#039;);
		assert.equal(self.uid, newUid);
		const settings = await user.getSettings(body.uid);
		assert.equal(settings.userLang, &#039;it&#039;);
	});

	it(&#039;should logout a user&#039;, async () =&gt; {
		await helpers.logoutUser(jar);

		const { response, body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/me`, {
			jar: jar,
		});
		assert.equal(response.statusCode, 401);
		assert.strictEqual(body.status.code, &#039;not-authorised&#039;);
	});

	it(&#039;should regenerate the session identifier on successful login&#039;, async () =&gt; {
		const matchRegexp = /express\.sid=s%3A(.+?);/;
		const { hostname, path } = url.parse(nconf.get(&#039;url&#039;));
		const sid = String(jar.store.idx[hostname][path][&#039;express.sid&#039;]).match(matchRegexp)[1];
		await helpers.logoutUser(jar);
		const newJar = (await helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;)).jar;
		const newSid = String(newJar.store.idx[hostname][path][&#039;express.sid&#039;]).match(matchRegexp)[1];

		assert.notStrictEqual(newSid, sid);
	});


	it(&#039;should revoke all sessions&#039;, async () =&gt; {
		const socketAdmin = require(&#039;../src/socket.io/admin&#039;);
		let sessionCount = await db.sortedSetCard(`uid:${regularUid}:sessions`);
		assert(sessionCount);
		await socketAdmin.deleteAllSessions({ uid: 1 }, {});
		sessionCount = await db.sortedSetCard(`uid:${regularUid}:sessions`);
		assert(!sessionCount);
	});

	describe(&#039;login&#039;, () =&gt; {
		let username;
		let password;
		let uid;

		function getCookieExpiry(response) {
			const { headers } = response;
			assert(headers[&#039;set-cookie&#039;]);
			assert.strictEqual(headers[&#039;set-cookie&#039;].includes(&#039;Expires&#039;), true);

			const values = headers[&#039;set-cookie&#039;].split(&#039;;&#039;);
			return values.reduce((memo, cur) =&gt; {
				if (!memo) {
					const [name, value] = cur.split(&#039;=&#039;);
					if (name === &#039; Expires&#039;) {
						memo = new Date(value);
					}
				}

				return memo;
			}, undefined);
		}

		beforeEach(async () =&gt; {
			([username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()]);
			uid = await user.create({ username, password });
		});

		it(&#039;should login a user&#039;, async () =&gt; {
			const { jar, body: loginBody } = await helpers.loginUser(username, password);
			assert(loginBody);
			const { body } = await request.get(`${nconf.get(&#039;url&#039;)}/api/self`, {
				jar,
			});
			assert(body);
			assert.equal(body.username, username);
			const sessions = await db.getSortedSetRange(`uid:${uid}:sessions`, 0, -1);
			assert(sessions);
			assert(Object.keys(sessions).length &gt; 0);
		});

		it(&#039;should set a cookie that only lasts for the life of the browser session&#039;, async () =&gt; {
			const { response } = await helpers.loginUser(username, password);

			assert(response.headers);
			assert(response.headers[&#039;set-cookie&#039;]);
			assert.strictEqual(response.headers[&#039;set-cookie&#039;].includes(&#039;Expires&#039;), false);
		});

		it(&#039;should set a different expiry if sessionDuration is set&#039;, async () =&gt; {
			const _sessionDuration = meta.config.sessionDuration;
			const days = 1;
			meta.config.sessionDuration = days * 24 * 60 * 60;

			const { response } = await helpers.loginUser(username, password);

			const expiry = getCookieExpiry(response);
			const expected = new Date();
			expected.setUTCDate(expected.getUTCDate() + days);

			assert.strictEqual(expiry.getUTCDate(), expected.getUTCDate());

			meta.config.sessionDuration = _sessionDuration;
		});

		it(&#039;should set a cookie that lasts for x days where x is loginDays setting, if asked to remember&#039;, async () =&gt; {
			const { response } = await helpers.loginUser(username, password, { remember: &#039;on&#039; });

			const expiry = getCookieExpiry(response);
			const expected = new Date();
			expected.setUTCDate(expected.getUTCDate() + meta.config.loginDays);

			assert.strictEqual(expiry.getUTCDate(), expected.getUTCDate());
		});

		it(&#039;should set the cookie expiry properly if loginDays setting is changed&#039;, async () =&gt; {
			const _loginDays = meta.config.loginDays;
			meta.config.loginDays = 5;

			const { response } = await helpers.loginUser(username, password, { remember: &#039;on&#039; });

			const expiry = getCookieExpiry(response);
			const expected = new Date();
			expected.setUTCDate(expected.getUTCDate() + meta.config.loginDays);

			assert.strictEqual(expiry.getUTCDate(), expected.getUTCDate());

			meta.config.loginDays = _loginDays;
		});

		it(&#039;should ignore loginDays if loginSeconds is truthy&#039;, async () =&gt; {
			const _loginSeconds = meta.config.loginSeconds;
			meta.config.loginSeconds = 60;

			const { response } = await helpers.loginUser(username, password, { remember: &#039;on&#039; });

			const expiry = getCookieExpiry(response);
			const expected = new Date();
			expected.setUTCSeconds(expected.getUTCSeconds() + meta.config.loginSeconds);

			assert.strictEqual(expiry.getUTCDate(), expected.getUTCDate());
			assert.strictEqual(expiry.getUTCMinutes(), expected.getUTCMinutes());

			meta.config.loginSeconds = _loginSeconds;
		});
	});

	it(&#039;should fail to login if ip address is invalid&#039;, async () =&gt; {
		const jar = request.jar();
		const csrf_token = await helpers.getCsrfToken(jar);

		const { response } = await request.post(`${nconf.get(&#039;url&#039;)}/login`, {
			body: {
				username: &#039;regular&#039;,
				password: &#039;regularpwd&#039;,
			},
			jar: jar,
			headers: {
				&#039;x-csrf-token&#039;: csrf_token,
				&#039;x-forwarded-for&#039;: &#039;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#039;,
			},
		});
		assert.equal(response.status, 500);
	});

	it(&#039;should fail to login if user does not exist&#039;, async () =&gt; {
		const { response, body } = await helpers.loginUser(&#039;doesnotexist&#039;, &#039;nopassword&#039;);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:invalid-login-credentials]]&#039;);
	});

	it(&#039;should fail to login if username is empty&#039;, async () =&gt; {
		const { response, body } = await helpers.loginUser(&#039;&#039;, &#039;some password&#039;);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:invalid-username-or-password]]&#039;);
	});

	it(&#039;should fail to login if password is empty&#039;, async () =&gt; {
		const { response, body } = await helpers.loginUser(&#039;someuser&#039;, &#039;&#039;);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:invalid-username-or-password]]&#039;);
	});

	it(&#039;should fail to login if username and password are empty&#039;, async () =&gt; {
		const { response, body } = await helpers.loginUser(&#039;&#039;, &#039;&#039;);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:invalid-username-or-password]]&#039;);
	});

	it(&#039;should fail to login if user does not have password field in db&#039;, async () =&gt; {
		await user.create({ username: &#039;hasnopassword&#039;, email: &#039;no@pass.org&#039; });
		const { response, body } = await helpers.loginUser(&#039;hasnopassword&#039;, &#039;doesntmatter&#039;);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:invalid-login-credentials]]&#039;);
	});

	it(&#039;should fail to login if password is longer than 4096&#039;, async () =&gt; {
		let longPassword = &#039;&#039;;
		for (let i = 0; i &lt; 5000; i++) {
			longPassword += &#039;a&#039;;
		}
		const { response, body } = await helpers.loginUser(&#039;someuser&#039;, longPassword);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:password-too-long]]&#039;);
	});

	it(&#039;should fail to login if local login is disabled&#039;, async () =&gt; {
		await privileges.global.rescind([&#039;groups:local:login&#039;], &#039;registered-users&#039;);
		const { response, body } = await helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;);
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;[[error:local-login-disabled]]&#039;);
		await privileges.global.give([&#039;groups:local:login&#039;], &#039;registered-users&#039;);
	});

	it(&#039;should fail to register if registraton is disabled&#039;, async () =&gt; {
		meta.config.registrationType = &#039;disabled&#039;;
		const { response, body } = await helpers.registerUser({
			username: &#039;someuser&#039;,
			password: &#039;somepassword&#039;,
		});
		assert.equal(response.statusCode, 403);
		assert.equal(body, &#039;Forbidden&#039;);
	});

	it(&#039;should return error if invitation is not valid&#039;, async () =&gt; {
		meta.config.registrationType = &#039;invite-only&#039;;
		const { response, body } = await helpers.registerUser({
			username: &#039;someuser&#039;,
			password: &#039;somepassword&#039;,
		});
		meta.config.registrationType = &#039;normal&#039;;
		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[register:invite.error-invite-only]]&#039;);
	});

	it(&#039;should fail to register if username is falsy or too short&#039;, async () =&gt; {
		const userData = [
			{ username: &#039;&#039;, password: &#039;somepassword&#039; },
			{ username: &#039;a&#039;, password: &#039;somepassword&#039; },
		];
		for (const user of userData) {
			// eslint-disable-next-line no-await-in-loop
			const { response, body } = await helpers.registerUser(user);
			assert.equal(response.statusCode, 400);
			assert.equal(body, &#039;[[error:username-too-short]]&#039;);
		}
	});

	it(&#039;should fail to register if username is too long&#039;, async () =&gt; {
		const { response, body } = await helpers.registerUser({
			username: &#039;thisisareallylongusername&#039;,
			password: &#039;123456&#039;,
		});

		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[error:username-too-long]]&#039;);
	});

	it(&#039;should queue user if ip is used before&#039;, async () =&gt; {
		meta.config.registrationApprovalType = &#039;admin-approval-ip&#039;;
		const { response, body } = await helpers.registerUser({
			email: &#039;another@user.com&#039;,
			username: &#039;anotheruser&#039;,
			password: &#039;anotherpwd&#039;,
			gdpr_consent: 1,
		});
		meta.config.registrationApprovalType = &#039;normal&#039;;
		assert.equal(response.statusCode, 200);
		assert.equal(body.message, &#039;[[register:registration-added-to-queue]]&#039;);
	});


	it(&#039;should be able to login with email&#039;, async () =&gt; {
		const email = &#039;ginger@nodebb.org&#039;;
		const uid = await user.create({ username: &#039;ginger&#039;, password: &#039;123456&#039;, email });
		await user.setUserField(uid, &#039;email&#039;, email);
		await user.email.confirmByUid(uid);
		const { response } = await helpers.loginUser(&#039;ginger@nodebb.org&#039;, &#039;123456&#039;);
		assert.equal(response.statusCode, 200);
	});

	it(&#039;should fail to login if login type is username and an email is sent&#039;, async () =&gt; {
		meta.config.allowLoginWith = &#039;username&#039;;
		const { response, body } = await helpers.loginUser(&#039;ginger@nodebb.org&#039;, &#039;123456&#039;);
		meta.config.allowLoginWith = &#039;username-email&#039;;
		assert.equal(response.statusCode, 400);
		assert.equal(body, &#039;[[error:wrong-login-type-username]]&#039;);
	});

	it(&#039;should send 200 if not logged in&#039;, async () =&gt; {
		const jar = request.jar();
		const csrf_token = await helpers.getCsrfToken(jar);

		const { response, body } = await request.post(`${nconf.get(&#039;url&#039;)}/logout`, {
			data: {},
			jar: jar,
			headers: {
				&#039;x-csrf-token&#039;: csrf_token,
			},
		});

		assert.equal(response.statusCode, 200);
		assert.equal(body, &#039;not-logged-in&#039;);
	});

	describe(&#039;banned user authentication&#039;, () =&gt; {
		const bannedUser = {
			username: &#039;banme&#039;,
			pw: &#039;123456&#039;,
			uid: null,
		};

		before(async () =&gt; {
			bannedUser.uid = await user.create({ username: &#039;banme&#039;, password: &#039;123456&#039;, email: &#039;ban@me.com&#039; });
		});

		it(&#039;should prevent banned user from logging in&#039;, async () =&gt; {
			await user.bans.ban(bannedUser.uid, 0, &#039;spammer&#039;);
			const { response: res1, body: body1 } = await helpers.loginUser(bannedUser.username, bannedUser.pw);
			assert.equal(res1.statusCode, 403);
			delete body1.timestamp;
			assert.deepStrictEqual(body1, {
				banned_until: 0,
				banned_until_readable: &#039;&#039;,
				expiry: 0,
				expiry_readable: &#039;&#039;,
				reason: &#039;spammer&#039;,
				uid: bannedUser.uid,
			});
			await user.bans.unban(bannedUser.uid);
			const expiry = Date.now() + 10000;
			await user.bans.ban(bannedUser.uid, expiry, &#039;&#039;);
			const { response: res2, body: body2 } = await helpers.loginUser(bannedUser.username, bannedUser.pw);
			assert.equal(res2.statusCode, 403);
			assert(body2.banned_until);
			assert(body2.reason, &#039;[[user:info.banned-no-reason]]&#039;);
		});

		it(&#039;should allow banned user to log in if the &quot;banned-users&quot; group has &quot;local-login&quot; privilege&#039;, async () =&gt; {
			await privileges.global.give([&#039;groups:local:login&#039;], &#039;banned-users&#039;);
			const { response } = await helpers.loginUser(bannedUser.username, bannedUser.pw);
			assert.strictEqual(response.statusCode, 200);
		});

		it(&#039;should allow banned user to log in if the user herself has &quot;local-login&quot; privilege&#039;, async () =&gt; {
			await privileges.global.rescind([&#039;groups:local:login&#039;], &#039;banned-users&#039;);
			await privileges.categories.give([&#039;local:login&#039;], 0, bannedUser.uid);
			const { response } = await helpers.loginUser(bannedUser.username, bannedUser.pw);
			assert.strictEqual(response.statusCode, 200);
		});
	});

	it(&#039;should lockout account on 3 failed login attempts&#039;, async () =&gt; {
		meta.config.loginAttempts = 3;
		const uid = await user.create({ username: &#039;lockme&#039;, password: &#039;123456&#039; });
		await helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;);
		await helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;);
		await helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;);
		let data = await helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;);

		meta.config.loginAttempts = 5;
		assert.equal(data.response.statusCode, 403);
		assert.equal(data.body, &#039;[[error:account-locked]]&#039;);
		data = await helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;);
		assert.equal(data.response.statusCode, 403);
		assert.equal(data.body, &#039;[[error:account-locked]]&#039;);
		const locked = await db.exists(`lockout:${uid}`);
		assert(locked);
	});

	it(&#039;should clear all reset tokens upon successful login&#039;, async () =&gt; {
		const code = await user.reset.generate(regularUid);
		await helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;);
		const valid = await user.reset.validate(code);
		assert.strictEqual(valid, false);
	});

	describe(&#039;api tokens&#039;, () =&gt; {
		let newUid;
		let userToken;
		let masterToken;
		before(async () =&gt; {
			newUid = await user.create({ username: &#039;apiUserTarget&#039; });
			userToken = await api.utils.tokens.generate({
				uid: newUid,
				description: `api token for uid ${newUid}`,
			});
			masterToken = await api.utils.tokens.generate({
				uid: 0,
				description: &#039;api master token&#039;,
			});
		});

		it(&#039;should fail with invalid token&#039;, async () =&gt; {
			const { response, body } = await helpers.request(&#039;get&#039;, `/api/self?_uid${newUid}`, {
				jar: jar,
				headers: {
					Authorization: `Bearer sdfhaskfdja-jahfdaksdf`,
				},
			});
			assert.strictEqual(response.statusCode, 401);
			assert.strictEqual(body, &#039;not-authorized&#039;);
		});

		it(&#039;should use a token tied to an uid&#039;, async () =&gt; {
			const { response, body } = await helpers.request(&#039;get&#039;, `/api/self`, {
				headers: {
					Authorization: `Bearer ${userToken}`,
				},
			});

			assert.strictEqual(response.statusCode, 200);
			assert.strictEqual(body.username, &#039;apiUserTarget&#039;);
		});

		it(&#039;should fail if _uid is not passed in with master token&#039;, async () =&gt; {
			const { response, body } = await helpers.request(&#039;get&#039;, `/api/self`, {
				headers: {
					Authorization: `Bearer ${masterToken}`,
				},
			});

			assert.strictEqual(response.statusCode, 500);
			assert.strictEqual(body.error, &#039;[[error:api.master-token-no-uid]]&#039;);
		});

		it(&#039;should use master api token and _uid&#039;, async () =&gt; {
			const { response, body } = await helpers.request(&#039;get&#039;, `/api/self?_uid=${newUid}`, {
				headers: {
					Authorization: `Bearer ${masterToken}`,
				},
			});

			assert.strictEqual(response.statusCode, 200);
			assert.strictEqual(body.username, &#039;apiUserTarget&#039;);
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
