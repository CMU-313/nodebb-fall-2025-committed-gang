<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ajv/dist/core.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ajv/dist/core.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">618</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">92.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.31</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
var validate_1 = require(&quot;./compile/validate&quot;);
Object.defineProperty(exports, &quot;KeywordCxt&quot;, { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
var codegen_1 = require(&quot;./compile/codegen&quot;);
Object.defineProperty(exports, &quot;_&quot;, { enumerable: true, get: function () { return codegen_1._; } });
Object.defineProperty(exports, &quot;str&quot;, { enumerable: true, get: function () { return codegen_1.str; } });
Object.defineProperty(exports, &quot;stringify&quot;, { enumerable: true, get: function () { return codegen_1.stringify; } });
Object.defineProperty(exports, &quot;nil&quot;, { enumerable: true, get: function () { return codegen_1.nil; } });
Object.defineProperty(exports, &quot;Name&quot;, { enumerable: true, get: function () { return codegen_1.Name; } });
Object.defineProperty(exports, &quot;CodeGen&quot;, { enumerable: true, get: function () { return codegen_1.CodeGen; } });
const validation_error_1 = require(&quot;./runtime/validation_error&quot;);
const ref_error_1 = require(&quot;./compile/ref_error&quot;);
const rules_1 = require(&quot;./compile/rules&quot;);
const compile_1 = require(&quot;./compile&quot;);
const codegen_2 = require(&quot;./compile/codegen&quot;);
const resolve_1 = require(&quot;./compile/resolve&quot;);
const dataType_1 = require(&quot;./compile/validate/dataType&quot;);
const util_1 = require(&quot;./compile/util&quot;);
const $dataRefSchema = require(&quot;./refs/data.json&quot;);
const uri_1 = require(&quot;./runtime/uri&quot;);
const defaultRegExp = (str, flags) =&gt; new RegExp(str, flags);
defaultRegExp.code = &quot;new RegExp&quot;;
const META_IGNORE_OPTIONS = [&quot;removeAdditional&quot;, &quot;useDefaults&quot;, &quot;coerceTypes&quot;];
const EXT_SCOPE_NAMES = new Set([
    &quot;validate&quot;,
    &quot;serialize&quot;,
    &quot;parse&quot;,
    &quot;wrapper&quot;,
    &quot;root&quot;,
    &quot;schema&quot;,
    &quot;keyword&quot;,
    &quot;pattern&quot;,
    &quot;formats&quot;,
    &quot;validate$data&quot;,
    &quot;func&quot;,
    &quot;obj&quot;,
    &quot;Error&quot;,
]);
const removedOptions = {
    errorDataPath: &quot;&quot;,
    format: &quot;`validateFormats: false` can be used instead.&quot;,
    nullable: &#039;&quot;nullable&quot; keyword is supported by default.&#039;,
    jsonPointers: &quot;Deprecated jsPropertySyntax can be used instead.&quot;,
    extendRefs: &quot;Deprecated ignoreKeywordsWithRef can be used instead.&quot;,
    missingRefs: &quot;Pass empty schema with $id that should be ignored to ajv.addSchema.&quot;,
    processCode: &quot;Use option `code: {process: (code, schemaEnv: object) =&gt; string}`&quot;,
    sourceCode: &quot;Use option `code: {source: true}`&quot;,
    strictDefaults: &quot;It is default now, see option `strict`.&quot;,
    strictKeywords: &quot;It is default now, see option `strict`.&quot;,
    uniqueItems: &#039;&quot;uniqueItems&quot; keyword is always validated.&#039;,
    unknownFormats: &quot;Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).&quot;,
    cache: &quot;Map is used as cache, schema object as key.&quot;,
    serialize: &quot;Map is used as cache, schema object as key.&quot;,
    ajvErrors: &quot;It is default now.&quot;,
};
const deprecatedOptions = {
    ignoreKeywordsWithRef: &quot;&quot;,
    jsPropertySyntax: &quot;&quot;,
    unicode: &#039;&quot;minLength&quot;/&quot;maxLength&quot; account for unicode characters by default.&#039;,
};
const MAX_EXPRESSION = 200;
// eslint-disable-next-line complexity
function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null &amp;&amp; _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null &amp;&amp; _d !== void 0 ? _d : uri_1.default;
    return {
        strictSchema: (_f = (_e = o.strictSchema) !== null &amp;&amp; _e !== void 0 ? _e : s) !== null &amp;&amp; _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null &amp;&amp; _g !== void 0 ? _g : s) !== null &amp;&amp; _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null &amp;&amp; _j !== void 0 ? _j : s) !== null &amp;&amp; _k !== void 0 ? _k : &quot;log&quot;,
        strictTuples: (_m = (_l = o.strictTuples) !== null &amp;&amp; _l !== void 0 ? _l : s) !== null &amp;&amp; _m !== void 0 ? _m : &quot;log&quot;,
        strictRequired: (_p = (_o = o.strictRequired) !== null &amp;&amp; _o !== void 0 ? _o : s) !== null &amp;&amp; _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null &amp;&amp; _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null &amp;&amp; _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null &amp;&amp; _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null &amp;&amp; _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null &amp;&amp; _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null &amp;&amp; _v !== void 0 ? _v : &quot;$id&quot;,
        addUsedSchema: (_w = o.addUsedSchema) !== null &amp;&amp; _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null &amp;&amp; _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null &amp;&amp; _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null &amp;&amp; _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null &amp;&amp; _0 !== void 0 ? _0 : true,
        uriResolver: uriResolver,
    };
}
class Ajv {
    constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = new Set();
        this._loading = {};
        this._cache = new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, &quot;NOT SUPPORTED&quot;);
        checkOptions.call(this, deprecatedOptions, opts, &quot;DEPRECATED&quot;, &quot;warn&quot;);
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == &quot;object&quot;)
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
        this.addKeyword(&quot;$async&quot;);
    }
    _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === &quot;id&quot;) {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
        }
        if (meta &amp;&amp; $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
        const { meta, schemaId } = this.opts;
        return (this.opts.defaultMeta = typeof meta == &quot;object&quot; ? meta[schemaId] || meta : undefined);
    }
    validate(schemaKeyRef, // key, ref or schema object
    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
    data // to be validated
    ) {
        let v;
        if (typeof schemaKeyRef == &quot;string&quot;) {
            v = this.getSchema(schemaKeyRef);
            if (!v)
                throw new Error(`no schema with key or ref &quot;${schemaKeyRef}&quot;`);
        }
        else {
            v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!(&quot;$async&quot; in v))
            this.errors = v.errors;
        return valid;
    }
    compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != &quot;function&quot;) {
            throw new Error(&quot;options.loadSchema should be a function&quot;);
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
            if ($ref &amp;&amp; !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
            }
        }
        async function _compileAsync(sch) {
            try {
                return this._compileSchemaEnv(sch);
            }
            catch (e) {
                if (!(e instanceof ref_error_1.default))
                    throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
            }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
        }
        async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
                await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
            const p = this._loading[ref];
            if (p)
                return p;
            try {
                return await (this._loading[ref] = loadSchema(ref));
            }
            finally {
                delete this._loading[ref];
            }
        }
    }
    // Adds schema to the instance
    addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    ) {
        if (Array.isArray(schema)) {
            for (const sch of schema)
                this.addSchema(sch, undefined, _meta, _validateSchema);
            return this;
        }
        let id;
        if (typeof schema === &quot;object&quot;) {
            const { schemaId } = this.opts;
            id = schema[schemaId];
            if (id !== undefined &amp;&amp; typeof id != &quot;string&quot;) {
                throw new Error(`schema ${schemaId} must be string`);
            }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, // schema key
    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    ) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
        if (typeof schema == &quot;boolean&quot;)
            return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== undefined &amp;&amp; typeof $schema != &quot;string&quot;) {
            throw new Error(&quot;$schema must be a string&quot;);
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
            this.logger.warn(&quot;meta-schema not available&quot;);
            this.errors = null;
            return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid &amp;&amp; throwOrLogError) {
            const message = &quot;schema is invalid: &quot; + this.errorsText();
            if (this.opts.validateSchema === &quot;log&quot;)
                this.logger.error(message);
            else
                throw new Error(message);
        }
        return valid;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == &quot;string&quot;)
            keyRef = sch;
        if (sch === undefined) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
                return;
            this.refs[keyRef] = sch;
        }
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
        }
        switch (typeof schemaKeyRef) {
            case &quot;undefined&quot;:
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
            case &quot;string&quot;: {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == &quot;object&quot;)
                    this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
            }
            case &quot;object&quot;: {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id = schemaKeyRef[this.opts.schemaId];
                if (id) {
                    id = (0, resolve_1.normalizeId)(id);
                    delete this.schemas[id];
                    delete this.refs[id];
                }
                return this;
            }
            default:
                throw new Error(&quot;ajv.removeSchema: invalid parameter&quot;);
        }
    }
    // add &quot;vocabulary&quot; - a collection of keywords
    addVocabulary(definitions) {
        for (const def of definitions)
            this.addKeyword(def);
        return this;
    }
    addKeyword(kwdOrDef, def // deprecated
    ) {
        let keyword;
        if (typeof kwdOrDef == &quot;string&quot;) {
            keyword = kwdOrDef;
            if (typeof def == &quot;object&quot;) {
                this.logger.warn(&quot;these parameters are deprecated, see docs for addKeyword&quot;);
                def.keyword = keyword;
            }
        }
        else if (typeof kwdOrDef == &quot;object&quot; &amp;&amp; def === undefined) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) &amp;&amp; !keyword.length) {
                throw new Error(&quot;addKeywords: keyword must be string or non-empty array&quot;);
            }
        }
        else {
            throw new Error(&quot;invalid addKeywords parameters&quot;);
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
            (0, util_1.eachItem)(keyword, (kwd) =&gt; addRule.call(this, kwd));
            return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
            ...def,
            type: (0, dataType_1.getJSONTypes)(def.type),
            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0
            ? (k) =&gt; addRule.call(this, k, definition)
            : (k) =&gt; definition.type.forEach((t) =&gt; addRule.call(this, k, definition, t)));
        return this;
    }
    getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == &quot;object&quot; ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword) {
        // TODO return type should be Ajv
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) =&gt; rule.keyword === keyword);
            if (i &gt;= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, format) {
        if (typeof format == &quot;string&quot;)
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors = this.errors, // optional array of validation errors
    { separator = &quot;, &quot;, dataVar = &quot;data&quot; } = {} // optional options with properties `separator` and `dataVar`
    ) {
        if (!errors || errors.length === 0)
            return &quot;No errors&quot;;
        return errors
            .map((e) =&gt; `${dataVar}${e.instancePath} ${e.message}`)
            .reduce((text, msg) =&gt; text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split(&quot;/&quot;).slice(1); // first segment is an empty string
            let keywords = metaSchema;
            for (const seg of segments)
                keywords = keywords[seg];
            for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != &quot;object&quot;)
                    continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data &amp;&amp; schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == &quot;string&quot;) {
                    delete schemas[keyRef];
                }
                else if (sch &amp;&amp; !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == &quot;object&quot;) {
            id = schema[schemaId];
        }
        else {
            if (this.opts.jtd)
                throw new Error(&quot;schema must be object&quot;);
            else if (typeof schema != &quot;boolean&quot;)
                throw new Error(&quot;schema must be object or boolean&quot;);
        }
        let sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema &amp;&amp; !baseId.startsWith(&quot;#&quot;)) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId)
                this._checkUnique(baseId);
            this.refs[baseId] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id &quot;${id}&quot; already exists`);
        }
    }
    _compileSchemaEnv(sch) {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile_1.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new Error(&quot;ajv implementation error&quot;);
        return sch.validate;
    }
    _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
            compile_1.compileSchema.call(this, sch);
        }
        finally {
            this.opts = currentOpts;
        }
    }
}
Ajv.ValidationError = validation_error_1.default;
Ajv.MissingRefError = ref_error_1.default;
exports.default = Ajv;
function checkOptions(checkOpts, options, msg, log = &quot;error&quot;) {
    for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
}
function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
    return this.schemas[keyRef] || this.refs[keyRef];
}
function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
        return;
    if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
    else
        for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
}
function addInitialFormats() {
    for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
            this.addFormat(name, format);
    }
}
function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
    }
    this.logger.warn(&quot;keywords option as map is deprecated, pass array&quot;);
    for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
            def.keyword = keyword;
        this.addKeyword(def);
    }
}
function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
    return metaOpts;
}
const noLogs = { log() { }, warn() { }, error() { } };
function getLogger(logger) {
    if (logger === false)
        return noLogs;
    if (logger === undefined)
        return console;
    if (logger.log &amp;&amp; logger.warn &amp;&amp; logger.error)
        return logger;
    throw new Error(&quot;logger must implement log, warn and error methods&quot;);
}
const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) =&gt; {
        if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
        return;
    if (def.$data &amp;&amp; !(&quot;code&quot; in def || &quot;validate&quot; in def)) {
        throw new Error(&#039;$data keyword must have &quot;code&quot; or &quot;validate&quot; function&#039;);
    }
}
function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType &amp;&amp; post)
        throw new Error(&#039;keyword with &quot;post&quot; flag cannot have &quot;type&quot;&#039;);
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) =&gt; t === dataType);
    if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
        return;
    const rule = {
        keyword,
        definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
        },
    };
    if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
        ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) =&gt; this.addKeyword(kwd));
}
function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) =&gt; _rule.keyword === before);
    if (i &gt;= 0) {
        ruleGroup.rules.splice(i, 0, rule);
    }
    else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
    }
}
function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
        return;
    if (def.$data &amp;&amp; this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
}
const $dataRef = {
    $ref: &quot;https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#&quot;,
};
function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
}
//# sourceMappingURL=core.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
