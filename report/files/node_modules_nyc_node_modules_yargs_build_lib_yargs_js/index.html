<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nyc/node_modules/yargs/build/lib/yargs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nyc/node_modules/yargs/build/lib/yargs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1191</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">127.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">15.92</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.isYargsInstance = exports.rebase = exports.Yargs = void 0;
const command_1 = require(&quot;./command&quot;);
const common_types_1 = require(&quot;./common-types&quot;);
const yerror_1 = require(&quot;./yerror&quot;);
const usage_1 = require(&quot;./usage&quot;);
const argsert_1 = require(&quot;./argsert&quot;);
const fs = require(&quot;fs&quot;);
const completion_1 = require(&quot;./completion&quot;);
const path = require(&quot;path&quot;);
const validation_1 = require(&quot;./validation&quot;);
const obj_filter_1 = require(&quot;./obj-filter&quot;);
const apply_extends_1 = require(&quot;./apply-extends&quot;);
const middleware_1 = require(&quot;./middleware&quot;);
const processArgv = require(&quot;./process-argv&quot;);
const is_promise_1 = require(&quot;./is-promise&quot;);
const Parser = require(&quot;yargs-parser&quot;);
const y18nFactory = require(&quot;y18n&quot;);
const setBlocking = require(&quot;set-blocking&quot;);
const findUp = require(&quot;find-up&quot;);
const requireMainFilename = require(&quot;require-main-filename&quot;);
function Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {
    const self = {};
    let command;
    let completion = null;
    let groups = {};
    const globalMiddleware = [];
    let output = &#039;&#039;;
    const preservedGroups = {};
    let usage;
    let validation;
    let handlerFinishCommand = null;
    const y18n = y18nFactory({
        directory: path.resolve(__dirname, &#039;../../locales&#039;),
        updateFiles: false
    });
    self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);
    self.scriptName = function (scriptName) {
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
    };
    // ignore the node bin, specify this in your
    // bin file with #!/usr/bin/env node
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(process.argv[0])) {
        default$0 = process.argv.slice(1, 2);
    }
    else {
        default$0 = process.argv.slice(0, 1);
    }
    self.$0 = default$0
        .map(x =&gt; {
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) &amp;&amp; b.length &lt; x.length ? b : x;
    })
        .join(&#039; &#039;).trim();
    if (process.env._ !== undefined &amp;&amp; processArgv.getProcessArgvBin() === process.env._) {
        self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, &#039;&#039;);
    }
    // use context object to keep track of resets, subcommand execution, etc
    // submodules should modify and check the state of context as necessary
    const context = { resets: -1, commands: [], fullCommands: [], files: [] };
    self.getContext = () =&gt; context;
    // puts yargs back into an initial state. any keys
    // that have been set to &quot;global&quot; will not be reset
    // by this action.
    let options;
    self.resetOptions = self.reset = function resetOptions(aliases = {}) {
        context.resets++;
        options = options || {};
        // put yargs back into an initial state, this
        // logic is used to build a nested command
        // hierarchy.
        const tmpOptions = {};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];
        // if a key has been explicitly set as local,
        // we should reset it before passing options to command.
        const localLookup = {};
        tmpOptions.local.forEach((l) =&gt; {
            localLookup[l] = true;
            (aliases[l] || []).forEach((a) =&gt; {
                localLookup[a] = true;
            });
        });
        // add all groups not set to local to preserved groups
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) =&gt; {
            const keys = groups[groupName].filter(key =&gt; !(key in localLookup));
            if (keys.length &gt; 0) {
                acc[groupName] = keys;
            }
            return acc;
        }, {}));
        // groups can now be reset
        groups = {};
        const arrayOptions = [
            &#039;array&#039;, &#039;boolean&#039;, &#039;string&#039;, &#039;skipValidation&#039;,
            &#039;count&#039;, &#039;normalize&#039;, &#039;number&#039;,
            &#039;hiddenOptions&#039;
        ];
        const objectOptions = [
            &#039;narg&#039;, &#039;key&#039;, &#039;alias&#039;, &#039;default&#039;, &#039;defaultDescription&#039;,
            &#039;config&#039;, &#039;choices&#039;, &#039;demandedOptions&#039;, &#039;demandedCommands&#039;, &#039;coerce&#039;,
            &#039;deprecatedOptions&#039;
        ];
        arrayOptions.forEach(k =&gt; {
            tmpOptions[k] = (options[k] || []).filter(k =&gt; !localLookup[k]);
        });
        objectOptions.forEach((k) =&gt; {
            tmpOptions[k] = obj_filter_1.objFilter(options[k], k =&gt; !localLookup[k]);
        });
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        // if this is the first time being executed, create
        // instances of all our helpers -- otherwise just reset.
        usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);
        validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);
        command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);
        if (!completion)
            completion = completion_1.completion(self, usage, command);
        completionCommand = null;
        output = &#039;&#039;;
        exitError = null;
        hasOutput = false;
        self.parsed = false;
        return self;
    };
    self.resetOptions();
    // temporary hack: allow &quot;freezing&quot; of reset-able state for parse(msg, cb)
    const frozens = [];
    function freeze() {
        frozens.push({
            options,
            configObjects: options.configObjects.slice(0),
            exitProcess,
            groups,
            strict,
            strictCommands,
            completionCommand,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            parseFn,
            parseContext,
            handlerFinishCommand
        });
        usage.freeze();
        validation.freeze();
        command.freeze();
    }
    function unfreeze() {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, undefined);
        let configObjects;
        ({
            options,
            configObjects,
            exitProcess,
            groups,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            strict,
            strictCommands,
            completionCommand,
            parseFn,
            parseContext,
            handlerFinishCommand
        } = frozen);
        options.configObjects = configObjects;
        usage.unfreeze();
        validation.unfreeze();
        command.unfreeze();
    }
    self.boolean = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;boolean&#039;, keys);
        return self;
    };
    self.array = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;array&#039;, keys);
        return self;
    };
    self.number = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;number&#039;, keys);
        return self;
    };
    self.normalize = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;normalize&#039;, keys);
        return self;
    };
    self.count = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;count&#039;, keys);
        return self;
    };
    self.string = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;string&#039;, keys);
        return self;
    };
    self.requiresArg = function (keys) {
        // the 2nd paramter [number] in the argsert the assertion is mandatory
        // as populateParserHintSingleValueDictionary recursively calls requiresArg
        // with Nan as a 2nd parameter, although we ignore it
        argsert_1.argsert(&#039;&lt;array|string|object&gt; [number]&#039;, [keys], arguments.length);
        // If someone configures nargs at the same time as requiresArg,
        // nargs should take precedent,
        // see: https://github.com/yargs/yargs/pull/1572
        // TODO: make this work with aliases, using a check similar to
        // checkAllAliases() in yargs-parser.
        if (typeof keys === &#039;string&#039; &amp;&amp; options.narg[keys]) {
            return self;
        }
        else {
            populateParserHintSingleValueDictionary(self.requiresArg, &#039;narg&#039;, keys, NaN);
        }
        return self;
    };
    self.skipValidation = function (keys) {
        argsert_1.argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;skipValidation&#039;, keys);
        return self;
    };
    function populateParserHintArray(type, keys) {
        keys = [].concat(keys);
        keys.forEach((key) =&gt; {
            key = sanitizeKey(key);
            options[type].push(key);
        });
    }
    self.nargs = function (key, value) {
        argsert_1.argsert(&#039;&lt;string|object|array&gt; [number]&#039;, [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self.nargs, &#039;narg&#039;, key, value);
        return self;
    };
    self.choices = function (key, value) {
        argsert_1.argsert(&#039;&lt;object|string|array&gt; [string|array]&#039;, [key, value], arguments.length);
        populateParserHintArrayDictionary(self.choices, &#039;choices&#039;, key, value);
        return self;
    };
    self.alias = function (key, value) {
        argsert_1.argsert(&#039;&lt;object|string|array&gt; [string|array]&#039;, [key, value], arguments.length);
        populateParserHintArrayDictionary(self.alias, &#039;alias&#039;, key, value);
        return self;
    };
    // TODO: actually deprecate self.defaults.
    self.default = self.defaults = function (key, value, defaultDescription) {
        argsert_1.argsert(&#039;&lt;object|string|array&gt; [*] [string]&#039;, [key, value, defaultDescription], arguments.length);
        if (defaultDescription) {
            common_types_1.assertSingleKey(key);
            options.defaultDescription[key] = defaultDescription;
        }
        if (typeof value === &#039;function&#039;) {
            common_types_1.assertSingleKey(key);
            if (!options.defaultDescription[key])
                options.defaultDescription[key] = usage.functionDescription(value);
            value = value.call();
        }
        populateParserHintSingleValueDictionary(self.default, &#039;default&#039;, key, value);
        return self;
    };
    self.describe = function (key, desc) {
        argsert_1.argsert(&#039;&lt;object|string|array&gt; [string]&#039;, [key, desc], arguments.length);
        setKey(key, true);
        usage.describe(key, desc);
        return self;
    };
    function setKey(key, set) {
        populateParserHintSingleValueDictionary(setKey, &#039;key&#039;, key, set);
        return self;
    }
    function demandOption(keys, msg) {
        argsert_1.argsert(&#039;&lt;object|string|array&gt; [string]&#039;, [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self.demandOption, &#039;demandedOptions&#039;, keys, msg);
        return self;
    }
    self.demandOption = demandOption;
    self.coerce = function (keys, value) {
        argsert_1.argsert(&#039;&lt;object|string|array&gt; [function]&#039;, [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self.coerce, &#039;coerce&#039;, keys, value);
        return self;
    };
    function populateParserHintSingleValueDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type, key, value) =&gt; {
            options[type][key] = value;
        });
    }
    function populateParserHintArrayDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type, key, value) =&gt; {
            options[type][key] = (options[type][key] || []).concat(value);
        });
    }
    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
            // an array of keys with one value [&#039;x&#039;, &#039;y&#039;, &#039;z&#039;], function parse () {}
            key.forEach((k) =&gt; {
                builder(k, value);
            });
        }
        else if (((key) =&gt; typeof key === &#039;object&#039;)(key)) {
            // an object of key value pairs: {&#039;x&#039;: parse () {}, &#039;y&#039;: parse() {}}
            for (const k of common_types_1.objectKeys(key)) {
                builder(k, key[k]);
            }
        }
        else {
            singleKeyHandler(type, sanitizeKey(key), value);
        }
    }
    function sanitizeKey(key) {
        if (key === &#039;__proto__&#039;)
            return &#039;___proto___&#039;;
        return key;
    }
    function deleteFromParserHintObject(optionKey) {
        // delete from all parsing hints:
        // boolean, array, key, alias, etc.
        common_types_1.objectKeys(options).forEach((hintKey) =&gt; {
            // configObjects is not a parsing hint array
            if (((key) =&gt; key === &#039;configObjects&#039;)(hintKey))
                return;
            const hint = options[hintKey];
            if (Array.isArray(hint)) {
                if (~hint.indexOf(optionKey))
                    hint.splice(hint.indexOf(optionKey), 1);
            }
            else if (typeof hint === &#039;object&#039;) {
                delete hint[optionKey];
            }
        });
        // now delete the description from usage.js.
        delete usage.getDescriptions()[optionKey];
    }
    self.config = function config(key = &#039;config&#039;, msg, parseFn) {
        argsert_1.argsert(&#039;[object|string] [string|function] [function]&#039;, [key, msg, parseFn], arguments.length);
        // allow a config object to be provided directly.
        if ((typeof key === &#039;object&#039;) &amp;&amp; !Array.isArray(key)) {
            key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()[&#039;deep-merge-config&#039;]);
            options.configObjects = (options.configObjects || []).concat(key);
            return self;
        }
        // allow for a custom parsing function.
        if (typeof msg === &#039;function&#039;) {
            parseFn = msg;
            msg = undefined;
        }
        self.describe(key, msg || usage.deferY18nLookup(&#039;Path to JSON config file&#039;));
        (Array.isArray(key) ? key : [key]).forEach((k) =&gt; {
            options.config[k] = parseFn || true;
        });
        return self;
    };
    self.example = function (cmd, description) {
        argsert_1.argsert(&#039;&lt;string|array&gt; [string]&#039;, [cmd, description], arguments.length);
        if (Array.isArray(cmd)) {
            cmd.forEach((exampleParams) =&gt; self.example(...exampleParams));
        }
        else {
            usage.example(cmd, description);
        }
        return self;
    };
    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {
        argsert_1.argsert(&#039;&lt;string|array|object&gt; [string|boolean] [function|object] [function] [array] [boolean|string]&#039;, [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self;
    };
    self.commandDir = function (dir, opts) {
        argsert_1.argsert(&#039;&lt;string&gt; [object]&#039;, [dir, opts], arguments.length);
        const req = parentRequire || require;
        command.addDirectory(dir, self.getContext(), req, require(&#039;get-caller-file&#039;)(), opts);
        return self;
    };
    // TODO: deprecate self.demand in favor of
    // .demandCommand() .demandOption().
    self.demand = self.required = self.require = function demand(keys, max, msg) {
        // you can optionally provide a &#039;max&#039; key,
        // which will raise an exception if too many &#039;_&#039;
        // options are provided.
        if (Array.isArray(max)) {
            max.forEach((key) =&gt; {
                common_types_1.assertNotStrictEqual(msg, true);
                demandOption(key, msg);
            });
            max = Infinity;
        }
        else if (typeof max !== &#039;number&#039;) {
            msg = max;
            max = Infinity;
        }
        if (typeof keys === &#039;number&#039;) {
            common_types_1.assertNotStrictEqual(msg, true);
            self.demandCommand(keys, max, msg, msg);
        }
        else if (Array.isArray(keys)) {
            keys.forEach((key) =&gt; {
                common_types_1.assertNotStrictEqual(msg, true);
                demandOption(key, msg);
            });
        }
        else {
            if (typeof msg === &#039;string&#039;) {
                demandOption(keys, msg);
            }
            else if (msg === true || typeof msg === &#039;undefined&#039;) {
                demandOption(keys);
            }
        }
        return self;
    };
    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert_1.argsert(&#039;[number] [number|string] [string|null|undefined] [string|null|undefined]&#039;, [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== &#039;number&#039;) {
            minMsg = max;
            max = Infinity;
        }
        self.global(&#039;_&#039;, false);
        options.demandedCommands._ = {
            min,
            max,
            minMsg,
            maxMsg
        };
        return self;
    };
    self.getDemandedOptions = () =&gt; {
        argsert_1.argsert([], 0);
        return options.demandedOptions;
    };
    self.getDemandedCommands = () =&gt; {
        argsert_1.argsert([], 0);
        return options.demandedCommands;
    };
    self.deprecateOption = function deprecateOption(option, message) {
        argsert_1.argsert(&#039;&lt;string&gt; [string|boolean]&#039;, [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self;
    };
    self.getDeprecatedOptions = () =&gt; {
        argsert_1.argsert([], 0);
        return options.deprecatedOptions;
    };
    self.implies = function (key, value) {
        argsert_1.argsert(&#039;&lt;string|object&gt; [number|string|array]&#039;, [key, value], arguments.length);
        validation.implies(key, value);
        return self;
    };
    self.conflicts = function (key1, key2) {
        argsert_1.argsert(&#039;&lt;string|object&gt; [string|array]&#039;, [key1, key2], arguments.length);
        validation.conflicts(key1, key2);
        return self;
    };
    self.usage = function (msg, description, builder, handler) {
        argsert_1.argsert(&#039;&lt;string|null|undefined&gt; [string|boolean] [function|object] [function]&#039;, [msg, description, builder, handler], arguments.length);
        if (description !== undefined) {
            common_types_1.assertNotStrictEqual(msg, null);
            // .usage() can be used as an alias for defining
            // a default command.
            if ((msg || &#039;&#039;).match(/^\$0( |$)/)) {
                return self.command(msg, description, builder, handler);
            }
            else {
                throw new yerror_1.YError(&#039;.usage() description must start with $0 if being used as alias for .command()&#039;);
            }
        }
        else {
            usage.usage(msg);
            return self;
        }
    };
    self.epilogue = self.epilog = function (msg) {
        argsert_1.argsert(&#039;&lt;string&gt;&#039;, [msg], arguments.length);
        usage.epilog(msg);
        return self;
    };
    self.fail = function (f) {
        argsert_1.argsert(&#039;&lt;function&gt;&#039;, [f], arguments.length);
        usage.failFn(f);
        return self;
    };
    self.onFinishCommand = function (f) {
        argsert_1.argsert(&#039;&lt;function&gt;&#039;, [f], arguments.length);
        handlerFinishCommand = f;
        return self;
    };
    self.getHandlerFinishCommand = () =&gt; handlerFinishCommand;
    self.check = function (f, _global) {
        argsert_1.argsert(&#039;&lt;function&gt; [boolean]&#039;, [f, _global], arguments.length);
        validation.check(f, _global !== false);
        return self;
    };
    self.global = function global(globals, global) {
        argsert_1.argsert(&#039;&lt;string|array&gt; [boolean]&#039;, [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
            options.local = options.local.filter(l =&gt; globals.indexOf(l) === -1);
        }
        else {
            globals.forEach((g) =&gt; {
                if (options.local.indexOf(g) === -1)
                    options.local.push(g);
            });
        }
        return self;
    };
    self.pkgConf = function pkgConf(key, rootPath) {
        argsert_1.argsert(&#039;&lt;string&gt; [string]&#039;, [key, rootPath], arguments.length);
        let conf = null;
        // prefer cwd to require-main-filename in this method
        // since we&#039;re looking for e.g. &quot;nyc&quot; config in nyc consumer
        // rather than &quot;yargs&quot; config in nyc (where nyc is the main filename)
        const obj = pkgUp(rootPath || cwd);
        // If an object exists in the key, add it to options.configObjects
        if (obj[key] &amp;&amp; typeof obj[key] === &#039;object&#039;) {
            conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()[&#039;deep-merge-config&#039;]);
            options.configObjects = (options.configObjects || []).concat(conf);
        }
        return self;
    };
    const pkgs = {};
    function pkgUp(rootPath) {
        const npath = rootPath || &#039;*&#039;;
        if (pkgs[npath])
            return pkgs[npath];
        let obj = {};
        try {
            let startDir = rootPath || requireMainFilename(parentRequire);
            // When called in an environment that lacks require.main.filename, such as a jest test runner,
            // startDir is already process.cwd(), and should not be shortened.
            // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.
            if (!rootPath &amp;&amp; path.extname(startDir)) {
                startDir = path.dirname(startDir);
            }
            const pkgJsonPath = findUp.sync(&#039;package.json&#039;, {
                cwd: startDir
            });
            common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);
            obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());
        }
        catch (noop) { }
        pkgs[npath] = obj || {};
        return pkgs[npath];
    }
    let parseFn = null;
    let parseContext = null;
    self.parse = function parse(args, shortCircuit, _parseFn) {
        argsert_1.argsert(&#039;[string|array] [function|boolean|object] [function]&#039;, [args, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args === &#039;undefined&#039;) {
            const argv = self._parseArgs(processArgs);
            const tmpParsed = self.parsed;
            unfreeze();
            // TODO: remove this compatibility hack when we release yargs@15.x:
            self.parsed = tmpParsed;
            return argv;
        }
        // a context object can optionally be provided, this allows
        // additional information to be passed to a command handler.
        if (typeof shortCircuit === &#039;object&#039;) {
            parseContext = shortCircuit;
            shortCircuit = _parseFn;
        }
        // by providing a function as a second argument to
        // parse you can capture output that would otherwise
        // default to printing to stdout/stderr.
        if (typeof shortCircuit === &#039;function&#039;) {
            parseFn = shortCircuit;
            shortCircuit = false;
        }
        // completion short-circuits the parsing process,
        // skipping validation, etc.
        if (!shortCircuit)
            processArgs = args;
        if (parseFn)
            exitProcess = false;
        const parsed = self._parseArgs(args, !!shortCircuit);
        completion.setParsed(self.parsed);
        if (parseFn)
            parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
    };
    self._getParseContext = () =&gt; parseContext || {};
    self._hasParseCallback = () =&gt; !!parseFn;
    self.option = self.options = function option(key, opt) {
        argsert_1.argsert(&#039;&lt;string|object&gt; [object]&#039;, [key, opt], arguments.length);
        if (typeof key === &#039;object&#039;) {
            Object.keys(key).forEach((k) =&gt; {
                self.options(k, key[k]);
            });
        }
        else {
            if (typeof opt !== &#039;object&#039;) {
                opt = {};
            }
            options.key[key] = true; // track manually set keys.
            if (opt.alias)
                self.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) {
                self.deprecateOption(key, deprecate);
            }
            const demand = opt.demand || opt.required || opt.require;
            // A required option can be specified via &quot;demand: true&quot;.
            if (demand) {
                self.demand(key, demand);
            }
            if (opt.demandOption) {
                self.demandOption(key, typeof opt.demandOption === &#039;string&#039; ? opt.demandOption : undefined);
            }
            if (opt.conflicts) {
                self.conflicts(key, opt.conflicts);
            }
            if (&#039;default&#039; in opt) {
                self.default(key, opt.default);
            }
            if (opt.implies !== undefined) {
                self.implies(key, opt.implies);
            }
            if (opt.nargs !== undefined) {
                self.nargs(key, opt.nargs);
            }
            if (opt.config) {
                self.config(key, opt.configParser);
            }
            if (opt.normalize) {
                self.normalize(key);
            }
            if (opt.choices) {
                self.choices(key, opt.choices);
            }
            if (opt.coerce) {
                self.coerce(key, opt.coerce);
            }
            if (opt.group) {
                self.group(key, opt.group);
            }
            if (opt.boolean || opt.type === &#039;boolean&#039;) {
                self.boolean(key);
                if (opt.alias)
                    self.boolean(opt.alias);
            }
            if (opt.array || opt.type === &#039;array&#039;) {
                self.array(key);
                if (opt.alias)
                    self.array(opt.alias);
            }
            if (opt.number || opt.type === &#039;number&#039;) {
                self.number(key);
                if (opt.alias)
                    self.number(opt.alias);
            }
            if (opt.string || opt.type === &#039;string&#039;) {
                self.string(key);
                if (opt.alias)
                    self.string(opt.alias);
            }
            if (opt.count || opt.type === &#039;count&#039;) {
                self.count(key);
            }
            if (typeof opt.global === &#039;boolean&#039;) {
                self.global(key, opt.global);
            }
            if (opt.defaultDescription) {
                options.defaultDescription[key] = opt.defaultDescription;
            }
            if (opt.skipValidation) {
                self.skipValidation(key);
            }
            const desc = opt.describe || opt.description || opt.desc;
            self.describe(key, desc);
            if (opt.hidden) {
                self.hide(key);
            }
            if (opt.requiresArg) {
                self.requiresArg(key);
            }
        }
        return self;
    };
    self.getOptions = () =&gt; options;
    self.positional = function (key, opts) {
        argsert_1.argsert(&#039;&lt;string&gt; &lt;object&gt;&#039;, [key, opts], arguments.length);
        if (context.resets === 0) {
            throw new yerror_1.YError(&quot;.positional() can only be called in a command&#039;s builder function&quot;);
        }
        // .positional() only supports a subset of the configuration
        // options available to .option().
        const supportedOpts = [&#039;default&#039;, &#039;defaultDescription&#039;, &#039;implies&#039;, &#039;normalize&#039;,
            &#039;choices&#039;, &#039;conflicts&#039;, &#039;coerce&#039;, &#039;type&#039;, &#039;describe&#039;,
            &#039;desc&#039;, &#039;description&#039;, &#039;alias&#039;];
        opts = obj_filter_1.objFilter(opts, (k, v) =&gt; {
            let accept = supportedOpts.indexOf(k) !== -1;
            // type can be one of string|number|boolean.
            if (k === &#039;type&#039; &amp;&amp; [&#039;string&#039;, &#039;number&#039;, &#039;boolean&#039;].indexOf(v) === -1)
                accept = false;
            return accept;
        });
        // copy over any settings that can be inferred from the command string.
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {
            array: [],
            alias: {},
            default: {},
            demand: {}
        };
        common_types_1.objectKeys(parseOptions).forEach((pk) =&gt; {
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) {
                if (parseOption.indexOf(key) !== -1)
                    opts[pk] = true;
            }
            else {
                if (parseOption[key] &amp;&amp; !(pk in opts))
                    opts[pk] = parseOption[key];
            }
        });
        self.group(key, usage.getPositionalGroupName());
        return self.option(key, opts);
    };
    self.group = function group(opts, groupName) {
        argsert_1.argsert(&#039;&lt;string|array&gt; &lt;string&gt;&#039;, [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) {
            // we now only need to track this group name in groups.
            delete preservedGroups[groupName];
        }
        const seen = {};
        groups[groupName] = (existing || []).concat(opts).filter((key) =&gt; {
            if (seen[key])
                return false;
            return (seen[key] = true);
        });
        return self;
    };
    // combine explicit and preserved groups. explicit groups should be first
    self.getGroups = () =&gt; Object.assign({}, groups, preservedGroups);
    // as long as options.envPrefix is not undefined,
    // parser will apply env vars matching prefix to argv
    self.env = function (prefix) {
        argsert_1.argsert(&#039;[string|boolean]&#039;, [prefix], arguments.length);
        if (prefix === false)
            delete options.envPrefix;
        else
            options.envPrefix = prefix || &#039;&#039;;
        return self;
    };
    self.wrap = function (cols) {
        argsert_1.argsert(&#039;&lt;number|null|undefined&gt;&#039;, [cols], arguments.length);
        usage.wrap(cols);
        return self;
    };
    let strict = false;
    self.strict = function (enabled) {
        argsert_1.argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        strict = enabled !== false;
        return self;
    };
    self.getStrict = () =&gt; strict;
    let strictCommands = false;
    self.strictCommands = function (enabled) {
        argsert_1.argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self;
    };
    self.getStrictCommands = () =&gt; strictCommands;
    let parserConfig = {};
    self.parserConfiguration = function parserConfiguration(config) {
        argsert_1.argsert(&#039;&lt;object&gt;&#039;, [config], arguments.length);
        parserConfig = config;
        return self;
    };
    self.getParserConfiguration = () =&gt; parserConfig;
    self.showHelp = function (level) {
        argsert_1.argsert(&#039;[string|function]&#039;, [level], arguments.length);
        if (!self.parsed)
            self._parseArgs(processArgs); // run parser, if it has not already been executed.
        if (command.hasDefaultCommand()) {
            context.resets++; // override the restriction on top-level positoinals.
            command.runDefaultBuilderOn(self);
        }
        usage.showHelp(level);
        return self;
    };
    let versionOpt = null;
    self.version = function version(opt, msg, ver) {
        const defaultVersionOpt = &#039;version&#039;;
        argsert_1.argsert(&#039;[boolean|string] [string] [string]&#039;, [opt, msg, ver], arguments.length);
        // nuke the key previously configured
        // to return version #.
        if (versionOpt) {
            deleteFromParserHintObject(versionOpt);
            usage.version(undefined);
            versionOpt = null;
        }
        if (arguments.length === 0) {
            ver = guessVersion();
            opt = defaultVersionOpt;
        }
        else if (arguments.length === 1) {
            if (opt === false) { // disable default &#039;version&#039; key.
                return self;
            }
            ver = opt;
            opt = defaultVersionOpt;
        }
        else if (arguments.length === 2) {
            ver = msg;
            msg = undefined;
        }
        versionOpt = typeof opt === &#039;string&#039; ? opt : defaultVersionOpt;
        msg = msg || usage.deferY18nLookup(&#039;Show version number&#039;);
        usage.version(ver || undefined);
        self.boolean(versionOpt);
        self.describe(versionOpt, msg);
        return self;
    };
    function guessVersion() {
        const obj = pkgUp();
        return obj.version || &#039;unknown&#039;;
    }
    let helpOpt = null;
    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {
        const defaultHelpOpt = &#039;help&#039;;
        argsert_1.argsert(&#039;[string|boolean] [string]&#039;, [opt, msg], arguments.length);
        // nuke the key previously configured
        // to return help.
        if (helpOpt) {
            deleteFromParserHintObject(helpOpt);
            helpOpt = null;
        }
        if (arguments.length === 1) {
            if (opt === false)
                return self;
        }
        // use arguments, fallback to defaults for opt and msg
        helpOpt = typeof opt === &#039;string&#039; ? opt : defaultHelpOpt;
        self.boolean(helpOpt);
        self.describe(helpOpt, msg || usage.deferY18nLookup(&#039;Show help&#039;));
        return self;
    };
    const defaultShowHiddenOpt = &#039;show-hidden&#039;;
    options.showHiddenOpt = defaultShowHiddenOpt;
    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {
        argsert_1.argsert(&#039;[string|boolean] [string]&#039;, [opt, msg], arguments.length);
        if (arguments.length === 1) {
            if (opt === false)
                return self;
        }
        const showHiddenOpt = typeof opt === &#039;string&#039; ? opt : defaultShowHiddenOpt;
        self.boolean(showHiddenOpt);
        self.describe(showHiddenOpt, msg || usage.deferY18nLookup(&#039;Show hidden options&#039;));
        options.showHiddenOpt = showHiddenOpt;
        return self;
    };
    self.hide = function hide(key) {
        argsert_1.argsert(&#039;&lt;string&gt;&#039;, [key], arguments.length);
        options.hiddenOptions.push(key);
        return self;
    };
    self.showHelpOnFail = function showHelpOnFail(enabled, message) {
        argsert_1.argsert(&#039;[boolean|string] [string]&#039;, [enabled, message], arguments.length);
        usage.showHelpOnFail(enabled, message);
        return self;
    };
    var exitProcess = true;
    self.exitProcess = function (enabled = true) {
        argsert_1.argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        exitProcess = enabled;
        return self;
    };
    self.getExitProcess = () =&gt; exitProcess;
    var completionCommand = null;
    self.completion = function (cmd, desc, fn) {
        argsert_1.argsert(&#039;[string] [string|boolean|function] [function]&#039;, [cmd, desc, fn], arguments.length);
        // a function to execute when generating
        // completions can be provided as the second
        // or third argument to completion.
        if (typeof desc === &#039;function&#039;) {
            fn = desc;
            desc = undefined;
        }
        // register the completion command.
        completionCommand = cmd || completionCommand || &#039;completion&#039;;
        if (!desc &amp;&amp; desc !== false) {
            desc = &#039;generate completion script&#039;;
        }
        self.command(completionCommand, desc);
        // a function can be provided
        if (fn)
            completion.registerFunction(fn);
        return self;
    };
    self.showCompletionScript = function ($0, cmd) {
        argsert_1.argsert(&#039;[string] [string]&#039;, [$0, cmd], arguments.length);
        $0 = $0 || self.$0;
        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || &#039;completion&#039;));
        return self;
    };
    self.getCompletion = function (args, done) {
        argsert_1.argsert(&#039;&lt;array&gt; &lt;function&gt;&#039;, [args, done], arguments.length);
        completion.getCompletion(args, done);
    };
    self.locale = function (locale) {
        argsert_1.argsert(&#039;[string]&#039;, [locale], arguments.length);
        if (!locale) {
            guessLocale();
            return y18n.getLocale();
        }
        detectLocale = false;
        y18n.setLocale(locale);
        return self;
    };
    self.updateStrings = self.updateLocale = function (obj) {
        argsert_1.argsert(&#039;&lt;object&gt;&#039;, [obj], arguments.length);
        detectLocale = false;
        y18n.updateLocale(obj);
        return self;
    };
    let detectLocale = true;
    self.detectLocale = function (detect) {
        argsert_1.argsert(&#039;&lt;boolean&gt;&#039;, [detect], arguments.length);
        detectLocale = detect;
        return self;
    };
    self.getDetectLocale = () =&gt; detectLocale;
    var hasOutput = false;
    var exitError = null;
    // maybe exit, always capture
    // context about why we wanted to exit.
    self.exit = (code, err) =&gt; {
        hasOutput = true;
        exitError = err;
        if (exitProcess)
            process.exit(code);
    };
    // we use a custom logger that buffers output,
    // so that we can print to non-CLIs, e.g., chat-bots.
    const _logger = {
        log(...args) {
            if (!self._hasParseCallback())
                console.log(...args);
            hasOutput = true;
            if (output.length)
                output += &#039;\n&#039;;
            output += args.join(&#039; &#039;);
        },
        error(...args) {
            if (!self._hasParseCallback())
                console.error(...args);
            hasOutput = true;
            if (output.length)
                output += &#039;\n&#039;;
            output += args.join(&#039; &#039;);
        }
    };
    self._getLoggerInstance = () =&gt; _logger;
    // has yargs output an error our help
    // message in the current execution context.
    self._hasOutput = () =&gt; hasOutput;
    self._setHasOutput = () =&gt; {
        hasOutput = true;
    };
    let recommendCommands;
    self.recommendCommands = function (recommend = true) {
        argsert_1.argsert(&#039;[boolean]&#039;, [recommend], arguments.length);
        recommendCommands = recommend;
        return self;
    };
    self.getUsageInstance = () =&gt; usage;
    self.getValidationInstance = () =&gt; validation;
    self.getCommandInstance = () =&gt; command;
    self.terminalWidth = () =&gt; {
        argsert_1.argsert([], 0);
        return typeof process.stdout.columns !== &#039;undefined&#039; ? process.stdout.columns : null;
    };
    Object.defineProperty(self, &#039;argv&#039;, {
        get: () =&gt; self._parseArgs(processArgs),
        enumerable: true
    });
    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {
        let skipValidation = !!_calledFromCommand;
        args = args || processArgs;
        options.__ = y18n.__;
        options.configuration = self.getParserConfiguration();
        const populateDoubleDash = !!options.configuration[&#039;populate--&#039;];
        const config = Object.assign({}, options.configuration, {
            &#039;populate--&#039;: true
        });
        const parsed = Parser.detailed(args, Object.assign({}, options, {
            configuration: config
        }));
        let argv = parsed.argv;
        if (parseContext)
            argv = Object.assign({}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self.$0;
        self.parsed = parsed;
        try {
            guessLocale(); // guess locale lazily, so that it can be turned off in chain.
            // while building up the argv object, there
            // are two passes through the parser. If completion
            // is being performed short-circuit on the first pass.
            if (shortCircuit) {
                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);
            }
            // if there&#039;s a handler associated with a
            // command defer processing to it.
            if (helpOpt) {
                // consider any multi-char helpOpt alias as a valid help command
                // unless all helpOpt aliases are single-char
                // note that parsed.aliases is a normalized bidirectional map :)
                const helpCmds = [helpOpt]
                    .concat(aliases[helpOpt] || [])
                    .filter(k =&gt; k.length &gt; 1);
                // check if help should trigger and strip it from _.
                if (~helpCmds.indexOf(argv._[argv._.length - 1])) {
                    argv._.pop();
                    argv[helpOpt] = true;
                }
            }
            const handlerKeys = command.getCommands();
            const requestCompletions = completion.completionKey in argv;
            const skipRecommendation = argv[helpOpt] || requestCompletions;
            const skipDefaultCommand = skipRecommendation &amp;&amp; (handlerKeys.length &gt; 1 || handlerKeys[0] !== &#039;$0&#039;);
            if (argv._.length) {
                if (handlerKeys.length) {
                    let firstUnknownCommand;
                    for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {
                        cmd = String(argv._[i]);
                        if (~handlerKeys.indexOf(cmd) &amp;&amp; cmd !== completionCommand) {
                            // commands are executed using a recursive algorithm that executes
                            // the deepest command first; we keep track of the position in the
                            // argv._ array that is currently being executed.
                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);
                            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
                        }
                        else if (!firstUnknownCommand &amp;&amp; cmd !== completionCommand) {
                            firstUnknownCommand = cmd;
                            break;
                        }
                    }
                    // run the default command, if defined
                    if (command.hasDefaultCommand() &amp;&amp; !skipDefaultCommand) {
                        const innerArgv = command.runCommand(null, self, parsed);
                        return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
                    }
                    // recommend a command if recommendCommands() has
                    // been enabled, and no commands were found to execute
                    if (recommendCommands &amp;&amp; firstUnknownCommand &amp;&amp; !skipRecommendation) {
                        validation.recommendCommands(firstUnknownCommand, handlerKeys);
                    }
                }
                // generate a completion script for adding to ~/.bashrc.
                if (completionCommand &amp;&amp; ~argv._.indexOf(completionCommand) &amp;&amp; !requestCompletions) {
                    if (exitProcess)
                        setBlocking(true);
                    self.showCompletionScript();
                    self.exit(0);
                }
            }
            else if (command.hasDefaultCommand() &amp;&amp; !skipDefaultCommand) {
                const innerArgv = command.runCommand(null, self, parsed);
                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
            }
            // we must run completions first, a user might
            // want to complete the --help or --version option.
            if (requestCompletions) {
                if (exitProcess)
                    setBlocking(true);
                // we allow for asynchronous completions,
                // e.g., loading in a list of commands from an API.
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);
                completion.getCompletion(completionArgs, (completions) =&gt; {
                    ;
                    (completions || []).forEach((completion) =&gt; {
                        _logger.log(completion);
                    });
                    self.exit(0);
                });
                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);
            }
            // Handle &#039;help&#039; and &#039;version&#039; options
            // if we haven&#039;t already output help!
            if (!hasOutput) {
                Object.keys(argv).forEach((key) =&gt; {
                    if (key === helpOpt &amp;&amp; argv[key]) {
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        self.showHelp(&#039;log&#039;);
                        self.exit(0);
                    }
                    else if (key === versionOpt &amp;&amp; argv[key]) {
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        usage.showVersion();
                        self.exit(0);
                    }
                });
            }
            // Check if any of the options to skip validation were provided
            if (!skipValidation &amp;&amp; options.skipValidation.length &gt; 0) {
                skipValidation = Object.keys(argv).some(key =&gt; options.skipValidation.indexOf(key) &gt;= 0 &amp;&amp; argv[key] === true);
            }
            // If the help or version options where used and exitProcess is false,
            // or if explicitly skipped, we won&#039;t run validations.
            if (!skipValidation) {
                if (parsed.error)
                    throw new yerror_1.YError(parsed.error.message);
                // if we&#039;re executed via bash completion, don&#039;t
                // bother with validation.
                if (!requestCompletions) {
                    self._runValidation(argv, aliases, {}, parsed.error);
                }
            }
        }
        catch (err) {
            if (err instanceof yerror_1.YError)
                usage.fail(err.message, err);
            else
                throw err;
        }
        return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);
    };
    // to simplify the parsing of positionals in commands,
    // we temporarily populate &#039;--&#039; rather than _, with arguments
    // after the &#039;--&#039; directive. After the parse, we copy these back.
    self._copyDoubleDash = function (argv) {
        if (is_promise_1.isPromise(argv) || !argv._ || !argv[&#039;--&#039;])
            return argv;
        argv._.push.apply(argv._, argv[&#039;--&#039;]);
        // TODO(bcoe): refactor command parsing such that this delete is not
        // necessary: https://github.com/yargs/yargs/issues/1482
        try {
            delete argv[&#039;--&#039;];
        }
        catch (_err) { }
        return argv;
    };
    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {
        if (parseErrors)
            throw new yerror_1.YError(parseErrors.message);
        validation.nonOptionCount(argv);
        validation.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) {
            failedStrictCommands = validation.unknownCommands(argv);
        }
        if (strict &amp;&amp; !failedStrictCommands) {
            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
        }
        validation.customChecks(argv, aliases);
        validation.limitedChoices(argv);
        validation.implications(argv);
        validation.conflicting(argv);
    };
    function guessLocale() {
        if (!detectLocale)
            return;
        const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || &#039;en_US&#039;;
        self.locale(locale.replace(/[.:].*/, &#039;&#039;));
    }
    // an app should almost always have --version and --help,
    // if you *really* want to disable this use .help(false)/.version(false).
    self.help();
    self.version();
    return self;
}
exports.Yargs = Yargs;
// rebase an absolute path to a relative one with respect to a base directory
// exported for tests
function rebase(base, dir) {
    return path.relative(base, dir);
}
exports.rebase = rebase;
function isYargsInstance(y) {
    return !!y &amp;&amp; (typeof y._parseArgs === &#039;function&#039;);
}
exports.isYargsInstance = isYargsInstance;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
