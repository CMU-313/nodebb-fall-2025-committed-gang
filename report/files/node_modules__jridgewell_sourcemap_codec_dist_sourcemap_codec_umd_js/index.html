<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.99</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">465</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">155.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.10</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function (global, factory) {
  if (typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039;) {
    factory(module);
    module.exports = def(module);
  } else if (typeof define === &#039;function&#039; &amp;&amp; define.amd) {
    define([&#039;module&#039;], function(mod) {
      factory.apply(this, arguments);
      mod.exports = def(mod);
    });
  } else {
    const mod = { exports: {} };
    factory(mod);
    global = typeof globalThis !== &#039;undefined&#039; ? globalThis : global || self;
    global.sourcemapCodec = def(mod);
  }
  function def(m) { return &#039;default&#039; in m.exports ? m.exports.default : m.exports; }
})(this, (function (module) {
&quot;use strict&quot;;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) =&gt; {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) =&gt; {
  if (from &amp;&amp; typeof from === &quot;object&quot; || typeof from === &quot;function&quot;) {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) &amp;&amp; key !== except)
        __defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) =&gt; __copyProps(__defProp({}, &quot;__esModule&quot;, { value: true }), mod);

// src/sourcemap-codec.ts
var sourcemap_codec_exports = {};
__export(sourcemap_codec_exports, {
  decode: () =&gt; decode,
  decodeGeneratedRanges: () =&gt; decodeGeneratedRanges,
  decodeOriginalScopes: () =&gt; decodeOriginalScopes,
  encode: () =&gt; encode,
  encodeGeneratedRanges: () =&gt; encodeGeneratedRanges,
  encodeOriginalScopes: () =&gt; encodeOriginalScopes
});
module.exports = __toCommonJS(sourcemap_codec_exports);

// src/vlq.ts
var comma = &quot;,&quot;.charCodeAt(0);
var semicolon = &quot;;&quot;.charCodeAt(0);
var chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i &lt; chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = reader.next();
    integer = charToInt[c];
    value |= (integer &amp; 31) &lt;&lt; shift;
    shift += 5;
  } while (integer &amp; 32);
  const shouldNegate = value &amp; 1;
  value &gt;&gt;&gt;= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative + value;
}
function encodeInteger(builder, num, relative) {
  let delta = num - relative;
  delta = delta &lt; 0 ? -delta &lt;&lt; 1 | 1 : delta &lt;&lt; 1;
  do {
    let clamped = delta &amp; 31;
    delta &gt;&gt;&gt;= 5;
    if (delta &gt; 0) clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta &gt; 0);
  return num;
}
function hasMoreVlq(reader, max) {
  if (reader.pos &gt;= max) return false;
  return reader.peek() !== comma;
}

// src/strings.ts
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== &quot;undefined&quot; ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== &quot;undefined&quot; ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = &quot;&quot;;
    for (let i = 0; i &lt; buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = &quot;&quot;;
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos &gt; 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};

// src/scopes.ts
var EMPTY = [];
function decodeOriginalScopes(input) {
  const { length } = input;
  const reader = new StringReader(input);
  const scopes = [];
  const stack = [];
  let line = 0;
  for (; reader.pos &lt; length; reader.pos++) {
    line = decodeInteger(reader, line);
    const column = decodeInteger(reader, 0);
    if (!hasMoreVlq(reader, length)) {
      const last = stack.pop();
      last[2] = line;
      last[3] = column;
      continue;
    }
    const kind = decodeInteger(reader, 0);
    const fields = decodeInteger(reader, 0);
    const hasName = fields &amp; 1;
    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
    let vars = EMPTY;
    if (hasMoreVlq(reader, length)) {
      vars = [];
      do {
        const varsIndex = decodeInteger(reader, 0);
        vars.push(varsIndex);
      } while (hasMoreVlq(reader, length));
    }
    scope.vars = vars;
    scopes.push(scope);
    stack.push(scope);
  }
  return scopes;
}
function encodeOriginalScopes(scopes) {
  const writer = new StringWriter();
  for (let i = 0; i &lt; scopes.length; ) {
    i = _encodeOriginalScopes(scopes, i, writer, [0]);
  }
  return writer.flush();
}
function _encodeOriginalScopes(scopes, index, writer, state) {
  const scope = scopes[index];
  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
  if (index &gt; 0) writer.write(comma);
  state[0] = encodeInteger(writer, startLine, state[0]);
  encodeInteger(writer, startColumn, 0);
  encodeInteger(writer, kind, 0);
  const fields = scope.length === 6 ? 1 : 0;
  encodeInteger(writer, fields, 0);
  if (scope.length === 6) encodeInteger(writer, scope[5], 0);
  for (const v of vars) {
    encodeInteger(writer, v, 0);
  }
  for (index++; index &lt; scopes.length; ) {
    const next = scopes[index];
    const { 0: l, 1: c } = next;
    if (l &gt; endLine || l === endLine &amp;&amp; c &gt;= endColumn) {
      break;
    }
    index = _encodeOriginalScopes(scopes, index, writer, state);
  }
  writer.write(comma);
  state[0] = encodeInteger(writer, endLine, state[0]);
  encodeInteger(writer, endColumn, 0);
  return index;
}
function decodeGeneratedRanges(input) {
  const { length } = input;
  const reader = new StringReader(input);
  const ranges = [];
  const stack = [];
  let genLine = 0;
  let definitionSourcesIndex = 0;
  let definitionScopeIndex = 0;
  let callsiteSourcesIndex = 0;
  let callsiteLine = 0;
  let callsiteColumn = 0;
  let bindingLine = 0;
  let bindingColumn = 0;
  do {
    const semi = reader.indexOf(&quot;;&quot;);
    let genColumn = 0;
    for (; reader.pos &lt; semi; reader.pos++) {
      genColumn = decodeInteger(reader, genColumn);
      if (!hasMoreVlq(reader, semi)) {
        const last = stack.pop();
        last[2] = genLine;
        last[3] = genColumn;
        continue;
      }
      const fields = decodeInteger(reader, 0);
      const hasDefinition = fields &amp; 1;
      const hasCallsite = fields &amp; 2;
      const hasScope = fields &amp; 4;
      let callsite = null;
      let bindings = EMPTY;
      let range;
      if (hasDefinition) {
        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
        definitionScopeIndex = decodeInteger(
          reader,
          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0
        );
        definitionSourcesIndex = defSourcesIndex;
        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
      } else {
        range = [genLine, genColumn, 0, 0];
      }
      range.isScope = !!hasScope;
      if (hasCallsite) {
        const prevCsi = callsiteSourcesIndex;
        const prevLine = callsiteLine;
        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
        const sameSource = prevCsi === callsiteSourcesIndex;
        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
        callsiteColumn = decodeInteger(
          reader,
          sameSource &amp;&amp; prevLine === callsiteLine ? callsiteColumn : 0
        );
        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
      }
      range.callsite = callsite;
      if (hasMoreVlq(reader, semi)) {
        bindings = [];
        do {
          bindingLine = genLine;
          bindingColumn = genColumn;
          const expressionsCount = decodeInteger(reader, 0);
          let expressionRanges;
          if (expressionsCount &lt; -1) {
            expressionRanges = [[decodeInteger(reader, 0)]];
            for (let i = -1; i &gt; expressionsCount; i--) {
              const prevBl = bindingLine;
              bindingLine = decodeInteger(reader, bindingLine);
              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
              const expression = decodeInteger(reader, 0);
              expressionRanges.push([expression, bindingLine, bindingColumn]);
            }
          } else {
            expressionRanges = [[expressionsCount]];
          }
          bindings.push(expressionRanges);
        } while (hasMoreVlq(reader, semi));
      }
      range.bindings = bindings;
      ranges.push(range);
      stack.push(range);
    }
    genLine++;
    reader.pos = semi + 1;
  } while (reader.pos &lt; length);
  return ranges;
}
function encodeGeneratedRanges(ranges) {
  if (ranges.length === 0) return &quot;&quot;;
  const writer = new StringWriter();
  for (let i = 0; i &lt; ranges.length; ) {
    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
  }
  return writer.flush();
}
function _encodeGeneratedRanges(ranges, index, writer, state) {
  const range = ranges[index];
  const {
    0: startLine,
    1: startColumn,
    2: endLine,
    3: endColumn,
    isScope,
    callsite,
    bindings
  } = range;
  if (state[0] &lt; startLine) {
    catchupLine(writer, state[0], startLine);
    state[0] = startLine;
    state[1] = 0;
  } else if (index &gt; 0) {
    writer.write(comma);
  }
  state[1] = encodeInteger(writer, range[1], state[1]);
  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
  encodeInteger(writer, fields, 0);
  if (range.length === 6) {
    const { 4: sourcesIndex, 5: scopesIndex } = range;
    if (sourcesIndex !== state[2]) {
      state[3] = 0;
    }
    state[2] = encodeInteger(writer, sourcesIndex, state[2]);
    state[3] = encodeInteger(writer, scopesIndex, state[3]);
  }
  if (callsite) {
    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
    if (sourcesIndex !== state[4]) {
      state[5] = 0;
      state[6] = 0;
    } else if (callLine !== state[5]) {
      state[6] = 0;
    }
    state[4] = encodeInteger(writer, sourcesIndex, state[4]);
    state[5] = encodeInteger(writer, callLine, state[5]);
    state[6] = encodeInteger(writer, callColumn, state[6]);
  }
  if (bindings) {
    for (const binding of bindings) {
      if (binding.length &gt; 1) encodeInteger(writer, -binding.length, 0);
      const expression = binding[0][0];
      encodeInteger(writer, expression, 0);
      let bindingStartLine = startLine;
      let bindingStartColumn = startColumn;
      for (let i = 1; i &lt; binding.length; i++) {
        const expRange = binding[i];
        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
        encodeInteger(writer, expRange[0], 0);
      }
    }
  }
  for (index++; index &lt; ranges.length; ) {
    const next = ranges[index];
    const { 0: l, 1: c } = next;
    if (l &gt; endLine || l === endLine &amp;&amp; c &gt;= endColumn) {
      break;
    }
    index = _encodeGeneratedRanges(ranges, index, writer, state);
  }
  if (state[0] &lt; endLine) {
    catchupLine(writer, state[0], endLine);
    state[0] = endLine;
    state[1] = 0;
  } else {
    writer.write(comma);
  }
  state[1] = encodeInteger(writer, endColumn, state[1]);
  return index;
}
function catchupLine(writer, lastLine, line) {
  do {
    writer.write(semicolon);
  } while (++lastLine &lt; line);
}

// src/sourcemap-codec.ts
function decode(mappings) {
  const { length } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(&quot;;&quot;);
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos &lt; semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn &lt; lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos &lt;= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[0] - b[0];
}
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i &lt; decoded.length; i++) {
    const line = decoded[i];
    if (i &gt; 0) writer.write(semicolon);
    if (line.length === 0) continue;
    let genColumn = 0;
    for (let j = 0; j &lt; line.length; j++) {
      const segment = line[j];
      if (j &gt; 0) writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1) continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4) continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}
}));
//# sourceMappingURL=sourcemap-codec.umd.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
