<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/postcss/lib/parser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/postcss/lib/parser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.52</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">612</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">158.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.80</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

let AtRule = require(&#039;./at-rule&#039;)
let Comment = require(&#039;./comment&#039;)
let Declaration = require(&#039;./declaration&#039;)
let Root = require(&#039;./root&#039;)
let Rule = require(&#039;./rule&#039;)
let tokenizer = require(&#039;./tokenize&#039;)

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i &gt;= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = &#039;&#039;
    this.semicolon = false

    this.createTokenizer()
    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === &#039;&#039;) {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === &#039;(&#039; || type === &#039;[&#039;) {
        brackets.push(type === &#039;(&#039; ? &#039;)&#039; : &#039;]&#039;)
      } else if (type === &#039;{&#039; &amp;&amp; brackets.length &gt; 0) {
        brackets.push(&#039;}&#039;)
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === &#039;;&#039;) {
          node.source.end = this.getPosition(token[2])
          node.source.end.offset++
          this.semicolon = true
          break
        } else if (type === &#039;{&#039;) {
          open = true
          break
        } else if (type === &#039;}&#039;) {
          if (params.length &gt; 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev &amp;&amp; prev[0] === &#039;space&#039;) {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
              node.source.end.offset++
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, &#039;params&#039;, params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        node.source.end.offset++
        this.spaces = node.raws.between
        node.raws.between = &#039;&#039;
      }
    } else {
      node.raws.afterName = &#039;&#039;
      node.params = &#039;&#039;
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j &gt;= 0; j--) {
      token = tokens[j]
      if (token[0] !== &#039;space&#039;) {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property&#039;s value.
    // Then we need to return the colon after that word token. [3] is the &quot;end&quot; colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      &#039;Missed semicolon&#039;,
      token[0] === &#039;word&#039; ? token[3] + 1 : token[2]
    )
  }

  colon(tokens) {
    let brackets = 0
    let prev, token, type
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === &#039;(&#039;) {
        brackets += 1
      }
      if (type === &#039;)&#039;) {
        brackets -= 1
      }
      if (brackets === 0 &amp;&amp; type === &#039;:&#039;) {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === &#039;word&#039; &amp;&amp; prev[1] === &#039;progid&#039;) {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])
    node.source.end.offset++

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = &#039;&#039;
      node.raws.left = text
      node.raws.right = &#039;&#039;
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === &#039;;&#039;) {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )
    node.source.end.offset++

    while (tokens[0][0] !== &#039;word&#039;) {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = &#039;&#039;
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === &#039;:&#039; || type === &#039;space&#039; || type === &#039;comment&#039;) {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = &#039;&#039;

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === &#039;:&#039;) {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === &#039;word&#039; &amp;&amp; /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === &#039;_&#039; || node.prop[0] === &#039;*&#039;) {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== &#039;space&#039; &amp;&amp; next !== &#039;comment&#039;) break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i &gt;= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === &#039;!important&#039;) {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== &#039; !important&#039;) node.raws.important = string
        break
      } else if (token[1].toLowerCase() === &#039;important&#039;) {
        let cache = tokens.slice(0)
        let str = &#039;&#039;
        for (let j = i; j &gt; 0; j--) {
          let type = cache[j][0]
          if (str.trim().startsWith(&#039;!&#039;) &amp;&amp; type !== &#039;space&#039;) {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().startsWith(&#039;!&#039;)) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== &#039;space&#039; &amp;&amp; token[0] !== &#039;comment&#039;) {
        break
      }
    }

    let hasWord = tokens.some(i =&gt; i[0] !== &#039;space&#039; &amp;&amp; i[0] !== &#039;comment&#039;)

    if (hasWord) {
      node.raws.between += firstSpaces.map(i =&gt; i[1]).join(&#039;&#039;)
      firstSpaces = []
    }
    this.raw(node, &#039;value&#039;, firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(&#039;:&#039;) &amp;&amp; !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  doubleColon(token) {
    throw this.input.error(
      &#039;Double colon&#039;,
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = &#039;&#039;
    node.raws.between = &#039;&#039;
    this.current = node
  }

  end(token) {
    if (this.current.nodes &amp;&amp; this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || &#039;&#039;) + this.spaces
    this.spaces = &#039;&#039;

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current.source.end.offset++
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes &amp;&amp; this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || &#039;&#039;) + this.spaces
    this.root.source.end = this.getPosition(this.tokenizer.position())
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev &amp;&amp; prev.type === &#039;rule&#039; &amp;&amp; !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = &#039;&#039;
        prev.source.end = this.getPosition(token[2])
        prev.source.end.offset += prev.raws.ownSemicolon.length
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      column: pos.col,
      line: pos.line,
      offset
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    }
    node.raws.before = this.spaces
    this.spaces = &#039;&#039;
    if (node.type !== &#039;comment&#039;) this.semicolon = false
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith(&#039;--&#039;)

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === &#039;(&#039; || type === &#039;[&#039;) {
        if (!bracket) bracket = token
        brackets.push(type === &#039;(&#039; ? &#039;)&#039; : &#039;]&#039;)
      } else if (customProperty &amp;&amp; colon &amp;&amp; type === &#039;{&#039;) {
        if (!bracket) bracket = token
        brackets.push(&#039;}&#039;)
      } else if (brackets.length === 0) {
        if (type === &#039;;&#039;) {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === &#039;{&#039;) {
          this.rule(tokens)
          return
        } else if (type === &#039;}&#039;) {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === &#039;:&#039;) {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length &gt; 0) this.unclosedBracket(bracket)

    if (end &amp;&amp; colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0]
          if (token !== &#039;space&#039; &amp;&amp; token !== &#039;comment&#039;) break
          this.tokenizer.back(tokens.pop())
        }
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case &#039;space&#039;:
          this.spaces += token[1]
          break

        case &#039;;&#039;:
          this.freeSemicolon(token)
          break

        case &#039;}&#039;:
          this.end(token)
          break

        case &#039;comment&#039;:
          this.comment(token)
          break

        case &#039;at-word&#039;:
          this.atrule(token)
          break

        case &#039;{&#039;:
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  raw(node, prop, tokens, customProperty) {
    let token, type
    let length = tokens.length
    let value = &#039;&#039;
    let clean = true
    let next, prev

    for (let i = 0; i &lt; length; i += 1) {
      token = tokens[i]
      type = token[0]
      if (type === &#039;space&#039; &amp;&amp; i === length - 1 &amp;&amp; !customProperty) {
        clean = false
      } else if (type === &#039;comment&#039;) {
        prev = tokens[i - 1] ? tokens[i - 1][0] : &#039;empty&#039;
        next = tokens[i + 1] ? tokens[i + 1][0] : &#039;empty&#039;
        if (!SAFE_COMMENT_NEIGHBOR[prev] &amp;&amp; !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === &#039;,&#039;) {
            clean = false
          } else {
            value += token[1]
          }
        } else {
          clean = false
        }
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) =&gt; all + i[1], &#039;&#039;)
      node.raws[prop] = { raw, value }
    }
    node[prop] = value
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, &#039;selector&#039;, tokens)
    this.current = node
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = &#039;&#039;
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== &#039;space&#039; &amp;&amp; lastTokenType !== &#039;comment&#039;) break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  // Errors

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = &#039;&#039;
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== &#039;space&#039; &amp;&amp; next !== &#039;comment&#039;) break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = &#039;&#039;
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== &#039;space&#039;) break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = &#039;&#039;
    for (let i = from; i &lt; tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error(&#039;Unclosed block&#039;, pos.line, pos.column)
  }

  unclosedBracket(bracket) {
    throw this.input.error(
      &#039;Unclosed bracket&#039;,
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    )
  }

  unexpectedClose(token) {
    throw this.input.error(
      &#039;Unexpected }&#039;,
      { offset: token[2] },
      { offset: token[2] + 1 }
    )
  }

  unknownWord(tokens) {
    throw this.input.error(
      &#039;Unknown word &#039; + tokens[0][1],
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    )
  }

  unnamedAtrule(node, token) {
    throw this.input.error(
      &#039;At-rule without name&#039;,
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }
}

module.exports = Parser
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
