<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/rxjs/dist/esm5/internal/testing/TestScheduler.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/rxjs/dist/esm5/internal/testing/TestScheduler.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">569</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">126.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.11</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { __extends, __read, __spreadArray, __values } from &quot;tslib&quot;;
import { Observable } from &#039;../Observable&#039;;
import { ColdObservable } from &#039;./ColdObservable&#039;;
import { HotObservable } from &#039;./HotObservable&#039;;
import { SubscriptionLog } from &#039;./SubscriptionLog&#039;;
import { VirtualTimeScheduler, VirtualAction } from &#039;../scheduler/VirtualTimeScheduler&#039;;
import { COMPLETE_NOTIFICATION, errorNotification, nextNotification } from &#039;../NotificationFactories&#039;;
import { dateTimestampProvider } from &#039;../scheduler/dateTimestampProvider&#039;;
import { performanceTimestampProvider } from &#039;../scheduler/performanceTimestampProvider&#039;;
import { animationFrameProvider } from &#039;../scheduler/animationFrameProvider&#039;;
import { immediateProvider } from &#039;../scheduler/immediateProvider&#039;;
import { intervalProvider } from &#039;../scheduler/intervalProvider&#039;;
import { timeoutProvider } from &#039;../scheduler/timeoutProvider&#039;;
var defaultMaxFrame = 750;
var TestScheduler = (function (_super) {
    __extends(TestScheduler, _super);
    function TestScheduler(assertDeepEqual) {
        var _this = _super.call(this, VirtualAction, defaultMaxFrame) || this;
        _this.assertDeepEqual = assertDeepEqual;
        _this.hotObservables = [];
        _this.coldObservables = [];
        _this.flushTests = [];
        _this.runMode = false;
        return _this;
    }
    TestScheduler.prototype.createTime = function (marbles) {
        var indexOf = this.runMode ? marbles.trim().indexOf(&#039;|&#039;) : marbles.indexOf(&#039;|&#039;);
        if (indexOf === -1) {
            throw new Error(&#039;marble diagram for time should have a completion marker &quot;|&quot;&#039;);
        }
        return indexOf * TestScheduler.frameTimeFactor;
    };
    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
        if (marbles.indexOf(&#039;^&#039;) !== -1) {
            throw new Error(&#039;cold observable cannot have subscription offset &quot;^&quot;&#039;);
        }
        if (marbles.indexOf(&#039;!&#039;) !== -1) {
            throw new Error(&#039;cold observable cannot have unsubscription marker &quot;!&quot;&#039;);
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        var cold = new ColdObservable(messages, this);
        this.coldObservables.push(cold);
        return cold;
    };
    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
        if (marbles.indexOf(&#039;!&#039;) !== -1) {
            throw new Error(&#039;hot observable cannot have unsubscription marker &quot;!&quot;&#039;);
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        var subject = new HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    };
    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
        var _this = this;
        var messages = [];
        observable.subscribe({
            next: function (value) {
                messages.push({ frame: _this.frame - outerFrame, notification: nextNotification(value) });
            },
            error: function (error) {
                messages.push({ frame: _this.frame - outerFrame, notification: errorNotification(error) });
            },
            complete: function () {
                messages.push({ frame: _this.frame - outerFrame, notification: COMPLETE_NOTIFICATION });
            },
        });
        return messages;
    };
    TestScheduler.prototype.expectObservable = function (observable, subscriptionMarbles) {
        var _this = this;
        if (subscriptionMarbles === void 0) { subscriptionMarbles = null; }
        var actual = [];
        var flushTest = { actual: actual, ready: false };
        var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
        var subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;
        var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
        var subscription;
        this.schedule(function () {
            subscription = observable.subscribe({
                next: function (x) {
                    var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                    actual.push({ frame: _this.frame, notification: nextNotification(value) });
                },
                error: function (error) {
                    actual.push({ frame: _this.frame, notification: errorNotification(error) });
                },
                complete: function () {
                    actual.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                },
            });
        }, subscriptionFrame);
        if (unsubscriptionFrame !== Infinity) {
            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
        }
        this.flushTests.push(flushTest);
        var runMode = this.runMode;
        return {
            toBe: function (marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
            },
            toEqual: function (other) {
                flushTest.ready = true;
                flushTest.expected = [];
                _this.schedule(function () {
                    subscription = other.subscribe({
                        next: function (x) {
                            var value = x instanceof Observable ? _this.materializeInnerObservable(x, _this.frame) : x;
                            flushTest.expected.push({ frame: _this.frame, notification: nextNotification(value) });
                        },
                        error: function (error) {
                            flushTest.expected.push({ frame: _this.frame, notification: errorNotification(error) });
                        },
                        complete: function () {
                            flushTest.expected.push({ frame: _this.frame, notification: COMPLETE_NOTIFICATION });
                        },
                    });
                }, subscriptionFrame);
            },
        };
    };
    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
        var flushTest = { actual: actualSubscriptionLogs, ready: false };
        this.flushTests.push(flushTest);
        var runMode = this.runMode;
        return {
            toBe: function (marblesOrMarblesArray) {
                var marblesArray = typeof marblesOrMarblesArray === &#039;string&#039; ? [marblesOrMarblesArray] : marblesOrMarblesArray;
                flushTest.ready = true;
                flushTest.expected = marblesArray
                    .map(function (marbles) { return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode); })
                    .filter(function (marbles) { return marbles.subscribedFrame !== Infinity; });
            },
        };
    };
    TestScheduler.prototype.flush = function () {
        var _this = this;
        var hotObservables = this.hotObservables;
        while (hotObservables.length &gt; 0) {
            hotObservables.shift().setup();
        }
        _super.prototype.flush.call(this);
        this.flushTests = this.flushTests.filter(function (test) {
            if (test.ready) {
                _this.assertDeepEqual(test.actual, test.expected);
                return false;
            }
            return true;
        });
    };
    TestScheduler.parseMarblesAsSubscriptions = function (marbles, runMode) {
        var _this = this;
        if (runMode === void 0) { runMode = false; }
        if (typeof marbles !== &#039;string&#039;) {
            return new SubscriptionLog(Infinity);
        }
        var characters = __spreadArray([], __read(marbles));
        var len = characters.length;
        var groupStart = -1;
        var subscriptionFrame = Infinity;
        var unsubscriptionFrame = Infinity;
        var frame = 0;
        var _loop_1 = function (i) {
            var nextFrame = frame;
            var advanceFrameBy = function (count) {
                nextFrame += count * _this.frameTimeFactor;
            };
            var c = characters[i];
            switch (c) {
                case &#039; &#039;:
                    if (!runMode) {
                        advanceFrameBy(1);
                    }
                    break;
                case &#039;-&#039;:
                    advanceFrameBy(1);
                    break;
                case &#039;(&#039;:
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case &#039;)&#039;:
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case &#039;^&#039;:
                    if (subscriptionFrame !== Infinity) {
                        throw new Error(&quot;found a second subscription point &#039;^&#039; in a &quot; + &#039;subscription marble diagram. There can only be one.&#039;);
                    }
                    subscriptionFrame = groupStart &gt; -1 ? groupStart : frame;
                    advanceFrameBy(1);
                    break;
                case &#039;!&#039;:
                    if (unsubscriptionFrame !== Infinity) {
                        throw new Error(&quot;found a second unsubscription point &#039;!&#039; in a &quot; + &#039;subscription marble diagram. There can only be one.&#039;);
                    }
                    unsubscriptionFrame = groupStart &gt; -1 ? groupStart : frame;
                    break;
                default:
                    if (runMode &amp;&amp; c.match(/^[0-9]$/)) {
                        if (i === 0 || characters[i - 1] === &#039; &#039;) {
                            var buffer = characters.slice(i).join(&#039;&#039;);
                            var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) {
                                i += match[0].length - 1;
                                var duration = parseFloat(match[1]);
                                var unit = match[2];
                                var durationInMs = void 0;
                                switch (unit) {
                                    case &#039;ms&#039;:
                                        durationInMs = duration;
                                        break;
                                    case &#039;s&#039;:
                                        durationInMs = duration * 1000;
                                        break;
                                    case &#039;m&#039;:
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                }
                                advanceFrameBy(durationInMs / this_1.frameTimeFactor);
                                break;
                            }
                        }
                    }
                    throw new Error(&quot;there can only be &#039;^&#039; and &#039;!&#039; markers in a &quot; + &quot;subscription marble diagram. Found instead &#039;&quot; + c + &quot;&#039;.&quot;);
            }
            frame = nextFrame;
            out_i_1 = i;
        };
        var this_1 = this, out_i_1;
        for (var i = 0; i &lt; len; i++) {
            _loop_1(i);
            i = out_i_1;
        }
        if (unsubscriptionFrame &lt; 0) {
            return new SubscriptionLog(subscriptionFrame);
        }
        else {
            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
        }
    };
    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables, runMode) {
        var _this = this;
        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
        if (runMode === void 0) { runMode = false; }
        if (marbles.indexOf(&#039;!&#039;) !== -1) {
            throw new Error(&#039;conventional marble diagrams cannot have the &#039; + &#039;unsubscription marker &quot;!&quot;&#039;);
        }
        var characters = __spreadArray([], __read(marbles));
        var len = characters.length;
        var testMessages = [];
        var subIndex = runMode ? marbles.replace(/^[ ]+/, &#039;&#039;).indexOf(&#039;^&#039;) : marbles.indexOf(&#039;^&#039;);
        var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
        var getValue = typeof values !== &#039;object&#039;
            ? function (x) { return x; }
            : function (x) {
                if (materializeInnerObservables &amp;&amp; values[x] instanceof ColdObservable) {
                    return values[x].messages;
                }
                return values[x];
            };
        var groupStart = -1;
        var _loop_2 = function (i) {
            var nextFrame = frame;
            var advanceFrameBy = function (count) {
                nextFrame += count * _this.frameTimeFactor;
            };
            var notification = void 0;
            var c = characters[i];
            switch (c) {
                case &#039; &#039;:
                    if (!runMode) {
                        advanceFrameBy(1);
                    }
                    break;
                case &#039;-&#039;:
                    advanceFrameBy(1);
                    break;
                case &#039;(&#039;:
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case &#039;)&#039;:
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case &#039;|&#039;:
                    notification = COMPLETE_NOTIFICATION;
                    advanceFrameBy(1);
                    break;
                case &#039;^&#039;:
                    advanceFrameBy(1);
                    break;
                case &#039;#&#039;:
                    notification = errorNotification(errorValue || &#039;error&#039;);
                    advanceFrameBy(1);
                    break;
                default:
                    if (runMode &amp;&amp; c.match(/^[0-9]$/)) {
                        if (i === 0 || characters[i - 1] === &#039; &#039;) {
                            var buffer = characters.slice(i).join(&#039;&#039;);
                            var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) {
                                i += match[0].length - 1;
                                var duration = parseFloat(match[1]);
                                var unit = match[2];
                                var durationInMs = void 0;
                                switch (unit) {
                                    case &#039;ms&#039;:
                                        durationInMs = duration;
                                        break;
                                    case &#039;s&#039;:
                                        durationInMs = duration * 1000;
                                        break;
                                    case &#039;m&#039;:
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                }
                                advanceFrameBy(durationInMs / this_2.frameTimeFactor);
                                break;
                            }
                        }
                    }
                    notification = nextNotification(getValue(c));
                    advanceFrameBy(1);
                    break;
            }
            if (notification) {
                testMessages.push({ frame: groupStart &gt; -1 ? groupStart : frame, notification: notification });
            }
            frame = nextFrame;
            out_i_2 = i;
        };
        var this_2 = this, out_i_2;
        for (var i = 0; i &lt; len; i++) {
            _loop_2(i);
            i = out_i_2;
        }
        return testMessages;
    };
    TestScheduler.prototype.createAnimator = function () {
        var _this = this;
        if (!this.runMode) {
            throw new Error(&#039;animate() must only be used in run mode&#039;);
        }
        var lastHandle = 0;
        var map;
        var delegate = {
            requestAnimationFrame: function (callback) {
                if (!map) {
                    throw new Error(&#039;animate() was not called within run()&#039;);
                }
                var handle = ++lastHandle;
                map.set(handle, callback);
                return handle;
            },
            cancelAnimationFrame: function (handle) {
                if (!map) {
                    throw new Error(&#039;animate() was not called within run()&#039;);
                }
                map.delete(handle);
            },
        };
        var animate = function (marbles) {
            var e_1, _a;
            if (map) {
                throw new Error(&#039;animate() must not be called more than once within run()&#039;);
            }
            if (/[|#]/.test(marbles)) {
                throw new Error(&#039;animate() must not complete or error&#039;);
            }
            map = new Map();
            var messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);
            try {
                for (var messages_1 = __values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
                    var message = messages_1_1.value;
                    _this.schedule(function () {
                        var e_2, _a;
                        var now = _this.now();
                        var callbacks = Array.from(map.values());
                        map.clear();
                        try {
                            for (var callbacks_1 = (e_2 = void 0, __values(callbacks)), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                                var callback = callbacks_1_1.value;
                                callback(now);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (callbacks_1_1 &amp;&amp; !callbacks_1_1.done &amp;&amp; (_a = callbacks_1.return)) _a.call(callbacks_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }, message.frame);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (messages_1_1 &amp;&amp; !messages_1_1.done &amp;&amp; (_a = messages_1.return)) _a.call(messages_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return { animate: animate, delegate: delegate };
    };
    TestScheduler.prototype.createDelegates = function () {
        var _this = this;
        var lastHandle = 0;
        var scheduleLookup = new Map();
        var run = function () {
            var now = _this.now();
            var scheduledRecords = Array.from(scheduleLookup.values());
            var scheduledRecordsDue = scheduledRecords.filter(function (_a) {
                var due = _a.due;
                return due &lt;= now;
            });
            var dueImmediates = scheduledRecordsDue.filter(function (_a) {
                var type = _a.type;
                return type === &#039;immediate&#039;;
            });
            if (dueImmediates.length &gt; 0) {
                var _a = dueImmediates[0], handle = _a.handle, handler = _a.handler;
                scheduleLookup.delete(handle);
                handler();
                return;
            }
            var dueIntervals = scheduledRecordsDue.filter(function (_a) {
                var type = _a.type;
                return type === &#039;interval&#039;;
            });
            if (dueIntervals.length &gt; 0) {
                var firstDueInterval = dueIntervals[0];
                var duration = firstDueInterval.duration, handler = firstDueInterval.handler;
                firstDueInterval.due = now + duration;
                firstDueInterval.subscription = _this.schedule(run, duration);
                handler();
                return;
            }
            var dueTimeouts = scheduledRecordsDue.filter(function (_a) {
                var type = _a.type;
                return type === &#039;timeout&#039;;
            });
            if (dueTimeouts.length &gt; 0) {
                var _b = dueTimeouts[0], handle = _b.handle, handler = _b.handler;
                scheduleLookup.delete(handle);
                handler();
                return;
            }
            throw new Error(&#039;Expected a due immediate or interval&#039;);
        };
        var immediate = {
            setImmediate: function (handler) {
                var handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: _this.now(),
                    duration: 0,
                    handle: handle,
                    handler: handler,
                    subscription: _this.schedule(run, 0),
                    type: &#039;immediate&#039;,
                });
                return handle;
            },
            clearImmediate: function (handle) {
                var value = scheduleLookup.get(handle);
                if (value) {
                    value.subscription.unsubscribe();
                    scheduleLookup.delete(handle);
                }
            },
        };
        var interval = {
            setInterval: function (handler, duration) {
                if (duration === void 0) { duration = 0; }
                var handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: _this.now() + duration,
                    duration: duration,
                    handle: handle,
                    handler: handler,
                    subscription: _this.schedule(run, duration),
                    type: &#039;interval&#039;,
                });
                return handle;
            },
            clearInterval: function (handle) {
                var value = scheduleLookup.get(handle);
                if (value) {
                    value.subscription.unsubscribe();
                    scheduleLookup.delete(handle);
                }
            },
        };
        var timeout = {
            setTimeout: function (handler, duration) {
                if (duration === void 0) { duration = 0; }
                var handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: _this.now() + duration,
                    duration: duration,
                    handle: handle,
                    handler: handler,
                    subscription: _this.schedule(run, duration),
                    type: &#039;timeout&#039;,
                });
                return handle;
            },
            clearTimeout: function (handle) {
                var value = scheduleLookup.get(handle);
                if (value) {
                    value.subscription.unsubscribe();
                    scheduleLookup.delete(handle);
                }
            },
        };
        return { immediate: immediate, interval: interval, timeout: timeout };
    };
    TestScheduler.prototype.run = function (callback) {
        var prevFrameTimeFactor = TestScheduler.frameTimeFactor;
        var prevMaxFrames = this.maxFrames;
        TestScheduler.frameTimeFactor = 1;
        this.maxFrames = Infinity;
        this.runMode = true;
        var animator = this.createAnimator();
        var delegates = this.createDelegates();
        animationFrameProvider.delegate = animator.delegate;
        dateTimestampProvider.delegate = this;
        immediateProvider.delegate = delegates.immediate;
        intervalProvider.delegate = delegates.interval;
        timeoutProvider.delegate = delegates.timeout;
        performanceTimestampProvider.delegate = this;
        var helpers = {
            cold: this.createColdObservable.bind(this),
            hot: this.createHotObservable.bind(this),
            flush: this.flush.bind(this),
            time: this.createTime.bind(this),
            expectObservable: this.expectObservable.bind(this),
            expectSubscriptions: this.expectSubscriptions.bind(this),
            animate: animator.animate,
        };
        try {
            var ret = callback(helpers);
            this.flush();
            return ret;
        }
        finally {
            TestScheduler.frameTimeFactor = prevFrameTimeFactor;
            this.maxFrames = prevMaxFrames;
            this.runMode = false;
            animationFrameProvider.delegate = undefined;
            dateTimestampProvider.delegate = undefined;
            immediateProvider.delegate = undefined;
            intervalProvider.delegate = undefined;
            timeoutProvider.delegate = undefined;
            performanceTimestampProvider.delegate = undefined;
        }
    };
    TestScheduler.frameTimeFactor = 10;
    return TestScheduler;
}(VirtualTimeScheduler));
export { TestScheduler };
//# sourceMappingURL=TestScheduler.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
