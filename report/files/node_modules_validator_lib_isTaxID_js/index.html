<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/validator/lib/isTaxID.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/validator/lib/isTaxID.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1399</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">131.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">16.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

function _typeof(o) { &quot;@babel/helpers - typeof&quot;; return _typeof = &quot;function&quot; == typeof Symbol &amp;&amp; &quot;symbol&quot; == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o &amp;&amp; &quot;function&quot; == typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? &quot;symbol&quot; : typeof o; }, _typeof(o); }
Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.default = isTaxID;
var _assertString = _interopRequireDefault(require(&quot;./util/assertString&quot;));
var algorithms = _interopRequireWildcard(require(&quot;./util/algorithms&quot;));
var _isDate = _interopRequireDefault(require(&quot;./isDate&quot;));
function _getRequireWildcardCache(e) { if (&quot;function&quot; != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r &amp;&amp; e &amp;&amp; e.__esModule) return e; if (null === e || &quot;object&quot; != _typeof(e) &amp;&amp; &quot;function&quot; != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t &amp;&amp; t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; for (var u in e) if (&quot;default&quot; !== u &amp;&amp; {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i &amp;&amp; (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t &amp;&amp; t.set(e, n), n; }
function _interopRequireDefault(e) { return e &amp;&amp; e.__esModule ? e : { default: e }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError(&quot;Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;); }
function _unsupportedIterableToArray(r, a) { if (r) { if (&quot;string&quot; == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return &quot;Object&quot; === t &amp;&amp; r.constructor &amp;&amp; (t = r.constructor.name), &quot;Map&quot; === t || &quot;Set&quot; === t ? Array.from(r) : &quot;Arguments&quot; === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if (&quot;undefined&quot; != typeof Symbol &amp;&amp; null != r[Symbol.iterator] || null != r[&quot;@@iterator&quot;]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a &gt; r.length) &amp;&amp; (a = r.length); for (var e = 0, n = Array(a); e &lt; a; e++) n[e] = r[e]; return n; }
/**
 * TIN Validation
 * Validates Tax Identification Numbers (TINs) from the US, EU member states and the United Kingdom.
 *
 * EU-UK:
 * National TIN validity is calculated using public algorithms as made available by DG TAXUD.
 *
 * See `https://ec.europa.eu/taxation_customs/tin/specs/FS-TIN%20Algorithms-Public.docx` for more information.
 *
 * US:
 * An Employer Identification Number (EIN), also known as a Federal Tax Identification Number,
 *  is used to identify a business entity.
 *
 * NOTES:
 *  - Prefix 47 is being reserved for future use
 *  - Prefixes 26, 27, 45, 46 and 47 were previously assigned by the Philadelphia campus.
 *
 * See `http://www.irs.gov/Businesses/Small-Businesses-&amp;-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes`
 * for more information.
 */

// Locale functions

/*
 * bg-BG validation function
 * (Edinen graždanski nomer (EGN/ЕГН), persons only)
 * Checks if birth date (first six digits) is valid and calculates check (last) digit
 */
function bgBgCheck(tin) {
  // Extract full year, normalize month and check birth date validity
  var century_year = tin.slice(0, 2);
  var month = parseInt(tin.slice(2, 4), 10);
  if (month &gt; 40) {
    month -= 40;
    century_year = &quot;20&quot;.concat(century_year);
  } else if (month &gt; 20) {
    month -= 20;
    century_year = &quot;18&quot;.concat(century_year);
  } else {
    century_year = &quot;19&quot;.concat(century_year);
  }
  if (month &lt; 10) {
    month = &quot;0&quot;.concat(month);
  }
  var date = &quot;&quot;.concat(century_year, &quot;/&quot;).concat(month, &quot;/&quot;).concat(tin.slice(4, 6));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // split digits into an array for further processing
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });

  // Calculate checksum by multiplying digits with fixed values
  var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
  var checksum = 0;
  for (var i = 0; i &lt; multip_lookup.length; i++) {
    checksum += digits[i] * multip_lookup[i];
  }
  checksum = checksum % 11 === 10 ? 0 : checksum % 11;
  return checksum === digits[9];
}

/**
 * Check if an input is a valid Canadian SIN (Social Insurance Number)
 *
 * The Social Insurance Number (SIN) is a 9 digit number that
 * you need to work in Canada or to have access to government programs and benefits.
 *
 * https://en.wikipedia.org/wiki/Social_Insurance_Number
 * https://www.canada.ca/en/employment-social-development/services/sin.html
 * https://www.codercrunch.com/challenge/819302488/sin-validator
 *
 * @param {string} input
 * @return {boolean}
 */
function isCanadianSIN(input) {
  var digitsArray = input.split(&#039;&#039;);
  var even = digitsArray.filter(function (_, idx) {
    return idx % 2;
  }).map(function (i) {
    return Number(i) * 2;
  }).join(&#039;&#039;).split(&#039;&#039;);
  var total = digitsArray.filter(function (_, idx) {
    return !(idx % 2);
  }).concat(even).map(function (i) {
    return Number(i);
  }).reduce(function (acc, cur) {
    return acc + cur;
  });
  return total % 10 === 0;
}

/*
 * cs-CZ validation function
 * (Rodné číslo (RČ), persons only)
 * Checks if birth date (first six digits) is valid and divisibility by 11
 * Material not in DG TAXUD document sourced from:
 * -`https://lorenc.info/3MA381/overeni-spravnosti-rodneho-cisla.htm`
 * -`https://www.mvcr.cz/clanek/rady-a-sluzby-dokumenty-rodne-cislo.aspx`
 */
function csCzCheck(tin) {
  tin = tin.replace(/\W/, &#039;&#039;);

  // Extract full year from TIN length
  var full_year = parseInt(tin.slice(0, 2), 10);
  if (tin.length === 10) {
    if (full_year &lt; 54) {
      full_year = &quot;20&quot;.concat(full_year);
    } else {
      full_year = &quot;19&quot;.concat(full_year);
    }
  } else {
    if (tin.slice(6) === &#039;000&#039;) {
      return false;
    } // Three-zero serial not assigned before 1954
    if (full_year &lt; 54) {
      full_year = &quot;19&quot;.concat(full_year);
    } else {
      return false; // No 18XX years seen in any of the resources
    }
  }
  // Add missing zero if needed
  if (full_year.length === 3) {
    full_year = [full_year.slice(0, 2), &#039;0&#039;, full_year.slice(2)].join(&#039;&#039;);
  }

  // Extract month from TIN and normalize
  var month = parseInt(tin.slice(2, 4), 10);
  if (month &gt; 50) {
    month -= 50;
  }
  if (month &gt; 20) {
    // Month-plus-twenty was only introduced in 2004
    if (parseInt(full_year, 10) &lt; 2004) {
      return false;
    }
    month -= 20;
  }
  if (month &lt; 10) {
    month = &quot;0&quot;.concat(month);
  }

  // Check date validity
  var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(month, &quot;/&quot;).concat(tin.slice(4, 6));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // Verify divisibility by 11
  if (tin.length === 10) {
    if (parseInt(tin, 10) % 11 !== 0) {
      // Some numbers up to and including 1985 are still valid if
      // check (last) digit equals 0 and modulo of first 9 digits equals 10
      var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
      if (parseInt(full_year, 10) &lt; 1986 &amp;&amp; checkdigit === 10) {
        if (parseInt(tin.slice(9), 10) !== 0) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}

/*
 * de-AT validation function
 * (Abgabenkontonummer, persons/entities)
 * Verify TIN validity by calling luhnCheck()
 */
function deAtCheck(tin) {
  return algorithms.luhnCheck(tin);
}

/*
 * de-DE validation function
 * (Steueridentifikationsnummer (Steuer-IdNr.), persons only)
 * Tests for single duplicate/triplicate value, then calculates ISO 7064 check (last) digit
 * Partial implementation of spec (same result with both algorithms always)
 */
function deDeCheck(tin) {
  // Split digits into an array for further processing
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });

  // Fill array with strings of number positions
  var occurrences = [];
  for (var i = 0; i &lt; digits.length - 1; i++) {
    occurrences.push(&#039;&#039;);
    for (var j = 0; j &lt; digits.length - 1; j++) {
      if (digits[i] === digits[j]) {
        occurrences[i] += j;
      }
    }
  }

  // Remove digits with one occurrence and test for only one duplicate/triplicate
  occurrences = occurrences.filter(function (a) {
    return a.length &gt; 1;
  });
  if (occurrences.length !== 2 &amp;&amp; occurrences.length !== 3) {
    return false;
  }

  // In case of triplicate value only two digits are allowed next to each other
  if (occurrences[0].length === 3) {
    var trip_locations = occurrences[0].split(&#039;&#039;).map(function (a) {
      return parseInt(a, 10);
    });
    var recurrent = 0; // Amount of neighbor occurrences
    for (var _i = 0; _i &lt; trip_locations.length - 1; _i++) {
      if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
        recurrent += 1;
      }
    }
    if (recurrent === 2) {
      return false;
    }
  }
  return algorithms.iso7064Check(tin);
}

/*
 * dk-DK validation function
 * (CPR-nummer (personnummer), persons only)
 * Checks if birth date (first six digits) is valid and assigned to century (seventh) digit,
 * and calculates check (last) digit
 */
function dkDkCheck(tin) {
  tin = tin.replace(/\W/, &#039;&#039;);

  // Extract year, check if valid for given century digit and add century
  var year = parseInt(tin.slice(4, 6), 10);
  var century_digit = tin.slice(6, 7);
  switch (century_digit) {
    case &#039;0&#039;:
    case &#039;1&#039;:
    case &#039;2&#039;:
    case &#039;3&#039;:
      year = &quot;19&quot;.concat(year);
      break;
    case &#039;4&#039;:
    case &#039;9&#039;:
      if (year &lt; 37) {
        year = &quot;20&quot;.concat(year);
      } else {
        year = &quot;19&quot;.concat(year);
      }
      break;
    default:
      if (year &lt; 37) {
        year = &quot;20&quot;.concat(year);
      } else if (year &gt; 58) {
        year = &quot;18&quot;.concat(year);
      } else {
        return false;
      }
      break;
  }
  // Add missing zero if needed
  if (year.length === 3) {
    year = [year.slice(0, 2), &#039;0&#039;, year.slice(2)].join(&#039;&#039;);
  }
  // Check date validity
  var date = &quot;&quot;.concat(year, &quot;/&quot;).concat(tin.slice(2, 4), &quot;/&quot;).concat(tin.slice(0, 2));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // Split digits into an array for further processing
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  var weight = 4;
  // Multiply by weight and add to checksum
  for (var i = 0; i &lt; 9; i++) {
    checksum += digits[i] * weight;
    weight -= 1;
    if (weight === 1) {
      weight = 7;
    }
  }
  checksum %= 11;
  if (checksum === 1) {
    return false;
  }
  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
}

/*
 * el-CY validation function
 * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons only)
 * Verify TIN validity by calculating ASCII value of check (last) character
 */
function elCyCheck(tin) {
  // split digits into an array for further processing
  var digits = tin.slice(0, 8).split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  // add digits in even places
  for (var i = 1; i &lt; digits.length; i += 2) {
    checksum += digits[i];
  }

  // add digits in odd places
  for (var _i2 = 0; _i2 &lt; digits.length; _i2 += 2) {
    if (digits[_i2] &lt; 2) {
      checksum += 1 - digits[_i2];
    } else {
      checksum += 2 * (digits[_i2] - 2) + 5;
      if (digits[_i2] &gt; 4) {
        checksum += 2;
      }
    }
  }
  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
}

/*
 * el-GR validation function
 * (Arithmos Forologikou Mitroou (AFM/ΑΦΜ), persons/entities)
 * Verify TIN validity by calculating check (last) digit
 * Algorithm not in DG TAXUD document- sourced from:
 * - `http://epixeirisi.gr/%CE%9A%CE%A1%CE%99%CE%A3%CE%99%CE%9C%CE%91-%CE%98%CE%95%CE%9C%CE%91%CE%A4%CE%91-%CE%A6%CE%9F%CE%A1%CE%9F%CE%9B%CE%9F%CE%93%CE%99%CE%91%CE%A3-%CE%9A%CE%91%CE%99-%CE%9B%CE%9F%CE%93%CE%99%CE%A3%CE%A4%CE%99%CE%9A%CE%97%CE%A3/23791/%CE%91%CF%81%CE%B9%CE%B8%CE%BC%CF%8C%CF%82-%CE%A6%CE%BF%CF%81%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CE%BA%CE%BF%CF%8D-%CE%9C%CE%B7%CF%84%CF%81%CF%8E%CE%BF%CF%85`
 */
function elGrCheck(tin) {
  // split digits into an array for further processing
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  for (var i = 0; i &lt; 8; i++) {
    checksum += digits[i] * Math.pow(2, 8 - i);
  }
  return checksum % 11 % 10 === digits[8];
}

/*
 * en-GB validation function (should go here if needed)
 * (National Insurance Number (NINO) or Unique Taxpayer Reference (UTR),
 * persons/entities respectively)
 */

/*
 * en-IE validation function
 * (Personal Public Service Number (PPS No), persons only)
 * Verify TIN validity by calculating check (second to last) character
 */
function enIeCheck(tin) {
  var checksum = algorithms.reverseMultiplyAndSum(tin.split(&#039;&#039;).slice(0, 7).map(function (a) {
    return parseInt(a, 10);
  }), 8);
  if (tin.length === 9 &amp;&amp; tin[8] !== &#039;W&#039;) {
    checksum += (tin[8].charCodeAt(0) - 64) * 9;
  }
  checksum %= 23;
  if (checksum === 0) {
    return tin[7].toUpperCase() === &#039;W&#039;;
  }
  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
}

// Valid US IRS campus prefixes
var enUsCampusPrefix = {
  andover: [&#039;10&#039;, &#039;12&#039;],
  atlanta: [&#039;60&#039;, &#039;67&#039;],
  austin: [&#039;50&#039;, &#039;53&#039;],
  brookhaven: [&#039;01&#039;, &#039;02&#039;, &#039;03&#039;, &#039;04&#039;, &#039;05&#039;, &#039;06&#039;, &#039;11&#039;, &#039;13&#039;, &#039;14&#039;, &#039;16&#039;, &#039;21&#039;, &#039;22&#039;, &#039;23&#039;, &#039;25&#039;, &#039;34&#039;, &#039;51&#039;, &#039;52&#039;, &#039;54&#039;, &#039;55&#039;, &#039;56&#039;, &#039;57&#039;, &#039;58&#039;, &#039;59&#039;, &#039;65&#039;],
  cincinnati: [&#039;30&#039;, &#039;32&#039;, &#039;35&#039;, &#039;36&#039;, &#039;37&#039;, &#039;38&#039;, &#039;61&#039;],
  fresno: [&#039;15&#039;, &#039;24&#039;],
  internet: [&#039;20&#039;, &#039;26&#039;, &#039;27&#039;, &#039;45&#039;, &#039;46&#039;, &#039;47&#039;],
  kansas: [&#039;40&#039;, &#039;44&#039;],
  memphis: [&#039;94&#039;, &#039;95&#039;],
  ogden: [&#039;80&#039;, &#039;90&#039;],
  philadelphia: [&#039;33&#039;, &#039;39&#039;, &#039;41&#039;, &#039;42&#039;, &#039;43&#039;, &#039;46&#039;, &#039;48&#039;, &#039;62&#039;, &#039;63&#039;, &#039;64&#039;, &#039;66&#039;, &#039;68&#039;, &#039;71&#039;, &#039;72&#039;, &#039;73&#039;, &#039;74&#039;, &#039;75&#039;, &#039;76&#039;, &#039;77&#039;, &#039;81&#039;, &#039;82&#039;, &#039;83&#039;, &#039;84&#039;, &#039;85&#039;, &#039;86&#039;, &#039;87&#039;, &#039;88&#039;, &#039;91&#039;, &#039;92&#039;, &#039;93&#039;, &#039;98&#039;, &#039;99&#039;],
  sba: [&#039;31&#039;]
};

// Return an array of all US IRS campus prefixes
function enUsGetPrefixes() {
  var prefixes = [];
  for (var location in enUsCampusPrefix) {
    // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
    // istanbul ignore else
    if (enUsCampusPrefix.hasOwnProperty(location)) {
      prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
    }
  }
  return prefixes;
}

/*
 * en-US validation function
 * Verify that the TIN starts with a valid IRS campus prefix
 */
function enUsCheck(tin) {
  return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
}

/*
 * es-AR validation function
 * Clave Única de Identificación Tributaria (CUIT/CUIL)
 * Sourced from:
 * - https://servicioscf.afip.gob.ar/publico/abc/ABCpaso2.aspx?id_nivel1=3036&amp;id_nivel2=3040&amp;p=Conceptos%20b%C3%A1sicos
 * - https://es.wikipedia.org/wiki/Clave_%C3%9Anica_de_Identificaci%C3%B3n_Tributaria
 */

function esArCheck(tin) {
  var accum = 0;
  var digits = tin.split(&#039;&#039;);
  var digit = parseInt(digits.pop(), 10);
  for (var i = 0; i &lt; digits.length; i++) {
    accum += digits[9 - i] * (2 + i % 6);
  }
  var verif = 11 - accum % 11;
  if (verif === 11) {
    verif = 0;
  } else if (verif === 10) {
    verif = 9;
  }
  return digit === verif;
}

/*
 * es-ES validation function
 * (Documento Nacional de Identidad (DNI)
 * or Número de Identificación de Extranjero (NIE), persons only)
 * Verify TIN validity by calculating check (last) character
 */
function esEsCheck(tin) {
  // Split characters into an array for further processing
  var chars = tin.toUpperCase().split(&#039;&#039;);

  // Replace initial letter if needed
  if (isNaN(parseInt(chars[0], 10)) &amp;&amp; chars.length &gt; 1) {
    var lead_replace = 0;
    switch (chars[0]) {
      case &#039;Y&#039;:
        lead_replace = 1;
        break;
      case &#039;Z&#039;:
        lead_replace = 2;
        break;
      default:
    }
    chars.splice(0, 1, lead_replace);
    // Fill with zeros if smaller than proper
  } else {
    while (chars.length &lt; 9) {
      chars.unshift(0);
    }
  }

  // Calculate checksum and check according to lookup
  var lookup = [&#039;T&#039;, &#039;R&#039;, &#039;W&#039;, &#039;A&#039;, &#039;G&#039;, &#039;M&#039;, &#039;Y&#039;, &#039;F&#039;, &#039;P&#039;, &#039;D&#039;, &#039;X&#039;, &#039;B&#039;, &#039;N&#039;, &#039;J&#039;, &#039;Z&#039;, &#039;S&#039;, &#039;Q&#039;, &#039;V&#039;, &#039;H&#039;, &#039;L&#039;, &#039;C&#039;, &#039;K&#039;, &#039;E&#039;];
  chars = chars.join(&#039;&#039;);
  var checksum = parseInt(chars.slice(0, 8), 10) % 23;
  return chars[8] === lookup[checksum];
}

/*
 * et-EE validation function
 * (Isikukood (IK), persons only)
 * Checks if birth date (century digit and six following) is valid and calculates check (last) digit
 * Material not in DG TAXUD document sourced from:
 * - `https://www.oecd.org/tax/automatic-exchange/crs-implementation-and-assistance/tax-identification-numbers/Estonia-TIN.pdf`
 */
function etEeCheck(tin) {
  // Extract year and add century
  var full_year = tin.slice(1, 3);
  var century_digit = tin.slice(0, 1);
  switch (century_digit) {
    case &#039;1&#039;:
    case &#039;2&#039;:
      full_year = &quot;18&quot;.concat(full_year);
      break;
    case &#039;3&#039;:
    case &#039;4&#039;:
      full_year = &quot;19&quot;.concat(full_year);
      break;
    default:
      full_year = &quot;20&quot;.concat(full_year);
      break;
  }
  // Check date validity
  var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(tin.slice(3, 5), &quot;/&quot;).concat(tin.slice(5, 7));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // Split digits into an array for further processing
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  var weight = 1;
  // Multiply by weight and add to checksum
  for (var i = 0; i &lt; 10; i++) {
    checksum += digits[i] * weight;
    weight += 1;
    if (weight === 10) {
      weight = 1;
    }
  }
  // Do again if modulo 11 of checksum is 10
  if (checksum % 11 === 10) {
    checksum = 0;
    weight = 3;
    for (var _i3 = 0; _i3 &lt; 10; _i3++) {
      checksum += digits[_i3] * weight;
      weight += 1;
      if (weight === 10) {
        weight = 1;
      }
    }
    if (checksum % 11 === 10) {
      return digits[10] === 0;
    }
  }
  return checksum % 11 === digits[10];
}

/*
 * fi-FI validation function
 * (Henkilötunnus (HETU), persons only)
 * Checks if birth date (first six digits plus century symbol) is valid
 * and calculates check (last) digit
 */
function fiFiCheck(tin) {
  // Extract year and add century
  var full_year = tin.slice(4, 6);
  var century_symbol = tin.slice(6, 7);
  switch (century_symbol) {
    case &#039;+&#039;:
      full_year = &quot;18&quot;.concat(full_year);
      break;
    case &#039;-&#039;:
      full_year = &quot;19&quot;.concat(full_year);
      break;
    default:
      full_year = &quot;20&quot;.concat(full_year);
      break;
  }
  // Check date validity
  var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(tin.slice(2, 4), &quot;/&quot;).concat(tin.slice(0, 2));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // Calculate check character
  var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
  if (checksum &lt; 10) {
    return checksum === parseInt(tin.slice(10), 10);
  }
  checksum -= 10;
  var letters_lookup = [&#039;A&#039;, &#039;B&#039;, &#039;C&#039;, &#039;D&#039;, &#039;E&#039;, &#039;F&#039;, &#039;H&#039;, &#039;J&#039;, &#039;K&#039;, &#039;L&#039;, &#039;M&#039;, &#039;N&#039;, &#039;P&#039;, &#039;R&#039;, &#039;S&#039;, &#039;T&#039;, &#039;U&#039;, &#039;V&#039;, &#039;W&#039;, &#039;X&#039;, &#039;Y&#039;];
  return letters_lookup[checksum] === tin.slice(10);
}

/*
 * fr/nl-BE validation function
 * (Numéro national (N.N.), persons only)
 * Checks if birth date (first six digits) is valid and calculates check (last two) digits
 */
function frBeCheck(tin) {
  // Zero month/day value is acceptable
  if (tin.slice(2, 4) !== &#039;00&#039; || tin.slice(4, 6) !== &#039;00&#039;) {
    // Extract date from first six digits of TIN
    var date = &quot;&quot;.concat(tin.slice(0, 2), &quot;/&quot;).concat(tin.slice(2, 4), &quot;/&quot;).concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, &#039;YY/MM/DD&#039;)) {
      return false;
    }
  }
  var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
  var checkdigits = parseInt(tin.slice(9, 11), 10);
  if (checksum !== checkdigits) {
    checksum = 97 - parseInt(&quot;2&quot;.concat(tin.slice(0, 9)), 10) % 97;
    if (checksum !== checkdigits) {
      return false;
    }
  }
  return true;
}

/*
 * fr-FR validation function
 * (Numéro fiscal de référence (numéro SPI), persons only)
 * Verify TIN validity by calculating check (last three) digits
 */
function frFrCheck(tin) {
  tin = tin.replace(/\s/g, &#039;&#039;);
  var checksum = parseInt(tin.slice(0, 10), 10) % 511;
  var checkdigits = parseInt(tin.slice(10, 13), 10);
  return checksum === checkdigits;
}

/*
 * fr/lb-LU validation function
 * (numéro d’identification personnelle, persons only)
 * Verify birth date validity and run Luhn and Verhoeff checks
 */
function frLuCheck(tin) {
  // Extract date and check validity
  var date = &quot;&quot;.concat(tin.slice(0, 4), &quot;/&quot;).concat(tin.slice(4, 6), &quot;/&quot;).concat(tin.slice(6, 8));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // Run Luhn check
  if (!algorithms.luhnCheck(tin.slice(0, 12))) {
    return false;
  }
  // Remove Luhn check digit and run Verhoeff check
  return algorithms.verhoeffCheck(&quot;&quot;.concat(tin.slice(0, 11)).concat(tin[12]));
}

/*
 * hr-HR validation function
 * (Osobni identifikacijski broj (OIB), persons/entities)
 * Verify TIN validity by calling iso7064Check(digits)
 */
function hrHrCheck(tin) {
  return algorithms.iso7064Check(tin);
}

/*
 * hu-HU validation function
 * (Adóazonosító jel, persons only)
 * Verify TIN validity by calculating check (last) digit
 */
function huHuCheck(tin) {
  // split digits into an array for further processing
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 8;
  for (var i = 1; i &lt; 9; i++) {
    checksum += digits[i] * (i + 1);
  }
  return checksum % 11 === digits[9];
}

/*
 * lt-LT validation function (should go here if needed)
 * (Asmens kodas, persons/entities respectively)
 * Current validation check is alias of etEeCheck- same format applies
 */

/*
 * it-IT first/last name validity check
 * Accepts it-IT TIN-encoded names as a three-element character array and checks their validity
 * Due to lack of clarity between resources (&quot;Are only Italian consonants used?
 * What happens if a person has X in their name?&quot; etc.) only two test conditions
 * have been implemented:
 * Vowels may only be followed by other vowels or an X character
 * and X characters after vowels may only be followed by other X characters.
 */
function itItNameCheck(name) {
  // true at the first occurrence of a vowel
  var vowelflag = false;

  // true at the first occurrence of an X AFTER vowel
  // (to properly handle last names with X as consonant)
  var xflag = false;
  for (var i = 0; i &lt; 3; i++) {
    if (!vowelflag &amp;&amp; /[AEIOU]/.test(name[i])) {
      vowelflag = true;
    } else if (!xflag &amp;&amp; vowelflag &amp;&amp; name[i] === &#039;X&#039;) {
      xflag = true;
    } else if (i &gt; 0) {
      if (vowelflag &amp;&amp; !xflag) {
        if (!/[AEIOU]/.test(name[i])) {
          return false;
        }
      }
      if (xflag) {
        if (!/X/.test(name[i])) {
          return false;
        }
      }
    }
  }
  return true;
}

/*
 * it-IT validation function
 * (Codice fiscale (TIN-IT), persons only)
 * Verify name, birth date and codice catastale validity
 * and calculate check character.
 * Material not in DG-TAXUD document sourced from:
 * `https://en.wikipedia.org/wiki/Italian_fiscal_code`
 */
function itItCheck(tin) {
  // Capitalize and split characters into an array for further processing
  var chars = tin.toUpperCase().split(&#039;&#039;);

  // Check first and last name validity calling itItNameCheck()
  if (!itItNameCheck(chars.slice(0, 3))) {
    return false;
  }
  if (!itItNameCheck(chars.slice(3, 6))) {
    return false;
  }

  // Convert letters in number spaces back to numbers if any
  var number_locations = [6, 7, 9, 10, 12, 13, 14];
  var number_replace = {
    L: &#039;0&#039;,
    M: &#039;1&#039;,
    N: &#039;2&#039;,
    P: &#039;3&#039;,
    Q: &#039;4&#039;,
    R: &#039;5&#039;,
    S: &#039;6&#039;,
    T: &#039;7&#039;,
    U: &#039;8&#039;,
    V: &#039;9&#039;
  };
  for (var _i4 = 0, _number_locations = number_locations; _i4 &lt; _number_locations.length; _i4++) {
    var i = _number_locations[_i4];
    if (chars[i] in number_replace) {
      chars.splice(i, 1, number_replace[chars[i]]);
    }
  }

  // Extract month and day, and check date validity
  var month_replace = {
    A: &#039;01&#039;,
    B: &#039;02&#039;,
    C: &#039;03&#039;,
    D: &#039;04&#039;,
    E: &#039;05&#039;,
    H: &#039;06&#039;,
    L: &#039;07&#039;,
    M: &#039;08&#039;,
    P: &#039;09&#039;,
    R: &#039;10&#039;,
    S: &#039;11&#039;,
    T: &#039;12&#039;
  };
  var month = month_replace[chars[8]];
  var day = parseInt(chars[9] + chars[10], 10);
  if (day &gt; 40) {
    day -= 40;
  }
  if (day &lt; 10) {
    day = &quot;0&quot;.concat(day);
  }
  var date = &quot;&quot;.concat(chars[6]).concat(chars[7], &quot;/&quot;).concat(month, &quot;/&quot;).concat(day);
  if (!(0, _isDate.default)(date, &#039;YY/MM/DD&#039;)) {
    return false;
  }

  // Calculate check character by adding up even and odd characters as numbers
  var checksum = 0;
  for (var _i5 = 1; _i5 &lt; chars.length - 1; _i5 += 2) {
    var char_to_int = parseInt(chars[_i5], 10);
    if (isNaN(char_to_int)) {
      char_to_int = chars[_i5].charCodeAt(0) - 65;
    }
    checksum += char_to_int;
  }
  var odd_convert = {
    // Maps of characters at odd places
    A: 1,
    B: 0,
    C: 5,
    D: 7,
    E: 9,
    F: 13,
    G: 15,
    H: 17,
    I: 19,
    J: 21,
    K: 2,
    L: 4,
    M: 18,
    N: 20,
    O: 11,
    P: 3,
    Q: 6,
    R: 8,
    S: 12,
    T: 14,
    U: 16,
    V: 10,
    W: 22,
    X: 25,
    Y: 24,
    Z: 23,
    0: 1,
    1: 0
  };
  for (var _i6 = 0; _i6 &lt; chars.length - 1; _i6 += 2) {
    var _char_to_int = 0;
    if (chars[_i6] in odd_convert) {
      _char_to_int = odd_convert[chars[_i6]];
    } else {
      var multiplier = parseInt(chars[_i6], 10);
      _char_to_int = 2 * multiplier + 1;
      if (multiplier &gt; 4) {
        _char_to_int += 2;
      }
    }
    checksum += _char_to_int;
  }
  if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
    return false;
  }
  return true;
}

/*
 * lv-LV validation function
 * (Personas kods (PK), persons only)
 * Check validity of birth date and calculate check (last) digit
 * Support only for old format numbers (not starting with &#039;32&#039;, issued before 2017/07/01)
 * Material not in DG TAXUD document sourced from:
 * `https://boot.ritakafija.lv/forums/index.php?/topic/88314-personas-koda-algoritms-%C4%8Deksumma/`
 */
function lvLvCheck(tin) {
  tin = tin.replace(/\W/, &#039;&#039;);
  // Extract date from TIN
  var day = tin.slice(0, 2);
  if (day !== &#039;32&#039;) {
    // No date/checksum check if new format
    var month = tin.slice(2, 4);
    if (month !== &#039;00&#039;) {
      // No date check if unknown month
      var full_year = tin.slice(4, 6);
      switch (tin[6]) {
        case &#039;0&#039;:
          full_year = &quot;18&quot;.concat(full_year);
          break;
        case &#039;1&#039;:
          full_year = &quot;19&quot;.concat(full_year);
          break;
        default:
          full_year = &quot;20&quot;.concat(full_year);
          break;
      }
      // Check date validity
      var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(tin.slice(2, 4), &quot;/&quot;).concat(day);
      if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
        return false;
      }
    }

    // Calculate check digit
    var checksum = 1101;
    var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
    for (var i = 0; i &lt; tin.length - 1; i++) {
      checksum -= parseInt(tin[i], 10) * multip_lookup[i];
    }
    return parseInt(tin[10], 10) === checksum % 11;
  }
  return true;
}

/*
 * mt-MT validation function
 * (Identity Card Number or Unique Taxpayer Reference, persons/entities)
 * Verify Identity Card Number structure (no other tests found)
 */
function mtMtCheck(tin) {
  if (tin.length !== 9) {
    // No tests for UTR
    var chars = tin.toUpperCase().split(&#039;&#039;);
    // Fill with zeros if smaller than proper
    while (chars.length &lt; 8) {
      chars.unshift(0);
    }
    // Validate format according to last character
    switch (tin[7]) {
      case &#039;A&#039;:
      case &#039;P&#039;:
        if (parseInt(chars[6], 10) === 0) {
          return false;
        }
        break;
      default:
        {
          var first_part = parseInt(chars.join(&#039;&#039;).slice(0, 5), 10);
          if (first_part &gt; 32000) {
            return false;
          }
          var second_part = parseInt(chars.join(&#039;&#039;).slice(5, 7), 10);
          if (first_part === second_part) {
            return false;
          }
        }
    }
  }
  return true;
}

/*
 * nl-NL validation function
 * (Burgerservicenummer (BSN) or Rechtspersonen Samenwerkingsverbanden Informatie Nummer (RSIN),
 * persons/entities respectively)
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function nlNlCheck(tin) {
  return algorithms.reverseMultiplyAndSum(tin.split(&#039;&#039;).slice(0, 8).map(function (a) {
    return parseInt(a, 10);
  }), 9) % 11 === parseInt(tin[8], 10);
}

/*
 * pl-PL validation function
 * (Powszechny Elektroniczny System Ewidencji Ludności (PESEL)
 * or Numer identyfikacji podatkowej (NIP), persons/entities)
 * Verify TIN validity by validating birth date (PESEL) and calculating check (last) digit
 */
function plPlCheck(tin) {
  // NIP
  if (tin.length === 10) {
    // Calculate last digit by multiplying with lookup
    var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
    var _checksum = 0;
    for (var i = 0; i &lt; lookup.length; i++) {
      _checksum += parseInt(tin[i], 10) * lookup[i];
    }
    _checksum %= 11;
    if (_checksum === 10) {
      return false;
    }
    return _checksum === parseInt(tin[9], 10);
  }

  // PESEL
  // Extract full year using month
  var full_year = tin.slice(0, 2);
  var month = parseInt(tin.slice(2, 4), 10);
  if (month &gt; 80) {
    full_year = &quot;18&quot;.concat(full_year);
    month -= 80;
  } else if (month &gt; 60) {
    full_year = &quot;22&quot;.concat(full_year);
    month -= 60;
  } else if (month &gt; 40) {
    full_year = &quot;21&quot;.concat(full_year);
    month -= 40;
  } else if (month &gt; 20) {
    full_year = &quot;20&quot;.concat(full_year);
    month -= 20;
  } else {
    full_year = &quot;19&quot;.concat(full_year);
  }
  // Add leading zero to month if needed
  if (month &lt; 10) {
    month = &quot;0&quot;.concat(month);
  }
  // Check date validity
  var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(month, &quot;/&quot;).concat(tin.slice(4, 6));
  if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }

  // Calculate last digit by multiplying with odd one-digit numbers except 5
  var checksum = 0;
  var multiplier = 1;
  for (var _i7 = 0; _i7 &lt; tin.length - 1; _i7++) {
    checksum += parseInt(tin[_i7], 10) * multiplier % 10;
    multiplier += 2;
    if (multiplier &gt; 10) {
      multiplier = 1;
    } else if (multiplier === 5) {
      multiplier += 2;
    }
  }
  checksum = 10 - checksum % 10;
  return checksum === parseInt(tin[10], 10);
}

/*
* pt-BR validation function
* (Cadastro de Pessoas Físicas (CPF, persons)
* Cadastro Nacional de Pessoas Jurídicas (CNPJ, entities)
* Both inputs will be validated
*/

function ptBrCheck(tin) {
  if (tin.length === 11) {
    var _sum;
    var remainder;
    _sum = 0;
    if (
    // Reject known invalid CPFs
    tin === &#039;11111111111&#039; || tin === &#039;22222222222&#039; || tin === &#039;33333333333&#039; || tin === &#039;44444444444&#039; || tin === &#039;55555555555&#039; || tin === &#039;66666666666&#039; || tin === &#039;77777777777&#039; || tin === &#039;88888888888&#039; || tin === &#039;99999999999&#039; || tin === &#039;00000000000&#039;) return false;
    for (var i = 1; i &lt;= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
    remainder = _sum * 10 % 11;
    if (remainder === 10) remainder = 0;
    if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;
    _sum = 0;
    for (var _i8 = 1; _i8 &lt;= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
    remainder = _sum * 10 % 11;
    if (remainder === 10) remainder = 0;
    if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;
    return true;
  }
  if (
  // Reject know invalid CNPJs
  tin === &#039;00000000000000&#039; || tin === &#039;11111111111111&#039; || tin === &#039;22222222222222&#039; || tin === &#039;33333333333333&#039; || tin === &#039;44444444444444&#039; || tin === &#039;55555555555555&#039; || tin === &#039;66666666666666&#039; || tin === &#039;77777777777777&#039; || tin === &#039;88888888888888&#039; || tin === &#039;99999999999999&#039;) {
    return false;
  }
  var length = tin.length - 2;
  var identifiers = tin.substring(0, length);
  var verificators = tin.substring(length);
  var sum = 0;
  var pos = length - 7;
  for (var _i9 = length; _i9 &gt;= 1; _i9--) {
    sum += identifiers.charAt(length - _i9) * pos;
    pos -= 1;
    if (pos &lt; 2) {
      pos = 9;
    }
  }
  var result = sum % 11 &lt; 2 ? 0 : 11 - sum % 11;
  if (result !== parseInt(verificators.charAt(0), 10)) {
    return false;
  }
  length += 1;
  identifiers = tin.substring(0, length);
  sum = 0;
  pos = length - 7;
  for (var _i10 = length; _i10 &gt;= 1; _i10--) {
    sum += identifiers.charAt(length - _i10) * pos;
    pos -= 1;
    if (pos &lt; 2) {
      pos = 9;
    }
  }
  result = sum % 11 &lt; 2 ? 0 : 11 - sum % 11;
  if (result !== parseInt(verificators.charAt(1), 10)) {
    return false;
  }
  return true;
}

/*
 * pt-PT validation function
 * (Número de identificação fiscal (NIF), persons/entities)
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function ptPtCheck(tin) {
  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split(&#039;&#039;).slice(0, 8).map(function (a) {
    return parseInt(a, 10);
  }), 9) % 11;
  if (checksum &gt; 9) {
    return parseInt(tin[8], 10) === 0;
  }
  return checksum === parseInt(tin[8], 10);
}

/*
 * ro-RO validation function
 * (Cod Numeric Personal (CNP) or Cod de înregistrare fiscală (CIF),
 * persons only)
 * Verify CNP validity by calculating check (last) digit (test not found for CIF)
 * Material not in DG TAXUD document sourced from:
 * `https://en.wikipedia.org/wiki/National_identification_number#Romania`
 */
function roRoCheck(tin) {
  if (tin.slice(0, 4) !== &#039;9000&#039;) {
    // No test found for this format
    // Extract full year using century digit if possible
    var full_year = tin.slice(1, 3);
    switch (tin[0]) {
      case &#039;1&#039;:
      case &#039;2&#039;:
        full_year = &quot;19&quot;.concat(full_year);
        break;
      case &#039;3&#039;:
      case &#039;4&#039;:
        full_year = &quot;18&quot;.concat(full_year);
        break;
      case &#039;5&#039;:
      case &#039;6&#039;:
        full_year = &quot;20&quot;.concat(full_year);
        break;
      default:
    }

    // Check date validity
    var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(tin.slice(3, 5), &quot;/&quot;).concat(tin.slice(5, 7));
    if (date.length === 8) {
      if (!(0, _isDate.default)(date, &#039;YY/MM/DD&#039;)) {
        return false;
      }
    } else if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
      return false;
    }

    // Calculate check digit
    var digits = tin.split(&#039;&#039;).map(function (a) {
      return parseInt(a, 10);
    });
    var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
    var checksum = 0;
    for (var i = 0; i &lt; multipliers.length; i++) {
      checksum += digits[i] * multipliers[i];
    }
    if (checksum % 11 === 10) {
      return digits[12] === 1;
    }
    return digits[12] === checksum % 11;
  }
  return true;
}

/*
 * sk-SK validation function
 * (Rodné číslo (RČ) or bezvýznamové identifikačné číslo (BIČ), persons only)
 * Checks validity of pre-1954 birth numbers (rodné číslo) only
 * Due to the introduction of the pseudo-random BIČ it is not possible to test
 * post-1954 birth numbers without knowing whether they are BIČ or RČ beforehand
 */
function skSkCheck(tin) {
  if (tin.length === 9) {
    tin = tin.replace(/\W/, &#039;&#039;);
    if (tin.slice(6) === &#039;000&#039;) {
      return false;
    } // Three-zero serial not assigned before 1954

    // Extract full year from TIN length
    var full_year = parseInt(tin.slice(0, 2), 10);
    if (full_year &gt; 53) {
      return false;
    }
    if (full_year &lt; 10) {
      full_year = &quot;190&quot;.concat(full_year);
    } else {
      full_year = &quot;19&quot;.concat(full_year);
    }

    // Extract month from TIN and normalize
    var month = parseInt(tin.slice(2, 4), 10);
    if (month &gt; 50) {
      month -= 50;
    }
    if (month &lt; 10) {
      month = &quot;0&quot;.concat(month);
    }

    // Check date validity
    var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(month, &quot;/&quot;).concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
      return false;
    }
  }
  return true;
}

/*
 * sl-SI validation function
 * (Davčna številka, persons/entities)
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function slSiCheck(tin) {
  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split(&#039;&#039;).slice(0, 7).map(function (a) {
    return parseInt(a, 10);
  }), 8) % 11;
  if (checksum === 10) {
    return parseInt(tin[7], 10) === 0;
  }
  return checksum === parseInt(tin[7], 10);
}

/*
 * sv-SE validation function
 * (Personnummer or samordningsnummer, persons only)
 * Checks validity of birth date and calls luhnCheck() to validate check (last) digit
 */
function svSeCheck(tin) {
  // Make copy of TIN and normalize to two-digit year form
  var tin_copy = tin.slice(0);
  if (tin.length &gt; 11) {
    tin_copy = tin_copy.slice(2);
  }

  // Extract date of birth
  var full_year = &#039;&#039;;
  var month = tin_copy.slice(2, 4);
  var day = parseInt(tin_copy.slice(4, 6), 10);
  if (tin.length &gt; 11) {
    full_year = tin.slice(0, 4);
  } else {
    full_year = tin.slice(0, 2);
    if (tin.length === 11 &amp;&amp; day &lt; 60) {
      // Extract full year from centenarian symbol
      // Should work just fine until year 10000 or so
      var current_year = new Date().getFullYear().toString();
      var current_century = parseInt(current_year.slice(0, 2), 10);
      current_year = parseInt(current_year, 10);
      if (tin[6] === &#039;-&#039;) {
        if (parseInt(&quot;&quot;.concat(current_century).concat(full_year), 10) &gt; current_year) {
          full_year = &quot;&quot;.concat(current_century - 1).concat(full_year);
        } else {
          full_year = &quot;&quot;.concat(current_century).concat(full_year);
        }
      } else {
        full_year = &quot;&quot;.concat(current_century - 1).concat(full_year);
        if (current_year - parseInt(full_year, 10) &lt; 100) {
          return false;
        }
      }
    }
  }

  // Normalize day and check date validity
  if (day &gt; 60) {
    day -= 60;
  }
  if (day &lt; 10) {
    day = &quot;0&quot;.concat(day);
  }
  var date = &quot;&quot;.concat(full_year, &quot;/&quot;).concat(month, &quot;/&quot;).concat(day);
  if (date.length === 8) {
    if (!(0, _isDate.default)(date, &#039;YY/MM/DD&#039;)) {
      return false;
    }
  } else if (!(0, _isDate.default)(date, &#039;YYYY/MM/DD&#039;)) {
    return false;
  }
  return algorithms.luhnCheck(tin.replace(/\W/, &#039;&#039;));
}

/**
 * uk-UA validation function
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function ukUaCheck(tin) {
  // Calculate check digit
  var digits = tin.split(&#039;&#039;).map(function (a) {
    return parseInt(a, 10);
  });
  var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
  var checksum = 0;
  for (var i = 0; i &lt; multipliers.length; i++) {
    checksum += digits[i] * multipliers[i];
  }
  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;
}

// Locale lookup objects

/*
 * Tax id regex formats for various locales
 *
 * Where not explicitly specified in DG-TAXUD document both
 * uppercase and lowercase letters are acceptable.
 */
var taxIdFormat = {
  &#039;bg-BG&#039;: /^\d{10}$/,
  &#039;cs-CZ&#039;: /^\d{6}\/{0,1}\d{3,4}$/,
  &#039;de-AT&#039;: /^\d{9}$/,
  &#039;de-DE&#039;: /^[1-9]\d{10}$/,
  &#039;dk-DK&#039;: /^\d{6}-{0,1}\d{4}$/,
  &#039;el-CY&#039;: /^[09]\d{7}[A-Z]$/,
  &#039;el-GR&#039;: /^([0-4]|[7-9])\d{8}$/,
  &#039;en-CA&#039;: /^\d{9}$/,
  &#039;en-GB&#039;: /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
  &#039;en-IE&#039;: /^\d{7}[A-W][A-IW]{0,1}$/i,
  &#039;en-US&#039;: /^\d{2}[- ]{0,1}\d{7}$/,
  &#039;es-AR&#039;: /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
  &#039;es-ES&#039;: /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
  &#039;et-EE&#039;: /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
  &#039;fi-FI&#039;: /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
  &#039;fr-BE&#039;: /^\d{11}$/,
  &#039;fr-FR&#039;: /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
  // Conforms both to official spec and provided example
  &#039;fr-LU&#039;: /^\d{13}$/,
  &#039;hr-HR&#039;: /^\d{11}$/,
  &#039;hu-HU&#039;: /^8\d{9}$/,
  &#039;it-IT&#039;: /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
  &#039;lv-LV&#039;: /^\d{6}-{0,1}\d{5}$/,
  // Conforms both to DG TAXUD spec and original research
  &#039;mt-MT&#039;: /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
  &#039;nl-NL&#039;: /^\d{9}$/,
  &#039;pl-PL&#039;: /^\d{10,11}$/,
  &#039;pt-BR&#039;: /(?:^\d{11}$)|(?:^\d{14}$)/,
  &#039;pt-PT&#039;: /^\d{9}$/,
  &#039;ro-RO&#039;: /^\d{13}$/,
  &#039;sk-SK&#039;: /^\d{6}\/{0,1}\d{3,4}$/,
  &#039;sl-SI&#039;: /^[1-9]\d{7}$/,
  &#039;sv-SE&#039;: /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
  &#039;uk-UA&#039;: /^\d{10}$/
};
// taxIdFormat locale aliases
taxIdFormat[&#039;lb-LU&#039;] = taxIdFormat[&#039;fr-LU&#039;];
taxIdFormat[&#039;lt-LT&#039;] = taxIdFormat[&#039;et-EE&#039;];
taxIdFormat[&#039;nl-BE&#039;] = taxIdFormat[&#039;fr-BE&#039;];
taxIdFormat[&#039;fr-CA&#039;] = taxIdFormat[&#039;en-CA&#039;];

// Algorithmic tax id check functions for various locales
var taxIdCheck = {
  &#039;bg-BG&#039;: bgBgCheck,
  &#039;cs-CZ&#039;: csCzCheck,
  &#039;de-AT&#039;: deAtCheck,
  &#039;de-DE&#039;: deDeCheck,
  &#039;dk-DK&#039;: dkDkCheck,
  &#039;el-CY&#039;: elCyCheck,
  &#039;el-GR&#039;: elGrCheck,
  &#039;en-CA&#039;: isCanadianSIN,
  &#039;en-IE&#039;: enIeCheck,
  &#039;en-US&#039;: enUsCheck,
  &#039;es-AR&#039;: esArCheck,
  &#039;es-ES&#039;: esEsCheck,
  &#039;et-EE&#039;: etEeCheck,
  &#039;fi-FI&#039;: fiFiCheck,
  &#039;fr-BE&#039;: frBeCheck,
  &#039;fr-FR&#039;: frFrCheck,
  &#039;fr-LU&#039;: frLuCheck,
  &#039;hr-HR&#039;: hrHrCheck,
  &#039;hu-HU&#039;: huHuCheck,
  &#039;it-IT&#039;: itItCheck,
  &#039;lv-LV&#039;: lvLvCheck,
  &#039;mt-MT&#039;: mtMtCheck,
  &#039;nl-NL&#039;: nlNlCheck,
  &#039;pl-PL&#039;: plPlCheck,
  &#039;pt-BR&#039;: ptBrCheck,
  &#039;pt-PT&#039;: ptPtCheck,
  &#039;ro-RO&#039;: roRoCheck,
  &#039;sk-SK&#039;: skSkCheck,
  &#039;sl-SI&#039;: slSiCheck,
  &#039;sv-SE&#039;: svSeCheck,
  &#039;uk-UA&#039;: ukUaCheck
};
// taxIdCheck locale aliases
taxIdCheck[&#039;lb-LU&#039;] = taxIdCheck[&#039;fr-LU&#039;];
taxIdCheck[&#039;lt-LT&#039;] = taxIdCheck[&#039;et-EE&#039;];
taxIdCheck[&#039;nl-BE&#039;] = taxIdCheck[&#039;fr-BE&#039;];
taxIdCheck[&#039;fr-CA&#039;] = taxIdCheck[&#039;en-CA&#039;];

// Regexes for locales where characters should be omitted before checking format
var allsymbols = /[-\\\/!@#$%\^&amp;\*\(\)\+\=\[\]]+/g;
var sanitizeRegexes = {
  &#039;de-AT&#039;: allsymbols,
  &#039;de-DE&#039;: /[\/\\]/g,
  &#039;fr-BE&#039;: allsymbols
};
// sanitizeRegexes locale aliases
sanitizeRegexes[&#039;nl-BE&#039;] = sanitizeRegexes[&#039;fr-BE&#039;];

/*
 * Validator function
 * Return true if the passed string is a valid tax identification number
 * for the specified locale.
 * Throw an error exception if the locale is not supported.
 */
function isTaxID(str) {
  var locale = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#039;en-US&#039;;
  (0, _assertString.default)(str);
  // Copy TIN to avoid replacement if sanitized
  var strcopy = str.slice(0);
  if (locale in taxIdFormat) {
    if (locale in sanitizeRegexes) {
      strcopy = strcopy.replace(sanitizeRegexes[locale], &#039;&#039;);
    }
    if (!taxIdFormat[locale].test(strcopy)) {
      return false;
    }
    if (locale in taxIdCheck) {
      return taxIdCheck[locale](strcopy);
    }
    // Fallthrough; not all locales have algorithmic checks
    return true;
  }
  throw new Error(&quot;Invalid locale &#039;&quot;.concat(locale, &quot;&#039;&quot;));
}
module.exports = exports.default;
module.exports.default = exports.default;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
