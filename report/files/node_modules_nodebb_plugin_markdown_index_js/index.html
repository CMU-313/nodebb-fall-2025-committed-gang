<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-plugin-markdown/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-plugin-markdown/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">432</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">44.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.30</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const MarkdownIt = require(&#039;markdown-it&#039;);
const fs = require(&#039;fs&#039;);
const path = require(&#039;path&#039;);

const nconf = require.main.require(&#039;nconf&#039;);
const winston = require.main.require(&#039;winston&#039;);
const meta = require.main.require(&#039;./src/meta&#039;);
const activitypub = require.main.require(&#039;./src/activitypub&#039;);
const plugins = require.main.require(&#039;./src/plugins&#039;);

const SocketPlugins = require.main.require(&#039;./src/socket.io/plugins&#039;);
SocketPlugins.markdown = require(&#039;./websockets&#039;);

let parser;
let app;
const Markdown = {
	config: {},
	onLoad: async function (params) {
		app = params.app;
		const { router } = params;
		const controllers = require(&#039;./lib/controllers&#039;);
		const hostMiddleware = require.main.require(&#039;./src/middleware&#039;);
		const routeHelpers = require.main.require(&#039;./src/routes/helpers&#039;);
		const middlewares = [
			hostMiddleware.maintenanceMode, hostMiddleware.registrationComplete, hostMiddleware.pluginHooks,
		];

		routeHelpers.setupAdminPageRoute(router, &#039;/admin/plugins/markdown&#039;, controllers.renderAdmin);

		// Return raw markdown via GET
		router.get(&#039;/api/post/:pid/raw&#039;, middlewares, controllers.retrieveRaw);

		Markdown.init();
		await Markdown.loadThemes();
	},

	getConfig: async (config) =&gt; {
		let { defaultHighlightLanguage, highlightTheme, hljsLanguages, highlightLinesLanguageList, externalMark } = await meta.settings.get(&#039;markdown&#039;);

		try {
			hljsLanguages = JSON.parse(hljsLanguages);
		} catch (e) {
			hljsLanguages = [&#039;common&#039;];
		}

		config.markdown = {
			highlight: Markdown.highlight ? 1 : 0,
			highlightLinesLanguageList,
			hljsLanguages,
			theme: highlightTheme || &#039;default.css&#039;,
			defaultHighlightLanguage: defaultHighlightLanguage || &#039;&#039;,
			externalMark: externalMark === &#039;on&#039;,
		};

		return config;
	},

	getLinkTags: async (hookData) =&gt; {
		const { highlightTheme } = await meta.settings.get(&#039;markdown&#039;);

		hookData.links.push({
			rel: &#039;prefetch stylesheet&#039;,
			type: &#039;&#039;,
			href: `${nconf.get(&#039;relative_path&#039;)}/assets/plugins/nodebb-plugin-markdown/styles/${highlightTheme || &#039;default.css&#039;}`,
		}, {
			rel: &#039;prefetch&#039;,
			href: `${nconf.get(&#039;relative_path&#039;)}/assets/language/${meta.config.defaultLang || &#039;en-GB&#039;}/markdown.json?${meta.config[&#039;cache-buster&#039;]}`,
		});

		return hookData;
	},

	init: function () {
		// Load saved config
		const _self = this;
		const defaults = {
			html: false,

			langPrefix: &#039;language-&#039;,
			highlight: true,
			highlightTheme: &#039;default.css&#039;,

			xhtmlOut: true,
			breaks: true,
			linkify: true,
			typographer: false,
			externalBlank: false,
			nofollow: true,
			allowRTLO: false,
			checkboxes: true,
			multimdTables: true,
		};
		const notCheckboxes = [&#039;langPrefix&#039;, &#039;highlightTheme&#039;];

		meta.settings.get(&#039;markdown&#039;, (err, options) =&gt; {
			if (err) {
				winston.warn(`[plugin/markdown] Unable to retrieve settings, assuming defaults: ${err.message}`);
			}

			Object.keys(defaults).forEach((field) =&gt; {
				// If not set in config (nil)
				if (!options.hasOwnProperty(field)) {
					_self.config[field] = defaults[field];
				} else if (!notCheckboxes.includes(field)) {
					_self.config[field] = options[field] === &#039;on&#039;;
				} else {
					_self.config[field] = options[field];
				}
			});

			_self.highlight = _self.config.highlight;
			delete _self.config.highlight;

			parser = new MarkdownIt(_self.config);

			Markdown.updateParserRules(parser);
		});
	},

	loadThemes: async () =&gt; {
		try {
			const files = await fs.promises.readdir(path.join(require.resolve(&#039;highlight.js&#039;), &#039;../../styles&#039;));
			const isStylesheet = /\.css$/;
			Markdown.themes = files.filter(file =&gt; isStylesheet.test(file));
		} catch (err) {
			winston.error(`[plugin/markdown] Could not load Markdown themes: ${err.message}`);
			Markdown.themes = [];
		}
	},

	parsePost: async function (data) {
		const env = await Markdown.beforeParse(data);
		if (env.parse &amp;&amp; data &amp;&amp; data.postData &amp;&amp; data.postData.content &amp;&amp; parser) {
			data.postData.content = parser.render(data.postData.content, env || {});
		}

		return Markdown.afterParse(data);
	},

	parseSignature: async function (data) {
		if (data &amp;&amp; data.userData &amp;&amp; data.userData.signature &amp;&amp; parser) {
			data.userData.signature = parser.render(data.userData.signature);
		}
		return Markdown.afterParse(data);
	},

	parseAboutMe: async function (aboutme) {
		aboutme = (aboutme &amp;&amp; parser) ? parser.render(aboutme) : aboutme;
		// process.nextTick(next, null, aboutme);
		return Markdown.afterParse(aboutme);
	},

	parseRaw: async function (raw) {
		raw = (raw &amp;&amp; parser) ? parser.render(raw) : raw;
		return Markdown.afterParse(raw);
	},

	beforeParse: async (data) =&gt; {
		let env = {
			parse: true,
			type: data.type,
			images: new Map(), // is this still used?
		};

		({ env } = await plugins.hooks.fire(&#039;filter:markdown.beforeParse&#039;, { env, data: Object.freeze({ ...data }) }));

		if (data.type === &#039;markdown&#039;) {
			// core is expecting markdown to come back, bypass parsing
			env.parse = false;
		} else if (activitypub.helpers.isUri(data.postData.pid)) {
			if (data.postData.sourceContent) {
				data.content = data.sourceContent;
				delete data.sourceContent;
			} else {
				// content contained is likely already html, bypass parsing
				env.parse = false;
			}
		}

		return env;
	},

	afterParse: function (payload) {
		if (!payload) {
			return payload;
		}
		const italicMention = /@&lt;em&gt;([^&lt;]+)&lt;\/em&gt;/g;
		const boldMention = /@&lt;strong&gt;([^&lt;]+)&lt;\/strong&gt;/g;
		const execute = function (html) {
			// Replace all italicised mentions back to regular mentions
			if (italicMention.test(html)) {
				html = html.replace(italicMention, (match, slug) =&gt; `@_${slug}_`);
			} else if (boldMention.test(html)) {
				html = html.replace(boldMention, (match, slug) =&gt; `@__${slug}__`);
			}

			return html;
		};

		if (payload.hasOwnProperty(&#039;postData&#039;)) {
			payload.postData.content = execute(payload.postData.content);
		} else if (payload.hasOwnProperty(&#039;userData&#039;)) {
			payload.userData.signature = execute(payload.userData.signature);
		} else {
			payload = execute(payload);
		}

		return payload;
	},

	renderHelp: async function (helpContent) {
		const html = await app.renderAsync(&#039;modals/markdown-help&#039;, {});
		helpContent += html;
		return helpContent;
	},

	registerFormatting: async function (payload) {
		const formatting = [
			{ name: &#039;bold&#039;, className: &#039;fa fa-bold&#039;, title: &#039;[[modules:composer.formatting.bold]]&#039; },
			{ name: &#039;italic&#039;, className: &#039;fa fa-italic&#039;, title: &#039;[[modules:composer.formatting.italic]]&#039; },
			{
				className: &#039;fa fa-heading&#039;,
				title: &#039;[[modules:composer.formatting.heading]]&#039;,
				dropdownItems: [
					{ name: &#039;heading1&#039;, text: &#039;[[modules:composer.formatting.heading1]]&#039; },
					{ name: &#039;heading2&#039;, text: &#039;[[modules:composer.formatting.heading2]]&#039; },
					{ name: &#039;heading3&#039;, text: &#039;[[modules:composer.formatting.heading3]]&#039; },
					{ name: &#039;heading4&#039;, text: &#039;[[modules:composer.formatting.heading4]]&#039; },
					{ name: &#039;heading5&#039;, text: &#039;[[modules:composer.formatting.heading5]]&#039; },
					{ name: &#039;heading6&#039;, text: &#039;[[modules:composer.formatting.heading6]]&#039; },
				],
			},
			{ name: &#039;list&#039;, className: &#039;fa fa-list-ul&#039;, title: &#039;[[modules:composer.formatting.list]]&#039; },
			{ name: &#039;strikethrough&#039;, className: &#039;fa fa-strikethrough&#039;, title: &#039;[[modules:composer.formatting.strikethrough]]&#039; },
			{ name: &#039;code&#039;, className: &#039;fa fa-code&#039;, title: &#039;[[modules:composer.formatting.code]]&#039; },
			{ name: &#039;link&#039;, className: &#039;fa fa-link&#039;, title: &#039;[[modules:composer.formatting.link]]&#039; },
			{ name: &#039;picture-o&#039;, className: &#039;fa fa-picture-o&#039;, title: &#039;[[modules:composer.formatting.picture]]&#039; },
		];

		payload.options = formatting.concat(payload.options);

		return payload;
	},

	updateSanitizeConfig: async (config) =&gt; {
		config.allowedTags.push(&#039;input&#039;);
		config.allowedAttributes.input = [&#039;type&#039;, &#039;checked&#039;];
		config.allowedAttributes.ol.push(&#039;start&#039;);
		config.allowedAttributes.th.push(&#039;colspan&#039;, &#039;rowspan&#039;);
		config.allowedAttributes.td.push(&#039;colspan&#039;, &#039;rowspan&#039;);

		return config;
	},

	updateParserRules: function (parser) {
		if (Markdown.config.checkboxes) {
			// Add support for checkboxes
			parser.use(require(&#039;markdown-it-checkbox&#039;), {
				divWrap: true,
				divClass: &#039;plugin-markdown&#039;,
			});
		}

		if (Markdown.config.multimdTables) {
			parser.use(require(&#039;markdown-it-multimd-table&#039;), {
				multiline: true,
				rowspan: true,
				headerless: true,
			});
		}

		parser.use((md) =&gt; {
			md.core.ruler.before(&#039;linkify&#039;, &#039;autodir&#039;, (state) =&gt; {
				state.tokens.forEach((token) =&gt; {
					if (token.type === &#039;paragraph_open&#039;) {
						token.attrJoin(&#039;dir&#039;, &#039;auto&#039;);
					}
				});
			});
		});

		// Update renderer to add some classes to all images
		const renderImage = parser.renderer.rules.image || function (tokens, idx, options, env, self) {
			return self.renderToken.apply(self, arguments);
		};
		const renderLink = parser.renderer.rules.link_open || function (tokens, idx, options, env, self) {
			return self.renderToken.apply(self, arguments);
		};
		const renderTable = parser.renderer.rules.table_open || function (tokens, idx, options, env, self) {
			return self.renderToken.apply(self, arguments);
		};

		parser.renderer.rules.image = function (tokens, idx, options, env, self) {
			const token = tokens[idx];
			const attributes = new Map(token.attrs);
			if (env.type === &#039;plaintext&#039;) {
				const filename = path.basename(attributes.get(&#039;src&#039;));
				return `[image: ${filename}]`;
			}

			// Validate the url
			if (!Markdown.isUrlValid(attributes.get(&#039;src&#039;))) { return &#039;&#039;; }

			token.attrSet(&#039;class&#039;, `${token.attrGet(&#039;class&#039;) || &#039;&#039;} img-fluid img-markdown`);

			return renderImage(tokens, idx, options, env, self);
		};

		parser.renderer.rules.link_open = function (tokens, idx, options, env, self) {
			if (env.type === &#039;plaintext&#039;) {
				return &#039;&#039;;
			}

			const attributes = new Map(tokens[idx].attrs);

			if (attributes.has(&#039;href&#039;) &amp;&amp; Markdown.isExternalLink(attributes.get(&#039;href&#039;))) {
				const rel = [];
				if (Markdown.config.externalBlank) {
					attributes.set(&#039;target&#039;, &#039;_blank&#039;);
					rel.push(&#039;noopener&#039;, &#039;noreferrer&#039;);
				}

				if (Markdown.config.nofollow) {
					rel.push(&#039;nofollow&#039;, &#039;ugc&#039;);
				}

				attributes.set(&#039;rel&#039;, rel.join(&#039; &#039;));
			}

			// Clearly indicate hidden links
			if (tokens[idx + 1].type === &#039;link_close&#039;) {
				attributes.set(&#039;class&#039;, String(`${attributes.get(&#039;class&#039;) || &#039;&#039;} plugin-markdown-hidden-link small link-danger`).trim());
			}

			if (!Markdown.config.allowRTLO) {
				if (tokens[idx + 1] &amp;&amp; tokens[idx + 1].type === &#039;text&#039;) {
					if (tokens[idx + 1].content.match(Markdown.regexes.rtl_override)) {
						tokens[idx + 1].content = tokens[idx + 1].content.replace(Markdown.regexes.rtl_override, &#039;&#039;);
					}
				}
			}

			tokens[idx].attrs = Array.from(attributes);
			return renderLink(tokens, idx, options, env, self);
		};

		parser.renderer.rules.link_close = function (...args) {
			const [,,, env, self] = args;
			if (env === &#039;plaintext&#039;) {
				return &#039;&#039;;
			}

			return self.renderToken(...args);
		};

		parser.renderer.rules.table_open = function (tokens, idx, options, env, self) {
			const classIdx = tokens[idx].attrIndex(&#039;class&#039;);

			if (classIdx &lt; 0) {
				tokens[idx].attrPush([&#039;class&#039;, &#039;table table-bordered table-striped&#039;]);
			} else {
				tokens[idx].attrs[classIdx][1] += &#039; table table-bordered table-striped&#039;;
			}

			return renderTable(tokens, idx, options, env, self);
		};

		plugins.hooks.fire(&#039;action:markdown.updateParserRules&#039;, parser);
	},

	isUrlValid: function (src) {
		/**
		 * Images linking to a relative path are only allowed from the root prefixes
		 * defined in allowedRoots. We allow both with and without relative_path
		 * even though upload_url should handle it, because sometimes installs
		 * migrate to (non-)subfolder and switch mid-way, but the uploads urls don&#039;t
		 * get updated.
		 */
		const allowedRoots = [nconf.get(&#039;upload_url&#039;), &#039;/uploads&#039;];
		const allowed = pathname =&gt; allowedRoots.some(root =&gt; pathname.toString().startsWith(root) || pathname.toString().startsWith(nconf.get(&#039;relative_path&#039;) + root));

		try {
			const urlObj = new URL(src, nconf.get(&#039;url&#039;));
			return !(urlObj.host === null &amp;&amp; !allowed(urlObj.pathname));
		} catch (e) {
			return false;
		}
	},

	isExternalLink: function (urlString) {
		let urlObj;
		let baseUrlObj;
		try {
			urlObj = new URL(urlString, nconf.get(&#039;url&#039;));
			baseUrlObj = nconf.get(&#039;url_parsed&#039;);
		} catch (err) {
			return false;
		}

		if (
			urlObj.host === null || // Relative paths are always internal links...
			(
				urlObj.host === baseUrlObj.host &amp;&amp;
				urlObj.protocol === baseUrlObj.protocol &amp;&amp; // Otherwise need to check that protocol and host match
				(nconf.get(&#039;relative_path&#039;).length &gt; 0 ? urlObj.pathname.indexOf(nconf.get(&#039;relative_path&#039;)) === 0 : true) // Subfolder installs need this additional check
			)
		) {
			return false;
		}
		return true;
	},

	admin: {
		menu: async function (custom_header) {
			custom_header.plugins.push({
				route: &#039;/plugins/markdown&#039;,
				icon: &#039;fa-edit&#039;,
				name: &#039;Markdown&#039;,
			});
			return custom_header;
		},
	},

	regexes: {
		rtl_override: /\u202E/gi,
	},
};

module.exports = Markdown;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
