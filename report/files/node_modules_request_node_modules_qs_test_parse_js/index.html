<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/request/node_modules/qs/test/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/request/node_modules/qs/test/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">650</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var test = require(&#039;tape&#039;);
var qs = require(&#039;../&#039;);
var utils = require(&#039;../lib/utils&#039;);
var iconv = require(&#039;iconv-lite&#039;);
var SaferBuffer = require(&#039;safer-buffer&#039;).Buffer;

test(&#039;parse()&#039;, function (t) {
    t.test(&#039;parses a simple string&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;0=foo&#039;), { 0: &#039;foo&#039; });
        st.deepEqual(qs.parse(&#039;foo=c++&#039;), { foo: &#039;c  &#039; });
        st.deepEqual(qs.parse(&#039;a[&gt;=]=23&#039;), { a: { &#039;&gt;=&#039;: &#039;23&#039; } });
        st.deepEqual(qs.parse(&#039;a[&lt;=&gt;]==23&#039;), { a: { &#039;&lt;=&gt;&#039;: &#039;=23&#039; } });
        st.deepEqual(qs.parse(&#039;a[==]=23&#039;), { a: { &#039;==&#039;: &#039;23&#039; } });
        st.deepEqual(qs.parse(&#039;foo&#039;, { strictNullHandling: true }), { foo: null });
        st.deepEqual(qs.parse(&#039;foo&#039;), { foo: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=&#039;), { foo: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&#039;), { foo: &#039;bar&#039; });
        st.deepEqual(qs.parse(&#039; foo = bar = baz &#039;), { &#039; foo &#039;: &#039; bar = baz &#039; });
        st.deepEqual(qs.parse(&#039;foo=bar=baz&#039;), { foo: &#039;bar=baz&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&amp;bar=baz&#039;), { foo: &#039;bar&#039;, bar: &#039;baz&#039; });
        st.deepEqual(qs.parse(&#039;foo2=bar2&amp;baz2=&#039;), { foo2: &#039;bar2&#039;, baz2: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&amp;baz&#039;, { strictNullHandling: true }), { foo: &#039;bar&#039;, baz: null });
        st.deepEqual(qs.parse(&#039;foo=bar&amp;baz&#039;), { foo: &#039;bar&#039;, baz: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;cht=p3&amp;chd=t:60,40&amp;chs=250x100&amp;chl=Hello|World&#039;), {
            cht: &#039;p3&#039;,
            chd: &#039;t:60,40&#039;,
            chs: &#039;250x100&#039;,
            chl: &#039;Hello|World&#039;
        });
        st.end();
    });

    t.test(&#039;allows enabling dot notation&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a.b=c&#039;), { &#039;a.b&#039;: &#039;c&#039; });
        st.deepEqual(qs.parse(&#039;a.b=c&#039;, { allowDots: true }), { a: { b: &#039;c&#039; } });
        st.end();
    });

    t.deepEqual(qs.parse(&#039;a[b]=c&#039;), { a: { b: &#039;c&#039; } }, &#039;parses a single nested string&#039;);
    t.deepEqual(qs.parse(&#039;a[b][c]=d&#039;), { a: { b: { c: &#039;d&#039; } } }, &#039;parses a double nested string&#039;);
    t.deepEqual(
        qs.parse(&#039;a[b][c][d][e][f][g][h]=i&#039;),
        { a: { b: { c: { d: { e: { f: { &#039;[g][h]&#039;: &#039;i&#039; } } } } } } },
        &#039;defaults to a depth of 5&#039;
    );

    t.test(&#039;only parses one level when depth = 1&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[b][c]=d&#039;, { depth: 1 }), { a: { b: { &#039;[c]&#039;: &#039;d&#039; } } });
        st.deepEqual(qs.parse(&#039;a[b][c][d]=e&#039;, { depth: 1 }), { a: { b: { &#039;[c][d]&#039;: &#039;e&#039; } } });
        st.end();
    });

    t.deepEqual(qs.parse(&#039;a=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] }, &#039;parses a simple array&#039;);

    t.test(&#039;parses an explicit array&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[]=b&#039;), { a: [&#039;b&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=c&amp;a[]=d&#039;), { a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] });
        st.end();
    });

    t.test(&#039;parses a mix of simple and explicit arrays&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a[0]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });

        st.deepEqual(qs.parse(&#039;a[1]=b&amp;a=c&#039;, { arrayLimit: 20 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a=c&#039;, { arrayLimit: 0 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });

        st.deepEqual(qs.parse(&#039;a=b&amp;a[1]=c&#039;, { arrayLimit: 20 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a[]=c&#039;, { arrayLimit: 0 }), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a=b&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });

        st.end();
    });

    t.test(&#039;parses a nested array&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[b][]=c&amp;a[b][]=d&#039;), { a: { b: [&#039;c&#039;, &#039;d&#039;] } });
        st.deepEqual(qs.parse(&#039;a[&gt;=]=25&#039;), { a: { &#039;&gt;=&#039;: &#039;25&#039; } });
        st.end();
    });

    t.test(&#039;allows to specify array indices&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[1]=c&amp;a[0]=b&amp;a[2]=d&#039;), { a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] });
        st.deepEqual(qs.parse(&#039;a[1]=c&amp;a[0]=b&#039;), { a: [&#039;b&#039;, &#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[1]=c&#039;, { arrayLimit: 20 }), { a: [&#039;c&#039;] });
        st.deepEqual(qs.parse(&#039;a[1]=c&#039;, { arrayLimit: 0 }), { a: { 1: &#039;c&#039; } });
        st.deepEqual(qs.parse(&#039;a[1]=c&#039;), { a: [&#039;c&#039;] });
        st.end();
    });

    t.test(&#039;limits specific array indices to arrayLimit&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[20]=a&#039;, { arrayLimit: 20 }), { a: [&#039;a&#039;] });
        st.deepEqual(qs.parse(&#039;a[21]=a&#039;, { arrayLimit: 20 }), { a: { 21: &#039;a&#039; } });
        st.end();
    });

    t.deepEqual(qs.parse(&#039;a[12b]=c&#039;), { a: { &#039;12b&#039;: &#039;c&#039; } }, &#039;supports keys that begin with a number&#039;);

    t.test(&#039;supports encoded = signs&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;he%3Dllo=th%3Dere&#039;), { &#039;he=llo&#039;: &#039;th=ere&#039; });
        st.end();
    });

    t.test(&#039;is ok with url encoded strings&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[b%20c]=d&#039;), { a: { &#039;b c&#039;: &#039;d&#039; } });
        st.deepEqual(qs.parse(&#039;a[b]=c%20d&#039;), { a: { b: &#039;c d&#039; } });
        st.end();
    });

    t.test(&#039;allows brackets in the value&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;pets=[&quot;tobi&quot;]&#039;), { pets: &#039;[&quot;tobi&quot;]&#039; });
        st.deepEqual(qs.parse(&#039;operators=[&quot;&gt;=&quot;, &quot;&lt;=&quot;]&#039;), { operators: &#039;[&quot;&gt;=&quot;, &quot;&lt;=&quot;]&#039; });
        st.end();
    });

    t.test(&#039;allows empty values&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;&#039;), {});
        st.deepEqual(qs.parse(null), {});
        st.deepEqual(qs.parse(undefined), {});
        st.end();
    });

    t.test(&#039;transforms arrays to objects&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo[0]=bar&amp;foo[bad]=baz&#039;), { foo: { 0: &#039;bar&#039;, bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[bad]=baz&amp;foo[0]=bar&#039;), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo[bad]=baz&amp;foo[]=bar&#039;), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo[]=bar&amp;foo[bad]=baz&#039;), { foo: { 0: &#039;bar&#039;, bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[bad]=baz&amp;foo[]=bar&amp;foo[]=foo&#039;), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039;, 1: &#039;foo&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0][a]=a&amp;foo[0][b]=b&amp;foo[1][a]=aa&amp;foo[1][b]=bb&#039;), { foo: [{ a: &#039;a&#039;, b: &#039;b&#039; }, { a: &#039;aa&#039;, b: &#039;bb&#039; }] });

        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[t]=u&amp;a[hasOwnProperty]=c&#039;, { allowPrototypes: false }), { a: { 0: &#039;b&#039;, t: &#039;u&#039; } });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[t]=u&amp;a[hasOwnProperty]=c&#039;, { allowPrototypes: true }), { a: { 0: &#039;b&#039;, t: &#039;u&#039;, hasOwnProperty: &#039;c&#039; } });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[hasOwnProperty]=c&amp;a[x]=y&#039;, { allowPrototypes: false }), { a: { 0: &#039;b&#039;, x: &#039;y&#039; } });
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[hasOwnProperty]=c&amp;a[x]=y&#039;, { allowPrototypes: true }), { a: { 0: &#039;b&#039;, hasOwnProperty: &#039;c&#039;, x: &#039;y&#039; } });
        st.end();
    });

    t.test(&#039;transforms arrays to objects (dot notation)&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;foo[0].baz=bar&amp;fool.bad=baz&#039;, { allowDots: true }), { foo: [{ baz: &#039;bar&#039; }], fool: { bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0].baz=bar&amp;fool.bad.boo=baz&#039;, { allowDots: true }), { foo: [{ baz: &#039;bar&#039; }], fool: { bad: { boo: &#039;baz&#039; } } });
        st.deepEqual(qs.parse(&#039;foo[0][0].baz=bar&amp;fool.bad=baz&#039;, { allowDots: true }), { foo: [[{ baz: &#039;bar&#039; }]], fool: { bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0].baz[0]=15&amp;foo[0].bar=2&#039;, { allowDots: true }), { foo: [{ baz: [&#039;15&#039;], bar: &#039;2&#039; }] });
        st.deepEqual(qs.parse(&#039;foo[0].baz[0]=15&amp;foo[0].baz[1]=16&amp;foo[0].bar=2&#039;, { allowDots: true }), { foo: [{ baz: [&#039;15&#039;, &#039;16&#039;], bar: &#039;2&#039; }] });
        st.deepEqual(qs.parse(&#039;foo.bad=baz&amp;foo[0]=bar&#039;, { allowDots: true }), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo.bad=baz&amp;foo[]=bar&#039;, { allowDots: true }), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039; } });
        st.deepEqual(qs.parse(&#039;foo[]=bar&amp;foo.bad=baz&#039;, { allowDots: true }), { foo: { 0: &#039;bar&#039;, bad: &#039;baz&#039; } });
        st.deepEqual(qs.parse(&#039;foo.bad=baz&amp;foo[]=bar&amp;foo[]=foo&#039;, { allowDots: true }), { foo: { bad: &#039;baz&#039;, 0: &#039;bar&#039;, 1: &#039;foo&#039; } });
        st.deepEqual(qs.parse(&#039;foo[0].a=a&amp;foo[0].b=b&amp;foo[1].a=aa&amp;foo[1].b=bb&#039;, { allowDots: true }), { foo: [{ a: &#039;a&#039;, b: &#039;b&#039; }, { a: &#039;aa&#039;, b: &#039;bb&#039; }] });
        st.end();
    });

    t.test(&#039;correctly prunes undefined values when converting an array to an object&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[2]=b&amp;a[99999999]=c&#039;), { a: { 2: &#039;b&#039;, 99999999: &#039;c&#039; } });
        st.end();
    });

    t.test(&#039;supports malformed uri characters&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;{%:%}&#039;, { strictNullHandling: true }), { &#039;{%:%}&#039;: null });
        st.deepEqual(qs.parse(&#039;{%:%}=&#039;), { &#039;{%:%}&#039;: &#039;&#039; });
        st.deepEqual(qs.parse(&#039;foo=%:%}&#039;), { foo: &#039;%:%}&#039; });
        st.end();
    });

    t.test(&#039;doesn\&#039;t produce empty keys&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;_r=1&amp;&#039;), { _r: &#039;1&#039; });
        st.end();
    });

    t.test(&#039;cannot access Object prototype&#039;, function (st) {
        qs.parse(&#039;constructor[prototype][bad]=bad&#039;);
        qs.parse(&#039;bad[constructor][prototype][bad]=bad&#039;);
        st.equal(typeof Object.prototype.bad, &#039;undefined&#039;);
        st.end();
    });

    t.test(&#039;parses arrays of objects&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[][b]=c&#039;), { a: [{ b: &#039;c&#039; }] });
        st.deepEqual(qs.parse(&#039;a[0][b]=c&#039;), { a: [{ b: &#039;c&#039; }] });
        st.end();
    });

    t.test(&#039;allows for empty strings in arrays&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[]=&amp;a[]=c&#039;), { a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;] });

        st.deepEqual(
            qs.parse(&#039;a[0]=b&amp;a[1]&amp;a[2]=c&amp;a[19]=&#039;, { strictNullHandling: true, arrayLimit: 20 }),
            { a: [&#039;b&#039;, null, &#039;c&#039;, &#039;&#039;] },
            &#039;with arrayLimit 20 + array indices: null then empty string works&#039;
        );
        st.deepEqual(
            qs.parse(&#039;a[]=b&amp;a[]&amp;a[]=c&amp;a[]=&#039;, { strictNullHandling: true, arrayLimit: 0 }),
            { a: [&#039;b&#039;, null, &#039;c&#039;, &#039;&#039;] },
            &#039;with arrayLimit 0 + array brackets: null then empty string works&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[0]=b&amp;a[1]=&amp;a[2]=c&amp;a[19]&#039;, { strictNullHandling: true, arrayLimit: 20 }),
            { a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;, null] },
            &#039;with arrayLimit 20 + array indices: empty string then null works&#039;
        );
        st.deepEqual(
            qs.parse(&#039;a[]=b&amp;a[]=&amp;a[]=c&amp;a[]&#039;, { strictNullHandling: true, arrayLimit: 0 }),
            { a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;, null] },
            &#039;with arrayLimit 0 + array brackets: empty string then null works&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[]=&amp;a[]=b&amp;a[]=c&#039;),
            { a: [&#039;&#039;, &#039;b&#039;, &#039;c&#039;] },
            &#039;array brackets: empty strings work&#039;
        );
        st.end();
    });

    t.test(&#039;compacts sparse arrays&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[10]=1&amp;a[2]=2&#039;, { arrayLimit: 20 }), { a: [&#039;2&#039;, &#039;1&#039;] });
        st.deepEqual(qs.parse(&#039;a[1][b][2][c]=1&#039;, { arrayLimit: 20 }), { a: [{ b: [{ c: &#039;1&#039; }] }] });
        st.deepEqual(qs.parse(&#039;a[1][2][3][c]=1&#039;, { arrayLimit: 20 }), { a: [[[{ c: &#039;1&#039; }]]] });
        st.deepEqual(qs.parse(&#039;a[1][2][3][c][1]=1&#039;, { arrayLimit: 20 }), { a: [[[{ c: [&#039;1&#039;] }]]] });
        st.end();
    });

    t.test(&#039;parses semi-parsed strings&#039;, function (st) {
        st.deepEqual(qs.parse({ &#039;a[b]&#039;: &#039;c&#039; }), { a: { b: &#039;c&#039; } });
        st.deepEqual(qs.parse({ &#039;a[b]&#039;: &#039;c&#039;, &#039;a[d]&#039;: &#039;e&#039; }), { a: { b: &#039;c&#039;, d: &#039;e&#039; } });
        st.end();
    });

    t.test(&#039;parses buffers correctly&#039;, function (st) {
        var b = SaferBuffer.from(&#039;test&#039;);
        st.deepEqual(qs.parse({ a: b }), { a: b });
        st.end();
    });

    t.test(&#039;parses jquery-param strings&#039;, function (st) {
        // readable = &#039;filter[0][]=int1&amp;filter[0][]==&amp;filter[0][]=77&amp;filter[]=and&amp;filter[2][]=int2&amp;filter[2][]==&amp;filter[2][]=8&#039;
        var encoded = &#039;filter%5B0%5D%5B%5D=int1&amp;filter%5B0%5D%5B%5D=%3D&amp;filter%5B0%5D%5B%5D=77&amp;filter%5B%5D=and&amp;filter%5B2%5D%5B%5D=int2&amp;filter%5B2%5D%5B%5D=%3D&amp;filter%5B2%5D%5B%5D=8&#039;;
        var expected = { filter: [[&#039;int1&#039;, &#039;=&#039;, &#039;77&#039;], &#039;and&#039;, [&#039;int2&#039;, &#039;=&#039;, &#039;8&#039;]] };
        st.deepEqual(qs.parse(encoded), expected);
        st.end();
    });

    t.test(&#039;continues parsing when no parent is found&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;[]=&amp;a=b&#039;), { 0: &#039;&#039;, a: &#039;b&#039; });
        st.deepEqual(qs.parse(&#039;[]&amp;a=b&#039;, { strictNullHandling: true }), { 0: null, a: &#039;b&#039; });
        st.deepEqual(qs.parse(&#039;[foo]=bar&#039;), { foo: &#039;bar&#039; });
        st.end();
    });

    t.test(&#039;does not error when parsing a very long array&#039;, function (st) {
        var str = &#039;a[]=a&#039;;
        while (Buffer.byteLength(str) &lt; 128 * 1024) {
            str = str + &#039;&amp;&#039; + str;
        }

        st.doesNotThrow(function () {
            qs.parse(str);
        });

        st.end();
    });

    t.test(&#039;should not throw when a native prototype has an enumerable property&#039;, function (st) {
        Object.prototype.crash = &#039;&#039;;
        Array.prototype.crash = &#039;&#039;;
        st.doesNotThrow(qs.parse.bind(null, &#039;a=b&#039;));
        st.deepEqual(qs.parse(&#039;a=b&#039;), { a: &#039;b&#039; });
        st.doesNotThrow(qs.parse.bind(null, &#039;a[][b]=c&#039;));
        st.deepEqual(qs.parse(&#039;a[][b]=c&#039;), { a: [{ b: &#039;c&#039; }] });
        delete Object.prototype.crash;
        delete Array.prototype.crash;
        st.end();
    });

    t.test(&#039;parses a string with an alternative string delimiter&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b;c=d&#039;, { delimiter: &#039;;&#039; }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;parses a string with an alternative RegExp delimiter&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b; c=d&#039;, { delimiter: /[;,] */ }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;does not use non-splittable objects as delimiters&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;c=d&#039;, { delimiter: true }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;allows overriding parameter limit&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;c=d&#039;, { parameterLimit: 1 }), { a: &#039;b&#039; });
        st.end();
    });

    t.test(&#039;allows setting the parameter limit to Infinity&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a=b&amp;c=d&#039;, { parameterLimit: Infinity }), { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;allows overriding array limit&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[0]=b&#039;, { arrayLimit: -1 }), { a: { 0: &#039;b&#039; } });
        st.deepEqual(qs.parse(&#039;a[-1]=b&#039;, { arrayLimit: -1 }), { a: { &#039;-1&#039;: &#039;b&#039; } });
        st.deepEqual(qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { arrayLimit: 0 }), { a: { 0: &#039;b&#039;, 1: &#039;c&#039; } });
        st.end();
    });

    t.test(&#039;allows disabling array parsing&#039;, function (st) {
        var indices = qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { parseArrays: false });
        st.deepEqual(indices, { a: { 0: &#039;b&#039;, 1: &#039;c&#039; } });
        st.equal(Array.isArray(indices.a), false, &#039;parseArrays:false, indices case is not an array&#039;);

        var emptyBrackets = qs.parse(&#039;a[]=b&#039;, { parseArrays: false });
        st.deepEqual(emptyBrackets, { a: { 0: &#039;b&#039; } });
        st.equal(Array.isArray(emptyBrackets.a), false, &#039;parseArrays:false, empty brackets case is not an array&#039;);

        st.end();
    });

    t.test(&#039;allows for query string prefix&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;?foo=bar&#039;, { ignoreQueryPrefix: true }), { foo: &#039;bar&#039; });
        st.deepEqual(qs.parse(&#039;foo=bar&#039;, { ignoreQueryPrefix: true }), { foo: &#039;bar&#039; });
        st.deepEqual(qs.parse(&#039;?foo=bar&#039;, { ignoreQueryPrefix: false }), { &#039;?foo&#039;: &#039;bar&#039; });
        st.end();
    });

    t.test(&#039;parses an object&#039;, function (st) {
        var input = {
            &#039;user[name]&#039;: { &#039;pop[bob]&#039;: 3 },
            &#039;user[email]&#039;: null
        };

        var expected = {
            user: {
                name: { &#039;pop[bob]&#039;: 3 },
                email: null
            }
        };

        var result = qs.parse(input);

        st.deepEqual(result, expected);
        st.end();
    });

    t.test(&#039;parses an object in dot notation&#039;, function (st) {
        var input = {
            &#039;user.name&#039;: { &#039;pop[bob]&#039;: 3 },
            &#039;user.email.&#039;: null
        };

        var expected = {
            user: {
                name: { &#039;pop[bob]&#039;: 3 },
                email: null
            }
        };

        var result = qs.parse(input, { allowDots: true });

        st.deepEqual(result, expected);
        st.end();
    });

    t.test(&#039;parses an object and not child values&#039;, function (st) {
        var input = {
            &#039;user[name]&#039;: { &#039;pop[bob]&#039;: { test: 3 } },
            &#039;user[email]&#039;: null
        };

        var expected = {
            user: {
                name: { &#039;pop[bob]&#039;: { test: 3 } },
                email: null
            }
        };

        var result = qs.parse(input);

        st.deepEqual(result, expected);
        st.end();
    });

    t.test(&#039;does not blow up when Buffer global is missing&#039;, function (st) {
        var tempBuffer = global.Buffer;
        delete global.Buffer;
        var result = qs.parse(&#039;a=b&amp;c=d&#039;);
        global.Buffer = tempBuffer;
        st.deepEqual(result, { a: &#039;b&#039;, c: &#039;d&#039; });
        st.end();
    });

    t.test(&#039;does not crash when parsing circular references&#039;, function (st) {
        var a = {};
        a.b = a;

        var parsed;

        st.doesNotThrow(function () {
            parsed = qs.parse({ &#039;foo[bar]&#039;: &#039;baz&#039;, &#039;foo[baz]&#039;: a });
        });

        st.equal(&#039;foo&#039; in parsed, true, &#039;parsed has &quot;foo&quot; property&#039;);
        st.equal(&#039;bar&#039; in parsed.foo, true);
        st.equal(&#039;baz&#039; in parsed.foo, true);
        st.equal(parsed.foo.bar, &#039;baz&#039;);
        st.deepEqual(parsed.foo.baz, a);
        st.end();
    });

    t.test(&#039;does not crash when parsing deep objects&#039;, function (st) {
        var parsed;
        var str = &#039;foo&#039;;

        for (var i = 0; i &lt; 5000; i++) {
            str += &#039;[p]&#039;;
        }

        str += &#039;=bar&#039;;

        st.doesNotThrow(function () {
            parsed = qs.parse(str, { depth: 5000 });
        });

        st.equal(&#039;foo&#039; in parsed, true, &#039;parsed has &quot;foo&quot; property&#039;);

        var depth = 0;
        var ref = parsed.foo;
        while ((ref = ref.p)) {
            depth += 1;
        }

        st.equal(depth, 5000, &#039;parsed is 5000 properties deep&#039;);

        st.end();
    });

    t.test(&#039;parses null objects correctly&#039;, { skip: !Object.create }, function (st) {
        var a = Object.create(null);
        a.b = &#039;c&#039;;

        st.deepEqual(qs.parse(a), { b: &#039;c&#039; });
        var result = qs.parse({ a: a });
        st.equal(&#039;a&#039; in result, true, &#039;result has &quot;a&quot; property&#039;);
        st.deepEqual(result.a, a);
        st.end();
    });

    t.test(&#039;parses dates correctly&#039;, function (st) {
        var now = new Date();
        st.deepEqual(qs.parse({ a: now }), { a: now });
        st.end();
    });

    t.test(&#039;parses regular expressions correctly&#039;, function (st) {
        var re = /^test$/;
        st.deepEqual(qs.parse({ a: re }), { a: re });
        st.end();
    });

    t.test(&#039;does not allow overwriting prototype properties&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[hasOwnProperty]=b&#039;, { allowPrototypes: false }), {});
        st.deepEqual(qs.parse(&#039;hasOwnProperty=b&#039;, { allowPrototypes: false }), {});

        st.deepEqual(
            qs.parse(&#039;toString&#039;, { allowPrototypes: false }),
            {},
            &#039;bare &quot;toString&quot; results in {}&#039;
        );

        st.end();
    });

    t.test(&#039;can allow overwriting prototype properties&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;a[hasOwnProperty]=b&#039;, { allowPrototypes: true }), { a: { hasOwnProperty: &#039;b&#039; } });
        st.deepEqual(qs.parse(&#039;hasOwnProperty=b&#039;, { allowPrototypes: true }), { hasOwnProperty: &#039;b&#039; });

        st.deepEqual(
            qs.parse(&#039;toString&#039;, { allowPrototypes: true }),
            { toString: &#039;&#039; },
            &#039;bare &quot;toString&quot; results in { toString: &quot;&quot; }&#039;
        );

        st.end();
    });

    t.test(&#039;params starting with a closing bracket&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;]=toString&#039;), { &#039;]&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;]]=toString&#039;), { &#039;]]&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;]hello]=toString&#039;), { &#039;]hello]&#039;: &#039;toString&#039; });
        st.end();
    });

    t.test(&#039;params starting with a starting bracket&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;[=toString&#039;), { &#039;[&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;[[=toString&#039;), { &#039;[[&#039;: &#039;toString&#039; });
        st.deepEqual(qs.parse(&#039;[hello[=toString&#039;), { &#039;[hello[&#039;: &#039;toString&#039; });
        st.end();
    });

    t.test(&#039;add keys to objects&#039;, function (st) {
        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=d&#039;),
            { a: { b: &#039;c&#039;, d: true } },
            &#039;can add keys to objects&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=toString&#039;),
            { a: { b: &#039;c&#039; } },
            &#039;can not overwrite prototype&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=toString&#039;, { allowPrototypes: true }),
            { a: { b: &#039;c&#039;, toString: true } },
            &#039;can overwrite prototype with allowPrototypes true&#039;
        );

        st.deepEqual(
            qs.parse(&#039;a[b]=c&amp;a=toString&#039;, { plainObjects: true }),
            { __proto__: null, a: { __proto__: null, b: &#039;c&#039;, toString: true } },
            &#039;can overwrite prototype with plainObjects true&#039;
        );

        st.end();
    });

    t.test(&#039;dunder proto is ignored&#039;, function (st) {
        var payload = &#039;categories[__proto__]=login&amp;categories[__proto__]&amp;categories[length]=42&#039;;
        var result = qs.parse(payload, { allowPrototypes: true });

        st.deepEqual(
            result,
            {
                categories: {
                    length: &#039;42&#039;
                }
            },
            &#039;silent [[Prototype]] payload&#039;
        );

        var plainResult = qs.parse(payload, { allowPrototypes: true, plainObjects: true });

        st.deepEqual(
            plainResult,
            {
                __proto__: null,
                categories: {
                    __proto__: null,
                    length: &#039;42&#039;
                }
            },
            &#039;silent [[Prototype]] payload: plain objects&#039;
        );

        var query = qs.parse(&#039;categories[__proto__]=cats&amp;categories[__proto__]=dogs&amp;categories[some][json]=toInject&#039;, { allowPrototypes: true });

        st.notOk(Array.isArray(query.categories), &#039;is not an array&#039;);
        st.notOk(query.categories instanceof Array, &#039;is not instanceof an array&#039;);
        st.deepEqual(query.categories, { some: { json: &#039;toInject&#039; } });
        st.equal(JSON.stringify(query.categories), &#039;{&quot;some&quot;:{&quot;json&quot;:&quot;toInject&quot;}}&#039;, &#039;stringifies as a non-array&#039;);

        st.deepEqual(
            qs.parse(&#039;foo[__proto__][hidden]=value&amp;foo[bar]=stuffs&#039;, { allowPrototypes: true }),
            {
                foo: {
                    bar: &#039;stuffs&#039;
                }
            },
            &#039;hidden values&#039;
        );

        st.deepEqual(
            qs.parse(&#039;foo[__proto__][hidden]=value&amp;foo[bar]=stuffs&#039;, { allowPrototypes: true, plainObjects: true }),
            {
                __proto__: null,
                foo: {
                    __proto__: null,
                    bar: &#039;stuffs&#039;
                }
            },
            &#039;hidden values: plain objects&#039;
        );

        st.end();
    });

    t.test(&#039;can return null objects&#039;, { skip: !Object.create }, function (st) {
        var expected = Object.create(null);
        expected.a = Object.create(null);
        expected.a.b = &#039;c&#039;;
        expected.a.hasOwnProperty = &#039;d&#039;;
        st.deepEqual(qs.parse(&#039;a[b]=c&amp;a[hasOwnProperty]=d&#039;, { plainObjects: true }), expected);
        st.deepEqual(qs.parse(null, { plainObjects: true }), Object.create(null));
        var expectedArray = Object.create(null);
        expectedArray.a = Object.create(null);
        expectedArray.a[0] = &#039;b&#039;;
        expectedArray.a.c = &#039;d&#039;;
        st.deepEqual(qs.parse(&#039;a[]=b&amp;a[c]=d&#039;, { plainObjects: true }), expectedArray);
        st.end();
    });

    t.test(&#039;can parse with custom encoding&#039;, function (st) {
        st.deepEqual(qs.parse(&#039;%8c%a7=%91%e5%8d%e3%95%7b&#039;, {
            decoder: function (str) {
                var reg = /%([0-9A-F]{2})/ig;
                var result = [];
                var parts = reg.exec(str);
                while (parts) {
                    result.push(parseInt(parts[1], 16));
                    parts = reg.exec(str);
                }
                return String(iconv.decode(SaferBuffer.from(result), &#039;shift_jis&#039;));
            }
        }), { 県: &#039;大阪府&#039; });
        st.end();
    });

    t.test(&#039;receives the default decoder as a second argument&#039;, function (st) {
        st.plan(1);
        qs.parse(&#039;a&#039;, {
            decoder: function (str, defaultDecoder) {
                st.equal(defaultDecoder, utils.decode);
            }
        });
        st.end();
    });

    t.test(&#039;throws error with wrong decoder&#039;, function (st) {
        st[&#039;throws&#039;](function () {
            qs.parse({}, { decoder: &#039;string&#039; });
        }, new TypeError(&#039;Decoder has to be a function.&#039;));
        st.end();
    });

    t.test(&#039;does not mutate the options argument&#039;, function (st) {
        var options = {};
        qs.parse(&#039;a[b]=true&#039;, options);
        st.deepEqual(options, {});
        st.end();
    });

    t.end();
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
