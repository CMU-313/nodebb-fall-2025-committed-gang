<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/mdurl/build/index.cjs.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/mdurl/build/index.cjs.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">48.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">535</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">96.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.73</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

/* eslint-disable no-bitwise */

const decodeCache = {};

function getDecodeCache (exclude) {
  let cache = decodeCache[exclude];
  if (cache) { return cache }

  cache = decodeCache[exclude] = [];

  for (let i = 0; i &lt; 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (let i = 0; i &lt; exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = &#039;%&#039; + (&#039;0&#039; + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache
}

// Decode percent-encoded string.
//
function decode (string, exclude) {
  if (typeof exclude !== &#039;string&#039;) {
    exclude = decode.defaultChars;
  }

  const cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    let result = &#039;&#039;;

    for (let i = 0, l = seq.length; i &lt; l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 &lt; 0x80) {
        result += cache[b1];
        continue
      }

      if ((b1 &amp; 0xE0) === 0xC0 &amp;&amp; (i + 3 &lt; l)) {
        // 110xxxxx 10xxxxxx
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 &amp; 0xC0) === 0x80) {
          const chr = ((b1 &lt;&lt; 6) &amp; 0x7C0) | (b2 &amp; 0x3F);

          if (chr &lt; 0x80) {
            result += &#039;\ufffd\ufffd&#039;;
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue
        }
      }

      if ((b1 &amp; 0xF0) === 0xE0 &amp;&amp; (i + 6 &lt; l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 &amp; 0xC0) === 0x80 &amp;&amp; (b3 &amp; 0xC0) === 0x80) {
          const chr = ((b1 &lt;&lt; 12) &amp; 0xF000) | ((b2 &lt;&lt; 6) &amp; 0xFC0) | (b3 &amp; 0x3F);

          if (chr &lt; 0x800 || (chr &gt;= 0xD800 &amp;&amp; chr &lt;= 0xDFFF)) {
            result += &#039;\ufffd\ufffd\ufffd&#039;;
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue
        }
      }

      if ((b1 &amp; 0xF8) === 0xF0 &amp;&amp; (i + 9 &lt; l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 &amp; 0xC0) === 0x80 &amp;&amp; (b3 &amp; 0xC0) === 0x80 &amp;&amp; (b4 &amp; 0xC0) === 0x80) {
          let chr = ((b1 &lt;&lt; 18) &amp; 0x1C0000) | ((b2 &lt;&lt; 12) &amp; 0x3F000) | ((b3 &lt;&lt; 6) &amp; 0xFC0) | (b4 &amp; 0x3F);

          if (chr &lt; 0x10000 || chr &gt; 0x10FFFF) {
            result += &#039;\ufffd\ufffd\ufffd\ufffd&#039;;
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr &gt;&gt; 10), 0xDC00 + (chr &amp; 0x3FF));
          }

          i += 9;
          continue
        }
      }

      result += &#039;\ufffd&#039;;
    }

    return result
  })
}

decode.defaultChars = &#039;;/?:@&amp;=+$,#&#039;;
decode.componentChars = &#039;&#039;;

const encodeCache = {};

// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache (exclude) {
  let cache = encodeCache[exclude];
  if (cache) { return cache }

  cache = encodeCache[exclude] = [];

  for (let i = 0; i &lt; 128; i++) {
    const ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push(&#039;%&#039; + (&#039;0&#039; + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (let i = 0; i &lt; exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache
}

// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don&#039;t encode &#039;%&#039; in a correct escape sequence (default: true)
//
function encode (string, exclude, keepEscaped) {
  if (typeof exclude !== &#039;string&#039;) {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === &#039;undefined&#039;) {
    keepEscaped = true;
  }

  const cache = getEncodeCache(exclude);
  let result = &#039;&#039;;

  for (let i = 0, l = string.length; i &lt; l; i++) {
    const code = string.charCodeAt(i);

    if (keepEscaped &amp;&amp; code === 0x25 /* % */ &amp;&amp; i + 2 &lt; l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue
      }
    }

    if (code &lt; 128) {
      result += cache[code];
      continue
    }

    if (code &gt;= 0xD800 &amp;&amp; code &lt;= 0xDFFF) {
      if (code &gt;= 0xD800 &amp;&amp; code &lt;= 0xDBFF &amp;&amp; i + 1 &lt; l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode &gt;= 0xDC00 &amp;&amp; nextCode &lt;= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue
        }
      }
      result += &#039;%EF%BF%BD&#039;;
      continue
    }

    result += encodeURIComponent(string[i]);
  }

  return result
}

encode.defaultChars = &quot;;/?:@&amp;=+$,-_.!~*&#039;()#&quot;;
encode.componentChars = &quot;-_.!~*&#039;()&quot;;

function format (url) {
  let result = &#039;&#039;;

  result += url.protocol || &#039;&#039;;
  result += url.slashes ? &#039;//&#039; : &#039;&#039;;
  result += url.auth ? url.auth + &#039;@&#039; : &#039;&#039;;

  if (url.hostname &amp;&amp; url.hostname.indexOf(&#039;:&#039;) !== -1) {
    // ipv6 address
    result += &#039;[&#039; + url.hostname + &#039;]&#039;;
  } else {
    result += url.hostname || &#039;&#039;;
  }

  result += url.port ? &#039;:&#039; + url.port : &#039;&#039;;
  result += url.pathname || &#039;&#039;;
  result += url.search || &#039;&#039;;
  result += url.hash || &#039;&#039;;

  return result
}

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse(&#039;http://foo?bar&#039;)` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//

function Url () {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
const protocolPattern = /^([a-z0-9.+-]+:)/i;
const portPattern = /:[0-9]*$/;

// Special case for a simple path URL
/* eslint-disable-next-line no-useless-escape */
const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;

// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
const delims = [&#039;&lt;&#039;, &#039;&gt;&#039;, &#039;&quot;&#039;, &#039;`&#039;, &#039; &#039;, &#039;\r&#039;, &#039;\n&#039;, &#039;\t&#039;];

// RFC 2396: characters not allowed for various reasons.
const unwise = [&#039;{&#039;, &#039;}&#039;, &#039;|&#039;, &#039;\\&#039;, &#039;^&#039;, &#039;`&#039;].concat(delims);

// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
const autoEscape = [&#039;\&#039;&#039;].concat(unwise);
// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
const nonHostChars = [&#039;%&#039;, &#039;/&#039;, &#039;?&#039;, &#039;;&#039;, &#039;#&#039;].concat(autoEscape);
const hostEndingChars = [&#039;/&#039;, &#039;?&#039;, &#039;#&#039;];
const hostnameMaxLen = 255;
const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
// protocols that can allow &quot;unsafe&quot; and &quot;unwise&quot; chars.
// protocols that never have a hostname.
const hostlessProtocol = {
  javascript: true,
  &#039;javascript:&#039;: true
};
// protocols that always contain a // bit.
const slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  &#039;http:&#039;: true,
  &#039;https:&#039;: true,
  &#039;ftp:&#039;: true,
  &#039;gopher:&#039;: true,
  &#039;file:&#039;: true
};

function urlParse (url, slashesDenoteHost) {
  if (url &amp;&amp; url instanceof Url) return url

  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;

  // trim before proceeding.
  // This is to support parse stuff like &quot;  http://foo.com  \n&quot;
  rest = rest.trim();

  if (!slashesDenoteHost &amp;&amp; url.split(&#039;#&#039;).length === 1) {
    // Try fast path regexp
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this
    }
  }

  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it&#039;s got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that&#039;s
  // how the browser resolves relative URLs.
  /* eslint-disable-next-line no-useless-escape */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === &#039;//&#039;;
    if (slashes &amp;&amp; !(proto &amp;&amp; hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &amp;&amp;
      (slashes || (proto &amp;&amp; !slashedProtocol[proto]))) {
    // there&#039;s a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ =&gt; user:a@b host:c
    // http://a@b?@c =&gt; user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    let hostEnd = -1;
    for (let i = 0; i &lt; hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    let auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf(&#039;@&#039;);
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d =&gt; host:b auth:a path:/c@d
      atSign = rest.lastIndexOf(&#039;@&#039;, hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (let i = 0; i &lt; nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === &#039;:&#039;) { hostEnd--; }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we&#039;ve indicated that there is a hostname,
    // so even if it&#039;s empty, it has to be present.
    this.hostname = this.hostname || &#039;&#039;;

    // if hostname begins with [ and ends with ]
    // assume that it&#039;s an IPv6 address.
    const ipv6Hostname = this.hostname[0] === &#039;[&#039; &amp;&amp;
        this.hostname[this.hostname.length - 1] === &#039;]&#039;;

    // validate a little.
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i &lt; l; i++) {
        const part = hostparts[i];
        if (!part) { continue }
        if (!part.match(hostnamePartPattern)) {
          let newpart = &#039;&#039;;
          for (let j = 0, k = part.length; j &lt; k; j++) {
            if (part.charCodeAt(j) &gt; 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += &#039;x&#039;;
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(&#039;.&#039;) + rest;
            }
            this.hostname = validParts.join(&#039;.&#039;);
            break
          }
        }
      }
    }

    if (this.hostname.length &gt; hostnameMaxLen) {
      this.hostname = &#039;&#039;;
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  const hash = rest.indexOf(&#039;#&#039;);
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf(&#039;?&#039;);
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] &amp;&amp;
      this.hostname &amp;&amp; !this.pathname) {
    this.pathname = &#039;&#039;;
  }

  return this
};

Url.prototype.parseHost = function (host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== &#039;:&#039;) {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.decode = decode;
exports.encode = encode;
exports.format = format;
exports.parse = urlParse;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
