<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nconf/node_modules/yargs/build/lib/yargs-factory.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nconf/node_modules/yargs/build/lib/yargs-factory.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1144</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">135.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">15.81</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { command as Command, } from &#039;./command.js&#039;;
import { assertNotStrictEqual, assertSingleKey, objectKeys, } from &#039;./typings/common-types.js&#039;;
import { YError } from &#039;./yerror.js&#039;;
import { usage as Usage } from &#039;./usage.js&#039;;
import { argsert } from &#039;./argsert.js&#039;;
import { completion as Completion, } from &#039;./completion.js&#039;;
import { validation as Validation, } from &#039;./validation.js&#039;;
import { objFilter } from &#039;./utils/obj-filter.js&#039;;
import { applyExtends } from &#039;./utils/apply-extends.js&#039;;
import { globalMiddlewareFactory, } from &#039;./middleware.js&#039;;
import { isPromise } from &#039;./utils/is-promise.js&#039;;
import setBlocking from &#039;./utils/set-blocking.js&#039;;
let shim;
export function YargsWithShim(_shim) {
    shim = _shim;
    return Yargs;
}
function Yargs(processArgs = [], cwd = shim.process.cwd(), parentRequire) {
    const self = {};
    let command;
    let completion = null;
    let groups = {};
    const globalMiddleware = [];
    let output = &#039;&#039;;
    const preservedGroups = {};
    let usage;
    let validation;
    let handlerFinishCommand = null;
    const y18n = shim.y18n;
    self.middleware = globalMiddlewareFactory(globalMiddleware, self);
    self.scriptName = function (scriptName) {
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
    };
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(shim.process.argv()[0])) {
        default$0 = shim.process.argv().slice(1, 2);
    }
    else {
        default$0 = shim.process.argv().slice(0, 1);
    }
    self.$0 = default$0
        .map(x =&gt; {
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) &amp;&amp; b.length &lt; x.length ? b : x;
    })
        .join(&#039; &#039;)
        .trim();
    if (shim.getEnv(&#039;_&#039;) &amp;&amp; shim.getProcessArgvBin() === shim.getEnv(&#039;_&#039;)) {
        self.$0 = shim
            .getEnv(&#039;_&#039;)
            .replace(`${shim.path.dirname(shim.process.execPath())}/`, &#039;&#039;);
    }
    const context = { resets: -1, commands: [], fullCommands: [], files: [] };
    self.getContext = () =&gt; context;
    let hasOutput = false;
    let exitError = null;
    self.exit = (code, err) =&gt; {
        hasOutput = true;
        exitError = err;
        if (exitProcess)
            shim.process.exit(code);
    };
    let completionCommand = null;
    self.completion = function (cmd, desc, fn) {
        argsert(&#039;[string] [string|boolean|function] [function]&#039;, [cmd, desc, fn], arguments.length);
        if (typeof desc === &#039;function&#039;) {
            fn = desc;
            desc = undefined;
        }
        completionCommand = cmd || completionCommand || &#039;completion&#039;;
        if (!desc &amp;&amp; desc !== false) {
            desc = &#039;generate completion script&#039;;
        }
        self.command(completionCommand, desc);
        if (fn)
            completion.registerFunction(fn);
        return self;
    };
    let options;
    self.resetOptions = self.reset = function resetOptions(aliases = {}) {
        context.resets++;
        options = options || {};
        const tmpOptions = {};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects
            ? options.configObjects
            : [];
        const localLookup = {};
        tmpOptions.local.forEach(l =&gt; {
            localLookup[l] = true;
            (aliases[l] || []).forEach(a =&gt; {
                localLookup[a] = true;
            });
        });
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) =&gt; {
            const keys = groups[groupName].filter(key =&gt; !(key in localLookup));
            if (keys.length &gt; 0) {
                acc[groupName] = keys;
            }
            return acc;
        }, {}));
        groups = {};
        const arrayOptions = [
            &#039;array&#039;,
            &#039;boolean&#039;,
            &#039;string&#039;,
            &#039;skipValidation&#039;,
            &#039;count&#039;,
            &#039;normalize&#039;,
            &#039;number&#039;,
            &#039;hiddenOptions&#039;,
        ];
        const objectOptions = [
            &#039;narg&#039;,
            &#039;key&#039;,
            &#039;alias&#039;,
            &#039;default&#039;,
            &#039;defaultDescription&#039;,
            &#039;config&#039;,
            &#039;choices&#039;,
            &#039;demandedOptions&#039;,
            &#039;demandedCommands&#039;,
            &#039;coerce&#039;,
            &#039;deprecatedOptions&#039;,
        ];
        arrayOptions.forEach(k =&gt; {
            tmpOptions[k] = (options[k] || []).filter((k) =&gt; !localLookup[k]);
        });
        objectOptions.forEach((k) =&gt; {
            tmpOptions[k] = objFilter(options[k], k =&gt; !localLookup[k]);
        });
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        usage = usage ? usage.reset(localLookup) : Usage(self, y18n, shim);
        validation = validation
            ? validation.reset(localLookup)
            : Validation(self, usage, y18n, shim);
        command = command
            ? command.reset()
            : Command(self, usage, validation, globalMiddleware, shim);
        if (!completion)
            completion = Completion(self, usage, command, shim);
        completionCommand = null;
        output = &#039;&#039;;
        exitError = null;
        hasOutput = false;
        self.parsed = false;
        return self;
    };
    self.resetOptions();
    const frozens = [];
    function freeze() {
        frozens.push({
            options,
            configObjects: options.configObjects.slice(0),
            exitProcess,
            groups,
            strict,
            strictCommands,
            strictOptions,
            completionCommand,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            parseFn,
            parseContext,
            handlerFinishCommand,
        });
        usage.freeze();
        validation.freeze();
        command.freeze();
    }
    function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        let configObjects;
        ({
            options,
            configObjects,
            exitProcess,
            groups,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            strict,
            strictCommands,
            strictOptions,
            completionCommand,
            parseFn,
            parseContext,
            handlerFinishCommand,
        } = frozen);
        options.configObjects = configObjects;
        usage.unfreeze();
        validation.unfreeze();
        command.unfreeze();
    }
    self.boolean = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;boolean&#039;, keys);
        return self;
    };
    self.array = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;array&#039;, keys);
        return self;
    };
    self.number = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;number&#039;, keys);
        return self;
    };
    self.normalize = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;normalize&#039;, keys);
        return self;
    };
    self.count = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;count&#039;, keys);
        return self;
    };
    self.string = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;string&#039;, keys);
        return self;
    };
    self.requiresArg = function (keys) {
        argsert(&#039;&lt;array|string|object&gt; [number]&#039;, [keys], arguments.length);
        if (typeof keys === &#039;string&#039; &amp;&amp; options.narg[keys]) {
            return self;
        }
        else {
            populateParserHintSingleValueDictionary(self.requiresArg, &#039;narg&#039;, keys, NaN);
        }
        return self;
    };
    self.skipValidation = function (keys) {
        argsert(&#039;&lt;array|string&gt;&#039;, [keys], arguments.length);
        populateParserHintArray(&#039;skipValidation&#039;, keys);
        return self;
    };
    function populateParserHintArray(type, keys) {
        keys = [].concat(keys);
        keys.forEach(key =&gt; {
            key = sanitizeKey(key);
            options[type].push(key);
        });
    }
    self.nargs = function (key, value) {
        argsert(&#039;&lt;string|object|array&gt; [number]&#039;, [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self.nargs, &#039;narg&#039;, key, value);
        return self;
    };
    self.choices = function (key, value) {
        argsert(&#039;&lt;object|string|array&gt; [string|array]&#039;, [key, value], arguments.length);
        populateParserHintArrayDictionary(self.choices, &#039;choices&#039;, key, value);
        return self;
    };
    self.alias = function (key, value) {
        argsert(&#039;&lt;object|string|array&gt; [string|array]&#039;, [key, value], arguments.length);
        populateParserHintArrayDictionary(self.alias, &#039;alias&#039;, key, value);
        return self;
    };
    self.default = self.defaults = function (key, value, defaultDescription) {
        argsert(&#039;&lt;object|string|array&gt; [*] [string]&#039;, [key, value, defaultDescription], arguments.length);
        if (defaultDescription) {
            assertSingleKey(key, shim);
            options.defaultDescription[key] = defaultDescription;
        }
        if (typeof value === &#039;function&#039;) {
            assertSingleKey(key, shim);
            if (!options.defaultDescription[key])
                options.defaultDescription[key] = usage.functionDescription(value);
            value = value.call();
        }
        populateParserHintSingleValueDictionary(self.default, &#039;default&#039;, key, value);
        return self;
    };
    self.describe = function (key, desc) {
        argsert(&#039;&lt;object|string|array&gt; [string]&#039;, [key, desc], arguments.length);
        setKey(key, true);
        usage.describe(key, desc);
        return self;
    };
    function setKey(key, set) {
        populateParserHintSingleValueDictionary(setKey, &#039;key&#039;, key, set);
        return self;
    }
    function demandOption(keys, msg) {
        argsert(&#039;&lt;object|string|array&gt; [string]&#039;, [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self.demandOption, &#039;demandedOptions&#039;, keys, msg);
        return self;
    }
    self.demandOption = demandOption;
    self.coerce = function (keys, value) {
        argsert(&#039;&lt;object|string|array&gt; [function]&#039;, [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self.coerce, &#039;coerce&#039;, keys, value);
        return self;
    };
    function populateParserHintSingleValueDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type, key, value) =&gt; {
            options[type][key] = value;
        });
    }
    function populateParserHintArrayDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type, key, value) =&gt; {
            options[type][key] = (options[type][key] || []).concat(value);
        });
    }
    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
            key.forEach(k =&gt; {
                builder(k, value);
            });
        }
        else if (((key) =&gt; typeof key === &#039;object&#039;)(key)) {
            for (const k of objectKeys(key)) {
                builder(k, key[k]);
            }
        }
        else {
            singleKeyHandler(type, sanitizeKey(key), value);
        }
    }
    function sanitizeKey(key) {
        if (key === &#039;__proto__&#039;)
            return &#039;___proto___&#039;;
        return key;
    }
    function deleteFromParserHintObject(optionKey) {
        objectKeys(options).forEach((hintKey) =&gt; {
            if (((key) =&gt; key === &#039;configObjects&#039;)(hintKey))
                return;
            const hint = options[hintKey];
            if (Array.isArray(hint)) {
                if (~hint.indexOf(optionKey))
                    hint.splice(hint.indexOf(optionKey), 1);
            }
            else if (typeof hint === &#039;object&#039;) {
                delete hint[optionKey];
            }
        });
        delete usage.getDescriptions()[optionKey];
    }
    self.config = function config(key = &#039;config&#039;, msg, parseFn) {
        argsert(&#039;[object|string] [string|function] [function]&#039;, [key, msg, parseFn], arguments.length);
        if (typeof key === &#039;object&#039; &amp;&amp; !Array.isArray(key)) {
            key = applyExtends(key, cwd, self.getParserConfiguration()[&#039;deep-merge-config&#039;] || false, shim);
            options.configObjects = (options.configObjects || []).concat(key);
            return self;
        }
        if (typeof msg === &#039;function&#039;) {
            parseFn = msg;
            msg = undefined;
        }
        self.describe(key, msg || usage.deferY18nLookup(&#039;Path to JSON config file&#039;));
        (Array.isArray(key) ? key : [key]).forEach(k =&gt; {
            options.config[k] = parseFn || true;
        });
        return self;
    };
    self.example = function (cmd, description) {
        argsert(&#039;&lt;string|array&gt; [string]&#039;, [cmd, description], arguments.length);
        if (Array.isArray(cmd)) {
            cmd.forEach(exampleParams =&gt; self.example(...exampleParams));
        }
        else {
            usage.example(cmd, description);
        }
        return self;
    };
    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {
        argsert(&#039;&lt;string|array|object&gt; [string|boolean] [function|object] [function] [array] [boolean|string]&#039;, [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self;
    };
    self.commandDir = function (dir, opts) {
        argsert(&#039;&lt;string&gt; [object]&#039;, [dir, opts], arguments.length);
        const req = parentRequire || shim.require;
        command.addDirectory(dir, self.getContext(), req, shim.getCallerFile(), opts);
        return self;
    };
    self.demand = self.required = self.require = function demand(keys, max, msg) {
        if (Array.isArray(max)) {
            max.forEach(key =&gt; {
                assertNotStrictEqual(msg, true, shim);
                demandOption(key, msg);
            });
            max = Infinity;
        }
        else if (typeof max !== &#039;number&#039;) {
            msg = max;
            max = Infinity;
        }
        if (typeof keys === &#039;number&#039;) {
            assertNotStrictEqual(msg, true, shim);
            self.demandCommand(keys, max, msg, msg);
        }
        else if (Array.isArray(keys)) {
            keys.forEach(key =&gt; {
                assertNotStrictEqual(msg, true, shim);
                demandOption(key, msg);
            });
        }
        else {
            if (typeof msg === &#039;string&#039;) {
                demandOption(keys, msg);
            }
            else if (msg === true || typeof msg === &#039;undefined&#039;) {
                demandOption(keys);
            }
        }
        return self;
    };
    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert(&#039;[number] [number|string] [string|null|undefined] [string|null|undefined]&#039;, [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== &#039;number&#039;) {
            minMsg = max;
            max = Infinity;
        }
        self.global(&#039;_&#039;, false);
        options.demandedCommands._ = {
            min,
            max,
            minMsg,
            maxMsg,
        };
        return self;
    };
    self.getDemandedOptions = () =&gt; {
        argsert([], 0);
        return options.demandedOptions;
    };
    self.getDemandedCommands = () =&gt; {
        argsert([], 0);
        return options.demandedCommands;
    };
    self.deprecateOption = function deprecateOption(option, message) {
        argsert(&#039;&lt;string&gt; [string|boolean]&#039;, [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self;
    };
    self.getDeprecatedOptions = () =&gt; {
        argsert([], 0);
        return options.deprecatedOptions;
    };
    self.implies = function (key, value) {
        argsert(&#039;&lt;string|object&gt; [number|string|array]&#039;, [key, value], arguments.length);
        validation.implies(key, value);
        return self;
    };
    self.conflicts = function (key1, key2) {
        argsert(&#039;&lt;string|object&gt; [string|array]&#039;, [key1, key2], arguments.length);
        validation.conflicts(key1, key2);
        return self;
    };
    self.usage = function (msg, description, builder, handler) {
        argsert(&#039;&lt;string|null|undefined&gt; [string|boolean] [function|object] [function]&#039;, [msg, description, builder, handler], arguments.length);
        if (description !== undefined) {
            assertNotStrictEqual(msg, null, shim);
            if ((msg || &#039;&#039;).match(/^\$0( |$)/)) {
                return self.command(msg, description, builder, handler);
            }
            else {
                throw new YError(&#039;.usage() description must start with $0 if being used as alias for .command()&#039;);
            }
        }
        else {
            usage.usage(msg);
            return self;
        }
    };
    self.epilogue = self.epilog = function (msg) {
        argsert(&#039;&lt;string&gt;&#039;, [msg], arguments.length);
        usage.epilog(msg);
        return self;
    };
    self.fail = function (f) {
        argsert(&#039;&lt;function&gt;&#039;, [f], arguments.length);
        usage.failFn(f);
        return self;
    };
    self.onFinishCommand = function (f) {
        argsert(&#039;&lt;function&gt;&#039;, [f], arguments.length);
        handlerFinishCommand = f;
        return self;
    };
    self.getHandlerFinishCommand = () =&gt; handlerFinishCommand;
    self.check = function (f, _global) {
        argsert(&#039;&lt;function&gt; [boolean]&#039;, [f, _global], arguments.length);
        validation.check(f, _global !== false);
        return self;
    };
    self.global = function global(globals, global) {
        argsert(&#039;&lt;string|array&gt; [boolean]&#039;, [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
            options.local = options.local.filter(l =&gt; globals.indexOf(l) === -1);
        }
        else {
            globals.forEach(g =&gt; {
                if (options.local.indexOf(g) === -1)
                    options.local.push(g);
            });
        }
        return self;
    };
    self.pkgConf = function pkgConf(key, rootPath) {
        argsert(&#039;&lt;string&gt; [string]&#039;, [key, rootPath], arguments.length);
        let conf = null;
        const obj = pkgUp(rootPath || cwd);
        if (obj[key] &amp;&amp; typeof obj[key] === &#039;object&#039;) {
            conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()[&#039;deep-merge-config&#039;] || false, shim);
            options.configObjects = (options.configObjects || []).concat(conf);
        }
        return self;
    };
    const pkgs = {};
    function pkgUp(rootPath) {
        const npath = rootPath || &#039;*&#039;;
        if (pkgs[npath])
            return pkgs[npath];
        let obj = {};
        try {
            let startDir = rootPath || shim.mainFilename;
            if (!rootPath &amp;&amp; shim.path.extname(startDir)) {
                startDir = shim.path.dirname(startDir);
            }
            const pkgJsonPath = shim.findUp(startDir, (dir, names) =&gt; {
                if (names.includes(&#039;package.json&#039;)) {
                    return &#039;package.json&#039;;
                }
                else {
                    return undefined;
                }
            });
            assertNotStrictEqual(pkgJsonPath, undefined, shim);
            obj = JSON.parse(shim.readFileSync(pkgJsonPath, &#039;utf8&#039;));
        }
        catch (_noop) { }
        pkgs[npath] = obj || {};
        return pkgs[npath];
    }
    let parseFn = null;
    let parseContext = null;
    self.parse = function parse(args, shortCircuit, _parseFn) {
        argsert(&#039;[string|array] [function|boolean|object] [function]&#039;, [args, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args === &#039;undefined&#039;) {
            const argv = self._parseArgs(processArgs);
            const tmpParsed = self.parsed;
            unfreeze();
            self.parsed = tmpParsed;
            return argv;
        }
        if (typeof shortCircuit === &#039;object&#039;) {
            parseContext = shortCircuit;
            shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === &#039;function&#039;) {
            parseFn = shortCircuit;
            shortCircuit = false;
        }
        if (!shortCircuit)
            processArgs = args;
        if (parseFn)
            exitProcess = false;
        const parsed = self._parseArgs(args, !!shortCircuit);
        completion.setParsed(self.parsed);
        if (parseFn)
            parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
    };
    self._getParseContext = () =&gt; parseContext || {};
    self._hasParseCallback = () =&gt; !!parseFn;
    self.option = self.options = function option(key, opt) {
        argsert(&#039;&lt;string|object&gt; [object]&#039;, [key, opt], arguments.length);
        if (typeof key === &#039;object&#039;) {
            Object.keys(key).forEach(k =&gt; {
                self.options(k, key[k]);
            });
        }
        else {
            if (typeof opt !== &#039;object&#039;) {
                opt = {};
            }
            options.key[key] = true;
            if (opt.alias)
                self.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) {
                self.deprecateOption(key, deprecate);
            }
            const demand = opt.demand || opt.required || opt.require;
            if (demand) {
                self.demand(key, demand);
            }
            if (opt.demandOption) {
                self.demandOption(key, typeof opt.demandOption === &#039;string&#039; ? opt.demandOption : undefined);
            }
            if (opt.conflicts) {
                self.conflicts(key, opt.conflicts);
            }
            if (&#039;default&#039; in opt) {
                self.default(key, opt.default);
            }
            if (opt.implies !== undefined) {
                self.implies(key, opt.implies);
            }
            if (opt.nargs !== undefined) {
                self.nargs(key, opt.nargs);
            }
            if (opt.config) {
                self.config(key, opt.configParser);
            }
            if (opt.normalize) {
                self.normalize(key);
            }
            if (opt.choices) {
                self.choices(key, opt.choices);
            }
            if (opt.coerce) {
                self.coerce(key, opt.coerce);
            }
            if (opt.group) {
                self.group(key, opt.group);
            }
            if (opt.boolean || opt.type === &#039;boolean&#039;) {
                self.boolean(key);
                if (opt.alias)
                    self.boolean(opt.alias);
            }
            if (opt.array || opt.type === &#039;array&#039;) {
                self.array(key);
                if (opt.alias)
                    self.array(opt.alias);
            }
            if (opt.number || opt.type === &#039;number&#039;) {
                self.number(key);
                if (opt.alias)
                    self.number(opt.alias);
            }
            if (opt.string || opt.type === &#039;string&#039;) {
                self.string(key);
                if (opt.alias)
                    self.string(opt.alias);
            }
            if (opt.count || opt.type === &#039;count&#039;) {
                self.count(key);
            }
            if (typeof opt.global === &#039;boolean&#039;) {
                self.global(key, opt.global);
            }
            if (opt.defaultDescription) {
                options.defaultDescription[key] = opt.defaultDescription;
            }
            if (opt.skipValidation) {
                self.skipValidation(key);
            }
            const desc = opt.describe || opt.description || opt.desc;
            self.describe(key, desc);
            if (opt.hidden) {
                self.hide(key);
            }
            if (opt.requiresArg) {
                self.requiresArg(key);
            }
        }
        return self;
    };
    self.getOptions = () =&gt; options;
    self.positional = function (key, opts) {
        argsert(&#039;&lt;string&gt; &lt;object&gt;&#039;, [key, opts], arguments.length);
        if (context.resets === 0) {
            throw new YError(&quot;.positional() can only be called in a command&#039;s builder function&quot;);
        }
        const supportedOpts = [
            &#039;default&#039;,
            &#039;defaultDescription&#039;,
            &#039;implies&#039;,
            &#039;normalize&#039;,
            &#039;choices&#039;,
            &#039;conflicts&#039;,
            &#039;coerce&#039;,
            &#039;type&#039;,
            &#039;describe&#039;,
            &#039;desc&#039;,
            &#039;description&#039;,
            &#039;alias&#039;,
        ];
        opts = objFilter(opts, (k, v) =&gt; {
            let accept = supportedOpts.indexOf(k) !== -1;
            if (k === &#039;type&#039; &amp;&amp; [&#039;string&#039;, &#039;number&#039;, &#039;boolean&#039;].indexOf(v) === -1)
                accept = false;
            return accept;
        });
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand
            ? command.cmdToParseOptions(fullCommand)
            : {
                array: [],
                alias: {},
                default: {},
                demand: {},
            };
        objectKeys(parseOptions).forEach(pk =&gt; {
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) {
                if (parseOption.indexOf(key) !== -1)
                    opts[pk] = true;
            }
            else {
                if (parseOption[key] &amp;&amp; !(pk in opts))
                    opts[pk] = parseOption[key];
            }
        });
        self.group(key, usage.getPositionalGroupName());
        return self.option(key, opts);
    };
    self.group = function group(opts, groupName) {
        argsert(&#039;&lt;string|array&gt; &lt;string&gt;&#039;, [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) {
            delete preservedGroups[groupName];
        }
        const seen = {};
        groups[groupName] = (existing || []).concat(opts).filter(key =&gt; {
            if (seen[key])
                return false;
            return (seen[key] = true);
        });
        return self;
    };
    self.getGroups = () =&gt; Object.assign({}, groups, preservedGroups);
    self.env = function (prefix) {
        argsert(&#039;[string|boolean]&#039;, [prefix], arguments.length);
        if (prefix === false)
            delete options.envPrefix;
        else
            options.envPrefix = prefix || &#039;&#039;;
        return self;
    };
    self.wrap = function (cols) {
        argsert(&#039;&lt;number|null|undefined&gt;&#039;, [cols], arguments.length);
        usage.wrap(cols);
        return self;
    };
    let strict = false;
    self.strict = function (enabled) {
        argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        strict = enabled !== false;
        return self;
    };
    self.getStrict = () =&gt; strict;
    let strictCommands = false;
    self.strictCommands = function (enabled) {
        argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self;
    };
    self.getStrictCommands = () =&gt; strictCommands;
    let strictOptions = false;
    self.strictOptions = function (enabled) {
        argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        strictOptions = enabled !== false;
        return self;
    };
    self.getStrictOptions = () =&gt; strictOptions;
    let parserConfig = {};
    self.parserConfiguration = function parserConfiguration(config) {
        argsert(&#039;&lt;object&gt;&#039;, [config], arguments.length);
        parserConfig = config;
        return self;
    };
    self.getParserConfiguration = () =&gt; parserConfig;
    self.showHelp = function (level) {
        argsert(&#039;[string|function]&#039;, [level], arguments.length);
        if (!self.parsed)
            self._parseArgs(processArgs);
        if (command.hasDefaultCommand()) {
            context.resets++;
            command.runDefaultBuilderOn(self);
        }
        usage.showHelp(level);
        return self;
    };
    let versionOpt = null;
    self.version = function version(opt, msg, ver) {
        const defaultVersionOpt = &#039;version&#039;;
        argsert(&#039;[boolean|string] [string] [string]&#039;, [opt, msg, ver], arguments.length);
        if (versionOpt) {
            deleteFromParserHintObject(versionOpt);
            usage.version(undefined);
            versionOpt = null;
        }
        if (arguments.length === 0) {
            ver = guessVersion();
            opt = defaultVersionOpt;
        }
        else if (arguments.length === 1) {
            if (opt === false) {
                return self;
            }
            ver = opt;
            opt = defaultVersionOpt;
        }
        else if (arguments.length === 2) {
            ver = msg;
            msg = undefined;
        }
        versionOpt = typeof opt === &#039;string&#039; ? opt : defaultVersionOpt;
        msg = msg || usage.deferY18nLookup(&#039;Show version number&#039;);
        usage.version(ver || undefined);
        self.boolean(versionOpt);
        self.describe(versionOpt, msg);
        return self;
    };
    function guessVersion() {
        const obj = pkgUp();
        return obj.version || &#039;unknown&#039;;
    }
    let helpOpt = null;
    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {
        const defaultHelpOpt = &#039;help&#039;;
        argsert(&#039;[string|boolean] [string]&#039;, [opt, msg], arguments.length);
        if (helpOpt) {
            deleteFromParserHintObject(helpOpt);
            helpOpt = null;
        }
        if (arguments.length === 1) {
            if (opt === false)
                return self;
        }
        helpOpt = typeof opt === &#039;string&#039; ? opt : defaultHelpOpt;
        self.boolean(helpOpt);
        self.describe(helpOpt, msg || usage.deferY18nLookup(&#039;Show help&#039;));
        return self;
    };
    const defaultShowHiddenOpt = &#039;show-hidden&#039;;
    options.showHiddenOpt = defaultShowHiddenOpt;
    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {
        argsert(&#039;[string|boolean] [string]&#039;, [opt, msg], arguments.length);
        if (arguments.length === 1) {
            if (opt === false)
                return self;
        }
        const showHiddenOpt = typeof opt === &#039;string&#039; ? opt : defaultShowHiddenOpt;
        self.boolean(showHiddenOpt);
        self.describe(showHiddenOpt, msg || usage.deferY18nLookup(&#039;Show hidden options&#039;));
        options.showHiddenOpt = showHiddenOpt;
        return self;
    };
    self.hide = function hide(key) {
        argsert(&#039;&lt;string&gt;&#039;, [key], arguments.length);
        options.hiddenOptions.push(key);
        return self;
    };
    self.showHelpOnFail = function showHelpOnFail(enabled, message) {
        argsert(&#039;[boolean|string] [string]&#039;, [enabled, message], arguments.length);
        usage.showHelpOnFail(enabled, message);
        return self;
    };
    let exitProcess = true;
    self.exitProcess = function (enabled = true) {
        argsert(&#039;[boolean]&#039;, [enabled], arguments.length);
        exitProcess = enabled;
        return self;
    };
    self.getExitProcess = () =&gt; exitProcess;
    self.showCompletionScript = function ($0, cmd) {
        argsert(&#039;[string] [string]&#039;, [$0, cmd], arguments.length);
        $0 = $0 || self.$0;
        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || &#039;completion&#039;));
        return self;
    };
    self.getCompletion = function (args, done) {
        argsert(&#039;&lt;array&gt; &lt;function&gt;&#039;, [args, done], arguments.length);
        completion.getCompletion(args, done);
    };
    self.locale = function (locale) {
        argsert(&#039;[string]&#039;, [locale], arguments.length);
        if (!locale) {
            guessLocale();
            return y18n.getLocale();
        }
        detectLocale = false;
        y18n.setLocale(locale);
        return self;
    };
    self.updateStrings = self.updateLocale = function (obj) {
        argsert(&#039;&lt;object&gt;&#039;, [obj], arguments.length);
        detectLocale = false;
        y18n.updateLocale(obj);
        return self;
    };
    let detectLocale = true;
    self.detectLocale = function (detect) {
        argsert(&#039;&lt;boolean&gt;&#039;, [detect], arguments.length);
        detectLocale = detect;
        return self;
    };
    self.getDetectLocale = () =&gt; detectLocale;
    const _logger = {
        log(...args) {
            if (!self._hasParseCallback())
                console.log(...args);
            hasOutput = true;
            if (output.length)
                output += &#039;\n&#039;;
            output += args.join(&#039; &#039;);
        },
        error(...args) {
            if (!self._hasParseCallback())
                console.error(...args);
            hasOutput = true;
            if (output.length)
                output += &#039;\n&#039;;
            output += args.join(&#039; &#039;);
        },
    };
    self._getLoggerInstance = () =&gt; _logger;
    self._hasOutput = () =&gt; hasOutput;
    self._setHasOutput = () =&gt; {
        hasOutput = true;
    };
    let recommendCommands;
    self.recommendCommands = function (recommend = true) {
        argsert(&#039;[boolean]&#039;, [recommend], arguments.length);
        recommendCommands = recommend;
        return self;
    };
    self.getUsageInstance = () =&gt; usage;
    self.getValidationInstance = () =&gt; validation;
    self.getCommandInstance = () =&gt; command;
    self.terminalWidth = () =&gt; {
        argsert([], 0);
        return shim.process.stdColumns;
    };
    Object.defineProperty(self, &#039;argv&#039;, {
        get: () =&gt; self._parseArgs(processArgs),
        enumerable: true,
    });
    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {
        let skipValidation = !!_calledFromCommand;
        args = args || processArgs;
        options.__ = y18n.__;
        options.configuration = self.getParserConfiguration();
        const populateDoubleDash = !!options.configuration[&#039;populate--&#039;];
        const config = Object.assign({}, options.configuration, {
            &#039;populate--&#039;: true,
        });
        const parsed = shim.Parser.detailed(args, Object.assign({}, options, {
            configuration: Object.assign({ &#039;parse-positional-numbers&#039;: false }, config),
        }));
        let argv = parsed.argv;
        if (parseContext)
            argv = Object.assign({}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self.$0;
        self.parsed = parsed;
        try {
            guessLocale();
            if (shortCircuit) {
                return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
            }
            if (helpOpt) {
                const helpCmds = [helpOpt]
                    .concat(aliases[helpOpt] || [])
                    .filter(k =&gt; k.length &gt; 1);
                if (~helpCmds.indexOf(&#039;&#039; + argv._[argv._.length - 1])) {
                    argv._.pop();
                    argv[helpOpt] = true;
                }
            }
            const handlerKeys = command.getCommands();
            const requestCompletions = completion.completionKey in argv;
            const skipRecommendation = argv[helpOpt] || requestCompletions;
            const skipDefaultCommand = skipRecommendation &amp;&amp;
                (handlerKeys.length &gt; 1 || handlerKeys[0] !== &#039;$0&#039;);
            if (argv._.length) {
                if (handlerKeys.length) {
                    let firstUnknownCommand;
                    for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {
                        cmd = String(argv._[i]);
                        if (~handlerKeys.indexOf(cmd) &amp;&amp; cmd !== completionCommand) {
                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);
                            return self._postProcess(innerArgv, populateDoubleDash);
                        }
                        else if (!firstUnknownCommand &amp;&amp; cmd !== completionCommand) {
                            firstUnknownCommand = cmd;
                            break;
                        }
                    }
                    if (command.hasDefaultCommand() &amp;&amp; !skipDefaultCommand) {
                        const innerArgv = command.runCommand(null, self, parsed);
                        return self._postProcess(innerArgv, populateDoubleDash);
                    }
                    if (recommendCommands &amp;&amp; firstUnknownCommand &amp;&amp; !skipRecommendation) {
                        validation.recommendCommands(firstUnknownCommand, handlerKeys);
                    }
                }
                if (completionCommand &amp;&amp;
                    ~argv._.indexOf(completionCommand) &amp;&amp;
                    !requestCompletions) {
                    if (exitProcess)
                        setBlocking(true);
                    self.showCompletionScript();
                    self.exit(0);
                }
            }
            else if (command.hasDefaultCommand() &amp;&amp; !skipDefaultCommand) {
                const innerArgv = command.runCommand(null, self, parsed);
                return self._postProcess(innerArgv, populateDoubleDash);
            }
            if (requestCompletions) {
                if (exitProcess)
                    setBlocking(true);
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);
                completion.getCompletion(completionArgs, completions =&gt; {
                    (completions || []).forEach(completion =&gt; {
                        _logger.log(completion);
                    });
                    self.exit(0);
                });
                return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);
            }
            if (!hasOutput) {
                Object.keys(argv).forEach(key =&gt; {
                    if (key === helpOpt &amp;&amp; argv[key]) {
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        self.showHelp(&#039;log&#039;);
                        self.exit(0);
                    }
                    else if (key === versionOpt &amp;&amp; argv[key]) {
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        usage.showVersion();
                        self.exit(0);
                    }
                });
            }
            if (!skipValidation &amp;&amp; options.skipValidation.length &gt; 0) {
                skipValidation = Object.keys(argv).some(key =&gt; options.skipValidation.indexOf(key) &gt;= 0 &amp;&amp; argv[key] === true);
            }
            if (!skipValidation) {
                if (parsed.error)
                    throw new YError(parsed.error.message);
                if (!requestCompletions) {
                    self._runValidation(argv, aliases, {}, parsed.error);
                }
            }
        }
        catch (err) {
            if (err instanceof YError)
                usage.fail(err.message, err);
            else
                throw err;
        }
        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
    };
    self._postProcess = function (argv, populateDoubleDash, calledFromCommand = false) {
        if (isPromise(argv))
            return argv;
        if (calledFromCommand)
            return argv;
        if (!populateDoubleDash) {
            argv = self._copyDoubleDash(argv);
        }
        const parsePositionalNumbers = self.getParserConfiguration()[&#039;parse-positional-numbers&#039;] ||
            self.getParserConfiguration()[&#039;parse-positional-numbers&#039;] === undefined;
        if (parsePositionalNumbers) {
            argv = self._parsePositionalNumbers(argv);
        }
        return argv;
    };
    self._copyDoubleDash = function (argv) {
        if (!argv._ || !argv[&#039;--&#039;])
            return argv;
        argv._.push.apply(argv._, argv[&#039;--&#039;]);
        try {
            delete argv[&#039;--&#039;];
        }
        catch (_err) { }
        return argv;
    };
    self._parsePositionalNumbers = function (argv) {
        const args = argv[&#039;--&#039;] ? argv[&#039;--&#039;] : argv._;
        for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {
            if (shim.Parser.looksLikeNumber(arg) &amp;&amp;
                Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
                args[i] = Number(arg);
            }
        }
        return argv;
    };
    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {
        if (parseErrors)
            throw new YError(parseErrors.message);
        validation.nonOptionCount(argv);
        validation.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) {
            failedStrictCommands = validation.unknownCommands(argv);
        }
        if (strict &amp;&amp; !failedStrictCommands) {
            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
        }
        else if (strictOptions) {
            validation.unknownArguments(argv, aliases, {}, false, false);
        }
        validation.customChecks(argv, aliases);
        validation.limitedChoices(argv);
        validation.implications(argv);
        validation.conflicting(argv);
    };
    function guessLocale() {
        if (!detectLocale)
            return;
        const locale = shim.getEnv(&#039;LC_ALL&#039;) ||
            shim.getEnv(&#039;LC_MESSAGES&#039;) ||
            shim.getEnv(&#039;LANG&#039;) ||
            shim.getEnv(&#039;LANGUAGE&#039;) ||
            &#039;en_US&#039;;
        self.locale(locale.replace(/[.:].*/, &#039;&#039;));
    }
    self.help();
    self.version();
    return self;
}
export const rebase = (base, dir) =&gt; shim.path.relative(base, dir);
export function isYargsInstance(y) {
    return !!y &amp;&amp; typeof y._parseArgs === &#039;function&#039;;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
