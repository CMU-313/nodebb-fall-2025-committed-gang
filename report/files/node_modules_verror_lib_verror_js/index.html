<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/verror/lib/verror.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/verror/lib/verror.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.20</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">452</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * verror.js: richer JavaScript errors
 */

var mod_assertplus = require(&#039;assert-plus&#039;);
var mod_util = require(&#039;util&#039;);

var mod_extsprintf = require(&#039;extsprintf&#039;);
var mod_isError = require(&#039;core-util-is&#039;).isError;
var sprintf = mod_extsprintf.sprintf;

/*
 * Public interface
 */

/* So you can &#039;var VError = require(&#039;verror&#039;)&#039; */
module.exports = VError;
/* For compatibility */
VError.VError = VError;
/* Other exported classes */
VError.SError = SError;
VError.WError = WError;
VError.MultiError = MultiError;

/*
 * Common function used to parse constructor arguments for VError, WError, and
 * SError.  Named arguments to this function:
 *
 *     strict		force strict interpretation of sprintf arguments, even
 *     			if the options in &quot;argv&quot; don&#039;t say so
 *
 *     argv		error&#039;s constructor arguments, which are to be
 *     			interpreted as described in README.md.  For quick
 *     			reference, &quot;argv&quot; has one of the following forms:
 *
 *          [ sprintf_args... ]           (argv[0] is a string)
 *          [ cause, sprintf_args... ]    (argv[0] is an Error)
 *          [ options, sprintf_args... ]  (argv[0] is an object)
 *
 * This function normalizes these forms, producing an object with the following
 * properties:
 *
 *    options           equivalent to &quot;options&quot; in third form.  This will never
 *    			be a direct reference to what the caller passed in
 *    			(i.e., it may be a shallow copy), so it can be freely
 *    			modified.
 *
 *    shortmessage      result of sprintf(sprintf_args), taking options.strict
 *    			into account as described in README.md.
 */
function parseConstructorArguments(args)
{
	var argv, options, sprintf_args, shortmessage, k;

	mod_assertplus.object(args, &#039;args&#039;);
	mod_assertplus.bool(args.strict, &#039;args.strict&#039;);
	mod_assertplus.array(args.argv, &#039;args.argv&#039;);
	argv = args.argv;

	/*
	 * First, figure out which form of invocation we&#039;ve been given.
	 */
	if (argv.length === 0) {
		options = {};
		sprintf_args = [];
	} else if (mod_isError(argv[0])) {
		options = { &#039;cause&#039;: argv[0] };
		sprintf_args = argv.slice(1);
	} else if (typeof (argv[0]) === &#039;object&#039;) {
		options = {};
		for (k in argv[0]) {
			options[k] = argv[0][k];
		}
		sprintf_args = argv.slice(1);
	} else {
		mod_assertplus.string(argv[0],
		    &#039;first argument to VError, SError, or WError &#039; +
		    &#039;constructor must be a string, object, or Error&#039;);
		options = {};
		sprintf_args = argv;
	}

	/*
	 * Now construct the error&#039;s message.
	 *
	 * extsprintf (which we invoke here with our caller&#039;s arguments in order
	 * to construct this Error&#039;s message) is strict in its interpretation of
	 * values to be processed by the &quot;%s&quot; specifier.  The value passed to
	 * extsprintf must actually be a string or something convertible to a
	 * String using .toString().  Passing other values (notably &quot;null&quot; and
	 * &quot;undefined&quot;) is considered a programmer error.  The assumption is
	 * that if you actually want to print the string &quot;null&quot; or &quot;undefined&quot;,
	 * then that&#039;s easy to do that when you&#039;re calling extsprintf; on the
	 * other hand, if you did NOT want that (i.e., there&#039;s actually a bug
	 * where the program assumes some variable is non-null and tries to
	 * print it, which might happen when constructing a packet or file in
	 * some specific format), then it&#039;s better to stop immediately than
	 * produce bogus output.
	 *
	 * However, sometimes the bug is only in the code calling VError, and a
	 * programmer might prefer to have the error message contain &quot;null&quot; or
	 * &quot;undefined&quot; rather than have the bug in the error path crash the
	 * program (making the first bug harder to identify).  For that reason,
	 * by default VError converts &quot;null&quot; or &quot;undefined&quot; arguments to their
	 * string representations and passes those to extsprintf.  Programmers
	 * desiring the strict behavior can use the SError class or pass the
	 * &quot;strict&quot; option to the VError constructor.
	 */
	mod_assertplus.object(options);
	if (!options.strict &amp;&amp; !args.strict) {
		sprintf_args = sprintf_args.map(function (a) {
			return (a === null ? &#039;null&#039; :
			    a === undefined ? &#039;undefined&#039; : a);
		});
	}

	if (sprintf_args.length === 0) {
		shortmessage = &#039;&#039;;
	} else {
		shortmessage = sprintf.apply(null, sprintf_args);
	}

	return ({
	    &#039;options&#039;: options,
	    &#039;shortmessage&#039;: shortmessage
	});
}

/*
 * See README.md for reference documentation.
 */
function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	/*
	 * This is a regrettable pattern, but JavaScript&#039;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &quot;new&quot;.
	 */
	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#039;argv&#039;: args,
	    &#039;strict&#039;: false
	});

	/*
	 * If we&#039;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#039;error\&#039;s &quot;name&quot; must be a string&#039;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#039;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#039;cause is not an Error&#039;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#039;: &#039; + cause.message;
		}
	}

	/*
	 * If we&#039;ve been given an object with properties, shallow-copy that
	 * here.  We don&#039;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#039;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}

mod_util.inherits(VError, Error);
VError.prototype.name = &#039;VError&#039;;

VError.prototype.toString = function ve_toString()
{
	var str = (this.hasOwnProperty(&#039;name&#039;) &amp;&amp; this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += &#039;: &#039; + this.message;

	return (str);
};

/*
 * This method is provided for compatibility.  New callers should use
 * VError.cause() instead.  That method also uses the saner `null` return value
 * when there is no cause.
 */
VError.prototype.cause = function ve_cause()
{
	var cause = VError.cause(this);
	return (cause === null ? undefined : cause);
};

/*
 * Static methods
 *
 * These class-level methods are provided so that callers can use them on
 * instances of Errors that are not VErrors.  New interfaces should be provided
 * only using static methods to eliminate the class of programming mistake where
 * people fail to check whether the Error object has the corresponding methods.
 */

VError.cause = function (err)
{
	mod_assertplus.ok(mod_isError(err), &#039;err must be an Error&#039;);
	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
};

VError.info = function (err)
{
	var rv, cause, k;

	mod_assertplus.ok(mod_isError(err), &#039;err must be an Error&#039;);
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}

	if (typeof (err.jse_info) == &#039;object&#039; &amp;&amp; err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}

	return (rv);
};

VError.findCauseByName = function (err, name)
{
	var cause;

	mod_assertplus.ok(mod_isError(err), &#039;err must be an Error&#039;);
	mod_assertplus.string(name, &#039;name&#039;);
	mod_assertplus.ok(name.length &gt; 0, &#039;name cannot be empty&#039;);

	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		mod_assertplus.ok(mod_isError(cause));
		if (cause.name == name) {
			return (cause);
		}
	}

	return (null);
};

VError.hasCauseWithName = function (err, name)
{
	return (VError.findCauseByName(err, name) !== null);
};

VError.fullStack = function (err)
{
	mod_assertplus.ok(mod_isError(err), &#039;err must be an Error&#039;);

	var cause = VError.cause(err);

	if (cause) {
		return (err.stack + &#039;\ncaused by: &#039; + VError.fullStack(cause));
	}

	return (err.stack);
};

VError.errorFromList = function (errors)
{
	mod_assertplus.arrayOfObject(errors, &#039;errors&#039;);

	if (errors.length === 0) {
		return (null);
	}

	errors.forEach(function (e) {
		mod_assertplus.ok(mod_isError(e));
	});

	if (errors.length == 1) {
		return (errors[0]);
	}

	return (new MultiError(errors));
};

VError.errorForEach = function (err, func)
{
	mod_assertplus.ok(mod_isError(err), &#039;err must be an Error&#039;);
	mod_assertplus.func(func, &#039;func&#039;);

	if (err instanceof MultiError) {
		err.errors().forEach(function iterError(e) { func(e); });
	} else {
		func(err);
	}
};


/*
 * SError is like VError, but stricter about types.  You cannot pass &quot;null&quot; or
 * &quot;undefined&quot; as string arguments to the formatter.
 */
function SError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#039;argv&#039;: args,
	    &#039;strict&#039;: true
	});

	options = parsed.options;
	VError.call(this, options, &#039;%s&#039;, parsed.shortmessage);

	return (this);
}

/*
 * We don&#039;t bother setting SError.prototype.name because once constructed,
 * SErrors are just like VErrors.
 */
mod_util.inherits(SError, VError);


/*
 * Represents a collection of errors for the purpose of consumers that generally
 * only deal with one error.  Callers can extract the individual errors
 * contained in this object, but may also just treat it as a normal single
 * error, in which case a summary message will be printed.
 */
function MultiError(errors)
{
	mod_assertplus.array(errors, &#039;list of errors&#039;);
	mod_assertplus.ok(errors.length &gt; 0, &#039;must be at least one error&#039;);
	this.ase_errors = errors;

	VError.call(this, {
	    &#039;cause&#039;: errors[0]
	}, &#039;first of %d error%s&#039;, errors.length, errors.length == 1 ? &#039;&#039; : &#039;s&#039;);
}

mod_util.inherits(MultiError, VError);
MultiError.prototype.name = &#039;MultiError&#039;;

MultiError.prototype.errors = function me_errors()
{
	return (this.ase_errors.slice(0));
};


/*
 * See README.md for reference details.
 */
function WError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#039;argv&#039;: args,
	    &#039;strict&#039;: false
	});

	options = parsed.options;
	options[&#039;skipCauseMessage&#039;] = true;
	VError.call(this, options, &#039;%s&#039;, parsed.shortmessage);

	return (this);
}

mod_util.inherits(WError, VError);
WError.prototype.name = &#039;WError&#039;;

WError.prototype.toString = function we_toString()
{
	var str = (this.hasOwnProperty(&#039;name&#039;) &amp;&amp; this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += &#039;: &#039; + this.message;
	if (this.jse_cause &amp;&amp; this.jse_cause.message)
		str += &#039;; caused by &#039; + this.jse_cause.toString();

	return (str);
};

/*
 * For purely historical reasons, WError&#039;s cause() function allows you to set
 * the cause.
 */
WError.prototype.cause = function we_cause(c)
{
	if (mod_isError(c))
		this.jse_cause = c;

	return (this.jse_cause);
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
