<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/max-len.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/max-len.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">498</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">64.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to check for max length on a line.
 * @author Matt DuVall &lt;http://www.mattduvall.com&gt;
 * @deprecated in ESLint v8.53.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const OPTIONS_SCHEMA = {
	type: &quot;object&quot;,
	properties: {
		code: {
			type: &quot;integer&quot;,
			minimum: 0,
		},
		comments: {
			type: &quot;integer&quot;,
			minimum: 0,
		},
		tabWidth: {
			type: &quot;integer&quot;,
			minimum: 0,
		},
		ignorePattern: {
			type: &quot;string&quot;,
		},
		ignoreComments: {
			type: &quot;boolean&quot;,
		},
		ignoreStrings: {
			type: &quot;boolean&quot;,
		},
		ignoreUrls: {
			type: &quot;boolean&quot;,
		},
		ignoreTemplateLiterals: {
			type: &quot;boolean&quot;,
		},
		ignoreRegExpLiterals: {
			type: &quot;boolean&quot;,
		},
		ignoreTrailingComments: {
			type: &quot;boolean&quot;,
		},
	},
	additionalProperties: false,
};

const OPTIONS_OR_INTEGER_SCHEMA = {
	anyOf: [
		OPTIONS_SCHEMA,
		{
			type: &quot;integer&quot;,
			minimum: 0,
		},
	],
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin-js&quot;,
						url: &quot;https://eslint.style/packages/js&quot;,
					},
					rule: {
						name: &quot;max-len&quot;,
						url: &quot;https://eslint.style/rules/js/max-len&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description: &quot;Enforce a maximum line length&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/max-len&quot;,
		},

		schema: [
			OPTIONS_OR_INTEGER_SCHEMA,
			OPTIONS_OR_INTEGER_SCHEMA,
			OPTIONS_SCHEMA,
		],
		messages: {
			max: &quot;This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.&quot;,
			maxComment:
				&quot;This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.&quot;,
		},
	},

	create(context) {
		/*
		 * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:
		 * - They&#039;re matching an entire string that we know is a URI
		 * - We&#039;re matching part of a string where we think there *might* be a URL
		 * - We&#039;re only concerned about URLs, as picking out any URI would cause
		 *   too many false positives
		 * - We don&#039;t care about matching the entire URL, any small segment is fine
		 */
		const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;

		const sourceCode = context.sourceCode;

		/**
		 * Computes the length of a line that may contain tabs. The width of each
		 * tab will be the number of spaces to the next tab stop.
		 * @param {string} line The line.
		 * @param {number} tabWidth The width of each tab stop in spaces.
		 * @returns {number} The computed line length.
		 * @private
		 */
		function computeLineLength(line, tabWidth) {
			let extraCharacterCount = 0;

			line.replace(/\t/gu, (match, offset) =&gt; {
				const totalOffset = offset + extraCharacterCount,
					previousTabStopOffset = tabWidth
						? totalOffset % tabWidth
						: 0,
					spaceCount = tabWidth - previousTabStopOffset;

				extraCharacterCount += spaceCount - 1; // -1 for the replaced tab
			});
			return Array.from(line).length + extraCharacterCount;
		}

		// The options object must be the last option specified…
		const options = Object.assign({}, context.options.at(-1));

		// …but max code length…
		if (typeof context.options[0] === &quot;number&quot;) {
			options.code = context.options[0];
		}

		// …and tabWidth can be optionally specified directly as integers.
		if (typeof context.options[1] === &quot;number&quot;) {
			options.tabWidth = context.options[1];
		}

		const maxLength = typeof options.code === &quot;number&quot; ? options.code : 80,
			tabWidth =
				typeof options.tabWidth === &quot;number&quot; ? options.tabWidth : 4,
			ignoreComments = !!options.ignoreComments,
			ignoreStrings = !!options.ignoreStrings,
			ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,
			ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,
			ignoreTrailingComments =
				!!options.ignoreTrailingComments || !!options.ignoreComments,
			ignoreUrls = !!options.ignoreUrls,
			maxCommentLength = options.comments;
		let ignorePattern = options.ignorePattern || null;

		if (ignorePattern) {
			ignorePattern = new RegExp(ignorePattern, &quot;u&quot;);
		}

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		/**
		 * Tells if a given comment is trailing: it starts on the current line and
		 * extends to or past the end of the current line.
		 * @param {string} line The source line we want to check for a trailing comment on
		 * @param {number} lineNumber The one-indexed line number for line
		 * @param {ASTNode} comment The comment to inspect
		 * @returns {boolean} If the comment is trailing on the given line
		 */
		function isTrailingComment(line, lineNumber, comment) {
			return (
				comment &amp;&amp;
				comment.loc.start.line === lineNumber &amp;&amp;
				lineNumber &lt;= comment.loc.end.line &amp;&amp;
				(comment.loc.end.line &gt; lineNumber ||
					comment.loc.end.column === line.length)
			);
		}

		/**
		 * Tells if a comment encompasses the entire line.
		 * @param {string} line The source line with a trailing comment
		 * @param {number} lineNumber The one-indexed line number this is on
		 * @param {ASTNode} comment The comment to remove
		 * @returns {boolean} If the comment covers the entire line
		 */
		function isFullLineComment(line, lineNumber, comment) {
			const start = comment.loc.start,
				end = comment.loc.end,
				isFirstTokenOnLine = !line
					.slice(0, comment.loc.start.column)
					.trim();

			return (
				comment &amp;&amp;
				(start.line &lt; lineNumber ||
					(start.line === lineNumber &amp;&amp; isFirstTokenOnLine)) &amp;&amp;
				(end.line &gt; lineNumber ||
					(end.line === lineNumber &amp;&amp; end.column === line.length))
			);
		}

		/**
		 * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.
		 * @param {ASTNode} node A node to check.
		 * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.
		 */
		function isJSXEmptyExpressionInSingleLineContainer(node) {
			if (
				!node ||
				!node.parent ||
				node.type !== &quot;JSXEmptyExpression&quot; ||
				node.parent.type !== &quot;JSXExpressionContainer&quot;
			) {
				return false;
			}

			const parent = node.parent;

			return parent.loc.start.line === parent.loc.end.line;
		}

		/**
		 * Gets the line after the comment and any remaining trailing whitespace is
		 * stripped.
		 * @param {string} line The source line with a trailing comment
		 * @param {ASTNode} comment The comment to remove
		 * @returns {string} Line without comment and trailing whitespace
		 */
		function stripTrailingComment(line, comment) {
			// loc.column is zero-indexed
			return line.slice(0, comment.loc.start.column).replace(/\s+$/u, &quot;&quot;);
		}

		/**
		 * Ensure that an array exists at [key] on `object`, and add `value` to it.
		 * @param {Object} object the object to mutate
		 * @param {string} key the object&#039;s key
		 * @param {any} value the value to add
		 * @returns {void}
		 * @private
		 */
		function ensureArrayAndPush(object, key, value) {
			if (!Array.isArray(object[key])) {
				object[key] = [];
			}
			object[key].push(value);
		}

		/**
		 * Retrieves an array containing all strings (&quot; or &#039;) in the source code.
		 * @returns {ASTNode[]} An array of string nodes.
		 */
		function getAllStrings() {
			return sourceCode.ast.tokens.filter(
				token =&gt;
					token.type === &quot;String&quot; ||
					(token.type === &quot;JSXText&quot; &amp;&amp;
						sourceCode.getNodeByRangeIndex(token.range[0] - 1)
							.type === &quot;JSXAttribute&quot;),
			);
		}

		/**
		 * Retrieves an array containing all template literals in the source code.
		 * @returns {ASTNode[]} An array of template literal nodes.
		 */
		function getAllTemplateLiterals() {
			return sourceCode.ast.tokens.filter(
				token =&gt; token.type === &quot;Template&quot;,
			);
		}

		/**
		 * Retrieves an array containing all RegExp literals in the source code.
		 * @returns {ASTNode[]} An array of RegExp literal nodes.
		 */
		function getAllRegExpLiterals() {
			return sourceCode.ast.tokens.filter(
				token =&gt; token.type === &quot;RegularExpression&quot;,
			);
		}

		/**
		 *
		 * reduce an array of AST nodes by line number, both start and end.
		 * @param {ASTNode[]} arr array of AST nodes
		 * @returns {Object} accululated AST nodes
		 */
		function groupArrayByLineNumber(arr) {
			const obj = {};

			for (let i = 0; i &lt; arr.length; i++) {
				const node = arr[i];

				for (let j = node.loc.start.line; j &lt;= node.loc.end.line; ++j) {
					ensureArrayAndPush(obj, j, node);
				}
			}
			return obj;
		}

		/**
		 * Returns an array of all comments in the source code.
		 * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,
		 * the element is changed with JSXExpressionContainer node.
		 * @returns {ASTNode[]} An array of comment nodes
		 */
		function getAllComments() {
			const comments = [];

			sourceCode.getAllComments().forEach(commentNode =&gt; {
				const containingNode = sourceCode.getNodeByRangeIndex(
					commentNode.range[0],
				);

				if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
					// push a unique node only
					if (comments.at(-1) !== containingNode.parent) {
						comments.push(containingNode.parent);
					}
				} else {
					comments.push(commentNode);
				}
			});

			return comments;
		}

		/**
		 * Check the program for max length
		 * @param {ASTNode} node Node to examine
		 * @returns {void}
		 * @private
		 */
		function checkProgramForMaxLength(node) {
			// split (honors line-ending)
			const lines = sourceCode.lines,
				// list of comments to ignore
				comments =
					ignoreComments || maxCommentLength || ignoreTrailingComments
						? getAllComments()
						: [];

			// we iterate over comments in parallel with the lines
			let commentsIndex = 0;

			const strings = getAllStrings();
			const stringsByLine = groupArrayByLineNumber(strings);

			const templateLiterals = getAllTemplateLiterals();
			const templateLiteralsByLine =
				groupArrayByLineNumber(templateLiterals);

			const regExpLiterals = getAllRegExpLiterals();
			const regExpLiteralsByLine = groupArrayByLineNumber(regExpLiterals);

			lines.forEach((line, i) =&gt; {
				// i is zero-indexed, line numbers are one-indexed
				const lineNumber = i + 1;

				/*
				 * if we&#039;re checking comment length; we need to know whether this
				 * line is a comment
				 */
				let lineIsComment = false;
				let textToMeasure;

				/*
				 * We can short-circuit the comment checks if we&#039;re already out of
				 * comments to check.
				 */
				if (commentsIndex &lt; comments.length) {
					let comment;

					// iterate over comments until we find one past the current line
					do {
						comment = comments[++commentsIndex];
					} while (comment &amp;&amp; comment.loc.start.line &lt;= lineNumber);

					// and step back by one
					comment = comments[--commentsIndex];

					if (isFullLineComment(line, lineNumber, comment)) {
						lineIsComment = true;
						textToMeasure = line;
					} else if (
						ignoreTrailingComments &amp;&amp;
						isTrailingComment(line, lineNumber, comment)
					) {
						textToMeasure = stripTrailingComment(line, comment);

						// ignore multiple trailing comments in the same line
						let lastIndex = commentsIndex;

						while (
							isTrailingComment(
								textToMeasure,
								lineNumber,
								comments[--lastIndex],
							)
						) {
							textToMeasure = stripTrailingComment(
								textToMeasure,
								comments[lastIndex],
							);
						}
					} else {
						textToMeasure = line;
					}
				} else {
					textToMeasure = line;
				}
				if (
					(ignorePattern &amp;&amp; ignorePattern.test(textToMeasure)) ||
					(ignoreUrls &amp;&amp; URL_REGEXP.test(textToMeasure)) ||
					(ignoreStrings &amp;&amp; stringsByLine[lineNumber]) ||
					(ignoreTemplateLiterals &amp;&amp;
						templateLiteralsByLine[lineNumber]) ||
					(ignoreRegExpLiterals &amp;&amp; regExpLiteralsByLine[lineNumber])
				) {
					// ignore this line
					return;
				}

				const lineLength = computeLineLength(textToMeasure, tabWidth);
				const commentLengthApplies = lineIsComment &amp;&amp; maxCommentLength;

				if (lineIsComment &amp;&amp; ignoreComments) {
					return;
				}

				const loc = {
					start: {
						line: lineNumber,
						column: 0,
					},
					end: {
						line: lineNumber,
						column: textToMeasure.length,
					},
				};

				if (commentLengthApplies) {
					if (lineLength &gt; maxCommentLength) {
						context.report({
							node,
							loc,
							messageId: &quot;maxComment&quot;,
							data: {
								lineLength,
								maxCommentLength,
							},
						});
					}
				} else if (lineLength &gt; maxLength) {
					context.report({
						node,
						loc,
						messageId: &quot;max&quot;,
						data: {
							lineLength,
							maxLength,
						},
					});
				}
			});
		}

		//--------------------------------------------------------------------------
		// Public API
		//--------------------------------------------------------------------------

		return {
			Program: checkProgramForMaxLength,
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
