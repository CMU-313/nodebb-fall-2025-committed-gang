<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cbor/lib/encoder.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cbor/lib/encoder.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">705</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.15</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

const stream = require(&#039;stream&#039;)
const url = require(&#039;url&#039;)
const bignumber = require(&#039;bignumber.js&#039;).BigNumber
const NoFilter = require(&#039;nofilter&#039;)
const Tagged = require(&#039;./tagged&#039;)
const Simple = require(&#039;./simple&#039;)
const utils = require(&#039;./utils&#039;)

const constants = require(&#039;./constants&#039;)
const MT = constants.MT
const NUMBYTES = constants.NUMBYTES
const SHIFT32 = constants.SHIFT32
const SYMS = constants.SYMS
const TAG = constants.TAG
const HALF = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.NUMBYTES.TWO
const FLOAT = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.NUMBYTES.FOUR
const DOUBLE = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.NUMBYTES.EIGHT
const TRUE = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.SIMPLE.TRUE
const FALSE = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.SIMPLE.FALSE
const UNDEFINED = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.SIMPLE.UNDEFINED
const NULL = (constants.MT.SIMPLE_FLOAT &lt;&lt; 5) | constants.SIMPLE.NULL

const MAXINT_BN = new bignumber(&#039;0x20000000000000&#039;)
const BUF_NAN = Buffer.from(&#039;f97e00&#039;, &#039;hex&#039;)
const BUF_INF_NEG = Buffer.from(&#039;f9fc00&#039;, &#039;hex&#039;)
const BUF_INF_POS = Buffer.from(&#039;f97c00&#039;, &#039;hex&#039;)
const BUF_NEG_ZERO = Buffer.from(&#039;f98000&#039;, &#039;hex&#039;)
const LOOP_DETECT = Symbol(&#039;CBOR_LOOP_DETECT&#039;)

/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends {stream.Transform}
 */
class Encoder extends stream.Transform {

  /**
   * Creates an instance of Encoder.
   *
   * @param {Object} [options={}] - options for the encoder
   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,
   *   `function(Encoder)` for semantic types to be encoded.  Not needed
   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.
   * @param {boolean} [options.canonical=false] - should the output be
   *   canonicalized
   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops
   *   be detected?  This will currently modify the encoded object graph
   *   by adding a Symbol property to each object.  If this bothers you,
   *   call `removeLoopDetectors` on the encoded object when done.  Do not
   *   encode the same object twice on the same encoder, without calling
   *   `removeLoopDetectors` in between.
   * @param {(&quot;number&quot;|&quot;float&quot;|&quot;int&quot;|&quot;string&quot;)} [options.dateType=&quot;number&quot;] -
   *   how should dates be encoded?  &quot;number&quot; means float or int, if no
   *   fractional seconds.
   * @param {any} [options.encodeUndefined=undefined] - How should an 
   *   &quot;undefined&quot; in the input be encoded.  By default, just encode a CBOR
   *   undefined.  If this is a buffer, use those bytes without re-encoding
   *   them.  If this is a function, the function will be called (which is
   *   a good time to throw an exception, if that&#039;s what you want), and the 
   *   return value will be used according to these rules.  Anything
   *   else will be encoded as CBOR.
   * @param {boolean} [options.disallowUndefinedKeys=false] - Should &quot;undefined&quot;
   *   be disallowed as a key in a Map that is serialized?  If this is true,
   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that
   *   it is impossible to get a key of undefined in a normal JS object.
   */
  constructor(options) {
    const opts = Object.assign({}, options, {
      readableObjectMode: false,
      writableObjectMode: true
    })
    super(opts)

    this.canonical = opts.canonical
    this.encodeUndefined = opts.encodeUndefined
    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys
    this.dateType = (opts.dateType != null) ?
      opts.dateType.toLowerCase() : &#039;number&#039;

    // new Symbol for each instance.  Note: means we can&#039;t re-use the same
    // encoder and encoded object
    if (typeof(opts.detectLoops) === &#039;symbol&#039;) {
      this.detectLoops = opts.detectLoops
    } else {
      this.detectLoops = !!opts.detectLoops ? Symbol(&#039;CBOR_DETECT&#039;) : null
    }

    this.semanticTypes = [
      Array, this._pushArray,
      Date, this._pushDate,
      Buffer, this._pushBuffer,
      Map, this._pushMap,
      NoFilter, this._pushNoFilter,
      RegExp, this._pushRegexp,
      Set, this._pushSet,
      bignumber, this._pushBigNumber,
      ArrayBuffer, this._pushUint8Array,
      Uint8ClampedArray, this._pushUint8Array,
      Uint8Array, this._pushUint8Array,
      Uint16Array, this._pushArray,
      Uint32Array, this._pushArray,
      Int8Array, this._pushArray,
      Int16Array, this._pushArray,
      Int32Array, this._pushArray,
      Float32Array, this._pushFloat32Array,
      Float64Array, this._pushFloat64Array
    ]

    // tsc doesn&#039;t know about old Url
    if (url[&#039;Url&#039;]) {
      this.semanticTypes.push(url[&#039;Url&#039;], this._pushUrl)
    }
    if (url[&#039;URL&#039;]) {
      this.semanticTypes.push(url[&#039;URL&#039;], this._pushURL)
    }

    const addTypes = opts.genTypes || []
    for (let i = 0, len = addTypes.length; i &lt; len; i += 2) {
      this.addSemanticType(addTypes[i], addTypes[i + 1])
    }
  }

  _transform(fresh, encoding, cb) {
    const ret = this.pushAny(fresh)
    // Old transformers might not return bool.  undefined !== false
    return cb((ret === false) ? new Error(&#039;Push Error&#039;) : undefined)
  }

  _flush(cb) {
    return cb()
  }

  /**
   * @callback encodeFunction
   * @param {Encoder} encoder - the encoder to serialize into.  Call &quot;write&quot;
   *   on the encoder as needed.
   * @return {bool} - true on success, else false
   */

  /**
   * Add an encoding function to the list of supported semantic types.  This is
   * useful for objects for which you can&#039;t add an encodeCBOR method
   *
   * @param {any} type
   * @param {any} fun
   * @returns {encodeFunction}
   */
  addSemanticType(type, fun) {
    for (let i = 0, len = this.semanticTypes.length; i &lt; len; i += 2) {
      const typ = this.semanticTypes[i]
      if (typ === type) {
        const old = this.semanticTypes[i + 1]
        this.semanticTypes[i + 1] = fun
        return old
      }
    }
    this.semanticTypes.push(type, fun)
    return null
  }

  _pushUInt8(val) {
    const b = Buffer.allocUnsafe(1)
    b.writeUInt8(val, 0)
    return this.push(b)
  }

  _pushUInt16BE(val) {
    const b = Buffer.allocUnsafe(2)
    b.writeUInt16BE(val, 0)
    return this.push(b)
  }

  _pushUInt32BE(val) {
    const b = Buffer.allocUnsafe(4)
    b.writeUInt32BE(val, 0)
    return this.push(b)
  }

  _pushFloatBE(val) {
    const b = Buffer.allocUnsafe(4)
    b.writeFloatBE(val, 0)
    return this.push(b)
  }

  _pushDoubleBE(val) {
    const b = Buffer.allocUnsafe(8)
    b.writeDoubleBE(val, 0)
    return this.push(b)
  }

  _pushNaN() {
    return this.push(BUF_NAN)
  }

  _pushInfinity(obj) {
    const half = (obj &lt; 0) ? BUF_INF_NEG : BUF_INF_POS
    return this.push(half)
  }

  _pushFloat(obj) {
    if (this.canonical) {
      // TODO: is this enough slower to hide behind canonical?
      // It&#039;s certainly enough of a hack (see utils.parseHalf)

      // From section 3.9:
      // If a protocol allows for IEEE floats, then additional canonicalization
      // rules might need to be added.  One example rule might be to have all
      // floats start as a 64-bit float, then do a test conversion to a 32-bit
      // float; if the result is the same numeric value, use the shorter value
      // and repeat the process with a test conversion to a 16-bit float.  (This
      // rule selects 16-bit float for positive and negative Infinity as well.)

      // which seems pretty much backwards to me.
      const b2 = Buffer.allocUnsafe(2)
      if (utils.writeHalf(b2, obj)) {
        if (utils.parseHalf(b2) === obj) {
          return this._pushUInt8(HALF) &amp;&amp; this.push(b2)
        }
      }
    }
    if (Math.fround(obj) === obj) {
      return this._pushUInt8(FLOAT) &amp;&amp; this._pushFloatBE(obj)
    }

    return this._pushUInt8(DOUBLE) &amp;&amp; this._pushDoubleBE(obj)
  }

  _pushInt(obj, mt, orig) {
    const m = mt &lt;&lt; 5
    switch (false) {
      case !(obj &lt; 24):
        return this._pushUInt8(m | obj)
      case !(obj &lt;= 0xff):
        return this._pushUInt8(m | NUMBYTES.ONE) &amp;&amp; this._pushUInt8(obj)
      case !(obj &lt;= 0xffff):
        return this._pushUInt8(m | NUMBYTES.TWO) &amp;&amp; this._pushUInt16BE(obj)
      case !(obj &lt;= 0xffffffff):
        return this._pushUInt8(m | NUMBYTES.FOUR) &amp;&amp; this._pushUInt32BE(obj)
      case !(obj &lt;= Number.MAX_SAFE_INTEGER):
        return this._pushUInt8(m | NUMBYTES.EIGHT) &amp;&amp;
          this._pushUInt32BE(Math.floor(obj / SHIFT32)) &amp;&amp;
          this._pushUInt32BE(obj % SHIFT32)
      default:
        if (mt === MT.NEG_INT) {
          return this._pushFloat(orig)
        } else {
          return this._pushFloat(obj)
        }
    }
  }

  _pushIntNum(obj) {
    if (Object.is(obj, -0)) {
      return this.push(BUF_NEG_ZERO)
    }

    if (obj &lt; 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj)
    } else {
      return this._pushInt(obj, MT.POS_INT)
    }
  }

  _pushNumber(obj) {
    switch (false) {
      case !isNaN(obj):
        return this._pushNaN()
      case isFinite(obj):
        return this._pushInfinity(obj)
      case Math.round(obj) !== obj:
        return this._pushIntNum(obj)
      default:
        return this._pushFloat(obj)
    }
  }

  _pushString(obj) {
    const len = Buffer.byteLength(obj, &#039;utf8&#039;)
    return this._pushInt(len, MT.UTF8_STRING) &amp;&amp; this.push(obj, &#039;utf8&#039;)
  }

  _pushBoolean(obj) {
    return this._pushUInt8(obj ? TRUE : FALSE)
  }

  _pushUndefined(obj) {
    switch (typeof this.encodeUndefined) {
      case &#039;undefined&#039;:
        return this._pushUInt8(UNDEFINED)
      case &#039;function&#039;:
        return this.pushAny(this.encodeUndefined.call(this, obj))
      case &#039;object&#039;:
        if (Buffer.isBuffer(this.encodeUndefined)) {
          return this.push(this.encodeUndefined)
        }
    }
    return this.pushAny(this.encodeUndefined)
  }

  _pushNull(obj) {
    return this._pushUInt8(NULL)
  }

  _pushArray(gen, obj) {
    const len = obj.length
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j &lt; len; j++) {
      if (!gen.pushAny(obj[j])) {
        return false
      }
    }
    return true
  }

  _pushTag(tag) {
    return this._pushInt(tag, MT.TAG)
  }

  _pushDate(gen, obj) {
    switch (gen.dateType) {
      case &#039;string&#039;:
        return gen._pushTag(TAG.DATE_STRING) &amp;&amp;
          gen._pushString(obj.toISOString())
      case &#039;int&#039;:
      case &#039;integer&#039;:
        return gen._pushTag(TAG.DATE_EPOCH) &amp;&amp;
          gen._pushIntNum(Math.round(obj / 1000))
      case &#039;float&#039;:
        // force float
        return gen._pushTag(TAG.DATE_EPOCH) &amp;&amp;
          gen._pushFloat(obj / 1000)
      case &#039;number&#039;:
      default:
        // if we happen to have an integral number of seconds,
        // use integer.  Otherwise, use float.
        return gen._pushTag(TAG.DATE_EPOCH) &amp;&amp;
          gen.pushAny(obj / 1000)
    }
  }

  _pushBuffer(gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) &amp;&amp; gen.push(obj)
  }

  _pushNoFilter(gen, obj) {
    return gen._pushBuffer(gen, obj.slice())
  }

  _pushRegexp(gen, obj) {
    return gen._pushTag(TAG.REGEXP) &amp;&amp; gen.pushAny(obj.source)
  }

  _pushSet(gen, obj) {
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false
    }
    for (const x of obj) {
      if (!gen.pushAny(x)) {
        return false
      }
    }
    return true
  }

  _pushUrl(gen, obj) {
    return gen._pushTag(TAG.URI) &amp;&amp; gen.pushAny(obj.format())
  }

  _pushURL(gen, obj) {
    return gen._pushTag(TAG.URI) &amp;&amp; gen.pushAny(obj.toString())
  }

  /**
   * @param {bignumber} obj
   * @private
   */
  _pushBigint(obj) {
    let tag = TAG.POS_BIGINT
    if (obj.isNegative()) {
      obj = obj.negated().minus(1)
      tag = TAG.NEG_BIGINT
    }
    let str = obj.toString(16)
    if (str.length % 2) {
      str = &#039;0&#039; + str
    }
    const buf = Buffer.from(str, &#039;hex&#039;)
    return this._pushTag(tag) &amp;&amp; this._pushBuffer(this, buf)
  }

  /**
   * @param {bigint} obj
   * @private
   */
  _pushJSBigint(obj) {
    let tag = TAG.POS_BIGINT
    if (obj &lt; 0) {
      obj = -obj + BigInt(&#039;-1&#039;) // avoid syntax error on old runtimes
      tag = TAG.NEG_BIGINT
    }
    let str = obj.toString(16)
    if (str.length % 2) {
      str = &#039;0&#039; + str
    }
    const buf = Buffer.from(str, &#039;hex&#039;)
    return this._pushTag(tag) &amp;&amp; this._pushBuffer(this, buf)
  }

  _pushBigNumber(gen, obj) {
    if (obj.isNaN()) {
      return gen._pushNaN()
    }
    if (!obj.isFinite()) {
      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)
    }
    if (obj.isInteger()) {
      return gen._pushBigint(obj)
    }
    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &amp;&amp;
      gen._pushInt(2, MT.ARRAY))) {
      return false
    }

    const dec = obj.decimalPlaces()
    const slide = obj.times(new bignumber(10).pow(dec))
    if (!gen._pushIntNum(-dec)) {
      return false
    }
    if (slide.abs().isLessThan(MAXINT_BN)) {
      return gen._pushIntNum(slide.toNumber())
    } else {
      return gen._pushBigint(slide)
    }
  }

  _pushMap(gen, obj) {
    if (!gen._pushInt(obj.size, MT.MAP)) {
      return false
    }
    // memoizing the cbor only helps in certain cases, and hurts in most
    // others.  Just avoid it.
    if (gen.canonical) {
      // keep the key/value pairs together, so we don&#039;t have to do odd
      // gets with object keys later
      const entries = [...obj.entries()]
      const enc = new Encoder(this) // TODO: fix genTypes
      const bs = new NoFilter({highWaterMark:this.readableHighWaterMark})
      enc.pipe(bs)
      entries.sort(([a], [b]) =&gt; {
        // a, b are the keys
        enc.pushAny(a)
        const a_cbor = bs.read()
        enc.pushAny(b)
        const b_cbor = bs.read()
        return a_cbor.compare(b_cbor)
      })
      for (const [k, v] of entries) {
        if (gen.disallowUndefinedKeys &amp;&amp; (typeof k === &#039;undefined&#039;)) {
          throw new Error(&#039;Invalid Map key: undefined&#039;)
        }
        if (!(gen.pushAny(k) &amp;&amp; gen.pushAny(v))) {
          return false
        }
      }
    } else {
      for (const [k, v] of obj) {
        if (gen.disallowUndefinedKeys &amp;&amp; (typeof k === &#039;undefined&#039;)) {
          throw new Error(&#039;Invalid Map key: undefined&#039;)
        }
        if (!(gen.pushAny(k) &amp;&amp; gen.pushAny(v))) {
          return false
        }
      }
    }
    return true
  }

  _pushUint8Array(gen, obj) {
    return gen._pushBuffer(gen, Buffer.from(obj))
  }

  _pushFloat32Array(gen, obj) {
    const len = obj.length
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j &lt; len; j++) {
      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {
        return false
      }
    }
    return true
  }

  _pushFloat64Array(gen, obj) {
    const len = obj.length
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j &lt; len; j++) {
      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {
        return false
      }
    }
    return true
  }

  removeLoopDetectors(obj) {
    if (!this.detectLoops || (typeof(obj) !== &#039;object&#039;) || !obj) {
      return false
    }
    const dl = obj[LOOP_DETECT]
    if (!dl || (dl !== this.detectLoops)) {
      // ironically, use loop marking to detect loops on removal as well
      return false
    }
    delete obj[LOOP_DETECT]
    if (Array.isArray(obj)) {
      for (const i of obj) {
        this.removeLoopDetectors(i)
      }
    } else {
      for (const k in obj) {
        this.removeLoopDetectors(obj[k])
      }
    }
    return true
  }

  _pushObject(obj) {
    if (!obj) {
      return this._pushNull(obj)
    }
    if (this.detectLoops) {
      if (obj[LOOP_DETECT] === this.detectLoops) {
        throw new Error(&#039;Loop detected while CBOR encoding&#039;)
      } else {
        obj[LOOP_DETECT] = this.detectLoops
      }
    }
    const f = obj.encodeCBOR
    if (typeof f === &#039;function&#039;) {
      return f.call(obj, this)
    }
    for (let i = 0, len1 = this.semanticTypes.length; i &lt; len1; i += 2) {
      const typ = this.semanticTypes[i]
      if (obj instanceof typ) {
        return this.semanticTypes[i + 1].call(obj, this, obj)
      }
    }
    const keys = Object.keys(obj)
    const cbor_keys = {}
    if (this.canonical) {
      // note: this can&#039;t be a normal sort, because &#039;b&#039; needs to sort before
      // &#039;aa&#039;
      keys.sort((a, b) =&gt; {
        // Always strings, so don&#039;t bother to pass options.
        // hold on to the cbor versions, since there&#039;s no need
        // to encode more than once
        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))
        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))

        return a_cbor.compare(b_cbor)
      })
    }
    if (!this._pushInt(keys.length, MT.MAP)) {
      return false
    }
    let ck
    for (let j = 0, len2 = keys.length; j &lt; len2; j++) {
      const k = keys[j]
      if (this.canonical &amp;&amp; ((ck = cbor_keys[k]))) {
        if (!this.push(ck)) { // already a Buffer
          return false
        }
      } else {
        if (!this._pushString(k)) {
          return false
        }
      }
      if (!this.pushAny(obj[k])) {
        return false
      }
    }

    return true
  }

  /**
   * Push any supported type onto the encoded stream
   *
   * @param {any} obj
   * @returns {boolean} true on success
   */
  pushAny(obj) {
    switch (typeof obj) {
      case &#039;number&#039;:
        return this._pushNumber(obj)
      case &#039;bigint&#039;:
        return this._pushJSBigint(obj)
      case &#039;string&#039;:
        return this._pushString(obj)
      case &#039;boolean&#039;:
        return this._pushBoolean(obj)
      case &#039;undefined&#039;:
        return this._pushUndefined(obj)
      case &#039;object&#039;:
        return this._pushObject(obj)
      case &#039;symbol&#039;:
        switch (obj) {
          case SYMS.NULL:
            return this._pushNull(null)
          case SYMS.UNDEFINED:
            return this._pushUndefined(void 0)
          // TODO: Add pluggable support for other symbols
          default:
            throw new Error(&#039;Unknown symbol: &#039; + obj.toString())
        }
      default:
        throw new Error(
          &#039;Unknown type: &#039; + typeof obj + &#039;, &#039; +
          (!!obj ? obj.toString() : &#039;&#039;))
    }
  }

  /* backwards-compat wrapper */
  _pushAny(obj) {
    // TODO: write deprecation warning
    return this.pushAny(obj)
  }

  _encodeAll(objs) {
    const bs = new NoFilter({ highWaterMark:this.readableHighWaterMark })
    this.pipe(bs)
    for (const o of objs) {
      this.pushAny(o)
    }
    this.end()
    return bs.read()
  }

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs - the objects to encode
   * @returns {Buffer} - the encoded objects
   */
  static encode(...objs) {
    return new Encoder()._encodeAll(objs)
  }

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} objs - the objects to encode
   * @returns {Buffer} - the encoded objects
   */
  static encodeCanonical(...objs) {
    return new Encoder({canonical: true})._encodeAll(objs)
  }

  /**
   * Encode one JavaScript object using the given options.
   *
   * @static
   * @param {any} obj - the object to encode
   * @param {Object?} options - passed to the Encoder constructor
   * @returns {Buffer} - the encoded objects
   */
  static encodeOne(obj, options) {
    return new Encoder(options)._encodeAll([obj])
  }

  /**
   * Encode one JavaScript object using the given options in a way that
   * is more resilient to objects being larger than the highWaterMark
   * number of bytes.  As with the other static encode functions, this 
   * will still use a large amount of memory.  Use a stream-based approach
   * directly if you need to process large and complicated inputs.
   *
   * @param {any} obj - the object to encode
   * @param {Object?} options - passed to the Encoder constructor
   */
  static encodeAsync(obj, options) {
    return new Promise((resolve, reject) =&gt; {
      const bufs = []
      const enc = new Encoder(options)
      enc.on(&#039;data&#039;, buf =&gt; bufs.push(buf))
      enc.on(&#039;error&#039;, reject)
      enc.on(&#039;finish&#039;, () =&gt; resolve(Buffer.concat(bufs)))
      enc.pushAny(obj)
      enc.end()
    })
  }
}

module.exports = Encoder
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
