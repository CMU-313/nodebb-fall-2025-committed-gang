<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/NormalModule.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/NormalModule.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1707</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">87.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.19</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const parseJson = require(&quot;json-parse-even-better-errors&quot;);
const { getContext, runLoaders } = require(&quot;loader-runner&quot;);
const querystring = require(&quot;querystring&quot;);
const {
	HookMap,
	SyncHook,
	SyncWaterfallHook,
	AsyncSeriesBailHook
} = require(&quot;tapable&quot;);
const {
	CachedSource,
	OriginalSource,
	RawSource,
	SourceMapSource
} = require(&quot;webpack-sources&quot;);
const Compilation = require(&quot;./Compilation&quot;);
const HookWebpackError = require(&quot;./HookWebpackError&quot;);
const Module = require(&quot;./Module&quot;);
const ModuleBuildError = require(&quot;./ModuleBuildError&quot;);
const ModuleError = require(&quot;./ModuleError&quot;);
const ModuleGraphConnection = require(&quot;./ModuleGraphConnection&quot;);
const ModuleParseError = require(&quot;./ModuleParseError&quot;);
const { JAVASCRIPT_MODULE_TYPE_AUTO } = require(&quot;./ModuleTypeConstants&quot;);
const ModuleWarning = require(&quot;./ModuleWarning&quot;);
const RuntimeGlobals = require(&quot;./RuntimeGlobals&quot;);
const UnhandledSchemeError = require(&quot;./UnhandledSchemeError&quot;);
const WebpackError = require(&quot;./WebpackError&quot;);
const formatLocation = require(&quot;./formatLocation&quot;);
const LazySet = require(&quot;./util/LazySet&quot;);
const { isSubset } = require(&quot;./util/SetHelpers&quot;);
const { getScheme } = require(&quot;./util/URLAbsoluteSpecifier&quot;);
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder
} = require(&quot;./util/comparators&quot;);
const createHash = require(&quot;./util/createHash&quot;);
const { createFakeHook } = require(&quot;./util/deprecation&quot;);
const { join } = require(&quot;./util/fs&quot;);
const {
	contextify,
	absolutify,
	makePathsRelative
} = require(&quot;./util/identifier&quot;);
const makeSerializable = require(&quot;./util/makeSerializable&quot;);
const memoize = require(&quot;./util/memoize&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).Mode} Mode */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).ResolveOptions} ResolveOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).NoParse} NoParse */
/** @typedef {import(&quot;./ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;./Compiler&quot;)} Compiler */
/** @typedef {import(&quot;./Dependency&quot;).UpdateHashContext} UpdateHashContext */
/** @typedef {import(&quot;./DependencyTemplates&quot;)} DependencyTemplates */
/** @typedef {import(&quot;./Generator&quot;)} Generator */
/** @typedef {import(&quot;./Generator&quot;).GenerateErrorFn} GenerateErrorFn */
/** @typedef {import(&quot;./Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;./Module&quot;).BuildMeta} BuildMeta */
/** @typedef {import(&quot;./Module&quot;).CodeGenerationContext} CodeGenerationContext */
/** @typedef {import(&quot;./Module&quot;).CodeGenerationResult} CodeGenerationResult */
/** @typedef {import(&quot;./Module&quot;).ConcatenationBailoutReasonContext} ConcatenationBailoutReasonContext */
/** @typedef {import(&quot;./Module&quot;).KnownBuildInfo} KnownBuildInfo */
/** @typedef {import(&quot;./Module&quot;).LibIdentOptions} LibIdentOptions */
/** @typedef {import(&quot;./Module&quot;).NeedBuildContext} NeedBuildContext */
/** @typedef {import(&quot;./Module&quot;).NeedBuildCallback} NeedBuildCallback */
/** @typedef {import(&quot;./Module&quot;).BuildCallback} BuildCallback */
/** @typedef {import(&quot;./Generator&quot;).SourceTypes} SourceTypes */
/** @typedef {import(&quot;./Module&quot;).UnsafeCacheData} UnsafeCacheData */
/** @typedef {import(&quot;./ModuleGraph&quot;)} ModuleGraph */
/** @typedef {import(&quot;./ModuleGraphConnection&quot;).ConnectionState} ConnectionState */
/** @typedef {import(&quot;./ModuleTypeConstants&quot;).JavaScriptModuleTypes} JavaScriptModuleTypes */
/** @typedef {import(&quot;./NormalModuleFactory&quot;)} NormalModuleFactory */
/** @typedef {import(&quot;./NormalModuleFactory&quot;).ResourceDataWithData} ResourceDataWithData */
/** @typedef {import(&quot;./Parser&quot;)} Parser */
/** @typedef {import(&quot;./Parser&quot;).PreparsedAst} PreparsedAst */
/** @typedef {import(&quot;./RequestShortener&quot;)} RequestShortener */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolveContext} ResolveContext */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolverWithOptions} ResolverWithOptions */
/** @typedef {import(&quot;./RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {import(&quot;./logging/Logger&quot;).Logger} WebpackLogger */
/** @typedef {import(&quot;./serialization/ObjectMiddleware&quot;).ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import(&quot;./serialization/ObjectMiddleware&quot;).ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import(&quot;./util/Hash&quot;)} Hash */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/** @typedef {import(&quot;./util/runtime&quot;).RuntimeSpec} RuntimeSpec */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).HashFunction} HashFunction */
/** @typedef {import(&quot;./util/identifier&quot;).AssociatedObjectForCache} AssociatedObjectForCache */
/**
 * @template T
 * @typedef {import(&quot;./util/deprecation&quot;).FakeHook&lt;T&gt;} FakeHook
 */

/** @typedef {{ [k: string]: EXPECTED_ANY }} ParserOptions */
/** @typedef {{ [k: string]: EXPECTED_ANY }} GeneratorOptions */

/**
 * @template T
 * @typedef {import(&quot;../declarations/LoaderContext&quot;).LoaderContext&lt;T&gt;} LoaderContext
 */

/**
 * @template T
 * @typedef {import(&quot;../declarations/LoaderContext&quot;).NormalModuleLoaderContext&lt;T&gt;} NormalModuleLoaderContext
 */

/**
 * @typedef {object} SourceMap
 * @property {number} version
 * @property {string[]} sources
 * @property {string} mappings
 * @property {string=} file
 * @property {string=} sourceRoot
 * @property {string[]=} sourcesContent
 * @property {string[]=} names
 * @property {string=} debugId
 */

const getInvalidDependenciesModuleWarning = memoize(() =&gt;
	require(&quot;./InvalidDependenciesModuleWarning&quot;)
);
const getValidate = memoize(() =&gt; require(&quot;schema-utils&quot;).validate);

const ABSOLUTE_PATH_REGEX = /^([a-zA-Z]:\\|\\\\|\/)/;

/**
 * @typedef {object} LoaderItem
 * @property {string} loader
 * @property {string | null | undefined | Record&lt;string, EXPECTED_ANY&gt;} options
 * @property {string?} ident
 * @property {string?} type
 */

/**
 * @param {string} context absolute context path
 * @param {string} source a source path
 * @param {AssociatedObjectForCache=} associatedObjectForCache an object to which the cache will be attached
 * @returns {string} new source path
 */
const contextifySourceUrl = (context, source, associatedObjectForCache) =&gt; {
	if (source.startsWith(&quot;webpack://&quot;)) return source;
	return `webpack://${makePathsRelative(
		context,
		source,
		associatedObjectForCache
	)}`;
};

/**
 * @param {string} context absolute context path
 * @param {SourceMap} sourceMap a source map
 * @param {AssociatedObjectForCache=} associatedObjectForCache an object to which the cache will be attached
 * @returns {SourceMap} new source map
 */
const contextifySourceMap = (context, sourceMap, associatedObjectForCache) =&gt; {
	if (!Array.isArray(sourceMap.sources)) return sourceMap;
	const { sourceRoot } = sourceMap;
	/** @type {(source: string) =&gt; string} */
	const mapper = !sourceRoot
		? source =&gt; source
		: sourceRoot.endsWith(&quot;/&quot;)
			? source =&gt;
					source.startsWith(&quot;/&quot;)
						? `${sourceRoot.slice(0, -1)}${source}`
						: `${sourceRoot}${source}`
			: source =&gt;
					source.startsWith(&quot;/&quot;)
						? `${sourceRoot}${source}`
						: `${sourceRoot}/${source}`;
	const newSources = sourceMap.sources.map(source =&gt;
		contextifySourceUrl(context, mapper(source), associatedObjectForCache)
	);
	return {
		...sourceMap,
		file: &quot;x&quot;,
		sourceRoot: undefined,
		sources: newSources
	};
};

/**
 * @param {string | Buffer} input the input
 * @returns {string} the converted string
 */
const asString = input =&gt; {
	if (Buffer.isBuffer(input)) {
		return input.toString(&quot;utf-8&quot;);
	}
	return input;
};

/**
 * @param {string | Buffer} input the input
 * @returns {Buffer} the converted buffer
 */
const asBuffer = input =&gt; {
	if (!Buffer.isBuffer(input)) {
		return Buffer.from(input, &quot;utf-8&quot;);
	}
	return input;
};

class NonErrorEmittedError extends WebpackError {
	/**
	 * @param {EXPECTED_ANY} error value which is not an instance of Error
	 */
	constructor(error) {
		super();

		this.name = &quot;NonErrorEmittedError&quot;;
		this.message = `(Emitted value instead of an instance of Error) ${error}`;
	}
}

makeSerializable(
	NonErrorEmittedError,
	&quot;webpack/lib/NormalModule&quot;,
	&quot;NonErrorEmittedError&quot;
);

/** @typedef {[string | Buffer, string | SourceMapSource, PreparsedAst]}  Result */

/**
 * @typedef {object} NormalModuleCompilationHooks
 * @property {SyncHook&lt;[LoaderContext&lt;EXPECTED_ANY&gt;, NormalModule]&gt;} loader
 * @property {SyncHook&lt;[LoaderItem[], NormalModule, LoaderContext&lt;EXPECTED_ANY&gt;]&gt;} beforeLoaders
 * @property {SyncHook&lt;[NormalModule]&gt;} beforeParse
 * @property {SyncHook&lt;[NormalModule]&gt;} beforeSnapshot
 * @property {HookMap&lt;FakeHook&lt;AsyncSeriesBailHook&lt;[string, NormalModule], string | Buffer | null&gt;&gt;&gt;} readResourceForScheme
 * @property {HookMap&lt;AsyncSeriesBailHook&lt;[LoaderContext&lt;EXPECTED_ANY&gt;], string | Buffer | null&gt;&gt;} readResource
 * @property {SyncWaterfallHook&lt;[Result, NormalModule]&gt;} processResult
 * @property {AsyncSeriesBailHook&lt;[NormalModule, NeedBuildContext], boolean&gt;} needBuild
 */

/**
 * @typedef {object} NormalModuleCreateData
 * @property {string=} layer an optional layer in which the module is
 * @property {JavaScriptModuleTypes | &quot;&quot;} type module type. When deserializing, this is set to an empty string &quot;&quot;.
 * @property {string} request request string
 * @property {string} userRequest request intended by user (without loaders from config)
 * @property {string} rawRequest request without resolving
 * @property {LoaderItem[]} loaders list of loaders
 * @property {string} resource path + query of the real resource
 * @property {TODO=} resourceResolveData resource resolve data
 * @property {string} context context directory for resolving
 * @property {string=} matchResource path + query of the matched resource (virtual)
 * @property {Parser} parser the parser used
 * @property {ParserOptions=} parserOptions the options of the parser used
 * @property {Generator} generator the generator used
 * @property {GeneratorOptions=} generatorOptions the options of the generator used
 * @property {ResolveOptions=} resolveOptions options used for resolving requests from this module
 */

/** @type {WeakMap&lt;Compilation, NormalModuleCompilationHooks&gt;} */
const compilationHooksMap = new WeakMap();

/** @typedef {Map&lt;string, EXPECTED_ANY&gt;} CodeGeneratorData */

class NormalModule extends Module {
	/**
	 * @param {Compilation} compilation the compilation
	 * @returns {NormalModuleCompilationHooks} the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				&quot;The &#039;compilation&#039; argument must be an instance of Compilation&quot;
			);
		}
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				loader: new SyncHook([&quot;loaderContext&quot;, &quot;module&quot;]),
				beforeLoaders: new SyncHook([&quot;loaders&quot;, &quot;module&quot;, &quot;loaderContext&quot;]),
				beforeParse: new SyncHook([&quot;module&quot;]),
				beforeSnapshot: new SyncHook([&quot;module&quot;]),
				// TODO webpack 6 deprecate
				readResourceForScheme: new HookMap(scheme =&gt; {
					const hook =
						/** @type {NormalModuleCompilationHooks} */
						(hooks).readResource.for(scheme);
					return createFakeHook(
						/** @type {AsyncSeriesBailHook&lt;[string, NormalModule], string | Buffer | null&gt;} */ ({
							tap: (options, fn) =&gt;
								hook.tap(options, loaderContext =&gt;
									fn(
										loaderContext.resource,
										/** @type {NormalModule} */ (loaderContext._module)
									)
								),
							tapAsync: (options, fn) =&gt;
								hook.tapAsync(options, (loaderContext, callback) =&gt;
									fn(
										loaderContext.resource,
										/** @type {NormalModule} */ (loaderContext._module),
										callback
									)
								),
							tapPromise: (options, fn) =&gt;
								hook.tapPromise(options, loaderContext =&gt;
									fn(
										loaderContext.resource,
										/** @type {NormalModule} */ (loaderContext._module)
									)
								)
						})
					);
				}),
				readResource: new HookMap(
					() =&gt; new AsyncSeriesBailHook([&quot;loaderContext&quot;])
				),
				processResult: new SyncWaterfallHook([&quot;result&quot;, &quot;module&quot;]),
				needBuild: new AsyncSeriesBailHook([&quot;module&quot;, &quot;context&quot;])
			};
			compilationHooksMap.set(
				compilation,
				/** @type {NormalModuleCompilationHooks} */ (hooks)
			);
		}
		return /** @type {NormalModuleCompilationHooks} */ (hooks);
	}

	/**
	 * @param {NormalModuleCreateData} options options object
	 */
	constructor({
		layer,
		type,
		request,
		userRequest,
		rawRequest,
		loaders,
		resource,
		resourceResolveData,
		context,
		matchResource,
		parser,
		parserOptions,
		generator,
		generatorOptions,
		resolveOptions
	}) {
		super(type, context || getContext(resource), layer);

		// Info from Factory
		/** @type {string} */
		this.request = request;
		/** @type {string} */
		this.userRequest = userRequest;
		/** @type {string} */
		this.rawRequest = rawRequest;
		/** @type {boolean} */
		this.binary = /^(asset|webassembly)\b/.test(type);
		/** @type {undefined | Parser} */
		this.parser = parser;
		/** @type {undefined | ParserOptions} */
		this.parserOptions = parserOptions;
		/** @type {undefined | Generator} */
		this.generator = generator;
		/** @type {undefined | GeneratorOptions} */
		this.generatorOptions = generatorOptions;
		/** @type {string} */
		this.resource = resource;
		this.resourceResolveData = resourceResolveData;
		/** @type {string | undefined} */
		this.matchResource = matchResource;
		/** @type {LoaderItem[]} */
		this.loaders = loaders;
		if (resolveOptions !== undefined) {
			// already declared in super class
			this.resolveOptions = resolveOptions;
		}

		// Info from Build
		/** @type {WebpackError | null} */
		this.error = null;
		/**
		 * @private
		 * @type {Source | null}
		 */
		this._source = null;
		/**
		 * @private
		 * @type {Map&lt;string | undefined, number&gt; | undefined}
		 */
		this._sourceSizes = undefined;
		/**
		 * @private
		 * @type {undefined | SourceTypes}
		 */
		this._sourceTypes = undefined;

		// Cache
		this._lastSuccessfulBuildMeta = {};
		this._forceBuild = true;
		this._isEvaluatingSideEffects = false;
		/** @type {WeakSet&lt;ModuleGraph&gt; | undefined} */
		this._addedSideEffectsBailout = undefined;
		/** @type {CodeGeneratorData} */
		this._codeGeneratorData = new Map();
	}

	/**
	 * @returns {string} a unique identifier of the module
	 */
	identifier() {
		if (this.layer === null) {
			if (this.type === JAVASCRIPT_MODULE_TYPE_AUTO) {
				return this.request;
			}
			return `${this.type}|${this.request}`;
		}
		return `${this.type}|${this.request}|${this.layer}`;
	}

	/**
	 * @param {RequestShortener} requestShortener the request shortener
	 * @returns {string} a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		return /** @type {string} */ (requestShortener.shorten(this.userRequest));
	}

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		let ident = contextify(
			options.context,
			this.userRequest,
			options.associatedObjectForCache
		);
		if (this.layer) ident = `(${this.layer})/${ident}`;
		return ident;
	}

	/**
	 * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)
	 */
	nameForCondition() {
		const resource = this.matchResource || this.resource;
		const idx = resource.indexOf(&quot;?&quot;);
		if (idx &gt;= 0) return resource.slice(0, idx);
		return resource;
	}

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 * @param {Module} module fresh module
	 * @returns {void}
	 */
	updateCacheModule(module) {
		super.updateCacheModule(module);
		const m = /** @type {NormalModule} */ (module);
		this.binary = m.binary;
		this.request = m.request;
		this.userRequest = m.userRequest;
		this.rawRequest = m.rawRequest;
		this.parser = m.parser;
		this.parserOptions = m.parserOptions;
		this.generator = m.generator;
		this.generatorOptions = m.generatorOptions;
		this.resource = m.resource;
		this.resourceResolveData = m.resourceResolveData;
		this.context = m.context;
		this.matchResource = m.matchResource;
		this.loaders = m.loaders;
	}

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache() {
		// Make sure to cache types and sizes before cleanup when this module has been built
		// They are accessed by the stats and we don&#039;t want them to crash after cleanup
		// TODO reconsider this for webpack 6
		if (this.buildInfo) {
			if (this._sourceTypes === undefined) this.getSourceTypes();
			for (const type of /** @type {SourceTypes} */ (this._sourceTypes)) {
				this.size(type);
			}
		}
		super.cleanupForCache();
		this.parser = undefined;
		this.parserOptions = undefined;
		this.generator = undefined;
		this.generatorOptions = undefined;
	}

	/**
	 * Module should be unsafe cached. Get data that&#039;s needed for that.
	 * This data will be passed to restoreFromUnsafeCache later.
	 * @returns {UnsafeCacheData} cached data
	 */
	getUnsafeCacheData() {
		const data = super.getUnsafeCacheData();
		data.parserOptions = this.parserOptions;
		data.generatorOptions = this.generatorOptions;
		return data;
	}

	/**
	 * restore unsafe cache data
	 * @param {UnsafeCacheData} unsafeCacheData data from getUnsafeCacheData
	 * @param {NormalModuleFactory} normalModuleFactory the normal module factory handling the unsafe caching
	 */
	restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
		this._restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory);
	}

	/**
	 * restore unsafe cache data
	 * @param {UnsafeCacheData} unsafeCacheData data from getUnsafeCacheData
	 * @param {NormalModuleFactory} normalModuleFactory the normal module factory handling the unsafe caching
	 */
	_restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
		super._restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory);
		this.parserOptions = unsafeCacheData.parserOptions;
		this.parser = normalModuleFactory.getParser(this.type, this.parserOptions);
		this.generatorOptions = unsafeCacheData.generatorOptions;
		this.generator = normalModuleFactory.getGenerator(
			this.type,
			this.generatorOptions
		);
		// we assume the generator behaves identically and keep cached sourceTypes/Sizes
	}

	/**
	 * @param {string} context the compilation context
	 * @param {string} name the asset name
	 * @param {string | Buffer} content the content
	 * @param {(string | SourceMap)=} sourceMap an optional source map
	 * @param {AssociatedObjectForCache=} associatedObjectForCache object for caching
	 * @returns {Source} the created source
	 */
	createSourceForAsset(
		context,
		name,
		content,
		sourceMap,
		associatedObjectForCache
	) {
		if (sourceMap) {
			if (
				typeof sourceMap === &quot;string&quot; &amp;&amp;
				(this.useSourceMap || this.useSimpleSourceMap)
			) {
				return new OriginalSource(
					content,
					contextifySourceUrl(context, sourceMap, associatedObjectForCache)
				);
			}

			if (this.useSourceMap) {
				return new SourceMapSource(
					content,
					name,
					contextifySourceMap(
						context,
						/** @type {SourceMap} */ (sourceMap),
						associatedObjectForCache
					)
				);
			}
		}

		return new RawSource(content);
	}

	/**
	 * @private
	 * @template T
	 * @param {ResolverWithOptions} resolver a resolver
	 * @param {WebpackOptions} options webpack options
	 * @param {Compilation} compilation the compilation
	 * @param {InputFileSystem} fs file system from reading
	 * @param {NormalModuleCompilationHooks} hooks the hooks
	 * @returns {import(&quot;../declarations/LoaderContext&quot;).NormalModuleLoaderContext&lt;T&gt;} loader context
	 */
	_createLoaderContext(resolver, options, compilation, fs, hooks) {
		const { requestShortener } = compilation.runtimeTemplate;
		const getCurrentLoaderName = () =&gt; {
			const currentLoader = this.getCurrentLoader(loaderContext);
			if (!currentLoader) return &quot;(not in loader scope)&quot;;
			return requestShortener.shorten(currentLoader.loader);
		};
		/**
		 * @returns {ResolveContext} resolve context
		 */
		const getResolveContext = () =&gt; ({
			fileDependencies: {
				add: d =&gt; /** @type {TODO} */ (loaderContext).addDependency(d)
			},
			contextDependencies: {
				add: d =&gt; /** @type {TODO} */ (loaderContext).addContextDependency(d)
			},
			missingDependencies: {
				add: d =&gt; /** @type {TODO} */ (loaderContext).addMissingDependency(d)
			}
		});
		const getAbsolutify = memoize(() =&gt;
			absolutify.bindCache(compilation.compiler.root)
		);
		const getAbsolutifyInContext = memoize(() =&gt;
			absolutify.bindContextCache(
				/** @type {string} */
				(this.context),
				compilation.compiler.root
			)
		);
		const getContextify = memoize(() =&gt;
			contextify.bindCache(compilation.compiler.root)
		);
		const getContextifyInContext = memoize(() =&gt;
			contextify.bindContextCache(
				/** @type {string} */
				(this.context),
				compilation.compiler.root
			)
		);
		const utils = {
			/**
			 * @param {string} context context
			 * @param {string} request request
			 * @returns {string} result
			 */
			absolutify: (context, request) =&gt;
				context === this.context
					? getAbsolutifyInContext()(request)
					: getAbsolutify()(context, request),
			/**
			 * @param {string} context context
			 * @param {string} request request
			 * @returns {string} result
			 */
			contextify: (context, request) =&gt;
				context === this.context
					? getContextifyInContext()(request)
					: getContextify()(context, request),
			/**
			 * @param {HashFunction=} type type
			 * @returns {Hash} hash
			 */
			createHash: type =&gt;
				createHash(
					type ||
						/** @type {HashFunction} */
						(compilation.outputOptions.hashFunction)
				)
		};
		/** @type {import(&quot;../declarations/LoaderContext&quot;).NormalModuleLoaderContext&lt;T&gt;} */
		const loaderContext = {
			version: 2,
			/**
			 * @param {import(&quot;../declarations/LoaderContext&quot;).Schema=} schema schema
			 * @returns {T} options
			 */
			getOptions: schema =&gt; {
				const loader = this.getCurrentLoader(loaderContext);

				let { options } = /** @type {LoaderItem} */ (loader);

				if (typeof options === &quot;string&quot;) {
					if (options.startsWith(&quot;{&quot;) &amp;&amp; options.endsWith(&quot;}&quot;)) {
						try {
							options = parseJson(options);
						} catch (err) {
							throw new Error(
								`Cannot parse string options: ${/** @type {Error} */ (err).message}`
							);
						}
					} else {
						options = querystring.parse(options, &quot;&amp;&quot;, &quot;=&quot;, {
							maxKeys: 0
						});
					}
				}

				if (options === null || options === undefined) {
					options = {};
				}

				if (schema) {
					let name = &quot;Loader&quot;;
					let baseDataPath = &quot;options&quot;;
					let match;
					if (schema.title &amp;&amp; (match = /^(.+) (.+)$/.exec(schema.title))) {
						[, name, baseDataPath] = match;
					}
					getValidate()(schema, /** @type {EXPECTED_OBJECT} */ (options), {
						name,
						baseDataPath
					});
				}

				return /** @type {T} */ (options);
			},
			emitWarning: warning =&gt; {
				if (!(warning instanceof Error)) {
					warning = new NonErrorEmittedError(warning);
				}
				this.addWarning(
					new ModuleWarning(warning, {
						from: getCurrentLoaderName()
					})
				);
			},
			emitError: error =&gt; {
				if (!(error instanceof Error)) {
					error = new NonErrorEmittedError(error);
				}
				this.addError(
					new ModuleError(error, {
						from: getCurrentLoaderName()
					})
				);
			},
			getLogger: name =&gt; {
				const currentLoader = this.getCurrentLoader(loaderContext);
				return compilation.getLogger(() =&gt;
					[currentLoader &amp;&amp; currentLoader.loader, name, this.identifier()]
						.filter(Boolean)
						.join(&quot;|&quot;)
				);
			},
			resolve(context, request, callback) {
				resolver.resolve({}, context, request, getResolveContext(), callback);
			},
			getResolve(options) {
				const child = options ? resolver.withOptions(options) : resolver;
				return /** @type {ReturnType&lt;import(&quot;../declarations/LoaderContext&quot;).NormalModuleLoaderContext&lt;T&gt;[&quot;getResolve&quot;]&gt;} */ (
					(context, request, callback) =&gt; {
						if (callback) {
							child.resolve(
								{},
								context,
								request,
								getResolveContext(),
								callback
							);
						} else {
							return new Promise((resolve, reject) =&gt; {
								child.resolve(
									{},
									context,
									request,
									getResolveContext(),
									(err, result) =&gt; {
										if (err) reject(err);
										else resolve(result);
									}
								);
							});
						}
					}
				);
			},
			emitFile: (name, content, sourceMap, assetInfo) =&gt; {
				const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);

				if (!buildInfo.assets) {
					buildInfo.assets = Object.create(null);
					buildInfo.assetsInfo = new Map();
				}

				const assets =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;assets&quot;]&gt;} */
					(buildInfo.assets);
				const assetsInfo =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;assetsInfo&quot;]&gt;} */
					(buildInfo.assetsInfo);

				assets[name] = this.createSourceForAsset(
					/** @type {string} */ (options.context),
					name,
					content,
					sourceMap,
					compilation.compiler.root
				);
				assetsInfo.set(name, assetInfo);
			},
			addBuildDependency: dep =&gt; {
				const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);

				if (buildInfo.buildDependencies === undefined) {
					buildInfo.buildDependencies = new LazySet();
				}
				buildInfo.buildDependencies.add(dep);
			},
			utils,
			rootContext: /** @type {string} */ (options.context),
			webpack: true,
			sourceMap: Boolean(this.useSourceMap),
			mode: options.mode || &quot;production&quot;,
			hashFunction: /** @type {string} */ (options.output.hashFunction),
			hashDigest: /** @type {string} */ (options.output.hashDigest),
			hashDigestLength: /** @type {number} */ (options.output.hashDigestLength),
			hashSalt: /** @type {string} */ (options.output.hashSalt),
			_module: this,
			_compilation: compilation,
			_compiler: compilation.compiler,
			fs
		};

		Object.assign(loaderContext, options.loader);

		hooks.loader.call(
			/** @type {LoaderContext&lt;EXPECTED_ANY&gt;} */
			(loaderContext),
			this
		);

		return loaderContext;
	}

	// TODO remove `loaderContext` in webpack@6
	/**
	 * @param {TODO} loaderContext loader context
	 * @param {number} index index
	 * @returns {LoaderItem | null} loader
	 */
	getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
		if (
			this.loaders &amp;&amp;
			this.loaders.length &amp;&amp;
			index &lt; this.loaders.length &amp;&amp;
			index &gt;= 0 &amp;&amp;
			this.loaders[index]
		) {
			return this.loaders[index];
		}
		return null;
	}

	/**
	 * @param {string} context the compilation context
	 * @param {string | Buffer} content the content
	 * @param {(string | SourceMapSource | null)=} sourceMap an optional source map
	 * @param {AssociatedObjectForCache=} associatedObjectForCache object for caching
	 * @returns {Source} the created source
	 */
	createSource(context, content, sourceMap, associatedObjectForCache) {
		if (Buffer.isBuffer(content)) {
			return new RawSource(content);
		}

		// if there is no identifier return raw source
		if (!this.identifier) {
			return new RawSource(content);
		}

		// from here on we assume we have an identifier
		const identifier = this.identifier();

		if (this.useSourceMap &amp;&amp; sourceMap) {
			return new SourceMapSource(
				content,
				contextifySourceUrl(context, identifier, associatedObjectForCache),
				contextifySourceMap(
					context,
					/** @type {TODO} */ (sourceMap),
					associatedObjectForCache
				)
			);
		}

		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(
				content,
				contextifySourceUrl(context, identifier, associatedObjectForCache)
			);
		}

		return new RawSource(content);
	}

	/**
	 * @param {WebpackOptions} options webpack options
	 * @param {Compilation} compilation the compilation
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {NormalModuleCompilationHooks} hooks the hooks
	 * @param {BuildCallback} callback callback function
	 * @returns {void}
	 */
	_doBuild(options, compilation, resolver, fs, hooks, callback) {
		const loaderContext = this._createLoaderContext(
			resolver,
			options,
			compilation,
			fs,
			hooks
		);

		/**
		 * @param {Error | null} err err
		 * @param {(Result | null)=} _result result
		 * @returns {void}
		 */
		const processResult = (err, _result) =&gt; {
			if (err) {
				if (!(err instanceof Error)) {
					err = new NonErrorEmittedError(err);
				}
				const currentLoader = this.getCurrentLoader(loaderContext);
				const error = new ModuleBuildError(err, {
					from:
						currentLoader &amp;&amp;
						compilation.runtimeTemplate.requestShortener.shorten(
							currentLoader.loader
						)
				});
				return callback(error);
			}
			const result = hooks.processResult.call(
				/** @type {Result} */ (_result),
				this
			);
			const source = result[0];
			const sourceMap = result.length &gt;= 1 ? result[1] : null;
			const extraInfo = result.length &gt;= 2 ? result[2] : null;

			if (!Buffer.isBuffer(source) &amp;&amp; typeof source !== &quot;string&quot;) {
				const currentLoader = this.getCurrentLoader(loaderContext, 0);
				const err = new Error(
					`Final loader (${
						currentLoader
							? compilation.runtimeTemplate.requestShortener.shorten(
									currentLoader.loader
								)
							: &quot;unknown&quot;
					}) didn&#039;t return a Buffer or String`
				);
				const error = new ModuleBuildError(err);
				return callback(error);
			}

			const isBinaryModule =
				this.generatorOptions &amp;&amp; this.generatorOptions.binary !== undefined
					? this.generatorOptions.binary
					: this.binary;

			this._source = this.createSource(
				/** @type {string} */ (options.context),
				isBinaryModule ? asBuffer(source) : asString(source),
				sourceMap,
				compilation.compiler.root
			);
			if (this._sourceSizes !== undefined) this._sourceSizes.clear();
			this._ast =
				typeof extraInfo === &quot;object&quot; &amp;&amp;
				extraInfo !== null &amp;&amp;
				extraInfo.webpackAST !== undefined
					? extraInfo.webpackAST
					: null;
			return callback();
		};

		const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);

		buildInfo.fileDependencies = new LazySet();
		buildInfo.contextDependencies = new LazySet();
		buildInfo.missingDependencies = new LazySet();
		buildInfo.cacheable = true;

		try {
			hooks.beforeLoaders.call(
				this.loaders,
				this,
				/** @type {LoaderContext&lt;EXPECTED_ANY&gt;} */
				(loaderContext)
			);
		} catch (err) {
			processResult(/** @type {Error} */ (err));
			return;
		}

		if (this.loaders.length &gt; 0) {
			/** @type {BuildInfo} */
			(this.buildInfo).buildDependencies = new LazySet();
		}

		runLoaders(
			{
				resource: this.resource,
				loaders: this.loaders,
				context: loaderContext,
				/**
				 * @param {LoaderContext&lt;TODO&gt;} loaderContext the loader context
				 * @param {string} resourcePath the resource Path
				 * @param {(err: Error | null, result?: string | Buffer) =&gt; void} callback callback
				 */
				processResource: (loaderContext, resourcePath, callback) =&gt; {
					const resource = loaderContext.resource;
					const scheme = getScheme(resource);
					hooks.readResource
						.for(scheme)
						.callAsync(loaderContext, (err, result) =&gt; {
							if (err) return callback(err);
							if (typeof result !== &quot;string&quot; &amp;&amp; !result) {
								return callback(
									new UnhandledSchemeError(
										/** @type {string} */
										(scheme),
										resource
									)
								);
							}
							return callback(null, result);
						});
				}
			},
			(err, result) =&gt; {
				// Cleanup loaderContext to avoid leaking memory in ICs
				loaderContext._compilation =
					loaderContext._compiler =
					loaderContext._module =
					loaderContext.fs =
						/** @type {EXPECTED_ANY} */
						(undefined);

				if (!result) {
					/** @type {BuildInfo} */
					(this.buildInfo).cacheable = false;
					return processResult(
						err || new Error(&quot;No result from loader-runner processing&quot;),
						null
					);
				}

				const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);

				const fileDependencies =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;fileDependencies&quot;]&gt;} */
					(buildInfo.fileDependencies);
				const contextDependencies =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;contextDependencies&quot;]&gt;} */
					(buildInfo.contextDependencies);
				const missingDependencies =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;missingDependencies&quot;]&gt;} */
					(buildInfo.missingDependencies);

				fileDependencies.addAll(result.fileDependencies);
				contextDependencies.addAll(result.contextDependencies);
				missingDependencies.addAll(result.missingDependencies);
				for (const loader of this.loaders) {
					const buildDependencies =
						/** @type {NonNullable&lt;KnownBuildInfo[&quot;buildDependencies&quot;]&gt;} */
						(buildInfo.buildDependencies);

					buildDependencies.add(loader.loader);
				}
				buildInfo.cacheable = buildInfo.cacheable &amp;&amp; result.cacheable;
				processResult(err, result.result);
			}
		);
	}

	/**
	 * @param {WebpackError} error the error
	 * @returns {void}
	 */
	markModuleAsErrored(error) {
		// Restore build meta from successful build to keep importing state
		this.buildMeta = { ...this._lastSuccessfulBuildMeta };
		this.error = error;
		this.addError(error);
	}

	/**
	 * @param {Exclude&lt;NoParse, EXPECTED_ANY[]&gt;} rule rule
	 * @param {string} content content
	 * @returns {boolean} result
	 */
	applyNoParseRule(rule, content) {
		// must start with &quot;rule&quot; if rule is a string
		if (typeof rule === &quot;string&quot;) {
			return content.startsWith(rule);
		}

		if (typeof rule === &quot;function&quot;) {
			return rule(content);
		}
		// we assume rule is a regexp
		return rule.test(content);
	}

	/**
	 * @param {undefined | NoParse} noParseRule no parse rule
	 * @param {string} request request
	 * @returns {boolean} check if module should not be parsed, returns &quot;true&quot; if the module should !not! be parsed, returns &quot;false&quot; if the module !must! be parsed
	 */
	shouldPreventParsing(noParseRule, request) {
		// if no noParseRule exists, return false
		// the module !must! be parsed.
		if (!noParseRule) {
			return false;
		}

		// we only have one rule to check
		if (!Array.isArray(noParseRule)) {
			// returns &quot;true&quot; if the module is !not! to be parsed
			return this.applyNoParseRule(noParseRule, request);
		}

		for (let i = 0; i &lt; noParseRule.length; i++) {
			const rule = noParseRule[i];
			// early exit on first truthy match
			// this module is !not! to be parsed
			if (this.applyNoParseRule(rule, request)) {
				return true;
			}
		}
		// no match found, so this module !should! be parsed
		return false;
	}

	/**
	 * @param {Compilation} compilation compilation
	 * @private
	 */
	_initBuildHash(compilation) {
		const hash = createHash(
			/** @type {HashFunction} */
			(compilation.outputOptions.hashFunction)
		);
		if (this._source) {
			hash.update(&quot;source&quot;);
			this._source.updateHash(hash);
		}
		hash.update(&quot;meta&quot;);
		hash.update(JSON.stringify(this.buildMeta));
		/** @type {BuildInfo} */
		(this.buildInfo).hash = /** @type {string} */ (hash.digest(&quot;hex&quot;));
	}

	/**
	 * @param {WebpackOptions} options webpack options
	 * @param {Compilation} compilation the compilation
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {BuildCallback} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		this._source = null;
		if (this._sourceSizes !== undefined) this._sourceSizes.clear();
		this._sourceTypes = undefined;
		this._ast = null;
		this.error = null;
		this.clearWarningsAndErrors();
		this.clearDependenciesAndBlocks();
		this.buildMeta = {};
		this.buildInfo = {
			cacheable: false,
			parsed: true,
			fileDependencies: undefined,
			contextDependencies: undefined,
			missingDependencies: undefined,
			buildDependencies: undefined,
			valueDependencies: undefined,
			hash: undefined,
			assets: undefined,
			assetsInfo: undefined
		};

		const startTime = compilation.compiler.fsStartTime || Date.now();

		const hooks = NormalModule.getCompilationHooks(compilation);

		return this._doBuild(options, compilation, resolver, fs, hooks, err =&gt; {
			// if we have an error mark module as failed and exit
			if (err) {
				this.markModuleAsErrored(err);
				this._initBuildHash(compilation);
				return callback();
			}

			/**
			 * @param {Error} e error
			 * @returns {void}
			 */
			const handleParseError = e =&gt; {
				const source = /** @type {Source} */ (this._source).source();
				const loaders = this.loaders.map(item =&gt;
					contextify(
						/** @type {string} */ (options.context),
						item.loader,
						compilation.compiler.root
					)
				);
				const error = new ModuleParseError(source, e, loaders, this.type);
				this.markModuleAsErrored(error);
				this._initBuildHash(compilation);
				return callback();
			};

			const handleParseResult = () =&gt; {
				this.dependencies.sort(
					concatComparators(
						compareSelect(a =&gt; a.loc, compareLocations),
						keepOriginalOrder(this.dependencies)
					)
				);
				this._initBuildHash(compilation);
				this._lastSuccessfulBuildMeta =
					/** @type {BuildMeta} */
					(this.buildMeta);
				return handleBuildDone();
			};

			const handleBuildDone = () =&gt; {
				try {
					hooks.beforeSnapshot.call(this);
				} catch (err) {
					this.markModuleAsErrored(/** @type {WebpackError} */ (err));
					return callback();
				}

				const snapshotOptions = compilation.options.snapshot.module;
				const { cacheable } = /** @type {BuildInfo} */ (this.buildInfo);
				if (!cacheable || !snapshotOptions) {
					return callback();
				}
				// add warning for all non-absolute paths in fileDependencies, etc
				// This makes it easier to find problems with watching and/or caching
				/** @type {undefined | Set&lt;string&gt;} */
				let nonAbsoluteDependencies;
				/**
				 * @param {LazySet&lt;string&gt;} deps deps
				 */
				const checkDependencies = deps =&gt; {
					for (const dep of deps) {
						if (!ABSOLUTE_PATH_REGEX.test(dep)) {
							if (nonAbsoluteDependencies === undefined)
								nonAbsoluteDependencies = new Set();
							nonAbsoluteDependencies.add(dep);
							deps.delete(dep);
							try {
								const depWithoutGlob = dep.replace(/[\\/]?\*.*$/, &quot;&quot;);
								const absolute = join(
									compilation.fileSystemInfo.fs,
									/** @type {string} */
									(this.context),
									depWithoutGlob
								);
								if (absolute !== dep &amp;&amp; ABSOLUTE_PATH_REGEX.test(absolute)) {
									(depWithoutGlob !== dep
										? /** @type {NonNullable&lt;KnownBuildInfo[&quot;contextDependencies&quot;]&gt;} */
											(
												/** @type {BuildInfo} */
												(this.buildInfo).contextDependencies
											)
										: deps
									).add(absolute);
								}
							} catch (_err) {
								// ignore
							}
						}
					}
				};
				const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);
				const fileDependencies =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;fileDependencies&quot;]&gt;} */
					(buildInfo.fileDependencies);
				const contextDependencies =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;contextDependencies&quot;]&gt;} */
					(buildInfo.contextDependencies);
				const missingDependencies =
					/** @type {NonNullable&lt;KnownBuildInfo[&quot;missingDependencies&quot;]&gt;} */
					(buildInfo.missingDependencies);
				checkDependencies(fileDependencies);
				checkDependencies(missingDependencies);
				checkDependencies(contextDependencies);
				if (nonAbsoluteDependencies !== undefined) {
					const InvalidDependenciesModuleWarning =
						getInvalidDependenciesModuleWarning();
					this.addWarning(
						new InvalidDependenciesModuleWarning(this, nonAbsoluteDependencies)
					);
				}
				// convert file/context/missingDependencies into filesystem snapshot
				compilation.fileSystemInfo.createSnapshot(
					startTime,
					fileDependencies,
					contextDependencies,
					missingDependencies,
					snapshotOptions,
					(err, snapshot) =&gt; {
						if (err) {
							this.markModuleAsErrored(err);
							return;
						}
						buildInfo.fileDependencies = undefined;
						buildInfo.contextDependencies = undefined;
						buildInfo.missingDependencies = undefined;
						buildInfo.snapshot = snapshot;
						return callback();
					}
				);
			};

			try {
				hooks.beforeParse.call(this);
			} catch (err) {
				this.markModuleAsErrored(/** @type {WebpackError} */ (err));
				this._initBuildHash(compilation);
				return callback();
			}

			// check if this module should !not! be parsed.
			// if so, exit here;
			const noParseRule = options.module &amp;&amp; options.module.noParse;
			if (this.shouldPreventParsing(noParseRule, this.request)) {
				// We assume that we need module and exports
				/** @type {BuildInfo} */
				(this.buildInfo).parsed = false;
				this._initBuildHash(compilation);
				return handleBuildDone();
			}

			try {
				const source = /** @type {Source} */ (this._source).source();
				/** @type {Parser} */
				(this.parser).parse(this._ast || source, {
					source,
					current: this,
					module: this,
					compilation,
					options
				});
			} catch (parseErr) {
				handleParseError(/** @type {Error} */ (parseErr));
				return;
			}
			handleParseResult();
		});
	}

	/**
	 * @param {ConcatenationBailoutReasonContext} context context
	 * @returns {string | undefined} reason why this module can&#039;t be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(context) {
		return /** @type {Generator} */ (
			this.generator
		).getConcatenationBailoutReason(this, context);
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only
	 */
	getSideEffectsConnectionState(moduleGraph) {
		if (this.factoryMeta !== undefined) {
			if (this.factoryMeta.sideEffectFree) return false;
			if (this.factoryMeta.sideEffectFree === false) return true;
		}
		if (this.buildMeta !== undefined &amp;&amp; this.buildMeta.sideEffectFree) {
			if (this._isEvaluatingSideEffects)
				return ModuleGraphConnection.CIRCULAR_CONNECTION;
			this._isEvaluatingSideEffects = true;
			/** @type {ConnectionState} */
			let current = false;
			for (const dep of this.dependencies) {
				const state = dep.getModuleEvaluationSideEffectsState(moduleGraph);
				if (state === true) {
					if (
						this._addedSideEffectsBailout === undefined
							? ((this._addedSideEffectsBailout = new WeakSet()), true)
							: !this._addedSideEffectsBailout.has(moduleGraph)
					) {
						this._addedSideEffectsBailout.add(moduleGraph);
						moduleGraph
							.getOptimizationBailout(this)
							.push(
								() =&gt;
									`Dependency (${
										dep.type
									}) with side effects at ${formatLocation(dep.loc)}`
							);
					}
					this._isEvaluatingSideEffects = false;
					return true;
				} else if (state !== ModuleGraphConnection.CIRCULAR_CONNECTION) {
					current = ModuleGraphConnection.addConnectionStates(current, state);
				}
			}
			this._isEvaluatingSideEffects = false;
			// When caching is implemented here, make sure to not cache when
			// at least one circular connection was in the loop above
			return current;
		}
		return true;
	}

	/**
	 * @returns {SourceTypes} types available (do not mutate)
	 */
	getSourceTypes() {
		if (this._sourceTypes === undefined) {
			this._sourceTypes = /** @type {Generator} */ (this.generator).getTypes(
				this
			);
		}
		return this._sourceTypes;
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration({
		dependencyTemplates,
		runtimeTemplate,
		moduleGraph,
		chunkGraph,
		runtime,
		concatenationScope,
		codeGenerationResults,
		sourceTypes
	}) {
		/** @type {Set&lt;string&gt;} */
		const runtimeRequirements = new Set();

		const { parsed } = /** @type {BuildInfo} */ (this.buildInfo);

		if (!parsed) {
			runtimeRequirements.add(RuntimeGlobals.module);
			runtimeRequirements.add(RuntimeGlobals.exports);
			runtimeRequirements.add(RuntimeGlobals.thisAsExports);
		}

		/**
		 * @type {() =&gt; CodeGeneratorData}
		 */
		const getData = () =&gt; this._codeGeneratorData;

		const sources = new Map();
		for (const type of sourceTypes || chunkGraph.getModuleSourceTypes(this)) {
			// TODO webpack@6 make generateError required
			const generator =
				/** @type {Generator &amp; { generateError?: GenerateErrorFn }} */
				(this.generator);
			const source = this.error
				? generator.generateError
					? generator.generateError(this.error, this, {
							dependencyTemplates,
							runtimeTemplate,
							moduleGraph,
							chunkGraph,
							runtimeRequirements,
							runtime,
							concatenationScope,
							codeGenerationResults,
							getData,
							type
						})
					: new RawSource(
							`throw new Error(${JSON.stringify(this.error.message)});`
						)
				: generator.generate(this, {
						dependencyTemplates,
						runtimeTemplate,
						moduleGraph,
						chunkGraph,
						runtimeRequirements,
						runtime,
						concatenationScope,
						codeGenerationResults,
						getData,
						type
					});

			if (source) {
				sources.set(type, new CachedSource(source));
			}
		}

		/** @type {CodeGenerationResult} */
		const resultEntry = {
			sources,
			runtimeRequirements,
			data: this._codeGeneratorData
		};
		return resultEntry;
	}

	/**
	 * @returns {Source | null} the original source for the module before webpack transformation
	 */
	originalSource() {
		return this._source;
	}

	/**
	 * @returns {void}
	 */
	invalidateBuild() {
		this._forceBuild = true;
	}

	/**
	 * @param {NeedBuildContext} context context info
	 * @param {NeedBuildCallback} callback callback function, returns true, if the module needs a rebuild
	 * @returns {void}
	 */
	needBuild(context, callback) {
		const { fileSystemInfo, compilation, valueCacheVersions } = context;
		// build if enforced
		if (this._forceBuild) return callback(null, true);

		// always try to build in case of an error
		if (this.error) return callback(null, true);

		const { cacheable, snapshot, valueDependencies } =
			/** @type {BuildInfo} */ (this.buildInfo);

		// always build when module is not cacheable
		if (!cacheable) return callback(null, true);

		// build when there is no snapshot to check
		if (!snapshot) return callback(null, true);

		// build when valueDependencies have changed
		if (valueDependencies) {
			if (!valueCacheVersions) return callback(null, true);
			for (const [key, value] of valueDependencies) {
				if (value === undefined) return callback(null, true);
				const current = valueCacheVersions.get(key);
				if (
					value !== current &amp;&amp;
					(typeof value === &quot;string&quot; ||
						typeof current === &quot;string&quot; ||
						current === undefined ||
						!isSubset(value, current))
				) {
					return callback(null, true);
				}
			}
		}

		// check snapshot for validity
		fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) =&gt; {
			if (err) return callback(err);
			if (!valid) return callback(null, true);
			const hooks = NormalModule.getCompilationHooks(compilation);
			hooks.needBuild.callAsync(this, context, (err, needBuild) =&gt; {
				if (err) {
					return callback(
						HookWebpackError.makeWebpackError(
							err,
							&quot;NormalModule.getCompilationHooks().needBuild&quot;
						)
					);
				}
				callback(null, Boolean(needBuild));
			});
		});
	}

	/**
	 * @param {string=} type the source type for which the size should be estimated
	 * @returns {number} the estimated size of the module (must be non-zero)
	 */
	size(type) {
		const cachedSize =
			this._sourceSizes === undefined ? undefined : this._sourceSizes.get(type);
		if (cachedSize !== undefined) {
			return cachedSize;
		}
		const size = Math.max(
			1,
			/** @type {Generator} */ (this.generator).getSize(this, type)
		);
		if (this._sourceSizes === undefined) {
			this._sourceSizes = new Map();
		}
		this._sourceSizes.set(type, size);
		return size;
	}

	/**
	 * @param {LazySet&lt;string&gt;} fileDependencies set where file dependencies are added to
	 * @param {LazySet&lt;string&gt;} contextDependencies set where context dependencies are added to
	 * @param {LazySet&lt;string&gt;} missingDependencies set where missing dependencies are added to
	 * @param {LazySet&lt;string&gt;} buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {
		const { snapshot, buildDependencies: buildDeps } =
			/** @type {BuildInfo} */ (this.buildInfo);
		if (snapshot) {
			fileDependencies.addAll(snapshot.getFileIterable());
			contextDependencies.addAll(snapshot.getContextIterable());
			missingDependencies.addAll(snapshot.getMissingIterable());
		} else {
			const {
				fileDependencies: fileDeps,
				contextDependencies: contextDeps,
				missingDependencies: missingDeps
			} = /** @type {BuildInfo} */ (this.buildInfo);
			if (fileDeps !== undefined) fileDependencies.addAll(fileDeps);
			if (contextDeps !== undefined) contextDependencies.addAll(contextDeps);
			if (missingDeps !== undefined) missingDependencies.addAll(missingDeps);
		}
		if (buildDeps !== undefined) {
			buildDependencies.addAll(buildDeps);
		}
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @param {UpdateHashContext} context context
	 * @returns {void}
	 */
	updateHash(hash, context) {
		const buildInfo = /** @type {BuildInfo} */ (this.buildInfo);
		hash.update(
			/** @type {string} */
			(buildInfo.hash)
		);
		/** @type {Generator} */
		(this.generator).updateHash(hash, {
			module: this,
			...context
		});
		super.updateHash(hash, context);
	}

	/**
	 * @param {ObjectSerializerContext} context context
	 */
	serialize(context) {
		const { write } = context;
		// deserialize
		write(this._source);
		write(this.error);
		write(this._lastSuccessfulBuildMeta);
		write(this._forceBuild);
		write(this._codeGeneratorData);
		super.serialize(context);
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 * @returns {TODO} Module
	 */
	static deserialize(context) {
		const obj = new NormalModule({
			// will be deserialized by Module
			layer: /** @type {EXPECTED_ANY} */ (null),
			type: &quot;&quot;,
			// will be filled by updateCacheModule
			resource: &quot;&quot;,
			context: &quot;&quot;,
			request: /** @type {EXPECTED_ANY} */ (null),
			userRequest: /** @type {EXPECTED_ANY} */ (null),
			rawRequest: /** @type {EXPECTED_ANY} */ (null),
			loaders: /** @type {EXPECTED_ANY} */ (null),
			matchResource: /** @type {EXPECTED_ANY} */ (null),
			parser: /** @type {EXPECTED_ANY} */ (null),
			parserOptions: /** @type {EXPECTED_ANY} */ (null),
			generator: /** @type {EXPECTED_ANY} */ (null),
			generatorOptions: /** @type {EXPECTED_ANY} */ (null),
			resolveOptions: /** @type {EXPECTED_ANY} */ (null)
		});
		obj.deserialize(context);
		return obj;
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 */
	deserialize(context) {
		const { read } = context;
		this._source = read();
		this.error = read();
		this._lastSuccessfulBuildMeta = read();
		this._forceBuild = read();
		this._codeGeneratorData = read();
		super.deserialize(context);
	}
}

makeSerializable(NormalModule, &quot;webpack/lib/NormalModule&quot;);

module.exports = NormalModule;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
