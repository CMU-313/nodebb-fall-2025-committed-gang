<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@stylistic/eslint-plugin-js/dist/rules/key-spacing.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@stylistic/eslint-plugin-js/dist/rules/key-spacing.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">513</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">96.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.41</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { c as createRule, x as isColonToken, C as getStaticPropertyName, D as getStringLength, v as isOpeningBraceToken, k as isClosingBraceToken, L as LINEBREAK_MATCHER } from &#039;../utils.js&#039;;
import &#039;eslint-visitor-keys&#039;;
import &#039;espree&#039;;

const listeningNodes = [
  &quot;ObjectExpression&quot;,
  &quot;ObjectPattern&quot;,
  &quot;ImportDeclaration&quot;,
  &quot;ExportNamedDeclaration&quot;,
  &quot;ExportAllDeclaration&quot;,
  &quot;TSTypeLiteral&quot;,
  &quot;TSInterfaceBody&quot;,
  &quot;ClassBody&quot;
];
function containsLineTerminator(str) {
  return LINEBREAK_MATCHER.test(str);
}
function last(arr) {
  return arr[arr.length - 1];
}
function isSingleLine(node) {
  return node.loc.end.line === node.loc.start.line;
}
function isSingleLineImportAttributes(node, sourceCode) {
  if (node.type === &quot;TSImportType&quot;) {
    if (&quot;options&quot; in node &amp;&amp; node.options) {
      return isSingleLine(node.options);
    }
    return false;
  }
  const openingBrace = sourceCode.getTokenBefore(node.attributes[0], isOpeningBraceToken);
  const closingBrace = sourceCode.getTokenAfter(node.attributes[node.attributes.length - 1], isClosingBraceToken);
  return closingBrace.loc.end.line === openingBrace.loc.start.line;
}
function isSingleLineProperties(properties) {
  const [firstProp] = properties;
  const lastProp = last(properties);
  return firstProp.loc.start.line === lastProp.loc.end.line;
}
function initOptionProperty(toOptions, fromOptions) {
  toOptions.mode = fromOptions.mode || &quot;strict&quot;;
  if (typeof fromOptions.beforeColon !== &quot;undefined&quot;)
    toOptions.beforeColon = +fromOptions.beforeColon;
  else
    toOptions.beforeColon = 0;
  if (typeof fromOptions.afterColon !== &quot;undefined&quot;)
    toOptions.afterColon = +fromOptions.afterColon;
  else
    toOptions.afterColon = 1;
  if (typeof fromOptions.align !== &quot;undefined&quot;) {
    if (typeof fromOptions.align === &quot;object&quot;) {
      toOptions.align = fromOptions.align;
    } else {
      toOptions.align = {
        on: fromOptions.align,
        mode: toOptions.mode,
        beforeColon: toOptions.beforeColon,
        afterColon: toOptions.afterColon
      };
    }
  }
  return toOptions;
}
function initOptions(toOptions, fromOptions) {
  if (typeof fromOptions.align === &quot;object&quot;) {
    toOptions.align = initOptionProperty({}, fromOptions.align);
    toOptions.align.on = fromOptions.align.on || &quot;colon&quot;;
    toOptions.align.mode = fromOptions.align.mode || &quot;strict&quot;;
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
  } else {
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
    if (toOptions.multiLine.align) {
      toOptions.align = {
        on: toOptions.multiLine.align.on,
        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
        beforeColon: toOptions.multiLine.align.beforeColon,
        afterColon: toOptions.multiLine.align.afterColon
      };
    }
  }
  toOptions.ignoredNodes = fromOptions.ignoredNodes || [];
  return toOptions;
}
var keySpacing = createRule({
  name: &quot;key-spacing&quot;,
  package: &quot;js&quot;,
  meta: {
    type: &quot;layout&quot;,
    docs: {
      description: &quot;Enforce consistent spacing between keys and values in object literal properties&quot;
    },
    fixable: &quot;whitespace&quot;,
    schema: [{
      anyOf: [
        {
          type: &quot;object&quot;,
          properties: {
            align: {
              anyOf: [
                {
                  type: &quot;string&quot;,
                  enum: [&quot;colon&quot;, &quot;value&quot;]
                },
                {
                  type: &quot;object&quot;,
                  properties: {
                    mode: {
                      type: &quot;string&quot;,
                      enum: [&quot;strict&quot;, &quot;minimum&quot;]
                    },
                    on: {
                      type: &quot;string&quot;,
                      enum: [&quot;colon&quot;, &quot;value&quot;]
                    },
                    beforeColon: {
                      type: &quot;boolean&quot;
                    },
                    afterColon: {
                      type: &quot;boolean&quot;
                    }
                  },
                  additionalProperties: false
                }
              ]
            },
            mode: {
              type: &quot;string&quot;,
              enum: [&quot;strict&quot;, &quot;minimum&quot;]
            },
            beforeColon: {
              type: &quot;boolean&quot;
            },
            afterColon: {
              type: &quot;boolean&quot;
            },
            ignoredNodes: {
              type: &quot;array&quot;,
              items: {
                type: &quot;string&quot;,
                enum: listeningNodes
              }
            }
          },
          additionalProperties: false
        },
        {
          type: &quot;object&quot;,
          properties: {
            singleLine: {
              type: &quot;object&quot;,
              properties: {
                mode: {
                  type: &quot;string&quot;,
                  enum: [&quot;strict&quot;, &quot;minimum&quot;]
                },
                beforeColon: {
                  type: &quot;boolean&quot;
                },
                afterColon: {
                  type: &quot;boolean&quot;
                }
              },
              additionalProperties: false
            },
            multiLine: {
              type: &quot;object&quot;,
              properties: {
                align: {
                  anyOf: [
                    {
                      type: &quot;string&quot;,
                      enum: [&quot;colon&quot;, &quot;value&quot;]
                    },
                    {
                      type: &quot;object&quot;,
                      properties: {
                        mode: {
                          type: &quot;string&quot;,
                          enum: [&quot;strict&quot;, &quot;minimum&quot;]
                        },
                        on: {
                          type: &quot;string&quot;,
                          enum: [&quot;colon&quot;, &quot;value&quot;]
                        },
                        beforeColon: {
                          type: &quot;boolean&quot;
                        },
                        afterColon: {
                          type: &quot;boolean&quot;
                        }
                      },
                      additionalProperties: false
                    }
                  ]
                },
                mode: {
                  type: &quot;string&quot;,
                  enum: [&quot;strict&quot;, &quot;minimum&quot;]
                },
                beforeColon: {
                  type: &quot;boolean&quot;
                },
                afterColon: {
                  type: &quot;boolean&quot;
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        },
        {
          type: &quot;object&quot;,
          properties: {
            singleLine: {
              type: &quot;object&quot;,
              properties: {
                mode: {
                  type: &quot;string&quot;,
                  enum: [&quot;strict&quot;, &quot;minimum&quot;]
                },
                beforeColon: {
                  type: &quot;boolean&quot;
                },
                afterColon: {
                  type: &quot;boolean&quot;
                }
              },
              additionalProperties: false
            },
            multiLine: {
              type: &quot;object&quot;,
              properties: {
                mode: {
                  type: &quot;string&quot;,
                  enum: [&quot;strict&quot;, &quot;minimum&quot;]
                },
                beforeColon: {
                  type: &quot;boolean&quot;
                },
                afterColon: {
                  type: &quot;boolean&quot;
                }
              },
              additionalProperties: false
            },
            align: {
              type: &quot;object&quot;,
              properties: {
                mode: {
                  type: &quot;string&quot;,
                  enum: [&quot;strict&quot;, &quot;minimum&quot;]
                },
                on: {
                  type: &quot;string&quot;,
                  enum: [&quot;colon&quot;, &quot;value&quot;]
                },
                beforeColon: {
                  type: &quot;boolean&quot;
                },
                afterColon: {
                  type: &quot;boolean&quot;
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ]
    }],
    messages: {
      extraKey: &quot;Extra space after {{computed}}key &#039;{{key}}&#039;.&quot;,
      extraValue: &quot;Extra space before value for {{computed}}key &#039;{{key}}&#039;.&quot;,
      missingKey: &quot;Missing space after {{computed}}key &#039;{{key}}&#039;.&quot;,
      missingValue: &quot;Missing space before value for {{computed}}key &#039;{{key}}&#039;.&quot;
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const ruleOptions = initOptions({}, options);
    const multiLineOptions = ruleOptions.multiLine;
    const singleLineOptions = ruleOptions.singleLine;
    const alignmentOptions = ruleOptions.align || null;
    const ignoredNodes = ruleOptions.ignoredNodes;
    const sourceCode = context.sourceCode;
    function isKeyValueProperty(property) {
      if (property.type === &quot;ImportAttribute&quot;)
        return true;
      return !(&quot;method&quot; in property &amp;&amp; property.method || &quot;shorthand&quot; in property &amp;&amp; property.shorthand || &quot;kind&quot; in property &amp;&amp; property.kind !== &quot;init&quot; || property.type !== &quot;Property&quot;);
    }
    function getNextColon(node) {
      return sourceCode.getTokenAfter(node, isColonToken);
    }
    function getLastTokenBeforeColon(node) {
      const colonToken = getNextColon(node);
      return sourceCode.getTokenBefore(colonToken);
    }
    function getFirstTokenAfterColon(node) {
      const colonToken = getNextColon(node);
      return sourceCode.getTokenAfter(colonToken);
    }
    function continuesPropertyGroup(lastMember, candidate) {
      const groupEndLine = lastMember.loc.start.line;
      const candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;
      if (candidateValueStartLine - groupEndLine &lt;= 1)
        return true;
      const leadingComments = sourceCode.getCommentsBefore(candidate);
      if (leadingComments.length &amp;&amp; leadingComments[0].loc.start.line - groupEndLine &lt;= 1 &amp;&amp; candidateValueStartLine - last(leadingComments).loc.end.line &lt;= 1) {
        for (let i = 1; i &lt; leadingComments.length; i++) {
          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line &gt; 1)
            return false;
        }
        return true;
      }
      return false;
    }
    function getKey(property) {
      const key = property.key;
      if (property.type !== &quot;ImportAttribute&quot; &amp;&amp; property.computed)
        return sourceCode.getText().slice(key.range[0], key.range[1]);
      return getStaticPropertyName(property);
    }
    function report(property, side, whitespace, expected, mode) {
      const diff = whitespace.length - expected;
      if ((diff &amp;&amp; mode === &quot;strict&quot; || diff &lt; 0 &amp;&amp; mode === &quot;minimum&quot; || diff &gt; 0 &amp;&amp; !expected &amp;&amp; mode === &quot;minimum&quot;) &amp;&amp; !(expected &amp;&amp; containsLineTerminator(whitespace))) {
        const nextColon = getNextColon(property.key);
        const tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true });
        const tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true });
        const isKeySide = side === &quot;key&quot;;
        const isExtra = diff &gt; 0;
        const diffAbs = Math.abs(diff);
        const spaces = new Array(diffAbs + 1).join(&quot; &quot;);
        const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
        const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
        const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
        const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;
        let fix;
        if (isExtra) {
          let range;
          if (isKeySide)
            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
          else
            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
          fix = function(fixer) {
            return fixer.removeRange(range);
          };
        } else {
          if (isKeySide) {
            fix = function(fixer) {
              return fixer.insertTextAfter(tokenBeforeColon, spaces);
            };
          } else {
            fix = function(fixer) {
              return fixer.insertTextBefore(tokenAfterColon, spaces);
            };
          }
        }
        let messageId;
        if (isExtra)
          messageId = side === &quot;key&quot; ? &quot;extraKey&quot; : &quot;extraValue&quot;;
        else
          messageId = side === &quot;key&quot; ? &quot;missingKey&quot; : &quot;missingValue&quot;;
        context.report({
          node: property[side],
          loc,
          messageId,
          data: {
            computed: property.type !== &quot;ImportAttribute&quot; &amp;&amp; property.computed ? &quot;computed &quot; : &quot;&quot;,
            key: getKey(property)
          },
          fix
        });
      }
    }
    function getKeyWidth(property) {
      const startToken = sourceCode.getFirstToken(property);
      const endToken = getLastTokenBeforeColon(property.key);
      return getStringLength(sourceCode.getText().slice(startToken.range[0], endToken.range[1]));
    }
    function getPropertyWhitespace(property) {
      const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(
        property.key.range[1],
        property.value.range[0]
      ));
      if (whitespace) {
        return {
          beforeColon: whitespace[1],
          afterColon: whitespace[2]
        };
      }
      return null;
    }
    function createGroups(properties) {
      if (properties.length === 1)
        return [properties];
      return properties.reduce((groups, property) =&gt; {
        const currentGroup = last(groups);
        const prev = last(currentGroup);
        if (!prev || continuesPropertyGroup(prev, property))
          currentGroup.push(property);
        else
          groups.push([property]);
        return groups;
      }, [
        []
      ]);
    }
    function verifyGroupAlignment(properties) {
      const length = properties.length;
      const widths = properties.map(getKeyWidth);
      const align = alignmentOptions.on;
      let targetWidth = Math.max(...widths);
      let beforeColon;
      let afterColon;
      let mode;
      if (alignmentOptions &amp;&amp; length &gt; 1) {
        beforeColon = alignmentOptions.beforeColon;
        afterColon = alignmentOptions.afterColon;
        mode = alignmentOptions.mode;
      } else {
        beforeColon = multiLineOptions.beforeColon;
        afterColon = multiLineOptions.afterColon;
        mode = alignmentOptions.mode;
      }
      targetWidth += align === &quot;colon&quot; ? beforeColon : afterColon;
      for (let i = 0; i &lt; length; i++) {
        const property = properties[i];
        const whitespace = getPropertyWhitespace(property);
        if (whitespace) {
          const width = widths[i];
          if (align === &quot;value&quot;) {
            report(property, &quot;key&quot;, whitespace.beforeColon, beforeColon, mode);
            report(property, &quot;value&quot;, whitespace.afterColon, targetWidth - width, mode);
          } else {
            report(property, &quot;key&quot;, whitespace.beforeColon, targetWidth - width, mode);
            report(property, &quot;value&quot;, whitespace.afterColon, afterColon, mode);
          }
        }
      }
    }
    function verifySpacing(node, lineOptions) {
      if (ignoredNodes.includes(node.parent.type))
        return;
      const actual = getPropertyWhitespace(node);
      if (actual) {
        report(node, &quot;key&quot;, actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
        report(node, &quot;value&quot;, actual.afterColon, lineOptions.afterColon, lineOptions.mode);
      }
    }
    function verifyListSpacing(properties, lineOptions) {
      const length = properties.length;
      for (let i = 0; i &lt; length; i++)
        verifySpacing(properties[i], lineOptions);
    }
    function verifyAlignment(properties) {
      createGroups(properties).forEach((group) =&gt; {
        const properties2 = group.filter(isKeyValueProperty);
        if (properties2.length &gt; 0 &amp;&amp; isSingleLineProperties(properties2))
          verifyListSpacing(properties2, multiLineOptions);
        else
          verifyGroupAlignment(properties2);
      });
    }
    function verifyImportAttributes(node) {
      if (ignoredNodes.includes(node.type))
        return;
      if (!node.attributes)
        return;
      if (!node.attributes.length)
        return;
      if (isSingleLineImportAttributes(node, sourceCode))
        verifyListSpacing(node.attributes, singleLineOptions);
      else
        verifyAlignment(node.attributes);
    }
    if (alignmentOptions) {
      return {
        ObjectExpression(node) {
          if (ignoredNodes.includes(node.type))
            return;
          if (isSingleLine(node))
            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);
          else
            verifyAlignment(node.properties);
        },
        ImportDeclaration(node) {
          verifyImportAttributes(node);
        },
        ExportNamedDeclaration(node) {
          verifyImportAttributes(node);
        },
        ExportAllDeclaration(node) {
          verifyImportAttributes(node);
        }
      };
    }
    return {
      Property(node) {
        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
      },
      ImportAttribute(node) {
        const parent = node.parent;
        verifySpacing(node, isSingleLineImportAttributes(parent, sourceCode) ? singleLineOptions : multiLineOptions);
      }
    };
  }
});

export { keySpacing as default };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
