<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/lib/attestations/packed.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/lib/attestations/packed.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">296</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">44.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.34</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint-disable no-invalid-this */
// validators are a mixin, so it&#039;s okay that we&#039;re using &#039;this&#039; all over the place

&quot;use strict&quot;;

const {
	printHex,
	abToBuf,
	abToPem,
	abEqual,
	coerceToArrayBuffer,
	coerceToBase64,
} = require(&quot;../utils&quot;);
const crypto = require(&quot;crypto&quot;);

const {
	Certificate,
	CertManager,
} = require(&quot;../certUtils&quot;);
const rootCertList = require(&quot;./u2fRootCerts&quot;);

const algMap = new Map([
	[-7, {
		algName: &quot;ECDSA_w_SHA256&quot;,
		hashAlg: &quot;SHA256&quot;,
	}],
	// [-8, {
	//     name: &quot;EdDSA&quot;,
	//     hash: undefined
	// }],
	[-35, {
		algName: &quot;ECDSA_w_SHA384&quot;,
		hashAlg: &quot;SHA384&quot;,
	}],
	[-36, {
		algName: &quot;ECDSA_w_SHA512&quot;,
		hashAlg: &quot;SHA512&quot;,
	}],
]);

function packedParseFn(attStmt) {
	var ret = new Map();

	// alg
	var algEntry = algMap.get(attStmt.alg);
	if (algEntry === undefined) {
		throw new Error(&quot;packed attestation: unknown algorithm: &quot; + attStmt.alg);
	}
	ret.set(&quot;alg&quot;, algEntry);

	// x5c
	var x5c = attStmt.x5c;
	var newX5c = [];
	if (Array.isArray(x5c)) {
		for (let cert of x5c) {
			cert = coerceToArrayBuffer(cert, &quot;packed x5c cert&quot;);
			newX5c.push(cert);
		}
		ret.set(&quot;attCert&quot;, newX5c.shift());
		ret.set(&quot;x5c&quot;, newX5c);
	} else {
		ret.set(&quot;x5c&quot;, x5c);
	}

	// ecdaaKeyId
	var ecdaaKeyId = attStmt.ecdaaKeyId;
	if (ecdaaKeyId !== undefined) {
		ecdaaKeyId = coerceToArrayBuffer(ecdaaKeyId, &quot;ecdaaKeyId&quot;);
		ret.set(&quot;ecdaaKeyId&quot;, ecdaaKeyId);
	}

	// sig
	var sig = attStmt.sig;
	sig = coerceToArrayBuffer(sig, &quot;packed signature&quot;);
	ret.set(&quot;sig&quot;, sig);

	return ret;
}

async function packedValidateFn() {
	var x5c = this.authnrData.get(&quot;x5c&quot;);
	var ecdaaKeyId = this.authnrData.get(&quot;ecdaaKeyId&quot;);

	if (x5c !== undefined &amp;&amp; ecdaaKeyId !== undefined) {
		throw new Error(&quot;packed attestation: should be &#039;basic&#039; or &#039;ecdaa&#039;, got both&quot;);
	}

	if (x5c) return packedValidateBasic.call(this);
	if (ecdaaKeyId) return packedValidateEcdaa.call(this);
	return packedValidateSurrogate.call(this);
}

async function packedValidateBasic() {
	// see what algorithm we&#039;re working with
	var {
		algName,
		hashAlg,
	} = this.authnrData.get(&quot;alg&quot;);

	if (algName === undefined) {
		throw new Error(&quot;packed attestation: unknown algorithm &quot; + alg);
	}

	// from: https://w3c.github.io/webauthn/#packed-attestation
	// Verify that sig is a valid signature over the concatenation of authenticatorData and clientDataHash using the attestation public key in x5c with the algorithm specified in alg.
	var res = validateSignature(
		this.clientData.get(&quot;rawClientDataJson&quot;),
		this.authnrData.get(&quot;rawAuthnrData&quot;),
		this.authnrData.get(&quot;sig&quot;),
		hashAlg,
		this.authnrData.get(&quot;attCert&quot;)
	);
	if (!res) {
		throw new Error(&quot;packed attestation signature verification failed&quot;);
	}
	this.audit.journal.add(&quot;sig&quot;);
	this.audit.journal.add(&quot;alg&quot;);

	// Verify that x5c meets the requirements in ยง8.2.1 Packed attestation statement certificate requirements.
	await validateCerts(
		this.authnrData.get(&quot;attCert&quot;),
		this.authnrData.get(&quot;aaguid&quot;),
		this.authnrData.get(&quot;x5c&quot;),
		this.audit
	);

	// If successful, return attestation type Basic and attestation trust path x5c.
	this.audit.info.set(&quot;attestation-type&quot;, &quot;basic&quot;);

	this.audit.journal.add(&quot;fmt&quot;);

	return true;
}

function validateSignature(rawClientData, authenticatorData, sig, hashAlg, parsedAttCert) {
	// create clientDataHash
	const hash = crypto.createHash(&quot;sha256&quot;);
	hash.update(abToBuf(rawClientData));
	var clientDataHashBuf = hash.digest();
	var clientDataHash = new Uint8Array(clientDataHashBuf).buffer;

	// convert cert to PEM
	var attCertPem = abToPem(&quot;CERTIFICATE&quot;, parsedAttCert);

	// verify signature
	const verify = crypto.createVerify(hashAlg);
	verify.write(abToBuf(authenticatorData));
	verify.write(abToBuf(clientDataHash));
	verify.end();
	return verify.verify(attCertPem, abToBuf(sig));
}

async function validateCerts(parsedAttCert, aaguid, x5c, audit) {
	// make sure our root certs are loaded
	if (CertManager.getCerts().size === 0) {
		rootCertList.forEach((cert) =&gt; CertManager.addCert(cert));
	}

	// decode attestation cert
	var attCert = new Certificate(coerceToBase64(parsedAttCert, &quot;parsedAttCert&quot;));
	try {
		await attCert.verify();
	} catch (e) {
		let err = e;
		if (err.message === &quot;Please provide issuer certificate as a parameter&quot;) {
			// err = new Error(&quot;Root attestation certificate for this token could not be found. Please contact your security key vendor.&quot;);
			audit.warning.set(&quot;attesation-not-validated&quot;, &quot;could not validate attestation because the root attestation certification could not be found&quot;);
		} else {
			throw err;
		}
	}
	// TODO: validate chain?
	audit.journal.add(&quot;x5c&quot;);

	// cert MUST be x.509v3
	if (attCert.getVersion() !== 3) {
		throw new Error(&quot;expected packed attestation certificate to be x.509v3&quot;);
	}

	// save certificate warnings, info, and extensions in our audit information
	var exts = attCert.getExtensions();
	exts.forEach((v, k) =&gt; audit.info.set(k, v));
	attCert.info.forEach((v, k) =&gt; audit.info.set(k, v));
	attCert.warning.forEach((v, k) =&gt; audit.warning.set(k, v));
	audit.journal.add(&quot;attCert&quot;);
	// console.log(&quot;_cert&quot;, attCert._cert);
	// console.log(&quot;_cert.subject&quot;, attCert._cert.subject);

	// from: https://w3c.github.io/webauthn/#packed-attestation
	// Version MUST be set to 3 (which is indicated by an ASN.1 INTEGER with value 2).
	if (attCert.getVersion() !== 3) {
		throw new Error(&quot;expected packed attestation certificate to be x.509v3&quot;);
	}

	// Subject field MUST be set to:
	// Subject-C ISO 3166 code specifying the country where the Authenticator vendor is incorporated (PrintableString)
	// Subject-O Legal name of the Authenticator vendor (UTF8String)
	// Subject-OU Literal string โAuthenticator Attestationโ (UTF8String)
	// Subject-CN A UTF8String of the vendorโs choosing
	var subject = attCert.getSubject();
	if (typeof subject.get(&quot;country-name&quot;) !== &quot;string&quot;) {
		throw new Error(&quot;packed attestation: attestation certificate missing &#039;country name&#039;&quot;);
	}

	if (typeof subject.get(&quot;organization-name&quot;) !== &quot;string&quot;) {
		throw new Error(&quot;packed attestation: attestation certificate missing &#039;organization name&#039;&quot;);
	}

	if (subject.get(&quot;organizational-unit-name&quot;) !== &quot;Authenticator Attestation&quot;) {
		throw new Error(&quot;packed attestation: attestation certificate &#039;organizational unit name&#039; must be &#039;Authenticator Attestation&#039;&quot;);
	}

	if (typeof subject.get(&quot;common-name&quot;) !== &quot;string&quot;) {
		throw new Error(&quot;packed attestation: attestation certificate missing &#039;common name&#039;&quot;);
	}

	// If the related attestation root certificate is used for multiple authenticator models, the Extension OID 1.3.6.1.4.1.45724.1.1.4 (id-fido-gen-ce-aaguid) MUST be present, containing the AAGUID as a 16-byte OCTET STRING. The extension MUST NOT be marked as critical.
	// XXX: no way to tell if AAGUID is required on the server side...

	// The Basic Constraints extension MUST have the CA component set to false.
	var basicConstraints = exts.get(&quot;basic-constraints&quot;);
	if (basicConstraints.cA !== false) {
		throw new Error(&quot;packed attestation: basic constraints &#039;cA&#039; must be &#039;false&#039;&quot;);
	}

	// An Authority Information Access (AIA) extension with entry id-ad-ocsp and a CRL Distribution Point extension [RFC5280] are both OPTIONAL as the status of many attestation certificates is available through authenticator metadata services
	// TODO: no example of this is available to test against

	// If x5c contains an extension with OID 1.3.6.1.4.1.45724.1.1.4 (id-fido-gen-ce-aaguid) verify that the value of this extension matches the aaguid in authenticatorData.
	var certAaguid = exts.get(&quot;fido-aaguid&quot;);
	if (certAaguid !== undefined &amp;&amp; !abEqual(aaguid, certAaguid)) {
		throw new Error(&quot;packed attestation: authnrData AAGUID did not match AAGUID in attestation certificate&quot;);
	}
}

function validateSelfSignature(rawClientData, authenticatorData, sig, hashAlg, publicKeyPem) {
	// create clientDataHash
	const hash = crypto.createHash(&quot;sha256&quot;);
	hash.update(abToBuf(rawClientData));
	var clientDataHashBuf = hash.digest();
	var clientDataHash = new Uint8Array(clientDataHashBuf).buffer;

	// verify signature
	const verify = crypto.createVerify(hashAlg);
	verify.write(abToBuf(authenticatorData));
	verify.write(abToBuf(clientDataHash));
	verify.end();
	return verify.verify(publicKeyPem, abToBuf(sig));
}

function packedValidateSurrogate() {
	// see what algorithm we&#039;re working with
	var {
		algName,
		hashAlg,
	} = this.authnrData.get(&quot;alg&quot;);

	if (algName === undefined) {
		throw new Error(&quot;packed attestation: unknown algorithm &quot; + alg);
	}

	// from: https://w3c.github.io/webauthn/#packed-attestation
	// Verify that sig is a valid signature over the concatenation of authenticatorData and clientDataHash using the credential public key with alg.

	var res = validateSelfSignature(
		this.clientData.get(&quot;rawClientDataJson&quot;),
		this.authnrData.get(&quot;rawAuthnrData&quot;),
		this.authnrData.get(&quot;sig&quot;),
		hashAlg,
		this.authnrData.get(&quot;credentialPublicKeyPem&quot;)
	);
	if (!res) {
		throw new Error(&quot;packed attestation signature verification failed&quot;);
	}
	this.audit.journal.add(&quot;sig&quot;);
	this.audit.journal.add(&quot;alg&quot;);
	this.audit.journal.add(&quot;x5c&quot;);

	// If successful, return attestation type Self and an empty trust path
	this.audit.info.set(&quot;attestation-type&quot;, &quot;self&quot;);

	this.audit.journal.add(&quot;fmt&quot;);

	return true;
}

function packedValidateEcdaa() {
	throw new Error(&quot;packed attestation: ECDAA not implemented, please open a GitHub issue.&quot;);
}

module.exports = {
	name: &quot;packed&quot;,
	parseFn: packedParseFn,
	validateFn: packedValidateFn,
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
