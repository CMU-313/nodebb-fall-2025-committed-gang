<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webcrypto-core/build/webcrypto-core.es.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webcrypto-core/build/webcrypto-core.es.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1596</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">168.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">22.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 Copyright (c) Peculiar Ventures, LLC
*/

import { Convert, BufferSourceConverter, combine } from &#039;pvtsutils&#039;;
export { BufferSourceConverter } from &#039;pvtsutils&#039;;
import { AsnProp, AsnPropTypes, AsnType, AsnTypeTypes, AsnIntegerConverter, AsnSerializer, AsnConvert } from &#039;@peculiar/asn1-schema&#039;;
import { __decorate } from &#039;tslib&#039;;
import { JsonProp, JsonPropTypes } from &#039;@peculiar/json-schema&#039;;
import * as asn1 from &#039;asn1js&#039;;

class CryptoError extends Error {
}

class AlgorithmError extends CryptoError {
}

class UnsupportedOperationError extends CryptoError {
    constructor(methodName) {
        super(`Unsupported operation: ${methodName ? `${methodName}` : &quot;&quot;}`);
    }
}

class OperationError extends CryptoError {
}

class RequiredPropertyError extends CryptoError {
    constructor(propName) {
        super(`${propName}: Missing required property`);
    }
}

class PemConverter {
    static toArrayBuffer(pem) {
        const base64 = pem
            .replace(/-{5}(BEGIN|END) .*-{5}/g, &quot;&quot;)
            .replace(&quot;\r&quot;, &quot;&quot;)
            .replace(&quot;\n&quot;, &quot;&quot;);
        return Convert.FromBase64(base64);
    }
    static toUint8Array(pem) {
        const bytes = this.toArrayBuffer(pem);
        return new Uint8Array(bytes);
    }
    static fromBufferSource(buffer, tag) {
        const base64 = Convert.ToBase64(buffer);
        let sliced;
        let offset = 0;
        const rows = [];
        while (offset &lt; base64.length) {
            sliced = base64.slice(offset, offset + 64);
            if (sliced.length) {
                rows.push(sliced);
            }
            else {
                break;
            }
            offset += 64;
        }
        const upperCaseTag = tag.toUpperCase();
        return `-----BEGIN ${upperCaseTag}-----\n${rows.join(&quot;\n&quot;)}\n-----END ${upperCaseTag}-----`;
    }
    static isPEM(data) {
        return /-----BEGIN .+-----[A-Za-z0-9+/+=\s\n]+-----END .+-----/i.test(data);
    }
    static getTagName(pem) {
        if (!this.isPEM(pem)) {
            throw new Error(&quot;Bad parameter. Incoming data is not right PEM&quot;);
        }
        const res = /-----BEGIN (.+)-----/.exec(pem);
        if (!res) {
            throw new Error(&quot;Cannot get tag from PEM&quot;);
        }
        return res[1];
    }
    static hasTagName(pem, tagName) {
        const tag = this.getTagName(pem);
        return tagName.toLowerCase() === tag.toLowerCase();
    }
    static isCertificate(pem) {
        return this.hasTagName(pem, &quot;certificate&quot;);
    }
    static isCertificateRequest(pem) {
        return this.hasTagName(pem, &quot;certificate request&quot;);
    }
    static isCRL(pem) {
        return this.hasTagName(pem, &quot;x509 crl&quot;);
    }
    static isPublicKey(pem) {
        return this.hasTagName(pem, &quot;public key&quot;);
    }
}

function isJWK(data) {
    return typeof data === &quot;object&quot; &amp;&amp; &quot;kty&quot; in data;
}

class ProviderCrypto {
    async digest(...args) {
        this.checkDigest.apply(this, args);
        return this.onDigest.apply(this, args);
    }
    checkDigest(algorithm, _data) {
        this.checkAlgorithmName(algorithm);
    }
    async onDigest(_algorithm, _data) {
        throw new UnsupportedOperationError(&quot;digest&quot;);
    }
    async generateKey(...args) {
        this.checkGenerateKey.apply(this, args);
        return this.onGenerateKey.apply(this, args);
    }
    checkGenerateKey(algorithm, _extractable, keyUsages, ..._args) {
        this.checkAlgorithmName(algorithm);
        this.checkGenerateKeyParams(algorithm);
        if (!(keyUsages &amp;&amp; keyUsages.length)) {
            throw new TypeError(`Usages cannot be empty when creating a key.`);
        }
        let allowedUsages;
        if (Array.isArray(this.usages)) {
            allowedUsages = this.usages;
        }
        else {
            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);
        }
        this.checkKeyUsages(keyUsages, allowedUsages);
    }
    checkGenerateKeyParams(_algorithm) {
    }
    async onGenerateKey(_algorithm, _extractable, _keyUsages, ..._args) {
        throw new UnsupportedOperationError(&quot;generateKey&quot;);
    }
    async sign(...args) {
        this.checkSign.apply(this, args);
        return this.onSign.apply(this, args);
    }
    checkSign(algorithm, key, _data, ..._args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, &quot;sign&quot;);
    }
    async onSign(_algorithm, _key, _data, ..._args) {
        throw new UnsupportedOperationError(&quot;sign&quot;);
    }
    async verify(...args) {
        this.checkVerify.apply(this, args);
        return this.onVerify.apply(this, args);
    }
    checkVerify(algorithm, key, _signature, _data, ..._args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, &quot;verify&quot;);
    }
    async onVerify(_algorithm, _key, _signature, _data, ..._args) {
        throw new UnsupportedOperationError(&quot;verify&quot;);
    }
    async encrypt(...args) {
        this.checkEncrypt.apply(this, args);
        return this.onEncrypt.apply(this, args);
    }
    checkEncrypt(algorithm, key, _data, options = {}, ..._args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? &quot;encrypt&quot; : void 0);
    }
    async onEncrypt(_algorithm, _key, _data, ..._args) {
        throw new UnsupportedOperationError(&quot;encrypt&quot;);
    }
    async decrypt(...args) {
        this.checkDecrypt.apply(this, args);
        return this.onDecrypt.apply(this, args);
    }
    checkDecrypt(algorithm, key, _data, options = {}, ..._args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? &quot;decrypt&quot; : void 0);
    }
    async onDecrypt(_algorithm, _key, _data, ..._args) {
        throw new UnsupportedOperationError(&quot;decrypt&quot;);
    }
    async deriveBits(...args) {
        this.checkDeriveBits.apply(this, args);
        return this.onDeriveBits.apply(this, args);
    }
    checkDeriveBits(algorithm, baseKey, length, options = {}, ..._args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(baseKey, options.keyUsage ? &quot;deriveBits&quot; : void 0);
        if (length % 8 !== 0) {
            throw new OperationError(&quot;length: Is not multiple of 8&quot;);
        }
    }
    async onDeriveBits(_algorithm, _baseKey, _length, ..._args) {
        throw new UnsupportedOperationError(&quot;deriveBits&quot;);
    }
    async exportKey(...args) {
        this.checkExportKey.apply(this, args);
        return this.onExportKey.apply(this, args);
    }
    checkExportKey(format, key, ..._args) {
        this.checkKeyFormat(format);
        this.checkCryptoKey(key);
        if (!key.extractable) {
            throw new CryptoError(&quot;key: Is not extractable&quot;);
        }
    }
    async onExportKey(_format, _key, ..._args) {
        throw new UnsupportedOperationError(&quot;exportKey&quot;);
    }
    async importKey(...args) {
        this.checkImportKey.apply(this, args);
        return this.onImportKey.apply(this, args);
    }
    checkImportKey(format, keyData, algorithm, _extractable, keyUsages, ..._args) {
        this.checkKeyFormat(format);
        this.checkKeyData(format, keyData);
        this.checkAlgorithmName(algorithm);
        this.checkImportParams(algorithm);
        if (Array.isArray(this.usages)) {
            this.checkKeyUsages(keyUsages, this.usages);
        }
    }
    async onImportKey(_format, _keyData, _algorithm, _extractable, _keyUsages, ..._args) {
        throw new UnsupportedOperationError(&quot;importKey&quot;);
    }
    checkAlgorithmName(algorithm) {
        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {
            throw new AlgorithmError(&quot;Unrecognized name&quot;);
        }
    }
    checkAlgorithmParams(_algorithm) {
    }
    checkDerivedKeyParams(_algorithm) {
    }
    checkKeyUsages(usages, allowed) {
        for (const usage of usages) {
            if (allowed.indexOf(usage) === -1) {
                throw new TypeError(&quot;Cannot create a key using the specified key usages&quot;);
            }
        }
    }
    checkCryptoKey(key, keyUsage) {
        this.checkAlgorithmName(key.algorithm);
        if (keyUsage &amp;&amp; key.usages.indexOf(keyUsage) === -1) {
            throw new CryptoError(`key does not match that of operation`);
        }
    }
    checkRequiredProperty(data, propName) {
        if (!(propName in data)) {
            throw new RequiredPropertyError(propName);
        }
    }
    checkHashAlgorithm(algorithm, hashAlgorithms) {
        for (const item of hashAlgorithms) {
            if (item.toLowerCase() === algorithm.name.toLowerCase()) {
                return;
            }
        }
        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(&quot;, &quot;)}`);
    }
    checkImportParams(_algorithm) {
    }
    checkKeyFormat(format) {
        switch (format) {
            case &quot;raw&quot;:
            case &quot;pkcs8&quot;:
            case &quot;spki&quot;:
            case &quot;jwk&quot;:
                break;
            default:
                throw new TypeError(&quot;format: Is invalid value. Must be &#039;jwk&#039;, &#039;raw&#039;, &#039;spki&#039;, or &#039;pkcs8&#039;&quot;);
        }
    }
    checkKeyData(format, keyData) {
        if (!keyData) {
            throw new TypeError(&quot;keyData: Cannot be empty on empty on key importing&quot;);
        }
        if (format === &quot;jwk&quot;) {
            if (!isJWK(keyData)) {
                throw new TypeError(&quot;keyData: Is not JsonWebToken&quot;);
            }
        }
        else if (!BufferSourceConverter.isBufferSource(keyData)) {
            throw new TypeError(&quot;keyData: Is not ArrayBufferView or ArrayBuffer&quot;);
        }
    }
    prepareData(data) {
        return BufferSourceConverter.toArrayBuffer(data);
    }
}

class AesProvider extends ProviderCrypto {
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;length&quot;);
        if (typeof algorithm.length !== &quot;number&quot;) {
            throw new TypeError(&quot;length: Is not of type Number&quot;);
        }
        switch (algorithm.length) {
            case 128:
            case 192:
            case 256:
                break;
            default:
                throw new TypeError(&quot;length: Must be 128, 192, or 256&quot;);
        }
    }
    checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
    }
}

class AesCbcProvider extends AesProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;AES-CBC&quot;;
        this.usages = [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;iv&quot;);
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
            throw new TypeError(&quot;iv: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
        if (algorithm.iv.byteLength !== 16) {
            throw new TypeError(&quot;iv: Must have length 16 bytes&quot;);
        }
    }
}

class AesCmacProvider extends AesProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;AES-CMAC&quot;;
        this.usages = [&quot;sign&quot;, &quot;verify&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;length&quot;);
        if (typeof algorithm.length !== &quot;number&quot;) {
            throw new TypeError(&quot;length: Is not a Number&quot;);
        }
        if (algorithm.length &lt; 1) {
            throw new OperationError(&quot;length: Must be more than 0&quot;);
        }
    }
}

class AesCtrProvider extends AesProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;AES-CTR&quot;;
        this.usages = [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;counter&quot;);
        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {
            throw new TypeError(&quot;counter: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
        if (algorithm.counter.byteLength !== 16) {
            throw new TypeError(&quot;iv: Must have length 16 bytes&quot;);
        }
        this.checkRequiredProperty(algorithm, &quot;length&quot;);
        if (typeof algorithm.length !== &quot;number&quot;) {
            throw new TypeError(&quot;length: Is not a Number&quot;);
        }
        if (algorithm.length &lt; 1) {
            throw new OperationError(&quot;length: Must be more than 0&quot;);
        }
    }
}

class AesEcbProvider extends AesProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;AES-ECB&quot;;
        this.usages = [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;];
    }
}

class AesGcmProvider extends AesProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;AES-GCM&quot;;
        this.usages = [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;];
    }
    checkAlgorithmParams(algorithm) {
        var _a;
        this.checkRequiredProperty(algorithm, &quot;iv&quot;);
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
            throw new TypeError(&quot;iv: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
        if (algorithm.iv.byteLength &lt; 1) {
            throw new OperationError(&quot;iv: Must have length more than 0 and less than 2^64 - 1&quot;);
        }
        (_a = algorithm.tagLength) !== null &amp;&amp; _a !== void 0 ? _a : (algorithm.tagLength = 128);
        switch (algorithm.tagLength) {
            case 32:
            case 64:
            case 96:
            case 104:
            case 112:
            case 120:
            case 128:
                break;
            default:
                throw new OperationError(&quot;tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128&quot;);
        }
    }
}

class AesKwProvider extends AesProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;AES-KW&quot;;
        this.usages = [&quot;wrapKey&quot;, &quot;unwrapKey&quot;];
    }
}

class DesProvider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.usages = [&quot;encrypt&quot;, &quot;decrypt&quot;, &quot;wrapKey&quot;, &quot;unwrapKey&quot;];
    }
    checkAlgorithmParams(algorithm) {
        if (this.ivSize) {
            this.checkRequiredProperty(algorithm, &quot;iv&quot;);
            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
                throw new TypeError(&quot;iv: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
            }
            if (algorithm.iv.byteLength !== this.ivSize) {
                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);
            }
        }
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;length&quot;);
        if (typeof algorithm.length !== &quot;number&quot;) {
            throw new TypeError(&quot;length: Is not of type Number&quot;);
        }
        if (algorithm.length !== this.keySizeBits) {
            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);
        }
    }
    checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
    }
}

class RsaProvider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.hashAlgorithms = [&quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;];
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, &quot;publicExponent&quot;);
        if (!(algorithm.publicExponent &amp;&amp; algorithm.publicExponent instanceof Uint8Array)) {
            throw new TypeError(&quot;publicExponent: Missing or not a Uint8Array&quot;);
        }
        const publicExponent = Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === &quot;Aw==&quot; || publicExponent === &quot;AQAB&quot;)) {
            throw new TypeError(&quot;publicExponent: Must be [3] or [1,0,1]&quot;);
        }
        this.checkRequiredProperty(algorithm, &quot;modulusLength&quot;);
        if (algorithm.modulusLength % 8
            || algorithm.modulusLength &lt; 256
            || algorithm.modulusLength &gt; 16384) {
            throw new TypeError(&quot;The modulus length must be a multiple of 8 bits and &gt;= 256 and &lt;= 16384&quot;);
        }
    }
    checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
    }
}

class RsaSsaProvider extends RsaProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;RSASSA-PKCS1-v1_5&quot;;
        this.usages = {
            privateKey: [&quot;sign&quot;],
            publicKey: [&quot;verify&quot;],
        };
    }
}

class RsaPssProvider extends RsaProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;RSA-PSS&quot;;
        this.usages = {
            privateKey: [&quot;sign&quot;],
            publicKey: [&quot;verify&quot;],
        };
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;saltLength&quot;);
        if (typeof algorithm.saltLength !== &quot;number&quot;) {
            throw new TypeError(&quot;saltLength: Is not a Number&quot;);
        }
        if (algorithm.saltLength &lt; 0) {
            throw new RangeError(&quot;saltLength: Must be positive number&quot;);
        }
    }
}

class RsaOaepProvider extends RsaProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;RSA-OAEP&quot;;
        this.usages = {
            privateKey: [&quot;decrypt&quot;, &quot;unwrapKey&quot;],
            publicKey: [&quot;encrypt&quot;, &quot;wrapKey&quot;],
        };
    }
    checkAlgorithmParams(algorithm) {
        if (algorithm.label
            &amp;&amp; !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {
            throw new TypeError(&quot;label: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
    }
}

class EllipticProvider extends ProviderCrypto {
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;namedCurve&quot;);
        this.checkNamedCurve(algorithm.namedCurve);
    }
    checkNamedCurve(namedCurve) {
        for (const item of this.namedCurves) {
            if (item.toLowerCase() === namedCurve.toLowerCase()) {
                return;
            }
        }
        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(&quot;, &quot;)}`);
    }
}

class EcdsaProvider extends EllipticProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;ECDSA&quot;;
        this.hashAlgorithms = [&quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;];
        this.usages = {
            privateKey: [&quot;sign&quot;],
            publicKey: [&quot;verify&quot;],
        };
        this.namedCurves = [&quot;P-256&quot;, &quot;P-384&quot;, &quot;P-521&quot;, &quot;K-256&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
    }
}

const KEY_TYPES = [&quot;secret&quot;, &quot;private&quot;, &quot;public&quot;];
class CryptoKey {
    static create(algorithm, type, extractable, usages) {
        const key = new this();
        key.algorithm = algorithm;
        key.type = type;
        key.extractable = extractable;
        key.usages = usages;
        return key;
    }
    static isKeyType(data) {
        return KEY_TYPES.indexOf(data) !== -1;
    }
    get [Symbol.toStringTag]() {
        return &quot;CryptoKey&quot;;
    }
}

class EcdhProvider extends EllipticProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;ECDH&quot;;
        this.usages = {
            privateKey: [&quot;deriveBits&quot;, &quot;deriveKey&quot;],
            publicKey: [],
        };
        this.namedCurves = [&quot;P-256&quot;, &quot;P-384&quot;, &quot;P-521&quot;, &quot;K-256&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;public&quot;);
        if (!(algorithm.public instanceof CryptoKey)) {
            throw new TypeError(&quot;public: Is not a CryptoKey&quot;);
        }
        if (algorithm.public.type !== &quot;public&quot;) {
            throw new OperationError(&quot;public: Is not a public key&quot;);
        }
        if (algorithm.public.algorithm.name !== this.name) {
            throw new OperationError(`public: Is not ${this.name} key`);
        }
    }
}

class EcdhEsProvider extends EcdhProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;ECDH-ES&quot;;
        this.namedCurves = [&quot;X25519&quot;, &quot;X448&quot;];
    }
}

class EdDsaProvider extends EllipticProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;EdDSA&quot;;
        this.usages = {
            privateKey: [&quot;sign&quot;],
            publicKey: [&quot;verify&quot;],
        };
        this.namedCurves = [&quot;Ed25519&quot;, &quot;Ed448&quot;];
    }
}

let ObjectIdentifier = class ObjectIdentifier {
    constructor(value) {
        if (value) {
            this.value = value;
        }
    }
};
__decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
], ObjectIdentifier.prototype, &quot;value&quot;, void 0);
ObjectIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
], ObjectIdentifier);

class AlgorithmIdentifier {
    constructor(params) {
        Object.assign(this, params);
    }
}
__decorate([
    AsnProp({
        type: AsnPropTypes.ObjectIdentifier,
    })
], AlgorithmIdentifier.prototype, &quot;algorithm&quot;, void 0);
__decorate([
    AsnProp({
        type: AsnPropTypes.Any,
        optional: true,
    })
], AlgorithmIdentifier.prototype, &quot;parameters&quot;, void 0);

class PrivateKeyInfo {
    constructor() {
        this.version = 0;
        this.privateKeyAlgorithm = new AlgorithmIdentifier();
        this.privateKey = new ArrayBuffer(0);
    }
}
__decorate([
    AsnProp({ type: AsnPropTypes.Integer })
], PrivateKeyInfo.prototype, &quot;version&quot;, void 0);
__decorate([
    AsnProp({ type: AlgorithmIdentifier })
], PrivateKeyInfo.prototype, &quot;privateKeyAlgorithm&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.OctetString })
], PrivateKeyInfo.prototype, &quot;privateKey&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Any, optional: true })
], PrivateKeyInfo.prototype, &quot;attributes&quot;, void 0);

class PublicKeyInfo {
    constructor() {
        this.publicKeyAlgorithm = new AlgorithmIdentifier();
        this.publicKey = new ArrayBuffer(0);
    }
}
__decorate([
    AsnProp({ type: AlgorithmIdentifier })
], PublicKeyInfo.prototype, &quot;publicKeyAlgorithm&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.BitString })
], PublicKeyInfo.prototype, &quot;publicKey&quot;, void 0);

const JsonBase64UrlArrayBufferConverter = {
    fromJSON: (value) =&gt; Convert.FromBase64Url(value),
    toJSON: (value) =&gt; Convert.ToBase64Url(new Uint8Array(value)),
};

const AsnIntegerArrayBufferConverter = {
    fromASN: (value) =&gt; {
        const valueHex = value.valueBlock.valueHex;
        return !(new Uint8Array(valueHex)[0])
            ? value.valueBlock.valueHex.slice(1)
            : value.valueBlock.valueHex;
    },
    toASN: (value) =&gt; {
        const valueHex = new Uint8Array(value)[0] &gt; 127
            ? combine(new Uint8Array([0]).buffer, value)
            : value;
        return new asn1.Integer({ valueHex });
    },
};

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,
  JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter
});

class RsaPrivateKey {
    constructor() {
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
    }
}
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerConverter })
], RsaPrivateKey.prototype, &quot;version&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;n&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;modulus&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;e&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;publicExponent&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;d&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;privateExponent&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;p&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;prime1&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;q&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;prime2&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;dp&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;exponent1&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;dq&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;exponent2&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;qi&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPrivateKey.prototype, &quot;coefficient&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Any, optional: true })
], RsaPrivateKey.prototype, &quot;otherPrimeInfos&quot;, void 0);

class RsaPublicKey {
    constructor() {
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
    }
}
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;n&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPublicKey.prototype, &quot;modulus&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
    JsonProp({ name: &quot;e&quot;, converter: JsonBase64UrlArrayBufferConverter })
], RsaPublicKey.prototype, &quot;publicExponent&quot;, void 0);

let EcPublicKey = class EcPublicKey {
    constructor(value) {
        this.value = new ArrayBuffer(0);
        if (value) {
            this.value = value;
        }
    }
    toJSON() {
        let bytes = new Uint8Array(this.value);
        if (bytes[0] !== 0x04) {
            throw new CryptoError(&quot;Wrong ECPoint. Current version supports only Uncompressed (0x04) point&quot;);
        }
        bytes = new Uint8Array(this.value.slice(1));
        const size = bytes.length / 2;
        const offset = 0;
        const json = {
            x: Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),
            y: Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size)),
        };
        return json;
    }
    fromJSON(json) {
        if (!(&quot;x&quot; in json)) {
            throw new Error(&quot;x: Missing required property&quot;);
        }
        if (!(&quot;y&quot; in json)) {
            throw new Error(&quot;y: Missing required property&quot;);
        }
        const x = Convert.FromBase64Url(json.x);
        const y = Convert.FromBase64Url(json.y);
        const value = combine(new Uint8Array([0x04]).buffer, x, y);
        this.value = new Uint8Array(value).buffer;
        return this;
    }
};
__decorate([
    AsnProp({ type: AsnPropTypes.OctetString })
], EcPublicKey.prototype, &quot;value&quot;, void 0);
EcPublicKey = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
], EcPublicKey);

class EcPrivateKey {
    constructor() {
        this.version = 1;
        this.privateKey = new ArrayBuffer(0);
    }
    fromJSON(json) {
        if (!(&quot;d&quot; in json)) {
            throw new Error(&quot;d: Missing required property&quot;);
        }
        this.privateKey = Convert.FromBase64Url(json.d);
        if (&quot;x&quot; in json) {
            const publicKey = new EcPublicKey();
            publicKey.fromJSON(json);
            const asn = AsnSerializer.toASN(publicKey);
            if (&quot;valueHex&quot; in asn.valueBlock) {
                this.publicKey = asn.valueBlock.valueHex;
            }
        }
        return this;
    }
    toJSON() {
        const jwk = {};
        jwk.d = Convert.ToBase64Url(this.privateKey);
        if (this.publicKey) {
            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());
        }
        return jwk;
    }
}
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerConverter })
], EcPrivateKey.prototype, &quot;version&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.OctetString })
], EcPrivateKey.prototype, &quot;privateKey&quot;, void 0);
__decorate([
    AsnProp({ context: 0, type: AsnPropTypes.Any, optional: true })
], EcPrivateKey.prototype, &quot;parameters&quot;, void 0);
__decorate([
    AsnProp({ context: 1, type: AsnPropTypes.BitString, optional: true })
], EcPrivateKey.prototype, &quot;publicKey&quot;, void 0);

const AsnIntegerWithoutPaddingConverter = {
    fromASN: (value) =&gt; {
        const bytes = new Uint8Array(value.valueBlock.valueHex);
        return (bytes[0] === 0)
            ? bytes.buffer.slice(1)
            : bytes.buffer;
    },
    toASN: (value) =&gt; {
        const bytes = new Uint8Array(value);
        if (bytes[0] &gt; 127) {
            const newValue = new Uint8Array(bytes.length + 1);
            newValue.set(bytes, 1);
            return new asn1.Integer({ valueHex: newValue.buffer });
        }
        return new asn1.Integer({ valueHex: value });
    },
};

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter
});

class EcUtils {
    static decodePoint(data, pointSize) {
        const view = BufferSourceConverter.toUint8Array(data);
        if ((view.length === 0) || (view[0] !== 4)) {
            throw new Error(&quot;Only uncompressed point format supported&quot;);
        }
        const n = (view.length - 1) / 2;
        if (n !== (Math.ceil(pointSize / 8))) {
            throw new Error(&quot;Point does not match field size&quot;);
        }
        const xb = view.slice(1, n + 1);
        const yb = view.slice(n + 1, n + 1 + n);
        return { x: xb, y: yb };
    }
    static encodePoint(point, pointSize) {
        const size = Math.ceil(pointSize / 8);
        if (point.x.byteLength !== size || point.y.byteLength !== size) {
            throw new Error(&quot;X,Y coordinates don&#039;t match point size criteria&quot;);
        }
        const x = BufferSourceConverter.toUint8Array(point.x);
        const y = BufferSourceConverter.toUint8Array(point.y);
        const res = new Uint8Array(size * 2 + 1);
        res[0] = 4;
        res.set(x, 1);
        res.set(y, size + 1);
        return res;
    }
    static getSize(pointSize) {
        return Math.ceil(pointSize / 8);
    }
    static encodeSignature(signature, pointSize) {
        const size = this.getSize(pointSize);
        const r = BufferSourceConverter.toUint8Array(signature.r);
        const s = BufferSourceConverter.toUint8Array(signature.s);
        const res = new Uint8Array(size * 2);
        res.set(this.padStart(r, size));
        res.set(this.padStart(s, size), size);
        return res;
    }
    static decodeSignature(data, pointSize) {
        const size = this.getSize(pointSize);
        const view = BufferSourceConverter.toUint8Array(data);
        if (view.length !== (size * 2)) {
            throw new Error(&quot;Incorrect size of the signature&quot;);
        }
        const r = view.slice(0, size);
        const s = view.slice(size);
        return {
            r: this.trimStart(r),
            s: this.trimStart(s),
        };
    }
    static trimStart(data) {
        let i = 0;
        while ((i &lt; data.length - 1) &amp;&amp; (data[i] === 0)) {
            i++;
        }
        if (i === 0) {
            return data;
        }
        return data.slice(i, data.length);
    }
    static padStart(data, size) {
        if (size === data.length) {
            return data;
        }
        const res = new Uint8Array(size);
        res.set(data, size - data.length);
        return res;
    }
}

class EcDsaSignature {
    constructor() {
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
    }
    static fromWebCryptoSignature(value) {
        const pointSize = value.byteLength / 2;
        const point = EcUtils.decodeSignature(value, pointSize * 8);
        const ecSignature = new EcDsaSignature();
        ecSignature.r = BufferSourceConverter.toArrayBuffer(point.r);
        ecSignature.s = BufferSourceConverter.toArrayBuffer(point.s);
        return ecSignature;
    }
    toWebCryptoSignature(pointSize) {
        if (!pointSize) {
            const maxPointLength = Math.max(this.r.byteLength, this.s.byteLength);
            if (maxPointLength &lt;= 32) {
                pointSize = 256;
            }
            else if (maxPointLength &lt;= 48) {
                pointSize = 384;
            }
            else {
                pointSize = 521;
            }
        }
        const signature = EcUtils.encodeSignature(this, pointSize);
        return signature.buffer;
    }
}
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })
], EcDsaSignature.prototype, &quot;r&quot;, void 0);
__decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })
], EcDsaSignature.prototype, &quot;s&quot;, void 0);

class OneAsymmetricKey extends PrivateKeyInfo {
}
__decorate([
    AsnProp({ context: 1, implicit: true, type: AsnPropTypes.BitString, optional: true })
], OneAsymmetricKey.prototype, &quot;publicKey&quot;, void 0);

let EdPrivateKey = class EdPrivateKey {
    constructor() {
        this.value = new ArrayBuffer(0);
    }
    fromJSON(json) {
        if (!json.d) {
            throw new Error(&quot;d: Missing required property&quot;);
        }
        this.value = Convert.FromBase64Url(json.d);
        return this;
    }
    toJSON() {
        const jwk = {
            d: Convert.ToBase64Url(this.value),
        };
        return jwk;
    }
};
__decorate([
    AsnProp({ type: AsnPropTypes.OctetString })
], EdPrivateKey.prototype, &quot;value&quot;, void 0);
EdPrivateKey = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
], EdPrivateKey);

let EdPublicKey = class EdPublicKey {
    constructor(value) {
        this.value = new ArrayBuffer(0);
        if (value) {
            this.value = value;
        }
    }
    toJSON() {
        const json = {
            x: Convert.ToBase64Url(this.value),
        };
        return json;
    }
    fromJSON(json) {
        if (!(&quot;x&quot; in json)) {
            throw new Error(&quot;x: Missing required property&quot;);
        }
        this.value = Convert.FromBase64Url(json.x);
        return this;
    }
};
__decorate([
    AsnProp({ type: AsnPropTypes.BitString })
], EdPublicKey.prototype, &quot;value&quot;, void 0);
EdPublicKey = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
], EdPublicKey);

let CurvePrivateKey = class CurvePrivateKey {
};
__decorate([
    AsnProp({ type: AsnPropTypes.OctetString }),
    JsonProp({ type: JsonPropTypes.String, converter: JsonBase64UrlArrayBufferConverter })
], CurvePrivateKey.prototype, &quot;d&quot;, void 0);
CurvePrivateKey = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
], CurvePrivateKey);

const idSecp256r1 = &quot;1.2.840.10045.3.1.7&quot;;
const idEllipticCurve = &quot;1.3.132.0&quot;;
const idSecp384r1 = `${idEllipticCurve}.34`;
const idSecp521r1 = `${idEllipticCurve}.35`;
const idSecp256k1 = `${idEllipticCurve}.10`;
const idVersionOne = &quot;1.3.36.3.3.2.8.1.1&quot;;
const idBrainpoolP160r1 = `${idVersionOne}.1`;
const idBrainpoolP160t1 = `${idVersionOne}.2`;
const idBrainpoolP192r1 = `${idVersionOne}.3`;
const idBrainpoolP192t1 = `${idVersionOne}.4`;
const idBrainpoolP224r1 = `${idVersionOne}.5`;
const idBrainpoolP224t1 = `${idVersionOne}.6`;
const idBrainpoolP256r1 = `${idVersionOne}.7`;
const idBrainpoolP256t1 = `${idVersionOne}.8`;
const idBrainpoolP320r1 = `${idVersionOne}.9`;
const idBrainpoolP320t1 = `${idVersionOne}.10`;
const idBrainpoolP384r1 = `${idVersionOne}.11`;
const idBrainpoolP384t1 = `${idVersionOne}.12`;
const idBrainpoolP512r1 = `${idVersionOne}.13`;
const idBrainpoolP512t1 = `${idVersionOne}.14`;
const idX25519 = &quot;1.3.101.110&quot;;
const idX448 = &quot;1.3.101.111&quot;;
const idEd25519 = &quot;1.3.101.112&quot;;
const idEd448 = &quot;1.3.101.113&quot;;

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AlgorithmIdentifier: AlgorithmIdentifier,
  get CurvePrivateKey () { return CurvePrivateKey; },
  EcDsaSignature: EcDsaSignature,
  EcPrivateKey: EcPrivateKey,
  get EcPublicKey () { return EcPublicKey; },
  get EdPrivateKey () { return EdPrivateKey; },
  get EdPublicKey () { return EdPublicKey; },
  get ObjectIdentifier () { return ObjectIdentifier; },
  OneAsymmetricKey: OneAsymmetricKey,
  PrivateKeyInfo: PrivateKeyInfo,
  PublicKeyInfo: PublicKeyInfo,
  RsaPrivateKey: RsaPrivateKey,
  RsaPublicKey: RsaPublicKey,
  converters: index$2,
  idBrainpoolP160r1: idBrainpoolP160r1,
  idBrainpoolP160t1: idBrainpoolP160t1,
  idBrainpoolP192r1: idBrainpoolP192r1,
  idBrainpoolP192t1: idBrainpoolP192t1,
  idBrainpoolP224r1: idBrainpoolP224r1,
  idBrainpoolP224t1: idBrainpoolP224t1,
  idBrainpoolP256r1: idBrainpoolP256r1,
  idBrainpoolP256t1: idBrainpoolP256t1,
  idBrainpoolP320r1: idBrainpoolP320r1,
  idBrainpoolP320t1: idBrainpoolP320t1,
  idBrainpoolP384r1: idBrainpoolP384r1,
  idBrainpoolP384t1: idBrainpoolP384t1,
  idBrainpoolP512r1: idBrainpoolP512r1,
  idBrainpoolP512t1: idBrainpoolP512t1,
  idEd25519: idEd25519,
  idEd448: idEd448,
  idEllipticCurve: idEllipticCurve,
  idSecp256k1: idSecp256k1,
  idSecp256r1: idSecp256r1,
  idSecp384r1: idSecp384r1,
  idSecp521r1: idSecp521r1,
  idVersionOne: idVersionOne,
  idX25519: idX25519,
  idX448: idX448
});

class EcCurves {
    constructor() { }
    static register(item) {
        const oid = new ObjectIdentifier();
        oid.value = item.id;
        const raw = AsnConvert.serialize(oid);
        this.items.push({
            ...item,
            raw,
        });
        this.names.push(item.name);
    }
    static find(nameOrId) {
        nameOrId = nameOrId.toUpperCase();
        for (const item of this.items) {
            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {
                return item;
            }
        }
        return null;
    }
    static get(nameOrId) {
        const res = this.find(nameOrId);
        if (!res) {
            throw new Error(`Unsupported EC named curve &#039;${nameOrId}&#039;`);
        }
        return res;
    }
}
EcCurves.items = [];
EcCurves.names = [];
EcCurves.register({ name: &quot;P-256&quot;, id: idSecp256r1, size: 256 });
EcCurves.register({ name: &quot;P-384&quot;, id: idSecp384r1, size: 384 });
EcCurves.register({ name: &quot;P-521&quot;, id: idSecp521r1, size: 521 });
EcCurves.register({ name: &quot;K-256&quot;, id: idSecp256k1, size: 256 });
EcCurves.register({ name: &quot;brainpoolP160r1&quot;, id: idBrainpoolP160r1, size: 160 });
EcCurves.register({ name: &quot;brainpoolP160t1&quot;, id: idBrainpoolP160t1, size: 160 });
EcCurves.register({ name: &quot;brainpoolP192r1&quot;, id: idBrainpoolP192r1, size: 192 });
EcCurves.register({ name: &quot;brainpoolP192t1&quot;, id: idBrainpoolP192t1, size: 192 });
EcCurves.register({ name: &quot;brainpoolP224r1&quot;, id: idBrainpoolP224r1, size: 224 });
EcCurves.register({ name: &quot;brainpoolP224t1&quot;, id: idBrainpoolP224t1, size: 224 });
EcCurves.register({ name: &quot;brainpoolP256r1&quot;, id: idBrainpoolP256r1, size: 256 });
EcCurves.register({ name: &quot;brainpoolP256t1&quot;, id: idBrainpoolP256t1, size: 256 });
EcCurves.register({ name: &quot;brainpoolP320r1&quot;, id: idBrainpoolP320r1, size: 320 });
EcCurves.register({ name: &quot;brainpoolP320t1&quot;, id: idBrainpoolP320t1, size: 320 });
EcCurves.register({ name: &quot;brainpoolP384r1&quot;, id: idBrainpoolP384r1, size: 384 });
EcCurves.register({ name: &quot;brainpoolP384t1&quot;, id: idBrainpoolP384t1, size: 384 });
EcCurves.register({ name: &quot;brainpoolP512r1&quot;, id: idBrainpoolP512r1, size: 512 });
EcCurves.register({ name: &quot;brainpoolP512t1&quot;, id: idBrainpoolP512t1, size: 512 });

class X25519Provider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;X25519&quot;;
        this.usages = {
            privateKey: [&quot;deriveKey&quot;, &quot;deriveBits&quot;],
            publicKey: [],
        };
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;public&quot;);
    }
}

class Ed25519Provider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;Ed25519&quot;;
        this.usages = {
            privateKey: [&quot;sign&quot;],
            publicKey: [&quot;verify&quot;],
        };
    }
}

class HmacProvider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;HMAC&quot;;
        this.hashAlgorithms = [&quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;];
        this.usages = [&quot;sign&quot;, &quot;verify&quot;];
    }
    getDefaultLength(algName) {
        switch (algName.toUpperCase()) {
            case &quot;SHA-1&quot;:
            case &quot;SHA-256&quot;:
            case &quot;SHA-384&quot;:
            case &quot;SHA-512&quot;:
                return 512;
            default:
                throw new Error(`Unknown algorithm name &#039;${algName}&#039;`);
        }
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        if (&quot;length&quot; in algorithm) {
            if (typeof algorithm.length !== &quot;number&quot;) {
                throw new TypeError(&quot;length: Is not a Number&quot;);
            }
            if (algorithm.length &lt; 1) {
                throw new RangeError(&quot;length: Number is out of range&quot;);
            }
        }
    }
    checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
    }
}

class Pbkdf2Provider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;PBKDF2&quot;;
        this.hashAlgorithms = [&quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;];
        this.usages = [&quot;deriveBits&quot;, &quot;deriveKey&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, &quot;salt&quot;);
        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {
            throw new TypeError(&quot;salt: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
        this.checkRequiredProperty(algorithm, &quot;iterations&quot;);
        if (typeof algorithm.iterations !== &quot;number&quot;) {
            throw new TypeError(&quot;iterations: Is not a Number&quot;);
        }
        if (algorithm.iterations &lt; 1) {
            throw new TypeError(&quot;iterations: Is less than 1&quot;);
        }
    }
    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args);
        if (extractable) {
            throw new SyntaxError(&quot;extractable: Must be &#039;false&#039;&quot;);
        }
    }
}

class HkdfProvider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.name = &quot;HKDF&quot;;
        this.hashAlgorithms = [&quot;SHA-1&quot;, &quot;SHA-256&quot;, &quot;SHA-384&quot;, &quot;SHA-512&quot;];
        this.usages = [&quot;deriveKey&quot;, &quot;deriveBits&quot;];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, &quot;hash&quot;);
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, &quot;salt&quot;);
        if (!BufferSourceConverter.isBufferSource(algorithm.salt)) {
            throw new TypeError(&quot;salt: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
        this.checkRequiredProperty(algorithm, &quot;info&quot;);
        if (!BufferSourceConverter.isBufferSource(algorithm.info)) {
            throw new TypeError(&quot;salt: Is not of type &#039;(ArrayBuffer or ArrayBufferView)&#039;&quot;);
        }
    }
    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args);
        if (extractable) {
            throw new SyntaxError(&quot;extractable: Must be &#039;false&#039;&quot;);
        }
    }
}

class ShakeProvider extends ProviderCrypto {
    constructor() {
        super(...arguments);
        this.usages = [];
        this.defaultLength = 0;
    }
    digest(...args) {
        args[0] = { length: this.defaultLength, ...args[0] };
        return super.digest.apply(this, args);
    }
    checkDigest(algorithm, data) {
        super.checkDigest(algorithm, data);
        const length = algorithm.length || 0;
        if (typeof length !== &quot;number&quot;) {
            throw new TypeError(&quot;length: Is not a Number&quot;);
        }
        if (length &lt; 0) {
            throw new TypeError(&quot;length: Is negative&quot;);
        }
    }
}

class Shake128Provider extends ShakeProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;shake128&quot;;
        this.defaultLength = 16;
    }
}

class Shake256Provider extends ShakeProvider {
    constructor() {
        super(...arguments);
        this.name = &quot;shake256&quot;;
        this.defaultLength = 32;
    }
}

class Crypto {
    get [Symbol.toStringTag]() {
        return &quot;Crypto&quot;;
    }
    randomUUID() {
        const b = this.getRandomValues(new Uint8Array(16));
        b[6] = (b[6] &amp; 0x0f) | 0x40;
        b[8] = (b[8] &amp; 0x3f) | 0x80;
        const uuid = Convert.ToHex(b).toLowerCase();
        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;
    }
}

class ProviderStorage {
    constructor() {
        this.items = {};
    }
    get(algorithmName) {
        return this.items[algorithmName.toLowerCase()] || null;
    }
    set(provider) {
        this.items[provider.name.toLowerCase()] = provider;
    }
    removeAt(algorithmName) {
        const provider = this.get(algorithmName.toLowerCase());
        if (provider) {
            delete this.items[algorithmName];
        }
        return provider;
    }
    has(name) {
        return !!this.get(name);
    }
    get length() {
        return Object.keys(this.items).length;
    }
    get algorithms() {
        const algorithms = [];
        for (const key in this.items) {
            const provider = this.items[key];
            algorithms.push(provider.name);
        }
        return algorithms.sort();
    }
}

const keyFormatMap = {
    &quot;jwk&quot;: [&quot;private&quot;, &quot;public&quot;, &quot;secret&quot;],
    &quot;pkcs8&quot;: [&quot;private&quot;],
    &quot;spki&quot;: [&quot;public&quot;],
    &quot;raw&quot;: [&quot;secret&quot;, &quot;public&quot;]
};
const sourceBufferKeyFormats = [&quot;pkcs8&quot;, &quot;spki&quot;, &quot;raw&quot;];
class SubtleCrypto {
    constructor() {
        this.providers = new ProviderStorage();
    }
    static isHashedAlgorithm(data) {
        return data
            &amp;&amp; typeof data === &quot;object&quot;
            &amp;&amp; &quot;name&quot; in data
            &amp;&amp; &quot;hash&quot; in data
            ? true
            : false;
    }
    get [Symbol.toStringTag]() {
        return &quot;SubtleCrypto&quot;;
    }
    async digest(...args) {
        this.checkRequiredArguments(args, 2, &quot;digest&quot;);
        const [algorithm, data, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);
        return result;
    }
    async generateKey(...args) {
        this.checkRequiredArguments(args, 3, &quot;generateKey&quot;);
        const [algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.generateKey({ ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
        return result;
    }
    async sign(...args) {
        this.checkRequiredArguments(args, 3, &quot;sign&quot;);
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.sign({ ...preparedAlgorithm, name: provider.name }, key, preparedData, ...params);
        return result;
    }
    async verify(...args) {
        this.checkRequiredArguments(args, 4, &quot;verify&quot;);
        const [algorithm, key, signature, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const preparedSignature = BufferSourceConverter.toArrayBuffer(signature);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.verify({ ...preparedAlgorithm, name: provider.name }, key, preparedSignature, preparedData, ...params);
        return result;
    }
    async encrypt(...args) {
        this.checkRequiredArguments(args, 3, &quot;encrypt&quot;);
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.encrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);
        return result;
    }
    async decrypt(...args) {
        this.checkRequiredArguments(args, 3, &quot;decrypt&quot;);
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);
        return result;
    }
    async deriveBits(...args) {
        this.checkRequiredArguments(args, 3, &quot;deriveBits&quot;);
        const [algorithm, baseKey, length, ...params] = args;
        this.checkCryptoKey(baseKey);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, length, { keyUsage: true }, ...params);
        return result;
    }
    async deriveKey(...args) {
        this.checkRequiredArguments(args, 5, &quot;deriveKey&quot;);
        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;
        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);
        const importProvider = this.getProvider(preparedDerivedKeyType.name);
        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        provider.checkCryptoKey(baseKey, &quot;deriveKey&quot;);
        const derivedBits = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, derivedKeyType.length || 512, { keyUsage: false }, ...params);
        return this.importKey(&quot;raw&quot;, derivedBits, derivedKeyType, extractable, keyUsages, ...params);
    }
    async exportKey(...args) {
        this.checkRequiredArguments(args, 2, &quot;exportKey&quot;);
        const [format, key, ...params] = args;
        this.checkCryptoKey(key);
        if (!keyFormatMap[format]) {
            throw new TypeError(&quot;Invalid keyFormat argument&quot;);
        }
        if (!keyFormatMap[format].includes(key.type)) {
            throw new DOMException(&quot;The key is not of the expected type&quot;);
        }
        const provider = this.getProvider(key.algorithm.name);
        const result = await provider.exportKey(format, key, ...params);
        return result;
    }
    async importKey(...args) {
        this.checkRequiredArguments(args, 5, &quot;importKey&quot;);
        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        if (format === &quot;jwk&quot;) {
            if (typeof keyData !== &quot;object&quot; || !keyData.kty) {
                throw new TypeError(&quot;Key data must be an object for JWK import&quot;);
            }
        }
        else if (sourceBufferKeyFormats.includes(format)) {
            if (!BufferSourceConverter.isBufferSource(keyData)) {
                throw new TypeError(&quot;Key data must be a BufferSource for non-JWK formats&quot;);
            }
        }
        else {
            throw new TypeError(&quot;The provided value is not of type &#039;(ArrayBuffer or ArrayBufferView or JsonWebKey)&#039;&quot;);
        }
        return provider.importKey(format, keyData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
    }
    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {
        let keyData = await this.exportKey(format, key, ...args);
        if (format === &quot;jwk&quot;) {
            const json = JSON.stringify(keyData);
            keyData = Convert.FromUtf8String(json);
        }
        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(keyData);
        const provider = this.getProvider(preparedAlgorithm.name);
        return provider.encrypt({ ...preparedAlgorithm, name: provider.name }, wrappingKey, preparedData, { keyUsage: false }, ...args);
    }
    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {
        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(wrappedKey);
        const provider = this.getProvider(preparedAlgorithm.name);
        let keyData = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, unwrappingKey, preparedData, { keyUsage: false }, ...args);
        if (format === &quot;jwk&quot;) {
            try {
                keyData = JSON.parse(Convert.ToUtf8String(keyData));
            }
            catch (e) {
                const error = new TypeError(&quot;wrappedKey: Is not a JSON&quot;);
                error.internal = e;
                throw error;
            }
        }
        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);
    }
    checkRequiredArguments(args, size, methodName) {
        if (args.length &lt; size) {
            throw new TypeError(`Failed to execute &#039;${methodName}&#039; on &#039;SubtleCrypto&#039;: ${size} arguments required, but only ${args.length} present`);
        }
    }
    prepareAlgorithm(algorithm) {
        if (typeof algorithm === &quot;string&quot;) {
            return {
                name: algorithm,
            };
        }
        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {
            const preparedAlgorithm = { ...algorithm };
            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);
            return preparedAlgorithm;
        }
        return { ...algorithm };
    }
    getProvider(name) {
        const provider = this.providers.get(name);
        if (!provider) {
            throw new AlgorithmError(&quot;Unrecognized name&quot;);
        }
        return provider;
    }
    checkCryptoKey(key) {
        if (!(key instanceof CryptoKey)) {
            throw new TypeError(`Key is not of type &#039;CryptoKey&#039;`);
        }
    }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  converters: index$3
});

const REQUIRED_FIELDS = [&quot;crv&quot;, &quot;e&quot;, &quot;k&quot;, &quot;kty&quot;, &quot;n&quot;, &quot;x&quot;, &quot;y&quot;];
class JwkUtils {
    static async thumbprint(hash, jwk, crypto) {
        const data = this.format(jwk, true);
        return crypto.subtle.digest(hash, Convert.FromBinary(JSON.stringify(data)));
    }
    static format(jwk, remove = false) {
        let res = Object.entries(jwk);
        if (remove) {
            res = res.filter(o =&gt; REQUIRED_FIELDS.includes(o[0]));
        }
        res = res.sort(([keyA], [keyB]) =&gt; keyA &gt; keyB ? 1 : keyA &lt; keyB ? -1 : 0);
        return Object.fromEntries(res);
    }
}

export { AesCbcProvider, AesCmacProvider, AesCtrProvider, AesEcbProvider, AesGcmProvider, AesKwProvider, AesProvider, AlgorithmError, Crypto, CryptoError, CryptoKey, DesProvider, EcCurves, EcUtils, EcdhEsProvider, EcdhProvider, EcdsaProvider, Ed25519Provider, EdDsaProvider, EllipticProvider, HkdfProvider, HmacProvider, JwkUtils, OperationError, Pbkdf2Provider, PemConverter, ProviderCrypto, ProviderStorage, RequiredPropertyError, RsaOaepProvider, RsaProvider, RsaPssProvider, RsaSsaProvider, Shake128Provider, Shake256Provider, ShakeProvider, SubtleCrypto, UnsupportedOperationError, X25519Provider, index$1 as asn1, isJWK, index as json };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
