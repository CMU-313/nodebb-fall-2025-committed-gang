<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/socket.io/dist/namespace.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/socket.io/dist/namespace.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">76.87</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">582</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">50.49</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.05</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &quot;default&quot;: mod };
};
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.Namespace = exports.RESERVED_EVENTS = void 0;
const socket_1 = require(&quot;./socket&quot;);
const typed_events_1 = require(&quot;./typed-events&quot;);
const debug_1 = __importDefault(require(&quot;debug&quot;));
const broadcast_operator_1 = require(&quot;./broadcast-operator&quot;);
const debug = (0, debug_1.default)(&quot;socket.io:namespace&quot;);
exports.RESERVED_EVENTS = new Set([&quot;connect&quot;, &quot;connection&quot;, &quot;new_namespace&quot;]);
/**
 * A Namespace is a communication channel that allows you to split the logic of your application over a single shared
 * connection.
 *
 * Each namespace has its own:
 *
 * - event handlers
 *
 * ```
 * io.of(&quot;/orders&quot;).on(&quot;connection&quot;, (socket) =&gt; {
 *   socket.on(&quot;order:list&quot;, () =&gt; {});
 *   socket.on(&quot;order:create&quot;, () =&gt; {});
 * });
 *
 * io.of(&quot;/users&quot;).on(&quot;connection&quot;, (socket) =&gt; {
 *   socket.on(&quot;user:list&quot;, () =&gt; {});
 * });
 * ```
 *
 * - rooms
 *
 * ```
 * const orderNamespace = io.of(&quot;/orders&quot;);
 *
 * orderNamespace.on(&quot;connection&quot;, (socket) =&gt; {
 *   socket.join(&quot;room1&quot;);
 *   orderNamespace.to(&quot;room1&quot;).emit(&quot;hello&quot;);
 * });
 *
 * const userNamespace = io.of(&quot;/users&quot;);
 *
 * userNamespace.on(&quot;connection&quot;, (socket) =&gt; {
 *   socket.join(&quot;room1&quot;); // distinct from the room in the &quot;orders&quot; namespace
 *   userNamespace.to(&quot;room1&quot;).emit(&quot;holà&quot;);
 * });
 * ```
 *
 * - middlewares
 *
 * ```
 * const orderNamespace = io.of(&quot;/orders&quot;);
 *
 * orderNamespace.use((socket, next) =&gt; {
 *   // ensure the socket has access to the &quot;orders&quot; namespace
 * });
 *
 * const userNamespace = io.of(&quot;/users&quot;);
 *
 * userNamespace.use((socket, next) =&gt; {
 *   // ensure the socket has access to the &quot;users&quot; namespace
 * });
 * ```
 */
class Namespace extends typed_events_1.StrictEventEmitter {
    /**
     * Namespace constructor.
     *
     * @param server instance
     * @param name
     */
    constructor(server, name) {
        super();
        /**
         * A map of currently connected sockets.
         */
        this.sockets = new Map();
        /**
         * A map of currently connecting sockets.
         */
        this._preConnectSockets = new Map();
        this._fns = [];
        /** @private */
        this._ids = 0;
        this.server = server;
        this.name = name;
        this._initAdapter();
    }
    /**
     * Initializes the `Adapter` for this nsp.
     * Run upon changing adapter by `Server#adapter`
     * in addition to the constructor.
     *
     * @private
     */
    _initAdapter() {
        // @ts-ignore
        this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.use((socket, next) =&gt; {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn) {
        this._fns.push(fn);
        return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */
    run(socket, fn) {
        if (!this._fns.length)
            return fn();
        const fns = this._fns.slice(0);
        function run(i) {
            fns[i](socket, (err) =&gt; {
                // upon error, short-circuit
                if (err)
                    return fn(err);
                // if no middleware left, summon callback
                if (!fns[i + 1])
                    return fn();
                // go on to next
                run(i + 1);
            });
        }
        run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // the “foo” event will be broadcast to all connected clients in the “room-101” room
     * myNamespace.to(&quot;room-101&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with an array of rooms (a client will be notified at most once)
     * myNamespace.to([&quot;room-101&quot;, &quot;room-102&quot;]).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with multiple chained calls
     * myNamespace.to(&quot;room-101&quot;).to(&quot;room-102&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // disconnect all clients in the &quot;room-101&quot; room
     * myNamespace.in(&quot;room-101&quot;).disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // the &quot;foo&quot; event will be broadcast to all connected clients, except the ones that are in the &quot;room-101&quot; room
     * myNamespace.except(&quot;room-101&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with an array of rooms
     * myNamespace.except([&quot;room-101&quot;, &quot;room-102&quot;]).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * // with multiple chained calls
     * myNamespace.except(&quot;room-101&quot;).except(&quot;room-102&quot;).emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */
    async _add(client, auth, fn) {
        var _a;
        debug(&quot;adding socket to nsp %s&quot;, this.name);
        const socket = await this._createSocket(client, auth);
        this._preConnectSockets.set(socket.id, socket);
        if (
        // @ts-ignore
        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) &amp;&amp;
            socket.recovered &amp;&amp;
            client.conn.readyState === &quot;open&quot;) {
            return this._doConnect(socket, fn);
        }
        this.run(socket, (err) =&gt; {
            process.nextTick(() =&gt; {
                if (&quot;open&quot; !== client.conn.readyState) {
                    debug(&quot;next called after client was closed - ignoring socket&quot;);
                    socket._cleanup();
                    return;
                }
                if (err) {
                    debug(&quot;middleware error, sending CONNECT_ERROR packet to the client&quot;);
                    socket._cleanup();
                    if (client.conn.protocol === 3) {
                        return socket._error(err.data || err.message);
                    }
                    else {
                        return socket._error({
                            message: err.message,
                            data: err.data,
                        });
                    }
                }
                this._doConnect(socket, fn);
            });
        });
    }
    async _createSocket(client, auth) {
        const sessionId = auth.pid;
        const offset = auth.offset;
        if (
        // @ts-ignore
        this.server.opts.connectionStateRecovery &amp;&amp;
            typeof sessionId === &quot;string&quot; &amp;&amp;
            typeof offset === &quot;string&quot;) {
            let session;
            try {
                session = await this.adapter.restoreSession(sessionId, offset);
            }
            catch (e) {
                debug(&quot;error while restoring session: %s&quot;, e);
            }
            if (session) {
                debug(&quot;connection state recovered for sid %s&quot;, session.sid);
                return new socket_1.Socket(this, client, auth, session);
            }
        }
        return new socket_1.Socket(this, client, auth);
    }
    _doConnect(socket, fn) {
        this._preConnectSockets.delete(socket.id);
        this.sockets.set(socket.id, socket);
        // it&#039;s paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket._onconnect();
        if (fn)
            fn(socket);
        // fire user-set events
        this.emitReserved(&quot;connect&quot;, socket);
        this.emitReserved(&quot;connection&quot;, socket);
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */
    _remove(socket) {
        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);
    }
    /**
     * Emits to all connected clients.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.emit(&quot;hello&quot;, &quot;world&quot;);
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * myNamespace.emit(&quot;hello&quot;, 1, &quot;2&quot;, { 3: [&quot;4&quot;], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the clients
     * myNamespace.timeout(1000).emit(&quot;some-event&quot;, (err, responses) =&gt; {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */
    emit(ev, ...args) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.send(&quot;hello&quot;);
     *
     * // this is equivalent to
     * myNamespace.emit(&quot;message&quot;, &quot;hello&quot;);
     *
     * @return self
     */
    send(...args) {
        // This type-cast is needed because EmitEvents likely doesn&#039;t have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.emit(&quot;message&quot;, ...args);
        return this;
    }
    /**
     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
        // This type-cast is needed because EmitEvents likely doesn&#039;t have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.emit(&quot;message&quot;, ...args);
        return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.serverSideEmit(&quot;hello&quot;, &quot;world&quot;);
     *
     * myNamespace.on(&quot;hello&quot;, (arg1) =&gt; {
     *   console.log(arg1); // prints &quot;world&quot;
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * myNamespace.serverSideEmit(&quot;ping&quot;, (err, responses) =&gt; {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * myNamespace.on(&quot;ping&quot;, (cb) =&gt; {
     *   cb(&quot;pong&quot;);
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
            throw new Error(`&quot;${String(ev)}&quot; is a reserved event name`);
        }
        args.unshift(ev);
        this.adapter.serverSideEmit(args);
        return true;
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * try {
     *   const responses = await myNamespace.serverSideEmitWithAck(&quot;ping&quot;);
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck(ev, ...args) {
        return new Promise((resolve, reject) =&gt; {
            args.push((err, responses) =&gt; {
                if (err) {
                    err.responses = responses;
                    return reject(err);
                }
                else {
                    return resolve(responses);
                }
            });
            this.serverSideEmit(ev, ...args);
        });
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */
    _onServerSideEmit(args) {
        super.emitUntyped.apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or
     * {@link Namespace#fetchSockets} instead.
     */
    allSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.compress(false).emit(&quot;hello&quot;);
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.volatile.emit(&quot;hello&quot;); // the clients may or may not receive it
     *
     * @return self
     */
    get volatile() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // the “foo” event will be broadcast to all connected clients on this node
     * myNamespace.local.emit(&quot;foo&quot;, &quot;bar&quot;);
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * myNamespace.timeout(1000).emit(&quot;some-event&quot;, (err, responses) =&gt; {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // return all Socket instances
     * const sockets = await myNamespace.fetchSockets();
     *
     * // return all Socket instances in the &quot;room1&quot; room
     * const sockets = await myNamespace.in(&quot;room1&quot;).fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit(&quot;hello&quot;);
     *   socket.join(&quot;room1&quot;);
     *   socket.leave(&quot;room2&quot;);
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // make all socket instances join the &quot;room1&quot; room
     * myNamespace.socketsJoin(&quot;room1&quot;);
     *
     * // make all socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms
     * myNamespace.in(&quot;room1&quot;).socketsJoin([&quot;room2&quot;, &quot;room3&quot;]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // make all socket instances leave the &quot;room1&quot; room
     * myNamespace.socketsLeave(&quot;room1&quot;);
     *
     * // make all socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms
     * myNamespace.in(&quot;room1&quot;).socketsLeave([&quot;room2&quot;, &quot;room3&quot;]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of(&quot;/my-namespace&quot;);
     *
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * myNamespace.disconnectSockets();
     *
     * // make all socket instances in the &quot;room1&quot; room disconnect and close the underlying connections
     * myNamespace.in(&quot;room1&quot;).disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
}
exports.Namespace = Namespace;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
