<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sshpk/lib/formats/dnssec.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sshpk/lib/formats/dnssec.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">288</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">47.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2017 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = require(&#039;assert-plus&#039;);
var Buffer = require(&#039;safer-buffer&#039;).Buffer;
var Key = require(&#039;../key&#039;);
var PrivateKey = require(&#039;../private-key&#039;);
var utils = require(&#039;../utils&#039;);
var SSHBuffer = require(&#039;../ssh-buffer&#039;);
var Dhe = require(&#039;../dhe&#039;);

var supportedAlgos = {
	&#039;rsa-sha1&#039; : 5,
	&#039;rsa-sha256&#039; : 8,
	&#039;rsa-sha512&#039; : 10,
	&#039;ecdsa-p256-sha256&#039; : 13,
	&#039;ecdsa-p384-sha384&#039; : 14
	/*
	 * ed25519 is hypothetically supported with id 15
	 * but the common tools available don&#039;t appear to be
	 * capable of generating/using ed25519 keys
	 */
};

var supportedAlgosById = {};
Object.keys(supportedAlgos).forEach(function (k) {
	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
});

function read(buf, options) {
	if (typeof (buf) !== &#039;string&#039;) {
		assert.buffer(buf, &#039;buf&#039;);
		buf = buf.toString(&#039;ascii&#039;);
	}
	var lines = buf.split(&#039;\n&#039;);
	if (lines[0].match(/^Private-key-format\: v1/)) {
		var algElems = lines[1].split(&#039; &#039;);
		var algoNum = parseInt(algElems[1], 10);
		var algoName = algElems[2];
		if (!supportedAlgosById[algoNum])
			throw (new Error(&#039;Unsupported algorithm: &#039; + algoName));
		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
	}

	// skip any comment-lines
	var line = 0;
	/* JSSTYLED */
	while (lines[line].match(/^\;/))
		line++;
	// we should now have *one single* line left with our KEY on it.
	if ((lines[line].match(/\. IN KEY /) ||
	    lines[line].match(/\. IN DNSKEY /)) &amp;&amp; lines[line+1].length === 0) {
		return (readRFC3110(lines[line]));
	}
	throw (new Error(&#039;Cannot parse dnssec key&#039;));
}

function readRFC3110(keyString) {
	var elems = keyString.split(&#039; &#039;);
	//unused var flags = parseInt(elems[3], 10);
	//unused var protocol = parseInt(elems[4], 10);
	var algorithm = parseInt(elems[5], 10);
	if (!supportedAlgosById[algorithm])
		throw (new Error(&#039;Unsupported algorithm: &#039; + algorithm));
	var base64key = elems.slice(6, elems.length).join();
	var keyBuffer = Buffer.from(base64key, &#039;base64&#039;);
	if (supportedAlgosById[algorithm].match(/^RSA-/)) {
		// join the rest of the body into a single base64-blob
		var publicExponentLen = keyBuffer.readUInt8(0);
		if (publicExponentLen != 3 &amp;&amp; publicExponentLen != 1)
			throw (new Error(&#039;Cannot parse dnssec key: &#039; +
			    &#039;unsupported exponent length&#039;));

		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
		publicExponent = utils.mpNormalize(publicExponent);
		var modulus = keyBuffer.slice(1+publicExponentLen);
		modulus = utils.mpNormalize(modulus);
		// now, make the key
		var rsaKey = {
			type: &#039;rsa&#039;,
			parts: []
		};
		rsaKey.parts.push({ name: &#039;e&#039;, data: publicExponent});
		rsaKey.parts.push({ name: &#039;n&#039;, data: modulus});
		return (new Key(rsaKey));
	}
	if (supportedAlgosById[algorithm] === &#039;ECDSA-P384-SHA384&#039; ||
	    supportedAlgosById[algorithm] === &#039;ECDSA-P256-SHA256&#039;) {
		var curve = &#039;nistp384&#039;;
		var size = 384;
		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
			curve = &#039;nistp256&#039;;
			size = 256;
		}

		var ecdsaKey = {
			type: &#039;ecdsa&#039;,
			curve: curve,
			size: size,
			parts: [
				{name: &#039;curve&#039;, data: Buffer.from(curve) },
				{name: &#039;Q&#039;, data: utils.ecNormalize(keyBuffer) }
			]
		};
		return (new Key(ecdsaKey));
	}
	throw (new Error(&#039;Unsupported algorithm: &#039; +
	    supportedAlgosById[algorithm]));
}

function elementToBuf(e) {
	return (Buffer.from(e.split(&#039; &#039;)[1], &#039;base64&#039;));
}

function readDNSSECRSAPrivateKey(elements) {
	var rsaParams = {};
	elements.forEach(function (element) {
		if (element.split(&#039; &#039;)[0] === &#039;Modulus:&#039;)
			rsaParams[&#039;n&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;PublicExponent:&#039;)
			rsaParams[&#039;e&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;PrivateExponent:&#039;)
			rsaParams[&#039;d&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;Prime1:&#039;)
			rsaParams[&#039;p&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;Prime2:&#039;)
			rsaParams[&#039;q&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;Exponent1:&#039;)
			rsaParams[&#039;dmodp&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;Exponent2:&#039;)
			rsaParams[&#039;dmodq&#039;] = elementToBuf(element);
		else if (element.split(&#039; &#039;)[0] === &#039;Coefficient:&#039;)
			rsaParams[&#039;iqmp&#039;] = elementToBuf(element);
	});
	// now, make the key
	var key = {
		type: &#039;rsa&#039;,
		parts: [
			{ name: &#039;e&#039;, data: utils.mpNormalize(rsaParams[&#039;e&#039;])},
			{ name: &#039;n&#039;, data: utils.mpNormalize(rsaParams[&#039;n&#039;])},
			{ name: &#039;d&#039;, data: utils.mpNormalize(rsaParams[&#039;d&#039;])},
			{ name: &#039;p&#039;, data: utils.mpNormalize(rsaParams[&#039;p&#039;])},
			{ name: &#039;q&#039;, data: utils.mpNormalize(rsaParams[&#039;q&#039;])},
			{ name: &#039;dmodp&#039;,
			    data: utils.mpNormalize(rsaParams[&#039;dmodp&#039;])},
			{ name: &#039;dmodq&#039;,
			    data: utils.mpNormalize(rsaParams[&#039;dmodq&#039;])},
			{ name: &#039;iqmp&#039;,
			    data: utils.mpNormalize(rsaParams[&#039;iqmp&#039;])}
		]
	};
	return (new PrivateKey(key));
}

function readDNSSECPrivateKey(alg, elements) {
	if (supportedAlgosById[alg].match(/^RSA-/)) {
		return (readDNSSECRSAPrivateKey(elements));
	}
	if (supportedAlgosById[alg] === &#039;ECDSA-P384-SHA384&#039; ||
	    supportedAlgosById[alg] === &#039;ECDSA-P256-SHA256&#039;) {
		var d = Buffer.from(elements[0].split(&#039; &#039;)[1], &#039;base64&#039;);
		var curve = &#039;nistp384&#039;;
		var size = 384;
		if (supportedAlgosById[alg] === &#039;ECDSA-P256-SHA256&#039;) {
			curve = &#039;nistp256&#039;;
			size = 256;
		}
		// DNSSEC generates the public-key on the fly (go calculate it)
		var publicKey = utils.publicFromPrivateECDSA(curve, d);
		var Q = publicKey.part[&#039;Q&#039;].data;
		var ecdsaKey = {
			type: &#039;ecdsa&#039;,
			curve: curve,
			size: size,
			parts: [
				{name: &#039;curve&#039;, data: Buffer.from(curve) },
				{name: &#039;d&#039;, data: d },
				{name: &#039;Q&#039;, data: Q }
			]
		};
		return (new PrivateKey(ecdsaKey));
	}
	throw (new Error(&#039;Unsupported algorithm: &#039; + supportedAlgosById[alg]));
}

function dnssecTimestamp(date) {
	var year = date.getFullYear() + &#039;&#039;; //stringify
	var month = (date.getMonth() + 1);
	var timestampStr = year + month + date.getUTCDate();
	timestampStr += &#039;&#039; + date.getUTCHours() + date.getUTCMinutes();
	timestampStr += date.getUTCSeconds();
	return (timestampStr);
}

function rsaAlgFromOptions(opts) {
	if (!opts || !opts.hashAlgo || opts.hashAlgo === &#039;sha1&#039;)
		return (&#039;5 (RSASHA1)&#039;);
	else if (opts.hashAlgo === &#039;sha256&#039;)
		return (&#039;8 (RSASHA256)&#039;);
	else if (opts.hashAlgo === &#039;sha512&#039;)
		return (&#039;10 (RSASHA512)&#039;);
	else
		throw (new Error(&#039;Unknown or unsupported hash: &#039; +
		    opts.hashAlgo));
}

function writeRSA(key, options) {
	// if we&#039;re missing parts, add them.
	if (!key.part.dmodp || !key.part.dmodq) {
		utils.addRSAMissing(key);
	}

	var out = &#039;&#039;;
	out += &#039;Private-key-format: v1.3\n&#039;;
	out += &#039;Algorithm: &#039; + rsaAlgFromOptions(options) + &#039;\n&#039;;
	var n = utils.mpDenormalize(key.part[&#039;n&#039;].data);
	out += &#039;Modulus: &#039; + n.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var e = utils.mpDenormalize(key.part[&#039;e&#039;].data);
	out += &#039;PublicExponent: &#039; + e.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var d = utils.mpDenormalize(key.part[&#039;d&#039;].data);
	out += &#039;PrivateExponent: &#039; + d.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var p = utils.mpDenormalize(key.part[&#039;p&#039;].data);
	out += &#039;Prime1: &#039; + p.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var q = utils.mpDenormalize(key.part[&#039;q&#039;].data);
	out += &#039;Prime2: &#039; + q.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var dmodp = utils.mpDenormalize(key.part[&#039;dmodp&#039;].data);
	out += &#039;Exponent1: &#039; + dmodp.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var dmodq = utils.mpDenormalize(key.part[&#039;dmodq&#039;].data);
	out += &#039;Exponent2: &#039; + dmodq.toString(&#039;base64&#039;) + &#039;\n&#039;;
	var iqmp = utils.mpDenormalize(key.part[&#039;iqmp&#039;].data);
	out += &#039;Coefficient: &#039; + iqmp.toString(&#039;base64&#039;) + &#039;\n&#039;;
	// Assume that we&#039;re valid as-of now
	var timestamp = new Date();
	out += &#039;Created: &#039; + dnssecTimestamp(timestamp) + &#039;\n&#039;;
	out += &#039;Publish: &#039; + dnssecTimestamp(timestamp) + &#039;\n&#039;;
	out += &#039;Activate: &#039; + dnssecTimestamp(timestamp) + &#039;\n&#039;;
	return (Buffer.from(out, &#039;ascii&#039;));
}

function writeECDSA(key, options) {
	var out = &#039;&#039;;
	out += &#039;Private-key-format: v1.3\n&#039;;

	if (key.curve === &#039;nistp256&#039;) {
		out += &#039;Algorithm: 13 (ECDSAP256SHA256)\n&#039;;
	} else if (key.curve === &#039;nistp384&#039;) {
		out += &#039;Algorithm: 14 (ECDSAP384SHA384)\n&#039;;
	} else {
		throw (new Error(&#039;Unsupported curve&#039;));
	}
	var base64Key = key.part[&#039;d&#039;].data.toString(&#039;base64&#039;);
	out += &#039;PrivateKey: &#039; + base64Key + &#039;\n&#039;;

	// Assume that we&#039;re valid as-of now
	var timestamp = new Date();
	out += &#039;Created: &#039; + dnssecTimestamp(timestamp) + &#039;\n&#039;;
	out += &#039;Publish: &#039; + dnssecTimestamp(timestamp) + &#039;\n&#039;;
	out += &#039;Activate: &#039; + dnssecTimestamp(timestamp) + &#039;\n&#039;;

	return (Buffer.from(out, &#039;ascii&#039;));
}

function write(key, options) {
	if (PrivateKey.isPrivateKey(key)) {
		if (key.type === &#039;rsa&#039;) {
			return (writeRSA(key, options));
		} else if (key.type === &#039;ecdsa&#039;) {
			return (writeECDSA(key, options));
		} else {
			throw (new Error(&#039;Unsupported algorithm: &#039; + key.type));
		}
	} else if (Key.isKey(key)) {
		/*
		 * RFC3110 requires a keyname, and a keytype, which we
		 * don&#039;t really have a mechanism for specifying such
		 * additional metadata.
		 */
		throw (new Error(&#039;Format &quot;dnssec&quot; only supports &#039; +
		    &#039;writing private keys&#039;));
	} else {
		throw (new Error(&#039;key is not a Key or PrivateKey&#039;));
	}
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
