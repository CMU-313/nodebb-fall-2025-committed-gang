<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sshpk/lib/certificate.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sshpk/lib/certificate.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">411</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2016 Joyent, Inc.

module.exports = Certificate;

var assert = require(&#039;assert-plus&#039;);
var Buffer = require(&#039;safer-buffer&#039;).Buffer;
var algs = require(&#039;./algs&#039;);
var crypto = require(&#039;crypto&#039;);
var Fingerprint = require(&#039;./fingerprint&#039;);
var Signature = require(&#039;./signature&#039;);
var errs = require(&#039;./errors&#039;);
var util = require(&#039;util&#039;);
var utils = require(&#039;./utils&#039;);
var Key = require(&#039;./key&#039;);
var PrivateKey = require(&#039;./private-key&#039;);
var Identity = require(&#039;./identity&#039;);

var formats = {};
formats[&#039;openssh&#039;] = require(&#039;./formats/openssh-cert&#039;);
formats[&#039;x509&#039;] = require(&#039;./formats/x509&#039;);
formats[&#039;pem&#039;] = require(&#039;./formats/x509-pem&#039;);

var CertificateParseError = errs.CertificateParseError;
var InvalidAlgorithmError = errs.InvalidAlgorithmError;

function Certificate(opts) {
	assert.object(opts, &#039;options&#039;);
	assert.arrayOfObject(opts.subjects, &#039;options.subjects&#039;);
	utils.assertCompatible(opts.subjects[0], Identity, [1, 0],
	    &#039;options.subjects&#039;);
	utils.assertCompatible(opts.subjectKey, Key, [1, 0],
	    &#039;options.subjectKey&#039;);
	utils.assertCompatible(opts.issuer, Identity, [1, 0], &#039;options.issuer&#039;);
	if (opts.issuerKey !== undefined) {
		utils.assertCompatible(opts.issuerKey, Key, [1, 0],
		    &#039;options.issuerKey&#039;);
	}
	assert.object(opts.signatures, &#039;options.signatures&#039;);
	assert.buffer(opts.serial, &#039;options.serial&#039;);
	assert.date(opts.validFrom, &#039;options.validFrom&#039;);
	assert.date(opts.validUntil, &#039;optons.validUntil&#039;);

	assert.optionalArrayOfString(opts.purposes, &#039;options.purposes&#039;);

	this._hashCache = {};

	this.subjects = opts.subjects;
	this.issuer = opts.issuer;
	this.subjectKey = opts.subjectKey;
	this.issuerKey = opts.issuerKey;
	this.signatures = opts.signatures;
	this.serial = opts.serial;
	this.validFrom = opts.validFrom;
	this.validUntil = opts.validUntil;
	this.purposes = opts.purposes;
}

Certificate.formats = formats;

Certificate.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = &#039;x509&#039;;
	assert.string(format, &#039;format&#039;);
	assert.object(formats[format], &#039;formats[format]&#039;);
	assert.optionalObject(options, &#039;options&#039;);

	return (formats[format].write(this, options));
};

Certificate.prototype.toString = function (format, options) {
	if (format === undefined)
		format = &#039;pem&#039;;
	return (this.toBuffer(format, options).toString());
};

Certificate.prototype.fingerprint = function (algo) {
	if (algo === undefined)
		algo = &#039;sha256&#039;;
	assert.string(algo, &#039;algorithm&#039;);
	var opts = {
		type: &#039;certificate&#039;,
		hash: this.hash(algo),
		algorithm: algo
	};
	return (new Fingerprint(opts));
};

Certificate.prototype.hash = function (algo) {
	assert.string(algo, &#039;algorithm&#039;);
	algo = algo.toLowerCase();
	if (algs.hashAlgs[algo] === undefined)
		throw (new InvalidAlgorithmError(algo));

	if (this._hashCache[algo])
		return (this._hashCache[algo]);

	var hash = crypto.createHash(algo).
	    update(this.toBuffer(&#039;x509&#039;)).digest();
	this._hashCache[algo] = hash;
	return (hash);
};

Certificate.prototype.isExpired = function (when) {
	if (when === undefined)
		when = new Date();
	return (!((when.getTime() &gt;= this.validFrom.getTime()) &amp;&amp;
		(when.getTime() &lt; this.validUntil.getTime())));
};

Certificate.prototype.isSignedBy = function (issuerCert) {
	utils.assertCompatible(issuerCert, Certificate, [1, 0], &#039;issuer&#039;);

	if (!this.issuer.equals(issuerCert.subjects[0]))
		return (false);
	if (this.issuer.purposes &amp;&amp; this.issuer.purposes.length &gt; 0 &amp;&amp;
	    this.issuer.purposes.indexOf(&#039;ca&#039;) === -1) {
		return (false);
	}

	return (this.isSignedByKey(issuerCert.subjectKey));
};

Certificate.prototype.getExtension = function (keyOrOid) {
	assert.string(keyOrOid, &#039;keyOrOid&#039;);
	var ext = this.getExtensions().filter(function (maybeExt) {
		if (maybeExt.format === &#039;x509&#039;)
			return (maybeExt.oid === keyOrOid);
		if (maybeExt.format === &#039;openssh&#039;)
			return (maybeExt.name === keyOrOid);
		return (false);
	})[0];
	return (ext);
};

Certificate.prototype.getExtensions = function () {
	var exts = [];
	var x509 = this.signatures.x509;
	if (x509 &amp;&amp; x509.extras &amp;&amp; x509.extras.exts) {
		x509.extras.exts.forEach(function (ext) {
			ext.format = &#039;x509&#039;;
			exts.push(ext);
		});
	}
	var openssh = this.signatures.openssh;
	if (openssh &amp;&amp; openssh.exts) {
		openssh.exts.forEach(function (ext) {
			ext.format = &#039;openssh&#039;;
			exts.push(ext);
		});
	}
	return (exts);
};

Certificate.prototype.isSignedByKey = function (issuerKey) {
	utils.assertCompatible(issuerKey, Key, [1, 2], &#039;issuerKey&#039;);

	if (this.issuerKey !== undefined) {
		return (this.issuerKey.
		    fingerprint(&#039;sha512&#039;).matches(issuerKey));
	}

	var fmt = Object.keys(this.signatures)[0];
	var valid = formats[fmt].verify(this, issuerKey);
	if (valid)
		this.issuerKey = issuerKey;
	return (valid);
};

Certificate.prototype.signWith = function (key) {
	utils.assertCompatible(key, PrivateKey, [1, 2], &#039;key&#039;);
	var fmts = Object.keys(formats);
	var didOne = false;
	for (var i = 0; i &lt; fmts.length; ++i) {
		if (fmts[i] !== &#039;pem&#039;) {
			var ret = formats[fmts[i]].sign(this, key);
			if (ret === true)
				didOne = true;
		}
	}
	if (!didOne) {
		throw (new Error(&#039;Failed to sign the certificate for any &#039; +
		    &#039;available certificate formats&#039;));
	}
};

Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
	var subjects;
	if (Array.isArray(subjectOrSubjects))
		subjects = subjectOrSubjects;
	else
		subjects = [subjectOrSubjects];

	assert.arrayOfObject(subjects);
	subjects.forEach(function (subject) {
		utils.assertCompatible(subject, Identity, [1, 0], &#039;subject&#039;);
	});

	utils.assertCompatible(key, PrivateKey, [1, 2], &#039;private key&#039;);

	assert.optionalObject(options, &#039;options&#039;);
	if (options === undefined)
		options = {};
	assert.optionalObject(options.validFrom, &#039;options.validFrom&#039;);
	assert.optionalObject(options.validUntil, &#039;options.validUntil&#039;);
	var validFrom = options.validFrom;
	var validUntil = options.validUntil;
	if (validFrom === undefined)
		validFrom = new Date();
	if (validUntil === undefined) {
		assert.optionalNumber(options.lifetime, &#039;options.lifetime&#039;);
		var lifetime = options.lifetime;
		if (lifetime === undefined)
			lifetime = 10*365*24*3600;
		validUntil = new Date();
		validUntil.setTime(validUntil.getTime() + lifetime*1000);
	}
	assert.optionalBuffer(options.serial, &#039;options.serial&#039;);
	var serial = options.serial;
	if (serial === undefined)
		serial = Buffer.from(&#039;0000000000000001&#039;, &#039;hex&#039;);

	var purposes = options.purposes;
	if (purposes === undefined)
		purposes = [];

	if (purposes.indexOf(&#039;signature&#039;) === -1)
		purposes.push(&#039;signature&#039;);

	/* Self-signed certs are always CAs. */
	if (purposes.indexOf(&#039;ca&#039;) === -1)
		purposes.push(&#039;ca&#039;);
	if (purposes.indexOf(&#039;crl&#039;) === -1)
		purposes.push(&#039;crl&#039;);

	/*
	 * If we weren&#039;t explicitly given any other purposes, do the sensible
	 * thing and add some basic ones depending on the subject type.
	 */
	if (purposes.length &lt;= 3) {
		var hostSubjects = subjects.filter(function (subject) {
			return (subject.type === &#039;host&#039;);
		});
		var userSubjects = subjects.filter(function (subject) {
			return (subject.type === &#039;user&#039;);
		});
		if (hostSubjects.length &gt; 0) {
			if (purposes.indexOf(&#039;serverAuth&#039;) === -1)
				purposes.push(&#039;serverAuth&#039;);
		}
		if (userSubjects.length &gt; 0) {
			if (purposes.indexOf(&#039;clientAuth&#039;) === -1)
				purposes.push(&#039;clientAuth&#039;);
		}
		if (userSubjects.length &gt; 0 || hostSubjects.length &gt; 0) {
			if (purposes.indexOf(&#039;keyAgreement&#039;) === -1)
				purposes.push(&#039;keyAgreement&#039;);
			if (key.type === &#039;rsa&#039; &amp;&amp;
			    purposes.indexOf(&#039;encryption&#039;) === -1)
				purposes.push(&#039;encryption&#039;);
		}
	}

	var cert = new Certificate({
		subjects: subjects,
		issuer: subjects[0],
		subjectKey: key.toPublic(),
		issuerKey: key.toPublic(),
		signatures: {},
		serial: serial,
		validFrom: validFrom,
		validUntil: validUntil,
		purposes: purposes
	});
	cert.signWith(key);

	return (cert);
};

Certificate.create =
    function (subjectOrSubjects, key, issuer, issuerKey, options) {
	var subjects;
	if (Array.isArray(subjectOrSubjects))
		subjects = subjectOrSubjects;
	else
		subjects = [subjectOrSubjects];

	assert.arrayOfObject(subjects);
	subjects.forEach(function (subject) {
		utils.assertCompatible(subject, Identity, [1, 0], &#039;subject&#039;);
	});

	utils.assertCompatible(key, Key, [1, 0], &#039;key&#039;);
	if (PrivateKey.isPrivateKey(key))
		key = key.toPublic();
	utils.assertCompatible(issuer, Identity, [1, 0], &#039;issuer&#039;);
	utils.assertCompatible(issuerKey, PrivateKey, [1, 2], &#039;issuer key&#039;);

	assert.optionalObject(options, &#039;options&#039;);
	if (options === undefined)
		options = {};
	assert.optionalObject(options.validFrom, &#039;options.validFrom&#039;);
	assert.optionalObject(options.validUntil, &#039;options.validUntil&#039;);
	var validFrom = options.validFrom;
	var validUntil = options.validUntil;
	if (validFrom === undefined)
		validFrom = new Date();
	if (validUntil === undefined) {
		assert.optionalNumber(options.lifetime, &#039;options.lifetime&#039;);
		var lifetime = options.lifetime;
		if (lifetime === undefined)
			lifetime = 10*365*24*3600;
		validUntil = new Date();
		validUntil.setTime(validUntil.getTime() + lifetime*1000);
	}
	assert.optionalBuffer(options.serial, &#039;options.serial&#039;);
	var serial = options.serial;
	if (serial === undefined)
		serial = Buffer.from(&#039;0000000000000001&#039;, &#039;hex&#039;);

	var purposes = options.purposes;
	if (purposes === undefined)
		purposes = [];

	if (purposes.indexOf(&#039;signature&#039;) === -1)
		purposes.push(&#039;signature&#039;);

	if (options.ca === true) {
		if (purposes.indexOf(&#039;ca&#039;) === -1)
			purposes.push(&#039;ca&#039;);
		if (purposes.indexOf(&#039;crl&#039;) === -1)
			purposes.push(&#039;crl&#039;);
	}

	var hostSubjects = subjects.filter(function (subject) {
		return (subject.type === &#039;host&#039;);
	});
	var userSubjects = subjects.filter(function (subject) {
		return (subject.type === &#039;user&#039;);
	});
	if (hostSubjects.length &gt; 0) {
		if (purposes.indexOf(&#039;serverAuth&#039;) === -1)
			purposes.push(&#039;serverAuth&#039;);
	}
	if (userSubjects.length &gt; 0) {
		if (purposes.indexOf(&#039;clientAuth&#039;) === -1)
			purposes.push(&#039;clientAuth&#039;);
	}
	if (userSubjects.length &gt; 0 || hostSubjects.length &gt; 0) {
		if (purposes.indexOf(&#039;keyAgreement&#039;) === -1)
			purposes.push(&#039;keyAgreement&#039;);
		if (key.type === &#039;rsa&#039; &amp;&amp;
		    purposes.indexOf(&#039;encryption&#039;) === -1)
			purposes.push(&#039;encryption&#039;);
	}

	var cert = new Certificate({
		subjects: subjects,
		issuer: issuer,
		subjectKey: key,
		issuerKey: issuerKey.toPublic(),
		signatures: {},
		serial: serial,
		validFrom: validFrom,
		validUntil: validUntil,
		purposes: purposes
	});
	cert.signWith(issuerKey);

	return (cert);
};

Certificate.parse = function (data, format, options) {
	if (typeof (data) !== &#039;string&#039;)
		assert.buffer(data, &#039;data&#039;);
	if (format === undefined)
		format = &#039;auto&#039;;
	assert.string(format, &#039;format&#039;);
	if (typeof (options) === &#039;string&#039;)
		options = { filename: options };
	assert.optionalObject(options, &#039;options&#039;);
	if (options === undefined)
		options = {};
	assert.optionalString(options.filename, &#039;options.filename&#039;);
	if (options.filename === undefined)
		options.filename = &#039;(unnamed)&#039;;

	assert.object(formats[format], &#039;formats[format]&#039;);

	try {
		var k = formats[format].read(data, options);
		return (k);
	} catch (e) {
		throw (new CertificateParseError(options.filename, format, e));
	}
};

Certificate.isCertificate = function (obj, ver) {
	return (utils.isCompatible(obj, Certificate, ver));
};

/*
 * API versions for Certificate:
 * [1,0] -- initial ver
 * [1,1] -- openssh format now unpacks extensions
 */
Certificate.prototype._sshpkApiVersion = [1, 1];

Certificate._oldVersionDetect = function (obj) {
	return ([1, 0]);
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
