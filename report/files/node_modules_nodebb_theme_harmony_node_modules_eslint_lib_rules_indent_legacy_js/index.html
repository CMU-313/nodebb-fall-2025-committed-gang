<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/indent-legacy.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/indent-legacy.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1369</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.28</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview This option sets a specific tab width for your code
 *
 * This rule has been ported and modified from nodeca.
 * @author Vitaly Puzrin
 * @author Gyandeep Singh
 * @deprecated in ESLint v4.0.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
// this rule has known coverage issues, but it&#039;s deprecated and shouldn&#039;t be updated in the future anyway.
/* c8 ignore next */
/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;layout&quot;,

		docs: {
			description: &quot;Enforce consistent indentation&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/indent-legacy&quot;,
		},

		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;4.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin-js&quot;,
						url: &quot;https://eslint.style/packages/js&quot;,
					},
					rule: {
						name: &quot;indent&quot;,
						url: &quot;https://eslint.style/rules/js/indent&quot;,
					},
				},
			],
		},

		fixable: &quot;whitespace&quot;,

		schema: [
			{
				oneOf: [
					{
						enum: [&quot;tab&quot;],
					},
					{
						type: &quot;integer&quot;,
						minimum: 0,
					},
				],
			},
			{
				type: &quot;object&quot;,
				properties: {
					SwitchCase: {
						type: &quot;integer&quot;,
						minimum: 0,
					},
					VariableDeclarator: {
						oneOf: [
							{
								type: &quot;integer&quot;,
								minimum: 0,
							},
							{
								type: &quot;object&quot;,
								properties: {
									var: {
										type: &quot;integer&quot;,
										minimum: 0,
									},
									let: {
										type: &quot;integer&quot;,
										minimum: 0,
									},
									const: {
										type: &quot;integer&quot;,
										minimum: 0,
									},
								},
							},
						],
					},
					outerIIFEBody: {
						type: &quot;integer&quot;,
						minimum: 0,
					},
					MemberExpression: {
						type: &quot;integer&quot;,
						minimum: 0,
					},
					FunctionDeclaration: {
						type: &quot;object&quot;,
						properties: {
							parameters: {
								oneOf: [
									{
										type: &quot;integer&quot;,
										minimum: 0,
									},
									{
										enum: [&quot;first&quot;],
									},
								],
							},
							body: {
								type: &quot;integer&quot;,
								minimum: 0,
							},
						},
					},
					FunctionExpression: {
						type: &quot;object&quot;,
						properties: {
							parameters: {
								oneOf: [
									{
										type: &quot;integer&quot;,
										minimum: 0,
									},
									{
										enum: [&quot;first&quot;],
									},
								],
							},
							body: {
								type: &quot;integer&quot;,
								minimum: 0,
							},
						},
					},
					CallExpression: {
						type: &quot;object&quot;,
						properties: {
							parameters: {
								oneOf: [
									{
										type: &quot;integer&quot;,
										minimum: 0,
									},
									{
										enum: [&quot;first&quot;],
									},
								],
							},
						},
					},
					ArrayExpression: {
						oneOf: [
							{
								type: &quot;integer&quot;,
								minimum: 0,
							},
							{
								enum: [&quot;first&quot;],
							},
						],
					},
					ObjectExpression: {
						oneOf: [
							{
								type: &quot;integer&quot;,
								minimum: 0,
							},
							{
								enum: [&quot;first&quot;],
							},
						],
					},
				},
				additionalProperties: false,
			},
		],
		messages: {
			expected:
				&quot;Expected indentation of {{expected}} but found {{actual}}.&quot;,
		},
	},

	create(context) {
		const DEFAULT_VARIABLE_INDENT = 1;
		const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don&#039;t check parameter indentation unless specified in the config
		const DEFAULT_FUNCTION_BODY_INDENT = 1;

		let indentType = &quot;space&quot;;
		let indentSize = 4;
		const options = {
			SwitchCase: 0,
			VariableDeclarator: {
				var: DEFAULT_VARIABLE_INDENT,
				let: DEFAULT_VARIABLE_INDENT,
				const: DEFAULT_VARIABLE_INDENT,
			},
			outerIIFEBody: null,
			FunctionDeclaration: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT,
			},
			FunctionExpression: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT,
			},
			CallExpression: {
				arguments: DEFAULT_PARAMETER_INDENT,
			},
			ArrayExpression: 1,
			ObjectExpression: 1,
		};

		const sourceCode = context.sourceCode;

		if (context.options.length) {
			if (context.options[0] === &quot;tab&quot;) {
				indentSize = 1;
				indentType = &quot;tab&quot;;
			} /* c8 ignore start */ else if (
				typeof context.options[0] === &quot;number&quot;
			) {
				indentSize = context.options[0];
				indentType = &quot;space&quot;;
			} /* c8 ignore stop */

			if (context.options[1]) {
				const opts = context.options[1];

				options.SwitchCase = opts.SwitchCase || 0;
				const variableDeclaratorRules = opts.VariableDeclarator;

				if (typeof variableDeclaratorRules === &quot;number&quot;) {
					options.VariableDeclarator = {
						var: variableDeclaratorRules,
						let: variableDeclaratorRules,
						const: variableDeclaratorRules,
					};
				} else if (typeof variableDeclaratorRules === &quot;object&quot;) {
					Object.assign(
						options.VariableDeclarator,
						variableDeclaratorRules,
					);
				}

				if (typeof opts.outerIIFEBody === &quot;number&quot;) {
					options.outerIIFEBody = opts.outerIIFEBody;
				}

				if (typeof opts.MemberExpression === &quot;number&quot;) {
					options.MemberExpression = opts.MemberExpression;
				}

				if (typeof opts.FunctionDeclaration === &quot;object&quot;) {
					Object.assign(
						options.FunctionDeclaration,
						opts.FunctionDeclaration,
					);
				}

				if (typeof opts.FunctionExpression === &quot;object&quot;) {
					Object.assign(
						options.FunctionExpression,
						opts.FunctionExpression,
					);
				}

				if (typeof opts.CallExpression === &quot;object&quot;) {
					Object.assign(options.CallExpression, opts.CallExpression);
				}

				if (
					typeof opts.ArrayExpression === &quot;number&quot; ||
					typeof opts.ArrayExpression === &quot;string&quot;
				) {
					options.ArrayExpression = opts.ArrayExpression;
				}

				if (
					typeof opts.ObjectExpression === &quot;number&quot; ||
					typeof opts.ObjectExpression === &quot;string&quot;
				) {
					options.ObjectExpression = opts.ObjectExpression;
				}
			}
		}

		const caseIndentStore = {};

		/**
		 * Creates an error message for a line, given the expected/actual indentation.
		 * @param {number} expectedAmount The expected amount of indentation characters for this line
		 * @param {number} actualSpaces The actual number of indentation spaces that were found on this line
		 * @param {number} actualTabs The actual number of indentation tabs that were found on this line
		 * @returns {string} An error message for this line
		 */
		function createErrorMessageData(
			expectedAmount,
			actualSpaces,
			actualTabs,
		) {
			const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? &quot;&quot; : &quot;s&quot;}`; // e.g. &quot;2 tabs&quot;
			const foundSpacesWord = `space${actualSpaces === 1 ? &quot;&quot; : &quot;s&quot;}`; // e.g. &quot;space&quot;
			const foundTabsWord = `tab${actualTabs === 1 ? &quot;&quot; : &quot;s&quot;}`; // e.g. &quot;tabs&quot;
			let foundStatement;

			if (actualSpaces &gt; 0 &amp;&amp; actualTabs &gt; 0) {
				foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. &quot;1 space and 2 tabs&quot;
			} else if (actualSpaces &gt; 0) {
				/*
				 * Abbreviate the message if the expected indentation is also spaces.
				 * e.g. &#039;Expected 4 spaces but found 2&#039; rather than &#039;Expected 4 spaces but found 2 spaces&#039;
				 */
				foundStatement =
					indentType === &quot;space&quot;
						? actualSpaces
						: `${actualSpaces} ${foundSpacesWord}`;
			} else if (actualTabs &gt; 0) {
				foundStatement =
					indentType === &quot;tab&quot;
						? actualTabs
						: `${actualTabs} ${foundTabsWord}`;
			} else {
				foundStatement = &quot;0&quot;;
			}
			return {
				expected: expectedStatement,
				actual: foundStatement,
			};
		}

		/**
		 * Reports a given indent violation
		 * @param {ASTNode} node Node violating the indent rule
		 * @param {number} needed Expected indentation character count
		 * @param {number} gottenSpaces Indentation space count in the actual node/code
		 * @param {number} gottenTabs Indentation tab count in the actual node/code
		 * @param {Object} [loc] Error line and column location
		 * @param {boolean} isLastNodeCheck Is the error for last node check
		 * @returns {void}
		 */
		function report(
			node,
			needed,
			gottenSpaces,
			gottenTabs,
			loc,
			isLastNodeCheck,
		) {
			if (gottenSpaces &amp;&amp; gottenTabs) {
				// To avoid conflicts with `no-mixed-spaces-and-tabs`, don&#039;t report lines that have both spaces and tabs.
				return;
			}

			const desiredIndent = (indentType === &quot;space&quot; ? &quot; &quot; : &quot;\t&quot;).repeat(
				needed,
			);

			const textRange = isLastNodeCheck
				? [
						node.range[1] - node.loc.end.column,
						node.range[1] -
							node.loc.end.column +
							gottenSpaces +
							gottenTabs,
					]
				: [
						node.range[0] - node.loc.start.column,
						node.range[0] -
							node.loc.start.column +
							gottenSpaces +
							gottenTabs,
					];

			context.report({
				node,
				loc,
				messageId: &quot;expected&quot;,
				data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
				fix: fixer =&gt; fixer.replaceTextRange(textRange, desiredIndent),
			});
		}

		/**
		 * Get the actual indent of node
		 * @param {ASTNode|Token} node Node to examine
		 * @param {boolean} [byLastLine=false] get indent of node&#039;s last line
		 * @returns {Object} The node&#039;s indent. Contains keys `space` and `tab`, representing the indent of each character. Also
		 * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user&#039;s desired indentation character, and
		 * `badChar` is the amount of the other indentation character.
		 */
		function getNodeIndent(node, byLastLine) {
			const token = byLastLine
				? sourceCode.getLastToken(node)
				: sourceCode.getFirstToken(node);
			const srcCharsBeforeNode = sourceCode
				.getText(token, token.loc.start.column)
				.split(&quot;&quot;);
			const indentChars = srcCharsBeforeNode.slice(
				0,
				srcCharsBeforeNode.findIndex(
					char =&gt; char !== &quot; &quot; &amp;&amp; char !== &quot;\t&quot;,
				),
			);
			const spaces = indentChars.filter(char =&gt; char === &quot; &quot;).length;
			const tabs = indentChars.filter(char =&gt; char === &quot;\t&quot;).length;

			return {
				space: spaces,
				tab: tabs,
				goodChar: indentType === &quot;space&quot; ? spaces : tabs,
				badChar: indentType === &quot;space&quot; ? tabs : spaces,
			};
		}

		/**
		 * Checks node is the first in its own start line. By default it looks by start line.
		 * @param {ASTNode} node The node to check
		 * @param {boolean} [byEndLocation=false] Lookup based on start position or end
		 * @returns {boolean} true if its the first in the its start line
		 */
		function isNodeFirstInLine(node, byEndLocation) {
			const firstToken =
					byEndLocation === true
						? sourceCode.getLastToken(node, 1)
						: sourceCode.getTokenBefore(node),
				startLine =
					byEndLocation === true
						? node.loc.end.line
						: node.loc.start.line,
				endLine = firstToken ? firstToken.loc.end.line : -1;

			return startLine !== endLine;
		}

		/**
		 * Check indent for node
		 * @param {ASTNode} node Node to check
		 * @param {number} neededIndent needed indent
		 * @returns {void}
		 */
		function checkNodeIndent(node, neededIndent) {
			const actualIndent = getNodeIndent(node, false);

			if (
				node.type !== &quot;ArrayExpression&quot; &amp;&amp;
				node.type !== &quot;ObjectExpression&quot; &amp;&amp;
				(actualIndent.goodChar !== neededIndent ||
					actualIndent.badChar !== 0) &amp;&amp;
				isNodeFirstInLine(node)
			) {
				report(
					node,
					neededIndent,
					actualIndent.space,
					actualIndent.tab,
				);
			}

			if (node.type === &quot;IfStatement&quot; &amp;&amp; node.alternate) {
				const elseToken = sourceCode.getTokenBefore(node.alternate);

				checkNodeIndent(elseToken, neededIndent);

				if (!isNodeFirstInLine(node.alternate)) {
					checkNodeIndent(node.alternate, neededIndent);
				}
			}

			if (node.type === &quot;TryStatement&quot; &amp;&amp; node.handler) {
				const catchToken = sourceCode.getFirstToken(node.handler);

				checkNodeIndent(catchToken, neededIndent);
			}

			if (node.type === &quot;TryStatement&quot; &amp;&amp; node.finalizer) {
				const finallyToken = sourceCode.getTokenBefore(node.finalizer);

				checkNodeIndent(finallyToken, neededIndent);
			}

			if (node.type === &quot;DoWhileStatement&quot;) {
				const whileToken = sourceCode.getTokenAfter(node.body);

				checkNodeIndent(whileToken, neededIndent);
			}
		}

		/**
		 * Check indent for nodes list
		 * @param {ASTNode[]} nodes list of node objects
		 * @param {number} indent needed indent
		 * @returns {void}
		 */
		function checkNodesIndent(nodes, indent) {
			nodes.forEach(node =&gt; checkNodeIndent(node, indent));
		}

		/**
		 * Check last node line indent this detects, that block closed correctly
		 * @param {ASTNode} node Node to examine
		 * @param {number} lastLineIndent needed indent
		 * @returns {void}
		 */
		function checkLastNodeLineIndent(node, lastLineIndent) {
			const lastToken = sourceCode.getLastToken(node);
			const endIndent = getNodeIndent(lastToken, true);

			if (
				(endIndent.goodChar !== lastLineIndent ||
					endIndent.badChar !== 0) &amp;&amp;
				isNodeFirstInLine(node, true)
			) {
				report(
					node,
					lastLineIndent,
					endIndent.space,
					endIndent.tab,
					{
						line: lastToken.loc.start.line,
						column: lastToken.loc.start.column,
					},
					true,
				);
			}
		}

		/**
		 * Check last node line indent this detects, that block closed correctly
		 * This function for more complicated return statement case, where closing parenthesis may be followed by &#039;;&#039;
		 * @param {ASTNode} node Node to examine
		 * @param {number} firstLineIndent first line needed indent
		 * @returns {void}
		 */
		function checkLastReturnStatementLineIndent(node, firstLineIndent) {
			/*
			 * in case if return statement ends with &#039;);&#039; we have traverse back to &#039;)&#039;
			 * otherwise we&#039;ll measure indent for &#039;;&#039; and replace &#039;)&#039;
			 */
			const lastToken = sourceCode.getLastToken(
				node,
				astUtils.isClosingParenToken,
			);
			const textBeforeClosingParenthesis = sourceCode
				.getText(lastToken, lastToken.loc.start.column)
				.slice(0, -1);

			if (textBeforeClosingParenthesis.trim()) {
				// There are tokens before the closing paren, don&#039;t report this case
				return;
			}

			const endIndent = getNodeIndent(lastToken, true);

			if (endIndent.goodChar !== firstLineIndent) {
				report(
					node,
					firstLineIndent,
					endIndent.space,
					endIndent.tab,
					{
						line: lastToken.loc.start.line,
						column: lastToken.loc.start.column,
					},
					true,
				);
			}
		}

		/**
		 * Check first node line indent is correct
		 * @param {ASTNode} node Node to examine
		 * @param {number} firstLineIndent needed indent
		 * @returns {void}
		 */
		function checkFirstNodeLineIndent(node, firstLineIndent) {
			const startIndent = getNodeIndent(node, false);

			if (
				(startIndent.goodChar !== firstLineIndent ||
					startIndent.badChar !== 0) &amp;&amp;
				isNodeFirstInLine(node)
			) {
				report(
					node,
					firstLineIndent,
					startIndent.space,
					startIndent.tab,
					{
						line: node.loc.start.line,
						column: node.loc.start.column,
					},
				);
			}
		}

		/**
		 * Returns a parent node of given node based on a specified type
		 * if not present then return null
		 * @param {ASTNode} node node to examine
		 * @param {string} type type that is being looked for
		 * @param {string} stopAtList end points for the evaluating code
		 * @returns {ASTNode|void} if found then node otherwise null
		 */
		function getParentNodeByType(node, type, stopAtList) {
			let parent = node.parent;
			const stopAtSet = new Set(stopAtList || [&quot;Program&quot;]);

			while (
				parent.type !== type &amp;&amp;
				!stopAtSet.has(parent.type) &amp;&amp;
				parent.type !== &quot;Program&quot;
			) {
				parent = parent.parent;
			}

			return parent.type === type ? parent : null;
		}

		/**
		 * Returns the VariableDeclarator based on the current node
		 * if not present then return null
		 * @param {ASTNode} node node to examine
		 * @returns {ASTNode|void} if found then node otherwise null
		 */
		function getVariableDeclaratorNode(node) {
			return getParentNodeByType(node, &quot;VariableDeclarator&quot;);
		}

		/**
		 * Check to see if the node is part of the multi-line variable declaration.
		 * Also if its on the same line as the varNode
		 * @param {ASTNode} node node to check
		 * @param {ASTNode} varNode variable declaration node to check against
		 * @returns {boolean} True if all the above condition satisfy
		 */
		function isNodeInVarOnTop(node, varNode) {
			return (
				varNode &amp;&amp;
				varNode.parent.loc.start.line === node.loc.start.line &amp;&amp;
				varNode.parent.declarations.length &gt; 1
			);
		}

		/**
		 * Check to see if the argument before the callee node is multi-line and
		 * there should only be 1 argument before the callee node
		 * @param {ASTNode} node node to check
		 * @returns {boolean} True if arguments are multi-line
		 */
		function isArgBeforeCalleeNodeMultiline(node) {
			const parent = node.parent;

			if (parent.arguments.length &gt;= 2 &amp;&amp; parent.arguments[1] === node) {
				return (
					parent.arguments[0].loc.end.line &gt;
					parent.arguments[0].loc.start.line
				);
			}

			return false;
		}

		/**
		 * Check to see if the node is a file level IIFE
		 * @param {ASTNode} node The function node to check.
		 * @returns {boolean} True if the node is the outer IIFE
		 */
		function isOuterIIFE(node) {
			const parent = node.parent;
			let stmt = parent.parent;

			/*
			 * Verify that the node is an IIEF
			 */
			if (parent.type !== &quot;CallExpression&quot; || parent.callee !== node) {
				return false;
			}

			/*
			 * Navigate legal ancestors to determine whether this IIEF is outer
			 */
			while (
				(stmt.type === &quot;UnaryExpression&quot; &amp;&amp;
					(stmt.operator === &quot;!&quot; ||
						stmt.operator === &quot;~&quot; ||
						stmt.operator === &quot;+&quot; ||
						stmt.operator === &quot;-&quot;)) ||
				stmt.type === &quot;AssignmentExpression&quot; ||
				stmt.type === &quot;LogicalExpression&quot; ||
				stmt.type === &quot;SequenceExpression&quot; ||
				stmt.type === &quot;VariableDeclarator&quot;
			) {
				stmt = stmt.parent;
			}

			return (
				(stmt.type === &quot;ExpressionStatement&quot; ||
					stmt.type === &quot;VariableDeclaration&quot;) &amp;&amp;
				stmt.parent &amp;&amp;
				stmt.parent.type === &quot;Program&quot;
			);
		}

		/**
		 * Check indent for function block content
		 * @param {ASTNode} node A BlockStatement node that is inside of a function.
		 * @returns {void}
		 */
		function checkIndentInFunctionBlock(node) {
			/*
			 * Search first caller in chain.
			 * Ex.:
			 *
			 * Models &lt;- Identifier
			 *   .User
			 *   .find()
			 *   .exec(function() {
			 *   // function body
			 * });
			 *
			 * Looks for &#039;Models&#039;
			 */
			const calleeNode = node.parent; // FunctionExpression
			let indent;

			if (
				calleeNode.parent &amp;&amp;
				(calleeNode.parent.type === &quot;Property&quot; ||
					calleeNode.parent.type === &quot;ArrayExpression&quot;)
			) {
				// If function is part of array or object, comma can be put at left
				indent = getNodeIndent(calleeNode, false).goodChar;
			} else {
				// If function is standalone, simple calculate indent
				indent = getNodeIndent(calleeNode).goodChar;
			}

			if (calleeNode.parent.type === &quot;CallExpression&quot;) {
				const calleeParent = calleeNode.parent;

				if (
					calleeNode.type !== &quot;FunctionExpression&quot; &amp;&amp;
					calleeNode.type !== &quot;ArrowFunctionExpression&quot;
				) {
					if (
						calleeParent &amp;&amp;
						calleeParent.loc.start.line &lt; node.loc.start.line
					) {
						indent = getNodeIndent(calleeParent).goodChar;
					}
				} else {
					if (
						isArgBeforeCalleeNodeMultiline(calleeNode) &amp;&amp;
						calleeParent.callee.loc.start.line ===
							calleeParent.callee.loc.end.line &amp;&amp;
						!isNodeFirstInLine(calleeNode)
					) {
						indent = getNodeIndent(calleeParent).goodChar;
					}
				}
			}

			/*
			 * function body indent should be indent + indent size, unless this
			 * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.
			 */
			let functionOffset = indentSize;

			if (options.outerIIFEBody !== null &amp;&amp; isOuterIIFE(calleeNode)) {
				functionOffset = options.outerIIFEBody * indentSize;
			} else if (calleeNode.type === &quot;FunctionExpression&quot;) {
				functionOffset = options.FunctionExpression.body * indentSize;
			} else if (calleeNode.type === &quot;FunctionDeclaration&quot;) {
				functionOffset = options.FunctionDeclaration.body * indentSize;
			}
			indent += functionOffset;

			// check if the node is inside a variable
			const parentVarNode = getVariableDeclaratorNode(node);

			if (parentVarNode &amp;&amp; isNodeInVarOnTop(node, parentVarNode)) {
				indent +=
					indentSize *
					options.VariableDeclarator[parentVarNode.parent.kind];
			}

			if (node.body.length &gt; 0) {
				checkNodesIndent(node.body, indent);
			}

			checkLastNodeLineIndent(node, indent - functionOffset);
		}

		/**
		 * Checks if the given node starts and ends on the same line
		 * @param {ASTNode} node The node to check
		 * @returns {boolean} Whether or not the block starts and ends on the same line.
		 */
		function isSingleLineNode(node) {
			const lastToken = sourceCode.getLastToken(node),
				startLine = node.loc.start.line,
				endLine = lastToken.loc.end.line;

			return startLine === endLine;
		}

		/**
		 * Check indent for array block content or object block content
		 * @param {ASTNode} node node to examine
		 * @returns {void}
		 */
		function checkIndentInArrayOrObjectBlock(node) {
			// Skip inline
			if (isSingleLineNode(node)) {
				return;
			}

			let elements =
				node.type === &quot;ArrayExpression&quot;
					? node.elements
					: node.properties;

			// filter out empty elements example would be [ , 2] so remove first element as espree considers it as null
			elements = elements.filter(elem =&gt; elem !== null);

			let nodeIndent;
			let elementsIndent;
			const parentVarNode = getVariableDeclaratorNode(node);

			// TODO - come up with a better strategy in future
			if (isNodeFirstInLine(node)) {
				const parent = node.parent;

				nodeIndent = getNodeIndent(parent).goodChar;
				if (
					!parentVarNode ||
					parentVarNode.loc.start.line !== node.loc.start.line
				) {
					if (
						parent.type !== &quot;VariableDeclarator&quot; ||
						parentVarNode === parentVarNode.parent.declarations[0]
					) {
						if (
							parent.type === &quot;VariableDeclarator&quot; &amp;&amp;
							parentVarNode.loc.start.line ===
								parent.loc.start.line
						) {
							nodeIndent +=
								indentSize *
								options.VariableDeclarator[
									parentVarNode.parent.kind
								];
						} else if (
							parent.type === &quot;ObjectExpression&quot; ||
							parent.type === &quot;ArrayExpression&quot;
						) {
							const parentElements =
								node.parent.type === &quot;ObjectExpression&quot;
									? node.parent.properties
									: node.parent.elements;

							if (
								parentElements[0] &amp;&amp;
								parentElements[0].loc.start.line ===
									parent.loc.start.line &amp;&amp;
								parentElements[0].loc.end.line !==
									parent.loc.start.line
							) {
								/*
								 * If the first element of the array spans multiple lines, don&#039;t increase the expected indentation of the rest.
								 * e.g. [{
								 *        foo: 1
								 *      },
								 *      {
								 *        bar: 1
								 *      }]
								 * the second object is not indented.
								 */
							} else if (
								typeof options[parent.type] === &quot;number&quot;
							) {
								nodeIndent += options[parent.type] * indentSize;
							} else {
								nodeIndent = parentElements[0].loc.start.column;
							}
						} else if (
							parent.type === &quot;CallExpression&quot; ||
							parent.type === &quot;NewExpression&quot;
						) {
							if (
								typeof options.CallExpression.arguments ===
								&quot;number&quot;
							) {
								nodeIndent +=
									options.CallExpression.arguments *
									indentSize;
							} else if (
								options.CallExpression.arguments === &quot;first&quot;
							) {
								if (parent.arguments.includes(node)) {
									nodeIndent =
										parent.arguments[0].loc.start.column;
								}
							} else {
								nodeIndent += indentSize;
							}
						} else if (
							parent.type === &quot;LogicalExpression&quot; ||
							parent.type === &quot;ArrowFunctionExpression&quot;
						) {
							nodeIndent += indentSize;
						}
					}
				}

				checkFirstNodeLineIndent(node, nodeIndent);
			} else {
				nodeIndent = getNodeIndent(node).goodChar;
			}

			if (options[node.type] === &quot;first&quot;) {
				elementsIndent = elements.length
					? elements[0].loc.start.column
					: 0; // If there are no elements, elementsIndent doesn&#039;t matter.
			} else {
				elementsIndent = nodeIndent + indentSize * options[node.type];
			}

			/*
			 * Check if the node is a multiple variable declaration; if so, then
			 * make sure indentation takes that into account.
			 */
			if (isNodeInVarOnTop(node, parentVarNode)) {
				elementsIndent +=
					indentSize *
					options.VariableDeclarator[parentVarNode.parent.kind];
			}

			checkNodesIndent(elements, elementsIndent);

			if (elements.length &gt; 0) {
				// Skip last block line check if last item in same line
				if (elements.at(-1).loc.end.line === node.loc.end.line) {
					return;
				}
			}

			checkLastNodeLineIndent(
				node,
				nodeIndent +
					(isNodeInVarOnTop(node, parentVarNode)
						? options.VariableDeclarator[
								parentVarNode.parent.kind
							] * indentSize
						: 0),
			);
		}

		/**
		 * Check if the node or node body is a BlockStatement or not
		 * @param {ASTNode} node node to test
		 * @returns {boolean} True if it or its body is a block statement
		 */
		function isNodeBodyBlock(node) {
			return (
				node.type === &quot;BlockStatement&quot; ||
				node.type === &quot;ClassBody&quot; ||
				(node.body &amp;&amp; node.body.type === &quot;BlockStatement&quot;) ||
				(node.consequent &amp;&amp; node.consequent.type === &quot;BlockStatement&quot;)
			);
		}

		/**
		 * Check indentation for blocks
		 * @param {ASTNode} node node to check
		 * @returns {void}
		 */
		function blockIndentationCheck(node) {
			// Skip inline blocks
			if (isSingleLineNode(node)) {
				return;
			}

			if (
				node.parent &amp;&amp;
				(node.parent.type === &quot;FunctionExpression&quot; ||
					node.parent.type === &quot;FunctionDeclaration&quot; ||
					node.parent.type === &quot;ArrowFunctionExpression&quot;)
			) {
				checkIndentInFunctionBlock(node);
				return;
			}

			let indent;
			let nodesToCheck;

			/*
			 * For this statements we should check indent from statement beginning,
			 * not from the beginning of the block.
			 */
			const statementsWithProperties = [
				&quot;IfStatement&quot;,
				&quot;WhileStatement&quot;,
				&quot;ForStatement&quot;,
				&quot;ForInStatement&quot;,
				&quot;ForOfStatement&quot;,
				&quot;DoWhileStatement&quot;,
				&quot;ClassDeclaration&quot;,
				&quot;TryStatement&quot;,
			];

			if (
				node.parent &amp;&amp;
				statementsWithProperties.includes(node.parent.type) &amp;&amp;
				isNodeBodyBlock(node)
			) {
				indent = getNodeIndent(node.parent).goodChar;
			} else if (node.parent &amp;&amp; node.parent.type === &quot;CatchClause&quot;) {
				indent = getNodeIndent(node.parent.parent).goodChar;
			} else {
				indent = getNodeIndent(node).goodChar;
			}

			if (
				node.type === &quot;IfStatement&quot; &amp;&amp;
				node.consequent.type !== &quot;BlockStatement&quot;
			) {
				nodesToCheck = [node.consequent];
			} else if (Array.isArray(node.body)) {
				nodesToCheck = node.body;
			} else {
				nodesToCheck = [node.body];
			}

			if (nodesToCheck.length &gt; 0) {
				checkNodesIndent(nodesToCheck, indent + indentSize);
			}

			if (node.type === &quot;BlockStatement&quot;) {
				checkLastNodeLineIndent(node, indent);
			}
		}

		/**
		 * Filter out the elements which are on the same line of each other or the node.
		 * basically have only 1 elements from each line except the variable declaration line.
		 * @param {ASTNode} node Variable declaration node
		 * @returns {ASTNode[]} Filtered elements
		 */
		function filterOutSameLineVars(node) {
			return node.declarations.reduce((finalCollection, elem) =&gt; {
				const lastElem = finalCollection.at(-1);

				if (
					(elem.loc.start.line !== node.loc.start.line &amp;&amp;
						!lastElem) ||
					(lastElem &amp;&amp;
						lastElem.loc.start.line !== elem.loc.start.line)
				) {
					finalCollection.push(elem);
				}

				return finalCollection;
			}, []);
		}

		/**
		 * Check indentation for variable declarations
		 * @param {ASTNode} node node to examine
		 * @returns {void}
		 */
		function checkIndentInVariableDeclarations(node) {
			const elements = filterOutSameLineVars(node);
			const nodeIndent = getNodeIndent(node).goodChar;
			const lastElement = elements.at(-1);

			const elementsIndent =
				nodeIndent + indentSize * options.VariableDeclarator[node.kind];

			checkNodesIndent(elements, elementsIndent);

			// Only check the last line if there is any token after the last item
			if (
				sourceCode.getLastToken(node).loc.end.line &lt;=
				lastElement.loc.end.line
			) {
				return;
			}

			const tokenBeforeLastElement =
				sourceCode.getTokenBefore(lastElement);

			if (tokenBeforeLastElement.value === &quot;,&quot;) {
				// Special case for comma-first syntax where the semicolon is indented
				checkLastNodeLineIndent(
					node,
					getNodeIndent(tokenBeforeLastElement).goodChar,
				);
			} else {
				checkLastNodeLineIndent(node, elementsIndent - indentSize);
			}
		}

		/**
		 * Check and decide whether to check for indentation for blockless nodes
		 * Scenarios are for or while statements without braces around them
		 * @param {ASTNode} node node to examine
		 * @returns {void}
		 */
		function blockLessNodes(node) {
			if (node.body.type !== &quot;BlockStatement&quot;) {
				blockIndentationCheck(node);
			}
		}

		/**
		 * Returns the expected indentation for the case statement
		 * @param {ASTNode} node node to examine
		 * @param {number} [providedSwitchIndent] indent for switch statement
		 * @returns {number} indent size
		 */
		function expectedCaseIndent(node, providedSwitchIndent) {
			const switchNode =
				node.type === &quot;SwitchStatement&quot; ? node : node.parent;
			const switchIndent =
				typeof providedSwitchIndent === &quot;undefined&quot;
					? getNodeIndent(switchNode).goodChar
					: providedSwitchIndent;
			let caseIndent;

			if (caseIndentStore[switchNode.loc.start.line]) {
				return caseIndentStore[switchNode.loc.start.line];
			}

			if (switchNode.cases.length &gt; 0 &amp;&amp; options.SwitchCase === 0) {
				caseIndent = switchIndent;
			} else {
				caseIndent = switchIndent + indentSize * options.SwitchCase;
			}

			caseIndentStore[switchNode.loc.start.line] = caseIndent;
			return caseIndent;
		}

		/**
		 * Checks whether a return statement is wrapped in ()
		 * @param {ASTNode} node node to examine
		 * @returns {boolean} the result
		 */
		function isWrappedInParenthesis(node) {
			const regex = /^return\s*?\(\s*?\);*?/u;

			const statementWithoutArgument = sourceCode
				.getText(node)
				.replace(sourceCode.getText(node.argument), &quot;&quot;);

			return regex.test(statementWithoutArgument);
		}

		return {
			Program(node) {
				if (node.body.length &gt; 0) {
					// Root nodes should have no indent
					checkNodesIndent(node.body, getNodeIndent(node).goodChar);
				}
			},

			ClassBody: blockIndentationCheck,

			BlockStatement: blockIndentationCheck,

			WhileStatement: blockLessNodes,

			ForStatement: blockLessNodes,

			ForInStatement: blockLessNodes,

			ForOfStatement: blockLessNodes,

			DoWhileStatement: blockLessNodes,

			IfStatement(node) {
				if (
					node.consequent.type !== &quot;BlockStatement&quot; &amp;&amp;
					node.consequent.loc.start.line &gt; node.loc.start.line
				) {
					blockIndentationCheck(node);
				}
			},

			VariableDeclaration(node) {
				if (
					node.declarations.at(-1).loc.start.line &gt;
					node.declarations[0].loc.start.line
				) {
					checkIndentInVariableDeclarations(node);
				}
			},

			ObjectExpression(node) {
				checkIndentInArrayOrObjectBlock(node);
			},

			ArrayExpression(node) {
				checkIndentInArrayOrObjectBlock(node);
			},

			MemberExpression(node) {
				if (typeof options.MemberExpression === &quot;undefined&quot;) {
					return;
				}

				if (isSingleLineNode(node)) {
					return;
				}

				/*
				 * The typical layout of variable declarations and assignments
				 * alter the expectation of correct indentation. Skip them.
				 * TODO: Add appropriate configuration options for variable
				 * declarations and assignments.
				 */
				if (
					getParentNodeByType(node, &quot;VariableDeclarator&quot;, [
						&quot;FunctionExpression&quot;,
						&quot;ArrowFunctionExpression&quot;,
					])
				) {
					return;
				}

				if (
					getParentNodeByType(node, &quot;AssignmentExpression&quot;, [
						&quot;FunctionExpression&quot;,
					])
				) {
					return;
				}

				const propertyIndent =
					getNodeIndent(node).goodChar +
					indentSize * options.MemberExpression;

				const checkNodes = [node.property];

				const dot = sourceCode.getTokenBefore(node.property);

				if (dot.type === &quot;Punctuator&quot; &amp;&amp; dot.value === &quot;.&quot;) {
					checkNodes.push(dot);
				}

				checkNodesIndent(checkNodes, propertyIndent);
			},

			SwitchStatement(node) {
				// Switch is not a &#039;BlockStatement&#039;
				const switchIndent = getNodeIndent(node).goodChar;
				const caseIndent = expectedCaseIndent(node, switchIndent);

				checkNodesIndent(node.cases, caseIndent);

				checkLastNodeLineIndent(node, switchIndent);
			},

			SwitchCase(node) {
				// Skip inline cases
				if (isSingleLineNode(node)) {
					return;
				}
				const caseIndent = expectedCaseIndent(node);

				checkNodesIndent(node.consequent, caseIndent + indentSize);
			},

			FunctionDeclaration(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (
					options.FunctionDeclaration.parameters === &quot;first&quot; &amp;&amp;
					node.params.length
				) {
					checkNodesIndent(
						node.params.slice(1),
						node.params[0].loc.start.column,
					);
				} else if (options.FunctionDeclaration.parameters !== null) {
					checkNodesIndent(
						node.params,
						getNodeIndent(node).goodChar +
							indentSize * options.FunctionDeclaration.parameters,
					);
				}
			},

			FunctionExpression(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (
					options.FunctionExpression.parameters === &quot;first&quot; &amp;&amp;
					node.params.length
				) {
					checkNodesIndent(
						node.params.slice(1),
						node.params[0].loc.start.column,
					);
				} else if (options.FunctionExpression.parameters !== null) {
					checkNodesIndent(
						node.params,
						getNodeIndent(node).goodChar +
							indentSize * options.FunctionExpression.parameters,
					);
				}
			},

			ReturnStatement(node) {
				if (isSingleLineNode(node)) {
					return;
				}

				const firstLineIndent = getNodeIndent(node).goodChar;

				// in case if return statement is wrapped in parenthesis
				if (isWrappedInParenthesis(node)) {
					checkLastReturnStatementLineIndent(node, firstLineIndent);
				} else {
					checkNodeIndent(node, firstLineIndent);
				}
			},

			CallExpression(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (
					options.CallExpression.arguments === &quot;first&quot; &amp;&amp;
					node.arguments.length
				) {
					checkNodesIndent(
						node.arguments.slice(1),
						node.arguments[0].loc.start.column,
					);
				} else if (options.CallExpression.arguments !== null) {
					checkNodesIndent(
						node.arguments,
						getNodeIndent(node).goodChar +
							indentSize * options.CallExpression.arguments,
					);
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
