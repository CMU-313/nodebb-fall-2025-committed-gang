<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint-module-utils/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint-module-utils/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">194</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">45.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

exports.__esModule = true;

/** @typedef {`.${string}`} Extension  */
/** @typedef {NonNullable&lt;import(&#039;eslint&#039;).Rule.RuleContext[&#039;settings&#039;]&gt; &amp; { &#039;import/extensions&#039;?: Extension[], &#039;import/parsers&#039;?: { [k: string]: Extension[] }, &#039;import/cache&#039;?: { lifetime: number | &#039;âˆž&#039; | &#039;Infinity&#039; } }} ESLintSettings */

const moduleRequire = require(&#039;./module-require&#039;).default;
const extname = require(&#039;path&#039;).extname;
const fs = require(&#039;fs&#039;);

const log = require(&#039;debug&#039;)(&#039;eslint-plugin-import:parse&#039;);

/** @type {(parserPath: NonNullable&lt;import(&#039;eslint&#039;).Rule.RuleContext[&#039;parserPath&#039;]&gt;) =&gt; unknown} */
function getBabelEslintVisitorKeys(parserPath) {
  if (parserPath.endsWith(&#039;index.js&#039;)) {
    const hypotheticalLocation = parserPath.replace(&#039;index.js&#039;, &#039;visitor-keys.js&#039;);
    if (fs.existsSync(hypotheticalLocation)) {
      const keys = moduleRequire(hypotheticalLocation);
      return keys.default || keys;
    }
  }
  return null;
}

/** @type {(parserPath: import(&#039;eslint&#039;).Rule.RuleContext[&#039;parserPath&#039;], parserInstance: { VisitorKeys: unknown }, parsedResult?: { visitorKeys?: unknown }) =&gt; unknown} */
function keysFromParser(parserPath, parserInstance, parsedResult) {
  // Exposed by @typescript-eslint/parser and @babel/eslint-parser
  if (parsedResult &amp;&amp; parsedResult.visitorKeys) {
    return parsedResult.visitorKeys;
  }
  // The old babel parser doesn&#039;t have a `parseForESLint` eslint function, so we don&#039;t end
  // up with a `parsedResult` here.  It also doesn&#039;t expose the visitor keys on the parser itself,
  // so we have to try and infer the visitor-keys module from the parserPath.
  // This is NOT supported in flat config!
  if (typeof parserPath === &#039;string&#039; &amp;&amp; parserPath.indexOf(&#039;babel-eslint&#039;) &gt; -1) {
    return getBabelEslintVisitorKeys(parserPath);
  }
  // The espree parser doesn&#039;t have the `parseForESLint` function, so we don&#039;t end up with a
  // `parsedResult` here, but it does expose the visitor keys on the parser instance that we can use.
  if (parserInstance &amp;&amp; parserInstance.VisitorKeys) {
    return parserInstance.VisitorKeys;
  }
  return null;
}

// this exists to smooth over the unintentional breaking change in v2.7.
// TODO, semver-major: avoid mutating `ast` and return a plain object instead.
/** @type {&lt;T extends import(&#039;eslint&#039;).AST.Program&gt;(ast: T, visitorKeys: unknown) =&gt; T} */
function makeParseReturn(ast, visitorKeys) {
  if (ast) {
    // @ts-expect-error see TODO
    ast.visitorKeys = visitorKeys;
    // @ts-expect-error see TODO
    ast.ast = ast;
  }
  return ast;
}

/** @type {(text: string) =&gt; string} */
function stripUnicodeBOM(text) {
  return text.charCodeAt(0) === 0xFEFF ? text.slice(1) : text;
}

/** @type {(text: string) =&gt; string} */
function transformHashbang(text) {
  return text.replace(/^#!([^\r\n]+)/u, (_, captured) =&gt; `//${captured}`);
}

/** @type {(path: string, context: import(&#039;eslint&#039;).Rule.RuleContext &amp; { settings?: ESLintSettings }) =&gt; import(&#039;eslint&#039;).Rule.RuleContext[&#039;parserPath&#039;]} */
function getParserPath(path, context) {
  const parsers = context.settings[&#039;import/parsers&#039;];
  if (parsers != null) {
    // eslint-disable-next-line no-extra-parens
    const extension = /** @type {Extension} */ (extname(path));
    for (const parserPath in parsers) {
      if (parsers[parserPath].indexOf(extension) &gt; -1) {
        // use this alternate parser
        log(&#039;using alt parser:&#039;, parserPath);
        return parserPath;
      }
    }
  }
  // default to use ESLint parser
  return context.parserPath;
}

/** @type {(path: string, context: import(&#039;eslint&#039;).Rule.RuleContext) =&gt; string | null | import(&#039;eslint&#039;).Linter.ParserModule | import(&#039;eslint&#039;).Linter.FlatConfigParserModule} */
function getParser(path, context) {
  const parserPath = getParserPath(path, context);
  if (parserPath) {
    return parserPath;
  }
  if (
    !!context.languageOptions
    &amp;&amp; !!context.languageOptions.parser
    &amp;&amp; typeof context.languageOptions.parser !== &#039;string&#039;
    &amp;&amp; (
      // @ts-expect-error TODO: figure out a better type
      typeof context.languageOptions.parser.parse === &#039;function&#039;
      // @ts-expect-error TODO: figure out a better type
      || typeof context.languageOptions.parser.parseForESLint === &#039;function&#039;
    )
  ) {
    return context.languageOptions.parser;
  }

  return null;
}

/** @type {import(&#039;./parse&#039;).default} */
exports.default = function parse(path, content, context) {
  if (context == null) { throw new Error(&#039;need context to parse properly&#039;); }

  // ESLint in &quot;flat&quot; mode only sets context.languageOptions.parserOptions
  const languageOptions = context.languageOptions;
  let parserOptions = languageOptions &amp;&amp; languageOptions.parserOptions || context.parserOptions;
  const parserOrPath = getParser(path, context);

  if (!parserOrPath) { throw new Error(&#039;parserPath or languageOptions.parser is required!&#039;); }

  // hack: espree blows up with frozen options
  parserOptions = Object.assign({}, parserOptions);
  parserOptions.ecmaFeatures = Object.assign({}, parserOptions.ecmaFeatures);

  // always include comments and tokens (for doc parsing)
  parserOptions.comment = true;
  parserOptions.attachComment = true;  // keeping this for backward-compat with  older parsers
  parserOptions.tokens = true;

  // attach node locations
  parserOptions.loc = true;
  parserOptions.range = true;

  // provide the `filePath` like eslint itself does, in `parserOptions`
  // https://github.com/eslint/eslint/blob/3ec436ee/lib/linter.js#L637
  parserOptions.filePath = path;

  // @typescript-eslint/parser will parse the entire project with typechecking if you provide
  // &quot;project&quot; or &quot;projects&quot; in parserOptions. Removing these options means the parser will
  // only parse one file in isolate mode, which is much, much faster.
  // https://github.com/import-js/eslint-plugin-import/issues/1408#issuecomment-509298962
  delete parserOptions.EXPERIMENTAL_useProjectService;
  delete parserOptions.projectService;
  delete parserOptions.project;
  delete parserOptions.projects;

  // If this is a flat config, we need to add ecmaVersion and sourceType (if present) from languageOptions
  if (languageOptions &amp;&amp; languageOptions.ecmaVersion) {
    parserOptions.ecmaVersion = languageOptions.ecmaVersion;
  }
  if (languageOptions &amp;&amp; languageOptions.sourceType) {
    // @ts-expect-error languageOptions is from the flatConfig Linter type in 8.57 while parserOptions is not.
    // Non-flat config parserOptions.sourceType doesn&#039;t have &quot;commonjs&quot; in the type.  Once upgraded to v9 types,
    // they&#039;ll be the same and this expect-error should be removed.
    parserOptions.sourceType = languageOptions.sourceType;
  }

  // require the parser relative to the main module (i.e., ESLint)
  const parser = typeof parserOrPath === &#039;string&#039; ? moduleRequire(parserOrPath) : parserOrPath;

  // replicate bom strip and hashbang transform of ESLint
  // https://github.com/eslint/eslint/blob/b93af98b3c417225a027cabc964c38e779adb945/lib/linter/linter.js#L779
  content = transformHashbang(stripUnicodeBOM(String(content)));

  if (typeof parser.parseForESLint === &#039;function&#039;) {
    let ast;
    try {
      const parserRaw = parser.parseForESLint(content, parserOptions);
      ast = parserRaw.ast;
      // @ts-expect-error TODO: FIXME
      return makeParseReturn(ast, keysFromParser(parserOrPath, parser, parserRaw));
    } catch (e) {
      console.warn();
      console.warn(&#039;Error while parsing &#039; + parserOptions.filePath);
      // @ts-expect-error e is almost certainly an Error here
      console.warn(&#039;Line &#039; + e.lineNumber + &#039;, column &#039; + e.column + &#039;: &#039; + e.message);
    }
    if (!ast || typeof ast !== &#039;object&#039;) {
      console.warn(
        // Can only be invalid for custom parser per imports/parser
        &#039;`parseForESLint` from parser `&#039; + (typeof parserOrPath === &#039;string&#039; ? parserOrPath : &#039;context.languageOptions.parser&#039;) + &#039;` is invalid and will just be ignored&#039;
      );
    } else {
      // @ts-expect-error TODO: FIXME
      return makeParseReturn(ast, keysFromParser(parserOrPath, parser, undefined));
    }
  }

  const ast = parser.parse(content, parserOptions);
  // @ts-expect-error TODO: FIXME
  return makeParseReturn(ast, keysFromParser(parserOrPath, parser, undefined));
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
