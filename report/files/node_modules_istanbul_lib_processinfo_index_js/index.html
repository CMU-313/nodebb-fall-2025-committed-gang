<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/istanbul-lib-processinfo/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/istanbul-lib-processinfo/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">75.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">348</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.52</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;
const { v4: uuidv4 } = require(&#039;uuid&#039;);
const archy = require(&#039;archy&#039;)
const libCoverage = require(&#039;istanbul-lib-coverage&#039;)
const {dirname, resolve} = require(&#039;path&#039;)
const {promisify} = require(&#039;util&#039;)
/* Shallow clone so we can promisify in-place */
const fs = { ...require(&#039;fs&#039;) }
const {spawn} = require(&#039;cross-spawn&#039;)
const rimraf = promisify(require(&#039;rimraf&#039;))
const pMap = require(&#039;p-map&#039;)

const _nodes = Symbol(&#039;nodes&#039;)
const _label = Symbol(&#039;label&#039;)
const _coverageMap = Symbol(&#039;coverageMap&#039;)
const _processInfoDirectory = Symbol(&#039;processInfo.directory&#039;)
// shared symbol for testing
const _spawnArgs = Symbol.for(&#039;spawnArgs&#039;)

;[&#039;writeFile&#039;, &#039;readFile&#039;, &#039;readdir&#039;].forEach(fn =&gt; {
  fs[fn] = promisify(fs[fn])
})

// the enumerable fields
const defaults = () =&gt; ({
  parent: null,
  pid: process.pid,
  argv: process.argv,
  execArgv: process.execArgv,
  cwd: process.cwd(),
  time: Date.now(),
  ppid: process.ppid,
  coverageFilename: null,
  externalId: &#039;&#039;,
  [_nodes]: [],
  [_label]: null,
  [_coverageMap]: null
})

/* istanbul ignore next */
const fromEntries = Object.fromEntries || (
  entries =&gt; entries.reduce((obj, [name, value]) =&gt; {
    obj[name] = value
    return obj
  }, {})
)

class ProcessInfo {
  constructor (fields = {}) {
    Object.assign(this, defaults(), fields)

    if (!this.uuid) {
      this.uuid = uuidv4()
    }
  }

  get nodes () {
    return this[_nodes]
  }

  set nodes (n) {
    this[_nodes] = n
  }

  set directory (d) {
    this[_processInfoDirectory] = resolve(d)
  }

  get directory () {
    return this[_processInfoDirectory]
  }

  saveSync () {
    const f = resolve(this.directory, this.uuid + &#039;.json&#039;)
    fs.writeFileSync(f, JSON.stringify(this), &#039;utf-8&#039;)
  }

  async save () {
    const f = resolve(this.directory, this.uuid + &#039;.json&#039;)
    await fs.writeFile(f, JSON.stringify(this), &#039;utf-8&#039;)
  }

  async getCoverageMap (nyc) {
    if (this[_coverageMap]) {
      return this[_coverageMap]
    }

    const childMaps = await Promise.all(this.nodes.map(child =&gt; child.getCoverageMap(nyc)))

    this[_coverageMap] = await mapMerger(nyc, this.coverageFilename, childMaps)

    return this[_coverageMap]
  }

  get label () {
    if (this[_label]) {
      return this[_label]
    }

    const covInfo = this[_coverageMap]
      ? &#039;\n  &#039; + this[_coverageMap].getCoverageSummary().lines.pct + &#039; % Lines&#039;
      : &#039;&#039;

    return this[_label] = this.argv.join(&#039; &#039;) + covInfo
  }
}

const mapMerger = async (nyc, filename, maps) =&gt; {
  const map = libCoverage.createCoverageMap({})
  if (filename) {
    map.merge(await nyc.coverageFileLoad(filename))
  }
  maps.forEach(otherMap =&gt; map.merge(otherMap))
  return map
}

// Operations on the processinfo database as a whole,
// and the root of the tree rendering operation.
class ProcessDB {
  constructor (directory) {
    if (!directory) {
      const nycConfig = process.env.NYC_CONFIG;
      if (nycConfig) {
        directory = resolve(JSON.parse(nycConfig).tempDir, &#039;processinfo&#039;)
      }

      if (!directory) {
        throw new TypeError(&#039;must provide directory argument when outside of NYC&#039;)
      }
    }

    Object.defineProperty(this, &#039;directory&#039;, { get: () =&gt; directory, enumerable: true })
    this.nodes = []
    this[_label] = null
    this[_coverageMap] = null
  }

  get label () {
    if (this[_label]) {
      return this[_label]
    }

    const covInfo = this[_coverageMap]
      ? &#039;\n  &#039; + this[_coverageMap].getCoverageSummary().lines.pct + &#039; % Lines&#039;
      : &#039;&#039;

    return this[_label] = &#039;nyc&#039; + covInfo
  }

  async getCoverageMap (nyc) {
    if (this[_coverageMap]) {
      return this[_coverageMap]
    }

    const childMaps = await Promise.all(this.nodes.map(child =&gt; child.getCoverageMap(nyc)))
    this[_coverageMap] = await mapMerger(nyc, undefined, childMaps)
    return this[_coverageMap]
  }

  async renderTree (nyc) {
    await this.buildProcessTree()
    await this.getCoverageMap(nyc)

    return archy(this)
  }

  async buildProcessTree () {
    const infos = await this.readProcessInfos(this.directory)
    const index = await this.readIndex()
    for (const id in index.processes) {
      const node = infos[id]
      if (!node) {
        throw new Error(`Invalid entry in processinfo index: ${id}`)
      }
      const idx = index.processes[id]
      node.nodes = idx.children.map(id =&gt; infos[id])
        .sort((a, b) =&gt; a.time - b.time)
      if (!node.parent) {
        this.nodes.push(node)
      }
    }
  }

  async _readJSON (file) {
    if (Array.isArray(file)) {
      const result = await pMap(
        file,
        f =&gt; this._readJSON(f),
        { concurrency: 8 }
      )
      return result.filter(Boolean)
    }

    try {
      return JSON.parse(await fs.readFile(resolve(this.directory, file), &#039;utf-8&#039;))
    } catch (error) {
    }
  }

  async readProcessInfos () {
    const files = await fs.readdir(this.directory)
    const fileData = await this._readJSON(files.filter(f =&gt; f !== &#039;index.json&#039;))

    return fromEntries(fileData.map(info =&gt; [
      info.uuid,
      new ProcessInfo(info)
    ]))
  }

  _createIndex (infos) {
    const infoMap = fromEntries(infos.map(info =&gt; [
      info.uuid,
      Object.assign(info, {children: []})
    ]))

    // create all the parent-child links
    infos.forEach(info =&gt; {
      if (info.parent) {
        const parentInfo = infoMap[info.parent]
        if (parentInfo &amp;&amp; !parentInfo.children.includes(info.uuid)) {
          parentInfo.children.push(info.uuid)
        }
      }
    })

    // figure out which files were touched by each process.
    const files = infos.reduce((files, info) =&gt; {
      info.files.forEach(f =&gt; {
        files[f] = files[f] || []
        if (!files[f].includes(info.uuid)) {
          files[f].push(info.uuid)
        }
      })
      return files
    }, {})

    const processes = fromEntries(infos.map(info =&gt; [
      info.uuid,
      {
        parent: info.parent,
        ...(info.externalId ? { externalId: info.externalId } : {}),
        children: Array.from(info.children)
      }
    ]))

    const eidList = new Set()
    const externalIds = fromEntries(infos.filter(info =&gt; info.externalId).map(info =&gt; {
      if (eidList.has(info.externalId)) {
        throw new Error(
          `External ID ${info.externalId} used by multiple processes`)
      }

      eidList.add(info.externalId)

      const children = Array.from(info.children)
      // flatten the descendant sets of all the externalId procs
      // push the next generation onto the list so we accumulate them all
      for (let i = 0; i &lt; children.length; i++) {
        children.push(...processes[children[i]].children.filter(uuid =&gt; !children.includes(uuid)))
      }

      return [
        info.externalId,
        {
          root: info.uuid,
          children
        }
      ]
    }))

    return { processes, files, externalIds }
  }

  async writeIndex () {
    const {directory} = this
    const files = await fs.readdir(directory)
    const infos = await this._readJSON(files.filter(f =&gt; f !== &#039;index.json&#039;))
    const index = this._createIndex(infos)
    const indexFile = resolve(directory, &#039;index.json&#039;)
    await fs.writeFile(indexFile, JSON.stringify(index))

    return index
  }

  async readIndex () {
    return await this._readJSON(&#039;index.json&#039;) || await this.writeIndex()
  }

  // delete all coverage and processinfo for a given process
  // Warning!  Doing this makes the index out of date, so make sure
  // to update it when you&#039;re done!
  // Not multi-process safe, because it cannot be done atomically.
  async expunge (id) {
    const index = await this.readIndex()
    const entry = index.externalIds[id]
    if (!entry) {
      return
    }

    await pMap(
      [].concat(
        `${dirname(this.directory)}/${entry.root}.json`,
        `${this.directory}/${entry.root}.json`,
        ...entry.children.map(c =&gt; [
          `${dirname(this.directory)}/${c}.json`,
          `${this.directory}/${c}.json`
        ])
      ),
      f =&gt; rimraf(f),
      { concurrency: 8 }
    )
  }

  [_spawnArgs] (name, file, args, options) {
    if (!Array.isArray(args)) {
      options = args
      args = []
    }
    if (!options) {
      options = {}
    }

    if (!process.env.NYC_CONFIG) {
      const nyc = options.nyc || &#039;nyc&#039;
      const nycArgs = options.nycArgs || []
      args = [...nycArgs, file, ...args]
      file = nyc
    }

    options.env = {
      ...(options.env || process.env),
      NYC_PROCESSINFO_EXTERNAL_ID: name
    }

    return [name, file, args, options]
  }

  // spawn an externally named process
  async spawn (...spawnArgs) {
    const [name, file, args, options] = this[_spawnArgs](...spawnArgs)
    await this.expunge(name)
    return spawn(file, args, options)
  }
}

exports.ProcessDB = ProcessDB
exports.ProcessInfo = ProcessInfo
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
