<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/mocha/lib/utils.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/mocha/lib/utils.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">699</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.15</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

/**
 * Various utility functions used throughout Mocha&#039;s codebase.
 * @module utils
 */

/**
 * Module dependencies.
 */
var path = require(&#039;node:path&#039;);
var util = require(&#039;node:util&#039;);
var he = require(&#039;he&#039;);

const MOCHA_ID_PROP_NAME = &#039;__mocha_id__&#039;;

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * @param {function} ctor - Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor - Constructor function to inherit prototype from.
 * @throws {TypeError} if either constructor is null, or if super constructor
 *     lacks a prototype.
 */
exports.inherits = util.inherits;

/**
 * Escape special characters in the given string of html.
 *
 * @private
 * @param  {string} html
 * @return {string}
 */
exports.escape = function (html) {
  return he.encode(String(html), {useNamedReferences: false});
};

/**
 * Test if the given obj is type of string.
 *
 * @private
 * @param {Object} obj
 * @return {boolean}
 */
exports.isString = function (obj) {
  return typeof obj === &#039;string&#039;;
};

/**
 * Compute a slug from the given `str`.
 *
 * @private
 * @param {string} str
 * @return {string}
 */
exports.slug = function (str) {
  return str
    .toLowerCase()
    .replace(/\s+/g, &#039;-&#039;)
    .replace(/[^-\w]/g, &#039;&#039;)
    .replace(/-{2,}/g, &#039;-&#039;);
};

/**
 * Strip the function definition from `str`, and re-indent for pre whitespace.
 *
 * @param {string} str
 * @return {string}
 */
exports.clean = function (str) {
  str = str
    .replace(/\r\n?|[\n\u2028\u2029]/g, &#039;\n&#039;)
    .replace(/^\uFEFF/, &#039;&#039;)
    // (traditional)-&gt;  space/name     parameters    body     (lambda)-&gt; parameters       body   multi-statement/single          keep body content
    .replace(
      /^function(?:\s*|\s[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\}$|^\([^)]*\)\s*=&gt;\s*(?:\{((?:.|\n)*?)\}|((?:.|\n)*))$/,
      &#039;$1$2$3&#039;
    );

  var spaces = str.match(/^\n?( *)/)[1].length;
  var tabs = str.match(/^\n?(\t*)/)[1].length;
  var re = new RegExp(
    &#039;^\n?&#039; + (tabs ? &#039;\t&#039; : &#039; &#039;) + &#039;{&#039; + (tabs || spaces) + &#039;}&#039;,
    &#039;gm&#039;
  );

  str = str.replace(re, &#039;&#039;);

  return str.trim();
};

/**
 * If a value could have properties, and has none, this function is called,
 * which returns a string representation of the empty value.
 *
 * Functions w/ no properties return `&#039;[Function]&#039;`
 * Arrays w/ length === 0 return `&#039;[]&#039;`
 * Objects w/ no properties return `&#039;{}&#039;`
 * All else: return result of `value.toString()`
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} typeHint The type of the value
 * @returns {string}
 */
function emptyRepresentation(value, typeHint) {
  switch (typeHint) {
    case &#039;function&#039;:
      return &#039;[Function]&#039;;
    case &#039;object&#039;:
      return &#039;{}&#039;;
    case &#039;array&#039;:
      return &#039;[]&#039;;
    default:
      return value.toString();
  }
}

/**
 * Takes some variable and asks `Object.prototype.toString()` what it thinks it
 * is.
 *
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
 * @param {*} value The value to test.
 * @returns {string} Computed type
 * @example
 * canonicalType({}) // &#039;object&#039;
 * canonicalType([]) // &#039;array&#039;
 * canonicalType(1) // &#039;number&#039;
 * canonicalType(false) // &#039;boolean&#039;
 * canonicalType(Infinity) // &#039;number&#039;
 * canonicalType(null) // &#039;null&#039;
 * canonicalType(new Date()) // &#039;date&#039;
 * canonicalType(/foo/) // &#039;regexp&#039;
 * canonicalType(&#039;type&#039;) // &#039;string&#039;
 * canonicalType(global) // &#039;global&#039;
 * canonicalType(new String(&#039;foo&#039;) // &#039;object&#039;
 * canonicalType(async function() {}) // &#039;asyncfunction&#039;
 * canonicalType(Object.create(null)) // &#039;null-prototype&#039;
 */
var canonicalType = (exports.canonicalType = function canonicalType(value) {
  if (value === undefined) {
    return &#039;undefined&#039;;
  } else if (value === null) {
    return &#039;null&#039;;
  } else if (Buffer.isBuffer(value)) {
    return &#039;buffer&#039;;
  } else if (Object.getPrototypeOf(value) === null) {
    return &#039;null-prototype&#039;;
  }

  return Object.prototype.toString
    .call(value)
    .replace(/^\[.+\s(.+?)]$/, &#039;$1&#039;)
    .toLowerCase();
});

/**
 *
 * Returns a general type or data structure of a variable
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures
 * @param {*} value The value to test.
 * @returns {string} One of undefined, boolean, number, string, bigint, symbol, object
 * @example
 * type({}) // &#039;object&#039;
 * type([]) // &#039;array&#039;
 * type(1) // &#039;number&#039;
 * type(false) // &#039;boolean&#039;
 * type(Infinity) // &#039;number&#039;
 * type(null) // &#039;null&#039;
 * type(new Date()) // &#039;object&#039;
 * type(/foo/) // &#039;object&#039;
 * type(&#039;type&#039;) // &#039;string&#039;
 * type(global) // &#039;object&#039;
 * type(new String(&#039;foo&#039;) // &#039;string&#039;
 */
exports.type = function type(value) {
  // Null is special
  if (value === null) return &#039;null&#039;;
  const primitives = new Set([
    &#039;undefined&#039;,
    &#039;boolean&#039;,
    &#039;number&#039;,
    &#039;string&#039;,
    &#039;bigint&#039;,
    &#039;symbol&#039;
  ]);
  const _type = typeof value;
  if (_type === &#039;function&#039;) return _type;
  if (primitives.has(_type)) return _type;
  if (value instanceof String) return &#039;string&#039;;
  if (value instanceof Error) return &#039;error&#039;;
  if (Array.isArray(value)) return &#039;array&#039;;

  return _type;
};

/**
 * Stringify `value`. Different behavior depending on type of value:
 *
 * - If `value` is undefined or null, return `&#039;[undefined]&#039;` or `&#039;[null]&#039;`, respectively.
 * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.
 * - If `value` is an *empty* object, function, or array, return result of function
 *   {@link emptyRepresentation}.
 * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of
 *   JSON.stringify().
 *
 * @private
 * @see exports.type
 * @param {*} value
 * @return {string}
 */
exports.stringify = function (value) {
  var typeHint = canonicalType(value);

  if (!~[&#039;object&#039;, &#039;array&#039;, &#039;function&#039;, &#039;null-prototype&#039;].indexOf(typeHint)) {
    if (typeHint === &#039;buffer&#039;) {
      var json = Buffer.prototype.toJSON.call(value);
      // Based on the toJSON result
      return jsonStringify(
        json.data &amp;&amp; json.type ? json.data : json,
        2
      ).replace(/,(\n|$)/g, &#039;$1&#039;);
    }

    // IE7/IE8 has a bizarre String constructor; needs to be coerced
    // into an array and back to obj.
    if (typeHint === &#039;string&#039; &amp;&amp; typeof value === &#039;object&#039;) {
      value = value.split(&#039;&#039;).reduce(function (acc, char, idx) {
        acc[idx] = char;
        return acc;
      }, {});
      typeHint = &#039;object&#039;;
    } else {
      return jsonStringify(value);
    }
  }

  for (var prop in value) {
    if (Object.prototype.hasOwnProperty.call(value, prop)) {
      return jsonStringify(
        exports.canonicalize(value, null, typeHint),
        2
      ).replace(/,(\n|$)/g, &#039;$1&#039;);
    }
  }

  return emptyRepresentation(value, typeHint);
};

/**
 * like JSON.stringify but more sense.
 *
 * @private
 * @param {Object}  object
 * @param {number=} spaces
 * @param {number=} depth
 * @returns {*}
 */
function jsonStringify(object, spaces, depth) {
  if (typeof spaces === &#039;undefined&#039;) {
    // primitive types
    return _stringify(object);
  }

  depth = depth || 1;
  var space = spaces * depth;
  var str = Array.isArray(object) ? &#039;[&#039; : &#039;{&#039;;
  var end = Array.isArray(object) ? &#039;]&#039; : &#039;}&#039;;
  var length =
    typeof object.length === &#039;number&#039;
      ? object.length
      : Object.keys(object).length;
  // `.repeat()` polyfill
  function repeat(s, n) {
    return new Array(n).join(s);
  }

  function _stringify(val) {
    switch (canonicalType(val)) {
      case &#039;null&#039;:
      case &#039;undefined&#039;:
        val = &#039;[&#039; + val + &#039;]&#039;;
        break;
      case &#039;array&#039;:
      case &#039;object&#039;:
        val = jsonStringify(val, spaces, depth + 1);
        break;
      case &#039;boolean&#039;:
      case &#039;regexp&#039;:
      case &#039;symbol&#039;:
      case &#039;number&#039;:
        val =
          val === 0 &amp;&amp; 1 / val === -Infinity // `-0`
            ? &#039;-0&#039;
            : val.toString();
        break;
      case &#039;bigint&#039;:
        val = val.toString() + &#039;n&#039;;
        break;
      case &#039;date&#039;:
        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
        val = &#039;[Date: &#039; + sDate + &#039;]&#039;;
        break;
      case &#039;buffer&#039;:
        var json = val.toJSON();
        // Based on the toJSON result
        json = json.data &amp;&amp; json.type ? json.data : json;
        val = &#039;[Buffer: &#039; + jsonStringify(json, 2, depth + 1) + &#039;]&#039;;
        break;
      default:
        val =
          val === &#039;[Function]&#039; || val === &#039;[Circular]&#039;
            ? val
            : JSON.stringify(val); // string
    }
    return val;
  }

  for (var i in object) {
    if (!Object.prototype.hasOwnProperty.call(object, i)) {
      continue; // not my business
    }
    --length;
    str +=
      &#039;\n &#039; +
      repeat(&#039; &#039;, space) +
      (Array.isArray(object) ? &#039;&#039; : &#039;&quot;&#039; + i + &#039;&quot;: &#039;) + // key
      _stringify(object[i]) + // value
      (length ? &#039;,&#039; : &#039;&#039;); // comma
  }

  return (
    str +
    // [], {}
    (str.length !== 1 ? &#039;\n&#039; + repeat(&#039; &#039;, --space) + end : end)
  );
}

/**
 * Return a new Thing that has the keys in sorted order. Recursive.
 *
 * If the Thing...
 * - has already been seen, return string `&#039;[Circular]&#039;`
 * - is `undefined`, return string `&#039;[undefined]&#039;`
 * - is `null`, return value `null`
 * - is some other primitive, return the value
 * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing&#039;s `toString()` method
 * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.
 * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`
 *
 * @private
 * @see {@link exports.stringify}
 * @param {*} value Thing to inspect.  May or may not have properties.
 * @param {Array} [stack=[]] Stack of seen values
 * @param {string} [typeHint] Type hint
 * @return {(Object|Array|Function|string|undefined)}
 */
exports.canonicalize = function canonicalize(value, stack, typeHint) {
  var canonicalizedObj;
  /* eslint-disable no-unused-vars */
  var prop;
  /* eslint-enable no-unused-vars */
  typeHint = typeHint || canonicalType(value);
  function withStack(value, fn) {
    stack.push(value);
    fn();
    stack.pop();
  }

  stack = stack || [];

  if (stack.indexOf(value) !== -1) {
    return &#039;[Circular]&#039;;
  }

  switch (typeHint) {
    case &#039;undefined&#039;:
    case &#039;buffer&#039;:
    case &#039;null&#039;:
      canonicalizedObj = value;
      break;
    case &#039;array&#039;:
      withStack(value, function () {
        canonicalizedObj = value.map(function (item) {
          return exports.canonicalize(item, stack);
        });
      });
      break;
    case &#039;function&#039;:
      /* eslint-disable-next-line no-unused-vars, no-unreachable-loop */
      for (prop in value) {
        canonicalizedObj = {};
        break;
      }
      /* eslint-enable guard-for-in */
      if (!canonicalizedObj) {
        canonicalizedObj = emptyRepresentation(value, typeHint);
        break;
      }
    /* falls through */
    case &#039;null-prototype&#039;:
    case &#039;object&#039;:
      canonicalizedObj = canonicalizedObj || {};
      if (typeHint === &#039;null-prototype&#039; &amp;&amp; Symbol.toStringTag in value) {
        canonicalizedObj[&#039;[Symbol.toStringTag]&#039;] = value[Symbol.toStringTag];
      }
      withStack(value, function () {
        Object.keys(value)
          .sort()
          .forEach(function (key) {
            canonicalizedObj[key] = exports.canonicalize(value[key], stack);
          });
      });
      break;
    case &#039;date&#039;:
    case &#039;number&#039;:
    case &#039;regexp&#039;:
    case &#039;boolean&#039;:
    case &#039;symbol&#039;:
      canonicalizedObj = value;
      break;
    default:
      canonicalizedObj = value + &#039;&#039;;
  }

  return canonicalizedObj;
};

/**
 * @summary
 * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)
 * @description
 * When invoking this function you get a filter function that get the Error.stack as an input,
 * and return a prettify output.
 * (i.e: strip Mocha and internal node functions from stack trace).
 * @returns {Function}
 */
exports.stackTraceFilter = function () {
  // TODO: Replace with `process.browser`
  var is = typeof document === &#039;undefined&#039; ? {node: true} : {browser: true};
  var slash = path.sep;
  var cwd;
  if (is.node) {
    cwd = exports.cwd() + slash;
  } else {
    cwd = (
      typeof location === &#039;undefined&#039; ? window.location : location
    ).href.replace(/\/[^/]*$/, &#039;/&#039;);
    slash = &#039;/&#039;;
  }

  function isMochaInternal(line) {
    return (
      ~line.indexOf(&#039;node_modules&#039; + slash + &#039;mocha&#039; + slash) ||
      ~line.indexOf(slash + &#039;mocha.js&#039;) ||
      ~line.indexOf(slash + &#039;mocha.min.js&#039;)
    );
  }

  function isNodeInternal(line) {
    return (
      ~line.indexOf(&#039;(timers.js:&#039;) ||
      ~line.indexOf(&#039;(events.js:&#039;) ||
      ~line.indexOf(&#039;(node.js:&#039;) ||
      ~line.indexOf(&#039;(module.js:&#039;) ||
      ~line.indexOf(&#039;GeneratorFunctionPrototype.next (native)&#039;) ||
      false
    );
  }

  return function (stack) {
    stack = stack.split(&#039;\n&#039;);

    stack = stack.reduce(function (list, line) {
      if (isMochaInternal(line)) {
        return list;
      }

      if (is.node &amp;&amp; isNodeInternal(line)) {
        return list;
      }

      // Clean up cwd(absolute)
      if (/:\d+:\d+\)?$/.test(line)) {
        line = line.replace(&#039;(&#039; + cwd, &#039;(&#039;);
      }

      list.push(line);
      return list;
    }, []);

    return stack.join(&#039;\n&#039;);
  };
};

/**
 * Crude, but effective.
 * @public
 * @param {*} value
 * @returns {boolean} Whether or not `value` is a Promise
 */
exports.isPromise = function isPromise(value) {
  return (
    typeof value === &#039;object&#039; &amp;&amp;
    value !== null &amp;&amp;
    typeof value.then === &#039;function&#039;
  );
};

/**
 * Clamps a numeric value to an inclusive range.
 *
 * @param {number} value - Value to be clamped.
 * @param {number[]} range - Two element array specifying [min, max] range.
 * @returns {number} clamped value
 */
exports.clamp = function clamp(value, range) {
  return Math.min(Math.max(value, range[0]), range[1]);
};

/**
 * It&#039;s a noop.
 * @public
 */
exports.noop = function () {};

/**
 * Creates a map-like object.
 *
 * @description
 * A &quot;map&quot; is an object with no prototype, for our purposes. In some cases
 * this would be more appropriate than a `Map`, especially if your environment
 * doesn&#039;t support it. Recommended for use in Mocha&#039;s public APIs.
 *
 * @public
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Custom_and_Null_objects|MDN:Map}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Custom_and_Null_objects|MDN:Object.create - Custom objects}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Custom_and_Null_objects|MDN:Object.assign}
 * @param {...*} [obj] - Arguments to `Object.assign()`.
 * @returns {Object} An object with no prototype, having `...obj` properties
 */
exports.createMap = function (obj) {
  return Object.assign.apply(
    null,
    [Object.create(null)].concat(Array.prototype.slice.call(arguments))
  );
};

/**
 * Creates a read-only map-like object.
 *
 * @description
 * This differs from {@link module:utils.createMap createMap} only in that
 * the argument must be non-empty, because the result is frozen.
 *
 * @see {@link module:utils.createMap createMap}
 * @param {...*} [obj] - Arguments to `Object.assign()`.
 * @returns {Object} A frozen object with no prototype, having `...obj` properties
 * @throws {TypeError} if argument is not a non-empty object.
 */
exports.defineConstants = function (obj) {
  if (canonicalType(obj) !== &#039;object&#039; || !Object.keys(obj).length) {
    throw new TypeError(&#039;Invalid argument; expected a non-empty object&#039;);
  }
  return Object.freeze(exports.createMap(obj));
};

/**
 * Returns current working directory
 *
 * Wrapper around `process.cwd()` for isolation
 * @private
 */
exports.cwd = function cwd() {
  return process.cwd();
};

/**
 * Returns `true` if Mocha is running in a browser.
 * Checks for `process.browser`.
 * @returns {boolean}
 * @private
 */
exports.isBrowser = function isBrowser() {
  return Boolean(process.browser);
};

/*
 * Casts `value` to an array; useful for optionally accepting array parameters
 *
 * It follows these rules, depending on `value`.  If `value` is...
 * 1. `undefined`: return an empty Array
 * 2. `null`: return an array with a single `null` element
 * 3. Any other object: return the value of `Array.from()` _if_ the object is iterable
 * 4. otherwise: return an array with a single element, `value`
 * @param {*} value - Something to cast to an Array
 * @returns {Array&lt;*&gt;}
 */
exports.castArray = function castArray(value) {
  if (value === undefined) {
    return [];
  }
  if (value === null) {
    return [null];
  }
  if (
    typeof value === &#039;object&#039; &amp;&amp;
    (typeof value[Symbol.iterator] === &#039;function&#039; || value.length !== undefined)
  ) {
    return Array.from(value);
  }
  return [value];
};

exports.constants = exports.defineConstants({
  MOCHA_ID_PROP_NAME
});

const uniqueIDBase =
  &#039;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_&#039;;

/**
 * Creates a new unique identifier
 * Does not create cryptographically safe ids.
 * Trivial copy of nanoid/non-secure
 * @returns {string} Unique identifier
 */
exports.uniqueID = () =&gt; {
  let id = &#039;&#039;;
  for (let i = 0; i &lt; 21; i++) {
    id += uniqueIDBase[(Math.random() * 64) | 0];
  }
  return id;
};

exports.assignNewMochaID = obj =&gt; {
  const id = exports.uniqueID();
  Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {
    get() {
      return id;
    }
  });
  return obj;
};

/**
 * Retrieves a Mocha ID from an object, if present.
 * @param {*} [obj] - Object
 * @returns {string|void}
 */
exports.getMochaID = obj =&gt;
  obj &amp;&amp; typeof obj === &#039;object&#039; ? obj[MOCHA_ID_PROP_NAME] : undefined;

/**
 * Replaces any detected circular dependency with the string &#039;[Circular]&#039;
 * Mutates original object
 * @param inputObj {*}
 * @returns {*}
 */
exports.breakCircularDeps = inputObj =&gt; {
  const seen = new Set();

  function _breakCircularDeps(obj) {
    if (obj &amp;&amp; typeof obj !== &#039;object&#039;) {
      return obj;
    }

    if (seen.has(obj)) {
      return &#039;[Circular]&#039;;
    }

    seen.add(obj);
    for (const k in obj) {
      const descriptor = Object.getOwnPropertyDescriptor(obj, k);

      if (descriptor &amp;&amp; descriptor.writable) {
        obj[k] = _breakCircularDeps(obj[k], k);
      }
    }

    // deleting means only a seen object that is its own child will be detected
    seen.delete(obj);
    return obj;
  }

  return _breakCircularDeps(inputObj);
};

/**
 * Checks if provided input can be parsed as a JavaScript Number.
 */
exports.isNumeric = input =&gt; {
  return !isNaN(parseFloat(input));
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
