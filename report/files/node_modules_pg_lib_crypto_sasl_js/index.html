<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pg/lib/crypto/sasl.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pg/lib/crypto/sasl.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">213</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">34.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.03</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;
const crypto = require(&#039;./utils&#039;)
const { signatureAlgorithmHashFromCertificate } = require(&#039;./cert-signatures&#039;)

function startSession(mechanisms, stream) {
  const candidates = [&#039;SCRAM-SHA-256&#039;]
  if (stream) candidates.unshift(&#039;SCRAM-SHA-256-PLUS&#039;) // higher-priority, so placed first

  const mechanism = candidates.find((candidate) =&gt; mechanisms.includes(candidate))

  if (!mechanism) {
    throw new Error(&#039;SASL: Only mechanism(s) &#039; + candidates.join(&#039; and &#039;) + &#039; are supported&#039;)
  }

  if (mechanism === &#039;SCRAM-SHA-256-PLUS&#039; &amp;&amp; typeof stream.getPeerCertificate !== &#039;function&#039;) {
    // this should never happen if we are really talking to a Postgres server
    throw new Error(&#039;SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate&#039;)
  }

  const clientNonce = crypto.randomBytes(18).toString(&#039;base64&#039;)
  const gs2Header = mechanism === &#039;SCRAM-SHA-256-PLUS&#039; ? &#039;p=tls-server-end-point&#039; : stream ? &#039;y&#039; : &#039;n&#039;

  return {
    mechanism,
    clientNonce,
    response: gs2Header + &#039;,,n=*,r=&#039; + clientNonce,
    message: &#039;SASLInitialResponse&#039;,
  }
}

async function continueSession(session, password, serverData, stream) {
  if (session.message !== &#039;SASLInitialResponse&#039;) {
    throw new Error(&#039;SASL: Last message was not SASLInitialResponse&#039;)
  }
  if (typeof password !== &#039;string&#039;) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string&#039;)
  }
  if (password === &#039;&#039;) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string&#039;)
  }
  if (typeof serverData !== &#039;string&#039;) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string&#039;)
  }

  const sv = parseServerFirstMessage(serverData)

  if (!sv.nonce.startsWith(session.clientNonce)) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce&#039;)
  } else if (sv.nonce.length === session.clientNonce.length) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short&#039;)
  }

  const clientFirstMessageBare = &#039;n=*,r=&#039; + session.clientNonce
  const serverFirstMessage = &#039;r=&#039; + sv.nonce + &#039;,s=&#039; + sv.salt + &#039;,i=&#039; + sv.iteration

  // without channel binding:
  let channelBinding = stream ? &#039;eSws&#039; : &#039;biws&#039; // &#039;y,,&#039; or &#039;n,,&#039;, base64-encoded

  // override if channel binding is in use:
  if (session.mechanism === &#039;SCRAM-SHA-256-PLUS&#039;) {
    const peerCert = stream.getPeerCertificate().raw
    let hashName = signatureAlgorithmHashFromCertificate(peerCert)
    if (hashName === &#039;MD5&#039; || hashName === &#039;SHA-1&#039;) hashName = &#039;SHA-256&#039;
    const certHash = await crypto.hashByName(hashName, peerCert)
    const bindingData = Buffer.concat([Buffer.from(&#039;p=tls-server-end-point,,&#039;), Buffer.from(certHash)])
    channelBinding = bindingData.toString(&#039;base64&#039;)
  }

  const clientFinalMessageWithoutProof = &#039;c=&#039; + channelBinding + &#039;,r=&#039; + sv.nonce
  const authMessage = clientFirstMessageBare + &#039;,&#039; + serverFirstMessage + &#039;,&#039; + clientFinalMessageWithoutProof

  const saltBytes = Buffer.from(sv.salt, &#039;base64&#039;)
  const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration)
  const clientKey = await crypto.hmacSha256(saltedPassword, &#039;Client Key&#039;)
  const storedKey = await crypto.sha256(clientKey)
  const clientSignature = await crypto.hmacSha256(storedKey, authMessage)
  const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString(&#039;base64&#039;)
  const serverKey = await crypto.hmacSha256(saltedPassword, &#039;Server Key&#039;)
  const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage)

  session.message = &#039;SASLResponse&#039;
  session.serverSignature = Buffer.from(serverSignatureBytes).toString(&#039;base64&#039;)
  session.response = clientFinalMessageWithoutProof + &#039;,p=&#039; + clientProof
}

function finalizeSession(session, serverData) {
  if (session.message !== &#039;SASLResponse&#039;) {
    throw new Error(&#039;SASL: Last message was not SASLResponse&#039;)
  }
  if (typeof serverData !== &#039;string&#039;) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string&#039;)
  }

  const { serverSignature } = parseServerFinalMessage(serverData)

  if (serverSignature !== session.serverSignature) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match&#039;)
  }
}

/**
 * printable       = %x21-2B / %x2D-7E
 *                   ;; Printable ASCII except &quot;,&quot;.
 *                   ;; Note that any &quot;printable&quot; is also
 *                   ;; a valid &quot;value&quot;.
 */
function isPrintableChars(text) {
  if (typeof text !== &#039;string&#039;) {
    throw new TypeError(&#039;SASL: text must be a string&#039;)
  }
  return text
    .split(&#039;&#039;)
    .map((_, i) =&gt; text.charCodeAt(i))
    .every((c) =&gt; (c &gt;= 0x21 &amp;&amp; c &lt;= 0x2b) || (c &gt;= 0x2d &amp;&amp; c &lt;= 0x7e))
}

/**
 * base64-char     = ALPHA / DIGIT / &quot;/&quot; / &quot;+&quot;
 *
 * base64-4        = 4base64-char
 *
 * base64-3        = 3base64-char &quot;=&quot;
 *
 * base64-2        = 2base64-char &quot;==&quot;
 *
 * base64          = *base64-4 [base64-3 / base64-2]
 */
function isBase64(text) {
  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text)
}

function parseAttributePairs(text) {
  if (typeof text !== &#039;string&#039;) {
    throw new TypeError(&#039;SASL: attribute pairs text must be a string&#039;)
  }

  return new Map(
    text.split(&#039;,&#039;).map((attrValue) =&gt; {
      if (!/^.=/.test(attrValue)) {
        throw new Error(&#039;SASL: Invalid attribute pair entry&#039;)
      }
      const name = attrValue[0]
      const value = attrValue.substring(2)
      return [name, value]
    })
  )
}

function parseServerFirstMessage(data) {
  const attrPairs = parseAttributePairs(data)

  const nonce = attrPairs.get(&#039;r&#039;)
  if (!nonce) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing&#039;)
  } else if (!isPrintableChars(nonce)) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters&#039;)
  }
  const salt = attrPairs.get(&#039;s&#039;)
  if (!salt) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing&#039;)
  } else if (!isBase64(salt)) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64&#039;)
  }
  const iterationText = attrPairs.get(&#039;i&#039;)
  if (!iterationText) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing&#039;)
  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count&#039;)
  }
  const iteration = parseInt(iterationText, 10)

  return {
    nonce,
    salt,
    iteration,
  }
}

function parseServerFinalMessage(serverData) {
  const attrPairs = parseAttributePairs(serverData)
  const serverSignature = attrPairs.get(&#039;v&#039;)
  if (!serverSignature) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing&#039;)
  } else if (!isBase64(serverSignature)) {
    throw new Error(&#039;SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64&#039;)
  }
  return {
    serverSignature,
  }
}

function xorBuffers(a, b) {
  if (!Buffer.isBuffer(a)) {
    throw new TypeError(&#039;first argument must be a Buffer&#039;)
  }
  if (!Buffer.isBuffer(b)) {
    throw new TypeError(&#039;second argument must be a Buffer&#039;)
  }
  if (a.length !== b.length) {
    throw new Error(&#039;Buffer lengths must match&#039;)
  }
  if (a.length === 0) {
    throw new Error(&#039;Buffers cannot be empty&#039;)
  }
  return Buffer.from(a.map((_, i) =&gt; a[i] ^ b[i]))
}

module.exports = {
  startSession,
  continueSession,
  finalizeSession,
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
