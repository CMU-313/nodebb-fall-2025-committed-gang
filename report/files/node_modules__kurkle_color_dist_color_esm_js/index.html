<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@kurkle/color/dist/color.esm.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@kurkle/color/dist/color.esm.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">590</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">79.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) =&gt; Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function b2p(v) {
  return lim(round(v / 2.55), 0, 100);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}

const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = [...&#039;0123456789ABCDEF&#039;];
const h1 = b =&gt; hex[b &amp; 0xF];
const h2 = b =&gt; hex[(b &amp; 0xF0) &gt;&gt; 4] + hex[b &amp; 0xF];
const eq = b =&gt; ((b &amp; 0xF0) &gt;&gt; 4) === (b &amp; 0xF);
const isShort = v =&gt; eq(v.r) &amp;&amp; eq(v.g) &amp;&amp; eq(v.b) &amp;&amp; eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === &#039;#&#039;) {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 &amp; map$1[str[1]] * 17,
        g: 255 &amp; map$1[str[2]] * 17,
        b: 255 &amp; map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] &lt;&lt; 4 | map$1[str[2]],
        g: map$1[str[3]] &lt;&lt; 4 | map$1[str[4]],
        b: map$1[str[5]] &lt;&lt; 4 | map$1[str[6]],
        a: len === 9 ? (map$1[str[7]] &lt;&lt; 4 | map$1[str[8]]) : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) =&gt; a &lt; 255 ? f(a) : &#039;&#039;;
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v
    ? &#039;#&#039; + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
    : undefined;
}

const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) =&gt; l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) =&gt; v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b &gt; 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i &lt; 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return ((g - b) / d) + (g &lt; b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (
    Array.isArray(a)
      ? f(a[0], a[1], a[2])
      : f(a, b, c)
  ).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === &#039;hwb&#039;) {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === &#039;hsv&#039;) {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a &lt; 255
    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
    : `hsl(${h}, ${s}%, ${l}%)`;
}

const map = {
	x: &#039;dark&#039;,
	Z: &#039;light&#039;,
	Y: &#039;re&#039;,
	X: &#039;blu&#039;,
	W: &#039;gr&#039;,
	V: &#039;medium&#039;,
	U: &#039;slate&#039;,
	A: &#039;ee&#039;,
	T: &#039;ol&#039;,
	S: &#039;or&#039;,
	B: &#039;ra&#039;,
	C: &#039;lateg&#039;,
	D: &#039;ights&#039;,
	R: &#039;in&#039;,
	Q: &#039;turquois&#039;,
	E: &#039;hi&#039;,
	P: &#039;ro&#039;,
	O: &#039;al&#039;,
	N: &#039;le&#039;,
	M: &#039;de&#039;,
	L: &#039;yello&#039;,
	F: &#039;en&#039;,
	K: &#039;ch&#039;,
	G: &#039;arks&#039;,
	H: &#039;ea&#039;,
	I: &#039;ightg&#039;,
	J: &#039;wh&#039;
};
const names$1 = {
	OiceXe: &#039;f0f8ff&#039;,
	antiquewEte: &#039;faebd7&#039;,
	aqua: &#039;ffff&#039;,
	aquamarRe: &#039;7fffd4&#039;,
	azuY: &#039;f0ffff&#039;,
	beige: &#039;f5f5dc&#039;,
	bisque: &#039;ffe4c4&#039;,
	black: &#039;0&#039;,
	blanKedOmond: &#039;ffebcd&#039;,
	Xe: &#039;ff&#039;,
	XeviTet: &#039;8a2be2&#039;,
	bPwn: &#039;a52a2a&#039;,
	burlywood: &#039;deb887&#039;,
	caMtXe: &#039;5f9ea0&#039;,
	KartYuse: &#039;7fff00&#039;,
	KocTate: &#039;d2691e&#039;,
	cSO: &#039;ff7f50&#039;,
	cSnflowerXe: &#039;6495ed&#039;,
	cSnsilk: &#039;fff8dc&#039;,
	crimson: &#039;dc143c&#039;,
	cyan: &#039;ffff&#039;,
	xXe: &#039;8b&#039;,
	xcyan: &#039;8b8b&#039;,
	xgTMnPd: &#039;b8860b&#039;,
	xWay: &#039;a9a9a9&#039;,
	xgYF: &#039;6400&#039;,
	xgYy: &#039;a9a9a9&#039;,
	xkhaki: &#039;bdb76b&#039;,
	xmagFta: &#039;8b008b&#039;,
	xTivegYF: &#039;556b2f&#039;,
	xSange: &#039;ff8c00&#039;,
	xScEd: &#039;9932cc&#039;,
	xYd: &#039;8b0000&#039;,
	xsOmon: &#039;e9967a&#039;,
	xsHgYF: &#039;8fbc8f&#039;,
	xUXe: &#039;483d8b&#039;,
	xUWay: &#039;2f4f4f&#039;,
	xUgYy: &#039;2f4f4f&#039;,
	xQe: &#039;ced1&#039;,
	xviTet: &#039;9400d3&#039;,
	dAppRk: &#039;ff1493&#039;,
	dApskyXe: &#039;bfff&#039;,
	dimWay: &#039;696969&#039;,
	dimgYy: &#039;696969&#039;,
	dodgerXe: &#039;1e90ff&#039;,
	fiYbrick: &#039;b22222&#039;,
	flSOwEte: &#039;fffaf0&#039;,
	foYstWAn: &#039;228b22&#039;,
	fuKsia: &#039;ff00ff&#039;,
	gaRsbSo: &#039;dcdcdc&#039;,
	ghostwEte: &#039;f8f8ff&#039;,
	gTd: &#039;ffd700&#039;,
	gTMnPd: &#039;daa520&#039;,
	Way: &#039;808080&#039;,
	gYF: &#039;8000&#039;,
	gYFLw: &#039;adff2f&#039;,
	gYy: &#039;808080&#039;,
	honeyMw: &#039;f0fff0&#039;,
	hotpRk: &#039;ff69b4&#039;,
	RdianYd: &#039;cd5c5c&#039;,
	Rdigo: &#039;4b0082&#039;,
	ivSy: &#039;fffff0&#039;,
	khaki: &#039;f0e68c&#039;,
	lavFMr: &#039;e6e6fa&#039;,
	lavFMrXsh: &#039;fff0f5&#039;,
	lawngYF: &#039;7cfc00&#039;,
	NmoncEffon: &#039;fffacd&#039;,
	ZXe: &#039;add8e6&#039;,
	ZcSO: &#039;f08080&#039;,
	Zcyan: &#039;e0ffff&#039;,
	ZgTMnPdLw: &#039;fafad2&#039;,
	ZWay: &#039;d3d3d3&#039;,
	ZgYF: &#039;90ee90&#039;,
	ZgYy: &#039;d3d3d3&#039;,
	ZpRk: &#039;ffb6c1&#039;,
	ZsOmon: &#039;ffa07a&#039;,
	ZsHgYF: &#039;20b2aa&#039;,
	ZskyXe: &#039;87cefa&#039;,
	ZUWay: &#039;778899&#039;,
	ZUgYy: &#039;778899&#039;,
	ZstAlXe: &#039;b0c4de&#039;,
	ZLw: &#039;ffffe0&#039;,
	lime: &#039;ff00&#039;,
	limegYF: &#039;32cd32&#039;,
	lRF: &#039;faf0e6&#039;,
	magFta: &#039;ff00ff&#039;,
	maPon: &#039;800000&#039;,
	VaquamarRe: &#039;66cdaa&#039;,
	VXe: &#039;cd&#039;,
	VScEd: &#039;ba55d3&#039;,
	VpurpN: &#039;9370db&#039;,
	VsHgYF: &#039;3cb371&#039;,
	VUXe: &#039;7b68ee&#039;,
	VsprRggYF: &#039;fa9a&#039;,
	VQe: &#039;48d1cc&#039;,
	VviTetYd: &#039;c71585&#039;,
	midnightXe: &#039;191970&#039;,
	mRtcYam: &#039;f5fffa&#039;,
	mistyPse: &#039;ffe4e1&#039;,
	moccasR: &#039;ffe4b5&#039;,
	navajowEte: &#039;ffdead&#039;,
	navy: &#039;80&#039;,
	Tdlace: &#039;fdf5e6&#039;,
	Tive: &#039;808000&#039;,
	TivedBb: &#039;6b8e23&#039;,
	Sange: &#039;ffa500&#039;,
	SangeYd: &#039;ff4500&#039;,
	ScEd: &#039;da70d6&#039;,
	pOegTMnPd: &#039;eee8aa&#039;,
	pOegYF: &#039;98fb98&#039;,
	pOeQe: &#039;afeeee&#039;,
	pOeviTetYd: &#039;db7093&#039;,
	papayawEp: &#039;ffefd5&#039;,
	pHKpuff: &#039;ffdab9&#039;,
	peru: &#039;cd853f&#039;,
	pRk: &#039;ffc0cb&#039;,
	plum: &#039;dda0dd&#039;,
	powMrXe: &#039;b0e0e6&#039;,
	purpN: &#039;800080&#039;,
	YbeccapurpN: &#039;663399&#039;,
	Yd: &#039;ff0000&#039;,
	Psybrown: &#039;bc8f8f&#039;,
	PyOXe: &#039;4169e1&#039;,
	saddNbPwn: &#039;8b4513&#039;,
	sOmon: &#039;fa8072&#039;,
	sandybPwn: &#039;f4a460&#039;,
	sHgYF: &#039;2e8b57&#039;,
	sHshell: &#039;fff5ee&#039;,
	siFna: &#039;a0522d&#039;,
	silver: &#039;c0c0c0&#039;,
	skyXe: &#039;87ceeb&#039;,
	UXe: &#039;6a5acd&#039;,
	UWay: &#039;708090&#039;,
	UgYy: &#039;708090&#039;,
	snow: &#039;fffafa&#039;,
	sprRggYF: &#039;ff7f&#039;,
	stAlXe: &#039;4682b4&#039;,
	tan: &#039;d2b48c&#039;,
	teO: &#039;8080&#039;,
	tEstN: &#039;d8bfd8&#039;,
	tomato: &#039;ff6347&#039;,
	Qe: &#039;40e0d0&#039;,
	viTet: &#039;ee82ee&#039;,
	JHt: &#039;f5deb3&#039;,
	wEte: &#039;ffffff&#039;,
	wEtesmoke: &#039;f5f5f5&#039;,
	Lw: &#039;ffff00&#039;,
	LwgYF: &#039;9acd32&#039;
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i &lt; keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j &lt; tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k &gt;&gt; 16 &amp; 0xFF, k &gt;&gt; 8 &amp; 0xFF, k &amp; 0xFF];
  }
  return unpacked;
}

let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a &amp;&amp; {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}

const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 &amp; (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 &amp; (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 &amp; (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function rgbString(v) {
  return v &amp;&amp; (
    v.a &lt; 255
      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
      : `rgb(${v.r}, ${v.g}, ${v.b})`
  );
}

const to = v =&gt; v &lt;= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const from = v =&gt; v &lt;= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}

function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = {r: 0, g: 0, b: 0, a: 255};
  if (Array.isArray(input)) {
    if (input.length &gt;= 3) {
      v = {r: input[0], g: input[1], b: input[2], a: 255};
      if (input.length &gt; 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, {r: 0, g: 0, b: 0, a: 1});
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === &#039;r&#039;) {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === &#039;object&#039;) {
      v = fromObject(input);
    } else if (type === &#039;string&#039;) {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }
  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF &amp; w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF &amp; w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF &amp; w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate(this._rgb, color._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}

function index_esm(input) {
  return new Color(input);
}

export { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
