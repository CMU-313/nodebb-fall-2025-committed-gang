<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/core/lib/vendor/import-meta-resolve.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/core/lib/vendor/import-meta-resolve.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.19</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1043</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">134.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">16.33</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.moduleResolve = moduleResolve;
exports.resolve = resolve;
function _assert() {
  const data = require(&quot;assert&quot;);
  _assert = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = _interopRequireWildcard(require(&quot;fs&quot;), true);
  _fs = function () {
    return data;
  };
  return data;
}
function _process() {
  const data = require(&quot;process&quot;);
  _process = function () {
    return data;
  };
  return data;
}
function _url() {
  const data = require(&quot;url&quot;);
  _url = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require(&quot;path&quot;);
  _path = function () {
    return data;
  };
  return data;
}
function _module() {
  const data = require(&quot;module&quot;);
  _module = function () {
    return data;
  };
  return data;
}
function _v() {
  const data = require(&quot;v8&quot;);
  _v = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require(&quot;util&quot;);
  _util = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard(e, t) { if (&quot;function&quot; == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t &amp;&amp; e &amp;&amp; e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || &quot;object&quot; != typeof e &amp;&amp; &quot;function&quot; != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) &quot;default&quot; !== t &amp;&amp; {}.hasOwnProperty.call(e, t) &amp;&amp; ((i = (o = Object.defineProperty) &amp;&amp; Object.getOwnPropertyDescriptor(e, t)) &amp;&amp; (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = new Set([&#039;string&#039;, &#039;function&#039;, &#039;number&#039;, &#039;object&#039;, &#039;Function&#039;, &#039;Object&#039;, &#039;boolean&#039;, &#039;bigint&#039;, &#039;symbol&#039;]);
const codes = {};
function formatList(array, type = &#039;and&#039;) {
  return array.length &lt; 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(&#039;, &#039;)}, ${type} ${array[array.length - 1]}`;
}
const messages = new Map();
const nodeInternalPrefix = &#039;__node_internal_&#039;;
let userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(&#039;ERR_INVALID_ARG_TYPE&#039;, (name, expected, actual) =&gt; {
  _assert()(typeof name === &#039;string&#039;, &quot;&#039;name&#039; must be a string&quot;);
  if (!Array.isArray(expected)) {
    expected = [expected];
  }
  let message = &#039;The &#039;;
  if (name.endsWith(&#039; argument&#039;)) {
    message += `${name} `;
  } else {
    const type = name.includes(&#039;.&#039;) ? &#039;property&#039; : &#039;argument&#039;;
    message += `&quot;${name}&quot; ${type} `;
  }
  message += &#039;must be &#039;;
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    _assert()(typeof value === &#039;string&#039;, &#039;All expected entries have to be of type string&#039;);
    if (kTypes.has(value)) {
      types.push(value.toLowerCase());
    } else if (classRegExp.exec(value) === null) {
      _assert()(value !== &#039;object&#039;, &#039;The value &quot;object&quot; should be written as &quot;Object&quot;&#039;);
      other.push(value);
    } else {
      instances.push(value);
    }
  }
  if (instances.length &gt; 0) {
    const pos = types.indexOf(&#039;object&#039;);
    if (pos !== -1) {
      types.slice(pos, 1);
      instances.push(&#039;Object&#039;);
    }
  }
  if (types.length &gt; 0) {
    message += `${types.length &gt; 1 ? &#039;one of type&#039; : &#039;of type&#039;} ${formatList(types, &#039;or&#039;)}`;
    if (instances.length &gt; 0 || other.length &gt; 0) message += &#039; or &#039;;
  }
  if (instances.length &gt; 0) {
    message += `an instance of ${formatList(instances, &#039;or&#039;)}`;
    if (other.length &gt; 0) message += &#039; or &#039;;
  }
  if (other.length &gt; 0) {
    if (other.length &gt; 1) {
      message += `one of ${formatList(other, &#039;or&#039;)}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) message += &#039;an &#039;;
      message += `${other[0]}`;
    }
  }
  message += `. Received ${determineSpecificType(actual)}`;
  return message;
}, TypeError);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(&#039;ERR_INVALID_MODULE_SPECIFIER&#039;, (request, reason, base = undefined) =&gt; {
  return `Invalid module &quot;${request}&quot; ${reason}${base ? ` imported from ${base}` : &#039;&#039;}`;
}, TypeError);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(&#039;ERR_INVALID_PACKAGE_CONFIG&#039;, (path, base, message) =&gt; {
  return `Invalid package config ${path}${base ? ` while importing ${base}` : &#039;&#039;}${message ? `. ${message}` : &#039;&#039;}`;
}, Error);
codes.ERR_INVALID_PACKAGE_TARGET = createError(&#039;ERR_INVALID_PACKAGE_TARGET&#039;, (packagePath, key, target, isImport = false, base = undefined) =&gt; {
  const relatedError = typeof target === &#039;string&#039; &amp;&amp; !isImport &amp;&amp; target.length &gt; 0 &amp;&amp; !target.startsWith(&#039;./&#039;);
  if (key === &#039;.&#039;) {
    _assert()(isImport === false);
    return `Invalid &quot;exports&quot; main target ${JSON.stringify(target)} defined ` + `in the package config ${packagePath}package.json${base ? ` imported from ${base}` : &#039;&#039;}${relatedError ? &#039;; targets must start with &quot;./&quot;&#039; : &#039;&#039;}`;
  }
  return `Invalid &quot;${isImport ? &#039;imports&#039; : &#039;exports&#039;}&quot; target ${JSON.stringify(target)} defined for &#039;${key}&#039; in the package config ${packagePath}package.json${base ? ` imported from ${base}` : &#039;&#039;}${relatedError ? &#039;; targets must start with &quot;./&quot;&#039; : &#039;&#039;}`;
}, Error);
codes.ERR_MODULE_NOT_FOUND = createError(&#039;ERR_MODULE_NOT_FOUND&#039;, (path, base, exactUrl = false) =&gt; {
  return `Cannot find ${exactUrl ? &#039;module&#039; : &#039;package&#039;} &#039;${path}&#039; imported from ${base}`;
}, Error);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(&#039;ERR_NETWORK_IMPORT_DISALLOWED&#039;, &quot;import of &#039;%s&#039; by %s is not supported: %s&quot;, Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(&#039;ERR_PACKAGE_IMPORT_NOT_DEFINED&#039;, (specifier, packagePath, base) =&gt; {
  return `Package import specifier &quot;${specifier}&quot; is not defined${packagePath ? ` in package ${packagePath}package.json` : &#039;&#039;} imported from ${base}`;
}, TypeError);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(&#039;ERR_PACKAGE_PATH_NOT_EXPORTED&#039;, (packagePath, subpath, base = undefined) =&gt; {
  if (subpath === &#039;.&#039;) return `No &quot;exports&quot; main defined in ${packagePath}package.json${base ? ` imported from ${base}` : &#039;&#039;}`;
  return `Package subpath &#039;${subpath}&#039; is not defined by &quot;exports&quot; in ${packagePath}package.json${base ? ` imported from ${base}` : &#039;&#039;}`;
}, Error);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(&#039;ERR_UNSUPPORTED_DIR_IMPORT&#039;, &quot;Directory import &#039;%s&#039; is not supported &quot; + &#039;resolving ES modules imported from %s&#039;, Error);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(&#039;ERR_UNSUPPORTED_RESOLVE_REQUEST&#039;, &#039;Failed to resolve module specifier &quot;%s&quot; from &quot;%s&quot;: Invalid relative URL or base scheme is not hierarchical.&#039;, TypeError);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(&#039;ERR_UNKNOWN_FILE_EXTENSION&#039;, (extension, path) =&gt; {
  return `Unknown file extension &quot;${extension}&quot; for ${path}`;
}, TypeError);
codes.ERR_INVALID_ARG_VALUE = createError(&#039;ERR_INVALID_ARG_VALUE&#039;, (name, value, reason = &#039;is invalid&#039;) =&gt; {
  let inspected = (0, _util().inspect)(value);
  if (inspected.length &gt; 128) {
    inspected = `${inspected.slice(0, 128)}...`;
  }
  const type = name.includes(&#039;.&#039;) ? &#039;property&#039; : &#039;argument&#039;;
  return `The ${type} &#039;${name}&#039; ${reason}. Received ${inspected}`;
}, TypeError);
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (_v().startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch (_unused) {}
  const desc = Object.getOwnPropertyDescriptor(Error, &#039;stackTraceLimit&#039;);
  if (desc === undefined) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, &#039;writable&#039;) &amp;&amp; desc.writable !== undefined ? desc.writable : desc.set !== undefined;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, &#039;name&#039;, {
    value: hidden
  });
  return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(function (error) {
  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  _assert()(message !== undefined, &#039;expected `message` to be found&#039;);
  if (typeof message === &#039;function&#039;) {
    _assert()(message.length &lt;= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not ` + `match the required ones (${message.length}).`);
    return Reflect.apply(message, self, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  _assert()(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not ` + `match the required ones (${expectedLength}).`);
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(_util().format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === undefined) {
    return String(value);
  }
  if (typeof value === &#039;function&#039; &amp;&amp; value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === &#039;object&#039;) {
    if (value.constructor &amp;&amp; value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${(0, _util().inspect)(value, {
      depth: -1
    })}`;
  }
  let inspected = (0, _util().inspect)(value, {
    colors: false
  });
  if (inspected.length &gt; 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
const hasOwnProperty$1 = {}.hasOwnProperty;
const {
  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1
} = codes;
const cache = new Map();
function read(jsonPath, {
  base,
  specifier
}) {
  const existing = cache.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = _fs().default.readFileSync(_path().toNamespacedPath(jsonPath), &#039;utf8&#039;);
  } catch (error) {
    const exception = error;
    if (exception.code !== &#039;ENOENT&#039;) {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: undefined,
    name: undefined,
    type: &#039;none&#039;,
    exports: undefined,
    imports: undefined
  };
  if (string !== undefined) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = error_;
      const error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `&quot;${specifier}&quot; from ` : &#039;&#039;) + (0, _url().fileURLToPath)(base || specifier), cause.message);
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty$1.call(parsed, &#039;name&#039;) &amp;&amp; typeof parsed.name === &#039;string&#039;) {
      result.name = parsed.name;
    }
    if (hasOwnProperty$1.call(parsed, &#039;main&#039;) &amp;&amp; typeof parsed.main === &#039;string&#039;) {
      result.main = parsed.main;
    }
    if (hasOwnProperty$1.call(parsed, &#039;exports&#039;)) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty$1.call(parsed, &#039;imports&#039;)) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty$1.call(parsed, &#039;type&#039;) &amp;&amp; (parsed.type === &#039;commonjs&#039; || parsed.type === &#039;module&#039;)) {
      result.type = parsed.type;
    }
  }
  cache.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL(&#039;package.json&#039;, resolved);
  while (true) {
    const packageJSONPath = packageJSONUrl.pathname;
    if (packageJSONPath.endsWith(&#039;node_modules/package.json&#039;)) {
      break;
    }
    const packageConfig = read((0, _url().fileURLToPath)(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL(&#039;../package.json&#039;, packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = (0, _url().fileURLToPath)(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: &#039;none&#039;
  };
}
function getPackageType(url) {
  return getPackageScopeConfig(url).type;
}
const {
  ERR_UNKNOWN_FILE_EXTENSION
} = codes;
const hasOwnProperty = {}.hasOwnProperty;
const extensionFormatMap = {
  __proto__: null,
  &#039;.cjs&#039;: &#039;commonjs&#039;,
  &#039;.js&#039;: &#039;module&#039;,
  &#039;.json&#039;: &#039;json&#039;,
  &#039;.mjs&#039;: &#039;module&#039;
};
function mimeToFormat(mime) {
  if (mime &amp;&amp; /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return &#039;module&#039;;
  if (mime === &#039;application/json&#039;) return &#039;json&#039;;
  return null;
}
const protocolHandlers = {
  __proto__: null,
  &#039;data:&#039;: getDataProtocolModuleFormat,
  &#039;file:&#039;: getFileProtocolModuleFormat,
  &#039;http:&#039;: getHttpProtocolModuleFormat,
  &#039;https:&#039;: getHttpProtocolModuleFormat,
  &#039;node:&#039;() {
    return &#039;builtin&#039;;
  }
};
function getDataProtocolModuleFormat(parsed) {
  const {
    1: mime
  } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url) {
  const pathname = url.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return &#039;&#039;;
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? &#039;&#039; : pathname.slice(index);
    }
  }
  return &#039;&#039;;
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const value = extname(url);
  if (value === &#039;.js&#039;) {
    const packageType = getPackageType(url);
    if (packageType !== &#039;none&#039;) {
      return packageType;
    }
    return &#039;commonjs&#039;;
  }
  if (value === &#039;&#039;) {
    const packageType = getPackageType(url);
    if (packageType === &#039;none&#039; || packageType === &#039;commonjs&#039;) {
      return &#039;commonjs&#039;;
    }
    return &#039;module&#039;;
  }
  const format = extensionFormatMap[value];
  if (format) return format;
  if (ignoreErrors) {
    return undefined;
  }
  const filepath = (0, _url().fileURLToPath)(url);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {}
function defaultGetFormatWithoutErrors(url, context) {
  const protocol = url.protocol;
  if (!hasOwnProperty.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url, context, true) || null;
}
const {
  ERR_INVALID_ARG_VALUE
} = codes;
const DEFAULT_CONDITIONS = Object.freeze([&#039;node&#039;, &#039;import&#039;]);
const DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== undefined &amp;&amp; conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE(&#039;conditions&#039;, conditions, &#039;expected an array&#039;);
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}
const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
const {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_RESOLVE_REQUEST
} = codes;
const own = {}.hasOwnProperty;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidPackageNameRegEx = /^\.|%|\\/;
const patternRegEx = /\*/g;
const encodedSeparatorRegEx = /%2f|%5c/i;
const emittedPackageWarnings = new Set();
const doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (_process().noDeprecation) {
    return;
  }
  const pjsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  _process().emitWarning(`Use of deprecated ${double ? &#039;double slash&#039; : &#039;leading or trailing slash matching&#039;} resolving &quot;${target}&quot; for module ` + `request &quot;${request}&quot; ${request === match ? &#039;&#039; : `matched to &quot;${match}&quot; `}in the &quot;${internal ? &#039;imports&#039; : &#039;exports&#039;}&quot; field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : &#039;&#039;}.`, &#039;DeprecationWarning&#039;, &#039;DEP0166&#039;);
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  if (_process().noDeprecation) {
    return;
  }
  const format = defaultGetFormatWithoutErrors(url, {
    parentURL: base.href
  });
  if (format !== &#039;module&#039;) return;
  const urlPath = (0, _url().fileURLToPath)(url.href);
  const packagePath = (0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl));
  const basePath = (0, _url().fileURLToPath)(base);
  if (!main) {
    _process().emitWarning(`No &quot;main&quot; or &quot;exports&quot; field defined in the package.json for ${packagePath} resolving the main entry point &quot;${urlPath.slice(packagePath.length)}&quot;, imported from ${basePath}.\nDefault &quot;index&quot; lookups for the main are deprecated for ES modules.`, &#039;DeprecationWarning&#039;, &#039;DEP0151&#039;);
  } else if (_path().resolve(packagePath, main) !== urlPath) {
    _process().emitWarning(`Package ${packagePath} has a &quot;main&quot; field set to &quot;${main}&quot;, ` + `excluding the full filename and extension to the resolved file at &quot;${urlPath.slice(packagePath.length)}&quot;, imported from ${basePath}.\n Automatic extension resolution of the &quot;main&quot; field is ` + &#039;deprecated for ES modules.&#039;, &#039;DeprecationWarning&#039;, &#039;DEP0151&#039;);
  }
}
function tryStatSync(path) {
  try {
    return (0, _fs().statSync)(path);
  } catch (_unused2) {}
}
function fileExists(url) {
  const stats = (0, _fs().statSync)(url, {
    throwIfNoEntry: false
  });
  const isFile = stats ? stats.isFile() : undefined;
  return isFile === null || isFile === undefined ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== undefined) {
    guess = new (_url().URL)(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
    let i = -1;
    while (++i &lt; tries.length) {
      guess = new (_url().URL)(tries[i], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = undefined;
    }
    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
  }
  const tries = [&#039;./index.js&#039;, &#039;./index.json&#039;, &#039;./index.node&#039;];
  let i = -1;
  while (++i &lt; tries.length) {
    guess = new (_url().URL)(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = undefined;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), (0, _url().fileURLToPath)(base));
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, &#039;must not include encoded &quot;/&quot; or &quot;\\&quot; characters&#039;, (0, _url().fileURLToPath)(base));
  }
  let filePath;
  try {
    filePath = (0, _url().fileURLToPath)(resolved);
  } catch (error) {
    const cause = error;
    Object.defineProperty(cause, &#039;input&#039;, {
      value: String(resolved)
    });
    Object.defineProperty(cause, &#039;module&#039;, {
      value: String(base)
    });
    throw cause;
  }
  const stats = tryStatSync(filePath.endsWith(&#039;/&#039;) ? filePath.slice(-1) : filePath);
  if (stats &amp;&amp; stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, _url().fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base &amp;&amp; (0, _url().fileURLToPath)(base), true);
    error.url = String(resolved);
    throw error;
  }
  if (!preserveSymlinks) {
    const real = (0, _fs().realpathSync)(filePath);
    const {
      search,
      hash
    } = resolved;
    resolved = (0, _url().pathToFileURL)(real + (filePath.endsWith(_path().sep) ? &#039;/&#039; : &#039;&#039;));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl &amp;&amp; (0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), (0, _url().fileURLToPath)(base));
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), subpath, base &amp;&amp; (0, _url().fileURLToPath)(base));
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern &quot;${match}&quot; for the &quot;${internal ? &#039;imports&#039; : &#039;exports&#039;}&quot; resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base &amp;&amp; (0, _url().fileURLToPath)(base));
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === &#039;object&#039; &amp;&amp; target !== null ? JSON.stringify(target, null, &#039;&#039;) : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url().URL)(&#039;.&#039;, packageJsonUrl)), subpath, target, internal, base &amp;&amp; (0, _url().fileURLToPath)(base));
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== &#039;&#039; &amp;&amp; !pattern &amp;&amp; target[target.length - 1] !== &#039;/&#039;) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith(&#039;./&#039;)) {
    if (internal &amp;&amp; !target.startsWith(&#039;../&#039;) &amp;&amp; !target.startsWith(&#039;/&#039;)) {
      let isURL = false;
      try {
        new (_url().URL)(target);
        isURL = true;
      } catch (_unused3) {}
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () =&gt; subpath) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace(&#039;*&#039;, () =&gt; subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () =&gt; subpath) : target;
        emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, true);
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new (_url().URL)(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new (_url().URL)(&#039;.&#039;, packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === &#039;&#039;) return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace(&#039;*&#039;, () =&gt; subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () =&gt; subpath) : target;
        emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, false);
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new (_url().URL)(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () =&gt; subpath));
  }
  return new (_url().URL)(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber &gt;= 0 &amp;&amp; keyNumber &lt; 0xffffffff;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === &#039;string&#039;) {
    return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i &lt; targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
      } catch (error) {
        const exception = error;
        lastException = exception;
        if (exception.code === &#039;ERR_INVALID_PACKAGE_TARGET&#039;) continue;
        throw error;
      }
      if (resolveResult === undefined) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === undefined || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === &#039;object&#039; &amp;&amp; target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i &lt; keys.length) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, &#039;&quot;exports&quot; cannot contain numeric property keys.&#039;);
      }
    }
    i = -1;
    while (++i &lt; keys.length) {
      const key = keys[i];
      if (key === &#039;default&#039; || conditions &amp;&amp; conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
        if (resolveResult === undefined) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === &#039;string&#039; || Array.isArray(exports)) return true;
  if (typeof exports !== &#039;object&#039; || exports === null) return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex &lt; keys.length) {
    const key = keys[keyIndex];
    const currentIsConditionalSugar = key === &#039;&#039; || key[0] !== &#039;.&#039;;
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, &#039;&quot;exports&quot; cannot contain some keys starting with \&#039;.\&#039; and some not.&#039; + &#039; The exports object must either be an object of package subpath keys&#039; + &#039; or an object of main entry condition name keys only.&#039;);
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (_process().noDeprecation) {
    return;
  }
  const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + &#039;|&#039; + match)) return;
  emittedPackageWarnings.add(pjsonPath + &#039;|&#039; + match);
  _process().emitWarning(`Use of deprecated trailing slash pattern mapping &quot;${match}&quot; in the ` + `&quot;exports&quot; field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : &#039;&#039;}. Mapping specifiers ending in &quot;/&quot; is no longer supported.`, &#039;DeprecationWarning&#039;, &#039;DEP0155&#039;);
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = {
      &#039;.&#039;: exports
    };
  }
  if (own.call(exports, packageSubpath) &amp;&amp; !packageSubpath.includes(&#039;*&#039;) &amp;&amp; !packageSubpath.endsWith(&#039;/&#039;)) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(packageJsonUrl, target, &#039;&#039;, packageSubpath, base, false, false, false, conditions);
    if (resolveResult === null || resolveResult === undefined) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = &#039;&#039;;
  let bestMatchSubpath = &#039;&#039;;
  const keys = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i &lt; keys.length) {
    const key = keys[i];
    const patternIndex = key.indexOf(&#039;*&#039;);
    if (patternIndex !== -1 &amp;&amp; packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith(&#039;/&#039;)) {
        emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length &gt;= key.length &amp;&amp; packageSubpath.endsWith(patternTrailer) &amp;&amp; patternKeyCompare(bestMatch, key) === 1 &amp;&amp; key.lastIndexOf(&#039;*&#039;) === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith(&#039;/&#039;), conditions);
    if (resolveResult === null || resolveResult === undefined) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf(&#039;*&#039;);
  const bPatternIndex = b.indexOf(&#039;*&#039;);
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA &gt; baseLengthB) return -1;
  if (baseLengthB &gt; baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length &gt; b.length) return -1;
  if (b.length &gt; a.length) return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === &#039;#&#039; || name.startsWith(&#039;#/&#039;) || name.endsWith(&#039;/&#039;)) {
    const reason = &#039;is not a valid internal imports specifier name&#039;;
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name) &amp;&amp; !name.includes(&#039;*&#039;)) {
        const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], &#039;&#039;, name, base, false, true, false, conditions);
        if (resolveResult !== null &amp;&amp; resolveResult !== undefined) {
          return resolveResult;
        }
      } else {
        let bestMatch = &#039;&#039;;
        let bestMatchSubpath = &#039;&#039;;
        const keys = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i &lt; keys.length) {
          const key = keys[i];
          const patternIndex = key.indexOf(&#039;*&#039;);
          if (patternIndex !== -1 &amp;&amp; name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length &gt;= key.length &amp;&amp; name.endsWith(patternTrailer) &amp;&amp; patternKeyCompare(bestMatch, key) === 1 &amp;&amp; key.lastIndexOf(&#039;*&#039;) === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
          if (resolveResult !== null &amp;&amp; resolveResult !== undefined) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf(&#039;/&#039;);
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === &#039;@&#039;) {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf(&#039;/&#039;, separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, &#039;is not a valid package name&#039;, (0, _url().fileURLToPath)(base));
  }
  const packageSubpath = &#039;.&#039; + (separatorIndex === -1 ? &#039;&#039; : specifier.slice(separatorIndex));
  return {
    packageName,
    packageSubpath,
    isScoped
  };
}
function packageResolve(specifier, base, conditions) {
  if (_module().builtinModules.includes(specifier)) {
    return new (_url().URL)(&#039;node:&#039; + specifier);
  }
  const {
    packageName,
    packageSubpath,
    isScoped
  } = parsePackageName(specifier, base);
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName &amp;&amp; packageConfig.exports !== undefined &amp;&amp; packageConfig.exports !== null) {
      return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
    }
  }
  let packageJsonUrl = new (_url().URL)(&#039;./node_modules/&#039; + packageName + &#039;/package.json&#039;, base);
  let packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat || !stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new (_url().URL)((isScoped ? &#039;../../../../node_modules/&#039; : &#039;../../../node_modules/&#039;) + packageName + &#039;/package.json&#039;, packageJsonUrl);
      packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig = read(packageJsonPath, {
      base,
      specifier
    });
    if (packageConfig.exports !== undefined &amp;&amp; packageConfig.exports !== null) {
      return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
    }
    if (packageSubpath === &#039;.&#039;) {
      return legacyMainResolve(packageJsonUrl, packageConfig, base);
    }
    return new (_url().URL)(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === &#039;.&#039;) {
    if (specifier.length === 1 || specifier[1] === &#039;/&#039;) return true;
    if (specifier[1] === &#039;.&#039; &amp;&amp; (specifier.length === 2 || specifier[2] === &#039;/&#039;)) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === &#039;&#039;) return false;
  if (specifier[0] === &#039;/&#039;) return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === &#039;data:&#039;;
  const isRemote = isData || protocol === &#039;http:&#039; || protocol === &#039;https:&#039;;
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new (_url().URL)(specifier, base);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === &#039;file:&#039; &amp;&amp; specifier[0] === &#039;#&#039;) {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new (_url().URL)(specifier);
    } catch (error_) {
      if (isRemote &amp;&amp; !_module().builtinModules.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  _assert()(resolved !== undefined, &#039;expected to be defined&#039;);
  if (resolved.protocol !== &#039;file:&#039;) {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    const parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === &#039;http:&#039; || parentProtocol === &#039;https:&#039;) {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        const parsedProtocol = parsed == null ? void 0 : parsed.protocol;
        if (parsedProtocol &amp;&amp; parsedProtocol !== &#039;https:&#039; &amp;&amp; parsedProtocol !== &#039;http:&#039;) {
          throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, &#039;remote imports cannot import from a local location.&#039;);
        }
        return {
          url: (parsed == null ? void 0 : parsed.href) || &#039;&#039;
        };
      }
      if (_module().builtinModules.includes(specifier)) {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, &#039;remote imports cannot import from a local location.&#039;);
      }
      throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, &#039;only relative and absolute specifiers are supported.&#039;);
    }
  }
}
function isURL(self) {
  return Boolean(self &amp;&amp; typeof self === &#039;object&#039; &amp;&amp; &#039;href&#039; in self &amp;&amp; typeof self.href === &#039;string&#039; &amp;&amp; &#039;protocol&#039; in self &amp;&amp; typeof self.protocol === &#039;string&#039; &amp;&amp; self.href &amp;&amp; self.protocol);
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL === undefined) {
    return;
  }
  if (typeof parentURL !== &#039;string&#039; &amp;&amp; !isURL(parentURL)) {
    throw new codes.ERR_INVALID_ARG_TYPE(&#039;parentURL&#039;, [&#039;string&#039;, &#039;URL&#039;], parentURL);
  }
}
function defaultResolve(specifier, context = {}) {
  const {
    parentURL
  } = context;
  _assert()(parentURL !== undefined, &#039;expected `parentURL` to be defined&#039;);
  throwIfInvalidParentURL(parentURL);
  let parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new (_url().URL)(parentURL);
    } catch (_unused4) {}
  }
  let parsed;
  let protocol;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new (_url().URL)(specifier, parsedParentURL) : new (_url().URL)(specifier);
    protocol = parsed.protocol;
    if (protocol === &#039;data:&#039;) {
      return {
        url: parsed.href,
        format: null
      };
    }
  } catch (_unused5) {}
  const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
  if (maybeReturn) return maybeReturn;
  if (protocol === undefined &amp;&amp; parsed) {
    protocol = parsed.protocol;
  }
  if (protocol === &#039;node:&#039;) {
    return {
      url: specifier
    };
  }
  if (parsed &amp;&amp; parsed.protocol === &#039;node:&#039;) return {
    url: specifier
  };
  const conditions = getConditionsSet(context.conditions);
  const url = moduleResolve(specifier, new (_url().URL)(parentURL), conditions, false);
  return {
    url: url.href,
    format: defaultGetFormatWithoutErrors(url, {
      parentURL
    })
  };
}
function resolve(specifier, parent) {
  if (!parent) {
    throw new Error(&#039;Please pass `parent`: `import-meta-resolve` cannot ponyfill that&#039;);
  }
  try {
    return defaultResolve(specifier, {
      parentURL: parent
    }).url;
  } catch (error) {
    const exception = error;
    if ((exception.code === &#039;ERR_UNSUPPORTED_DIR_IMPORT&#039; || exception.code === &#039;ERR_MODULE_NOT_FOUND&#039;) &amp;&amp; typeof exception.url === &#039;string&#039;) {
      return exception.url;
    }
    throw error;
  }
}
0 &amp;&amp; 0;

//# sourceMappingURL=import-meta-resolve.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
