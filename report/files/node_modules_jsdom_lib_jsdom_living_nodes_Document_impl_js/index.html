<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1004</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.17</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const { CookieJar } = require(&quot;tough-cookie&quot;);

const NodeImpl = require(&quot;./Node-impl&quot;).implementation;
const idlUtils = require(&quot;../generated/utils&quot;);
const NODE_TYPE = require(&quot;../node-type&quot;);
const { mixin, memoizeQuery } = require(&quot;../../utils&quot;);
const { firstChildWithLocalName, firstChildWithLocalNames, firstDescendantWithLocalName } =
  require(&quot;../helpers/traversal&quot;);
const whatwgURL = require(&quot;whatwg-url&quot;);
const StyleSheetList = require(&quot;../generated/StyleSheetList.js&quot;);
const { domSymbolTree } = require(&quot;../helpers/internal-constants&quot;);
const eventAccessors = require(&quot;../helpers/create-event-accessor&quot;);
const { asciiLowercase, stripAndCollapseASCIIWhitespace } = require(&quot;../helpers/strings&quot;);
const { childTextContent } = require(&quot;../helpers/text&quot;);
const { HTML_NS, SVG_NS } = require(&quot;../helpers/namespaces&quot;);
const DOMException = require(&quot;../generated/DOMException&quot;);
const { parseIntoDocument } = require(&quot;../../browser/parser&quot;);
const History = require(&quot;../generated/History&quot;);
const Location = require(&quot;../generated/Location&quot;);
const HTMLCollection = require(&quot;../generated/HTMLCollection&quot;);
const NodeList = require(&quot;../generated/NodeList&quot;);
const validateName = require(&quot;../helpers/validate-names&quot;).name;
const { validateAndExtract } = require(&quot;../helpers/validate-names&quot;);
const { fireAnEvent } = require(&quot;../helpers/events&quot;);
const { shadowIncludingInclusiveDescendantsIterator } = require(&quot;../helpers/shadow-dom&quot;);
const { enqueueCECallbackReaction } = require(&quot;../helpers/custom-elements&quot;);
const { createElement, internalCreateElementNSSteps } = require(&quot;../helpers/create-element&quot;);
const IterableWeakSet = require(&quot;../helpers/iterable-weak-set&quot;);

const DocumentOrShadowRootImpl = require(&quot;./DocumentOrShadowRoot-impl&quot;).implementation;
const GlobalEventHandlersImpl = require(&quot;./GlobalEventHandlers-impl&quot;).implementation;
const NonElementParentNodeImpl = require(&quot;./NonElementParentNode-impl&quot;).implementation;
const ParentNodeImpl = require(&quot;./ParentNode-impl&quot;).implementation;

const { clone, listOfElementsWithQualifiedName, listOfElementsWithNamespaceAndLocalName,
  listOfElementsWithClassNames } = require(&quot;../node&quot;);
const generatedAttr = require(&quot;../generated/Attr&quot;);
const Comment = require(&quot;../generated/Comment&quot;);
const ProcessingInstruction = require(&quot;../generated/ProcessingInstruction&quot;);
const CDATASection = require(&quot;../generated/CDATASection&quot;);
const Text = require(&quot;../generated/Text&quot;);
const DocumentFragment = require(&quot;../generated/DocumentFragment&quot;);
const DOMImplementation = require(&quot;../generated/DOMImplementation&quot;);
const TreeWalker = require(&quot;../generated/TreeWalker&quot;);
const NodeIterator = require(&quot;../generated/NodeIterator&quot;);
const ShadowRoot = require(&quot;../generated/ShadowRoot&quot;);
const Range = require(&quot;../generated/Range&quot;);
const documents = require(&quot;../documents.js&quot;);

const CustomEvent = require(&quot;../generated/CustomEvent&quot;);
const ErrorEvent = require(&quot;../generated/ErrorEvent&quot;);
const Event = require(&quot;../generated/Event&quot;);
const FocusEvent = require(&quot;../generated/FocusEvent&quot;);
const HashChangeEvent = require(&quot;../generated/HashChangeEvent&quot;);
const KeyboardEvent = require(&quot;../generated/KeyboardEvent&quot;);
const MessageEvent = require(&quot;../generated/MessageEvent&quot;);
const MouseEvent = require(&quot;../generated/MouseEvent&quot;);
const PopStateEvent = require(&quot;../generated/PopStateEvent&quot;);
const ProgressEvent = require(&quot;../generated/ProgressEvent&quot;);
const TouchEvent = require(&quot;../generated/TouchEvent&quot;);
const UIEvent = require(&quot;../generated/UIEvent&quot;);

const RequestManager = require(&quot;../../browser/resources/request-manager&quot;);
const AsyncResourceQueue = require(&quot;../../browser/resources/async-resource-queue&quot;);
const ResourceQueue = require(&quot;../../browser/resources/resource-queue&quot;);
const PerDocumentResourceLoader = require(&quot;../../browser/resources/per-document-resource-loader&quot;);

function clearChildNodes(node) {
  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {
    node.removeChild(child);
  }
}

function pad(number) {
  if (number &lt; 10) {
    return &quot;0&quot; + number;
  }
  return number;
}

function toLastModifiedString(date) {
  return pad(date.getMonth() + 1) +
    &quot;/&quot; + pad(date.getDate()) +
    &quot;/&quot; + date.getFullYear() +
    &quot; &quot; + pad(date.getHours()) +
    &quot;:&quot; + pad(date.getMinutes()) +
    &quot;:&quot; + pad(date.getSeconds());
}

const eventInterfaceTable = {
  customevent: CustomEvent,
  errorevent: ErrorEvent,
  event: Event,
  events: Event,
  focusevent: FocusEvent,
  hashchangeevent: HashChangeEvent,
  htmlevents: Event,
  keyboardevent: KeyboardEvent,
  messageevent: MessageEvent,
  mouseevent: MouseEvent,
  mouseevents: MouseEvent,
  popstateevent: PopStateEvent,
  progressevent: ProgressEvent,
  svgevents: Event,
  touchevent: TouchEvent,
  uievent: UIEvent,
  uievents: UIEvent
};

class DocumentImpl extends NodeImpl {
  constructor(globalObject, args, privateData) {
    super(globalObject, args, privateData);

    this._initGlobalEvents();

    this._ownerDocument = this;
    this.nodeType = NODE_TYPE.DOCUMENT_NODE;
    if (!privateData.options) {
      privateData.options = {};
    }
    if (!privateData.options.parsingMode) {
      privateData.options.parsingMode = &quot;xml&quot;;
    }
    if (!privateData.options.encoding) {
      privateData.options.encoding = &quot;UTF-8&quot;;
    }
    if (!privateData.options.contentType) {
      privateData.options.contentType = privateData.options.parsingMode === &quot;xml&quot; ? &quot;application/xml&quot; : &quot;text/html&quot;;
    }

    this._parsingMode = privateData.options.parsingMode;

    this._implementation = DOMImplementation.createImpl(this._globalObject, [], {
      ownerDocument: this
    });

    this._defaultView = privateData.options.defaultView || null;
    this._global = privateData.options.global;
    this._ids = Object.create(null);
    this._attached = true;
    this._currentScript = null;
    this._pageShowingFlag = false;
    this._cookieJar = privateData.options.cookieJar;
    this._parseOptions = privateData.options.parseOptions || {};
    this._scriptingDisabled = privateData.options.scriptingDisabled;
    if (this._cookieJar === undefined) {
      this._cookieJar = new CookieJar(null, { looseMode: true });
    }

    if (this._scriptingDisabled) {
      this._parseOptions.scriptingEnabled = false;
    }

    this.contentType = privateData.options.contentType;
    this._encoding = privateData.options.encoding;

    const urlOption = privateData.options.url === undefined ? &quot;about:blank&quot; : privateData.options.url;
    const parsed = whatwgURL.parseURL(urlOption);
    if (parsed === null) {
      throw new TypeError(`Could not parse &quot;${urlOption}&quot; as a URL`);
    }

    this._URL = parsed;
    this._origin = urlOption === &quot;about:blank&quot; &amp;&amp; privateData.options.parentOrigin ?
      privateData.options.parentOrigin :
      whatwgURL.serializeURLOrigin(this._URL);

    this._location = Location.createImpl(this._globalObject, [], { relevantDocument: this });
    this._history = History.createImpl(this._globalObject, [], {
      window: this._defaultView,
      document: this,
      actAsIfLocationReloadCalled: () =&gt; this._location.reload()
    });

    this._workingNodeIterators = new IterableWeakSet();

    this._referrer = privateData.options.referrer || &quot;&quot;;
    this._lastModified = toLastModifiedString(privateData.options.lastModified || new Date());
    this._asyncQueue = new AsyncResourceQueue();
    this._queue = new ResourceQueue({ asyncQueue: this._asyncQueue, paused: false });
    this._deferQueue = new ResourceQueue({ paused: true });
    this._requestManager = new RequestManager();
    this._currentDocumentReadiness = privateData.options.readyState || &quot;loading&quot;;

    this._lastFocusedElement = null;

    this._resourceLoader = new PerDocumentResourceLoader(this);

    // Each Document in a browsing context can also have a latest entry. This is the entry for that Document
    // to which the browsing context&#039;s session history was most recently traversed. When a Document is created,
    // it initially has no latest entry.
    this._latestEntry = null;

    // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#throw-on-dynamic-markup-insertion-counter
    this._throwOnDynamicMarkupInsertionCounter = 0;

    // Cache of computed element styles
    this._styleCache = null;

    // Cache of document base URL
    this._baseURLCache = null;
    this._baseURLSerializedCache = null;
  }

  _clearBaseURLCache() {
    this._baseURLCache = null;
    this._baseURLSerializedCache = null;
  }

  // https://html.spec.whatwg.org/multipage/infrastructure.html#document-base-url
  baseURL() {
    if (this._baseURLCache) {
      return this._baseURLCache;
    }

    const firstBase = this.querySelector(&quot;base[href]&quot;);

    this._baseURLCache = firstBase === null ?
      this._fallbackBaseURL() :
      this._frozenBaseURL(firstBase, this._fallbackBaseURL());
    return this._baseURLCache;
  }

  baseURLSerialized() {
    if (this._baseURLSerializedCache) {
      return this._baseURLSerializedCache;
    }

    const result = whatwgURL.serializeURL(this.baseURL());
    this._baseURLSerializedCache = result;
    return result;
  }

  // https://html.spec.whatwg.org/#resolve-a-url
  encodingParseAURL(url) {
    // TODO account for encoding (once whatwg-url supports that)
    return whatwgURL.parseURL(url, { baseURL: this.baseURL() });
  }

  // https://html.spec.whatwg.org/#frozen-base-url
  _frozenBaseURL(baseElement, fallbackBaseURL) {
    // The spec is eager (setting the frozen base URL when things change); we are lazy (getting it when we need to).
    //
    // There is a slight difference, which is when history.pushState() is involved. The frozen base URL does not get
    // updated in response to history.pushState() per spec, but since we&#039;re lazy, it will get updated.
    //
    // The test in to-port-to-wpts/history.js checks for the current jsdom behavior (which is incorrect).
    // We could make it pass by not invalidating the base URL cache, actually. But that would just make the fallback
    // base URL case use the stale base URL.
    //
    // TODO: implement, with tests for all code paths, the spec&#039;s behavior.

    const baseHrefAttribute = baseElement.getAttributeNS(null, &quot;href&quot;);
    const result = whatwgURL.parseURL(baseHrefAttribute, { baseURL: fallbackBaseURL });
    return result === null ? fallbackBaseURL : result;
  }

  // https://html.spec.whatwg.org/#fallback-base-url
  _fallbackBaseURL() {
    if (this.URL === &quot;about:blank&quot; &amp;&amp; this._defaultView &amp;&amp;
      this._defaultView._parent !== this._defaultView) {
      const parentDocument = idlUtils.implForWrapper(this._defaultView._parent._document);
      return parentDocument.baseURL();
    }

    return this._URL;
  }

  _getTheParent(event) {
    if (event.type === &quot;load&quot; || !this._defaultView) {
      return null;
    }

    return idlUtils.implForWrapper(this._defaultView);
  }

  get compatMode() {
    return this._parsingMode === &quot;xml&quot; || this.doctype ? &quot;CSS1Compat&quot; : &quot;BackCompat&quot;;
  }
  get charset() {
    return this._encoding;
  }
  get characterSet() {
    return this._encoding;
  }
  get inputEncoding() {
    return this._encoding;
  }
  get doctype() {
    for (const childNode of domSymbolTree.childrenIterator(this)) {
      if (childNode.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
        return childNode;
      }
    }
    return null;
  }
  get URL() {
    return whatwgURL.serializeURL(this._URL);
  }
  get documentURI() {
    return whatwgURL.serializeURL(this._URL);
  }
  get location() {
    return this._defaultView ? this._location : null;
  }

  // https://dom.spec.whatwg.org/#dom-document-documentelement
  get documentElement() {
    for (const childNode of domSymbolTree.childrenIterator(this)) {
      if (childNode.nodeType === NODE_TYPE.ELEMENT_NODE) {
        return childNode;
      }
    }

    return null;
  }

  get implementation() {
    return this._implementation;
  }
  set implementation(implementation) {
    this._implementation = implementation;
  }

  get defaultView() {
    return this._defaultView;
  }

  get currentScript() {
    return this._currentScript;
  }

  get readyState() {
    return this._currentDocumentReadiness;
  }

  set readyState(state) {
    this._currentDocumentReadiness = state;
    fireAnEvent(&quot;readystatechange&quot;, this);
  }

  hasFocus() {
    return Boolean(this._lastFocusedElement);
  }

  _descendantRemoved(parent, child) {
    if (child.tagName === &quot;STYLE&quot;) {
      this.styleSheets._remove(child.sheet);
    }

    super._descendantRemoved(parent, child);
  }

  write(...args) {
    let text = &quot;&quot;;
    for (let i = 0; i &lt; args.length; ++i) {
      text += args[i];
    }

    if (this._parsingMode === &quot;xml&quot;) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot use document.write on XML documents&quot;,
        &quot;InvalidStateError&quot;
      ]);
    }

    if (this._throwOnDynamicMarkupInsertionCounter &gt; 0) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot use document.write while a custom element upgrades&quot;,
        &quot;InvalidStateError&quot;
      ]);
    }

    if (this._writeAfterElement) {
      // If called from an script element directly (during the first tick),
      // the new elements are inserted right after that element.
      const tempDiv = this.createElement(&quot;div&quot;);
      tempDiv.innerHTML = text;

      let child = tempDiv.firstChild;
      let previous = this._writeAfterElement;
      const parent = this._writeAfterElement.parentNode;

      while (child) {
        const node = child;
        child = child.nextSibling;

        node._isMovingDueToDocumentWrite = true; // hack for script execution
        parent.insertBefore(node, previous.nextSibling);
        node._isMovingDueToDocumentWrite = false;

        previous = node;
      }
    } else if (this.readyState === &quot;loading&quot;) {
      // During page loading, document.write appends to the current element
      // Find the last child that has been added to the document.
      if (this.lastChild) {
        let node = this;
        while (node.lastChild &amp;&amp; node.lastChild.nodeType === NODE_TYPE.ELEMENT_NODE) {
          node = node.lastChild;
        }
        node.innerHTML = text;
      } else {
        clearChildNodes(this);
        parseIntoDocument(text, this);
      }
    } else if (text) {
      clearChildNodes(this);
      parseIntoDocument(text, this);
    }
  }

  writeln(...args) {
    this.write(...args, &quot;\n&quot;);
  }

  // This is implemented separately for Document (which has a _ids cache) and DocumentFragment (which does not).
  getElementById(id) {
    if (!this._ids[id]) {
      return null;
    }

    // Let&#039;s find the first element with where it&#039;s root is the document.
    const matchElement = this._ids[id].find(candidate =&gt; {
      let root = candidate;
      while (domSymbolTree.parent(root)) {
        root = domSymbolTree.parent(root);
      }

      return root === this;
    });

    return matchElement || null;
  }

  get referrer() {
    return this._referrer || &quot;&quot;;
  }
  get lastModified() {
    return this._lastModified;
  }
  get images() {
    return this.getElementsByTagName(&quot;IMG&quot;);
  }
  get embeds() {
    return this.getElementsByTagName(&quot;EMBED&quot;);
  }
  get plugins() {
    return this.embeds;
  }
  get links() {
    return HTMLCollection.createImpl(this._globalObject, [], {
      element: this,
      query: () =&gt; domSymbolTree.treeToArray(this, {
        filter: node =&gt; (node._localName === &quot;a&quot; || node._localName === &quot;area&quot;) &amp;&amp;
                        node.hasAttributeNS(null, &quot;href&quot;) &amp;&amp;
                        node._namespaceURI === HTML_NS
      })
    });
  }
  get forms() {
    return this.getElementsByTagName(&quot;FORM&quot;);
  }
  get scripts() {
    return this.getElementsByTagName(&quot;SCRIPT&quot;);
  }
  get anchors() {
    return HTMLCollection.createImpl(this._globalObject, [], {
      element: this,
      query: () =&gt; domSymbolTree.treeToArray(this, {
        filter: node =&gt; node._localName === &quot;a&quot; &amp;&amp;
                        node.hasAttributeNS(null, &quot;name&quot;) &amp;&amp;
                        node._namespaceURI === HTML_NS
      })
    });
  }

  // The applets attribute must return an
  // HTMLCollection rooted at the Document node,
  // whose filter matches nothing.
  // (It exists for historical reasons.)
  get applets() {
    return HTMLCollection.createImpl(this._globalObject, [], {
      element: this,
      query: () =&gt; []
    });
  }

  open() {
    let child = domSymbolTree.firstChild(this);
    while (child) {
      this.removeChild(child);
      child = domSymbolTree.firstChild(this);
    }
    this._modified();
    return this;
  }
  close(noQueue) {
    // In some cases like when creating an empty iframe, I want to emit the
    // events right away to avoid problems if later I asign the property src.
    if (noQueue) {
      this.readyState = &quot;complete&quot;;

      fireAnEvent(&quot;DOMContentLoaded&quot;, this, undefined, { bubbles: true });
      fireAnEvent(&quot;load&quot;, this);

      return;
    }
    this._queue.resume();

    const dummyPromise = Promise.resolve();

    const onDOMContentLoad = () =&gt; {
      const doc = this;
      function dispatchEvent() {
        // https://html.spec.whatwg.org/#the-end
        doc.readyState = &quot;interactive&quot;;
        fireAnEvent(&quot;DOMContentLoaded&quot;, doc, undefined, { bubbles: true });
      }

      return new Promise(resolve =&gt; {
        if (!this._deferQueue.tail) {
          dispatchEvent();
          resolve();
          return;
        }

        this._deferQueue.setListener(() =&gt; {
          dispatchEvent();
          resolve();
        });

        this._deferQueue.resume();
      });
    };

    const onLoad = () =&gt; {
      const doc = this;
      function dispatchEvent() {
        doc.readyState = &quot;complete&quot;;
        fireAnEvent(&quot;load&quot;, doc);
      }

      return new Promise(resolve =&gt; {
        if (this._asyncQueue.count() === 0) {
          dispatchEvent();
          resolve();
          return;
        }

        this._asyncQueue.setListener(() =&gt; {
          dispatchEvent();
          resolve();
        });
      });
    };

    this._queue.push(dummyPromise, onDOMContentLoad, null);
    // Set the readyState to &#039;complete&#039; once all resources are loaded.
    // As a side-effect the document&#039;s load-event will be dispatched.
    this._queue.push(dummyPromise, onLoad, null, true);
  }

  getElementsByName(elementName) {
    return NodeList.createImpl(this._globalObject, [], {
      element: this,
      query: () =&gt; domSymbolTree.treeToArray(this, {
        filter: node =&gt; node.getAttributeNS &amp;&amp; node.getAttributeNS(null, &quot;name&quot;) === elementName
      })
    });
  }

  get title() {
    const { documentElement } = this;
    let value = &quot;&quot;;

    if (documentElement &amp;&amp; documentElement._localName === &quot;svg&quot;) {
      const svgTitleElement = firstChildWithLocalName(documentElement, &quot;title&quot;, SVG_NS);

      if (svgTitleElement) {
        value = childTextContent(svgTitleElement);
      }
    } else {
      const titleElement = firstDescendantWithLocalName(this, &quot;title&quot;);

      if (titleElement) {
        value = childTextContent(titleElement);
      }
    }

    value = stripAndCollapseASCIIWhitespace(value);

    return value;
  }

  set title(value) {
    const { documentElement } = this;
    let element;

    if (documentElement &amp;&amp; documentElement._localName === &quot;svg&quot;) {
      element = firstChildWithLocalName(documentElement, &quot;title&quot;, SVG_NS);

      if (!element) {
        element = this.createElementNS(SVG_NS, &quot;title&quot;);

        this._insert(element, documentElement.firstChild);
      }

      element.textContent = value;
    } else if (documentElement &amp;&amp; documentElement._namespaceURI === HTML_NS) {
      const titleElement = firstDescendantWithLocalName(this, &quot;title&quot;);
      const headElement = this.head;

      if (titleElement === null &amp;&amp; headElement === null) {
        return;
      }

      if (titleElement !== null) {
        element = titleElement;
      } else {
        element = this.createElement(&quot;title&quot;);
        headElement._append(element);
      }

      element.textContent = value;
    }
  }

  get dir() {
    return this.documentElement ? this.documentElement.dir : &quot;&quot;;
  }
  set dir(value) {
    if (this.documentElement) {
      this.documentElement.dir = value;
    }
  }

  get head() {
    return this.documentElement ? firstChildWithLocalName(this.documentElement, &quot;head&quot;) : null;
  }

  get body() {
    const { documentElement } = this;
    if (!documentElement || documentElement._localName !== &quot;html&quot; ||
        documentElement._namespaceURI !== HTML_NS) {
      return null;
    }

    return firstChildWithLocalNames(this.documentElement, new Set([&quot;body&quot;, &quot;frameset&quot;]));
  }

  set body(value) {
    if (value === null ||
        value._namespaceURI !== HTML_NS ||
        (value._localName !== &quot;body&quot; &amp;&amp; value._localName !== &quot;frameset&quot;)) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot set the body to null or a non-body/frameset element&quot;,
        &quot;HierarchyRequestError&quot;
      ]);
    }

    const bodyElement = this.body;
    if (value === bodyElement) {
      return;
    }

    if (bodyElement !== null) {
      bodyElement.parentNode._replace(value, bodyElement);
      return;
    }

    const { documentElement } = this;
    if (documentElement === null) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot set the body when there is no document element&quot;,
        &quot;HierarchyRequestError&quot;
      ]);
    }

    documentElement._append(value);
  }

  _runPreRemovingSteps(oldNode) {
    // https://html.spec.whatwg.org/#focus-fixup-rule
    if (oldNode === this.activeElement) {
      this._lastFocusedElement = this.body;
    }
    for (const activeNodeIterator of this._workingNodeIterators) {
      activeNodeIterator._preRemovingSteps(oldNode);
    }
  }

  createEvent(type) {
    const typeLower = type.toLowerCase();
    const eventWrapper = eventInterfaceTable[typeLower] || null;

    if (!eventWrapper) {
      throw DOMException.create(this._globalObject, [
        &quot;The provided event type (\&quot;&quot; + type + &quot;\&quot;) is invalid&quot;,
        &quot;NotSupportedError&quot;
      ]);
    }

    const impl = eventWrapper.createImpl(this._globalObject, [&quot;&quot;]);
    impl._initializedFlag = false;
    return impl;
  }

  createRange() {
    return Range.createImpl(this._globalObject, [], {
      start: { node: this, offset: 0 },
      end: { node: this, offset: 0 }
    });
  }

  createProcessingInstruction(target, data) {
    validateName(this._globalObject, target);

    if (data.includes(&quot;?&gt;&quot;)) {
      throw DOMException.create(this._globalObject, [
        &quot;Processing instruction data cannot contain the string \&quot;?&gt;\&quot;&quot;,
        &quot;InvalidCharacterError&quot;
      ]);
    }

    return ProcessingInstruction.createImpl(this._globalObject, [], {
      ownerDocument: this,
      target,
      data
    });
  }

  // https://dom.spec.whatwg.org/#dom-document-createcdatasection
  createCDATASection(data) {
    if (this._parsingMode === &quot;html&quot;) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot create CDATA sections in HTML documents&quot;,
        &quot;NotSupportedError&quot;
      ]);
    }

    if (data.includes(&quot;]]&gt;&quot;)) {
      throw DOMException.create(this._globalObject, [
        &quot;CDATA section data cannot contain the string \&quot;]]&gt;\&quot;&quot;,
        &quot;InvalidCharacterError&quot;
      ]);
    }

    return CDATASection.createImpl(this._globalObject, [], {
      ownerDocument: this,
      data
    });
  }

  createTextNode(data) {
    return Text.createImpl(this._globalObject, [], {
      ownerDocument: this,
      data
    });
  }

  createComment(data) {
    return Comment.createImpl(this._globalObject, [], {
      ownerDocument: this,
      data
    });
  }

  // https://dom.spec.whatwg.org/#dom-document-createelement
  createElement(localName, options) {
    validateName(this._globalObject, localName);

    if (this._parsingMode === &quot;html&quot;) {
      localName = asciiLowercase(localName);
    }

    let isValue = null;
    if (options &amp;&amp; options.is !== undefined) {
      isValue = options.is;
    }

    const namespace = this._parsingMode === &quot;html&quot; || this.contentType === &quot;application/xhtml+xml&quot; ? HTML_NS : null;

    return createElement(this, localName, namespace, null, isValue, true);
  }

  // https://dom.spec.whatwg.org/#dom-document-createelementns
  createElementNS(namespace, qualifiedName, options) {
    return internalCreateElementNSSteps(this, namespace, qualifiedName, options);
  }

  createDocumentFragment() {
    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument: this });
  }

  createAttribute(localName) {
    validateName(this._globalObject, localName);

    if (this._parsingMode === &quot;html&quot;) {
      localName = asciiLowercase(localName);
    }

    return this._createAttribute({ localName });
  }

  createAttributeNS(namespace, name) {
    if (namespace === undefined) {
      namespace = null;
    }
    namespace = namespace !== null ? String(namespace) : namespace;

    const extracted = validateAndExtract(this._globalObject, namespace, name);
    return this._createAttribute({
      namespace: extracted.namespace,
      namespacePrefix: extracted.prefix,
      localName: extracted.localName
    });
  }

  // Using this helper function rather than directly calling generatedAttr.createImpl may be preferred in some files,
  // to avoid introducing a potentially cyclic dependency on generated/Attr.js.
  _createAttribute({
    localName,
    value,
    namespace,
    namespacePrefix
  }) {
    return generatedAttr.createImpl(this._globalObject, [], {
      localName,
      value,
      namespace,
      namespacePrefix,
      ownerDocument: this
    });
  }

  createTreeWalker(root, whatToShow, filter) {
    return TreeWalker.createImpl(this._globalObject, [], { root, whatToShow, filter });
  }

  createNodeIterator(root, whatToShow, filter) {
    const nodeIterator = NodeIterator.createImpl(this._globalObject, [], { root, whatToShow, filter });
    this._workingNodeIterators.add(nodeIterator);
    return nodeIterator;
  }

  importNode(node, deep) {
    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot import a document node&quot;,
        &quot;NotSupportedError&quot;
      ]);
    } else if (ShadowRoot.isImpl(node)) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot adopt a shadow root&quot;,
        &quot;NotSupportedError&quot;
      ]);
    }

    return clone(node, this, deep);
  }

  // https://dom.spec.whatwg.org/#dom-document-adoptnode
  adoptNode(node) {
    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot adopt a document node&quot;,
        &quot;NotSupportedError&quot;
      ]);
    } else if (ShadowRoot.isImpl(node)) {
      throw DOMException.create(this._globalObject, [
        &quot;Cannot adopt a shadow root&quot;,
        &quot;HierarchyRequestError&quot;
      ]);
    }

    this._adoptNode(node);

    return node;
  }

  // https://dom.spec.whatwg.org/#concept-node-adopt
  _adoptNode(node) {
    const newDocument = this;
    const oldDocument = node._ownerDocument;

    const parent = domSymbolTree.parent(node);
    if (parent) {
      parent._remove(node);
    }

    if (oldDocument !== newDocument) {
      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {
        inclusiveDescendant._ownerDocument = newDocument;
      }

      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {
        if (inclusiveDescendant._ceState === &quot;custom&quot;) {
          enqueueCECallbackReaction(inclusiveDescendant, &quot;adoptedCallback&quot;, [
            idlUtils.wrapperForImpl(oldDocument),
            idlUtils.wrapperForImpl(newDocument)
          ]);
        }
      }

      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {
        if (inclusiveDescendant._adoptingSteps) {
          inclusiveDescendant._adoptingSteps(oldDocument);
        }
      }
    }
  }

  get cookie() {
    return this._cookieJar.getCookieStringSync(this.URL, { http: false });
  }
  set cookie(cookieStr) {
    cookieStr = String(cookieStr);
    this._cookieJar.setCookieSync(cookieStr, this.URL, {
      http: false,
      ignoreError: true
    });
  }

  // The clear(), captureEvents(), and releaseEvents() methods must do nothing
  clear() {}

  captureEvents() {}

  releaseEvents() {}

  get styleSheets() {
    if (!this._styleSheets) {
      this._styleSheets = StyleSheetList.createImpl(this._globalObject);
    }

    // TODO: each style and link element should register its sheet on creation
    // and remove it on removal.
    return this._styleSheets;
  }

  get hidden() {
    if (this._defaultView &amp;&amp; this._defaultView._pretendToBeVisual) {
      return false;
    }

    return true;
  }

  get visibilityState() {
    if (this._defaultView &amp;&amp; this._defaultView._pretendToBeVisual) {
      return &quot;visible&quot;;
    }

    return &quot;prerender&quot;;
  }

  // https://w3c.github.io/selection-api/#extensions-to-document-interface
  getSelection() {
    return this._defaultView ? this._defaultView._selection : null;
  }

  // Needed to ensure that the resulting document has the correct prototype chain:
  // https://dom.spec.whatwg.org/#concept-node-clone says &quot;that implements the same interfaces as node&quot;.
  _cloneDocument() {
    const copy = documents.createImpl(
      this._globalObject,
      {
        contentType: this.contentType,
        encoding: this._encoding,
        parsingMode: this._parsingMode
      }
    );

    copy._URL = this._URL;
    copy._origin = this._origin;
    return copy;
  }
}

eventAccessors.createEventAccessor(DocumentImpl.prototype, &quot;readystatechange&quot;);
mixin(DocumentImpl.prototype, DocumentOrShadowRootImpl.prototype);
mixin(DocumentImpl.prototype, GlobalEventHandlersImpl.prototype);
mixin(DocumentImpl.prototype, NonElementParentNodeImpl.prototype);
mixin(DocumentImpl.prototype, ParentNodeImpl.prototype);

DocumentImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {
  return listOfElementsWithQualifiedName(qualifiedName, this);
});

DocumentImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {
  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);
});

DocumentImpl.prototype.getElementsByClassName = memoizeQuery(function getElementsByClassName(classNames) {
  return listOfElementsWithClassNames(classNames, this);
});

module.exports = {
  implementation: DocumentImpl
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
