<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@nicolo-ribaudo/chokidar-2/dist/main.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@nicolo-ribaudo/chokidar-2/dist/main.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">81.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2086</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">19.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.36</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * ATTENTION: The &quot;eval&quot; devtool has been used (maybe by default in mode: &quot;development&quot;).
 * This devtool is neither made for production nor for readable output files.
 * It uses &quot;eval()&quot; calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with &quot;devtool: false&quot;.
 * If you are looking for production-ready output files, see mode: &quot;production&quot; (https://webpack.js.org/configuration/mode/).
 */
/******/ (() =&gt; { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ &quot;./chokidar/index.js&quot;:
/*!***************************!*\
  !*** ./chokidar/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\nvar EventEmitter = __webpack_require__(/*! events */ \&quot;events\&quot;).EventEmitter;\nvar fs = __webpack_require__(/*! fs */ \&quot;fs\&quot;);\nvar sysPath = __webpack_require__(/*! path */ \&quot;path\&quot;);\nvar asyncEach = __webpack_require__(/*! async-each */ \&quot;./node_modules/async-each/index.js\&quot;);\nvar anymatch = __webpack_require__(/*! anymatch */ \&quot;./node_modules/anymatch/index.js\&quot;);\nvar globParent = __webpack_require__(/*! glob-parent */ \&quot;./node_modules/glob-parent/index.js\&quot;);\nvar isGlob = __webpack_require__(/*! is-glob */ \&quot;./node_modules/is-glob/index.js\&quot;);\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \&quot;./node_modules/path-is-absolute/index.js\&quot;);\nvar inherits = __webpack_require__(/*! inherits */ \&quot;./node_modules/inherits/inherits.js\&quot;);\nvar braces = __webpack_require__(/*! braces */ \&quot;./node_modules/braces/index.js\&quot;);\nvar normalizePath = __webpack_require__(/*! normalize-path */ \&quot;./node_modules/normalize-path/index.js\&quot;);\nvar upath = __webpack_require__(/*! upath */ \&quot;./node_modules/upath/build/code/upath.js\&quot;);\n\nvar NodeFsHandler = __webpack_require__(/*! ./lib/nodefs-handler */ \&quot;./chokidar/lib/nodefs-handler.js\&quot;);\nvar FsEventsHandler = __webpack_require__(/*! ./lib/fsevents-handler */ \&quot;./chokidar/lib/fsevents-handler.js\&quot;);\n\nvar arrify = function(value) {\n  if (value == null) return [];\n  return Array.isArray(value) ? value : [value];\n};\n\nvar flatten = function(list, result) {\n  if (result == null) result = [];\n  list.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\n// Little isString util for use in Array#every.\nvar isString = function(thing) {\n  return typeof thing === &#039;string&#039;;\n};\n\n// Public: Main class.\n// Watches files &amp; directories for changes.\n//\n// * _opts - object, chokidar options hash\n//\n// Emitted events:\n// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n//\n// Examples\n//\n//  var watcher = new FSWatcher()\n//    .add(directories)\n//    .on(&#039;add&#039;, path =&gt; console.log(&#039;File&#039;, path, &#039;was added&#039;))\n//    .on(&#039;change&#039;, path =&gt; console.log(&#039;File&#039;, path, &#039;was changed&#039;))\n//    .on(&#039;unlink&#039;, path =&gt; console.log(&#039;File&#039;, path, &#039;was removed&#039;))\n//    .on(&#039;all&#039;, (event, path) =&gt; console.log(path, &#039; emitted &#039;, event))\n//\nfunction FSWatcher(_opts) {\n  EventEmitter.call(this);\n  var opts = {};\n  // in case _opts that is passed in is a frozen object\n  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];\n  this._watched = Object.create(null);\n  this._closers = Object.create(null);\n  this._ignoredPaths = Object.create(null);\n  Object.defineProperty(this, &#039;_globIgnored&#039;, {\n    get: function() { return Object.keys(this._ignoredPaths); }\n  });\n  this.closed = false;\n  this._throttled = Object.create(null);\n  this._symlinkPaths = Object.create(null);\n\n  function undef(key) {\n    return opts[key] === undefined;\n  }\n\n  // Set up default options.\n  if (undef(&#039;persistent&#039;)) opts.persistent = true;\n  if (undef(&#039;ignoreInitial&#039;)) opts.ignoreInitial = false;\n  if (undef(&#039;ignorePermissionErrors&#039;)) opts.ignorePermissionErrors = false;\n  if (undef(&#039;interval&#039;)) opts.interval = 100;\n  if (undef(&#039;binaryInterval&#039;)) opts.binaryInterval = 300;\n  if (undef(&#039;disableGlobbing&#039;)) opts.disableGlobbing = false;\n  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn&#039;t explicitly enabled.\n  if (undef(&#039;useFsEvents&#039;)) opts.useFsEvents = !opts.usePolling;\n\n  // If we can&#039;t use fsevents, ensure the options reflect it&#039;s disabled.\n  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs.watch.\n  if (undef(&#039;usePolling&#039;) &amp;&amp; !opts.useFsEvents) {\n    opts.usePolling = process.platform === &#039;darwin&#039;;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  var envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    var envLower = envPoll.toLowerCase();\n\n    if (envLower === &#039;false&#039; || envLower === &#039;0&#039;) {\n      opts.usePolling = false;\n    } else if (envLower === &#039;true&#039; || envLower === &#039;1&#039;) {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower\n    }\n  }\n  var envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = parseInt(envInterval);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(&#039;atomic&#039;)) opts.atomic = !opts.usePolling &amp;&amp; !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = Object.create(null);\n\n  if (undef(&#039;followSymlinks&#039;)) opts.followSymlinks = true;\n\n  if (undef(&#039;awaitWriteFinish&#039;)) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  var awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n\n    this._pendingWrites = Object.create(null);\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  this._isntIgnored = function(path, stat) {\n    return !this._isIgnored(path, stat);\n  }.bind(this);\n\n  var readyCalls = 0;\n  this._emitReady = function() {\n    if (++readyCalls &gt;= this._readyCount) {\n      this._emitReady = Function.prototype;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(this.emit.bind(this, &#039;ready&#039;));\n    }\n  }.bind(this);\n\n  this.options = opts;\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\ninherits(FSWatcher, EventEmitter);\n\n// Common helpers\n// --------------\n\n// Private method: Normalize and emit events\n//\n// * event     - string, type of event\n// * path      - string, file or directory path\n// * val[1..3] - arguments to be passed with event\n//\n// Returns the error if defined, otherwise the value of the\n// FSWatcher instance&#039;s `closed` flag\nFSWatcher.prototype._emit = function(event, path, val1, val2, val3) {\n  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);\n  var args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  var awf = this.options.awaitWriteFinish;\n  if (awf &amp;&amp; this._pendingWrites[path]) {\n    this._pendingWrites[path].lastChange = new Date();\n    return this;\n  }\n\n  if (this.options.atomic) {\n    if (event === &#039;unlink&#039;) {\n      this._pendingUnlinks[path] = args;\n      setTimeout(function() {\n        Object.keys(this._pendingUnlinks).forEach(function(path) {\n          this.emit.apply(this, this._pendingUnlinks[path]);\n          this.emit.apply(this, [&#039;all&#039;].concat(this._pendingUnlinks[path]));\n          delete this._pendingUnlinks[path];\n        }.bind(this));\n      }.bind(this), typeof this.options.atomic === \&quot;number\&quot;\n        ? this.options.atomic\n        : 100);\n      return this;\n    } else if (event === &#039;add&#039; &amp;&amp; this._pendingUnlinks[path]) {\n      event = args[0] = &#039;change&#039;;\n      delete this._pendingUnlinks[path];\n    }\n  }\n\n  var emitEvent = function() {\n    this.emit.apply(this, args);\n    if (event !== &#039;error&#039;) this.emit.apply(this, [&#039;all&#039;].concat(args));\n  }.bind(this);\n\n  if (awf &amp;&amp; (event === &#039;add&#039; || event === &#039;change&#039;) &amp;&amp; this._readyEmitted) {\n    var awfEmit = function(err, stats) {\n      if (err) {\n        event = args[0] = &#039;error&#039;;\n        args[1] = err;\n        emitEvent();\n      } else if (stats) {\n        // if stats doesn&#039;t exist the file must have been deleted\n        if (args.length &gt; 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        emitEvent();\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === &#039;change&#039;) {\n    if (!this._throttle(&#039;change&#039;, path, 50)) return this;\n  }\n\n  if (\n    this.options.alwaysStat &amp;&amp; val1 === undefined &amp;&amp;\n    (event === &#039;add&#039; || event === &#039;addDir&#039; || event === &#039;change&#039;)\n  ) {\n    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;\n    fs.stat(fullPath, function(error, stats) {\n      // Suppress event when fs.stat fails, to avoid sending undefined &#039;stat&#039;\n      if (error || !stats) return;\n\n      args.push(stats);\n      emitEvent();\n    });\n  } else {\n    emitEvent();\n  }\n\n  return this;\n};\n\n// Private method: Common handler for errors\n//\n// * error  - object, Error instance\n//\n// Returns the error if defined, otherwise the value of the\n// FSWatcher instance&#039;s `closed` flag\nFSWatcher.prototype._handleError = function(error) {\n  var code = error &amp;&amp; error.code;\n  var ipe = this.options.ignorePermissionErrors;\n  if (error &amp;&amp;\n    code !== &#039;ENOENT&#039; &amp;&amp;\n    code !== &#039;ENOTDIR&#039; &amp;&amp;\n    (!ipe || (code !== &#039;EPERM&#039; &amp;&amp; code !== &#039;EACCES&#039;))\n  ) this.emit(&#039;error&#039;, error);\n  return error || this.closed;\n};\n\n// Private method: Helper utility for throttling\n//\n// * action  - string, type of action being throttled\n// * path    - string, path being acted upon\n// * timeout - int, duration of time to suppress duplicate actions\n//\n// Returns throttle tracking object or false if action should be suppressed\nFSWatcher.prototype._throttle = function(action, path, timeout) {\n  if (!(action in this._throttled)) {\n    this._throttled[action] = Object.create(null);\n  }\n  var throttled = this._throttled[action];\n  if (path in throttled) {\n    throttled[path].count++;\n    return false;\n  }\n  function clear() {\n    var count = throttled[path] ? throttled[path].count : 0;\n    delete throttled[path];\n    clearTimeout(timeoutObject);\n    return count;\n  }\n  var timeoutObject = setTimeout(clear, timeout);\n  throttled[path] = {timeoutObject: timeoutObject, clear: clear, count: 0};\n  return throttled[path];\n};\n\n// Private method: Awaits write operation to finish\n//\n// * path    - string, path being acted upon\n// * threshold - int, time in milliseconds a file size must be fixed before\n//                    acknowledging write operation is finished\n// * awfEmit - function, to be called when ready for event to be emitted\n// Polls a newly created file for size variations. When files size does not\n// change for &#039;threshold&#039; milliseconds calls callback.\nFSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {\n  var timeoutHandler;\n\n  var fullPath = path;\n  if (this.options.cwd &amp;&amp; !isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  var now = new Date();\n\n  var awaitWriteFinish = (function (prevStat) {\n    fs.stat(fullPath, function(err, curStat) {\n      if (err || !(path in this._pendingWrites)) {\n        if (err &amp;&amp; err.code !== &#039;ENOENT&#039;) awfEmit(err);\n        return;\n      }\n\n      var now = new Date();\n\n      if (prevStat &amp;&amp; curStat.size != prevStat.size) {\n        this._pendingWrites[path].lastChange = now;\n      }\n\n      if (now - this._pendingWrites[path].lastChange &gt;= threshold) {\n        delete this._pendingWrites[path];\n        awfEmit(null, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish.bind(this, curStat),\n          this.options.awaitWriteFinish.pollInterval\n        );\n      }\n    }.bind(this));\n  }.bind(this));\n\n  if (!(path in this._pendingWrites)) {\n    this._pendingWrites[path] = {\n      lastChange: now,\n      cancelWait: function() {\n        delete this._pendingWrites[path];\n        clearTimeout(timeoutHandler);\n        return event;\n      }.bind(this)\n    };\n    timeoutHandler = setTimeout(\n      awaitWriteFinish.bind(this),\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n};\n\n// Private method: Determines whether user has asked to ignore this path\n//\n// * path  - string, path to file or directory\n// * stats - object, result of fs.stat\n//\n// Returns boolean\nvar dotRe = /\\..*\\.(sw[px])$|\\~$|\\.subl.*\\.tmp/;\nFSWatcher.prototype._isIgnored = function(path, stats) {\n  if (this.options.atomic &amp;&amp; dotRe.test(path)) return true;\n\n  if (!this._userIgnored) {\n    var cwd = this.options.cwd;\n    var ignored = this.options.ignored;\n    if (cwd &amp;&amp; ignored) {\n      ignored = ignored.map(function (path) {\n        if (typeof path !== &#039;string&#039;) return path;\n        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));\n      });\n    }\n    var paths = arrify(ignored)\n      .filter(function(path) {\n        return typeof path === &#039;string&#039; &amp;&amp; !isGlob(path);\n      }).map(function(path) {\n        return path + &#039;/**&#039;;\n      });\n    this._userIgnored = anymatch(\n      this._globIgnored.concat(ignored).concat(paths)\n    );\n  }\n\n  return this._userIgnored([path, stats]);\n};\n\n// Private method: Provides a set of common helpers and properties relating to\n// symlink and glob handling\n//\n// * path - string, file, directory, or glob pattern being watched\n// * depth - int, at any depth &gt; 0, this isn&#039;t a glob\n//\n// Returns object containing helpers for this path\nvar replacerRe = /^\\.[\\/\\\\]/;\nFSWatcher.prototype._getWatchHelpers = function(path, depth) {\n  path = path.replace(replacerRe, &#039;&#039;);\n  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  var fullWatchPath = sysPath.resolve(watchPath);\n  var hasGlob = watchPath !== path;\n  var globFilter = hasGlob ? anymatch(path) : false;\n  var follow = this.options.followSymlinks;\n  var globSymlink = hasGlob &amp;&amp; follow ? null : false;\n\n  var checkGlobSymlink = function(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === &#039;&#039;\n    if (globSymlink == null) {\n      globSymlink = entry.fullParentDir === fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: fullWatchPath\n      };\n    }\n\n    if (globSymlink) {\n      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  };\n\n  var entryPath = function(entry) {\n    return sysPath.join(watchPath,\n      sysPath.relative(watchPath, checkGlobSymlink(entry))\n    );\n  };\n\n  var filterPath = function(entry) {\n    if (entry.stat &amp;&amp; entry.stat.isSymbolicLink()) return filterDir(entry);\n    var resolvedPath = entryPath(entry);\n    return (!hasGlob || globFilter(resolvedPath)) &amp;&amp;\n      this._isntIgnored(resolvedPath, entry.stat) &amp;&amp;\n      (this.options.ignorePermissionErrors ||\n        this._hasReadPermissions(entry.stat));\n  }.bind(this);\n\n  var getDirParts = function(path) {\n    if (!hasGlob) return false;\n    var parts = [];\n    var expandedPath = braces.expand(path);\n    expandedPath.forEach(function(path) {\n      parts.push(sysPath.relative(watchPath, path).split(/[\\/\\\\]/));\n    });\n    return parts;\n  };\n\n  var dirParts = getDirParts(path);\n  if (dirParts) {\n    dirParts.forEach(function(parts) {\n      if (parts.length &gt; 1) parts.pop();\n    });\n  }\n  var unmatchedGlob;\n\n  var filterDir = function(entry) {\n    if (hasGlob) {\n      var entryParts = getDirParts(checkGlobSymlink(entry));\n      var globstar = false;\n      unmatchedGlob = !dirParts.some(function(parts) {\n        return parts.every(function(part, i) {\n          if (part === &#039;**&#039;) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);\n        });\n      });\n    }\n    return !unmatchedGlob &amp;&amp; this._isntIgnored(entryPath(entry), entry.stat);\n  }.bind(this);\n\n  return {\n    followSymlinks: follow,\n    statMethod: follow ? &#039;stat&#039; : &#039;lstat&#039;,\n    path: path,\n    watchPath: watchPath,\n    entryPath: entryPath,\n    hasGlob: hasGlob,\n    globFilter: globFilter,\n    filterPath: filterPath,\n    filterDir: filterDir\n  };\n};\n\n// Directory helpers\n// -----------------\n\n// Private method: Provides directory tracking objects\n//\n// * directory - string, path of the directory\n//\n// Returns the directory&#039;s tracking object\nFSWatcher.prototype._getWatchedDir = function(directory) {\n  var dir = sysPath.resolve(directory);\n  var watcherRemove = this._remove.bind(this);\n  if (!(dir in this._watched)) this._watched[dir] = {\n    _items: Object.create(null),\n    add: function(item) {\n      if (item !== &#039;.&#039; &amp;&amp; item !== &#039;..&#039;) this._items[item] = true;\n    },\n    remove: function(item) {\n      delete this._items[item];\n      if (!this.children().length) {\n        fs.readdir(dir, function(err) {\n          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));\n        });\n      }\n    },\n    has: function(item) {return item in this._items;},\n    children: function() {return Object.keys(this._items);}\n  };\n  return this._watched[dir];\n};\n\n// File helpers\n// ------------\n\n// Private method: Check for read permissions\n// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405\n//\n// * stats - object, result of fs.stat\n//\n// Returns boolean\nFSWatcher.prototype._hasReadPermissions = function(stats) {\n  return Boolean(4 &amp; parseInt(((stats &amp;&amp; stats.mode) &amp; 0x1ff).toString(8)[0], 10));\n};\n\n// Private method: Handles emitting unlink events for\n// files and directories, and via recursion, for\n// files and directories within directories that are unlinked\n//\n// * directory - string, directory within which the following item is located\n// * item      - string, base path of item/directory\n//\n// Returns nothing\nFSWatcher.prototype._remove = function(directory, item) {\n  // if what is being deleted is a directory, get that directory&#039;s paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  var path = sysPath.join(directory, item);\n  var fullPath = sysPath.resolve(path);\n  var isDirectory = this._watched[path] || this._watched[fullPath];\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle(&#039;remove&#039;, path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  var watchedDirs = Object.keys(this._watched);\n  if (!isDirectory &amp;&amp; !this.options.useFsEvents &amp;&amp; watchedDirs.length === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  var nestedDirectoryChildren = this._getWatchedDir(path).children();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(function(nestedItem) {\n    this._remove(path, nestedItem);\n  }, this);\n\n  // Check if item was on the watched list and remove it\n  var parent = this._getWatchedDir(directory);\n  var wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // If we wait for this file to be fully written, cancel the wait.\n  var relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish &amp;&amp; this._pendingWrites[relPath]) {\n    var event = this._pendingWrites[relPath].cancelWait();\n    if (event === &#039;add&#039;) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  delete this._watched[path];\n  delete this._watched[fullPath];\n  var eventName = isDirectory ? &#039;unlinkDir&#039; : &#039;unlink&#039;;\n  if (wasTracked &amp;&amp; !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n};\n\nFSWatcher.prototype._closePath = function(path) {\n  if (!this._closers[path]) return;\n  this._closers[path].forEach(function(closer) {\n    closer();\n  });\n  delete this._closers[path];\n  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));\n}\n\n// Public method: Adds paths to be watched on an existing FSWatcher instance\n\n// * paths     - string or array of strings, file/directory paths and/or globs\n// * _origAdd  - private boolean, for handling non-existent paths to be watched\n// * _internal - private boolean, indicates a non-user add\n\n// Returns an instance of FSWatcher for chaining.\nFSWatcher.prototype.add = function(paths, _origAdd, _internal) {\n  var disableGlobbing = this.options.disableGlobbing;\n  var cwd = this.options.cwd;\n  this.closed = false;\n  paths = flatten(arrify(paths));\n\n  if (!paths.every(isString)) {\n    throw new TypeError(&#039;Non-string provided as watch path: &#039; + paths);\n  }\n\n  if (cwd) paths = paths.map(function(path) {\n    var absPath;\n    if (isAbsolute(path)) {\n      absPath = path;\n    } else if (path[0] === &#039;!&#039;) {\n      absPath = &#039;!&#039; + sysPath.join(cwd, path.substring(1));\n    } else {\n      absPath = sysPath.join(cwd, path);\n    }\n\n    // Check `path` instead of `absPath` because the cwd portion can&#039;t be a glob\n    if (disableGlobbing || !isGlob(path)) {\n      return absPath;\n    } else {\n      return normalizePath(absPath);\n    }\n  });\n\n  // set aside negated glob strings\n  paths = paths.filter(function(path) {\n    if (path[0] === &#039;!&#039;) {\n      this._ignoredPaths[path.substring(1)] = true;\n    } else {\n      // if a path is being added that was previously ignored, stop ignoring it\n      delete this._ignoredPaths[path];\n      delete this._ignoredPaths[path + &#039;/**&#039;];\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = null;\n\n      return true;\n    }\n  }, this);\n\n  if (this.options.useFsEvents &amp;&amp; FsEventsHandler.canUse()) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach(this._addToFsEvents, this);\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    asyncEach(paths, function(path, next) {\n      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {\n        if (res) this._emitReady();\n        next(err, res);\n      }.bind(this));\n    }.bind(this), function(error, results) {\n      results.forEach(function(item) {\n        if (!item || this.closed) return;\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      }, this);\n    }.bind(this));\n  }\n\n  return this;\n};\n\n// Public method: Close watchers or start ignoring events from specified paths.\n\n// * paths     - string or array of strings, file/directory paths and/or globs\n\n// Returns instance of FSWatcher for chaining.\nFSWatcher.prototype.unwatch = function(paths) {\n  if (this.closed) return this;\n  paths = flatten(arrify(paths));\n\n  paths.forEach(function(path) {\n    // convert to absolute path unless relative path already matches\n    if (!isAbsolute(path) &amp;&amp; !this._closers[path]) {\n      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths[path] = true;\n    if (path in this._watched) {\n      this._ignoredPaths[path + &#039;/**&#039;] = true;\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = null;\n  }, this);\n\n  return this;\n};\n\n// Public method: Close watchers and remove all listeners from watched paths.\n\n// Returns instance of FSWatcher for chaining.\nFSWatcher.prototype.close = function() {\n  if (this.closed) return this;\n\n  this.closed = true;\n  Object.keys(this._closers).forEach(function(watchPath) {\n    this._closers[watchPath].forEach(function(closer) {\n      closer();\n    });\n    delete this._closers[watchPath];\n  }, this);\n  this._watched = Object.create(null);\n\n  this.removeAllListeners();\n  return this;\n};\n\n// Public method: Expose list of watched paths\n\n// Returns object w/ dir paths as keys and arrays of contained paths as values.\nFSWatcher.prototype.getWatched = function() {\n  var watchList = {};\n  Object.keys(this._watched).forEach(function(dir) {\n    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || &#039;.&#039;] = Object.keys(this._watched[dir]._items).sort();\n  }.bind(this));\n  return watchList;\n};\n\n// Attach watch handler prototype methods\nfunction importHandler(handler) {\n  Object.keys(handler.prototype).forEach(function(method) {\n    FSWatcher.prototype[method] = handler.prototype[method];\n  });\n}\nimportHandler(NodeFsHandler);\nif (FsEventsHandler.canUse()) importHandler(FsEventsHandler);\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n// Public function: Instantiates watcher with paths to be tracked.\n\n// * paths     - string or array of strings, file/directory paths and/or globs\n// * options   - object, chokidar options\n\n// Returns an instance of FSWatcher for chaining.\nexports.watch = function(paths, options) {\n  return new FSWatcher(options).add(paths);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./chokidar/index.js?&quot;);

/***/ }),

/***/ &quot;./chokidar/lib/fsevents-handler.js&quot;:
/*!******************************************!*\
  !*** ./chokidar/lib/fsevents-handler.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar fs = __webpack_require__(/*! fs */ \&quot;fs\&quot;);\nvar sysPath = __webpack_require__(/*! path */ \&quot;path\&quot;);\nvar readdirp = __webpack_require__(/*! readdirp */ \&quot;./node_modules/readdirp/readdirp.js\&quot;);\nvar fsevents;\ntry { fsevents = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\&quot;Cannot find module &#039;fsevents&#039;\&quot;); e.code = &#039;MODULE_NOT_FOUND&#039;; throw e; }())); } catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error)\n}\n\n// fsevents instance helper functions\n\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\nvar FSEventsWatchers = Object.create(null);\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nvar consolidateThreshhold = 10;\n\n// Private function: Instantiates the fsevents interface\n\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n\n// Returns new fsevents instance\nfunction createFSEventsInstance(path, callback) {\n  return (new fsevents(path)).on(&#039;fsevent&#039;, callback).start();\n}\n\n// Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the &#039;raw&#039; event\n\n// Returns close function\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath);\n\n  // If we&#039;ve accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  }\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function(watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function(listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function(emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n  var listenerIndex = watchContainer.listeners.length - 1;\n\n  // removes this instance&#039;s listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n\n  for (var i = 0, len = keys.length; i &lt; len; ++i) {\n    var watchPath = keys[i];\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count &gt;= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isConstructor(obj) {\n  return obj.prototype !== undefined &amp;&amp; obj.prototype.constructor !== undefined;\n}\n\n// returns boolean indicating whether fsevents can be used\nfunction canUse() {\n  return fsevents &amp;&amp; Object.keys(FSEventsWatchers).length &lt; 128 &amp;&amp; isConstructor(fsevents);\n}\n\n// determines subdirectory traversal levels from root to path\nfunction depth(path, root) {\n  var i = 0;\n  while (!path.indexOf(root) &amp;&amp; (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n}\n\n// fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher&#039;s prototype\nfunction FsEventsHandler() {}\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n\n// Returns close function for the watcher instance\nFsEventsHandler.prototype._watchWithFsEvents =\nfunction(watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n  var watchCallback = function(fullPath, flags, info) {\n    if (\n      this.options.depth !== undefined &amp;&amp;\n      depth(fullPath, realPath) &gt; this.options.depth\n    ) return;\n    var path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter &amp;&amp; !globFilter(path)) return;\n    // ensure directories are tracked\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n    var watchedDir = this._getWatchedDir(\n      info.type === &#039;directory&#039; ? path : parent\n    );\n    var checkIgnored = function(stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n        if (stats &amp;&amp; stats.isDirectory()) {\n          this._ignoredPaths[path + &#039;/**/*&#039;] = true;\n        }\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + &#039;/**/*&#039;];\n      }\n    }.bind(this);\n\n    var handleEvent = function(event) {\n      if (checkIgnored()) return;\n\n      if (event === &#039;unlink&#039;) {\n        // suppress unlink events on never before seen files\n        if (info.type === &#039;directory&#039; || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === &#039;add&#039;) {\n          // track new directories\n          if (info.type === &#039;directory&#039;) this._getWatchedDir(path);\n\n          if (info.type === &#039;symlink&#039; &amp;&amp; this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ?\n              undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n        var eventName = info.type === &#039;directory&#039; ? event + &#039;Dir&#039; : event;\n        this._emit(eventName, path);\n        if (eventName === &#039;addDir&#039;) this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? &#039;change&#039; : &#039;add&#039;);\n    }\n    function checkFd() {\n      fs.open(path, &#039;r&#039;, function(error, fd) {\n        if (error) {\n          error.code !== &#039;EACCES&#039; ?\n            handleEvent(&#039;unlink&#039;) : addOrChange();\n        } else {\n          fs.close(fd, function(err) {\n            err &amp;&amp; err.code !== &#039;EACCES&#039; ?\n              handleEvent(&#039;unlink&#039;) : addOrChange();\n          });\n        }\n      });\n    }\n    // correct for wrong events emitted\n    var wrongEventFlags = [\n      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n    ];\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === &#039;unknown&#039;) {\n      if (typeof this.options.ignored === &#039;function&#039;) {\n        fs.stat(path, function(error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent(&#039;unlink&#039;);\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n      case &#039;created&#039;:\n      case &#039;modified&#039;:\n        return addOrChange();\n      case &#039;deleted&#039;:\n      case &#039;moved&#039;:\n        return checkFd();\n      }\n    }\n  }.bind(this);\n\n  var closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.emit.bind(this, &#039;raw&#039;)\n  );\n\n  this._emitReady();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n\n// Returns nothing\nFsEventsHandler.prototype._handleFsEventsSymlink =\nfunction(linkPath, fullPath, transform, curDepth) {\n  // don&#039;t follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;\n  else this._symlinkPaths[fullPath] = true;\n\n  this._readyCount++;\n\n  fs.realpath(linkPath, function(error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n\n    this._readyCount++;\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link&#039;s path\n    this._addToFsEvents(linkTarget || linkPath, function(path) {\n      var dotSlash = &#039;.&#039; + sysPath.sep;\n      var aliasedPath = linkPath;\n      if (linkTarget &amp;&amp; linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n};\n\n// Private method: Handle added path with fsevents\n\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n\n// Returns nothing\nFsEventsHandler.prototype._addToFsEvents =\nfunction(path, transform, forceAdd, priorDepth) {\n\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === &#039;function&#039; ?\n    transform : function(val) { return val; };\n\n  var emitAdd = function(newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n    var base = sysPath.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this._getWatchedDir(pp);\n\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? &#039;addDir&#039; : &#039;add&#039;, pp, stats);\n    }\n  }.bind(this);\n\n  var wh = this._getWatchHelpers(path);\n\n  // evaluate what is at the path we&#039;re being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n      return this._emitReady();\n    }\n\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats);\n\n      // don&#039;t recurse further if it would exceed depth setting\n      if (priorDepth &amp;&amp; priorDepth &gt; this.options.depth) return;\n\n      // scan the contents of the dir\n      readdirp({\n        root: wh.watchPath,\n        entryType: &#039;all&#039;,\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on(&#039;data&#039;, function(entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() &amp;&amp; !wh.filterPath(entry)) return;\n\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n\n        if (wh.followSymlinks &amp;&amp; entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can&#039;t be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ?\n            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on(&#039;error&#039;, function() {\n        // Ignore readdirp errors\n      }).on(&#039;end&#039;, this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n      this._emitReady();\n    }\n  }.bind(this));\n\n  if (this.options.persistent &amp;&amp; forceAdd !== true) {\n    var initWatch = function(error, realPath) {\n      if (this.closed) return;\n      var closer = this._watchWithFsEvents(\n        wh.watchPath,\n        sysPath.resolve(realPath || wh.watchPath),\n        processPath,\n        wh.globFilter\n      );\n      if (closer) {\n        this._closers[path] = this._closers[path] || [];\n        this._closers[path].push(closer);\n      }\n    }.bind(this);\n\n    if (typeof transform === &#039;function&#039;) {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./chokidar/lib/fsevents-handler.js?&quot;);

/***/ }),

/***/ &quot;./chokidar/lib/nodefs-handler.js&quot;:
/*!****************************************!*\
  !*** ./chokidar/lib/nodefs-handler.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar fs = __webpack_require__(/*! fs */ \&quot;fs\&quot;);\nvar sysPath = __webpack_require__(/*! path */ \&quot;path\&quot;);\nvar readdirp = __webpack_require__(/*! readdirp */ \&quot;./node_modules/readdirp/readdirp.js\&quot;);\nvar isBinaryPath = __webpack_require__(/*! is-binary-path */ \&quot;./node_modules/is-binary-path/index.js\&quot;);\n\n// fs.watch helpers\n\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchInstances = Object.create(null);\n\n\n// Private function: Instantiates the fs.watch interface\n\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n\n// Returns new fsevents instance\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function(rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory&#039;s watcher in\n    // case the file&#039;s watcher misses it (and rely on throttling to de-dupe)\n    if (evPath &amp;&amp; path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), &#039;listeners&#039;, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n// Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n\n// Returns nothing\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function(listener) {\n    listener(val1, val2, val3);\n  });\n}\n\n// Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (!container) {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, &#039;listeners&#039;),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, &#039;rawEmitters&#039;)\n    );\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, &#039;errHandlers&#039;);\n    watcher.on(&#039;error&#039;, function(error) {\n      container.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (process.platform === &#039;win32&#039; &amp;&amp; error.code === &#039;EPERM&#039;) {\n        fs.open(path, &#039;r&#039;, function(err, fd) {\n          if (!err) fs.close(fd, function(err) {\n            if (!err) broadcastErr(error);\n          });\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance&#039;s listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      if (!container.watcherUnusable) { // check to protect against issue #730\n        container.watcher.close();\n      }\n      delete FsWatchInstances[fullPath];\n    }\n  };\n}\n\n// fs.watchFile helpers\n\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchFileInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n  if (\n    container &amp;&amp; (\n      container.options.persistent &lt; options.persistent ||\n      container.options.interval &gt; options.interval\n    )\n  ) {\n    // \&quot;Upgrade\&quot; the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn&#039;t seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function(curr, prev) {\n        container.rawEmitters.forEach(function(rawEmitter) {\n          rawEmitter(&#039;change&#039;, fullPath, {curr: curr, prev: prev});\n        });\n        var currmtime = curr.mtime.getTime();\n        if (curr.size !== prev.size || currmtime &gt; prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function(listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance&#039;s listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n}\n\n// fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher&#039;s prototype\nfunction NodeFsHandler() {}\n\n// Private method: Watch file for changes with fs.watchFile or fs.watch.\n\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._watchWithNodeFs =\nfunction(path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n  var parent = this._getWatchedDir(directory);\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {persistent: this.options.persistent};\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval &amp;&amp; isBinaryPath(basename) ?\n      this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, &#039;raw&#039;)\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, &#039;raw&#039;)\n    });\n  }\n  return closer;\n};\n\n// Private method: Watch a file and emit add event if warranted\n\n// * file       - string, the file&#039;s path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleFile =\nfunction(file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n  var parent = this._getWatchedDir(dirname);\n  // stats is always present\n  var prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return callback();\n\n  // kick off the watcher\n  var closer = this._watchWithNodeFs(file, function(path, newStats) {\n    if (!this._throttle(&#039;watch&#039;, file, 5)) return;\n    if (!newStats || newStats &amp;&amp; newStats.mtime.getTime() === 0) {\n      fs.stat(file, function(error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          // Check that change event was not fired because of changed only accessTime.\n          var at = newStats.atime.getTime();\n          var mt = newStats.mtime.getTime();\n          if (!at || at &lt;= mt || mt !== prevStats.mtime.getTime()) {\n            this._emit(&#039;change&#039;, file, newStats);\n          }\n          prevStats = newStats;\n        }\n      }.bind(this));\n    // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      var at = newStats.atime.getTime();\n      var mt = newStats.mtime.getTime();\n      if (!at || at &lt;= mt ||  mt !== prevStats.mtime.getTime()) {\n        this._emit(&#039;change&#039;, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }.bind(this));\n\n  // emit an add event if we&#039;re supposed to\n  if (!(initialAdd &amp;&amp; this.options.ignoreInitial)) {\n    if (!this._throttle(&#039;add&#039;, file, 0)) return;\n    this._emit(&#039;add&#039;, file, stats);\n  }\n\n  if (callback) callback();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered while reading a dir\n\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n\n// Returns true if no more processing is needed for this entry.\nNodeFsHandler.prototype._handleSymlink =\nfunction(entry, directory, path, item) {\n  var full = entry.fullPath;\n  var dir = this._getWatchedDir(directory);\n\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don&#039;t follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function(error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n          this._emit(&#039;change&#039;, path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n        this._emit(&#039;add&#039;, path, entry.stat);\n      }\n      this._emitReady();\n    }.bind(this));\n    return true;\n  }\n\n  // don&#039;t follow the same symlink more than once\n  if (this._symlinkPaths[full]) return true;\n  else this._symlinkPaths[full] = true;\n};\n\n// Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleDir =\nfunction(dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n  var tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd &amp;&amp; this.options.ignoreInitial) &amp;&amp; !target &amp;&amp; !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit(&#039;addDir&#039;, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this._getWatchedDir(dir);\n\n  var read = function(directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, &#039;&#039;);\n\n    if (!wh.hasGlob) {\n      var throttler = this._throttle(&#039;readdir&#039;, directory, 1000);\n      if (!throttler) return;\n    }\n\n    var previous = this._getWatchedDir(wh.path);\n    var current = [];\n\n    readdirp({\n      root: directory,\n      entryType: &#039;all&#039;,\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on(&#039;data&#039;, function(entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n\n      if (entry.stat.isSymbolicLink() &amp;&amp;\n        this._handleSymlink(entry, directory, path, item)) return;\n\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target &amp;&amp; !previous.has(item)) {\n        this._readyCount++;\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on(&#039;end&#039;, function() {\n      var wasThrottled = throttler ? throttler.clear() : false;\n      if (done) done();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.children().filter(function(item) {\n        return item !== directory &amp;&amp;\n          current.indexOf(item) === -1 &amp;&amp;\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn&#039;t be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach(function(item) {\n        this._remove(directory, item);\n      }, this);\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) read(directory, false);\n    }.bind(this)).on(&#039;error&#039;, this._handleError.bind(this));\n  }.bind(this);\n\n  var closer;\n\n  if (this.options.depth == null || depth &lt;= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats &amp;&amp; stats.mtime.getTime() === 0) return;\n\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n  return closer;\n};\n\n// Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n\n// Returns nothing\nNodeFsHandler.prototype._addToNodeFs =\nfunction(path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n\n  var wh = this._getWatchHelpers(path, depth);\n  if (!wh.hasGlob &amp;&amp; priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  }\n\n  // evaluate what is at the path we&#039;re being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n\n    var initDir = function(dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n\n    var closer;\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n      this._getWatchedDir(parent).add(wh.watchPath);\n      this._emit(&#039;add&#039;, wh.watchPath, stats);\n      closer = initDir(parent, path);\n\n      // preserve this symlink&#039;s target path\n      fs.realpath(path, function(error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n\n    if (closer) {\n      this._closers[path] = this._closers[path] || [];\n      this._closers[path].push(closer);\n    }\n    callback(null, false);\n  }.bind(this));\n};\n\nmodule.exports = NodeFsHandler;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./chokidar/lib/nodefs-handler.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/anymatch/index.js&quot;:
/*!****************************************!*\
  !*** ./node_modules/anymatch/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar micromatch = __webpack_require__(/*! micromatch */ \&quot;./node_modules/micromatch/index.js\&quot;);\nvar normalize = __webpack_require__(/*! normalize-path */ \&quot;./node_modules/anymatch/node_modules/normalize-path/index.js\&quot;);\nvar path = __webpack_require__(/*! path */ \&quot;path\&quot;); // required for tests.\nvar arrify = function(a) { return a == null ? [] : (Array.isArray(a) ? a : [a]); };\n\nvar anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {\n  criteria = arrify(criteria);\n  value = arrify(value);\n  if (arguments.length === 1) {\n    return anymatch.bind(null, criteria.map(function(criterion) {\n      return typeof criterion === &#039;string&#039; &amp;&amp; criterion[0] !== &#039;!&#039; ?\n        micromatch.matcher(criterion) : criterion;\n    }));\n  }\n  startIndex = startIndex || 0;\n  var string = value[0];\n  var altString, altValue;\n  var matched = false;\n  var matchIndex = -1;\n  function testCriteria(criterion, index) {\n    var result;\n    switch (Object.prototype.toString.call(criterion)) {\n    case &#039;[object String]&#039;:\n      result = string === criterion || altString &amp;&amp; altString === criterion;\n      result = result || micromatch.isMatch(string, criterion);\n      break;\n    case &#039;[object RegExp]&#039;:\n      result = criterion.test(string) || altString &amp;&amp; criterion.test(altString);\n      break;\n    case &#039;[object Function]&#039;:\n      result = criterion.apply(null, value);\n      result = result || altValue &amp;&amp; criterion.apply(null, altValue);\n      break;\n    default:\n      result = false;\n    }\n    if (result) {\n      matchIndex = index + startIndex;\n    }\n    return result;\n  }\n  var crit = criteria;\n  var negGlobs = crit.reduce(function(arr, criterion, index) {\n    if (typeof criterion === &#039;string&#039; &amp;&amp; criterion[0] === &#039;!&#039;) {\n      if (crit === criteria) {\n        // make a copy before modifying\n        crit = crit.slice();\n      }\n      crit[index] = null;\n      arr.push(criterion.substr(1));\n    }\n    return arr;\n  }, []);\n  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {\n    if (path.sep === &#039;\\\\&#039; &amp;&amp; typeof string === &#039;string&#039;) {\n      altString = normalize(string);\n      altString = altString === string ? null : altString;\n      if (altString) altValue = [altString].concat(value.slice(1));\n    }\n    matched = crit.slice(startIndex, endIndex).some(testCriteria);\n  }\n  return returnIndex === true ? matchIndex : matched;\n};\n\nmodule.exports = anymatch;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/anymatch/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/anymatch/node_modules/normalize-path/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/anymatch/node_modules/normalize-path/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;/*!\n * normalize-path &lt;https://github.com/jonschlinkert/normalize-path&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar removeTrailingSeparator = __webpack_require__(/*! remove-trailing-separator */ \&quot;./node_modules/remove-trailing-separator/index.js\&quot;);\n\nmodule.exports = function normalizePath(str, stripTrailing) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n  str = str.replace(/[\\\\\\/]+/g, &#039;/&#039;);\n  if (stripTrailing !== false) {\n    str = removeTrailingSeparator(str);\n  }\n  return str;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/anymatch/node_modules/normalize-path/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/arr-diff/index.js&quot;:
/*!****************************************!*\
  !*** ./node_modules/arr-diff/index.js ***!
  \****************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * arr-diff &lt;https://github.com/jonschlinkert/arr-diff&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function diff(arr/*, arrays*/) {\n  var len = arguments.length;\n  var idx = 0;\n  while (++idx &lt; len) {\n    arr = diffArray(arr, arguments[idx]);\n  }\n  return arr;\n};\n\nfunction diffArray(one, two) {\n  if (!Array.isArray(two)) {\n    return one.slice();\n  }\n\n  var tlen = two.length\n  var olen = one.length;\n  var idx = -1;\n  var arr = [];\n\n  while (++idx &lt; olen) {\n    var ele = one[idx];\n\n    var hasEle = false;\n    for (var i = 0; i &lt; tlen; i++) {\n      var val = two[i];\n\n      if (ele === val) {\n        hasEle = true;\n        break;\n      }\n    }\n\n    if (hasEle === false) {\n      arr.push(ele);\n    }\n  }\n  return arr;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/arr-diff/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/arr-flatten/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/arr-flatten/index.js ***!
  \*******************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * arr-flatten &lt;https://github.com/jonschlinkert/arr-flatten&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function (arr) {\n  return flat(arr, []);\n};\n\nfunction flat(arr, res) {\n  var i = 0, cur;\n  var len = arr.length;\n  for (; i &lt; len; i++) {\n    cur = arr[i];\n    Array.isArray(cur) ? flat(cur, res) : res.push(cur);\n  }\n  return res;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/arr-flatten/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/arr-union/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/arr-union/index.js ***!
  \*****************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nmodule.exports = function union(init) {\n  if (!Array.isArray(init)) {\n    throw new TypeError(&#039;arr-union expects the first argument to be an array.&#039;);\n  }\n\n  var len = arguments.length;\n  var i = 0;\n\n  while (++i &lt; len) {\n    var arg = arguments[i];\n    if (!arg) continue;\n\n    if (!Array.isArray(arg)) {\n      arg = [arg];\n    }\n\n    for (var j = 0; j &lt; arg.length; j++) {\n      var ele = arg[j];\n\n      if (init.indexOf(ele) &gt;= 0) {\n        continue;\n      }\n      init.push(ele);\n    }\n  }\n  return init;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/arr-union/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/array-unique/index.js&quot;:
/*!********************************************!*\
  !*** ./node_modules/array-unique/index.js ***!
  \********************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * array-unique &lt;https://github.com/jonschlinkert/array-unique&gt;\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nmodule.exports = function unique(arr) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(&#039;array-unique expects an array.&#039;);\n  }\n\n  var len = arr.length;\n  var i = -1;\n\n  while (i++ &lt; len) {\n    var j = i + 1;\n\n    for (; j &lt; arr.length; ++j) {\n      if (arr[i] === arr[j]) {\n        arr.splice(j--, 1);\n      }\n    }\n  }\n  return arr;\n};\n\nmodule.exports.immutable = function uniqueImmutable(arr) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(&#039;array-unique expects an array.&#039;);\n  }\n\n  var arrLen = arr.length;\n  var newArr = new Array(arrLen);\n\n  for (var i = 0; i &lt; arrLen; i++) {\n    newArr[i] = arr[i];\n  }\n\n  return module.exports(newArr);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/array-unique/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/assign-symbols/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/assign-symbols/index.js ***!
  \**********************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * assign-symbols &lt;https://github.com/jonschlinkert/assign-symbols&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nmodule.exports = function(receiver, objects) {\n  if (receiver === null || typeof receiver === &#039;undefined&#039;) {\n    throw new TypeError(&#039;expected first argument to be an object.&#039;);\n  }\n\n  if (typeof objects === &#039;undefined&#039; || typeof Symbol === &#039;undefined&#039;) {\n    return receiver;\n  }\n\n  if (typeof Object.getOwnPropertySymbols !== &#039;function&#039;) {\n    return receiver;\n  }\n\n  var isEnumerable = Object.prototype.propertyIsEnumerable;\n  var target = Object(receiver);\n  var len = arguments.length, i = 0;\n\n  while (++i &lt; len) {\n    var provider = Object(arguments[i]);\n    var names = Object.getOwnPropertySymbols(provider);\n\n    for (var j = 0; j &lt; names.length; j++) {\n      var key = names[j];\n\n      if (isEnumerable.call(provider, key)) {\n        target[key] = provider[key];\n      }\n    }\n  }\n  return target;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/assign-symbols/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/async-each/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/async-each/index.js ***!
  \******************************************/
/***/ (function(module, exports) {

eval(&quot;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// async-each MIT license (by Paul Miller from https://paulmillr.com).\n(function(globals) {\n  &#039;use strict&#039;;\n  var each = function(items, next, callback) {\n    if (!Array.isArray(items)) throw new TypeError(&#039;each() expects array as first argument&#039;);\n    if (typeof next !== &#039;function&#039;) throw new TypeError(&#039;each() expects function as second argument&#039;);\n    if (typeof callback !== &#039;function&#039;) callback = Function.prototype; // no-op\n\n    if (items.length === 0) return callback(undefined, items);\n\n    var transformed = new Array(items.length);\n    var count = 0;\n    var returned = false;\n\n    items.forEach(function(item, index) {\n      next(item, function(error, transformedItem) {\n        if (returned) return;\n        if (error) {\n          returned = true;\n          return callback(error);\n        }\n        transformed[index] = transformedItem;\n        count += 1;\n        if (count === items.length) return callback(undefined, transformed);\n      });\n    });\n  };\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return each;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS\n  } else {}\n})(this);\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/async-each/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/atob/node-atob.js&quot;:
/*!****************************************!*\
  !*** ./node_modules/atob/node-atob.js ***!
  \****************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nfunction atob(str) {\n  return Buffer.from(str, &#039;base64&#039;).toString(&#039;binary&#039;);\n}\n\nmodule.exports = atob.atob = atob;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/atob/node-atob.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/base/index.js&quot;:
/*!************************************!*\
  !*** ./node_modules/base/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/base/node_modules/define-property/index.js\&quot;);\nvar CacheBase = __webpack_require__(/*! cache-base */ \&quot;./node_modules/cache-base/index.js\&quot;);\nvar Emitter = __webpack_require__(/*! component-emitter */ \&quot;./node_modules/component-emitter/index.js\&quot;);\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar merge = __webpack_require__(/*! mixin-deep */ \&quot;./node_modules/mixin-deep/index.js\&quot;);\nvar pascal = __webpack_require__(/*! pascalcase */ \&quot;./node_modules/pascalcase/index.js\&quot;);\nvar cu = __webpack_require__(/*! class-utils */ \&quot;./node_modules/class-utils/index.js\&quot;);\n\n/**\n * Optionally define a custom `cache` namespace to use.\n */\n\nfunction namespace(name) {\n  var Cache = name ? CacheBase.namespace(name) : CacheBase;\n  var fns = [];\n\n  /**\n   * Create an instance of `Base` with the given `config` and `options`.\n   *\n   * ```js\n   * // initialize with `config` and `options`\n   * var app = new Base({isApp: true}, {abc: true});\n   * app.set(&#039;foo&#039;, &#039;bar&#039;);\n   *\n   * // values defined with the given `config` object will be on the root of the instance\n   * console.log(app.baz); //=&gt; undefined\n   * console.log(app.foo); //=&gt; &#039;bar&#039;\n   * // or use `.get`\n   * console.log(app.get(&#039;isApp&#039;)); //=&gt; true\n   * console.log(app.get(&#039;foo&#039;)); //=&gt; &#039;bar&#039;\n   *\n   * // values defined with the given `options` object will be on `app.options\n   * console.log(app.options.abc); //=&gt; true\n   * ```\n   *\n   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.\n   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.\n   * @api public\n   */\n\n  function Base(config, options) {\n    if (!(this instanceof Base)) {\n      return new Base(config, options);\n    }\n    Cache.call(this, config);\n    this.is(&#039;base&#039;);\n    this.initBase(config, options);\n  }\n\n  /**\n   * Inherit cache-base\n   */\n\n  util.inherits(Base, Cache);\n\n  /**\n   * Add static emitter methods\n   */\n\n  Emitter(Base);\n\n  /**\n   * Initialize `Base` defaults with the given `config` object\n   */\n\n  Base.prototype.initBase = function(config, options) {\n    this.options = merge({}, this.options, options);\n    this.cache = this.cache || {};\n    this.define(&#039;registered&#039;, {});\n    if (name) this[name] = {};\n\n    // make `app._callbacks` non-enumerable\n    this.define(&#039;_callbacks&#039;, this._callbacks);\n    if (isObject(config)) {\n      this.visit(&#039;set&#039;, config);\n    }\n    Base.run(this, &#039;use&#039;, fns);\n  };\n\n  /**\n   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing\n   * lookups in plugins.\n   *\n   * ```js\n   * app.is(&#039;foo&#039;);\n   * console.log(app._name);\n   * //=&gt; &#039;foo&#039;\n   * console.log(app.isFoo);\n   * //=&gt; true\n   * app.is(&#039;bar&#039;);\n   * console.log(app.isFoo);\n   * //=&gt; true\n   * console.log(app.isBar);\n   * //=&gt; true\n   * console.log(app._name);\n   * //=&gt; &#039;bar&#039;\n   * ```\n   * @name .is\n   * @param {String} `name`\n   * @return {Boolean}\n   * @api public\n   */\n\n  Base.prototype.is = function(name) {\n    if (typeof name !== &#039;string&#039;) {\n      throw new TypeError(&#039;expected name to be a string&#039;);\n    }\n    this.define(&#039;is&#039; + pascal(name), true);\n    this.define(&#039;_name&#039;, name);\n    this.define(&#039;_appname&#039;, name);\n    return this;\n  };\n\n  /**\n   * Returns true if a plugin has already been registered on an instance.\n   *\n   * Plugin implementors are encouraged to use this first thing in a plugin\n   * to prevent the plugin from being called more than once on the same\n   * instance.\n   *\n   * ```js\n   * var base = new Base();\n   * base.use(function(app) {\n   *   if (app.isRegistered(&#039;myPlugin&#039;)) return;\n   *   // do stuff to `app`\n   * });\n   *\n   * // to also record the plugin as being registered\n   * base.use(function(app) {\n   *   if (app.isRegistered(&#039;myPlugin&#039;, true)) return;\n   *   // do stuff to `app`\n   * });\n   * ```\n   * @name .isRegistered\n   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.\n   * @param {String} `name` The plugin name.\n   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.\n   * @return {Boolean} Returns true if a plugin is already registered.\n   * @api public\n   */\n\n  Base.prototype.isRegistered = function(name, register) {\n    if (this.registered.hasOwnProperty(name)) {\n      return true;\n    }\n    if (register !== false) {\n      this.registered[name] = true;\n      this.emit(&#039;plugin&#039;, name);\n    }\n    return false;\n  };\n\n  /**\n   * Define a plugin function to be called immediately upon init. Plugins are chainable\n   * and expose the following arguments to the plugin function:\n   *\n   * - `app`: the current instance of `Base`\n   * - `base`: the [first ancestor instance](#base) of `Base`\n   *\n   * ```js\n   * var app = new Base()\n   *   .use(foo)\n   *   .use(bar)\n   *   .use(baz)\n   * ```\n   * @name .use\n   * @param {Function} `fn` plugin function to call\n   * @return {Object} Returns the item instance for chaining.\n   * @api public\n   */\n\n  Base.prototype.use = function(fn) {\n    fn.call(this, this);\n    return this;\n  };\n\n  /**\n   * The `.define` method is used for adding non-enumerable property on the instance.\n   * Dot-notation is **not supported** with `define`.\n   *\n   * ```js\n   * // arbitrary `render` function using lodash `template`\n   * app.define(&#039;render&#039;, function(str, locals) {\n   *   return _.template(str)(locals);\n   * });\n   * ```\n   * @name .define\n   * @param {String} `key` The name of the property to define.\n   * @param {any} `value`\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n  Base.prototype.define = function(key, val) {\n    if (isObject(key)) {\n      return this.visit(&#039;define&#039;, key);\n    }\n    define(this, key, val);\n    return this;\n  };\n\n  /**\n   * Mix property `key` onto the Base prototype. If base is inherited using\n   * `Base.extend` this method will be overridden by a new `mixin` method that will\n   * only add properties to the prototype of the inheriting application.\n   *\n   * ```js\n   * app.mixin(&#039;foo&#039;, function() {\n   *   // do stuff\n   * });\n   * ```\n   * @name .mixin\n   * @param {String} `key`\n   * @param {Object|Array} `val`\n   * @return {Object} Returns the `base` instance for chaining.\n   * @api public\n   */\n\n  Base.prototype.mixin = function(key, val) {\n    Base.prototype[key] = val;\n    return this;\n  };\n\n  /**\n   * Non-enumberable mixin array, used by the static [Base.mixin]() method.\n   */\n\n  Base.prototype.mixins = Base.prototype.mixins || [];\n\n  /**\n   * Getter/setter used when creating nested instances of `Base`, for storing a reference\n   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`\n   * property of a \&quot;child\&quot; instance. The `base` property defaults to the current instance if\n   * no `parent` property is defined.\n   *\n   * ```js\n   * // create an instance of `Base`, this is our first (\&quot;base\&quot;) instance\n   * var first = new Base();\n   * first.foo = &#039;bar&#039;; // arbitrary property, to make it easier to see what&#039;s happening later\n   *\n   * // create another instance\n   * var second = new Base();\n   * // create a reference to the first instance (`first`)\n   * second.parent = first;\n   *\n   * // create another instance\n   * var third = new Base();\n   * // create a reference to the previous instance (`second`)\n   * // repeat this pattern every time a \&quot;child\&quot; instance is created\n   * third.parent = second;\n   *\n   * // we can always access the first instance using the `base` property\n   * console.log(first.base.foo);\n   * //=&gt; &#039;bar&#039;\n   * console.log(second.base.foo);\n   * //=&gt; &#039;bar&#039;\n   * console.log(third.base.foo);\n   * //=&gt; &#039;bar&#039;\n   * // and now you know how to get to third base ;)\n   * ```\n   * @name .base\n   * @api public\n   */\n\n  Object.defineProperty(Base.prototype, &#039;base&#039;, {\n    configurable: true,\n    get: function() {\n      return this.parent ? this.parent.base : this;\n    }\n  });\n\n  /**\n   * Static method for adding global plugin functions that will\n   * be added to an instance when created.\n   *\n   * ```js\n   * Base.use(function(app) {\n   *   app.foo = &#039;bar&#039;;\n   * });\n   * var app = new Base();\n   * console.log(app.foo);\n   * //=&gt; &#039;bar&#039;\n   * ```\n   * @name #use\n   * @param {Function} `fn` Plugin function to use on each instance.\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, &#039;use&#039;, function(fn) {\n    fns.push(fn);\n    return Base;\n  });\n\n  /**\n   * Run an array of functions by passing each function\n   * to a method on the given object specified by the given property.\n   *\n   * @param  {Object} `obj` Object containing method to use.\n   * @param  {String} `prop` Name of the method on the object to use.\n   * @param  {Array} `arr` Array of functions to pass to the method.\n   */\n\n  define(Base, &#039;run&#039;, function(obj, prop, arr) {\n    var len = arr.length, i = 0;\n    while (len--) {\n      obj[prop](arr[i++]);\n    }\n    return Base;\n  });\n\n  /**\n   * Static method for inheriting the prototype and static methods of the `Base` class.\n   * This method greatly simplifies the process of creating inheritance-based applications.\n   * See [static-extend][] for more details.\n   *\n   * ```js\n   * var extend = cu.extend(Parent);\n   * Parent.extend(Child);\n   *\n   * // optional methods\n   * Parent.extend(Child, {\n   *   foo: function() {},\n   *   bar: function() {}\n   * });\n   * ```\n   * @name #extend\n   * @param {Function} `Ctor` constructor to extend\n   * @param {Object} `methods` Optional prototype properties to mix in.\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, &#039;extend&#039;, cu.extend(Base, function(Ctor, Parent) {\n    Ctor.prototype.mixins = Ctor.prototype.mixins || [];\n\n    define(Ctor, &#039;mixin&#039;, function(fn) {\n      var mixin = fn(Ctor.prototype, Ctor);\n      if (typeof mixin === &#039;function&#039;) {\n        Ctor.prototype.mixins.push(mixin);\n      }\n      return Ctor;\n    });\n\n    define(Ctor, &#039;mixins&#039;, function(Child) {\n      Base.run(Child, &#039;mixin&#039;, Ctor.prototype.mixins);\n      return Ctor;\n    });\n\n    Ctor.prototype.mixin = function(key, value) {\n      Ctor.prototype[key] = value;\n      return this;\n    };\n    return Base;\n  }));\n\n  /**\n   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.\n   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`\n   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is\n   * called (e.g. `Base.mixins(Child)`).\n   *\n   * ```js\n   * Base.mixin(function(proto) {\n   *   proto.foo = function(msg) {\n   *     return &#039;foo &#039; + msg;\n   *   };\n   * });\n   * ```\n   * @name #mixin\n   * @param {Function} `fn` Function to call\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, &#039;mixin&#039;, function(fn) {\n    var mixin = fn(Base.prototype, Base);\n    if (typeof mixin === &#039;function&#039;) {\n      Base.prototype.mixins.push(mixin);\n    }\n    return Base;\n  });\n\n  /**\n   * Static method for running global mixin functions against a child constructor.\n   * Mixins must be registered before calling this method.\n   *\n   * ```js\n   * Base.extend(Child);\n   * Base.mixins(Child);\n   * ```\n   * @name #mixins\n   * @param {Function} `Child` Constructor function of a child class\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, &#039;mixins&#039;, function(Child) {\n    Base.run(Child, &#039;mixin&#039;, Base.prototype.mixins);\n    return Base;\n  });\n\n  /**\n   * Similar to `util.inherit`, but copies all static properties, prototype properties, and\n   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.\n   *\n   * ```js\n   * Base.inherit(Foo, Bar);\n   * ```\n   * @name #inherit\n   * @param {Function} `Receiver` Receiving (child) constructor\n   * @param {Function} `Provider` Providing (parent) constructor\n   * @return {Object} Returns the `Base` constructor for chaining\n   * @api public\n   */\n\n  define(Base, &#039;inherit&#039;, cu.inherit);\n  define(Base, &#039;bubble&#039;, cu.bubble);\n  return Base;\n}\n\n/**\n * Expose `Base` with default settings\n */\n\nmodule.exports = namespace();\n\n/**\n * Allow users to define a namespace\n */\n\nmodule.exports.namespace = namespace;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/base/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/base/node_modules/define-property/index.js&quot;:
/*!*****************************************************************!*\
  !*** ./node_modules/base/node_modules/define-property/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/is-descriptor/index.js\&quot;);\n\nmodule.exports = function defineProperty(obj, prop, val) {\n  if (typeof obj !== &#039;object&#039; &amp;&amp; typeof obj !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected an object or function.&#039;);\n  }\n\n  if (typeof prop !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected `prop` to be a string.&#039;);\n  }\n\n  if (isDescriptor(val) &amp;&amp; (&#039;set&#039; in val || &#039;get&#039; in val)) {\n    return Object.defineProperty(obj, prop, val);\n  }\n\n  return Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/base/node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/braces/index.js&quot;:
/*!**************************************!*\
  !*** ./node_modules/braces/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Module dependencies\n */\n\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\nvar unique = __webpack_require__(/*! array-unique */ \&quot;./node_modules/array-unique/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\n\n/**\n * Local dependencies\n */\n\nvar compilers = __webpack_require__(/*! ./lib/compilers */ \&quot;./node_modules/braces/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./lib/parsers */ \&quot;./node_modules/braces/lib/parsers.js\&quot;);\nvar Braces = __webpack_require__(/*! ./lib/braces */ \&quot;./node_modules/braces/lib/braces.js\&quot;);\nvar utils = __webpack_require__(/*! ./lib/utils */ \&quot;./node_modules/braces/lib/utils.js\&quot;);\nvar MAX_LENGTH = 1024 * 64;\nvar cache = {};\n\n/**\n * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it&#039;s recommended that you read the [performance notes](#performance)).\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n * console.log(braces(&#039;{a,b,c}&#039;));\n * //=&gt; [&#039;(a|b|c)&#039;]\n *\n * console.log(braces(&#039;{a,b,c}&#039;, {expand: true}));\n * //=&gt; [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nfunction braces(pattern, options) {\n  var key = utils.createKey(String(pattern), options);\n  var arr = [];\n\n  var disabled = options &amp;&amp; options.cache === false;\n  if (!disabled &amp;&amp; cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (Array.isArray(pattern)) {\n    for (var i = 0; i &lt; pattern.length; i++) {\n      arr.push.apply(arr, braces.create(pattern[i], options));\n    }\n  } else {\n    arr = braces.create(pattern, options);\n  }\n\n  if (options &amp;&amp; options.nodupes === true) {\n    arr = unique(arr);\n  }\n\n  if (!disabled) {\n    cache[key] = arr;\n  }\n  return arr;\n}\n\n/**\n * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it&#039;s recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n * console.log(braces.expand(&#039;a/{b,c}/d&#039;));\n * //=&gt; [&#039;a/b/d&#039;, &#039;a/c/d&#039;];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = function(pattern, options) {\n  return braces.create(pattern, extend({}, options, {expand: true}));\n};\n\n/**\n * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n * console.log(braces.expand(&#039;a/{b,c}/d&#039;));\n * //=&gt; [&#039;a/(b|c)/d&#039;]\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.optimize = function(pattern, options) {\n  return braces.create(pattern, options);\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n * console.log(braces.create(&#039;user-{200..300}/project-{a,b,c}-{1..10}&#039;))\n * //=&gt; &#039;user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)&#039;\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  var maxLength = (options &amp;&amp; options.maxLength) || MAX_LENGTH;\n  if (pattern.length &gt;= maxLength) {\n    throw new Error(&#039;expected pattern to be less than &#039; + maxLength + &#039; characters&#039;);\n  }\n\n  function create() {\n    if (pattern === &#039;&#039; || pattern.length &lt; 3) {\n      return [pattern];\n    }\n\n    if (utils.isEmptySets(pattern)) {\n      return [];\n    }\n\n    if (utils.isQuotedString(pattern)) {\n      return [pattern.slice(1, -1)];\n    }\n\n    var proto = new Braces(options);\n    var result = !options || options.expand !== true\n      ? proto.optimize(pattern, options)\n      : proto.expand(pattern, options);\n\n    // get the generated pattern(s)\n    var arr = result.output;\n\n    // filter out empty strings if specified\n    if (options &amp;&amp; options.noempty === true) {\n      arr = arr.filter(Boolean);\n    }\n\n    // filter out duplicates if specified\n    if (options &amp;&amp; options.nodupes === true) {\n      arr = unique(arr);\n    }\n\n    Object.defineProperty(arr, &#039;result&#039;, {\n      enumerable: false,\n      value: result\n    });\n\n    return arr;\n  }\n\n  return memoize(&#039;create&#039;, pattern, options, create);\n};\n\n/**\n * Create a regular expression from the given string `pattern`.\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n *\n * console.log(braces.makeRe(&#039;id-{200..300}&#039;));\n * //=&gt; /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/\n * ```\n * @param {String} `pattern` The pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nbraces.makeRe = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  var maxLength = (options &amp;&amp; options.maxLength) || MAX_LENGTH;\n  if (pattern.length &gt;= maxLength) {\n    throw new Error(&#039;expected pattern to be less than &#039; + maxLength + &#039; characters&#039;);\n  }\n\n  function makeRe() {\n    var arr = braces(pattern, options);\n    var opts = extend({strictErrors: false}, options);\n    return toRegex(arr, opts);\n  }\n\n  return memoize(&#039;makeRe&#039;, pattern, options, makeRe);\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n * var ast = braces.parse(&#039;a/{b,c}/d&#039;);\n * console.log(ast);\n * // { type: &#039;root&#039;,\n * //   errors: [],\n * //   input: &#039;a/{b,c}/d&#039;,\n * //   nodes:\n * //    [ { type: &#039;bos&#039;, val: &#039;&#039; },\n * //      { type: &#039;text&#039;, val: &#039;a/&#039; },\n * //      { type: &#039;brace&#039;,\n * //        nodes:\n * //         [ { type: &#039;brace.open&#039;, val: &#039;{&#039; },\n * //           { type: &#039;text&#039;, val: &#039;b,c&#039; },\n * //           { type: &#039;brace.close&#039;, val: &#039;}&#039; } ] },\n * //      { type: &#039;text&#039;, val: &#039;/d&#039; },\n * //      { type: &#039;eos&#039;, val: &#039;&#039; } ] }\n * ```\n * @param {String} `pattern` Brace pattern to parse\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = function(pattern, options) {\n  var proto = new Braces(options);\n  return proto.parse(pattern, options);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var braces = require(&#039;braces&#039;);\n * var ast = braces.parse(&#039;a/{b,c}/d&#039;);\n * console.log(braces.compile(ast));\n * // { options: { source: &#039;string&#039; },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      &#039;brace.open&#039;: [Function],\n * //      text: [Function],\n * //      &#039;brace.close&#039;: [Function] },\n * //   output: [ &#039;a/(b|c)/d&#039; ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nbraces.compile = function(ast, options) {\n  var proto = new Braces(options);\n  return proto.compile(ast, options);\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * braces.clearCache();\n * ```\n * @api public\n */\n\nbraces.clearCache = function() {\n  cache = braces.cache = {};\n};\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the method name, pattern, and user-defined options. Set\n * options.memoize to false to disable.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + &#039;:&#039; + pattern, options);\n  var disabled = options &amp;&amp; options.cache === false;\n  if (disabled) {\n    braces.clearCache();\n    return fn(pattern, options);\n  }\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  var res = fn(pattern, options);\n  cache[key] = res;\n  return res;\n}\n\n/**\n * Expose `Braces` constructor and methods\n * @type {Function}\n */\n\nbraces.Braces = Braces;\nbraces.compilers = compilers;\nbraces.parsers = parsers;\nbraces.cache = cache;\n\n/**\n * Expose `braces`\n * @type {Function}\n */\n\nmodule.exports = braces;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/braces/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/braces/lib/braces.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/braces/lib/braces.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nvar Snapdragon = __webpack_require__(/*! snapdragon */ \&quot;./node_modules/snapdragon/index.js\&quot;);\nvar compilers = __webpack_require__(/*! ./compilers */ \&quot;./node_modules/braces/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./parsers */ \&quot;./node_modules/braces/lib/parsers.js\&quot;);\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/braces/lib/utils.js\&quot;);\n\n/**\n * Customize Snapdragon parser and renderer\n */\n\nfunction Braces(options) {\n  this.options = extend({}, options);\n}\n\n/**\n * Initialize braces\n */\n\nBraces.prototype.init = function(options) {\n  if (this.isInitialized) return;\n  this.isInitialized = true;\n  var opts = utils.createOptions({}, this.options, options);\n  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);\n  this.compiler = this.snapdragon.compiler;\n  this.parser = this.snapdragon.parser;\n\n  compilers(this.snapdragon, opts);\n  parsers(this.snapdragon, opts);\n\n  /**\n   * Call Snapdragon `.parse` method. When AST is returned, we check to\n   * see if any unclosed braces are left on the stack and, if so, we iterate\n   * over the stack and correct the AST so that compilers are called in the correct\n   * order and unbalance braces are properly escaped.\n   */\n\n  utils.define(this.snapdragon, &#039;parse&#039;, function(pattern, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    this.parser.ast.input = pattern;\n\n    var stack = this.parser.stack;\n    while (stack.length) {\n      addParent({type: &#039;brace.close&#039;, val: &#039;&#039;}, stack.pop());\n    }\n\n    function addParent(node, parent) {\n      utils.define(node, &#039;parent&#039;, parent);\n      parent.nodes.push(node);\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, &#039;parser&#039;, this.parser);\n    return parsed;\n  });\n};\n\n/**\n * Decorate `.parse` method\n */\n\nBraces.prototype.parse = function(ast, options) {\n  if (ast &amp;&amp; typeof ast === &#039;object&#039; &amp;&amp; ast.nodes) return ast;\n  this.init(options);\n  return this.snapdragon.parse(ast, options);\n};\n\n/**\n * Decorate `.compile` method\n */\n\nBraces.prototype.compile = function(ast, options) {\n  if (typeof ast === &#039;string&#039;) {\n    ast = this.parse(ast, options);\n  } else {\n    this.init(options);\n  }\n  return this.snapdragon.compile(ast, options);\n};\n\n/**\n * Expand\n */\n\nBraces.prototype.expand = function(pattern) {\n  var ast = this.parse(pattern, {expand: true});\n  return this.compile(ast, {expand: true});\n};\n\n/**\n * Optimize\n */\n\nBraces.prototype.optimize = function(pattern) {\n  var ast = this.parse(pattern, {optimize: true});\n  return this.compile(ast, {optimize: true});\n};\n\n/**\n * Expose `Braces`\n */\n\nmodule.exports = Braces;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/braces/lib/braces.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/braces/lib/compilers.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/compilers.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/braces/lib/utils.js\&quot;);\n\nmodule.exports = function(braces, options) {\n  braces.compiler\n\n    /**\n     * bos\n     */\n\n    .set(&#039;bos&#039;, function() {\n      if (this.output) return;\n      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];\n      this.ast.count = 1;\n    })\n\n    /**\n     * Square brackets\n     */\n\n    .set(&#039;bracket&#039;, function(node) {\n      var close = node.close;\n      var open = !node.escaped ? &#039;[&#039; : &#039;\\\\[&#039;;\n      var negated = node.negated;\n      var inner = node.inner;\n\n      inner = inner.replace(/\\\\(?=[\\\\\\w]|$)/g, &#039;\\\\\\\\&#039;);\n      if (inner === &#039;]-&#039;) {\n        inner = &#039;\\\\]\\\\-&#039;;\n      }\n\n      if (negated &amp;&amp; inner.indexOf(&#039;.&#039;) === -1) {\n        inner += &#039;.&#039;;\n      }\n      if (negated &amp;&amp; inner.indexOf(&#039;/&#039;) === -1) {\n        inner += &#039;/&#039;;\n      }\n\n      var val = open + negated + inner + close;\n      var queue = node.parent.queue;\n      var last = utils.arrayify(queue.pop());\n\n      queue.push(utils.join(last, val));\n      queue.push.apply(queue, []);\n    })\n\n    /**\n     * Brace\n     */\n\n    .set(&#039;brace&#039;, function(node) {\n      node.queue = isEscaped(node) ? [node.val] : [];\n      node.count = 1;\n      return this.mapVisit(node.nodes);\n    })\n\n    /**\n     * Open\n     */\n\n    .set(&#039;brace.open&#039;, function(node) {\n      node.parent.open = node.val;\n    })\n\n    /**\n     * Inner\n     */\n\n    .set(&#039;text&#039;, function(node) {\n      var queue = node.parent.queue;\n      var escaped = node.escaped;\n      var segs = [node.val];\n\n      if (node.optimize === false) {\n        options = utils.extend({}, options, {optimize: false});\n      }\n\n      if (node.multiplier &gt; 1) {\n        node.parent.count *= node.multiplier;\n      }\n\n      if (options.quantifiers === true &amp;&amp; utils.isQuantifier(node.val)) {\n        escaped = true;\n\n      } else if (node.val.length &gt; 1) {\n        if (isType(node.parent, &#039;brace&#039;) &amp;&amp; !isEscaped(node)) {\n          var expanded = utils.expand(node.val, options);\n          segs = expanded.segs;\n\n          if (expanded.isOptimized) {\n            node.parent.isOptimized = true;\n          }\n\n          // if nothing was expanded, we probably have a literal brace\n          if (!segs.length) {\n            var val = (expanded.val || node.val);\n            if (options.unescape !== false) {\n              // unescape unexpanded brace sequence/set separators\n              val = val.replace(/\\\\([,.])/g, &#039;$1&#039;);\n              // strip quotes\n              val = val.replace(/[\&quot;&#039;`]/g, &#039;&#039;);\n            }\n\n            segs = [val];\n            escaped = true;\n          }\n        }\n\n      } else if (node.val === &#039;,&#039;) {\n        if (options.expand) {\n          node.parent.queue.push([&#039;&#039;]);\n          segs = [&#039;&#039;];\n        } else {\n          segs = [&#039;|&#039;];\n        }\n      } else {\n        escaped = true;\n      }\n\n      if (escaped &amp;&amp; isType(node.parent, &#039;brace&#039;)) {\n        if (node.parent.nodes.length &lt;= 4 &amp;&amp; node.parent.count === 1) {\n          node.parent.escaped = true;\n        } else if (node.parent.length &lt;= 3) {\n          node.parent.escaped = true;\n        }\n      }\n\n      if (!hasQueue(node.parent)) {\n        node.parent.queue = segs;\n        return;\n      }\n\n      var last = utils.arrayify(queue.pop());\n      if (node.parent.count &gt; 1 &amp;&amp; options.expand) {\n        last = multiply(last, node.parent.count);\n        node.parent.count = 1;\n      }\n\n      queue.push(utils.join(utils.flatten(last), segs.shift()));\n      queue.push.apply(queue, segs);\n    })\n\n    /**\n     * Close\n     */\n\n    .set(&#039;brace.close&#039;, function(node) {\n      var queue = node.parent.queue;\n      var prev = node.parent.parent;\n      var last = prev.queue.pop();\n      var open = node.parent.open;\n      var close = node.val;\n\n      if (open &amp;&amp; close &amp;&amp; isOptimized(node, options)) {\n        open = &#039;(&#039;;\n        close = &#039;)&#039;;\n      }\n\n      // if a close brace exists, and the previous segment is one character\n      // don&#039;t wrap the result in braces or parens\n      var ele = utils.last(queue);\n      if (node.parent.count &gt; 1 &amp;&amp; options.expand) {\n        ele = multiply(queue.pop(), node.parent.count);\n        node.parent.count = 1;\n        queue.push(ele);\n      }\n\n      if (close &amp;&amp; typeof ele === &#039;string&#039; &amp;&amp; ele.length === 1) {\n        open = &#039;&#039;;\n        close = &#039;&#039;;\n      }\n\n      if ((isLiteralBrace(node, options) || noInner(node)) &amp;&amp; !node.parent.hasEmpty) {\n        queue.push(utils.join(open, queue.pop() || &#039;&#039;));\n        queue = utils.flatten(utils.join(queue, close));\n      }\n\n      if (typeof last === &#039;undefined&#039;) {\n        prev.queue = [queue];\n      } else {\n        prev.queue.push(utils.flatten(utils.join(last, queue)));\n      }\n    })\n\n    /**\n     * eos\n     */\n\n    .set(&#039;eos&#039;, function(node) {\n      if (this.input) return;\n\n      if (options.optimize !== false) {\n        this.output = utils.last(utils.flatten(this.ast.queue));\n      } else if (Array.isArray(utils.last(this.ast.queue))) {\n        this.output = utils.flatten(this.ast.queue.pop());\n      } else {\n        this.output = utils.flatten(this.ast.queue);\n      }\n\n      if (node.parent.count &gt; 1 &amp;&amp; options.expand) {\n        this.output = multiply(this.output, node.parent.count);\n      }\n\n      this.output = utils.arrayify(this.output);\n      this.ast.queue = [];\n    });\n\n};\n\n/**\n * Multiply the segments in the current brace level\n */\n\nfunction multiply(queue, n, options) {\n  return utils.flatten(utils.repeat(utils.arrayify(queue), n));\n}\n\n/**\n * Return true if `node` is escaped\n */\n\nfunction isEscaped(node) {\n  return node.escaped === true;\n}\n\n/**\n * Returns true if regex parens should be used for sets. If the parent `type`\n * is not `brace`, then we&#039;re on a root node, which means we should never\n * expand segments and open/close braces should be `{}` (since this indicates\n * a brace is missing from the set)\n */\n\nfunction isOptimized(node, options) {\n  if (node.parent.isOptimized) return true;\n  return isType(node.parent, &#039;brace&#039;)\n    &amp;&amp; !isEscaped(node.parent)\n    &amp;&amp; options.expand !== true;\n}\n\n/**\n * Returns true if the value in `node` should be wrapped in a literal brace.\n * @return {Boolean}\n */\n\nfunction isLiteralBrace(node, options) {\n  return isEscaped(node.parent) || options.optimize !== false;\n}\n\n/**\n * Returns true if the given `node` does not have an inner value.\n * @return {Boolean}\n */\n\nfunction noInner(node, type) {\n  if (node.parent.queue.length === 1) {\n    return true;\n  }\n  var nodes = node.parent.nodes;\n  return nodes.length === 3\n    &amp;&amp; isType(nodes[0], &#039;brace.open&#039;)\n    &amp;&amp; !isType(nodes[1], &#039;text&#039;)\n    &amp;&amp; isType(nodes[2], &#039;brace.close&#039;);\n}\n\n/**\n * Returns true if the given `node` is the given `type`\n * @return {Boolean}\n */\n\nfunction isType(node, type) {\n  return typeof node !== &#039;undefined&#039; &amp;&amp; node.type === type;\n}\n\n/**\n * Returns true if the given `node` has a non-empty queue.\n * @return {Boolean}\n */\n\nfunction hasQueue(node) {\n  return Array.isArray(node.queue) &amp;&amp; node.queue.length;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/braces/lib/compilers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/braces/lib/parsers.js&quot;:
/*!********************************************!*\
  !*** ./node_modules/braces/lib/parsers.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar Node = __webpack_require__(/*! snapdragon-node */ \&quot;./node_modules/snapdragon-node/index.js\&quot;);\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/braces/lib/utils.js\&quot;);\n\n/**\n * Braces parsers\n */\n\nmodule.exports = function(braces, options) {\n  braces.parser\n    .set(&#039;bos&#039;, function() {\n      if (!this.parsed) {\n        this.ast = this.nodes[0] = new Node(this.ast);\n      }\n    })\n\n    /**\n     * Character parsers\n     */\n\n    .set(&#039;escape&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^(?:\\\\(.)|\\$\\{)/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      var node = pos(new Node({\n        type: &#039;text&#039;,\n        multiplier: 1,\n        val: m[0]\n      }));\n\n      if (node.val === &#039;\\\\\\\\&#039;) {\n        return node;\n      }\n\n      if (node.val === &#039;${&#039;) {\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          node.val += ch;\n          if (ch === &#039;\\\\&#039;) {\n            node.val += str[++idx];\n            continue;\n          }\n          if (ch === &#039;}&#039;) {\n            break;\n          }\n        }\n      }\n\n      if (this.options.unescape !== false) {\n        node.val = node.val.replace(/\\\\([{}])/g, &#039;$1&#039;);\n      }\n\n      if (last.val === &#039;\&quot;&#039; &amp;&amp; this.input.charAt(0) === &#039;\&quot;&#039;) {\n        last.val = node.val;\n        this.consume(1);\n        return;\n      }\n\n      return concatNodes.call(this, pos, node, prev, options);\n    })\n\n    /**\n     * Brackets: \&quot;[...]\&quot; (basic, this is overridden by\n     * other parsers in more advanced implementations)\n     */\n\n    .set(&#039;bracket&#039;, function() {\n      var isInside = this.isInside(&#039;brace&#039;);\n      var pos = this.position();\n      var m = this.match(/^(?:\\[([!^]?)([^\\]]{2,}|\\]-)(\\]|[^*+?]+)|\\[)/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n      var negated = m[1] ? &#039;^&#039; : &#039;&#039;;\n      var inner = m[2] || &#039;&#039;;\n      var close = m[3] || &#039;&#039;;\n\n      if (isInside &amp;&amp; prev.type === &#039;brace&#039;) {\n        prev.text = prev.text || &#039;&#039;;\n        prev.text += val;\n      }\n\n      var esc = this.input.slice(0, 2);\n      if (inner === &#039;&#039; &amp;&amp; esc === &#039;\\\\]&#039;) {\n        inner += esc;\n        this.consume(2);\n\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          if (ch === &#039;]&#039;) {\n            close = ch;\n            break;\n          }\n          inner += ch;\n        }\n      }\n\n      return pos(new Node({\n        type: &#039;bracket&#039;,\n        val: val,\n        escaped: close !== &#039;]&#039;,\n        negated: negated,\n        inner: inner,\n        close: close\n      }));\n    })\n\n    /**\n     * Empty braces (we capture these early to\n     * speed up processing in the compiler)\n     */\n\n    .set(&#039;multiplier&#039;, function() {\n      var isInside = this.isInside(&#039;brace&#039;);\n      var pos = this.position();\n      var m = this.match(/^\\{((?:,|\\{,+\\})+)\\}/);\n      if (!m) return;\n\n      this.multiplier = true;\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside &amp;&amp; prev.type === &#039;brace&#039;) {\n        prev.text = prev.text || &#039;&#039;;\n        prev.text += val;\n      }\n\n      var node = pos(new Node({\n        type: &#039;text&#039;,\n        multiplier: 1,\n        match: m,\n        val: val\n      }));\n\n      return concatNodes.call(this, pos, node, prev, options);\n    })\n\n    /**\n     * Open\n     */\n\n    .set(&#039;brace.open&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^\\{(?!(?:[^\\\\}]?|,+)\\})/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      // if the last parsed character was an extglob character\n      // we need to _not optimize_ the brace pattern because\n      // it might be mistaken for an extglob by a downstream parser\n      if (last &amp;&amp; last.val &amp;&amp; isExtglobChar(last.val.slice(-1))) {\n        last.optimize = false;\n      }\n\n      var open = pos(new Node({\n        type: &#039;brace.open&#039;,\n        val: m[0]\n      }));\n\n      var node = pos(new Node({\n        type: &#039;brace&#039;,\n        nodes: []\n      }));\n\n      node.push(open);\n      prev.push(node);\n      this.push(&#039;brace&#039;, node);\n    })\n\n    /**\n     * Close\n     */\n\n    .set(&#039;brace.close&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^\\}/);\n      if (!m || !m[0]) return;\n\n      var brace = this.pop(&#039;brace&#039;);\n      var node = pos(new Node({\n        type: &#039;brace.close&#039;,\n        val: m[0]\n      }));\n\n      if (!this.isType(brace, &#039;brace&#039;)) {\n        if (this.options.strict) {\n          throw new Error(&#039;missing opening \&quot;{\&quot;&#039;);\n        }\n        node.type = &#039;text&#039;;\n        node.multiplier = 0;\n        node.escaped = true;\n        return node;\n      }\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n      if (last.text) {\n        var lastNode = utils.last(last.nodes);\n        if (lastNode.val === &#039;)&#039; &amp;&amp; /[!@*?+]\\(/.test(last.text)) {\n          var open = last.nodes[0];\n          var text = last.nodes[1];\n          if (open.type === &#039;brace.open&#039; &amp;&amp; text &amp;&amp; text.type === &#039;text&#039;) {\n            text.optimize = false;\n          }\n        }\n      }\n\n      if (brace.nodes.length &gt; 2) {\n        var first = brace.nodes[1];\n        if (first.type === &#039;text&#039; &amp;&amp; first.val === &#039;,&#039;) {\n          brace.nodes.splice(1, 1);\n          brace.nodes.push(first);\n        }\n      }\n\n      brace.push(node);\n    })\n\n    /**\n     * Capture boundary characters\n     */\n\n    .set(&#039;boundary&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^[$^](?!\\{)/);\n      if (!m) return;\n      return pos(new Node({\n        type: &#039;text&#039;,\n        val: m[0]\n      }));\n    })\n\n    /**\n     * One or zero, non-comma characters wrapped in braces\n     */\n\n    .set(&#039;nobrace&#039;, function() {\n      var isInside = this.isInside(&#039;brace&#039;);\n      var pos = this.position();\n      var m = this.match(/^\\{[^,]?\\}/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside &amp;&amp; prev.type === &#039;brace&#039;) {\n        prev.text = prev.text || &#039;&#039;;\n        prev.text += val;\n      }\n\n      return pos(new Node({\n        type: &#039;text&#039;,\n        multiplier: 0,\n        val: val\n      }));\n    })\n\n    /**\n     * Text\n     */\n\n    .set(&#039;text&#039;, function() {\n      var isInside = this.isInside(&#039;brace&#039;);\n      var pos = this.position();\n      var m = this.match(/^((?!\\\\)[^${}[\\]])+/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var val = m[0];\n\n      if (isInside &amp;&amp; prev.type === &#039;brace&#039;) {\n        prev.text = prev.text || &#039;&#039;;\n        prev.text += val;\n      }\n\n      var node = pos(new Node({\n        type: &#039;text&#039;,\n        multiplier: 1,\n        val: val\n      }));\n\n      return concatNodes.call(this, pos, node, prev, options);\n    });\n};\n\n/**\n * Returns true if the character is an extglob character.\n */\n\nfunction isExtglobChar(ch) {\n  return ch === &#039;!&#039; || ch === &#039;@&#039; || ch === &#039;*&#039; || ch === &#039;?&#039; || ch === &#039;+&#039;;\n}\n\n/**\n * Combine text nodes, and calculate empty sets (`{,,}`)\n * @param {Function} `pos` Function to calculate node position\n * @param {Object} `node` AST node\n * @return {Object}\n */\n\nfunction concatNodes(pos, node, parent, options) {\n  node.orig = node.val;\n  var prev = this.prev();\n  var last = utils.last(prev.nodes);\n  var isEscaped = false;\n\n  if (node.val.length &gt; 1) {\n    var a = node.val.charAt(0);\n    var b = node.val.slice(-1);\n\n    isEscaped = (a === &#039;\&quot;&#039; &amp;&amp; b === &#039;\&quot;&#039;)\n      || (a === \&quot;&#039;\&quot; &amp;&amp; b === \&quot;&#039;\&quot;)\n      || (a === &#039;`&#039; &amp;&amp; b === &#039;`&#039;);\n  }\n\n  if (isEscaped &amp;&amp; options.unescape !== false) {\n    node.val = node.val.slice(1, node.val.length - 1);\n    node.escaped = true;\n  }\n\n  if (node.match) {\n    var match = node.match[1];\n    if (!match || match.indexOf(&#039;}&#039;) === -1) {\n      match = node.match[0];\n    }\n\n    // replace each set with a single \&quot;,\&quot;\n    var val = match.replace(/\\{/g, &#039;,&#039;).replace(/\\}/g, &#039;&#039;);\n    node.multiplier *= val.length;\n    node.val = &#039;&#039;;\n  }\n\n  var simpleText = last.type === &#039;text&#039;\n    &amp;&amp; last.multiplier === 1\n    &amp;&amp; node.multiplier === 1\n    &amp;&amp; node.val;\n\n  if (simpleText) {\n    last.val += node.val;\n    return;\n  }\n\n  prev.push(node);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/braces/lib/parsers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/braces/lib/utils.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/braces/lib/utils.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar splitString = __webpack_require__(/*! split-string */ \&quot;./node_modules/split-string/index.js\&quot;);\nvar utils = module.exports;\n\n/**\n * Module dependencies\n */\n\nutils.extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nutils.flatten = __webpack_require__(/*! arr-flatten */ \&quot;./node_modules/arr-flatten/index.js\&quot;);\nutils.isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nutils.fillRange = __webpack_require__(/*! fill-range */ \&quot;./node_modules/fill-range/index.js\&quot;);\nutils.repeat = __webpack_require__(/*! repeat-element */ \&quot;./node_modules/repeat-element/index.js\&quot;);\nutils.unique = __webpack_require__(/*! array-unique */ \&quot;./node_modules/array-unique/index.js\&quot;);\n\nutils.define = function(obj, key, val) {\n  Object.defineProperty(obj, key, {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: val\n  });\n};\n\n/**\n * Returns true if the given string contains only empty brace sets.\n */\n\nutils.isEmptySets = function(str) {\n  return /^(?:\\{,\\})+$/.test(str);\n};\n\n/**\n * Returns true if the given string contains only empty brace sets.\n */\n\nutils.isQuotedString = function(str) {\n  var open = str.charAt(0);\n  if (open === &#039;\\&#039;&#039; || open === &#039;\&quot;&#039; || open === &#039;`&#039;) {\n    return str.slice(-1) === open;\n  }\n  return false;\n};\n\n/**\n * Create the key to use for memoization. The unique key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  var id = pattern;\n  if (typeof options === &#039;undefined&#039;) {\n    return id;\n  }\n  var keys = Object.keys(options);\n  for (var i = 0; i &lt; keys.length; i++) {\n    var key = keys[i];\n    id += &#039;;&#039; + key + &#039;=&#039; + String(options[key]);\n  }\n  return id;\n};\n\n/**\n * Normalize options\n */\n\nutils.createOptions = function(options) {\n  var opts = utils.extend.apply(null, arguments);\n  if (typeof opts.expand === &#039;boolean&#039;) {\n    opts.optimize = !opts.expand;\n  }\n  if (typeof opts.optimize === &#039;boolean&#039;) {\n    opts.expand = !opts.optimize;\n  }\n  if (opts.optimize === true) {\n    opts.makeRe = true;\n  }\n  return opts;\n};\n\n/**\n * Join patterns in `a` to patterns in `b`\n */\n\nutils.join = function(a, b, options) {\n  options = options || {};\n  a = utils.arrayify(a);\n  b = utils.arrayify(b);\n\n  if (!a.length) return b;\n  if (!b.length) return a;\n\n  var len = a.length;\n  var idx = -1;\n  var arr = [];\n\n  while (++idx &lt; len) {\n    var val = a[idx];\n    if (Array.isArray(val)) {\n      for (var i = 0; i &lt; val.length; i++) {\n        val[i] = utils.join(val[i], b, options);\n      }\n      arr.push(val);\n      continue;\n    }\n\n    for (var j = 0; j &lt; b.length; j++) {\n      var bval = b[j];\n\n      if (Array.isArray(bval)) {\n        arr.push(utils.join(val, bval, options));\n      } else {\n        arr.push(val + bval);\n      }\n    }\n  }\n  return arr;\n};\n\n/**\n * Split the given string on `,` if not escaped.\n */\n\nutils.split = function(str, options) {\n  var opts = utils.extend({sep: &#039;,&#039;}, options);\n  if (typeof opts.keepQuotes !== &#039;boolean&#039;) {\n    opts.keepQuotes = true;\n  }\n  if (opts.unescape === false) {\n    opts.keepEscaping = true;\n  }\n  return splitString(str, opts, utils.escapeBrackets(opts));\n};\n\n/**\n * Expand ranges or sets in the given `pattern`.\n *\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object}\n */\n\nutils.expand = function(str, options) {\n  var opts = utils.extend({rangeLimit: 10000}, options);\n  var segs = utils.split(str, opts);\n  var tok = { segs: segs };\n\n  if (utils.isQuotedString(str)) {\n    return tok;\n  }\n\n  if (opts.rangeLimit === true) {\n    opts.rangeLimit = 10000;\n  }\n\n  if (segs.length &gt; 1) {\n    if (opts.optimize === false) {\n      tok.val = segs[0];\n      return tok;\n    }\n\n    tok.segs = utils.stringifyArray(tok.segs);\n  } else if (segs.length === 1) {\n    var arr = str.split(&#039;..&#039;);\n\n    if (arr.length === 1) {\n      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;\n      tok.segs = [];\n      return tok;\n    }\n\n    if (arr.length === 2 &amp;&amp; arr[0] === arr[1]) {\n      tok.escaped = true;\n      tok.val = arr[0];\n      tok.segs = [];\n      return tok;\n    }\n\n    if (arr.length &gt; 1) {\n      if (opts.optimize !== false) {\n        opts.optimize = true;\n        delete opts.expand;\n      }\n\n      if (opts.optimize !== true) {\n        var min = Math.min(arr[0], arr[1]);\n        var max = Math.max(arr[0], arr[1]);\n        var step = arr[2] || 1;\n\n        if (opts.rangeLimit !== false &amp;&amp; ((max - min) / step &gt;= opts.rangeLimit)) {\n          throw new RangeError(&#039;expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.&#039;);\n        }\n      }\n\n      arr.push(opts);\n      tok.segs = utils.fillRange.apply(null, arr);\n\n      if (!tok.segs.length) {\n        tok.escaped = true;\n        tok.val = str;\n        return tok;\n      }\n\n      if (opts.optimize === true) {\n        tok.segs = utils.stringifyArray(tok.segs);\n      }\n\n      if (tok.segs === &#039;&#039;) {\n        tok.val = str;\n      } else {\n        tok.val = tok.segs[0];\n      }\n      return tok;\n    }\n  } else {\n    tok.val = str;\n  }\n  return tok;\n};\n\n/**\n * Ensure commas inside brackets and parens are not split.\n * @param {Object} `tok` Token from the `split-string` module\n * @return {undefined}\n */\n\nutils.escapeBrackets = function(options) {\n  return function(tok) {\n    if (tok.escaped &amp;&amp; tok.val === &#039;b&#039;) {\n      tok.val = &#039;\\\\b&#039;;\n      return;\n    }\n\n    if (tok.val !== &#039;(&#039; &amp;&amp; tok.val !== &#039;[&#039;) return;\n    var opts = utils.extend({}, options);\n    var brackets = [];\n    var parens = [];\n    var stack = [];\n    var val = tok.val;\n    var str = tok.str;\n    var i = tok.idx - 1;\n\n    while (++i &lt; str.length) {\n      var ch = str[i];\n\n      if (ch === &#039;\\\\&#039;) {\n        val += (opts.keepEscaping === false ? &#039;&#039; : ch) + str[++i];\n        continue;\n      }\n\n      if (ch === &#039;(&#039;) {\n        parens.push(ch);\n        stack.push(ch);\n      }\n\n      if (ch === &#039;[&#039;) {\n        brackets.push(ch);\n        stack.push(ch);\n      }\n\n      if (ch === &#039;)&#039;) {\n        parens.pop();\n        stack.pop();\n        if (!stack.length) {\n          val += ch;\n          break;\n        }\n      }\n\n      if (ch === &#039;]&#039;) {\n        brackets.pop();\n        stack.pop();\n        if (!stack.length) {\n          val += ch;\n          break;\n        }\n      }\n      val += ch;\n    }\n\n    tok.split = false;\n    tok.val = val.slice(1);\n    tok.idx = i;\n  };\n};\n\n/**\n * Returns true if the given string looks like a regex quantifier\n * @return {Boolean}\n */\n\nutils.isQuantifier = function(str) {\n  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);\n};\n\n/**\n * Cast `val` to an array.\n * @param {*} `val`\n */\n\nutils.stringifyArray = function(arr) {\n  return [utils.arrayify(arr).join(&#039;|&#039;)];\n};\n\n/**\n * Cast `val` to an array.\n * @param {*} `val`\n */\n\nutils.arrayify = function(arr) {\n  if (typeof arr === &#039;undefined&#039;) {\n    return [];\n  }\n  if (typeof arr === &#039;string&#039;) {\n    return [arr];\n  }\n  return arr;\n};\n\n/**\n * Returns true if the given `str` is a non-empty string\n * @return {Boolean}\n */\n\nutils.isString = function(str) {\n  return str != null &amp;&amp; typeof str === &#039;string&#039;;\n};\n\n/**\n * Get the last element from `array`\n * @param {Array} `array`\n * @return {*}\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\nutils.escapeRegex = function(str) {\n  return str.replace(/\\\\?([!^*?()[\\]{}+?/])/g, &#039;\\\\$1&#039;);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/braces/lib/utils.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/cache-base/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/cache-base/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar Emitter = __webpack_require__(/*! component-emitter */ \&quot;./node_modules/component-emitter/index.js\&quot;);\nvar visit = __webpack_require__(/*! collection-visit */ \&quot;./node_modules/collection-visit/index.js\&quot;);\nvar toPath = __webpack_require__(/*! to-object-path */ \&quot;./node_modules/to-object-path/index.js\&quot;);\nvar union = __webpack_require__(/*! union-value */ \&quot;./node_modules/union-value/index.js\&quot;);\nvar del = __webpack_require__(/*! unset-value */ \&quot;./node_modules/unset-value/index.js\&quot;);\nvar get = __webpack_require__(/*! get-value */ \&quot;./node_modules/get-value/index.js\&quot;);\nvar has = __webpack_require__(/*! has-value */ \&quot;./node_modules/has-value/index.js\&quot;);\nvar set = __webpack_require__(/*! set-value */ \&quot;./node_modules/set-value/index.js\&quot;);\n\n/**\n * Create a `Cache` constructor that when instantiated will\n * store values on the given `prop`.\n *\n * ```js\n * var Cache = require(&#039;cache-base&#039;).namespace(&#039;data&#039;);\n * var cache = new Cache();\n *\n * cache.set(&#039;foo&#039;, &#039;bar&#039;);\n * //=&gt; {data: {foo: &#039;bar&#039;}}\n * ```\n * @param {String} `prop` The property name to use for storing values.\n * @return {Function} Returns a custom `Cache` constructor\n * @api public\n */\n\nfunction namespace(prop) {\n\n  /**\n   * Create a new `Cache`. Internally the `Cache` constructor is created using\n   * the `namespace` function, with `cache` defined as the storage object.\n   *\n   * ```js\n   * var app = new Cache();\n   * ```\n   * @param {Object} `cache` Optionally pass an object to initialize with.\n   * @constructor\n   * @api public\n   */\n\n  function Cache(cache) {\n    if (prop) {\n      this[prop] = {};\n    }\n    if (cache) {\n      this.set(cache);\n    }\n  }\n\n  /**\n   * Inherit Emitter\n   */\n\n  Emitter(Cache.prototype);\n\n  /**\n   * Assign `value` to `key`. Also emits `set` with\n   * the key and value.\n   *\n   * ```js\n   * app.on(&#039;set&#039;, function(key, val) {\n   *   // do something when `set` is emitted\n   * });\n   *\n   * app.set(key, value);\n   *\n   * // also takes an object or array\n   * app.set({name: &#039;Halle&#039;});\n   * app.set([{foo: &#039;bar&#039;}, {baz: &#039;quux&#039;}]);\n   * console.log(app);\n   * //=&gt; {name: &#039;Halle&#039;, foo: &#039;bar&#039;, baz: &#039;quux&#039;}\n   * ```\n   *\n   * @name .set\n   * @emits `set` with `key` and `value` as arguments.\n   * @param {String} `key`\n   * @param {any} `value`\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n  Cache.prototype.set = function(key, val) {\n    if (Array.isArray(key) &amp;&amp; arguments.length === 2) {\n      key = toPath(key);\n    }\n    if (isObject(key) || Array.isArray(key)) {\n      this.visit(&#039;set&#039;, key);\n    } else {\n      set(prop ? this[prop] : this, key, val);\n      this.emit(&#039;set&#039;, key, val);\n    }\n    return this;\n  };\n\n  /**\n   * Union `array` to `key`. Also emits `set` with\n   * the key and value.\n   *\n   * ```js\n   * app.union(&#039;a.b&#039;, [&#039;foo&#039;]);\n   * app.union(&#039;a.b&#039;, [&#039;bar&#039;]);\n   * console.log(app.get(&#039;a&#039;));\n   * //=&gt; {b: [&#039;foo&#039;, &#039;bar&#039;]}\n   * ```\n   * @name .union\n   * @param {String} `key`\n   * @param {any} `value`\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n  Cache.prototype.union = function(key, val) {\n    if (Array.isArray(key) &amp;&amp; arguments.length === 2) {\n      key = toPath(key);\n    }\n    var ctx = prop ? this[prop] : this;\n    union(ctx, key, arrayify(val));\n    this.emit(&#039;union&#039;, val);\n    return this;\n  };\n\n  /**\n   * Return the value of `key`. Dot notation may be used\n   * to get [nested property values][get-value].\n   *\n   * ```js\n   * app.set(&#039;a.b.c&#039;, &#039;d&#039;);\n   * app.get(&#039;a.b&#039;);\n   * //=&gt; {c: &#039;d&#039;}\n   *\n   * app.get([&#039;a&#039;, &#039;b&#039;]);\n   * //=&gt; {c: &#039;d&#039;}\n   * ```\n   *\n   * @name .get\n   * @emits `get` with `key` and `value` as arguments.\n   * @param {String} `key` The name of the property to get. Dot-notation may be used.\n   * @return {any} Returns the value of `key`\n   * @api public\n   */\n\n  Cache.prototype.get = function(key) {\n    key = toPath(arguments);\n\n    var ctx = prop ? this[prop] : this;\n    var val = get(ctx, key);\n\n    this.emit(&#039;get&#039;, key, val);\n    return val;\n  };\n\n  /**\n   * Return true if app has a stored value for `key`,\n   * false only if value is `undefined`.\n   *\n   * ```js\n   * app.set(&#039;foo&#039;, &#039;bar&#039;);\n   * app.has(&#039;foo&#039;);\n   * //=&gt; true\n   * ```\n   *\n   * @name .has\n   * @emits `has` with `key` and true or false as arguments.\n   * @param {String} `key`\n   * @return {Boolean}\n   * @api public\n   */\n\n  Cache.prototype.has = function(key) {\n    key = toPath(arguments);\n\n    var ctx = prop ? this[prop] : this;\n    var val = get(ctx, key);\n\n    var has = typeof val !== &#039;undefined&#039;;\n    this.emit(&#039;has&#039;, key, has);\n    return has;\n  };\n\n  /**\n   * Delete one or more properties from the instance.\n   *\n   * ```js\n   * app.del(); // delete all\n   * // or\n   * app.del(&#039;foo&#039;);\n   * // or\n   * app.del([&#039;foo&#039;, &#039;bar&#039;]);\n   * ```\n   * @name .del\n   * @emits `del` with the `key` as the only argument.\n   * @param {String|Array} `key` Property name or array of property names.\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n  Cache.prototype.del = function(key) {\n    if (Array.isArray(key)) {\n      this.visit(&#039;del&#039;, key);\n    } else {\n      del(prop ? this[prop] : this, key);\n      this.emit(&#039;del&#039;, key);\n    }\n    return this;\n  };\n\n  /**\n   * Reset the entire cache to an empty object.\n   *\n   * ```js\n   * app.clear();\n   * ```\n   * @api public\n   */\n\n  Cache.prototype.clear = function() {\n    if (prop) {\n      this[prop] = {};\n    }\n  };\n\n  /**\n   * Visit `method` over the properties in the given object, or map\n   * visit over the object-elements in an array.\n   *\n   * @name .visit\n   * @param {String} `method` The name of the `base` method to call.\n   * @param {Object|Array} `val` The object or array to iterate over.\n   * @return {Object} Returns the instance for chaining.\n   * @api public\n   */\n\n  Cache.prototype.visit = function(method, val) {\n    visit(this, method, val);\n    return this;\n  };\n\n  return Cache;\n}\n\n/**\n * Cast val to an array\n */\n\nfunction arrayify(val) {\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n}\n\n/**\n * Expose `Cache`\n */\n\nmodule.exports = namespace();\n\n/**\n * Expose `Cache.namespace`\n */\n\nmodule.exports.namespace = namespace;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/cache-base/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/class-utils/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/class-utils/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar union = __webpack_require__(/*! arr-union */ \&quot;./node_modules/arr-union/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\nvar staticExtend = __webpack_require__(/*! static-extend */ \&quot;./node_modules/static-extend/index.js\&quot;);\nvar isObj = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\n\n/**\n * Expose class utils\n */\n\nvar cu = module.exports;\n\n/**\n * Expose class utils: `cu`\n */\n\ncu.isObject = function isObject(val) {\n  return isObj(val) || typeof val === &#039;function&#039;;\n};\n\n/**\n * Returns true if an array has any of the given elements, or an\n * object has any of the give keys.\n *\n * ```js\n * cu.has([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], &#039;c&#039;);\n * //=&gt; true\n *\n * cu.has([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], [&#039;c&#039;, &#039;z&#039;]);\n * //=&gt; true\n *\n * cu.has({a: &#039;b&#039;, c: &#039;d&#039;}, [&#039;c&#039;, &#039;z&#039;]);\n * //=&gt; true\n * ```\n * @param {Object} `obj`\n * @param {String|Array} `val`\n * @return {Boolean}\n * @api public\n */\n\ncu.has = function has(obj, val) {\n  val = cu.arrayify(val);\n  var len = val.length;\n\n  if (cu.isObject(obj)) {\n    for (var key in obj) {\n      if (val.indexOf(key) &gt; -1) {\n        return true;\n      }\n    }\n\n    var keys = cu.nativeKeys(obj);\n    return cu.has(keys, val);\n  }\n\n  if (Array.isArray(obj)) {\n    var arr = obj;\n    while (len--) {\n      if (arr.indexOf(val[len]) &gt; -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  throw new TypeError(&#039;expected an array or object.&#039;);\n};\n\n/**\n * Returns true if an array or object has all of the given values.\n *\n * ```js\n * cu.hasAll([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], &#039;c&#039;);\n * //=&gt; true\n *\n * cu.hasAll([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], [&#039;c&#039;, &#039;z&#039;]);\n * //=&gt; false\n *\n * cu.hasAll({a: &#039;b&#039;, c: &#039;d&#039;}, [&#039;c&#039;, &#039;z&#039;]);\n * //=&gt; false\n * ```\n * @param {Object|Array} `val`\n * @param {String|Array} `values`\n * @return {Boolean}\n * @api public\n */\n\ncu.hasAll = function hasAll(val, values) {\n  values = cu.arrayify(values);\n  var len = values.length;\n  while (len--) {\n    if (!cu.has(val, values[len])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Cast the given value to an array.\n *\n * ```js\n * cu.arrayify(&#039;foo&#039;);\n * //=&gt; [&#039;foo&#039;]\n *\n * cu.arrayify([&#039;foo&#039;]);\n * //=&gt; [&#039;foo&#039;]\n * ```\n *\n * @param {String|Array} `val`\n * @return {Array}\n * @api public\n */\n\ncu.arrayify = function arrayify(val) {\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Noop\n */\n\ncu.noop = function noop() {\n  return;\n};\n\n/**\n * Returns the first argument passed to the function.\n */\n\ncu.identity = function identity(val) {\n  return val;\n};\n\n/**\n * Returns true if a value has a `contructor`\n *\n * ```js\n * cu.hasConstructor({});\n * //=&gt; true\n *\n * cu.hasConstructor(Object.create(null));\n * //=&gt; false\n * ```\n * @param  {Object} `value`\n * @return {Boolean}\n * @api public\n */\n\ncu.hasConstructor = function hasConstructor(val) {\n  return cu.isObject(val) &amp;&amp; typeof val.constructor !== &#039;undefined&#039;;\n};\n\n/**\n * Get the native `ownPropertyNames` from the constructor of the\n * given `object`. An empty array is returned if the object does\n * not have a constructor.\n *\n * ```js\n * cu.nativeKeys({a: &#039;b&#039;, b: &#039;c&#039;, c: &#039;d&#039;})\n * //=&gt; [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]\n *\n * cu.nativeKeys(function(){})\n * //=&gt; [&#039;length&#039;, &#039;caller&#039;]\n * ```\n *\n * @param  {Object} `obj` Object that has a `constructor`.\n * @return {Array} Array of keys.\n * @api public\n */\n\ncu.nativeKeys = function nativeKeys(val) {\n  if (!cu.hasConstructor(val)) return [];\n  var keys = Object.getOwnPropertyNames(val);\n  if (&#039;caller&#039; in val) keys.push(&#039;caller&#039;);\n  return keys;\n};\n\n/**\n * Returns property descriptor `key` if it&#039;s an \&quot;own\&quot; property\n * of the given object.\n *\n * ```js\n * function App() {}\n * Object.defineProperty(App.prototype, &#039;count&#039;, {\n *   get: function() {\n *     return Object.keys(this).length;\n *   }\n * });\n * cu.getDescriptor(App.prototype, &#039;count&#039;);\n * // returns:\n * // {\n * //   get: [Function],\n * //   set: undefined,\n * //   enumerable: false,\n * //   configurable: false\n * // }\n * ```\n *\n * @param {Object} `obj`\n * @param {String} `key`\n * @return {Object} Returns descriptor `key`\n * @api public\n */\n\ncu.getDescriptor = function getDescriptor(obj, key) {\n  if (!cu.isObject(obj)) {\n    throw new TypeError(&#039;expected an object.&#039;);\n  }\n  if (typeof key !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected key to be a string.&#039;);\n  }\n  return Object.getOwnPropertyDescriptor(obj, key);\n};\n\n/**\n * Copy a descriptor from one object to another.\n *\n * ```js\n * function App() {}\n * Object.defineProperty(App.prototype, &#039;count&#039;, {\n *   get: function() {\n *     return Object.keys(this).length;\n *   }\n * });\n * var obj = {};\n * cu.copyDescriptor(obj, App.prototype, &#039;count&#039;);\n * ```\n * @param {Object} `receiver`\n * @param {Object} `provider`\n * @param {String} `name`\n * @return {Object}\n * @api public\n */\n\ncu.copyDescriptor = function copyDescriptor(receiver, provider, name) {\n  if (!cu.isObject(receiver)) {\n    throw new TypeError(&#039;expected receiving object to be an object.&#039;);\n  }\n  if (!cu.isObject(provider)) {\n    throw new TypeError(&#039;expected providing object to be an object.&#039;);\n  }\n  if (typeof name !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected name to be a string.&#039;);\n  }\n\n  var val = cu.getDescriptor(provider, name);\n  if (val) Object.defineProperty(receiver, name, val);\n};\n\n/**\n * Copy static properties, prototype properties, and descriptors\n * from one object to another.\n *\n * @param {Object} `receiver`\n * @param {Object} `provider`\n * @param {String|Array} `omit` One or more properties to omit\n * @return {Object}\n * @api public\n */\n\ncu.copy = function copy(receiver, provider, omit) {\n  if (!cu.isObject(receiver)) {\n    throw new TypeError(&#039;expected receiving object to be an object.&#039;);\n  }\n  if (!cu.isObject(provider)) {\n    throw new TypeError(&#039;expected providing object to be an object.&#039;);\n  }\n  var props = Object.getOwnPropertyNames(provider);\n  var keys = Object.keys(provider);\n  var len = props.length,\n    key;\n  omit = cu.arrayify(omit);\n\n  while (len--) {\n    key = props[len];\n\n    if (cu.has(keys, key)) {\n      define(receiver, key, provider[key]);\n    } else if (!(key in receiver) &amp;&amp; !cu.has(omit, key)) {\n      cu.copyDescriptor(receiver, provider, key);\n    }\n  }\n};\n\n/**\n * Inherit the static properties, prototype properties, and descriptors\n * from of an object.\n *\n * @param {Object} `receiver`\n * @param {Object} `provider`\n * @param {String|Array} `omit` One or more properties to omit\n * @return {Object}\n * @api public\n */\n\ncu.inherit = function inherit(receiver, provider, omit) {\n  if (!cu.isObject(receiver)) {\n    throw new TypeError(&#039;expected receiving object to be an object.&#039;);\n  }\n  if (!cu.isObject(provider)) {\n    throw new TypeError(&#039;expected providing object to be an object.&#039;);\n  }\n\n  var keys = [];\n  for (var key in provider) {\n    keys.push(key);\n    receiver[key] = provider[key];\n  }\n\n  keys = keys.concat(cu.arrayify(omit));\n\n  var a = provider.prototype || provider;\n  var b = receiver.prototype || receiver;\n  cu.copy(b, a, keys);\n};\n\n/**\n * Returns a function for extending the static properties,\n * prototype properties, and descriptors from the `Parent`\n * constructor onto `Child` constructors.\n *\n * ```js\n * var extend = cu.extend(Parent);\n * Parent.extend(Child);\n *\n * // optional methods\n * Parent.extend(Child, {\n *   foo: function() {},\n *   bar: function() {}\n * });\n * ```\n * @param {Function} `Parent` Parent ctor\n * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.\n *   @param {Function} `Child` Child ctor\n *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.\n *   @return {Object}\n * @api public\n */\n\ncu.extend = function() {\n  // keep it lazy, instead of assigning to `cu.extend`\n  return staticExtend.apply(null, arguments);\n};\n\n/**\n * Bubble up events emitted from static methods on the Parent ctor.\n *\n * @param {Object} `Parent`\n * @param {Array} `events` Event names to bubble up\n * @api public\n */\n\ncu.bubble = function(Parent, events) {\n  events = events || [];\n  Parent.bubble = function(Child, arr) {\n    if (Array.isArray(arr)) {\n      events = union([], events, arr);\n    }\n    var len = events.length;\n    var idx = -1;\n    while (++idx &lt; len) {\n      var name = events[idx];\n      Parent.on(name, Child.emit.bind(Child, name));\n    }\n    cu.bubble(Child, events);\n  };\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/class-utils/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/collection-visit/index.js&quot;:
/*!************************************************!*\
  !*** ./node_modules/collection-visit/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * collection-visit &lt;https://github.com/jonschlinkert/collection-visit&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar visit = __webpack_require__(/*! object-visit */ \&quot;./node_modules/object-visit/index.js\&quot;);\nvar mapVisit = __webpack_require__(/*! map-visit */ \&quot;./node_modules/map-visit/index.js\&quot;);\n\nmodule.exports = function(collection, method, val) {\n  var result;\n\n  if (typeof val === &#039;string&#039; &amp;&amp; (method in collection)) {\n    var args = [].slice.call(arguments, 2);\n    result = collection[method].apply(collection, args);\n  } else if (Array.isArray(val)) {\n    result = mapVisit.apply(null, arguments);\n  } else {\n    result = visit.apply(null, arguments);\n  }\n\n  if (typeof result !== &#039;undefined&#039;) {\n    return result;\n  }\n\n  return collection;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/collection-visit/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/component-emitter/index.js&quot;:
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/***/ ((module) =&gt; {

eval(&quot;\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (true) {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks[&#039;$&#039; + event] = this._callbacks[&#039;$&#039; + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks[&#039;$&#039; + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks[&#039;$&#039; + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i &lt; callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Remove event specific arrays for event types that no\r\n  // one is subscribed for to avoid memory leak.\r\n  if (callbacks.length === 0) {\r\n    delete this._callbacks[&#039;$&#039; + event];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  var args = new Array(arguments.length - 1)\r\n    , callbacks = this._callbacks[&#039;$&#039; + event];\r\n\r\n  for (var i = 1; i &lt; arguments.length; i++) {\r\n    args[i - 1] = arguments[i];\r\n  }\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i &lt; len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks[&#039;$&#039; + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/component-emitter/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/copy-descriptor/index.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/copy-descriptor/index.js ***!
  \***********************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * copy-descriptor &lt;https://github.com/jonschlinkert/copy-descriptor&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Copy a descriptor from one object to another.\n *\n * ```js\n * function App() {\n *   this.cache = {};\n * }\n * App.prototype.set = function(key, val) {\n *   this.cache[key] = val;\n *   return this;\n * };\n * Object.defineProperty(App.prototype, &#039;count&#039;, {\n *   get: function() {\n *     return Object.keys(this.cache).length;\n *   }\n * });\n *\n * copy(App.prototype, &#039;count&#039;, &#039;len&#039;);\n *\n * // create an instance\n * var app = new App();\n *\n * app.set(&#039;a&#039;, true);\n * app.set(&#039;b&#039;, true);\n * app.set(&#039;c&#039;, true);\n *\n * console.log(app.count);\n * //=&gt; 3\n * console.log(app.len);\n * //=&gt; 3\n * ```\n * @name copy\n * @param {Object} `receiver` The target object\n * @param {Object} `provider` The provider object\n * @param {String} `from` The key to copy on provider.\n * @param {String} `to` Optionally specify a new key name to use.\n * @return {Object}\n * @api public\n */\n\nmodule.exports = function copyDescriptor(receiver, provider, from, to) {\n  if (!isObject(provider) &amp;&amp; typeof provider !== &#039;function&#039;) {\n    to = from;\n    from = provider;\n    provider = receiver;\n  }\n  if (!isObject(receiver) &amp;&amp; typeof receiver !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected the first argument to be an object&#039;);\n  }\n  if (!isObject(provider) &amp;&amp; typeof provider !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected provider to be an object&#039;);\n  }\n\n  if (typeof to !== &#039;string&#039;) {\n    to = from;\n  }\n  if (typeof from !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected key to be a string&#039;);\n  }\n\n  if (!(from in provider)) {\n    throw new Error(&#039;property \&quot;&#039; + from + &#039;\&quot; does not exist&#039;);\n  }\n\n  var val = Object.getOwnPropertyDescriptor(provider, from);\n  if (val) Object.defineProperty(receiver, to, val);\n};\n\nfunction isObject(val) {\n  return {}.toString.call(val) === &#039;[object Object]&#039;;\n}\n\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/copy-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/core-util-is/lib/util.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don&#039;t use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === &#039;[object Array]&#039;;\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === &#039;boolean&#039;;\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === &#039;number&#039;;\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === &#039;string&#039;;\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === &#039;symbol&#039;;\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === &#039;[object RegExp]&#039;;\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === &#039;object&#039; &amp;&amp; arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === &#039;[object Date]&#039;;\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === &#039;[object Error]&#039; || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === &#039;function&#039;;\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === &#039;boolean&#039; ||\n         typeof arg === &#039;number&#039; ||\n         typeof arg === &#039;string&#039; ||\n         typeof arg === &#039;symbol&#039; ||  // ES6 symbol\n         typeof arg === &#039;undefined&#039;;\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! buffer */ \&quot;buffer\&quot;).Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/core-util-is/lib/util.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/debug/src/browser.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

eval(&quot;/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \&quot;./node_modules/debug/src/debug.js\&quot;);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = &#039;undefined&#039; != typeof chrome\n               &amp;&amp; &#039;undefined&#039; != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  &#039;lightseagreen&#039;,\n  &#039;forestgreen&#039;,\n  &#039;goldenrod&#039;,\n  &#039;dodgerblue&#039;,\n  &#039;darkorchid&#039;,\n  &#039;crimson&#039;\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \&quot;%c\&quot; CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we&#039;re in Chrome, we&#039;ll just detect this case\n  // explicitly\n  if (typeof window !== &#039;undefined&#039; &amp;&amp; window.process &amp;&amp; window.process.type === &#039;renderer&#039;) {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== &#039;undefined&#039; &amp;&amp; document.documentElement &amp;&amp; document.documentElement.style &amp;&amp; document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== &#039;undefined&#039; &amp;&amp; window.console &amp;&amp; (window.console.firebug || (window.console.exception &amp;&amp; window.console.table))) ||\n    // is firefox &gt;= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== &#039;undefined&#039; &amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) &amp;&amp; parseInt(RegExp.$1, 10) &gt;= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== &#039;undefined&#039; &amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return &#039;[UnexpectedJSONParseError]: &#039; + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? &#039;%c&#039; : &#039;&#039;)\n    + this.namespace\n    + (useColors ? &#039; %c&#039; : &#039; &#039;)\n    + args[0]\n    + (useColors ? &#039;%c &#039; : &#039; &#039;)\n    + &#039;+&#039; + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = &#039;color: &#039; + this.color;\n  args.splice(1, 0, c, &#039;color: inherit&#039;)\n\n  // the final \&quot;%c\&quot; is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if (&#039;%%&#039; === match) return;\n    index++;\n    if (&#039;%c&#039; === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \&quot;function\&quot;.\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn&#039;t have &#039;apply&#039;\n  return &#039;object&#039; === typeof console\n    &amp;&amp; console.log\n    &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem(&#039;debug&#039;);\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn&#039;t set in LS, and we&#039;re in Electron, try to load $DEBUG\n  if (!r &amp;&amp; typeof process !== &#039;undefined&#039; &amp;&amp; &#039;env&#039; in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/debug/src/browser.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/debug/src/debug.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

eval(&quot;\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug[&#039;default&#039;] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \&quot;./node_modules/ms/index.js\&quot;);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \&quot;%n\&quot; handling functions, for the debug \&quot;format\&quot; argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \&quot;n\&quot; and \&quot;N\&quot;.\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash &lt;&lt; 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i &lt; args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if (&#039;string&#039; !== typeof args[0]) {\n      // anything else let&#039;s inspect with %O\n      args.unshift(&#039;%O&#039;);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don&#039;t increase the array index\n      if (match === &#039;%%&#039;) return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if (&#039;function&#039; === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it&#039;s inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if (&#039;function&#039; === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === &#039;string&#039; ? namespaces : &#039;&#039;).split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i &lt; len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, &#039;.*?&#039;);\n    if (namespaces[0] === &#039;-&#039;) {\n      exports.skips.push(new RegExp(&#039;^&#039; + namespaces.substr(1) + &#039;$&#039;));\n    } else {\n      exports.names.push(new RegExp(&#039;^&#039; + namespaces + &#039;$&#039;));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable(&#039;&#039;);\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i &lt; len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i &lt; len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/debug/src/debug.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/debug/src/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== &#039;undefined&#039; &amp;&amp; process.type === &#039;renderer&#039;) {\n  module.exports = __webpack_require__(/*! ./browser.js */ \&quot;./node_modules/debug/src/browser.js\&quot;);\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \&quot;./node_modules/debug/src/node.js\&quot;);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/debug/src/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/debug/src/node.js&quot;:
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

eval(&quot;/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \&quot;tty\&quot;);\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \&quot;./node_modules/debug/src/debug.js\&quot;);\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === &#039;null&#039;) val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3&gt;debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd &amp;&amp; 2 !== fd) {\n  util.deprecate(function(){}, &#039;except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)&#039;)()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return &#039;colors&#039; in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split(&#039;\\n&#039;).map(function(str) {\n      return str.trim()\n    }).join(&#039; &#039;);\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = &#039;  \\u001b[3&#039; + c + &#039;;1m&#039; + name + &#039; &#039; + &#039;\\u001b[0m&#039;;\n\n    args[0] = prefix + args[0].split(&#039;\\n&#039;).join(&#039;\\n&#039; + prefix);\n    args.push(&#039;\\u001b[3&#039; + c + &#039;m+&#039; + exports.humanize(this.diff) + &#039;\\u001b[0m&#039;);\n  } else {\n    args[0] = new Date().toUTCString()\n      + &#039; &#039; + name + &#039; &#039; + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + &#039;\\n&#039;);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string &#039;null&#039; or &#039;undefined&#039;. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It&#039;s lame that node doesn&#039;t expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding(&#039;tty_wrap&#039;);\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case &#039;TTY&#039;:\n      stream = new tty.WriteStream(fd);\n      stream._type = &#039;tty&#039;;\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle &amp;&amp; stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case &#039;FILE&#039;:\n      var fs = __webpack_require__(/*! fs */ \&quot;fs\&quot;);\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = &#039;fs&#039;;\n      break;\n\n    case &#039;PIPE&#039;:\n    case &#039;TCP&#039;:\n      var net = __webpack_require__(/*! net */ \&quot;net\&quot;);\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we&#039;ll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js &lt; /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = &#039;pipe&#039;;\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle &amp;&amp; stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error(&#039;Implement me. Unknown stream file type!&#039;);\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i &lt; keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/debug/src/node.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/decode-uri-component/index.js&quot;:
/*!****************************************************!*\
  !*** ./node_modules/decode-uri-component/index.js ***!
  \****************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\nvar token = &#039;%[a-f0-9]{2}&#039;;\nvar singleMatcher = new RegExp(token, &#039;gi&#039;);\nvar multiMatcher = new RegExp(&#039;(&#039; + token + &#039;)+&#039;, &#039;gi&#039;);\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(&#039;&#039;));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i &lt; tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join(&#039;&#039;);\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t&#039;%FE%FF&#039;: &#039;\\uFFFD\\uFFFD&#039;,\n\t\t&#039;%FF%FE&#039;: &#039;\\uFFFD\\uFFFD&#039;\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap[&#039;%C2&#039;] = &#039;\\uFFFD&#039;;\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i &lt; entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, &#039;g&#039;), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== &#039;string&#039;) {\n\t\tthrow new TypeError(&#039;Expected `encodedURI` to be of type `string`, got `&#039; + typeof encodedURI + &#039;`&#039;);\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, &#039; &#039;);\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/decode-uri-component/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/index.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/define-property/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/define-property/node_modules/is-descriptor/index.js\&quot;);\n\nmodule.exports = function defineProperty(obj, prop, val) {\n  if (typeof obj !== &#039;object&#039; &amp;&amp; typeof obj !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected an object or function.&#039;);\n  }\n\n  if (typeof prop !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected `prop` to be a string.&#039;);\n  }\n\n  if (isDescriptor(val) &amp;&amp; (&#039;set&#039; in val || &#039;get&#039; in val)) {\n    return Object.defineProperty(obj, prop, val);\n  }\n\n  return Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/node_modules/is-accessor-descriptor/index.js&quot;:
/*!***********************************************************************************!*\
  !*** ./node_modules/define-property/node_modules/is-accessor-descriptor/index.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-accessor-descriptor &lt;https://github.com/jonschlinkert/is-accessor-descriptor&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/define-property/node_modules/is-accessor-descriptor/node_modules/kind-of/index.js\&quot;);\n\n// accessor descriptor properties\nvar accessor = {\n  get: &#039;function&#039;,\n  set: &#039;function&#039;,\n  configurable: &#039;boolean&#039;,\n  enumerable: &#039;boolean&#039;\n};\n\nfunction isAccessorDescriptor(obj, prop) {\n  if (typeof prop === &#039;string&#039;) {\n    var val = Object.getOwnPropertyDescriptor(obj, prop);\n    return typeof val !== &#039;undefined&#039;;\n  }\n\n  if (typeOf(obj) !== &#039;object&#039;) {\n    return false;\n  }\n\n  if (has(obj, &#039;value&#039;) || has(obj, &#039;writable&#039;)) {\n    return false;\n  }\n\n  if (!has(obj, &#039;get&#039;) || typeof obj.get !== &#039;function&#039;) {\n    return false;\n  }\n\n  // tldr: it&#039;s valid to have \&quot;set\&quot; be undefined\n  // \&quot;set\&quot; might be undefined if `Object.getOwnPropertyDescriptor`\n  // was used to get the value, and only `get` was defined by the user\n  if (has(obj, &#039;set&#039;) &amp;&amp; typeof obj[key] !== &#039;function&#039; &amp;&amp; typeof obj[key] !== &#039;undefined&#039;) {\n    return false;\n  }\n\n  for (var key in obj) {\n    if (!accessor.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (typeOf(obj[key]) === accessor[key]) {\n      continue;\n    }\n\n    if (typeof obj[key] !== &#039;undefined&#039;) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction has(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\n\n/**\n * Expose `isAccessorDescriptor`\n */\n\nmodule.exports = isAccessorDescriptor;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/node_modules/is-accessor-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/node_modules/is-accessor-descriptor/node_modules/kind-of/index.js&quot;:
/*!********************************************************************************************************!*\
  !*** ./node_modules/define-property/node_modules/is-accessor-descriptor/node_modules/kind-of/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/node_modules/is-accessor-descriptor/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/node_modules/is-data-descriptor/index.js&quot;:
/*!*******************************************************************************!*\
  !*** ./node_modules/define-property/node_modules/is-data-descriptor/index.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-data-descriptor &lt;https://github.com/jonschlinkert/is-data-descriptor&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/define-property/node_modules/is-data-descriptor/node_modules/kind-of/index.js\&quot;);\n\n// data descriptor properties\nvar data = {\n  configurable: &#039;boolean&#039;,\n  enumerable: &#039;boolean&#039;,\n  writable: &#039;boolean&#039;\n};\n\nfunction isDataDescriptor(obj, prop) {\n  if (typeOf(obj) !== &#039;object&#039;) {\n    return false;\n  }\n\n  if (typeof prop === &#039;string&#039;) {\n    var val = Object.getOwnPropertyDescriptor(obj, prop);\n    return typeof val !== &#039;undefined&#039;;\n  }\n\n  if (!(&#039;value&#039; in obj) &amp;&amp; !(&#039;writable&#039; in obj)) {\n    return false;\n  }\n\n  for (var key in obj) {\n    if (key === &#039;value&#039;) continue;\n\n    if (!data.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (typeOf(obj[key]) === data[key]) {\n      continue;\n    }\n\n    if (typeof obj[key] !== &#039;undefined&#039;) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Expose `isDataDescriptor`\n */\n\nmodule.exports = isDataDescriptor;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/node_modules/is-data-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/node_modules/is-data-descriptor/node_modules/kind-of/index.js&quot;:
/*!****************************************************************************************************!*\
  !*** ./node_modules/define-property/node_modules/is-data-descriptor/node_modules/kind-of/index.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/node_modules/is-data-descriptor/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/node_modules/is-descriptor/index.js&quot;:
/*!**************************************************************************!*\
  !*** ./node_modules/define-property/node_modules/is-descriptor/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-descriptor &lt;https://github.com/jonschlinkert/is-descriptor&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/define-property/node_modules/kind-of/index.js\&quot;);\nvar isAccessor = __webpack_require__(/*! is-accessor-descriptor */ \&quot;./node_modules/define-property/node_modules/is-accessor-descriptor/index.js\&quot;);\nvar isData = __webpack_require__(/*! is-data-descriptor */ \&quot;./node_modules/define-property/node_modules/is-data-descriptor/index.js\&quot;);\n\nmodule.exports = function isDescriptor(obj, key) {\n  if (typeOf(obj) !== &#039;object&#039;) {\n    return false;\n  }\n  if (&#039;get&#039; in obj) {\n    return isAccessor(obj, key);\n  }\n  return isData(obj, key);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/node_modules/is-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/define-property/node_modules/kind-of/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/define-property/node_modules/kind-of/index.js ***!
  \********************************************************************/
/***/ ((module) =&gt; {

eval(&quot;var toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  var type = typeof val;\n\n  // primitivies\n  if (type === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (type === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (type === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (type === &#039;function&#039; || val instanceof Function) {\n    if (typeof val.constructor.name !== &#039;undefined&#039; &amp;&amp; val.constructor.name.slice(0, 9) === &#039;Generator&#039;) {\n      return &#039;generatorfunction&#039;;\n    }\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n  if (type === &#039;[object Promise]&#039;) {\n    return &#039;promise&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n  \n  if (type === &#039;[object Map Iterator]&#039;) {\n    return &#039;mapiterator&#039;;\n  }\n  if (type === &#039;[object Set Iterator]&#039;) {\n    return &#039;setiterator&#039;;\n  }\n  if (type === &#039;[object String Iterator]&#039;) {\n    return &#039;stringiterator&#039;;\n  }\n  if (type === &#039;[object Array Iterator]&#039;) {\n    return &#039;arrayiterator&#039;;\n  }\n  \n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  return val.constructor\n    &amp;&amp; typeof val.constructor.isBuffer === &#039;function&#039;\n    &amp;&amp; val.constructor.isBuffer(val);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/define-property/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/expand-brackets/index.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/expand-brackets/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Local dependencies\n */\n\nvar compilers = __webpack_require__(/*! ./lib/compilers */ \&quot;./node_modules/expand-brackets/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./lib/parsers */ \&quot;./node_modules/expand-brackets/lib/parsers.js\&quot;);\n\n/**\n * Module dependencies\n */\n\nvar debug = __webpack_require__(/*! debug */ \&quot;./node_modules/debug/src/index.js\&quot;)(&#039;expand-brackets&#039;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nvar Snapdragon = __webpack_require__(/*! snapdragon */ \&quot;./node_modules/snapdragon/index.js\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\n\n/**\n * Parses the given POSIX character class `pattern` and returns a\n * string that can be used for creating regular expressions for matching.\n *\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\nfunction brackets(pattern, options) {\n  debug(&#039;initializing from &lt;%s&gt;&#039;, __filename);\n  var res = brackets.create(pattern, options);\n  return res.output;\n}\n\n/**\n * Takes an array of strings and a POSIX character class pattern, and returns a new\n * array with only the strings that matched the pattern.\n *\n * ```js\n * var brackets = require(&#039;expand-brackets&#039;);\n * console.log(brackets.match([&#039;1&#039;, &#039;a&#039;, &#039;ab&#039;], &#039;[[:alpha:]]&#039;));\n * //=&gt; [&#039;a&#039;]\n *\n * console.log(brackets.match([&#039;1&#039;, &#039;a&#039;, &#039;ab&#039;], &#039;[[:alpha:]]+&#039;));\n * //=&gt; [&#039;a&#039;, &#039;ab&#039;]\n * ```\n * @param {Array} `arr` Array of strings to match\n * @param {String} `pattern` POSIX character class pattern(s)\n * @param {Object} `options`\n * @return {Array}\n * @api public\n */\n\nbrackets.match = function(arr, pattern, options) {\n  arr = [].concat(arr);\n  var opts = extend({}, options);\n  var isMatch = brackets.matcher(pattern, opts);\n  var len = arr.length;\n  var idx = -1;\n  var res = [];\n\n  while (++idx &lt; len) {\n    var ele = arr[idx];\n    if (isMatch(ele)) {\n      res.push(ele);\n    }\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error(&#039;no matches found for \&quot;&#039; + pattern + &#039;\&quot;&#039;);\n    }\n\n    if (opts.nonull === true || opts.nullglob === true) {\n      return [pattern.split(&#039;\\\\&#039;).join(&#039;&#039;)];\n    }\n  }\n  return res;\n};\n\n/**\n * Returns true if the specified `string` matches the given\n * brackets `pattern`.\n *\n * ```js\n * var brackets = require(&#039;expand-brackets&#039;);\n *\n * console.log(brackets.isMatch(&#039;a.a&#039;, &#039;[[:alpha:]].[[:alpha:]]&#039;));\n * //=&gt; true\n * console.log(brackets.isMatch(&#039;1.2&#039;, &#039;[[:alpha:]].[[:alpha:]]&#039;));\n * //=&gt; false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Poxis pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\nbrackets.isMatch = function(str, pattern, options) {\n  return brackets.matcher(pattern, options)(str);\n};\n\n/**\n * Takes a POSIX character class pattern and returns a matcher function. The returned\n * function takes the string to match as its only argument.\n *\n * ```js\n * var brackets = require(&#039;expand-brackets&#039;);\n * var isMatch = brackets.matcher(&#039;[[:lower:]].[[:upper:]]&#039;);\n *\n * console.log(isMatch(&#039;a.a&#039;));\n * //=&gt; false\n * console.log(isMatch(&#039;a.A&#039;));\n * //=&gt; true\n * ```\n * @param {String} `pattern` Poxis pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\nbrackets.matcher = function(pattern, options) {\n  var re = brackets.makeRe(pattern, options);\n  return function(str) {\n    return re.test(str);\n  };\n};\n\n/**\n * Create a regular expression from the given `pattern`.\n *\n * ```js\n * var brackets = require(&#039;expand-brackets&#039;);\n * var re = brackets.makeRe(&#039;[[:alpha:]]&#039;);\n * console.log(re);\n * //=&gt; /^(?:[a-zA-Z])$/\n * ```\n * @param {String} `pattern` The pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nbrackets.makeRe = function(pattern, options) {\n  var res = brackets.create(pattern, options);\n  var opts = extend({strictErrors: false}, options);\n  return toRegex(res.output, opts);\n};\n\n/**\n * Parses the given POSIX character class `pattern` and returns an object\n * with the compiled `output` and optional source `map`.\n *\n * ```js\n * var brackets = require(&#039;expand-brackets&#039;);\n * console.log(brackets(&#039;[[:alpha:]]&#039;));\n * // { options: { source: &#039;string&#039; },\n * //   input: &#039;[[:alpha:]]&#039;,\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      not: [Function],\n * //      escape: [Function],\n * //      text: [Function],\n * //      posix: [Function],\n * //      bracket: [Function],\n * //      &#039;bracket.open&#039;: [Function],\n * //      &#039;bracket.inner&#039;: [Function],\n * //      &#039;bracket.literal&#039;: [Function],\n * //      &#039;bracket.close&#039;: [Function] },\n * //   output: &#039;[a-zA-Z]&#039;,\n * //   ast:\n * //    { type: &#039;root&#039;,\n * //      errors: [],\n * //      nodes: [ [Object], [Object], [Object] ] },\n * //   parsingErrors: [] }\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\nbrackets.create = function(pattern, options) {\n  var snapdragon = (options &amp;&amp; options.snapdragon) || new Snapdragon(options);\n  compilers(snapdragon);\n  parsers(snapdragon);\n\n  var ast = snapdragon.parse(pattern, options);\n  ast.input = pattern;\n  var res = snapdragon.compile(ast, options);\n  res.input = pattern;\n  return res;\n};\n\n/**\n * Expose `brackets` constructor, parsers and compilers\n */\n\nbrackets.compilers = compilers;\nbrackets.parsers = parsers;\n\n/**\n * Expose `brackets`\n * @type {Function}\n */\n\nmodule.exports = brackets;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/expand-brackets/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/expand-brackets/lib/compilers.js&quot;:
/*!*******************************************************!*\
  !*** ./node_modules/expand-brackets/lib/compilers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar posix = __webpack_require__(/*! posix-character-classes */ \&quot;./node_modules/posix-character-classes/index.js\&quot;);\n\nmodule.exports = function(brackets) {\n  brackets.compiler\n\n    /**\n     * Escaped characters\n     */\n\n    .set(&#039;escape&#039;, function(node) {\n      return this.emit(&#039;\\\\&#039; + node.val.replace(/^\\\\/, &#039;&#039;), node);\n    })\n\n    /**\n     * Text\n     */\n\n    .set(&#039;text&#039;, function(node) {\n      return this.emit(node.val.replace(/([{}])/g, &#039;\\\\$1&#039;), node);\n    })\n\n    /**\n     * POSIX character classes\n     */\n\n    .set(&#039;posix&#039;, function(node) {\n      if (node.val === &#039;[::]&#039;) {\n        return this.emit(&#039;\\\\[::\\\\]&#039;, node);\n      }\n\n      var val = posix[node.inner];\n      if (typeof val === &#039;undefined&#039;) {\n        val = &#039;[&#039; + node.inner + &#039;]&#039;;\n      }\n      return this.emit(val, node);\n    })\n\n    /**\n     * Non-posix brackets\n     */\n\n    .set(&#039;bracket&#039;, function(node) {\n      return this.mapVisit(node.nodes);\n    })\n    .set(&#039;bracket.open&#039;, function(node) {\n      return this.emit(node.val, node);\n    })\n    .set(&#039;bracket.inner&#039;, function(node) {\n      var inner = node.val;\n\n      if (inner === &#039;[&#039; || inner === &#039;]&#039;) {\n        return this.emit(&#039;\\\\&#039; + node.val, node);\n      }\n      if (inner === &#039;^]&#039;) {\n        return this.emit(&#039;^\\\\]&#039;, node);\n      }\n      if (inner === &#039;^&#039;) {\n        return this.emit(&#039;^&#039;, node);\n      }\n\n      if (/-/.test(inner) &amp;&amp; !/(\\d-\\d|\\w-\\w)/.test(inner)) {\n        inner = inner.split(&#039;-&#039;).join(&#039;\\\\-&#039;);\n      }\n\n      var isNegated = inner.charAt(0) === &#039;^&#039;;\n      // add slashes to negated brackets, per spec\n      if (isNegated &amp;&amp; inner.indexOf(&#039;/&#039;) === -1) {\n        inner += &#039;/&#039;;\n      }\n      if (isNegated &amp;&amp; inner.indexOf(&#039;.&#039;) === -1) {\n        inner += &#039;.&#039;;\n      }\n\n      // don&#039;t unescape `0` (octal literal)\n      inner = inner.replace(/\\\\([1-9])/g, &#039;$1&#039;);\n      return this.emit(inner, node);\n    })\n    .set(&#039;bracket.close&#039;, function(node) {\n      var val = node.val.replace(/^\\\\/, &#039;&#039;);\n      if (node.parent.escaped === true) {\n        return this.emit(&#039;\\\\&#039; + val, node);\n      }\n      return this.emit(val, node);\n    });\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/expand-brackets/lib/compilers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/expand-brackets/lib/parsers.js&quot;:
/*!*****************************************************!*\
  !*** ./node_modules/expand-brackets/lib/parsers.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/expand-brackets/lib/utils.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\n\n/**\n * Text regex\n */\n\nvar TEXT_REGEX = &#039;(\\\\[(?=.*\\\\])|\\\\])+&#039;;\nvar not = utils.createRegex(TEXT_REGEX);\n\n/**\n * Brackets parsers\n */\n\nfunction parsers(brackets) {\n  brackets.state = brackets.state || {};\n  brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];\n  brackets.parser\n\n    .capture(&#039;escape&#039;, function() {\n      if (this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(/^\\\\(.)/);\n      if (!m) return;\n\n      return pos({\n        type: &#039;escape&#039;,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Text parser\n     */\n\n    .capture(&#039;text&#039;, function() {\n      if (this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(not);\n      if (!m || !m[0]) return;\n\n      return pos({\n        type: &#039;text&#039;,\n        val: m[0]\n      });\n    })\n\n    /**\n     * POSIX character classes: \&quot;[[:alpha:][:digits:]]\&quot;\n     */\n\n    .capture(&#039;posix&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^\\[:(.*?):\\](?=.*\\])/);\n      if (!m) return;\n\n      var inside = this.isInside(&#039;bracket&#039;);\n      if (inside) {\n        brackets.posix++;\n      }\n\n      return pos({\n        type: &#039;posix&#039;,\n        insideBracket: inside,\n        inner: m[1],\n        val: m[0]\n      });\n    })\n\n    /**\n     * Bracket (noop)\n     */\n\n    .capture(&#039;bracket&#039;, function() {})\n\n    /**\n     * Open: &#039;[&#039;\n     */\n\n    .capture(&#039;bracket.open&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\[(?=.*\\])/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      if (parsed.slice(-1) === &#039;\\\\&#039; &amp;&amp; !this.isInside(&#039;bracket&#039;)) {\n        last.val = last.val.slice(0, last.val.length - 1);\n        return pos({\n          type: &#039;escape&#039;,\n          val: m[0]\n        });\n      }\n\n      var open = pos({\n        type: &#039;bracket.open&#039;,\n        val: m[0]\n      });\n\n      if (last.type === &#039;bracket.open&#039; || this.isInside(&#039;bracket&#039;)) {\n        open.val = &#039;\\\\&#039; + open.val;\n        open.type = &#039;bracket.inner&#039;;\n        open.escaped = true;\n        return open;\n      }\n\n      var node = pos({\n        type: &#039;bracket&#039;,\n        nodes: [open]\n      });\n\n      define(node, &#039;parent&#039;, prev);\n      define(open, &#039;parent&#039;, node);\n      this.push(&#039;bracket&#039;, node);\n      prev.nodes.push(node);\n    })\n\n    /**\n     * Bracket text\n     */\n\n    .capture(&#039;bracket.inner&#039;, function() {\n      if (!this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(not);\n      if (!m || !m[0]) return;\n\n      var next = this.input.charAt(0);\n      var val = m[0];\n\n      var node = pos({\n        type: &#039;bracket.inner&#039;,\n        val: val\n      });\n\n      if (val === &#039;\\\\\\\\&#039;) {\n        return node;\n      }\n\n      var first = val.charAt(0);\n      var last = val.slice(-1);\n\n      if (first === &#039;!&#039;) {\n        val = &#039;^&#039; + val.slice(1);\n      }\n\n      if (last === &#039;\\\\&#039; || (val === &#039;^&#039; &amp;&amp; next === &#039;]&#039;)) {\n        val += this.input[0];\n        this.consume(1);\n      }\n\n      node.val = val;\n      return node;\n    })\n\n    /**\n     * Close: &#039;]&#039;\n     */\n\n    .capture(&#039;bracket.close&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\]/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var last = utils.last(prev.nodes);\n\n      if (parsed.slice(-1) === &#039;\\\\&#039; &amp;&amp; !this.isInside(&#039;bracket&#039;)) {\n        last.val = last.val.slice(0, last.val.length - 1);\n\n        return pos({\n          type: &#039;escape&#039;,\n          val: m[0]\n        });\n      }\n\n      var node = pos({\n        type: &#039;bracket.close&#039;,\n        rest: this.input,\n        val: m[0]\n      });\n\n      if (last.type === &#039;bracket.open&#039;) {\n        node.type = &#039;bracket.inner&#039;;\n        node.escaped = true;\n        return node;\n      }\n\n      var bracket = this.pop(&#039;bracket&#039;);\n      if (!this.isType(bracket, &#039;bracket&#039;)) {\n        if (this.options.strict) {\n          throw new Error(&#039;missing opening \&quot;[\&quot;&#039;);\n        }\n        node.type = &#039;bracket.inner&#039;;\n        node.escaped = true;\n        return node;\n      }\n\n      bracket.nodes.push(node);\n      define(node, &#039;parent&#039;, bracket);\n    });\n}\n\n/**\n * Brackets parsers\n */\n\nmodule.exports = parsers;\n\n/**\n * Expose text regex\n */\n\nmodule.exports.TEXT_REGEX = TEXT_REGEX;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/expand-brackets/lib/parsers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/expand-brackets/lib/utils.js&quot;:
/*!***************************************************!*\
  !*** ./node_modules/expand-brackets/lib/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\nvar regexNot = __webpack_require__(/*! regex-not */ \&quot;./node_modules/regex-not/index.js\&quot;);\nvar cached;\n\n/**\n * Get the last element from `array`\n * @param {Array} `array`\n * @return {*}\n */\n\nexports.last = function(arr) {\n  return arr[arr.length - 1];\n};\n\n/**\n * Create and cache regex to use for text nodes\n */\n\nexports.createRegex = function(pattern, include) {\n  if (cached) return cached;\n  var opts = {contains: true, strictClose: false};\n  var not = regexNot.create(pattern, opts);\n  var re;\n\n  if (typeof include === &#039;string&#039;) {\n    re = toRegex(&#039;^(?:&#039; + include + &#039;|&#039; + not + &#039;)&#039;, opts);\n  } else {\n    re = toRegex(not, opts);\n  }\n\n  return (cached = re);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/expand-brackets/lib/utils.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extend-shallow/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/extend-shallow/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isObject = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/is-extendable/index.js\&quot;);\n\nmodule.exports = function extend(o/*, objects*/) {\n  if (!isObject(o)) { o = {}; }\n\n  var len = arguments.length;\n  for (var i = 1; i &lt; len; i++) {\n    var obj = arguments[i];\n\n    if (isObject(obj)) {\n      assign(o, obj);\n    }\n  }\n  return o;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extend-shallow/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extglob/index.js&quot;:
/*!***************************************!*\
  !*** ./node_modules/extglob/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Module dependencies\n */\n\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nvar unique = __webpack_require__(/*! array-unique */ \&quot;./node_modules/array-unique/index.js\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\n\n/**\n * Local dependencies\n */\n\nvar compilers = __webpack_require__(/*! ./lib/compilers */ \&quot;./node_modules/extglob/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./lib/parsers */ \&quot;./node_modules/extglob/lib/parsers.js\&quot;);\nvar Extglob = __webpack_require__(/*! ./lib/extglob */ \&quot;./node_modules/extglob/lib/extglob.js\&quot;);\nvar utils = __webpack_require__(/*! ./lib/utils */ \&quot;./node_modules/extglob/lib/utils.js\&quot;);\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * Convert the given `extglob` pattern into a regex-compatible string. Returns\n * an object with the compiled result and the parsed AST.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * console.log(extglob(&#039;*.!(*a)&#039;));\n * //=&gt; &#039;(?!\\\\.)[^/]*?\\\\.(?!(?!\\\\.)[^/]*?a\\\\b).*?&#039;\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nfunction extglob(pattern, options) {\n  return extglob.create(pattern, options).output;\n}\n\n/**\n * Takes an array of strings and an extglob pattern and returns a new\n * array that contains only the strings that match the pattern.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * console.log(extglob.match([&#039;a.a&#039;, &#039;a.b&#039;, &#039;a.c&#039;], &#039;*.!(*a)&#039;));\n * //=&gt; [&#039;a.b&#039;, &#039;a.c&#039;]\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Extglob pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nextglob.match = function(list, pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  list = utils.arrayify(list);\n  var isMatch = extglob.matcher(pattern, options);\n  var len = list.length;\n  var idx = -1;\n  var matches = [];\n\n  while (++idx &lt; len) {\n    var ele = list[idx];\n\n    if (isMatch(ele)) {\n      matches.push(ele);\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === &#039;undefined&#039;) {\n    return unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(&#039;no matches found for \&quot;&#039; + pattern + &#039;\&quot;&#039;);\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [pattern.split(&#039;\\\\&#039;).join(&#039;&#039;)];\n    }\n  }\n\n  return options.nodupes !== false ? unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given\n * extglob `pattern`.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n *\n * console.log(extglob.isMatch(&#039;a.a&#039;, &#039;*.!(*a)&#039;));\n * //=&gt; false\n * console.log(extglob.isMatch(&#039;a.b&#039;, &#039;*.!(*a)&#039;));\n * //=&gt; true\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Extglob pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\nextglob.isMatch = function(str, pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  if (pattern === str) {\n    return true;\n  }\n\n  if (pattern === &#039;&#039; || pattern === &#039; &#039; || pattern === &#039;.&#039;) {\n    return pattern === str;\n  }\n\n  var isMatch = utils.memoize(&#039;isMatch&#039;, pattern, options, extglob.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but\n * the pattern can match any part of the string.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * console.log(extglob.contains(&#039;aa/bb/cc&#039;, &#039;*b&#039;));\n * //=&gt; true\n * console.log(extglob.contains(&#039;aa/bb/cc&#039;, &#039;*d&#039;));\n * //=&gt; false\n * ```\n * @param {String} `str` The string to match.\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options`\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nextglob.contains = function(str, pattern, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  if (pattern === &#039;&#039; || pattern === &#039; &#039; || pattern === &#039;.&#039;) {\n    return pattern === str;\n  }\n\n  var opts = extend({}, options, {contains: true});\n  opts.strictClose = false;\n  opts.strictOpen = false;\n  return extglob.isMatch(str, pattern, opts);\n};\n\n/**\n * Takes an extglob pattern and returns a matcher function. The returned\n * function takes the string to match as its only argument.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * var isMatch = extglob.matcher(&#039;*.!(*a)&#039;);\n *\n * console.log(isMatch(&#039;a.a&#039;));\n * //=&gt; false\n * console.log(isMatch(&#039;a.b&#039;));\n * //=&gt; true\n * ```\n * @param {String} `pattern` Extglob pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\nextglob.matcher = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  function matcher() {\n    var re = extglob.makeRe(pattern, options);\n    return function(str) {\n      return re.test(str);\n    };\n  }\n\n  return utils.memoize(&#039;matcher&#039;, pattern, options, matcher);\n};\n\n/**\n * Convert the given `extglob` pattern into a regex-compatible string. Returns\n * an object with the compiled result and the parsed AST.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * console.log(extglob.create(&#039;*.!(*a)&#039;).output);\n * //=&gt; &#039;(?!\\\\.)[^/]*?\\\\.(?!(?!\\\\.)[^/]*?a\\\\b).*?&#039;\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nextglob.create = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  function create() {\n    var ext = new Extglob(options);\n    var ast = ext.parse(pattern, options);\n    return ext.compile(ast, options);\n  }\n\n  return utils.memoize(&#039;create&#039;, pattern, options, create);\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string`, or `null`\n * if the pattern did not match.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * extglob.capture(pattern, string[, options]);\n *\n * console.log(extglob.capture(&#039;test/*.js&#039;, &#039;test/foo.js&#039;));\n * //=&gt; [&#039;foo&#039;]\n * console.log(extglob.capture(&#039;test/*.js&#039;, &#039;foo/bar.css&#039;));\n * //=&gt; null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nextglob.capture = function(pattern, str, options) {\n  var re = extglob.makeRe(pattern, extend({capture: true}, options));\n\n  function match() {\n    return function(string) {\n      var match = re.exec(string);\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = utils.memoize(&#039;capture&#039;, pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given `pattern` and `options`.\n *\n * ```js\n * var extglob = require(&#039;extglob&#039;);\n * var re = extglob.makeRe(&#039;*.!(*a)&#039;);\n * console.log(re);\n * //=&gt; /^[^\\/]*?\\.(?![^\\/]*?a)[^\\/]*?$/\n * ```\n * @param {String} `pattern` The pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nextglob.makeRe = function(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  if (pattern.length &gt; MAX_LENGTH) {\n    throw new Error(&#039;expected pattern to be less than &#039; + MAX_LENGTH + &#039; characters&#039;);\n  }\n\n  function makeRe() {\n    var opts = extend({strictErrors: false}, options);\n    if (opts.strictErrors === true) opts.strict = true;\n    var res = extglob.create(pattern, opts);\n    return toRegex(res.output, opts);\n  }\n\n  var regex = utils.memoize(&#039;makeRe&#039;, pattern, options, makeRe);\n  if (regex.source.length &gt; MAX_LENGTH) {\n    throw new SyntaxError(&#039;potentially malicious regex detected&#039;);\n  }\n\n  return regex;\n};\n\n/**\n * Cache\n */\n\nextglob.cache = utils.cache;\nextglob.clearCache = function() {\n  extglob.cache.__data__ = {};\n};\n\n/**\n * Expose `Extglob` constructor, parsers and compilers\n */\n\nextglob.Extglob = Extglob;\nextglob.compilers = compilers;\nextglob.parsers = parsers;\n\n/**\n * Expose `extglob`\n * @type {Function}\n */\n\nmodule.exports = extglob;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extglob/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extglob/lib/compilers.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/extglob/lib/compilers.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar brackets = __webpack_require__(/*! expand-brackets */ \&quot;./node_modules/expand-brackets/index.js\&quot;);\n\n/**\n * Extglob compilers\n */\n\nmodule.exports = function(extglob) {\n  function star() {\n    if (typeof extglob.options.star === &#039;function&#039;) {\n      return extglob.options.star.apply(this, arguments);\n    }\n    if (typeof extglob.options.star === &#039;string&#039;) {\n      return extglob.options.star;\n    }\n    return &#039;.*?&#039;;\n  }\n\n  /**\n   * Use `expand-brackets` compilers\n   */\n\n  extglob.use(brackets.compilers);\n  extglob.compiler\n\n    /**\n     * Escaped: \&quot;\\\\*\&quot;\n     */\n\n    .set(&#039;escape&#039;, function(node) {\n      return this.emit(node.val, node);\n    })\n\n    /**\n     * Dot: \&quot;.\&quot;\n     */\n\n    .set(&#039;dot&#039;, function(node) {\n      return this.emit(&#039;\\\\&#039; + node.val, node);\n    })\n\n    /**\n     * Question mark: \&quot;?\&quot;\n     */\n\n    .set(&#039;qmark&#039;, function(node) {\n      var val = &#039;[^\\\\\\\\/.]&#039;;\n      var prev = this.prev();\n\n      if (node.parsed.slice(-1) === &#039;(&#039;) {\n        var ch = node.rest.charAt(0);\n        if (ch !== &#039;!&#039; &amp;&amp; ch !== &#039;=&#039; &amp;&amp; ch !== &#039;:&#039;) {\n          return this.emit(val, node);\n        }\n        return this.emit(node.val, node);\n      }\n\n      if (prev.type === &#039;text&#039; &amp;&amp; prev.val) {\n        return this.emit(val, node);\n      }\n\n      if (node.val.length &gt; 1) {\n        val += &#039;{&#039; + node.val.length + &#039;}&#039;;\n      }\n      return this.emit(val, node);\n    })\n\n    /**\n     * Plus: \&quot;+\&quot;\n     */\n\n    .set(&#039;plus&#039;, function(node) {\n      var prev = node.parsed.slice(-1);\n      if (prev === &#039;]&#039; || prev === &#039;)&#039;) {\n        return this.emit(node.val, node);\n      }\n      var ch = this.output.slice(-1);\n      if (!this.output || (/[?*+]/.test(ch) &amp;&amp; node.parent.type !== &#039;bracket&#039;)) {\n        return this.emit(&#039;\\\\+&#039;, node);\n      }\n      if (/\\w/.test(ch) &amp;&amp; !node.inside) {\n        return this.emit(&#039;+\\\\+?&#039;, node);\n      }\n      return this.emit(&#039;+&#039;, node);\n    })\n\n    /**\n     * Star: \&quot;*\&quot;\n     */\n\n    .set(&#039;star&#039;, function(node) {\n      var prev = this.prev();\n      var prefix = prev.type !== &#039;text&#039; &amp;&amp; prev.type !== &#039;escape&#039;\n        ? &#039;(?!\\\\.)&#039;\n        : &#039;&#039;;\n\n      return this.emit(prefix + star.call(this, node), node);\n    })\n\n    /**\n     * Parens\n     */\n\n    .set(&#039;paren&#039;, function(node) {\n      return this.mapVisit(node.nodes);\n    })\n    .set(&#039;paren.open&#039;, function(node) {\n      var capture = this.options.capture ? &#039;(&#039; : &#039;&#039;;\n\n      switch (node.parent.prefix) {\n        case &#039;!&#039;:\n        case &#039;^&#039;:\n          return this.emit(capture + &#039;(?:(?!(?:&#039;, node);\n        case &#039;*&#039;:\n        case &#039;+&#039;:\n        case &#039;?&#039;:\n        case &#039;@&#039;:\n          return this.emit(capture + &#039;(?:&#039;, node);\n        default: {\n          var val = node.val;\n          if (this.options.bash === true) {\n            val = &#039;\\\\&#039; + val;\n          } else if (!this.options.capture &amp;&amp; val === &#039;(&#039; &amp;&amp; node.parent.rest[0] !== &#039;?&#039;) {\n            val += &#039;?:&#039;;\n          }\n\n          return this.emit(val, node);\n        }\n      }\n    })\n    .set(&#039;paren.close&#039;, function(node) {\n      var capture = this.options.capture ? &#039;)&#039; : &#039;&#039;;\n\n      switch (node.prefix) {\n        case &#039;!&#039;:\n        case &#039;^&#039;:\n          var prefix = /^(\\)|$)/.test(node.rest) ? &#039;$&#039; : &#039;&#039;;\n          var str = star.call(this, node);\n\n          // if the extglob has a slash explicitly defined, we know the user wants\n          // to match slashes, so we need to ensure the \&quot;star\&quot; regex allows for it\n          if (node.parent.hasSlash &amp;&amp; !this.options.star &amp;&amp; this.options.slash !== false) {\n            str = &#039;.*?&#039;;\n          }\n\n          return this.emit(prefix + (&#039;))&#039; + str + &#039;)&#039;) + capture, node);\n        case &#039;*&#039;:\n        case &#039;+&#039;:\n        case &#039;?&#039;:\n          return this.emit(&#039;)&#039; + node.prefix + capture, node);\n        case &#039;@&#039;:\n          return this.emit(&#039;)&#039; + capture, node);\n        default: {\n          var val = (this.options.bash === true ? &#039;\\\\&#039; : &#039;&#039;) + &#039;)&#039;;\n          return this.emit(val, node);\n        }\n      }\n    })\n\n    /**\n     * Text\n     */\n\n    .set(&#039;text&#039;, function(node) {\n      var val = node.val.replace(/[\\[\\]]/g, &#039;\\\\$&amp;&#039;);\n      return this.emit(val, node);\n    });\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extglob/lib/compilers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extglob/lib/extglob.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/extglob/lib/extglob.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Module dependencies\n */\n\nvar Snapdragon = __webpack_require__(/*! snapdragon */ \&quot;./node_modules/snapdragon/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/extglob/node_modules/define-property/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\n\n/**\n * Local dependencies\n */\n\nvar compilers = __webpack_require__(/*! ./compilers */ \&quot;./node_modules/extglob/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./parsers */ \&quot;./node_modules/extglob/lib/parsers.js\&quot;);\n\n/**\n * Customize Snapdragon parser and renderer\n */\n\nfunction Extglob(options) {\n  this.options = extend({source: &#039;extglob&#039;}, options);\n  this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);\n  this.snapdragon.patterns = this.snapdragon.patterns || {};\n  this.compiler = this.snapdragon.compiler;\n  this.parser = this.snapdragon.parser;\n\n  compilers(this.snapdragon);\n  parsers(this.snapdragon);\n\n  /**\n   * Override Snapdragon `.parse` method\n   */\n\n  define(this.snapdragon, &#039;parse&#039;, function(str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last &amp;&amp; this.options.strict !== true) {\n      var node = last.nodes[0];\n      node.val = &#039;\\\\&#039; + node.val;\n      var sibling = node.parent.nodes[1];\n      if (sibling.type === &#039;star&#039;) {\n        sibling.loose = true;\n      }\n    }\n\n    // add non-enumerable parser reference\n    define(parsed, &#039;parser&#039;, this.parser);\n    return parsed;\n  });\n\n  /**\n   * Decorate `.parse` method\n   */\n\n  define(this, &#039;parse&#039;, function(ast, options) {\n    return this.snapdragon.parse.apply(this.snapdragon, arguments);\n  });\n\n  /**\n   * Decorate `.compile` method\n   */\n\n  define(this, &#039;compile&#039;, function(ast, options) {\n    return this.snapdragon.compile.apply(this.snapdragon, arguments);\n  });\n\n}\n\n/**\n * Expose `Extglob`\n */\n\nmodule.exports = Extglob;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extglob/lib/extglob.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extglob/lib/parsers.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/extglob/lib/parsers.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar brackets = __webpack_require__(/*! expand-brackets */ \&quot;./node_modules/expand-brackets/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/extglob/node_modules/define-property/index.js\&quot;);\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/extglob/lib/utils.js\&quot;);\n\n/**\n * Characters to use in text regex (we want to \&quot;not\&quot; match\n * characters that are matched by other parsers)\n */\n\nvar TEXT_REGEX = &#039;([!@*?+]?\\\\(|\\\\)|[*?.+\\\\\\\\]|\\\\[:?(?=.*\\\\])|:?\\\\])+&#039;;\nvar not = utils.createRegex(TEXT_REGEX);\n\n/**\n * Extglob parsers\n */\n\nfunction parsers(extglob) {\n  extglob.state = extglob.state || {};\n\n  /**\n   * Use `expand-brackets` parsers\n   */\n\n  extglob.use(brackets.parsers);\n  extglob.parser.sets.paren = extglob.parser.sets.paren || [];\n  extglob.parser\n\n    /**\n     * Extglob open: \&quot;*(\&quot;\n     */\n\n    .capture(&#039;paren.open&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^([!@*?+])?\\(/);\n      if (!m) return;\n\n      var prev = this.prev();\n      var prefix = m[1];\n      var val = m[0];\n\n      var open = pos({\n        type: &#039;paren.open&#039;,\n        parsed: parsed,\n        val: val\n      });\n\n      var node = pos({\n        type: &#039;paren&#039;,\n        prefix: prefix,\n        nodes: [open]\n      });\n\n      // if nested negation extglobs, just cancel them out to simplify\n      if (prefix === &#039;!&#039; &amp;&amp; prev.type === &#039;paren&#039; &amp;&amp; prev.prefix === &#039;!&#039;) {\n        prev.prefix = &#039;@&#039;;\n        node.prefix = &#039;@&#039;;\n      }\n\n      define(node, &#039;rest&#039;, this.input);\n      define(node, &#039;parsed&#039;, parsed);\n      define(node, &#039;parent&#039;, prev);\n      define(open, &#039;parent&#039;, node);\n\n      this.push(&#039;paren&#039;, node);\n      prev.nodes.push(node);\n    })\n\n    /**\n     * Extglob close: \&quot;)\&quot;\n     */\n\n    .capture(&#039;paren.close&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\)/);\n      if (!m) return;\n\n      var parent = this.pop(&#039;paren&#039;);\n      var node = pos({\n        type: &#039;paren.close&#039;,\n        rest: this.input,\n        parsed: parsed,\n        val: m[0]\n      });\n\n      if (!this.isType(parent, &#039;paren&#039;)) {\n        if (this.options.strict) {\n          throw new Error(&#039;missing opening paren: \&quot;(\&quot;&#039;);\n        }\n        node.escaped = true;\n        return node;\n      }\n\n      node.prefix = parent.prefix;\n      parent.nodes.push(node);\n      define(node, &#039;parent&#039;, parent);\n    })\n\n    /**\n     * Escape: \&quot;\\\\.\&quot;\n     */\n\n    .capture(&#039;escape&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^\\\\(.)/);\n      if (!m) return;\n\n      return pos({\n        type: &#039;escape&#039;,\n        val: m[0],\n        ch: m[1]\n      });\n    })\n\n    /**\n     * Question marks: \&quot;?\&quot;\n     */\n\n    .capture(&#039;qmark&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\?+(?!\\()/);\n      if (!m) return;\n      extglob.state.metachar = true;\n      return pos({\n        type: &#039;qmark&#039;,\n        rest: this.input,\n        parsed: parsed,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Character parsers\n     */\n\n    .capture(&#039;star&#039;, /^\\*(?!\\()/)\n    .capture(&#039;plus&#039;, /^\\+(?!\\()/)\n    .capture(&#039;dot&#039;, /^\\./)\n    .capture(&#039;text&#039;, not);\n};\n\n/**\n * Expose text regex string\n */\n\nmodule.exports.TEXT_REGEX = TEXT_REGEX;\n\n/**\n * Extglob parsers\n */\n\nmodule.exports = parsers;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extglob/lib/parsers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extglob/lib/utils.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/extglob/lib/utils.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar regex = __webpack_require__(/*! regex-not */ \&quot;./node_modules/regex-not/index.js\&quot;);\nvar Cache = __webpack_require__(/*! fragment-cache */ \&quot;./node_modules/fragment-cache/index.js\&quot;);\n\n/**\n * Utils\n */\n\nvar utils = module.exports;\nvar cache = utils.cache = new Cache();\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function(val) {\n  if (!Array.isArray(val)) {\n    return [val];\n  }\n  return val;\n};\n\n/**\n * Memoize a generated regex or function\n */\n\nutils.memoize = function(type, pattern, options, fn) {\n  var key = utils.createKey(type + pattern, options);\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  if (options &amp;&amp; options.cache === false) {\n    return val;\n  }\n\n  cache.set(type, key, val);\n  return val;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  var key = pattern;\n  if (typeof options === &#039;undefined&#039;) {\n    return key;\n  }\n  for (var prop in options) {\n    key += &#039;;&#039; + prop + &#039;=&#039; + String(options[prop]);\n  }\n  return key;\n};\n\n/**\n * Create the regex to use for matching text\n */\n\nutils.createRegex = function(str) {\n  var opts = {contains: true, strictClose: false};\n  return regex(str, opts);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extglob/lib/utils.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/extglob/node_modules/define-property/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/extglob/node_modules/define-property/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/is-descriptor/index.js\&quot;);\n\nmodule.exports = function defineProperty(obj, prop, val) {\n  if (typeof obj !== &#039;object&#039; &amp;&amp; typeof obj !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected an object or function.&#039;);\n  }\n\n  if (typeof prop !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected `prop` to be a string.&#039;);\n  }\n\n  if (isDescriptor(val) &amp;&amp; (&#039;set&#039; in val || &#039;get&#039; in val)) {\n    return Object.defineProperty(obj, prop, val);\n  }\n\n  return Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/extglob/node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/fill-range/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/fill-range/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * fill-range &lt;https://github.com/jonschlinkert/fill-range&gt;\n *\n * Copyright (c) 2014-2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar isNumber = __webpack_require__(/*! is-number */ \&quot;./node_modules/is-number/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nvar repeat = __webpack_require__(/*! repeat-string */ \&quot;./node_modules/repeat-string/index.js\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex-range */ \&quot;./node_modules/to-regex-range/index.js\&quot;);\n\n/**\n * Return a range of numbers or letters.\n *\n * @param  {String} `start` Start of the range\n * @param  {String} `stop` End of the range\n * @param  {String} `step` Increment or decrement to use.\n * @param  {Function} `fn` Custom function to modify each element in the range.\n * @return {Array}\n */\n\nfunction fillRange(start, stop, step, options) {\n  if (typeof start === &#039;undefined&#039;) {\n    return [];\n  }\n\n  if (typeof stop === &#039;undefined&#039; || start === stop) {\n    // special case, for handling negative zero\n    var isString = typeof start === &#039;string&#039;;\n    if (isNumber(start) &amp;&amp; !toNumber(start)) {\n      return [isString ? &#039;0&#039; : 0];\n    }\n    return [start];\n  }\n\n  if (typeof step !== &#039;number&#039; &amp;&amp; typeof step !== &#039;string&#039;) {\n    options = step;\n    step = undefined;\n  }\n\n  if (typeof options === &#039;function&#039;) {\n    options = { transform: options };\n  }\n\n  var opts = extend({step: step}, options);\n  if (opts.step &amp;&amp; !isValidNumber(opts.step)) {\n    if (opts.strictRanges === true) {\n      throw new TypeError(&#039;expected options.step to be a number&#039;);\n    }\n    return [];\n  }\n\n  opts.isNumber = isValidNumber(start) &amp;&amp; isValidNumber(stop);\n  if (!opts.isNumber &amp;&amp; !isValid(start, stop)) {\n    if (opts.strictRanges === true) {\n      throw new RangeError(&#039;invalid range arguments: &#039; + util.inspect([start, stop]));\n    }\n    return [];\n  }\n\n  opts.isPadded = isPadded(start) || isPadded(stop);\n  opts.toString = opts.stringify\n    || typeof opts.step === &#039;string&#039;\n    || typeof start === &#039;string&#039;\n    || typeof stop === &#039;string&#039;\n    || !opts.isNumber;\n\n  if (opts.isPadded) {\n    opts.maxLength = Math.max(String(start).length, String(stop).length);\n  }\n\n  // support legacy minimatch/fill-range options\n  if (typeof opts.optimize === &#039;boolean&#039;) opts.toRegex = opts.optimize;\n  if (typeof opts.makeRe === &#039;boolean&#039;) opts.toRegex = opts.makeRe;\n  return expand(start, stop, opts);\n}\n\nfunction expand(start, stop, options) {\n  var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);\n  var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);\n\n  var step = Math.abs(toNumber(options.step)) || 1;\n  if (options.toRegex &amp;&amp; step === 1) {\n    return toRange(a, b, start, stop, options);\n  }\n\n  var zero = {greater: [], lesser: []};\n  var asc = a &lt; b;\n  var arr = new Array(Math.round((asc ? b - a : a - b) / step));\n  var idx = 0;\n\n  while (asc ? a &lt;= b : a &gt;= b) {\n    var val = options.isNumber ? a : String.fromCharCode(a);\n    if (options.toRegex &amp;&amp; (val &gt;= 0 || !options.isNumber)) {\n      zero.greater.push(val);\n    } else {\n      zero.lesser.push(Math.abs(val));\n    }\n\n    if (options.isPadded) {\n      val = zeros(val, options);\n    }\n\n    if (options.toString) {\n      val = String(val);\n    }\n\n    if (typeof options.transform === &#039;function&#039;) {\n      arr[idx++] = options.transform(val, a, b, step, idx, arr, options);\n    } else {\n      arr[idx++] = val;\n    }\n\n    if (asc) {\n      a += step;\n    } else {\n      a -= step;\n    }\n  }\n\n  if (options.toRegex === true) {\n    return toSequence(arr, zero, options);\n  }\n  return arr;\n}\n\nfunction toRange(a, b, start, stop, options) {\n  if (options.isPadded) {\n    return toRegex(start, stop, options);\n  }\n\n  if (options.isNumber) {\n    return toRegex(Math.min(a, b), Math.max(a, b), options);\n  }\n\n  var start = String.fromCharCode(Math.min(a, b));\n  var stop = String.fromCharCode(Math.max(a, b));\n  return &#039;[&#039; + start + &#039;-&#039; + stop + &#039;]&#039;;\n}\n\nfunction toSequence(arr, zeros, options) {\n  var greater = &#039;&#039;, lesser = &#039;&#039;;\n  if (zeros.greater.length) {\n    greater = zeros.greater.join(&#039;|&#039;);\n  }\n  if (zeros.lesser.length) {\n    lesser = &#039;-(&#039; + zeros.lesser.join(&#039;|&#039;) + &#039;)&#039;;\n  }\n  var res = greater &amp;&amp; lesser\n    ? greater + &#039;|&#039; + lesser\n    : greater || lesser;\n\n  if (options.capture) {\n    return &#039;(&#039; + res + &#039;)&#039;;\n  }\n  return res;\n}\n\nfunction zeros(val, options) {\n  if (options.isPadded) {\n    var str = String(val);\n    var len = str.length;\n    var dash = &#039;&#039;;\n    if (str.charAt(0) === &#039;-&#039;) {\n      dash = &#039;-&#039;;\n      str = str.slice(1);\n    }\n    var diff = options.maxLength - len;\n    var pad = repeat(&#039;0&#039;, diff);\n    val = (dash + pad + str);\n  }\n  if (options.stringify) {\n    return String(val);\n  }\n  return val;\n}\n\nfunction toNumber(val) {\n  return Number(val) || 0;\n}\n\nfunction isPadded(str) {\n  return /^-?0\\d/.test(str);\n}\n\nfunction isValid(min, max) {\n  return (isValidNumber(min) || isValidLetter(min))\n      &amp;&amp; (isValidNumber(max) || isValidLetter(max));\n}\n\nfunction isValidLetter(ch) {\n  return typeof ch === &#039;string&#039; &amp;&amp; ch.length === 1 &amp;&amp; /^\\w+$/.test(ch);\n}\n\nfunction isValidNumber(n) {\n  return isNumber(n) &amp;&amp; !/\\./.test(n);\n}\n\n/**\n * Expose `fillRange`\n * @type {Function}\n */\n\nmodule.exports = fillRange;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/fill-range/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/for-in/index.js&quot;:
/*!**************************************!*\
  !*** ./node_modules/for-in/index.js ***!
  \**************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * for-in &lt;https://github.com/jonschlinkert/for-in&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function forIn(obj, fn, thisArg) {\n  for (var key in obj) {\n    if (fn.call(thisArg, obj[key], key, obj) === false) {\n      break;\n    }\n  }\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/for-in/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/fragment-cache/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/fragment-cache/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * fragment-cache &lt;https://github.com/jonschlinkert/fragment-cache&gt;\n *\n * Copyright (c) 2016-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar MapCache = __webpack_require__(/*! map-cache */ \&quot;./node_modules/map-cache/index.js\&quot;);\n\n/**\n * Create a new `FragmentCache` with an optional object to use for `caches`.\n *\n * ```js\n * var fragment = new FragmentCache();\n * ```\n * @name FragmentCache\n * @param {String} `cacheName`\n * @return {Object} Returns the [map-cache][] instance.\n * @api public\n */\n\nfunction FragmentCache(caches) {\n  this.caches = caches || {};\n}\n\n/**\n * Prototype\n */\n\nFragmentCache.prototype = {\n\n  /**\n   * Get cache `name` from the `fragment.caches` object. Creates a new\n   * `MapCache` if it doesn&#039;t already exist.\n   *\n   * ```js\n   * var cache = fragment.cache(&#039;files&#039;);\n   * console.log(fragment.caches.hasOwnProperty(&#039;files&#039;));\n   * //=&gt; true\n   * ```\n   * @name .cache\n   * @param {String} `cacheName`\n   * @return {Object} Returns the [map-cache][] instance.\n   * @api public\n   */\n\n  cache: function(cacheName) {\n    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());\n  },\n\n  /**\n   * Set a value for property `key` on cache `name`\n   *\n   * ```js\n   * fragment.set(&#039;files&#039;, &#039;somefile.js&#039;, new File({path: &#039;somefile.js&#039;}));\n   * ```\n   * @name .set\n   * @param {String} `name`\n   * @param {String} `key` Property name to set\n   * @param {any} `val` The value of `key`\n   * @return {Object} The cache instance for chaining\n   * @api public\n   */\n\n  set: function(cacheName, key, val) {\n    var cache = this.cache(cacheName);\n    cache.set(key, val);\n    return cache;\n  },\n\n  /**\n   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.\n   *\n   * ```js\n   * var cache = fragment.cache(&#039;files&#039;);\n   * cache.set(&#039;somefile.js&#039;);\n   *\n   * console.log(cache.has(&#039;somefile.js&#039;));\n   * //=&gt; true\n   *\n   * console.log(cache.has(&#039;some-other-file.js&#039;));\n   * //=&gt; false\n   * ```\n   * @name .has\n   * @param {String} `name` Cache name\n   * @param {String} `key` Optionally specify a property to check for on cache `name`\n   * @return {Boolean}\n   * @api public\n   */\n\n  has: function(cacheName, key) {\n    return typeof this.get(cacheName, key) !== &#039;undefined&#039;;\n  },\n\n  /**\n   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,\n   * so that cache `name` will be created it doesn&#039;t already exist. If `key` is not passed,\n   * the entire cache (`name`) is returned.\n   *\n   * ```js\n   * var Vinyl = require(&#039;vinyl&#039;);\n   * var cache = fragment.cache(&#039;files&#039;);\n   * cache.set(&#039;somefile.js&#039;, new Vinyl({path: &#039;somefile.js&#039;}));\n   * console.log(cache.get(&#039;somefile.js&#039;));\n   * //=&gt; &lt;File \&quot;somefile.js\&quot;&gt;\n   * ```\n   * @name .get\n   * @param {String} `name`\n   * @return {Object} Returns cache `name`, or the value of `key` if specified\n   * @api public\n   */\n\n  get: function(name, key) {\n    var cache = this.cache(name);\n    if (typeof key === &#039;string&#039;) {\n      return cache.get(key);\n    }\n    return cache;\n  }\n};\n\n/**\n * Expose `FragmentCache`\n */\n\nexports = module.exports = FragmentCache;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/fragment-cache/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/get-value/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/get-value/index.js ***!
  \*****************************************/
/***/ ((module) =&gt; {

eval(&quot;/*!\n * get-value &lt;https://github.com/jonschlinkert/get-value&gt;\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function(obj, prop, a, b, c) {\n  if (!isObject(obj) || !prop) {\n    return obj;\n  }\n\n  prop = toString(prop);\n\n  // allowing for multiple properties to be passed as\n  // a string or array, but much faster (3-4x) than doing\n  // `[].slice.call(arguments)`\n  if (a) prop += &#039;.&#039; + toString(a);\n  if (b) prop += &#039;.&#039; + toString(b);\n  if (c) prop += &#039;.&#039; + toString(c);\n\n  if (prop in obj) {\n    return obj[prop];\n  }\n\n  var segs = prop.split(&#039;.&#039;);\n  var len = segs.length;\n  var i = -1;\n\n  while (obj &amp;&amp; (++i &lt; len)) {\n    var key = segs[i];\n    while (key[key.length - 1] === &#039;\\\\&#039;) {\n      key = key.slice(0, -1) + &#039;.&#039; + segs[++i];\n    }\n    obj = obj[key];\n  }\n  return obj;\n};\n\nfunction isObject(val) {\n  return val !== null &amp;&amp; (typeof val === &#039;object&#039; || typeof val === &#039;function&#039;);\n}\n\nfunction toString(val) {\n  if (!val) return &#039;&#039;;\n  if (Array.isArray(val)) {\n    return val.join(&#039;.&#039;);\n  }\n  return val;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/get-value/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/glob-parent/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/glob-parent/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isGlob = __webpack_require__(/*! is-glob */ \&quot;./node_modules/is-glob/index.js\&quot;);\nvar pathPosixDirname = __webpack_require__(/*! path */ \&quot;path\&quot;).posix.dirname;\nvar isWin32 = __webpack_require__(/*! os */ \&quot;os\&quot;).platform() === &#039;win32&#039;;\n\nvar slash = &#039;/&#039;;\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes &amp;&amp; isWin32 &amp;&amp; str.indexOf(slash) &lt; 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += &#039;a&#039;;\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, &#039;$1&#039;);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/glob-parent/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/graceful-fs/clone.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== &#039;object&#039;)\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: getPrototypeOf(obj) }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/graceful-fs/clone.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/graceful-fs/graceful-fs.js&quot;:
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var fs = __webpack_require__(/*! fs */ \&quot;fs\&quot;)\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \&quot;./node_modules/graceful-fs/polyfills.js\&quot;)\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \&quot;./node_modules/graceful-fs/legacy-streams.js\&quot;)\nvar clone = __webpack_require__(/*! ./clone.js */ \&quot;./node_modules/graceful-fs/clone.js\&quot;)\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;)\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === &#039;function&#039; &amp;&amp; typeof Symbol.for === &#039;function&#039;) {\n  gracefulQueue = Symbol.for(&#039;graceful-fs.queue&#039;)\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for(&#039;graceful-fs.previous&#039;)\n} else {\n  gracefulQueue = &#039;___graceful-fs.queue&#039;\n  previousSymbol = &#039;___graceful-fs.previous&#039;\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog(&#039;gfs4&#039;)\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || &#039;&#039;))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = &#039;GFS4: &#039; + m.split(/\\n/).join(&#039;\\nGFS4: &#039;)\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === &#039;function&#039;)\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || &#039;&#039;)) {\n    process.on(&#039;exit&#039;, function() {\n      debug(fs[gracefulQueue])\n      __webpack_require__(/*! assert */ \&quot;assert\&quot;).equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH &amp;&amp; !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === &#039;function&#039;)\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err &amp;&amp; (err.code === &#039;EMFILE&#039; || err.code === &#039;ENFILE&#039;))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === &#039;function&#039;)\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === &#039;function&#039;)\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err &amp;&amp; (err.code === &#039;EMFILE&#039; || err.code === &#039;ENFILE&#039;))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === &#039;function&#039;)\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === &#039;function&#039;)\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err &amp;&amp; (err.code === &#039;EMFILE&#039; || err.code === &#039;ENFILE&#039;))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === &#039;function&#039;)\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === &#039;function&#039;) {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err &amp;&amp; (err.code === &#039;EMFILE&#039; || err.code === &#039;ENFILE&#039;))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === &#039;function&#039;)\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    if (typeof options === &#039;function&#039;)\n      cb = options, options = null\n\n    return go$readdir(path, options, cb)\n\n    function go$readdir (path, options, cb, startTime) {\n      return fs$readdir(path, options, function (err, files) {\n        if (err &amp;&amp; (err.code === &#039;EMFILE&#039; || err.code === &#039;ENFILE&#039;))\n          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (files &amp;&amp; files.sort)\n            files.sort()\n\n          if (typeof cb === &#039;function&#039;)\n            cb.call(this, err, files)\n        }\n      })\n    }\n  }\n\n  if (process.version.substr(0, 4) === &#039;v0.8&#039;) {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, &#039;ReadStream&#039;, {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, &#039;WriteStream&#039;, {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, &#039;FileReadStream&#039;, {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, &#039;FileWriteStream&#039;, {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit(&#039;error&#039;, err)\n      } else {\n        that.fd = fd\n        that.emit(&#039;open&#039;, fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit(&#039;error&#039;, err)\n      } else {\n        that.fd = fd\n        that.emit(&#039;open&#039;, fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === &#039;function&#039;)\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err &amp;&amp; (err.code === &#039;EMFILE&#039; || err.code === &#039;ENFILE&#039;))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === &#039;function&#039;)\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug(&#039;ENQUEUE&#039;, elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we&#039;ll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i &lt; fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don&#039;t\n    // bother modifying those since they&#039;ll be retried anyway.\n    if (fs[gracefulQueue][i].length &gt; 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we&#039;re actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don&#039;t have a startTime we have no way of knowing if we&#039;ve waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug(&#039;RETRY&#039;, fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime &gt;= 60000) {\n    // it&#039;s been more than 60 seconds total, bail now\n    debug(&#039;TIMEOUT&#039;, fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === &#039;function&#039;)\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we&#039;ve been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it&#039;s been long enough since the last retry, do it again\n    if (sinceAttempt &gt;= desiredDelay) {\n      debug(&#039;RETRY&#039;, fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can&#039;t do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn&#039;t already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/graceful-fs/graceful-fs.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/graceful-fs/legacy-streams.js&quot;:
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var Stream = __webpack_require__(/*! stream */ \&quot;stream\&quot;).Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = &#039;r&#039;;\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index &lt; length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if (&#039;number&#039; !== typeof this.start) {\n        throw TypeError(&#039;start must be a Number&#039;);\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if (&#039;number&#039; !== typeof this.end) {\n        throw TypeError(&#039;end must be a Number&#039;);\n      }\n\n      if (this.start &gt; this.end) {\n        throw new Error(&#039;start must be &lt;= end&#039;);\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit(&#039;error&#039;, err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit(&#039;open&#039;, fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = &#039;w&#039;;\n    this.encoding = &#039;binary&#039;;\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index &lt; length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if (&#039;number&#039; !== typeof this.start) {\n        throw TypeError(&#039;start must be a Number&#039;);\n      }\n      if (this.start &lt; 0) {\n        throw new Error(&#039;start must be &gt;= zero&#039;);\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/graceful-fs/legacy-streams.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/graceful-fs/polyfills.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var constants = __webpack_require__(/*! constants */ \&quot;constants\&quot;)\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === &#039;function&#039;) {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty(&#039;O_SYMLINK&#039;) &amp;&amp;\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn&#039;t support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn&#039;t resolve.\n  if (platform === \&quot;win32\&quot;) {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            &amp;&amp; (er.code === \&quot;EACCES\&quot; || er.code === \&quot;EPERM\&quot;)\n            &amp;&amp; Date.now() - start &lt; 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater &amp;&amp; stater.code === \&quot;ENOENT\&quot;)\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff &lt; 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ &amp;&amp; typeof callback_ === &#039;function&#039;) {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er &amp;&amp; er.code === &#039;EAGAIN&#039; &amp;&amp; eagCounter &lt; 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === &#039;EAGAIN&#039; &amp;&amp; eagCounter &lt; 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\&quot;O_SYMLINK\&quot;)) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === &#039;function&#039;) {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid &lt; 0) stats.uid += 0x100000000\n          if (stats.gid &lt; 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid &lt; 0) stats.uid += 0x100000000\n      if (stats.gid &lt; 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn&#039;t support the op. Just ignore\n  // that, because it doesn&#039;t matter.\n  //\n  // if there&#039;s no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it&#039;s strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \&quot;ENOSYS\&quot;)\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \&quot;EINVAL\&quot; || er.code === \&quot;EPERM\&quot;)\n        return true\n    }\n\n    return false\n  }\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/graceful-fs/polyfills.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/has-value/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/has-value/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * has-value &lt;https://github.com/jonschlinkert/has-value&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar hasValues = __webpack_require__(/*! has-values */ \&quot;./node_modules/has-values/index.js\&quot;);\nvar get = __webpack_require__(/*! get-value */ \&quot;./node_modules/get-value/index.js\&quot;);\n\nmodule.exports = function(val, prop) {\n  return hasValues(isObject(val) &amp;&amp; prop ? get(val, prop) : val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/has-value/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/has-values/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/has-values/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * has-values &lt;https://github.com/jonschlinkert/has-values&gt;\n *\n * Copyright (c) 2014-2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/has-values/node_modules/kind-of/index.js\&quot;);\nvar isNumber = __webpack_require__(/*! is-number */ \&quot;./node_modules/is-number/index.js\&quot;);\n\nmodule.exports = function hasValue(val) {\n  // is-number checks for NaN and other edge cases\n  if (isNumber(val)) {\n    return true;\n  }\n\n  switch (typeOf(val)) {\n    case &#039;null&#039;:\n    case &#039;boolean&#039;:\n    case &#039;function&#039;:\n      return true;\n    case &#039;string&#039;:\n    case &#039;arguments&#039;:\n      return val.length !== 0;\n    case &#039;error&#039;:\n      return val.message !== &#039;&#039;;\n    case &#039;array&#039;:\n      var len = val.length;\n      if (len === 0) {\n        return false;\n      }\n      for (var i = 0; i &lt; len; i++) {\n        if (hasValue(val[i])) {\n          return true;\n        }\n      }\n      return false;\n    case &#039;file&#039;:\n    case &#039;map&#039;:\n    case &#039;set&#039;:\n      return val.size !== 0;\n    case &#039;object&#039;:\n      var keys = Object.keys(val);\n      if (keys.length === 0) {\n        return false;\n      }\n      for (var i = 0; i &lt; keys.length; i++) {\n        var key = keys[i];\n        if (hasValue(val[key])) {\n          return true;\n        }\n      }\n      return false;\n    default: {\n      return false;\n    }\n  }\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/has-values/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/has-values/node_modules/kind-of/index.js&quot;:
/*!***************************************************************!*\
  !*** ./node_modules/has-values/node_modules/kind-of/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n  if (type === &#039;[object Promise]&#039;) {\n    return &#039;promise&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/has-values/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/inherits/inherits.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;try {\n  var util = __webpack_require__(/*! util */ \&quot;util\&quot;);\n  /* istanbul ignore next */\n  if (typeof util.inherits !== &#039;function&#039;) throw &#039;&#039;;\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \&quot;./node_modules/inherits/inherits_browser.js\&quot;);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/inherits/inherits.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/inherits/inherits_browser.js&quot;:
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) =&gt; {

eval(&quot;if (typeof Object.create === &#039;function&#039;) {\n  // implementation from standard node.js &#039;util&#039; module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/inherits/inherits_browser.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-accessor-descriptor/index.js&quot;:
/*!******************************************************!*\
  !*** ./node_modules/is-accessor-descriptor/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-accessor-descriptor &lt;https://github.com/jonschlinkert/is-accessor-descriptor&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/kind-of/index.js\&quot;);\n\n// accessor descriptor properties\nvar accessor = {\n  get: &#039;function&#039;,\n  set: &#039;function&#039;,\n  configurable: &#039;boolean&#039;,\n  enumerable: &#039;boolean&#039;\n};\n\nfunction isAccessorDescriptor(obj, prop) {\n  if (typeof prop === &#039;string&#039;) {\n    var val = Object.getOwnPropertyDescriptor(obj, prop);\n    return typeof val !== &#039;undefined&#039;;\n  }\n\n  if (typeOf(obj) !== &#039;object&#039;) {\n    return false;\n  }\n\n  if (has(obj, &#039;value&#039;) || has(obj, &#039;writable&#039;)) {\n    return false;\n  }\n\n  if (!has(obj, &#039;get&#039;) || typeof obj.get !== &#039;function&#039;) {\n    return false;\n  }\n\n  // tldr: it&#039;s valid to have \&quot;set\&quot; be undefined\n  // \&quot;set\&quot; might be undefined if `Object.getOwnPropertyDescriptor`\n  // was used to get the value, and only `get` was defined by the user\n  if (has(obj, &#039;set&#039;) &amp;&amp; typeof obj[key] !== &#039;function&#039; &amp;&amp; typeof obj[key] !== &#039;undefined&#039;) {\n    return false;\n  }\n\n  for (var key in obj) {\n    if (!accessor.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (typeOf(obj[key]) === accessor[key]) {\n      continue;\n    }\n\n    if (typeof obj[key] !== &#039;undefined&#039;) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction has(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\n\n/**\n * Expose `isAccessorDescriptor`\n */\n\nmodule.exports = isAccessorDescriptor;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-accessor-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-binary-path/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/is-binary-path/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\nvar path = __webpack_require__(/*! path */ \&quot;path\&quot;);\nvar binaryExtensions = __webpack_require__(/*! binary-extensions */ \&quot;./node_modules/binary-extensions/binary-extensions.json\&quot;);\nvar exts = Object.create(null);\n\nbinaryExtensions.forEach(function (el) {\n\texts[el] = true;\n});\n\nmodule.exports = function (filepath) {\n\treturn path.extname(filepath).slice(1).toLowerCase() in exts;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-binary-path/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-buffer/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/***/ ((module) =&gt; {

eval(&quot;/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh &lt;https://feross.org&gt;\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it&#039;s missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null &amp;&amp; (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor &amp;&amp; typeof obj.constructor.isBuffer === &#039;function&#039; &amp;&amp; obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === &#039;function&#039; &amp;&amp; typeof obj.slice === &#039;function&#039; &amp;&amp; isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-buffer/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-data-descriptor/index.js&quot;:
/*!**************************************************!*\
  !*** ./node_modules/is-data-descriptor/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-data-descriptor &lt;https://github.com/jonschlinkert/is-data-descriptor&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/kind-of/index.js\&quot;);\n\nmodule.exports = function isDataDescriptor(obj, prop) {\n  // data descriptor properties\n  var data = {\n    configurable: &#039;boolean&#039;,\n    enumerable: &#039;boolean&#039;,\n    writable: &#039;boolean&#039;\n  };\n\n  if (typeOf(obj) !== &#039;object&#039;) {\n    return false;\n  }\n\n  if (typeof prop === &#039;string&#039;) {\n    var val = Object.getOwnPropertyDescriptor(obj, prop);\n    return typeof val !== &#039;undefined&#039;;\n  }\n\n  if (!(&#039;value&#039; in obj) &amp;&amp; !(&#039;writable&#039; in obj)) {\n    return false;\n  }\n\n  for (var key in obj) {\n    if (key === &#039;value&#039;) continue;\n\n    if (!data.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (typeOf(obj[key]) === data[key]) {\n      continue;\n    }\n\n    if (typeof obj[key] !== &#039;undefined&#039;) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-data-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-descriptor/index.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/is-descriptor/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-descriptor &lt;https://github.com/jonschlinkert/is-descriptor&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/kind-of/index.js\&quot;);\nvar isAccessor = __webpack_require__(/*! is-accessor-descriptor */ \&quot;./node_modules/is-accessor-descriptor/index.js\&quot;);\nvar isData = __webpack_require__(/*! is-data-descriptor */ \&quot;./node_modules/is-data-descriptor/index.js\&quot;);\n\nmodule.exports = function isDescriptor(obj, key) {\n  if (typeOf(obj) !== &#039;object&#039;) {\n    return false;\n  }\n  if (&#039;get&#039; in obj) {\n    return isAccessor(obj, key);\n  }\n  return isData(obj, key);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-descriptor/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-extendable/index.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/is-extendable/index.js ***!
  \*********************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nmodule.exports = function isExtendable(val) {\n  return typeof val !== &#039;undefined&#039; &amp;&amp; val !== null\n    &amp;&amp; (typeof val === &#039;object&#039; || typeof val === &#039;function&#039;);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-extglob/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/is-extglob/index.js ***!
  \******************************************/
/***/ ((module) =&gt; {

eval(&quot;/*!\n * is-extglob &lt;https://github.com/jonschlinkert/is-extglob&gt;\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== &#039;string&#039; || str === &#039;&#039;) {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-extglob/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-glob/index.js&quot;:
/*!***************************************!*\
  !*** ./node_modules/is-glob/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;/*!\n * is-glob &lt;https://github.com/jonschlinkert/is-glob&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = __webpack_require__(/*! is-extglob */ \&quot;./node_modules/is-extglob/index.js\&quot;);\nvar chars = { &#039;{&#039;: &#039;}&#039;, &#039;(&#039;: &#039;)&#039;, &#039;[&#039;: &#039;]&#039;};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== &#039;string&#039; || str === &#039;&#039;) {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options &amp;&amp; options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open &amp;&amp; close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-glob/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-number/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/is-number/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-number &lt;https://github.com/jonschlinkert/is-number&gt;\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/is-number/node_modules/kind-of/index.js\&quot;);\n\nmodule.exports = function isNumber(num) {\n  var type = typeOf(num);\n\n  if (type === &#039;string&#039;) {\n    if (!num.trim()) return false;\n  } else if (type !== &#039;number&#039;) {\n    return false;\n  }\n\n  return (num - num + 1) &gt;= 0;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-number/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-number/node_modules/kind-of/index.js&quot;:
/*!**************************************************************!*\
  !*** ./node_modules/is-number/node_modules/kind-of/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-number/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-plain-object/index.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/is-plain-object/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-plain-object &lt;https://github.com/jonschlinkert/is-plain-object&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    &amp;&amp; Object.prototype.toString.call(o) === &#039;[object Object]&#039;;\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== &#039;function&#039;) return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty(&#039;isPrototypeOf&#039;) === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-plain-object/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/is-windows/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/is-windows/index.js ***!
  \******************************************/
/***/ ((module, exports) =&gt; {

eval(&quot;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * is-windows &lt;https://github.com/jonschlinkert/is-windows&gt;\n *\n * Copyright © 2015-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n(function(factory) {\n  if (exports &amp;&amp; typeof exports === &#039;object&#039; &amp;&amp; \&quot;object\&quot; !== &#039;undefined&#039;) {\n    module.exports = factory();\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#039;function&#039; ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function() {\n  &#039;use strict&#039;;\n  return function isWindows() {\n    return process &amp;&amp; (process.platform === &#039;win32&#039; || /^(msys|cygwin)$/.test(process.env.OSTYPE));\n  };\n});\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/is-windows/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/isarray/index.js&quot;:
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) =&gt; {

eval(&quot;var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == &#039;[object Array]&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/isarray/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/isobject/index.js&quot;:
/*!****************************************!*\
  !*** ./node_modules/isobject/index.js ***!
  \****************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * isobject &lt;https://github.com/jonschlinkert/isobject&gt;\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function isObject(val) {\n  return val != null &amp;&amp; typeof val === &#039;object&#039; &amp;&amp; Array.isArray(val) === false;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/isobject/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/kind-of/index.js&quot;:
/*!***************************************!*\
  !*** ./node_modules/kind-of/index.js ***!
  \***************************************/
/***/ ((module) =&gt; {

eval(&quot;var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return &#039;undefined&#039;;\n  if (val === null) return &#039;null&#039;;\n\n  var type = typeof val;\n  if (type === &#039;boolean&#039;) return &#039;boolean&#039;;\n  if (type === &#039;string&#039;) return &#039;string&#039;;\n  if (type === &#039;number&#039;) return &#039;number&#039;;\n  if (type === &#039;symbol&#039;) return &#039;symbol&#039;;\n  if (type === &#039;function&#039;) {\n    return isGeneratorFn(val) ? &#039;generatorfunction&#039; : &#039;function&#039;;\n  }\n\n  if (isArray(val)) return &#039;array&#039;;\n  if (isBuffer(val)) return &#039;buffer&#039;;\n  if (isArguments(val)) return &#039;arguments&#039;;\n  if (isDate(val)) return &#039;date&#039;;\n  if (isError(val)) return &#039;error&#039;;\n  if (isRegexp(val)) return &#039;regexp&#039;;\n\n  switch (ctorName(val)) {\n    case &#039;Symbol&#039;: return &#039;symbol&#039;;\n    case &#039;Promise&#039;: return &#039;promise&#039;;\n\n    // Set, Map, WeakSet, WeakMap\n    case &#039;WeakMap&#039;: return &#039;weakmap&#039;;\n    case &#039;WeakSet&#039;: return &#039;weakset&#039;;\n    case &#039;Map&#039;: return &#039;map&#039;;\n    case &#039;Set&#039;: return &#039;set&#039;;\n\n    // 8-bit typed arrays\n    case &#039;Int8Array&#039;: return &#039;int8array&#039;;\n    case &#039;Uint8Array&#039;: return &#039;uint8array&#039;;\n    case &#039;Uint8ClampedArray&#039;: return &#039;uint8clampedarray&#039;;\n\n    // 16-bit typed arrays\n    case &#039;Int16Array&#039;: return &#039;int16array&#039;;\n    case &#039;Uint16Array&#039;: return &#039;uint16array&#039;;\n\n    // 32-bit typed arrays\n    case &#039;Int32Array&#039;: return &#039;int32array&#039;;\n    case &#039;Uint32Array&#039;: return &#039;uint32array&#039;;\n    case &#039;Float32Array&#039;: return &#039;float32array&#039;;\n    case &#039;Float64Array&#039;: return &#039;float64array&#039;;\n  }\n\n  if (isGeneratorObj(val)) {\n    return &#039;generator&#039;;\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case &#039;[object Object]&#039;: return &#039;object&#039;;\n    // iterators\n    case &#039;[object Map Iterator]&#039;: return &#039;mapiterator&#039;;\n    case &#039;[object Set Iterator]&#039;: return &#039;setiterator&#039;;\n    case &#039;[object String Iterator]&#039;: return &#039;stringiterator&#039;;\n    case &#039;[object Array Iterator]&#039;: return &#039;arrayiterator&#039;;\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, &#039;&#039;);\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === &#039;function&#039; ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === &#039;string&#039; &amp;&amp; val.constructor &amp;&amp; typeof val.constructor.stackTraceLimit === &#039;number&#039;);\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === &#039;function&#039;\n    &amp;&amp; typeof val.getDate === &#039;function&#039;\n    &amp;&amp; typeof val.setDate === &#039;function&#039;;\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === &#039;string&#039;\n    &amp;&amp; typeof val.ignoreCase === &#039;boolean&#039;\n    &amp;&amp; typeof val.multiline === &#039;boolean&#039;\n    &amp;&amp; typeof val.global === &#039;boolean&#039;;\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === &#039;GeneratorFunction&#039;;\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === &#039;function&#039;\n    &amp;&amp; typeof val.return === &#039;function&#039;\n    &amp;&amp; typeof val.next === &#039;function&#039;;\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === &#039;number&#039; &amp;&amp; typeof val.callee === &#039;function&#039;) {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf(&#039;callee&#039;) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor &amp;&amp; typeof val.constructor.isBuffer === &#039;function&#039;) {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/map-cache/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/map-cache/index.js ***!
  \*****************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * map-cache &lt;https://github.com/jonschlinkert/map-cache&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * Expose `MapCache`\n */\n\nmodule.exports = MapCache;\n\n/**\n * Creates a cache object to store key/value pairs.\n *\n * ```js\n * var cache = new MapCache();\n * ```\n *\n * @api public\n */\n\nfunction MapCache(data) {\n  this.__data__ = data || {};\n}\n\n/**\n * Adds `value` to `key` on the cache.\n *\n * ```js\n * cache.set(&#039;foo&#039;, &#039;bar&#039;);\n * ```\n *\n * @param {String} `key` The key of the value to cache.\n * @param {*} `value` The value to cache.\n * @returns {Object} Returns the `Cache` object for chaining.\n * @api public\n */\n\nMapCache.prototype.set = function mapSet(key, value) {\n  if (key !== &#039;__proto__&#039;) {\n    this.__data__[key] = value;\n  }\n  return this;\n};\n\n/**\n * Gets the cached value for `key`.\n *\n * ```js\n * cache.get(&#039;foo&#039;);\n * //=&gt; &#039;bar&#039;\n * ```\n *\n * @param {String} `key` The key of the value to get.\n * @returns {*} Returns the cached value.\n * @api public\n */\n\nMapCache.prototype.get = function mapGet(key) {\n  return key === &#039;__proto__&#039; ? undefined : this.__data__[key];\n};\n\n/**\n * Checks if a cached value for `key` exists.\n *\n * ```js\n * cache.has(&#039;foo&#039;);\n * //=&gt; true\n * ```\n *\n * @param {String} `key` The key of the entry to check.\n * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.\n * @api public\n */\n\nMapCache.prototype.has = function mapHas(key) {\n  return key !== &#039;__proto__&#039; &amp;&amp; hasOwn.call(this.__data__, key);\n};\n\n/**\n * Removes `key` and its value from the cache.\n *\n * ```js\n * cache.del(&#039;foo&#039;);\n * ```\n * @title .del\n * @param {String} `key` The key of the value to remove.\n * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.\n * @api public\n */\n\nMapCache.prototype.del = function mapDelete(key) {\n  return this.has(key) &amp;&amp; delete this.__data__[key];\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/map-cache/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/map-visit/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/map-visit/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar visit = __webpack_require__(/*! object-visit */ \&quot;./node_modules/object-visit/index.js\&quot;);\n\n/**\n * Map `visit` over an array of objects.\n *\n * @param  {Object} `collection` The context in which to invoke `method`\n * @param  {String} `method` Name of the method to call on `collection`\n * @param  {Object} `arr` Array of objects.\n */\n\nmodule.exports = function mapVisit(collection, method, val) {\n  if (isObject(val)) {\n    return visit.apply(null, arguments);\n  }\n\n  if (!Array.isArray(val)) {\n    throw new TypeError(&#039;expected an array: &#039; + util.inspect(val));\n  }\n\n  var args = [].slice.call(arguments, 3);\n\n  for (var i = 0; i &lt; val.length; i++) {\n    var ele = val[i];\n    if (isObject(ele)) {\n      visit.apply(null, [collection, method, ele].concat(args));\n    } else {\n      collection[method].apply(collection, [ele].concat(args));\n    }\n  }\n};\n\nfunction isObject(val) {\n  return val &amp;&amp; (typeof val === &#039;function&#039; || (!Array.isArray(val) &amp;&amp; typeof val === &#039;object&#039;));\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/map-visit/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/micromatch/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Module dependencies\n */\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar braces = __webpack_require__(/*! braces */ \&quot;./node_modules/braces/index.js\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/micromatch/node_modules/extend-shallow/index.js\&quot;);\n\n/**\n * Local dependencies\n */\n\nvar compilers = __webpack_require__(/*! ./lib/compilers */ \&quot;./node_modules/micromatch/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./lib/parsers */ \&quot;./node_modules/micromatch/lib/parsers.js\&quot;);\nvar cache = __webpack_require__(/*! ./lib/cache */ \&quot;./node_modules/micromatch/lib/cache.js\&quot;);\nvar utils = __webpack_require__(/*! ./lib/utils */ \&quot;./node_modules/micromatch/lib/utils.js\&quot;);\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm(list, patterns[, options]);\n *\n * console.log(mm([&#039;a.js&#039;, &#039;a.txt&#039;], [&#039;*.js&#039;]));\n * //=&gt; [ &#039;a.js&#039; ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx &lt; len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === &#039;string&#039; &amp;&amp; pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match([&#039;a.a&#039;, &#039;a.aa&#039;, &#039;a.b&#039;, &#039;a.c&#039;], &#039;*.a&#039;));\n * //=&gt; [&#039;a.a&#039;, &#039;a.aa&#039;]\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nmicromatch.match = function(list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize(&#039;match&#039;, pattern, options, micromatch.matcher);\n  var matches = [];\n\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx &lt; len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === &#039;undefined&#039;) {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(&#039;no matches found for \&quot;&#039; + pattern + &#039;\&quot;&#039;);\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch(&#039;a.a&#039;, &#039;*.a&#039;));\n * //=&gt; true\n * console.log(mm.isMatch(&#039;a.b&#039;, &#039;*.a&#039;));\n * //=&gt; false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nmicromatch.isMatch = function(str, pattern, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize(&#039;isMatch&#039;, pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // true\n * console.log(mm.some([&#039;foo.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = function(list, patterns, options) {\n  if (typeof list === &#039;string&#039;) {\n    list = [list];\n  }\n  for (var i = 0; i &lt; list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every(&#039;foo.js&#039;, [&#039;foo.js&#039;]));\n * // true\n * console.log(mm.every([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;]));\n * // true\n * console.log(mm.every([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n * console.log(mm.every([&#039;foo.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = function(list, patterns, options) {\n  if (typeof list === &#039;string&#039;) {\n    list = [list];\n  }\n  for (var i = 0; i &lt; list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any(&#039;a.a&#039;, [&#039;b.*&#039;, &#039;*.a&#039;]));\n * //=&gt; true\n * console.log(mm.any(&#039;a.a&#039;, &#039;b.*&#039;));\n * //=&gt; false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.any = function(str, patterns, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === &#039;string&#039;) {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i &lt; patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all(&#039;foo.js&#039;, [&#039;foo.js&#039;]));\n * // true\n *\n * console.log(mm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n *\n * console.log(mm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;foo.js&#039;]));\n * // true\n *\n * console.log(mm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;f*&#039;, &#039;*o*&#039;, &#039;*o.js&#039;]));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = function(str, patterns, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n  if (typeof patterns === &#039;string&#039;) {\n    patterns = [patterns];\n  }\n  for (var i = 0; i &lt; patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not([&#039;a.a&#039;, &#039;b.b&#039;, &#039;c.c&#039;], &#039;*.a&#039;));\n * //=&gt; [&#039;b.b&#039;, &#039;c.c&#039;]\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function(list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains(&#039;aa/bb/cc&#039;, &#039;*b&#039;));\n * //=&gt; true\n * console.log(mm.contains(&#039;aa/bb/cc&#039;, &#039;*d&#039;));\n * //=&gt; false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = function(str, patterns, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (typeof patterns === &#039;string&#039;) {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {contains: true});\n  return micromatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nmicromatch.matchBase = function(pattern, options) {\n  if (pattern &amp;&amp; pattern.indexOf(&#039;/&#039;) !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: &#039;a&#039;, ab: &#039;b&#039;, ac: &#039;c&#039; };\n * console.log(mm.matchKeys(obj, &#039;*b&#039;));\n * //=&gt; { ab: &#039;b&#039; }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = function(obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError(&#039;expected the first argument to be an object&#039;);\n  }\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher(&#039;*.!(*a)&#039;);\n * console.log(isMatch(&#039;a.a&#039;));\n * //=&gt; false\n * console.log(isMatch(&#039;a.b&#039;));\n * //=&gt; true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError(&#039;expected pattern to be an array, string or regex&#039;);\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options &amp;&amp; options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = micromatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n\n    return function(str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  var fn = test(re);\n  Object.defineProperty(fn, &#039;result&#039;, {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture(&#039;test/*.js&#039;, &#039;test/foo.js&#039;));\n * //=&gt; [&#039;foo&#039;]\n * console.log(mm.capture(&#039;test/*.js&#039;, &#039;foo/bar.css&#039;));\n * //=&gt; null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = function(pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({capture: true}, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function(string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize(&#039;capture&#039;, pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe(&#039;*.js&#039;));\n * //=&gt; /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  if (pattern.length &gt; MAX_LENGTH) {\n    throw new Error(&#039;expected pattern to be less than &#039; + MAX_LENGTH + &#039; characters&#039;);\n  }\n\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function(obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n\n    var regex = toRegex(output.join(&#039;|&#039;), options);\n    Object.defineProperty(regex, &#039;result&#039;, {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n\n  return memoize(&#039;makeRe&#039;, pattern, options, makeRe);\n};\n\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * console.log(mm.braces(&#039;foo/{a,b}/bar&#039;));\n * //=&gt; [&#039;foo/(a|b)/bar&#039;]\n *\n * console.log(mm.braces(&#039;foo/{a,b}/bar&#039;, {expand: true}));\n * //=&gt; [&#039;foo/(a|b)/bar&#039;]\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039; &amp;&amp; !Array.isArray(pattern)) {\n    throw new TypeError(&#039;expected pattern to be an array or string&#039;);\n  }\n\n  function expand() {\n    if (options &amp;&amp; options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n    return braces(pattern, options);\n  }\n\n  return memoize(&#039;braces&#039;, pattern, options, expand);\n};\n\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\nmicromatch.braceExpand = function(pattern, options) {\n  var opts = extend({}, options, {expand: true});\n  return micromatch.braces(pattern, opts);\n};\n\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create(&#039;abc/*.js&#039;));\n * // [{ options: { source: &#039;string&#039;, sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: &#039;(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js&#039;,\n * //   ast:\n * //    { type: &#039;root&#039;,\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: &#039;abc/*.js&#039; },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ &#039;string&#039; ],\n * //      names: [],\n * //      mappings: &#039;AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE&#039;,\n * //      sourcesContent: [ &#039;abc/*.js&#039; ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nmicromatch.create = function(pattern, options) {\n  return memoize(&#039;create&#039;, pattern, options, function() {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n\n    while (++idx &lt; len) {\n      res.push(create(pattern[idx], options));\n    }\n    return res;\n  });\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse(&#039;a/{b,c}/d&#039;);\n * console.log(ast);\n * // { type: &#039;root&#039;,\n * //   errors: [],\n * //   input: &#039;a/{b,c}/d&#039;,\n * //   nodes:\n * //    [ { type: &#039;bos&#039;, val: &#039;&#039; },\n * //      { type: &#039;text&#039;, val: &#039;a/&#039; },\n * //      { type: &#039;brace&#039;,\n * //        nodes:\n * //         [ { type: &#039;brace.open&#039;, val: &#039;{&#039; },\n * //           { type: &#039;text&#039;, val: &#039;b,c&#039; },\n * //           { type: &#039;brace.close&#039;, val: &#039;}&#039; } ] },\n * //      { type: &#039;text&#039;, val: &#039;/d&#039; },\n * //      { type: &#039;eos&#039;, val: &#039;&#039; } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nmicromatch.parse = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, &#039;snapdragon&#039;, snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize(&#039;parse&#039;, pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require(&#039;micromatch&#039;);\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse(&#039;a/{b,c}/d&#039;);\n * console.log(mm.compile(ast));\n * // { options: { source: &#039;string&#039; },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      &#039;brace.open&#039;: [Function],\n * //      text: [Function],\n * //      &#039;brace.close&#039;: [Function] },\n * //   output: [ &#039;a/(b|c)/d&#039; ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nmicromatch.compile = function(ast, options) {\n  if (typeof ast === &#039;string&#039;) {\n    ast = micromatch.parse(ast, options);\n  }\n\n  return memoize(&#039;compile&#039;, ast.input, options, function() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\nmicromatch.clearCache = function() {\n  micromatch.cache.caches = {};\n};\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nfunction isEmptyString(val) {\n  return String(val) === &#039;&#039; || String(val) === &#039;./&#039;;\n}\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n\n  return memoize(&#039;compose&#039;, String(patterns), options, function() {\n    return function(file) {\n      // delay composition until it&#039;s invoked the first time,\n      // after that it won&#039;t be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i &lt; patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + &#039;=&#039; + pattern, options);\n\n  if (options &amp;&amp; options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/lib/cache.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/micromatch/lib/cache.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;module.exports = new (__webpack_require__(/*! fragment-cache */ \&quot;./node_modules/fragment-cache/index.js\&quot;))();\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/lib/cache.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/lib/compilers.js&quot;:
/*!**************************************************!*\
  !*** ./node_modules/micromatch/lib/compilers.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar nanomatch = __webpack_require__(/*! nanomatch */ \&quot;./node_modules/nanomatch/index.js\&quot;);\nvar extglob = __webpack_require__(/*! extglob */ \&quot;./node_modules/extglob/index.js\&quot;);\n\nmodule.exports = function(snapdragon) {\n  var compilers = snapdragon.compiler.compilers;\n  var opts = snapdragon.options;\n\n  // register nanomatch compilers\n  snapdragon.use(nanomatch.compilers);\n\n  // get references to some specific nanomatch compilers before they\n  // are overridden by the extglob and/or custom compilers\n  var escape = compilers.escape;\n  var qmark = compilers.qmark;\n  var slash = compilers.slash;\n  var star = compilers.star;\n  var text = compilers.text;\n  var plus = compilers.plus;\n  var dot = compilers.dot;\n\n  // register extglob compilers or escape exglobs if disabled\n  if (opts.extglob === false || opts.noext === true) {\n    snapdragon.compiler.use(escapeExtglobs);\n  } else {\n    snapdragon.use(extglob.compilers);\n  }\n\n  snapdragon.use(function() {\n    this.options.star = this.options.star || function(/*node*/) {\n      return &#039;[^\\\\\\\\/]*?&#039;;\n    };\n  });\n\n  // custom micromatch compilers\n  snapdragon.compiler\n\n    // reset referenced compiler\n    .set(&#039;dot&#039;, dot)\n    .set(&#039;escape&#039;, escape)\n    .set(&#039;plus&#039;, plus)\n    .set(&#039;slash&#039;, slash)\n    .set(&#039;qmark&#039;, qmark)\n    .set(&#039;star&#039;, star)\n    .set(&#039;text&#039;, text);\n};\n\nfunction escapeExtglobs(compiler) {\n  compiler.set(&#039;paren&#039;, function(node) {\n    var val = &#039;&#039;;\n    visit(node, function(tok) {\n      if (tok.val) val += (/^\\W/.test(tok.val) ? &#039;\\\\&#039; : &#039;&#039;) + tok.val;\n    });\n    return this.emit(val, node);\n  });\n\n  /**\n   * Visit `node` with the given `fn`\n   */\n\n  function visit(node, fn) {\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n\n  /**\n   * Map visit over array of `nodes`.\n   */\n\n  function mapVisit(nodes, fn) {\n    var len = nodes.length;\n    var idx = -1;\n    while (++idx &lt; len) {\n      visit(nodes[idx], fn);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/lib/compilers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/lib/parsers.js&quot;:
/*!************************************************!*\
  !*** ./node_modules/micromatch/lib/parsers.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar extglob = __webpack_require__(/*! extglob */ \&quot;./node_modules/extglob/index.js\&quot;);\nvar nanomatch = __webpack_require__(/*! nanomatch */ \&quot;./node_modules/nanomatch/index.js\&quot;);\nvar regexNot = __webpack_require__(/*! regex-not */ \&quot;./node_modules/regex-not/index.js\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\nvar not;\n\n/**\n * Characters to use in negation regex (we want to \&quot;not\&quot; match\n * characters that are matched by other parsers)\n */\n\nvar TEXT = &#039;([!@*?+]?\\\\(|\\\\)|\\\\[:?(?=.*?:?\\\\])|:?\\\\]|[*+?!^$.\\\\\\\\/])+&#039;;\nvar createNotRegex = function(opts) {\n  return not || (not = textRegex(TEXT));\n};\n\n/**\n * Parsers\n */\n\nmodule.exports = function(snapdragon) {\n  var parsers = snapdragon.parser.parsers;\n\n  // register nanomatch parsers\n  snapdragon.use(nanomatch.parsers);\n\n  // get references to some specific nanomatch parsers before they\n  // are overridden by the extglob and/or parsers\n  var escape = parsers.escape;\n  var slash = parsers.slash;\n  var qmark = parsers.qmark;\n  var plus = parsers.plus;\n  var star = parsers.star;\n  var dot = parsers.dot;\n\n  // register extglob parsers\n  snapdragon.use(extglob.parsers);\n\n  // custom micromatch parsers\n  snapdragon.parser\n    .use(function() {\n      // override \&quot;notRegex\&quot; created in nanomatch parser\n      this.notRegex = /^\\!+(?!\\()/;\n    })\n    // reset the referenced parsers\n    .capture(&#039;escape&#039;, escape)\n    .capture(&#039;slash&#039;, slash)\n    .capture(&#039;qmark&#039;, qmark)\n    .capture(&#039;star&#039;, star)\n    .capture(&#039;plus&#039;, plus)\n    .capture(&#039;dot&#039;, dot)\n\n    /**\n     * Override `text` parser\n     */\n\n    .capture(&#039;text&#039;, function() {\n      if (this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(createNotRegex(this.options));\n      if (!m || !m[0]) return;\n\n      // escape regex boundary characters and simple brackets\n      var val = m[0].replace(/([[\\]^$])/g, &#039;\\\\$1&#039;);\n\n      return pos({\n        type: &#039;text&#039;,\n        val: val\n      });\n    });\n};\n\n/**\n * Create text regex\n */\n\nfunction textRegex(pattern) {\n  var notStr = regexNot.create(pattern, {contains: true, strictClose: false});\n  var prefix = &#039;(?:[\\\\^]|\\\\\\\\|&#039;;\n  return toRegex(prefix + notStr + &#039;)&#039;, {strictClose: false});\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/lib/parsers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/lib/utils.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/micromatch/lib/utils.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar utils = module.exports;\nvar path = __webpack_require__(/*! path */ \&quot;path\&quot;);\n\n/**\n * Module dependencies\n */\n\nvar Snapdragon = __webpack_require__(/*! snapdragon */ \&quot;./node_modules/snapdragon/index.js\&quot;);\nutils.define = __webpack_require__(/*! define-property */ \&quot;./node_modules/micromatch/node_modules/define-property/index.js\&quot;);\nutils.diff = __webpack_require__(/*! arr-diff */ \&quot;./node_modules/arr-diff/index.js\&quot;);\nutils.extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/micromatch/node_modules/extend-shallow/index.js\&quot;);\nutils.pick = __webpack_require__(/*! object.pick */ \&quot;./node_modules/object.pick/index.js\&quot;);\nutils.typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/kind-of/index.js\&quot;);\nutils.unique = __webpack_require__(/*! array-unique */ \&quot;./node_modules/array-unique/index.js\&quot;);\n\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function() {\n  return path.sep === &#039;\\\\&#039; || process.platform === &#039;win32&#039;;\n};\n\n/**\n * Get the `Snapdragon` instance to use\n */\n\nutils.instantiate = function(ast, options) {\n  var snapdragon;\n  // if an instance was created by `.parse`, use that instance\n  if (utils.typeOf(ast) === &#039;object&#039; &amp;&amp; ast.snapdragon) {\n    snapdragon = ast.snapdragon;\n  // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === &#039;object&#039; &amp;&amp; options.snapdragon) {\n    snapdragon = options.snapdragon;\n  // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, &#039;parse&#039;, function(str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last &amp;&amp; this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n      if (last.type === &#039;bracket&#039;) {\n        if (inner.val.charAt(0) === &#039;[&#039;) {\n          inner.val = &#039;\\\\&#039; + inner.val;\n        }\n\n      } else {\n        open.val = &#039;\\\\&#039; + open.val;\n        var sibling = open.parent.nodes[1];\n        if (sibling.type === &#039;star&#039;) {\n          sibling.loose = true;\n        }\n      }\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, &#039;parser&#039;, this.parser);\n    return parsed;\n  });\n\n  return snapdragon;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  if (utils.typeOf(options) !== &#039;object&#039;) {\n    return pattern;\n  }\n  var val = pattern;\n  var keys = Object.keys(options);\n  for (var i = 0; i &lt; keys.length; i++) {\n    var key = keys[i];\n    val += &#039;;&#039; + key + &#039;=&#039; + String(options[key]);\n  }\n  return val;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === &#039;string&#039;) return [val];\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isString = function(val) {\n  return typeof val === &#039;string&#039;;\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isObject = function(val) {\n  return utils.typeOf(val) === &#039;object&#039;;\n};\n\n/**\n * Returns true if the given `str` has special characters\n */\n\nutils.hasSpecialChars = function(str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|\\[\\]{}]|[+@]\\()/.test(str);\n};\n\n/**\n * Escape regex characters in the given string\n */\n\nutils.escapeRegex = function(str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\\\/\\s]/g, &#039;\\\\$&amp;&#039;);\n};\n\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\nutils.toPosixPath = function(str) {\n  return str.replace(/\\\\+/g, &#039;/&#039;);\n};\n\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\nutils.unescape = function(str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, &#039;&#039;));\n};\n\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripPrefix = function(str) {\n  if (str.charAt(0) !== &#039;.&#039;) {\n    return str;\n  }\n  var ch = str.charAt(1);\n  if (utils.isSlash(ch)) {\n    return str.slice(2);\n  }\n  return str;\n};\n\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\nutils.isSlash = function(str) {\n  return str === &#039;/&#039; || str === &#039;\\\\/&#039; || str === &#039;\\\\&#039; || str === &#039;\\\\\\\\&#039;;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function(pattern, options) {\n  return (options &amp;&amp; options.contains)\n    ? utils.containsPattern(pattern, options)\n    : utils.equalsPattern(pattern, options);\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\nutils._equals = function(filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\nutils._contains = function(filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.equalsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.containsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function(filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\nutils.matchBasename = function(re) {\n  return function(filepath) {\n    return re.test(path.basename(filepath));\n  };\n};\n\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\nutils.value = function(str, unixify, options) {\n  if (options &amp;&amp; options.unixify === false) {\n    return str;\n  }\n  return unixify(str);\n};\n\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\nutils.unixify = function(options) {\n  options = options || {};\n  return function(filepath) {\n    if (utils.isWindows() || options.unixify === true) {\n      filepath = utils.toPosixPath(filepath);\n    }\n    if (options.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n    if (options.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n    return filepath;\n  };\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/lib/utils.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/node_modules/define-property/index.js&quot;:
/*!***********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/define-property/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isobject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/is-descriptor/index.js\&quot;);\nvar define = (typeof Reflect !== &#039;undefined&#039; &amp;&amp; Reflect.defineProperty)\n  ? Reflect.defineProperty\n  : Object.defineProperty;\n\nmodule.exports = function defineProperty(obj, key, val) {\n  if (!isobject(obj) &amp;&amp; typeof obj !== &#039;function&#039; &amp;&amp; !Array.isArray(obj)) {\n    throw new TypeError(&#039;expected an object, function, or array&#039;);\n  }\n\n  if (typeof key !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected \&quot;key\&quot; to be a string&#039;);\n  }\n\n  if (isDescriptor(val)) {\n    define(obj, key, val);\n    return obj;\n  }\n\n  define(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/node_modules/extend-shallow/index.js&quot;:
/*!**********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/extend-shallow/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isExtendable = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/micromatch/node_modules/is-extendable/index.js\&quot;);\nvar assignSymbols = __webpack_require__(/*! assign-symbols */ \&quot;./node_modules/assign-symbols/index.js\&quot;);\n\nmodule.exports = Object.assign || function(obj/*, objects*/) {\n  if (obj === null || typeof obj === &#039;undefined&#039;) {\n    throw new TypeError(&#039;Cannot convert undefined or null to object&#039;);\n  }\n  if (!isObject(obj)) {\n    obj = {};\n  }\n  for (var i = 1; i &lt; arguments.length; i++) {\n    var val = arguments[i];\n    if (isString(val)) {\n      val = toObject(val);\n    }\n    if (isObject(val)) {\n      assign(obj, val);\n      assignSymbols(obj, val);\n    }\n  }\n  return obj;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction isString(val) {\n  return (val &amp;&amp; typeof val === &#039;string&#039;);\n}\n\nfunction toObject(str) {\n  var obj = {};\n  for (var i in str) {\n    obj[i] = str[i];\n  }\n  return obj;\n}\n\nfunction isObject(val) {\n  return (val &amp;&amp; typeof val === &#039;object&#039;) || isExtendable(val);\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isEnum(obj, key) {\n  return Object.prototype.propertyIsEnumerable.call(obj, key);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/node_modules/extend-shallow/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/micromatch/node_modules/is-extendable/index.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/is-extendable/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\n\nmodule.exports = function isExtendable(val) {\n  return isPlainObject(val) || typeof val === &#039;function&#039; || Array.isArray(val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/micromatch/node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/mixin-deep/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/mixin-deep/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isExtendable = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/mixin-deep/node_modules/is-extendable/index.js\&quot;);\nvar forIn = __webpack_require__(/*! for-in */ \&quot;./node_modules/for-in/index.js\&quot;);\n\nfunction mixinDeep(target, objects) {\n  var len = arguments.length, i = 0;\n  while (++i &lt; len) {\n    var obj = arguments[i];\n    if (isObject(obj)) {\n      forIn(obj, copy, target);\n    }\n  }\n  return target;\n}\n\n/**\n * Copy properties from the source object to the\n * target object.\n *\n * @param  {*} `val`\n * @param  {String} `key`\n */\n\nfunction copy(val, key) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  var obj = this[key];\n  if (isObject(val) &amp;&amp; isObject(obj)) {\n    mixinDeep(obj, val);\n  } else {\n    this[key] = val;\n  }\n}\n\n/**\n * Returns true if `val` is an object or function.\n *\n * @param  {any} val\n * @return {Boolean}\n */\n\nfunction isObject(val) {\n  return isExtendable(val) &amp;&amp; !Array.isArray(val);\n}\n\n/**\n * Returns true if `key` is a valid key to use when extending objects.\n *\n * @param  {String} `key`\n * @return {Boolean}\n */\n\nfunction isValidKey(key) {\n  return key !== &#039;__proto__&#039; &amp;&amp; key !== &#039;constructor&#039; &amp;&amp; key !== &#039;prototype&#039;;\n};\n\n/**\n * Expose `mixinDeep`\n */\n\nmodule.exports = mixinDeep;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/mixin-deep/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/mixin-deep/node_modules/is-extendable/index.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/mixin-deep/node_modules/is-extendable/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\n\nmodule.exports = function isExtendable(val) {\n  return isPlainObject(val) || typeof val === &#039;function&#039; || Array.isArray(val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/mixin-deep/node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/ms/index.js&quot;:
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) =&gt; {

eval(&quot;/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === &#039;string&#039; &amp;&amp; val.length &gt; 0) {\n    return parse(val);\n  } else if (type === &#039;number&#039; &amp;&amp; isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    &#039;val is not a non-empty string or a valid number. val=&#039; +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length &gt; 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || &#039;ms&#039;).toLowerCase();\n  switch (type) {\n    case &#039;years&#039;:\n    case &#039;year&#039;:\n    case &#039;yrs&#039;:\n    case &#039;yr&#039;:\n    case &#039;y&#039;:\n      return n * y;\n    case &#039;days&#039;:\n    case &#039;day&#039;:\n    case &#039;d&#039;:\n      return n * d;\n    case &#039;hours&#039;:\n    case &#039;hour&#039;:\n    case &#039;hrs&#039;:\n    case &#039;hr&#039;:\n    case &#039;h&#039;:\n      return n * h;\n    case &#039;minutes&#039;:\n    case &#039;minute&#039;:\n    case &#039;mins&#039;:\n    case &#039;min&#039;:\n    case &#039;m&#039;:\n      return n * m;\n    case &#039;seconds&#039;:\n    case &#039;second&#039;:\n    case &#039;secs&#039;:\n    case &#039;sec&#039;:\n    case &#039;s&#039;:\n      return n * s;\n    case &#039;milliseconds&#039;:\n    case &#039;millisecond&#039;:\n    case &#039;msecs&#039;:\n    case &#039;msec&#039;:\n    case &#039;ms&#039;:\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms &gt;= d) {\n    return Math.round(ms / d) + &#039;d&#039;;\n  }\n  if (ms &gt;= h) {\n    return Math.round(ms / h) + &#039;h&#039;;\n  }\n  if (ms &gt;= m) {\n    return Math.round(ms / m) + &#039;m&#039;;\n  }\n  if (ms &gt;= s) {\n    return Math.round(ms / s) + &#039;s&#039;;\n  }\n  return ms + &#039;ms&#039;;\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, &#039;day&#039;) ||\n    plural(ms, h, &#039;hour&#039;) ||\n    plural(ms, m, &#039;minute&#039;) ||\n    plural(ms, s, &#039;second&#039;) ||\n    ms + &#039; ms&#039;;\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms &lt; n) {\n    return;\n  }\n  if (ms &lt; n * 1.5) {\n    return Math.floor(ms / n) + &#039; &#039; + name;\n  }\n  return Math.ceil(ms / n) + &#039; &#039; + name + &#039;s&#039;;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/ms/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/nanomatch/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Module dependencies\n */\n\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/nanomatch/node_modules/extend-shallow/index.js\&quot;);\n\n/**\n * Local dependencies\n */\n\nvar compilers = __webpack_require__(/*! ./lib/compilers */ \&quot;./node_modules/nanomatch/lib/compilers.js\&quot;);\nvar parsers = __webpack_require__(/*! ./lib/parsers */ \&quot;./node_modules/nanomatch/lib/parsers.js\&quot;);\nvar cache = __webpack_require__(/*! ./lib/cache */ \&quot;./node_modules/nanomatch/lib/cache.js\&quot;);\nvar utils = __webpack_require__(/*! ./lib/utils */ \&quot;./node_modules/nanomatch/lib/utils.js\&quot;);\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm(list, patterns[, options]);\n *\n * console.log(nm([&#039;a.js&#039;, &#039;a.txt&#039;], [&#039;*.js&#039;]));\n * //=&gt; [ &#039;a.js&#039; ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction nanomatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return nanomatch.match(list, patterns[0], options);\n  }\n\n  var negated = false;\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx &lt; len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === &#039;string&#039; &amp;&amp; pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));\n      negated = true;\n    } else {\n      keep.push.apply(keep, nanomatch.match(list, pattern, options));\n    }\n  }\n\n  // minimatch.match parity\n  if (negated &amp;&amp; keep.length === 0) {\n    if (options &amp;&amp; options.unixify === false) {\n      keep = list.slice();\n    } else {\n      var unixify = utils.unixify(options);\n      for (var i = 0; i &lt; list.length; i++) {\n        keep.push(unixify(list[i]));\n      }\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.match(list, pattern[, options]);\n *\n * console.log(nm.match([&#039;a.a&#039;, &#039;a.aa&#039;, &#039;a.b&#039;, &#039;a.c&#039;], &#039;*.a&#039;));\n * //=&gt; [&#039;a.a&#039;, &#039;a.aa&#039;]\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nnanomatch.match = function(list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize(&#039;match&#039;, pattern, options, nanomatch.matcher);\n  var matches = [];\n\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx &lt; len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === &#039;undefined&#039;) {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(&#039;no matches found for \&quot;&#039; + pattern + &#039;\&quot;&#039;);\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = nanomatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.isMatch(string, pattern[, options]);\n *\n * console.log(nm.isMatch(&#039;a.a&#039;, &#039;*.a&#039;));\n * //=&gt; true\n * console.log(nm.isMatch(&#039;a.b&#039;, &#039;*.a&#039;));\n * //=&gt; false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nnanomatch.isMatch = function(str, pattern, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize(&#039;isMatch&#039;, pattern, options, nanomatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the elements in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.some(list, patterns[, options]);\n *\n * console.log(nm.some([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // true\n * console.log(nm.some([&#039;foo.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.some = function(list, patterns, options) {\n  if (typeof list === &#039;string&#039;) {\n    list = [list];\n  }\n\n  for (var i = 0; i &lt; list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Returns true if every element in the given `list` matches\n * at least one of the given glob `patterns`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.every(list, patterns[, options]);\n *\n * console.log(nm.every(&#039;foo.js&#039;, [&#039;foo.js&#039;]));\n * // true\n * console.log(nm.every([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;]));\n * // true\n * console.log(nm.every([&#039;foo.js&#039;, &#039;bar.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n * console.log(nm.every([&#039;foo.js&#039;], [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.every = function(list, patterns, options) {\n  if (typeof list === &#039;string&#039;) {\n    list = [list];\n  }\n\n  for (var i = 0; i &lt; list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.any(string, patterns[, options]);\n *\n * console.log(nm.any(&#039;a.a&#039;, [&#039;b.*&#039;, &#039;*.a&#039;]));\n * //=&gt; true\n * console.log(nm.any(&#039;a.a&#039;, &#039;b.*&#039;));\n * //=&gt; false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.any = function(str, patterns, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === &#039;string&#039;) {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i &lt; patterns.length; i++) {\n    if (nanomatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns`\n * match the specified string.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.all(string, patterns[, options]);\n *\n * console.log(nm.all(&#039;foo.js&#039;, [&#039;foo.js&#039;]));\n * // true\n *\n * console.log(nm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;!foo.js&#039;]));\n * // false\n *\n * console.log(nm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;foo.js&#039;]));\n * // true\n *\n * console.log(nm.all(&#039;foo.js&#039;, [&#039;*.js&#039;, &#039;f*&#039;, &#039;*o*&#039;, &#039;*o.js&#039;]));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.all = function(str, patterns, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (typeof patterns === &#039;string&#039;) {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i &lt; patterns.length; i++) {\n    if (!nanomatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.not(list, patterns[, options]);\n *\n * console.log(nm.not([&#039;a.a&#039;, &#039;b.b&#039;, &#039;c.c&#039;], &#039;*.a&#039;));\n * //=&gt; [&#039;b.b&#039;, &#039;c.c&#039;]\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nnanomatch.not = function(list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n\n  list = utils.arrayify(list);\n\n  var matches = utils.diff(list, nanomatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, nanomatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.contains(string, pattern[, options]);\n *\n * console.log(nm.contains(&#039;aa/bb/cc&#039;, &#039;*b&#039;));\n * //=&gt; true\n * console.log(nm.contains(&#039;aa/bb/cc&#039;, &#039;*d&#039;));\n * //=&gt; false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nnanomatch.contains = function(str, patterns, options) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string: \&quot;&#039; + util.inspect(str) + &#039;\&quot;&#039;);\n  }\n\n  if (typeof patterns === &#039;string&#039;) {\n    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {contains: true});\n  return nanomatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nnanomatch.matchBase = function(pattern, options) {\n  if (pattern &amp;&amp; pattern.indexOf(&#039;/&#039;) !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: &#039;a&#039;, ab: &#039;b&#039;, ac: &#039;c&#039; };\n * console.log(nm.matchKeys(obj, &#039;*b&#039;));\n * //=&gt; { ab: &#039;b&#039; }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nnanomatch.matchKeys = function(obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError(&#039;expected the first argument to be an object&#039;);\n  }\n  var keys = nanomatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.matcher(pattern[, options]);\n *\n * var isMatch = nm.matcher(&#039;*.!(*a)&#039;);\n * console.log(isMatch(&#039;a.a&#039;));\n * //=&gt; false\n * console.log(isMatch(&#039;a.b&#039;));\n * //=&gt; true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nnanomatch.matcher = function matcher(pattern, options) {\n  if (utils.isEmptyString(pattern)) {\n    return function() {\n      return false;\n    };\n  }\n\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError(&#039;expected pattern to be an array, string or regex&#039;);\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options &amp;&amp; options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = nanomatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (nanomatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n\n    return function(str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  // create matcher function\n  var matcherFn = test(re);\n  // set result object from compiler on matcher function,\n  // as a non-enumerable property. useful for debugging\n  utils.define(matcherFn, &#039;result&#039;, re.result);\n  return matcherFn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or\n * `null` if the pattern did not match.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.capture(pattern, string[, options]);\n *\n * console.log(nm.capture(&#039;test/*.js&#039;, &#039;test/foo.js&#039;));\n * //=&gt; [&#039;foo&#039;]\n * console.log(nm.capture(&#039;test/*.js&#039;, &#039;foo/bar.css&#039;));\n * //=&gt; null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nnanomatch.capture = function(pattern, str, options) {\n  var re = nanomatch.makeRe(pattern, extend({capture: true}, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function(string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize(&#039;capture&#039;, pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.makeRe(pattern[, options]);\n *\n * console.log(nm.makeRe(&#039;*.js&#039;));\n * //=&gt; /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nnanomatch.makeRe = function(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected pattern to be a string&#039;);\n  }\n\n  if (pattern.length &gt; MAX_LENGTH) {\n    throw new Error(&#039;expected pattern to be less than &#039; + MAX_LENGTH + &#039; characters&#039;);\n  }\n\n  function makeRe() {\n    var opts = utils.extend({wrap: false}, options);\n    var result = nanomatch.create(pattern, opts);\n    var regex = toRegex(result.output, opts);\n    utils.define(regex, &#039;result&#039;, result);\n    return regex;\n  }\n\n  return memoize(&#039;makeRe&#039;, pattern, options, makeRe);\n};\n\n/**\n * Parses the given glob `pattern` and returns an object with the compiled `output`\n * and optional source `map`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.create(pattern[, options]);\n *\n * console.log(nm.create(&#039;abc/*.js&#039;));\n * // { options: { source: &#039;string&#039;, sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: &#039;(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js&#039;,\n * //   ast:\n * //    { type: &#039;root&#039;,\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: &#039;abc/*.js&#039; },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ &#039;string&#039; ],\n * //      names: [],\n * //      mappings: &#039;AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE&#039;,\n * //      sourcesContent: [ &#039;abc/*.js&#039; ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nnanomatch.create = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n  function create() {\n    return nanomatch.compile(nanomatch.parse(pattern, options), options);\n  }\n  return memoize(&#039;create&#039;, pattern, options, create);\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.parse(pattern[, options]);\n *\n * var ast = nm.parse(&#039;a/{b,c}/d&#039;);\n * console.log(ast);\n * // { type: &#039;root&#039;,\n * //   errors: [],\n * //   input: &#039;a/{b,c}/d&#039;,\n * //   nodes:\n * //    [ { type: &#039;bos&#039;, val: &#039;&#039; },\n * //      { type: &#039;text&#039;, val: &#039;a/&#039; },\n * //      { type: &#039;brace&#039;,\n * //        nodes:\n * //         [ { type: &#039;brace.open&#039;, val: &#039;{&#039; },\n * //           { type: &#039;text&#039;, val: &#039;b,c&#039; },\n * //           { type: &#039;brace.close&#039;, val: &#039;}&#039; } ] },\n * //      { type: &#039;text&#039;, val: &#039;/d&#039; },\n * //      { type: &#039;eos&#039;, val: &#039;&#039; } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nnanomatch.parse = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, &#039;snapdragon&#039;, snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize(&#039;parse&#039;, pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var nm = require(&#039;nanomatch&#039;);\n * nm.compile(ast[, options]);\n *\n * var ast = nm.parse(&#039;a/{b,c}/d&#039;);\n * console.log(nm.compile(ast));\n * // { options: { source: &#039;string&#039; },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      &#039;brace.open&#039;: [Function],\n * //      text: [Function],\n * //      &#039;brace.close&#039;: [Function] },\n * //   output: [ &#039;a/(b|c)/d&#039; ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nnanomatch.compile = function(ast, options) {\n  if (typeof ast === &#039;string&#039;) {\n    ast = nanomatch.parse(ast, options);\n  }\n\n  function compile() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  }\n\n  return memoize(&#039;compile&#039;, ast.input, options, compile);\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * nm.clearCache();\n * ```\n * @api public\n */\n\nnanomatch.clearCache = function() {\n  nanomatch.cache.__data__ = {};\n};\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n\n  return memoize(&#039;compose&#039;, String(patterns), options, function() {\n    return function(file) {\n      // delay composition until it&#039;s invoked the first time,\n      // after that it won&#039;t be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i &lt; patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + &#039;=&#039; + pattern, options);\n\n  if (options &amp;&amp; options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `nanomatch`\n */\n\nnanomatch.compilers = compilers;\nnanomatch.parsers = parsers;\nnanomatch.cache = cache;\n\n/**\n * Expose `nanomatch`\n * @type {Function}\n */\n\nmodule.exports = nanomatch;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/lib/cache.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/nanomatch/lib/cache.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;module.exports = new (__webpack_require__(/*! fragment-cache */ \&quot;./node_modules/fragment-cache/index.js\&quot;))();\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/lib/cache.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/lib/compilers.js&quot;:
/*!*************************************************!*\
  !*** ./node_modules/nanomatch/lib/compilers.js ***!
  \*************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n* Nanomatch compilers\n*/\n\nmodule.exports = function(nanomatch, options) {\n  function slash() {\n    if (options &amp;&amp; typeof options.slash === &#039;string&#039;) {\n      return options.slash;\n    }\n    if (options &amp;&amp; typeof options.slash === &#039;function&#039;) {\n      return options.slash.call(nanomatch);\n    }\n    return &#039;\\\\\\\\/&#039;;\n  }\n\n  function star() {\n    if (options &amp;&amp; typeof options.star === &#039;string&#039;) {\n      return options.star;\n    }\n    if (options &amp;&amp; typeof options.star === &#039;function&#039;) {\n      return options.star.call(nanomatch);\n    }\n    return &#039;[^&#039; + slash() + &#039;]*?&#039;;\n  }\n\n  var ast = nanomatch.ast = nanomatch.parser.ast;\n  ast.state = nanomatch.parser.state;\n  nanomatch.compiler.state = ast.state;\n  nanomatch.compiler\n\n    /**\n     * Negation / escaping\n     */\n\n    .set(&#039;not&#039;, function(node) {\n      var prev = this.prev();\n      if (this.options.nonegate === true || prev.type !== &#039;bos&#039;) {\n        return this.emit(&#039;\\\\&#039; + node.val, node);\n      }\n      return this.emit(node.val, node);\n    })\n    .set(&#039;escape&#039;, function(node) {\n      if (this.options.unescape &amp;&amp; /^[-\\w_.]/.test(node.val)) {\n        return this.emit(node.val, node);\n      }\n      return this.emit(&#039;\\\\&#039; + node.val, node);\n    })\n    .set(&#039;quoted&#039;, function(node) {\n      return this.emit(node.val, node);\n    })\n\n    /**\n     * Regex\n     */\n\n    .set(&#039;dollar&#039;, function(node) {\n      if (node.parent.type === &#039;bracket&#039;) {\n        return this.emit(node.val, node);\n      }\n      return this.emit(&#039;\\\\&#039; + node.val, node);\n    })\n\n    /**\n     * Dot: \&quot;.\&quot;\n     */\n\n    .set(&#039;dot&#039;, function(node) {\n      if (node.dotfiles === true) this.dotfiles = true;\n      return this.emit(&#039;\\\\&#039; + node.val, node);\n    })\n\n    /**\n     * Slashes: \&quot;/\&quot; and \&quot;\\\&quot;\n     */\n\n    .set(&#039;backslash&#039;, function(node) {\n      return this.emit(node.val, node);\n    })\n    .set(&#039;slash&#039;, function(node, nodes, i) {\n      var val = &#039;[&#039; + slash() + &#039;]&#039;;\n      var parent = node.parent;\n      var prev = this.prev();\n\n      // set \&quot;node.hasSlash\&quot; to true on all ancestor parens nodes\n      while (parent.type === &#039;paren&#039; &amp;&amp; !parent.hasSlash) {\n        parent.hasSlash = true;\n        parent = parent.parent;\n      }\n\n      if (prev.addQmark) {\n        val += &#039;?&#039;;\n      }\n\n      // word boundary\n      if (node.rest.slice(0, 2) === &#039;\\\\b&#039;) {\n        return this.emit(val, node);\n      }\n\n      // globstars\n      if (node.parsed === &#039;**&#039; || node.parsed === &#039;./**&#039;) {\n        this.output = &#039;(?:&#039; + this.output;\n        return this.emit(val + &#039;)?&#039;, node);\n      }\n\n      // negation\n      if (node.parsed === &#039;!**&#039; &amp;&amp; this.options.nonegate !== true) {\n        return this.emit(val + &#039;?\\\\b&#039;, node);\n      }\n      return this.emit(val, node);\n    })\n\n    /**\n     * Square brackets\n     */\n\n    .set(&#039;bracket&#039;, function(node) {\n      var close = node.close;\n      var open = !node.escaped ? &#039;[&#039; : &#039;\\\\[&#039;;\n      var negated = node.negated;\n      var inner = node.inner;\n      var val = node.val;\n\n      if (node.escaped === true) {\n        inner = inner.replace(/\\\\?(\\W)/g, &#039;\\\\$1&#039;);\n        negated = &#039;&#039;;\n      }\n\n      if (inner === &#039;]-&#039;) {\n        inner = &#039;\\\\]\\\\-&#039;;\n      }\n\n      if (negated &amp;&amp; inner.indexOf(&#039;.&#039;) === -1) {\n        inner += &#039;.&#039;;\n      }\n      if (negated &amp;&amp; inner.indexOf(&#039;/&#039;) === -1) {\n        inner += &#039;/&#039;;\n      }\n\n      val = open + negated + inner + close;\n      return this.emit(val, node);\n    })\n\n    /**\n     * Square: \&quot;[.]\&quot; (only matches a single character in brackets)\n     */\n\n    .set(&#039;square&#039;, function(node) {\n      var val = (/^\\W/.test(node.val) ? &#039;\\\\&#039; : &#039;&#039;) + node.val;\n      return this.emit(val, node);\n    })\n\n    /**\n     * Question mark: \&quot;?\&quot;\n     */\n\n    .set(&#039;qmark&#039;, function(node) {\n      var prev = this.prev();\n      // don&#039;t use \&quot;slash\&quot; variable so that we always avoid\n      // matching backslashes and slashes with a qmark\n      var val = &#039;[^.\\\\\\\\/]&#039;;\n      if (this.options.dot || (prev.type !== &#039;bos&#039; &amp;&amp; prev.type !== &#039;slash&#039;)) {\n        val = &#039;[^\\\\\\\\/]&#039;;\n      }\n\n      if (node.parsed.slice(-1) === &#039;(&#039;) {\n        var ch = node.rest.charAt(0);\n        if (ch === &#039;!&#039; || ch === &#039;=&#039; || ch === &#039;:&#039;) {\n          return this.emit(node.val, node);\n        }\n      }\n\n      if (node.val.length &gt; 1) {\n        val += &#039;{&#039; + node.val.length + &#039;}&#039;;\n      }\n      return this.emit(val, node);\n    })\n\n    /**\n     * Plus\n     */\n\n    .set(&#039;plus&#039;, function(node) {\n      var prev = node.parsed.slice(-1);\n      if (prev === &#039;]&#039; || prev === &#039;)&#039;) {\n        return this.emit(node.val, node);\n      }\n      if (!this.output || (/[?*+]/.test(ch) &amp;&amp; node.parent.type !== &#039;bracket&#039;)) {\n        return this.emit(&#039;\\\\+&#039;, node);\n      }\n      var ch = this.output.slice(-1);\n      if (/\\w/.test(ch) &amp;&amp; !node.inside) {\n        return this.emit(&#039;+\\\\+?&#039;, node);\n      }\n      return this.emit(&#039;+&#039;, node);\n    })\n\n    /**\n     * globstar: &#039;**&#039;\n     */\n\n    .set(&#039;globstar&#039;, function(node, nodes, i) {\n      if (!this.output) {\n        this.state.leadingGlobstar = true;\n      }\n\n      var prev = this.prev();\n      var before = this.prev(2);\n      var next = this.next();\n      var after = this.next(2);\n      var type = prev.type;\n      var val = node.val;\n\n      if (prev.type === &#039;slash&#039; &amp;&amp; next.type === &#039;slash&#039;) {\n        if (before.type === &#039;text&#039;) {\n          this.output += &#039;?&#039;;\n\n          if (after.type !== &#039;text&#039;) {\n            this.output += &#039;\\\\b&#039;;\n          }\n        }\n      }\n\n      var parsed = node.parsed;\n      if (parsed.charAt(0) === &#039;!&#039;) {\n        parsed = parsed.slice(1);\n      }\n\n      var isInside = node.isInside.paren || node.isInside.brace;\n      if (parsed &amp;&amp; type !== &#039;slash&#039; &amp;&amp; type !== &#039;bos&#039; &amp;&amp; !isInside) {\n        val = star();\n      } else {\n        val = this.options.dot !== true\n          ? &#039;(?:(?!(?:[&#039; + slash() + &#039;]|^)\\\\.).)*?&#039;\n          : &#039;(?:(?!(?:[&#039; + slash() + &#039;]|^)(?:\\\\.{1,2})($|[&#039; + slash() + &#039;]))(?!\\\\.{2}).)*?&#039;;\n      }\n\n      if ((type === &#039;slash&#039; || type === &#039;bos&#039;) &amp;&amp; this.options.dot !== true) {\n        val = &#039;(?!\\\\.)&#039; + val;\n      }\n\n      if (prev.type === &#039;slash&#039; &amp;&amp; next.type === &#039;slash&#039; &amp;&amp; before.type !== &#039;text&#039;) {\n        if (after.type === &#039;text&#039; || after.type === &#039;star&#039;) {\n          node.addQmark = true;\n        }\n      }\n\n      if (this.options.capture) {\n        val = &#039;(&#039; + val + &#039;)&#039;;\n      }\n\n      return this.emit(val, node);\n    })\n\n    /**\n     * Star: \&quot;*\&quot;\n     */\n\n    .set(&#039;star&#039;, function(node, nodes, i) {\n      var prior = nodes[i - 2] || {};\n      var prev = this.prev();\n      var next = this.next();\n      var type = prev.type;\n\n      function isStart(n) {\n        return n.type === &#039;bos&#039; || n.type === &#039;slash&#039;;\n      }\n\n      if (this.output === &#039;&#039; &amp;&amp; this.options.contains !== true) {\n        this.output = &#039;(?![&#039; + slash() + &#039;])&#039;;\n      }\n\n      if (type === &#039;bracket&#039; &amp;&amp; this.options.bash === false) {\n        var str = next &amp;&amp; next.type === &#039;bracket&#039; ? star() : &#039;*?&#039;;\n        if (!prev.nodes || prev.nodes[1].type !== &#039;posix&#039;) {\n          return this.emit(str, node);\n        }\n      }\n\n      var prefix = !this.dotfiles &amp;&amp; type !== &#039;text&#039; &amp;&amp; type !== &#039;escape&#039;\n        ? (this.options.dot ? &#039;(?!(?:^|[&#039; + slash() + &#039;])\\\\.{1,2}(?:$|[&#039; + slash() + &#039;]))&#039; : &#039;(?!\\\\.)&#039;)\n        : &#039;&#039;;\n\n      if (isStart(prev) || (isStart(prior) &amp;&amp; type === &#039;not&#039;)) {\n        if (prefix !== &#039;(?!\\\\.)&#039;) {\n          prefix += &#039;(?!(\\\\.{2}|\\\\.[&#039; + slash() + &#039;]))(?=.)&#039;;\n        } else {\n          prefix += &#039;(?=.)&#039;;\n        }\n      } else if (prefix === &#039;(?!\\\\.)&#039;) {\n        prefix = &#039;&#039;;\n      }\n\n      if (prev.type === &#039;not&#039; &amp;&amp; prior.type === &#039;bos&#039; &amp;&amp; this.options.dot === true) {\n        this.output = &#039;(?!\\\\.)&#039; + this.output;\n      }\n\n      var output = prefix + star();\n      if (this.options.capture) {\n        output = &#039;(&#039; + output + &#039;)&#039;;\n      }\n\n      return this.emit(output, node);\n    })\n\n    /**\n     * Text\n     */\n\n    .set(&#039;text&#039;, function(node) {\n      return this.emit(node.val, node);\n    })\n\n    /**\n     * End-of-string\n     */\n\n    .set(&#039;eos&#039;, function(node) {\n      var prev = this.prev();\n      var val = node.val;\n\n      this.output = &#039;(?:\\\\.[&#039; + slash() + &#039;](?=.))?&#039; + this.output;\n      if (this.state.metachar &amp;&amp; prev.type !== &#039;qmark&#039; &amp;&amp; prev.type !== &#039;slash&#039;) {\n        val += (this.options.contains ? &#039;[&#039; + slash() + &#039;]?&#039; : &#039;(?:[&#039; + slash() + &#039;]|$)&#039;);\n      }\n\n      return this.emit(val, node);\n    });\n\n  /**\n   * Allow custom compilers to be passed on options\n   */\n\n  if (options &amp;&amp; typeof options.compilers === &#039;function&#039;) {\n    options.compilers(nanomatch.compiler);\n  }\n};\n\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/lib/compilers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/lib/parsers.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/nanomatch/lib/parsers.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar regexNot = __webpack_require__(/*! regex-not */ \&quot;./node_modules/regex-not/index.js\&quot;);\nvar toRegex = __webpack_require__(/*! to-regex */ \&quot;./node_modules/to-regex/index.js\&quot;);\n\n/**\n * Characters to use in negation regex (we want to \&quot;not\&quot; match\n * characters that are matched by other parsers)\n */\n\nvar cached;\nvar NOT_REGEX = &#039;[\\\\[!*+?$^\&quot;\\&#039;.\\\\\\\\/]+&#039;;\nvar not = createTextRegex(NOT_REGEX);\n\n/**\n * Nanomatch parsers\n */\n\nmodule.exports = function(nanomatch, options) {\n  var parser = nanomatch.parser;\n  var opts = parser.options;\n\n  parser.state = {\n    slashes: 0,\n    paths: []\n  };\n\n  parser.ast.state = parser.state;\n  parser\n\n    /**\n     * Beginning-of-string\n     */\n\n    .capture(&#039;prefix&#039;, function() {\n      if (this.parsed) return;\n      var m = this.match(/^\\.[\\\\/]/);\n      if (!m) return;\n      this.state.strictOpen = !!this.options.strictOpen;\n      this.state.addPrefix = true;\n    })\n\n    /**\n     * Escape: \&quot;\\\\.\&quot;\n     */\n\n    .capture(&#039;escape&#039;, function() {\n      if (this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(/^(?:\\\\(.)|([$^]))/);\n      if (!m) return;\n\n      return pos({\n        type: &#039;escape&#039;,\n        val: m[2] || m[1]\n      });\n    })\n\n    /**\n     * Quoted strings\n     */\n\n    .capture(&#039;quoted&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^[\&quot;&#039;]/);\n      if (!m) return;\n\n      var quote = m[0];\n      if (this.input.indexOf(quote) === -1) {\n        return pos({\n          type: &#039;escape&#039;,\n          val: quote\n        });\n      }\n\n      var tok = advanceTo(this.input, quote);\n      this.consume(tok.len);\n\n      return pos({\n        type: &#039;quoted&#039;,\n        val: tok.esc\n      });\n    })\n\n    /**\n     * Negations: \&quot;!\&quot;\n     */\n\n    .capture(&#039;not&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(this.notRegex || /^!+/);\n      if (!m) return;\n      var val = m[0];\n\n      var isNegated = (val.length % 2) === 1;\n      if (parsed === &#039;&#039; &amp;&amp; !isNegated) {\n        val = &#039;&#039;;\n      }\n\n      // if nothing has been parsed, we know `!` is at the start,\n      // so we need to wrap the result in a negation regex\n      if (parsed === &#039;&#039; &amp;&amp; isNegated &amp;&amp; this.options.nonegate !== true) {\n        this.bos.val = &#039;(?!^(?:&#039;;\n        this.append = &#039;)$).*&#039;;\n        val = &#039;&#039;;\n      }\n      return pos({\n        type: &#039;not&#039;,\n        val: val\n      });\n    })\n\n    /**\n     * Dot: \&quot;.\&quot;\n     */\n\n    .capture(&#039;dot&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\.+/);\n      if (!m) return;\n\n      var val = m[0];\n      this.state.dot = val === &#039;.&#039; &amp;&amp; (parsed === &#039;&#039; || parsed.slice(-1) === &#039;/&#039;);\n\n      return pos({\n        type: &#039;dot&#039;,\n        dotfiles: this.state.dot,\n        val: val\n      });\n    })\n\n    /**\n     * Plus: \&quot;+\&quot;\n     */\n\n    .capture(&#039;plus&#039;, /^\\+(?!\\()/)\n\n    /**\n     * Question mark: \&quot;?\&quot;\n     */\n\n    .capture(&#039;qmark&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\?+(?!\\()/);\n      if (!m) return;\n\n      this.state.metachar = true;\n      this.state.qmark = true;\n\n      return pos({\n        type: &#039;qmark&#039;,\n        parsed: parsed,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Globstar: \&quot;**\&quot;\n     */\n\n    .capture(&#039;globstar&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\*{2}(?![*(])(?=[,)/]|$)/);\n      if (!m) return;\n\n      var type = opts.noglobstar !== true ? &#039;globstar&#039; : &#039;star&#039;;\n      var node = pos({type: type, parsed: parsed});\n      this.state.metachar = true;\n\n      while (this.input.slice(0, 4) === &#039;/**/&#039;) {\n        this.input = this.input.slice(3);\n      }\n\n      node.isInside = {\n        brace: this.isInside(&#039;brace&#039;),\n        paren: this.isInside(&#039;paren&#039;)\n      };\n\n      if (type === &#039;globstar&#039;) {\n        this.state.globstar = true;\n        node.val = &#039;**&#039;;\n\n      } else {\n        this.state.star = true;\n        node.val = &#039;*&#039;;\n      }\n\n      return node;\n    })\n\n    /**\n     * Star: \&quot;*\&quot;\n     */\n\n    .capture(&#039;star&#039;, function() {\n      var pos = this.position();\n      var starRe = /^(?:\\*(?![*(])|[*]{3,}(?!\\()|[*]{2}(?![(/]|$)|\\*(?=\\*\\())/;\n      var m = this.match(starRe);\n      if (!m) return;\n\n      this.state.metachar = true;\n      this.state.star = true;\n      return pos({\n        type: &#039;star&#039;,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Slash: \&quot;/\&quot;\n     */\n\n    .capture(&#039;slash&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^\\//);\n      if (!m) return;\n\n      this.state.slashes++;\n      return pos({\n        type: &#039;slash&#039;,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Backslash: \&quot;\\\\\&quot;\n     */\n\n    .capture(&#039;backslash&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^\\\\(?![*+?(){}[\\]&#039;\&quot;])/);\n      if (!m) return;\n\n      var val = m[0];\n\n      if (this.isInside(&#039;bracket&#039;)) {\n        val = &#039;\\\\&#039;;\n      } else if (val.length &gt; 1) {\n        val = &#039;\\\\\\\\&#039;;\n      }\n\n      return pos({\n        type: &#039;backslash&#039;,\n        val: val\n      });\n    })\n\n    /**\n     * Square: \&quot;[.]\&quot;\n     */\n\n    .capture(&#039;square&#039;, function() {\n      if (this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(/^\\[([^!^\\\\])\\]/);\n      if (!m) return;\n\n      return pos({\n        type: &#039;square&#039;,\n        val: m[1]\n      });\n    })\n\n    /**\n     * Brackets: \&quot;[...]\&quot; (basic, this can be overridden by other parsers)\n     */\n\n    .capture(&#039;bracket&#039;, function() {\n      var pos = this.position();\n      var m = this.match(/^(?:\\[([!^]?)([^\\]]+|\\]-)(\\]|[^*+?]+)|\\[)/);\n      if (!m) return;\n\n      var val = m[0];\n      var negated = m[1] ? &#039;^&#039; : &#039;&#039;;\n      var inner = (m[2] || &#039;&#039;).replace(/\\\\\\\\+/, &#039;\\\\\\\\&#039;);\n      var close = m[3] || &#039;&#039;;\n\n      if (m[2] &amp;&amp; inner.length &lt; m[2].length) {\n        val = val.replace(/\\\\\\\\+/, &#039;\\\\\\\\&#039;);\n      }\n\n      var esc = this.input.slice(0, 2);\n      if (inner === &#039;&#039; &amp;&amp; esc === &#039;\\\\]&#039;) {\n        inner += esc;\n        this.consume(2);\n\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          if (ch === &#039;]&#039;) {\n            close = ch;\n            break;\n          }\n          inner += ch;\n        }\n      }\n\n      return pos({\n        type: &#039;bracket&#039;,\n        val: val,\n        escaped: close !== &#039;]&#039;,\n        negated: negated,\n        inner: inner,\n        close: close\n      });\n    })\n\n    /**\n     * Text\n     */\n\n    .capture(&#039;text&#039;, function() {\n      if (this.isInside(&#039;bracket&#039;)) return;\n      var pos = this.position();\n      var m = this.match(not);\n      if (!m || !m[0]) return;\n\n      return pos({\n        type: &#039;text&#039;,\n        val: m[0]\n      });\n    });\n\n  /**\n   * Allow custom parsers to be passed on options\n   */\n\n  if (options &amp;&amp; typeof options.parsers === &#039;function&#039;) {\n    options.parsers(nanomatch.parser);\n  }\n};\n\n/**\n * Advance to the next non-escaped character\n */\n\nfunction advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = { len: 1, val: &#039;&#039;, esc: &#039;&#039; };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== &#039;\\\\&#039;) {\n      tok.esc += &#039;\\\\&#039; + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === &#039;\\\\&#039;) {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch &amp;&amp; ch !== endChar) {\n    advance();\n  }\n  return tok;\n}\n\n/**\n * Create text regex\n */\n\nfunction createTextRegex(pattern) {\n  if (cached) return cached;\n  var opts = {contains: true, strictClose: false};\n  var not = regexNot.create(pattern, opts);\n  var re = toRegex(&#039;^(?:[*]\\\\((?=.)|&#039; + not + &#039;)&#039;, opts);\n  return (cached = re);\n}\n\n/**\n * Expose negation string\n */\n\nmodule.exports.not = NOT_REGEX;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/lib/parsers.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/lib/utils.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/nanomatch/lib/utils.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar utils = module.exports;\nvar path = __webpack_require__(/*! path */ \&quot;path\&quot;);\n\n/**\n * Module dependencies\n */\n\nvar isWindows = __webpack_require__(/*! is-windows */ \&quot;./node_modules/is-windows/index.js\&quot;)();\nvar Snapdragon = __webpack_require__(/*! snapdragon */ \&quot;./node_modules/snapdragon/index.js\&quot;);\nutils.define = __webpack_require__(/*! define-property */ \&quot;./node_modules/nanomatch/node_modules/define-property/index.js\&quot;);\nutils.diff = __webpack_require__(/*! arr-diff */ \&quot;./node_modules/arr-diff/index.js\&quot;);\nutils.extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/nanomatch/node_modules/extend-shallow/index.js\&quot;);\nutils.pick = __webpack_require__(/*! object.pick */ \&quot;./node_modules/object.pick/index.js\&quot;);\nutils.typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/kind-of/index.js\&quot;);\nutils.unique = __webpack_require__(/*! array-unique */ \&quot;./node_modules/array-unique/index.js\&quot;);\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nutils.isEmptyString = function(val) {\n  return String(val) === &#039;&#039; || String(val) === &#039;./&#039;;\n};\n\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function() {\n  return path.sep === &#039;\\\\&#039; || isWindows === true;\n};\n\n/**\n * Return the last element from an array\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Get the `Snapdragon` instance to use\n */\n\nutils.instantiate = function(ast, options) {\n  var snapdragon;\n  // if an instance was created by `.parse`, use that instance\n  if (utils.typeOf(ast) === &#039;object&#039; &amp;&amp; ast.snapdragon) {\n    snapdragon = ast.snapdragon;\n  // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === &#039;object&#039; &amp;&amp; options.snapdragon) {\n    snapdragon = options.snapdragon;\n  // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, &#039;parse&#039;, function(str, options) {\n    var parsed = Snapdragon.prototype.parse.call(this, str, options);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last &amp;&amp; this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n      if (last.type === &#039;bracket&#039;) {\n        if (inner.val.charAt(0) === &#039;[&#039;) {\n          inner.val = &#039;\\\\&#039; + inner.val;\n        }\n\n      } else {\n        open.val = &#039;\\\\&#039; + open.val;\n        var sibling = open.parent.nodes[1];\n        if (sibling.type === &#039;star&#039;) {\n          sibling.loose = true;\n        }\n      }\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, &#039;parser&#039;, this.parser);\n    return parsed;\n  });\n\n  return snapdragon;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  if (typeof options === &#039;undefined&#039;) {\n    return pattern;\n  }\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += &#039;;&#039; + prop + &#039;=&#039; + String(options[prop]);\n    }\n  }\n  return key;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === &#039;string&#039;) return [val];\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isString = function(val) {\n  return typeof val === &#039;string&#039;;\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isRegex = function(val) {\n  return utils.typeOf(val) === &#039;regexp&#039;;\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isObject = function(val) {\n  return utils.typeOf(val) === &#039;object&#039;;\n};\n\n/**\n * Escape regex characters in the given string\n */\n\nutils.escapeRegex = function(str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\/\\s]/g, &#039;\\\\$&amp;&#039;);\n};\n\n/**\n * Combines duplicate characters in the provided `input` string.\n * @param {String} `input`\n * @returns {String}\n */\n\nutils.combineDupes = function(input, patterns) {\n  patterns = utils.arrayify(patterns).join(&#039;|&#039;).split(&#039;|&#039;);\n  patterns = patterns.map(function(s) {\n    return s.replace(/\\\\?([+*\\\\/])/g, &#039;\\\\$1&#039;);\n  });\n  var substr = patterns.join(&#039;|&#039;);\n  var regex = new RegExp(&#039;(&#039; + substr + &#039;)(?=\\\\1)&#039;, &#039;g&#039;);\n  return input.replace(regex, &#039;&#039;);\n};\n\n/**\n * Returns true if the given `str` has special characters\n */\n\nutils.hasSpecialChars = function(str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|[\\]{}]|[+@]\\()/.test(str);\n};\n\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\nutils.toPosixPath = function(str) {\n  return str.replace(/\\\\+/g, &#039;/&#039;);\n};\n\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\nutils.unescape = function(str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, &#039;&#039;));\n};\n\n/**\n * Strip the drive letter from a windows filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripDrive = function(fp) {\n  return utils.isWindows() ? fp.replace(/^[a-z]:[\\\\/]+?/i, &#039;/&#039;) : fp;\n};\n\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripPrefix = function(str) {\n  if (str.charAt(0) === &#039;.&#039; &amp;&amp; (str.charAt(1) === &#039;/&#039; || str.charAt(1) === &#039;\\\\&#039;)) {\n    return str.slice(2);\n  }\n  return str;\n};\n\n/**\n * Returns true if `str` is a common character that doesn&#039;t need\n * to be processed to be used for matching.\n * @param {String} `str`\n * @return {Boolean}\n */\n\nutils.isSimpleChar = function(str) {\n  return str.trim() === &#039;&#039; || str === &#039;.&#039;;\n};\n\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\nutils.isSlash = function(str) {\n  return str === &#039;/&#039; || str === &#039;\\\\/&#039; || str === &#039;\\\\&#039; || str === &#039;\\\\\\\\&#039;;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function(pattern, options) {\n  return (options &amp;&amp; options.contains)\n    ? utils.containsPattern(pattern, options)\n    : utils.equalsPattern(pattern, options);\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\nutils._equals = function(filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\nutils._contains = function(filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.equalsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.containsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function(filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\nutils.matchBasename = function(re) {\n  return function(filepath) {\n    return re.test(filepath) || re.test(path.basename(filepath));\n  };\n};\n\n/**\n * Returns the given value unchanced.\n * @return {any}\n */\n\nutils.identity = function(val) {\n  return val;\n};\n\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\nutils.value = function(str, unixify, options) {\n  if (options &amp;&amp; options.unixify === false) {\n    return str;\n  }\n  if (options &amp;&amp; typeof options.unixify === &#039;function&#039;) {\n    return options.unixify(str);\n  }\n  return unixify(str);\n};\n\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\nutils.unixify = function(options) {\n  var opts = options || {};\n  return function(filepath) {\n    if (opts.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n    if (opts.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n    if (opts.unixify === true || utils.isWindows()) {\n      filepath = utils.toPosixPath(filepath);\n    }\n    return filepath;\n  };\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/lib/utils.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/node_modules/define-property/index.js&quot;:
/*!**********************************************************************!*\
  !*** ./node_modules/nanomatch/node_modules/define-property/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isobject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/is-descriptor/index.js\&quot;);\nvar define = (typeof Reflect !== &#039;undefined&#039; &amp;&amp; Reflect.defineProperty)\n  ? Reflect.defineProperty\n  : Object.defineProperty;\n\nmodule.exports = function defineProperty(obj, key, val) {\n  if (!isobject(obj) &amp;&amp; typeof obj !== &#039;function&#039; &amp;&amp; !Array.isArray(obj)) {\n    throw new TypeError(&#039;expected an object, function, or array&#039;);\n  }\n\n  if (typeof key !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected \&quot;key\&quot; to be a string&#039;);\n  }\n\n  if (isDescriptor(val)) {\n    define(obj, key, val);\n    return obj;\n  }\n\n  define(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/node_modules/extend-shallow/index.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/nanomatch/node_modules/extend-shallow/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isExtendable = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/nanomatch/node_modules/is-extendable/index.js\&quot;);\nvar assignSymbols = __webpack_require__(/*! assign-symbols */ \&quot;./node_modules/assign-symbols/index.js\&quot;);\n\nmodule.exports = Object.assign || function(obj/*, objects*/) {\n  if (obj === null || typeof obj === &#039;undefined&#039;) {\n    throw new TypeError(&#039;Cannot convert undefined or null to object&#039;);\n  }\n  if (!isObject(obj)) {\n    obj = {};\n  }\n  for (var i = 1; i &lt; arguments.length; i++) {\n    var val = arguments[i];\n    if (isString(val)) {\n      val = toObject(val);\n    }\n    if (isObject(val)) {\n      assign(obj, val);\n      assignSymbols(obj, val);\n    }\n  }\n  return obj;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction isString(val) {\n  return (val &amp;&amp; typeof val === &#039;string&#039;);\n}\n\nfunction toObject(str) {\n  var obj = {};\n  for (var i in str) {\n    obj[i] = str[i];\n  }\n  return obj;\n}\n\nfunction isObject(val) {\n  return (val &amp;&amp; typeof val === &#039;object&#039;) || isExtendable(val);\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isEnum(obj, key) {\n  return Object.prototype.propertyIsEnumerable.call(obj, key);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/node_modules/extend-shallow/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/nanomatch/node_modules/is-extendable/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/nanomatch/node_modules/is-extendable/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\n\nmodule.exports = function isExtendable(val) {\n  return isPlainObject(val) || typeof val === &#039;function&#039; || Array.isArray(val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/nanomatch/node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/normalize-path/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/normalize-path/index.js ***!
  \**********************************************/
/***/ ((module) =&gt; {

eval(&quot;/*!\n * normalize-path &lt;https://github.com/jonschlinkert/normalize-path&gt;\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected path to be a string&#039;);\n  }\n\n  if (path === &#039;\\\\&#039; || path === &#039;/&#039;) return &#039;/&#039;;\n\n  var len = path.length;\n  if (len &lt;= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = &#039;&#039;;\n  if (len &gt; 4 &amp;&amp; path[3] === &#039;\\\\&#039;) {\n    var ch = path[2];\n    if ((ch === &#039;?&#039; || ch === &#039;.&#039;) &amp;&amp; path.slice(0, 2) === &#039;\\\\\\\\&#039;) {\n      path = path.slice(2);\n      prefix = &#039;//&#039;;\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false &amp;&amp; segs[segs.length - 1] === &#039;&#039;) {\n    segs.pop();\n  }\n  return prefix + segs.join(&#039;/&#039;);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/normalize-path/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/object-copy/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/object-copy/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/object-copy/node_modules/kind-of/index.js\&quot;);\nvar copyDescriptor = __webpack_require__(/*! copy-descriptor */ \&quot;./node_modules/copy-descriptor/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\n\n/**\n * Copy static properties, prototype properties, and descriptors from one object to another.\n *\n * ```js\n * function App() {}\n * var proto = App.prototype;\n * App.prototype.set = function() {};\n * App.prototype.get = function() {};\n *\n * var obj = {};\n * copy(obj, proto);\n * ```\n * @param {Object} `receiver`\n * @param {Object} `provider`\n * @param {String|Array} `omit` One or more properties to omit\n * @return {Object}\n * @api public\n */\n\nfunction copy(receiver, provider, omit) {\n  if (!isObject(receiver)) {\n    throw new TypeError(&#039;expected receiving object to be an object.&#039;);\n  }\n  if (!isObject(provider)) {\n    throw new TypeError(&#039;expected providing object to be an object.&#039;);\n  }\n\n  var props = nativeKeys(provider);\n  var keys = Object.keys(provider);\n  var len = props.length;\n  omit = arrayify(omit);\n\n  while (len--) {\n    var key = props[len];\n\n    if (has(keys, key)) {\n      define(receiver, key, provider[key]);\n    } else if (!(key in receiver) &amp;&amp; !has(omit, key)) {\n      copyDescriptor(receiver, provider, key);\n    }\n  }\n};\n\n/**\n * Return true if the given value is an object or function\n */\n\nfunction isObject(val) {\n  return typeOf(val) === &#039;object&#039; || typeof val === &#039;function&#039;;\n}\n\n/**\n * Returns true if an array has any of the given elements, or an\n * object has any of the give keys.\n *\n * ```js\n * has([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], &#039;c&#039;);\n * //=&gt; true\n *\n * has([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], [&#039;c&#039;, &#039;z&#039;]);\n * //=&gt; true\n *\n * has({a: &#039;b&#039;, c: &#039;d&#039;}, [&#039;c&#039;, &#039;z&#039;]);\n * //=&gt; true\n * ```\n * @param {Object} `obj`\n * @param {String|Array} `val`\n * @return {Boolean}\n */\n\nfunction has(obj, val) {\n  val = arrayify(val);\n  var len = val.length;\n\n  if (isObject(obj)) {\n    for (var key in obj) {\n      if (val.indexOf(key) &gt; -1) {\n        return true;\n      }\n    }\n\n    var keys = nativeKeys(obj);\n    return has(keys, val);\n  }\n\n  if (Array.isArray(obj)) {\n    var arr = obj;\n    while (len--) {\n      if (arr.indexOf(val[len]) &gt; -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  throw new TypeError(&#039;expected an array or object.&#039;);\n}\n\n/**\n * Cast the given value to an array.\n *\n * ```js\n * arrayify(&#039;foo&#039;);\n * //=&gt; [&#039;foo&#039;]\n *\n * arrayify([&#039;foo&#039;]);\n * //=&gt; [&#039;foo&#039;]\n * ```\n *\n * @param {String|Array} `val`\n * @return {Array}\n */\n\nfunction arrayify(val) {\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n}\n\n/**\n * Returns true if a value has a `contructor`\n *\n * ```js\n * hasConstructor({});\n * //=&gt; true\n *\n * hasConstructor(Object.create(null));\n * //=&gt; false\n * ```\n * @param  {Object} `value`\n * @return {Boolean}\n */\n\nfunction hasConstructor(val) {\n  return isObject(val) &amp;&amp; typeof val.constructor !== &#039;undefined&#039;;\n}\n\n/**\n * Get the native `ownPropertyNames` from the constructor of the\n * given `object`. An empty array is returned if the object does\n * not have a constructor.\n *\n * ```js\n * nativeKeys({a: &#039;b&#039;, b: &#039;c&#039;, c: &#039;d&#039;})\n * //=&gt; [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]\n *\n * nativeKeys(function(){})\n * //=&gt; [&#039;length&#039;, &#039;caller&#039;]\n * ```\n *\n * @param  {Object} `obj` Object that has a `constructor`.\n * @return {Array} Array of keys.\n */\n\nfunction nativeKeys(val) {\n  if (!hasConstructor(val)) return [];\n  return Object.getOwnPropertyNames(val);\n}\n\n/**\n * Expose `copy`\n */\n\nmodule.exports = copy;\n\n/**\n * Expose `copy.has` for tests\n */\n\nmodule.exports.has = has;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/object-copy/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/object-copy/node_modules/kind-of/index.js&quot;:
/*!****************************************************************!*\
  !*** ./node_modules/object-copy/node_modules/kind-of/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/object-copy/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/object-visit/index.js&quot;:
/*!********************************************!*\
  !*** ./node_modules/object-visit/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * object-visit &lt;https://github.com/jonschlinkert/object-visit&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\n\nmodule.exports = function visit(thisArg, method, target, val) {\n  if (!isObject(thisArg) &amp;&amp; typeof thisArg !== &#039;function&#039;) {\n    throw new Error(&#039;object-visit expects `thisArg` to be an object.&#039;);\n  }\n\n  if (typeof method !== &#039;string&#039;) {\n    throw new Error(&#039;object-visit expects `method` name to be a string&#039;);\n  }\n\n  if (typeof thisArg[method] !== &#039;function&#039;) {\n    return thisArg;\n  }\n\n  var args = [].slice.call(arguments, 3);\n  target = target || {};\n\n  for (var key in target) {\n    var arr = [key, target[key]].concat(args);\n    thisArg[method].apply(thisArg, arr);\n  }\n  return thisArg;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/object-visit/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/object.pick/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/object.pick/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * object.pick &lt;https://github.com/jonschlinkert/object.pick&gt;\n *\n * Copyright (c) 2014-2015 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\n\nmodule.exports = function pick(obj, keys) {\n  if (!isObject(obj) &amp;&amp; typeof obj !== &#039;function&#039;) {\n    return {};\n  }\n\n  var res = {};\n  if (typeof keys === &#039;string&#039;) {\n    if (keys in obj) {\n      res[keys] = obj[keys];\n    }\n    return res;\n  }\n\n  var len = keys.length;\n  var idx = -1;\n\n  while (++idx &lt; len) {\n    var key = keys[idx];\n    if (key in obj) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/object.pick/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/pascalcase/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/pascalcase/index.js ***!
  \******************************************/
/***/ ((module) =&gt; {

eval(&quot;/*!\n * pascalcase &lt;https://github.com/jonschlinkert/pascalcase&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nfunction pascalcase(str) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string.&#039;);\n  }\n  str = str.replace(/([A-Z])/g, &#039; $1&#039;);\n  if (str.length === 1) { return str.toUpperCase(); }\n  str = str.replace(/^[\\W_]+|[\\W_]+$/g, &#039;&#039;).toLowerCase();\n  str = str.charAt(0).toUpperCase() + str.slice(1);\n  return str.replace(/[\\W_]+(\\w|$)/g, function (_, ch) {\n    return ch.toUpperCase();\n  });\n}\n\nmodule.exports = pascalcase;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/pascalcase/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/path-is-absolute/index.js&quot;:
/*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nfunction posix(path) {\n\treturn path.charAt(0) === &#039;/&#039;;\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || &#039;&#039;;\n\tvar isUnc = Boolean(device &amp;&amp; device.charAt(1) !== &#039;:&#039;);\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === &#039;win32&#039; ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/path-is-absolute/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/posix-character-classes/index.js&quot;:
/*!*******************************************************!*\
  !*** ./node_modules/posix-character-classes/index.js ***!
  \*******************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * POSIX character classes\n */\n\nmodule.exports = {\n  alnum: &#039;a-zA-Z0-9&#039;,\n  alpha: &#039;a-zA-Z&#039;,\n  ascii: &#039;\\\\x00-\\\\x7F&#039;,\n  blank: &#039; \\\\t&#039;,\n  cntrl: &#039;\\\\x00-\\\\x1F\\\\x7F&#039;,\n  digit: &#039;0-9&#039;,\n  graph: &#039;\\\\x21-\\\\x7E&#039;,\n  lower: &#039;a-z&#039;,\n  print: &#039;\\\\x20-\\\\x7E &#039;,\n  punct: &#039;\\\\-!\&quot;#$%&amp;\\&#039;()\\\\*+,./:;&lt;=&gt;?@[\\\\]^_`{|}~&#039;,\n  space: &#039; \\\\t\\\\r\\\\n\\\\v\\\\f&#039;,\n  upper: &#039;A-Z&#039;,\n  word: &#039;A-Za-z0-9_&#039;,\n  xdigit: &#039;A-Fa-f0-9&#039;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/posix-character-classes/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/process-nextick-args/index.js&quot;:
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nif (typeof process === &#039;undefined&#039; ||\n    !process.version ||\n    process.version.indexOf(&#039;v0.&#039;) === 0 ||\n    process.version.indexOf(&#039;v1.&#039;) === 0 &amp;&amp; process.version.indexOf(&#039;v1.8.&#039;) !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== &#039;function&#039;) {\n    throw new TypeError(&#039;\&quot;callback\&quot; argument must be a function&#039;);\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i &lt; args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/process-nextick-args/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/_stream_duplex.js&quot;:
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn&#039;t have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*&lt;replacement&gt;*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \&quot;./node_modules/process-nextick-args/index.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*&lt;/replacement&gt;*/\n\nmodule.exports = Duplex;\n\n/*&lt;replacement&gt;*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \&quot;./node_modules/core-util-is/lib/util.js\&quot;));\nutil.inherits = __webpack_require__(/*! inherits */ \&quot;./node_modules/inherits/inherits.js\&quot;);\n/*&lt;/replacement&gt;*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \&quot;./node_modules/readable-stream/lib/_stream_readable.js\&quot;);\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \&quot;./node_modules/readable-stream/lib/_stream_writable.js\&quot;);\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v &lt; keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options &amp;&amp; options.readable === false) this.readable = false;\n\n  if (options &amp;&amp; options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options &amp;&amp; options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once(&#039;end&#039;, onend);\n}\n\nObject.defineProperty(Duplex.prototype, &#039;writableHighWaterMark&#039;, {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we&#039;re ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, &#039;destroyed&#039;, {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed &amp;&amp; this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/_stream_duplex.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/_stream_passthrough.js&quot;:
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \&quot;./node_modules/readable-stream/lib/_stream_transform.js\&quot;);\n\n/*&lt;replacement&gt;*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \&quot;./node_modules/core-util-is/lib/util.js\&quot;));\nutil.inherits = __webpack_require__(/*! inherits */ \&quot;./node_modules/inherits/inherits.js\&quot;);\n/*&lt;/replacement&gt;*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/_stream_passthrough.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/_stream_readable.js&quot;:
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*&lt;replacement&gt;*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \&quot;./node_modules/process-nextick-args/index.js\&quot;);\n/*&lt;/replacement&gt;*/\n\nmodule.exports = Readable;\n\n/*&lt;replacement&gt;*/\nvar isArray = __webpack_require__(/*! isarray */ \&quot;./node_modules/isarray/index.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar Duplex;\n/*&lt;/replacement&gt;*/\n\nReadable.ReadableState = ReadableState;\n\n/*&lt;replacement&gt;*/\nvar EE = __webpack_require__(/*! events */ \&quot;events\&quot;).EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \&quot;./node_modules/readable-stream/lib/internal/streams/stream.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \&quot;./node_modules/safe-buffer/index.js\&quot;).Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \&quot;./node_modules/core-util-is/lib/util.js\&quot;));\nutil.inherits = __webpack_require__(/*! inherits */ \&quot;./node_modules/inherits/inherits.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar debugUtil = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar debug = void 0;\nif (debugUtil &amp;&amp; debugUtil.debuglog) {\n  debug = debugUtil.debuglog(&#039;stream&#039;);\n} else {\n  debug = function () {};\n}\n/*&lt;/replacement&gt;*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \&quot;./node_modules/readable-stream/lib/internal/streams/BufferList.js\&quot;);\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \&quot;./node_modules/readable-stream/lib/internal/streams/destroy.js\&quot;);\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = [&#039;error&#039;, &#039;close&#039;, &#039;destroy&#039;, &#039;pause&#039;, &#039;resume&#039;];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === &#039;function&#039;) return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \&quot;./node_modules/readable-stream/lib/_stream_duplex.js\&quot;);\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \&quot;don&#039;t call _read preemptively ever\&quot;\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex &amp;&amp; (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event &#039;readable&#039;/&#039;data&#039; is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn&#039;t happen until \&quot;later\&quot; should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we&#039;re awaiting a &#039;readable&#039; event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is &#039;binary&#039; so we have to make this configurable.\n  // Everything else in the universe uses &#039;utf8&#039;, though.\n  this.defaultEncoding = options.defaultEncoding || &#039;utf8&#039;;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \&quot;./node_modules/string_decoder/lib/string_decoder.js\&quot;).StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \&quot;./node_modules/readable-stream/lib/_stream_duplex.js\&quot;);\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === &#039;function&#039;) this._read = options.read;\n\n    if (typeof options.destroy === &#039;function&#039;) this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, &#039;destroyed&#039;, {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === &#039;string&#039;) {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = &#039;&#039;;\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit(&#039;error&#039;, er);\n    } else if (state.objectMode || chunk &amp;&amp; chunk.length &gt; 0) {\n      if (typeof chunk !== &#039;string&#039; &amp;&amp; !state.objectMode &amp;&amp; Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit(&#039;error&#039;, new Error(&#039;stream.unshift() after end event&#039;));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit(&#039;error&#039;, new Error(&#039;stream.push() after EOF&#039;));\n      } else {\n        state.reading = false;\n        if (state.decoder &amp;&amp; !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing &amp;&amp; state.length === 0 &amp;&amp; !state.sync) {\n    stream.emit(&#039;data&#039;, chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) &amp;&amp; typeof chunk !== &#039;string&#039; &amp;&amp; chunk !== undefined &amp;&amp; !state.objectMode) {\n    er = new TypeError(&#039;Invalid non-string/buffer chunk&#039;);\n  }\n  return er;\n}\n\n// if it&#039;s past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// &#039;readable&#039; event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &amp;&amp; (state.needReadable || state.length &lt; state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \&quot;./node_modules/string_decoder/lib/string_decoder.js\&quot;).StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don&#039;t raise the hwm &gt; 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n &gt;= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n &gt;&gt;&gt; 1;\n    n |= n &gt;&gt;&gt; 2;\n    n |= n &gt;&gt;&gt; 4;\n    n |= n &gt;&gt;&gt; 8;\n    n |= n &gt;&gt;&gt; 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n &lt;= 0 || state.length === 0 &amp;&amp; state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing &amp;&amp; state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we&#039;re asking for more than the current hwm, then raise the hwm.\n  if (n &gt; state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n &lt;= state.length) return n;\n  // Don&#039;t have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug(&#039;read&#039;, n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we&#039;re doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the &#039;readable&#039; event and move on.\n  if (n === 0 &amp;&amp; state.needReadable &amp;&amp; (state.length &gt;= state.highWaterMark || state.ended)) {\n    debug(&#039;read: emitReadable&#039;, state.length, state.ended);\n    if (state.length === 0 &amp;&amp; state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we&#039;ve ended, and we&#039;re now clear, then finish it up.\n  if (n === 0 &amp;&amp; state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn&#039;t mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it&#039;s safe to emit\n  // &#039;readable&#039; etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug(&#039;need readable&#039;, doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n &lt; state.highWaterMark) {\n    doRead = true;\n    debug(&#039;length less than watermark&#039;, doRead);\n  }\n\n  // however, if we&#039;ve ended, then there&#039;s no point, and if we&#039;re already\n  // reading, then it&#039;s unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug(&#039;reading or ended&#039;, doRead);\n  } else if (doRead) {\n    debug(&#039;do read&#039;);\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n &gt; 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n &amp;&amp; state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit(&#039;data&#039;, ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk &amp;&amp; chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit &#039;readable&#039; now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don&#039;t emit readable right away in sync mode, because this can trigger\n// another read() call =&gt; stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that&#039;s not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug(&#039;emitReadable&#039;, state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug(&#039;emit readable&#039;);\n  stream.emit(&#039;readable&#039;);\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the &#039;readable&#039; event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it&#039;s in progress.\n// However, if we&#039;re not ended, or reading, and the length &lt; hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading &amp;&amp; !state.flowing &amp;&amp; !state.ended &amp;&amp; state.length &lt; state.highWaterMark) {\n    debug(&#039;maybeReadMore read 0&#039;);\n    stream.read(0);\n    if (len === state.length)\n      // didn&#039;t get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is &lt;= n in length.\n// for virtual (non-string, non-buffer) streams, \&quot;length\&quot; is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit(&#039;error&#039;, new Error(&#039;_read() is not implemented&#039;));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug(&#039;pipe count=%d opts=%j&#039;, state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &amp;&amp; dest !== process.stdout &amp;&amp; dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once(&#039;end&#039;, endFn);\n\n  dest.on(&#039;unpipe&#039;, onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug(&#039;onunpipe&#039;);\n    if (readable === src) {\n      if (unpipeInfo &amp;&amp; unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug(&#039;onend&#039;);\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on(&#039;drain&#039;, ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug(&#039;cleanup&#039;);\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener(&#039;close&#039;, onclose);\n    dest.removeListener(&#039;finish&#039;, onfinish);\n    dest.removeListener(&#039;drain&#039;, ondrain);\n    dest.removeListener(&#039;error&#039;, onerror);\n    dest.removeListener(&#039;unpipe&#039;, onunpipe);\n    src.removeListener(&#039;end&#039;, onend);\n    src.removeListener(&#039;end&#039;, unpipe);\n    src.removeListener(&#039;data&#039;, ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don&#039;t know, then assume that we are waiting for one.\n    if (state.awaitDrain &amp;&amp; (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we&#039;re writing to dest then we&#039;ll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one &#039;drain&#039; event for the multiple writes.\n  // =&gt; Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on(&#039;data&#039;, ondata);\n  function ondata(chunk) {\n    debug(&#039;ondata&#039;);\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret &amp;&amp; !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // =&gt; Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 &amp;&amp; state.pipes === dest || state.pipesCount &gt; 1 &amp;&amp; indexOf(state.pipes, dest) !== -1) &amp;&amp; !cleanedUp) {\n        debug(&#039;false write response, pause&#039;, src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don&#039;t suppress the throwing behavior for this.\n  function onerror(er) {\n    debug(&#039;onerror&#039;, er);\n    unpipe();\n    dest.removeListener(&#039;error&#039;, onerror);\n    if (EElistenerCount(dest, &#039;error&#039;) === 0) dest.emit(&#039;error&#039;, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, &#039;error&#039;, onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener(&#039;finish&#039;, onfinish);\n    unpipe();\n  }\n  dest.once(&#039;close&#039;, onclose);\n  function onfinish() {\n    debug(&#039;onfinish&#039;);\n    dest.removeListener(&#039;close&#039;, onclose);\n    unpipe();\n  }\n  dest.once(&#039;finish&#039;, onfinish);\n\n  function unpipe() {\n    debug(&#039;unpipe&#039;);\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it&#039;s being piped to\n  dest.emit(&#039;pipe&#039;, src);\n\n  // start the flow if it hasn&#039;t been started already.\n  if (!state.flowing) {\n    debug(&#039;pipe resume&#039;);\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug(&#039;pipeOnDrain&#039;, state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 &amp;&amp; EElistenerCount(src, &#039;data&#039;)) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we&#039;re not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it&#039;s not the right one.\n    if (dest &amp;&amp; dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit(&#039;unpipe&#039;, this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i &lt; len; i++) {\n      dests[i].emit(&#039;unpipe&#039;, this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit(&#039;unpipe&#039;, this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === &#039;data&#039;) {\n    // Start flowing on next tick if stream isn&#039;t explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === &#039;readable&#039;) {\n    var state = this._readableState;\n    if (!state.endEmitted &amp;&amp; !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug(&#039;readable nexttick read 0&#039;);\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug(&#039;resume&#039;);\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug(&#039;resume read 0&#039;);\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit(&#039;resume&#039;);\n  flow(stream);\n  if (state.flowing &amp;&amp; !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug(&#039;call pause flowing=%j&#039;, this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug(&#039;pause&#039;);\n    this._readableState.flowing = false;\n    this.emit(&#039;pause&#039;);\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug(&#039;flow&#039;, state.flowing);\n  while (state.flowing &amp;&amp; stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on(&#039;end&#039;, function () {\n    debug(&#039;wrapped end&#039;);\n    if (state.decoder &amp;&amp; !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk &amp;&amp; chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on(&#039;data&#039;, function (chunk) {\n    debug(&#039;wrapped data&#039;);\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don&#039;t skip over falsy values in objectMode\n    if (state.objectMode &amp;&amp; (chunk === null || chunk === undefined)) return;else if (!state.objectMode &amp;&amp; (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined &amp;&amp; typeof stream[i] === &#039;function&#039;) {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n &lt; kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug(&#039;wrapped _read&#039;, n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, &#039;readableHighWaterMark&#039;, {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n &gt;= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join(&#039;&#039;);else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n &lt; list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n &gt; str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n &gt; buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length &gt; 0) throw new Error(&#039;\&quot;endReadable()\&quot; called on non-empty stream&#039;);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn&#039;t get one last unshift.\n  if (!state.endEmitted &amp;&amp; state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit(&#039;end&#039;);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i &lt; l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/_stream_readable.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/_stream_transform.js&quot;:
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it&#039;s called a \&quot;filter\&quot;,\n// but that&#039;s not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it&#039;s not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here&#039;s how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there&#039;s a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there&#039;s enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb&#039;s as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit &#039;readable&#039; if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there&#039;d be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \&quot;./node_modules/readable-stream/lib/_stream_duplex.js\&quot;);\n\n/*&lt;replacement&gt;*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \&quot;./node_modules/core-util-is/lib/util.js\&quot;));\nutil.inherits = __webpack_require__(/*! inherits */ \&quot;./node_modules/inherits/inherits.js\&quot;);\n/*&lt;/replacement&gt;*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit(&#039;error&#039;, new Error(&#039;write callback called multiple times&#039;));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length &lt; rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === &#039;function&#039;) this._transform = options.transform;\n\n    if (typeof options.flush === &#039;function&#039;) this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on(&#039;prefinish&#039;, prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === &#039;function&#039;) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// &#039;chunk&#039; is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call &#039;push&#039; zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that&#039;ll put the hurt on the whole operation.  If you\n// never call cb(), then you&#039;ll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error(&#039;_transform() is not implemented&#039;);\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length &lt; rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn&#039;t matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we&#039;ve asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit(&#039;close&#039;);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit(&#039;error&#039;, er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there&#039;s nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error(&#039;Calling transform done when ws.length != 0&#039;);\n\n  if (stream._transformState.transforming) throw new Error(&#039;Calling transform done when still transforming&#039;);\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/_stream_transform.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/_stream_writable.js&quot;:
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it&#039;ll handle all\n// the drain event emission and buffering.\n\n\n\n/*&lt;replacement&gt;*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \&quot;./node_modules/process-nextick-args/index.js\&quot;);\n/*&lt;/replacement&gt;*/\n\nmodule.exports = Writable;\n\n/* &lt;replacement&gt; */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* &lt;/replacement&gt; */\n\n/*&lt;replacement&gt;*/\nvar asyncWrite = !process.browser &amp;&amp; [&#039;v0.10&#039;, &#039;v0.9.&#039;].indexOf(process.version.slice(0, 5)) &gt; -1 ? setImmediate : pna.nextTick;\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar Duplex;\n/*&lt;/replacement&gt;*/\n\nWritable.WritableState = WritableState;\n\n/*&lt;replacement&gt;*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \&quot;./node_modules/core-util-is/lib/util.js\&quot;));\nutil.inherits = __webpack_require__(/*! inherits */ \&quot;./node_modules/inherits/inherits.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \&quot;./node_modules/util-deprecate/node.js\&quot;)\n};\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \&quot;./node_modules/readable-stream/lib/internal/streams/stream.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n/*&lt;replacement&gt;*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \&quot;./node_modules/safe-buffer/index.js\&quot;).Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*&lt;/replacement&gt;*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \&quot;./node_modules/readable-stream/lib/internal/streams/destroy.js\&quot;);\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \&quot;./node_modules/readable-stream/lib/_stream_duplex.js\&quot;);\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex &amp;&amp; (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when &#039;finish&#039; is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is &#039;binary&#039; so we have to make this configurable.\n  // Everything else in the universe uses &#039;utf8&#039;, though.\n  this.defaultEncoding = options.defaultEncoding || &#039;utf8&#039;;\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we&#039;re waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we&#039;re in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn&#039;t happen until \&quot;later\&quot; should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we&#039;re processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don&#039;t\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that&#039;s passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before &#039;finish&#039; can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we&#039;re waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, &#039;buffer&#039;, {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, &#039;_writableState.buffer is deprecated. Use _writableState.getBuffer &#039; + &#039;instead.&#039;, &#039;DEP0003&#039;)\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === &#039;function&#039; &amp;&amp; Symbol.hasInstance &amp;&amp; typeof Function.prototype[Symbol.hasInstance] === &#039;function&#039;) {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object &amp;&amp; object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \&quot;./node_modules/readable-stream/lib/_stream_duplex.js\&quot;);\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) &amp;&amp; !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === &#039;function&#039;) this._write = options.write;\n\n    if (typeof options.writev === &#039;function&#039;) this._writev = options.writev;\n\n    if (typeof options.destroy === &#039;function&#039;) this._destroy = options.destroy;\n\n    if (typeof options.final === &#039;function&#039;) this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit(&#039;error&#039;, new Error(&#039;Cannot pipe, not readable&#039;));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error(&#039;write after end&#039;);\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit(&#039;error&#039;, er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError(&#039;May not write null values to stream&#039;);\n  } else if (typeof chunk !== &#039;string&#039; &amp;&amp; chunk !== undefined &amp;&amp; !state.objectMode) {\n    er = new TypeError(&#039;Invalid non-string/buffer chunk&#039;);\n  }\n  if (er) {\n    stream.emit(&#039;error&#039;, er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode &amp;&amp; _isUint8Array(chunk);\n\n  if (isBuf &amp;&amp; !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === &#039;function&#039;) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = &#039;buffer&#039;;else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== &#039;function&#039;) cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &amp;&amp; !state.corked &amp;&amp; !state.finished &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === &#039;string&#039;) encoding = encoding.toLowerCase();\n  if (!([&#039;hex&#039;, &#039;utf8&#039;, &#039;utf-8&#039;, &#039;ascii&#039;, &#039;binary&#039;, &#039;base64&#039;, &#039;ucs2&#039;, &#039;ucs-2&#039;, &#039;utf16le&#039;, &#039;utf-16le&#039;, &#039;raw&#039;].indexOf((encoding + &#039;&#039;).toLowerCase()) &gt; -1)) throw new TypeError(&#039;Unknown encoding: &#039; + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &amp;&amp; state.decodeStrings !== false &amp;&amp; typeof chunk === &#039;string&#039;) {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, &#039;writableHighWaterMark&#039;, {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we&#039;re already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = &#039;buffer&#039;;\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length &lt; state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit(&#039;error&#039;, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit(&#039;error&#039;, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we&#039;re actually ready to finish, but don&#039;t emit yet\n    var finished = needFinish(state);\n\n    if (!finished &amp;&amp; !state.corked &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*&lt;replacement&gt;*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*&lt;/replacement&gt;*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don&#039;t\n// emit &#039;drain&#039; before the write() consumer gets the &#039;false&#039; return\n// value, and has a chance to attach a &#039;drain&#039; listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 &amp;&amp; state.needDrain) {\n    state.needDrain = false;\n    stream.emit(&#039;drain&#039;);\n  }\n}\n\n// if there&#039;s something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev &amp;&amp; entry &amp;&amp; entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, &#039;&#039;, holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn&#039;t call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error(&#039;_write() is not implemented&#039;));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === &#039;function&#039;) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === &#039;function&#039;) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null &amp;&amp; chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending &amp;&amp; !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending &amp;&amp; state.length === 0 &amp;&amp; state.bufferedRequest === null &amp;&amp; !state.finished &amp;&amp; !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit(&#039;error&#039;, err);\n    }\n    state.prefinished = true;\n    stream.emit(&#039;prefinish&#039;);\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished &amp;&amp; !state.finalCalled) {\n    if (typeof stream._final === &#039;function&#039;) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit(&#039;prefinish&#039;);\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit(&#039;finish&#039;);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once(&#039;finish&#039;, cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, &#039;destroyed&#039;, {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/_stream_writable.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/internal/streams/BufferList.js&quot;:
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\&quot;Cannot call a class as a function\&quot;); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \&quot;./node_modules/safe-buffer/index.js\&quot;).Buffer;\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length &gt; 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return &#039;&#039;;\n    var p = this.head;\n    var ret = &#039;&#039; + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n &gt;&gt;&gt; 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util &amp;&amp; util.inspect &amp;&amp; util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + &#039; &#039; + obj;\n  };\n}\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/internal/streams/BufferList.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/internal/streams/destroy.js&quot;:
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/*&lt;replacement&gt;*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \&quot;./node_modules/process-nextick-args/index.js\&quot;);\n/*&lt;/replacement&gt;*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState &amp;&amp; this._readableState.destroyed;\n  var writableDestroyed = this._writableState &amp;&amp; this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err &amp;&amp; (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb &amp;&amp; err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit(&#039;error&#039;, err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/internal/streams/destroy.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/lib/internal/streams/stream.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;module.exports = __webpack_require__(/*! stream */ \&quot;stream\&quot;);\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/lib/internal/streams/stream.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readable-stream/readable.js&quot;:
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/readable.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

eval(&quot;var Stream = __webpack_require__(/*! stream */ \&quot;stream\&quot;);\nif (process.env.READABLE_STREAM === &#039;disable&#039; &amp;&amp; Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \&quot;./node_modules/readable-stream/lib/_stream_readable.js\&quot;);\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \&quot;./node_modules/readable-stream/lib/_stream_writable.js\&quot;);\n  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \&quot;./node_modules/readable-stream/lib/_stream_duplex.js\&quot;);\n  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \&quot;./node_modules/readable-stream/lib/_stream_transform.js\&quot;);\n  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \&quot;./node_modules/readable-stream/lib/_stream_passthrough.js\&quot;);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readable-stream/readable.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readdirp/readdirp.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/readdirp/readdirp.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar fs        =  __webpack_require__(/*! graceful-fs */ \&quot;./node_modules/graceful-fs/graceful-fs.js\&quot;)\n  , path      =  __webpack_require__(/*! path */ \&quot;path\&quot;)\n  , micromatch =  __webpack_require__(/*! micromatch */ \&quot;./node_modules/micromatch/index.js\&quot;).isMatch\n  , toString  =  Object.prototype.toString\n  ;\n\n\n// Standard helpers\nfunction isFunction (obj) {\n  return toString.call(obj) === &#039;[object Function]&#039;;\n}\n\nfunction isString (obj) {\n  return toString.call(obj) === &#039;[object String]&#039;;\n}\n\nfunction isUndefined (obj) {\n  return obj === void 0;\n}\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth\n * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },\n *                                when callback2 is not given, it behaves like explained in callback2\n * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos\n *                                function (err, fileInfos) { ... }\n */\nfunction readdir(opts, callback1, callback2) {\n  var stream\n    , handleError\n    , handleFatalError\n    , errors = []\n    , readdirResult = {\n        directories: []\n      , files: []\n    }\n    , fileProcessed\n    , allProcessed\n    , realRoot\n    , aborted = false\n    , paused = false\n    ;\n\n  // If no callbacks were given we will use a streaming interface\n  if (isUndefined(callback1)) {\n    var api          =  __webpack_require__(/*! ./stream-api */ \&quot;./node_modules/readdirp/stream-api.js\&quot;)();\n    stream           =  api.stream;\n    callback1        =  api.processEntry;\n    callback2        =  api.done;\n    handleError      =  api.handleError;\n    handleFatalError =  api.handleFatalError;\n\n    stream.on(&#039;close&#039;, function () { aborted = true; });\n    stream.on(&#039;pause&#039;, function () { paused = true; });\n    stream.on(&#039;resume&#039;, function () { paused = false; });\n  } else {\n    handleError      =  function (err) { errors.push(err); };\n    handleFatalError =  function (err) {\n      handleError(err);\n      allProcessed(errors, null);\n    };\n  }\n\n  if (isUndefined(opts)){\n    handleFatalError(new Error (\n      &#039;Need to pass at least one argument: opts! \\n&#039; +\n      &#039;https://github.com/paulmillr/readdirp#options&#039;\n      )\n    );\n    return stream;\n  }\n\n  opts.root            =  opts.root            || &#039;.&#039;;\n  opts.fileFilter      =  opts.fileFilter      || function() { return true; };\n  opts.directoryFilter =  opts.directoryFilter || function() { return true; };\n  opts.depth           =  typeof opts.depth === &#039;undefined&#039; ? 999999999 : opts.depth;\n  opts.entryType       =  opts.entryType       || &#039;files&#039;;\n\n  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);\n\n  if (isUndefined(callback2)) {\n    fileProcessed = function() { };\n    allProcessed = callback1;\n  } else {\n    fileProcessed = callback1;\n    allProcessed = callback2;\n  }\n\n  function normalizeFilter (filter) {\n\n    if (isUndefined(filter)) return undefined;\n\n    function isNegated (filters) {\n\n      function negated(f) {\n        return f.indexOf(&#039;!&#039;) === 0;\n      }\n\n      var some = filters.some(negated);\n      if (!some) {\n        return false;\n      } else {\n        if (filters.every(negated)) {\n          return true;\n        } else {\n          // if we detect illegal filters, bail out immediately\n          throw new Error(\n            &#039;Cannot mix negated with non negated glob filters: &#039; + filters + &#039;\\n&#039; +\n            &#039;https://github.com/paulmillr/readdirp#filters&#039;\n          );\n        }\n      }\n    }\n\n    // Turn all filters into a function\n    if (isFunction(filter)) {\n\n      return filter;\n\n    } else if (isString(filter)) {\n\n      return function (entryInfo) {\n        return micromatch(entryInfo.name, filter.trim());\n      };\n\n    } else if (filter &amp;&amp; Array.isArray(filter)) {\n\n      if (filter) filter = filter.map(function (f) {\n        return f.trim();\n      });\n\n      return isNegated(filter) ?\n        // use AND to concat multiple negated filters\n        function (entryInfo) {\n          return filter.every(function (f) {\n            return micromatch(entryInfo.name, f);\n          });\n        }\n        :\n        // use OR to concat multiple inclusive filters\n        function (entryInfo) {\n          return filter.some(function (f) {\n            return micromatch(entryInfo.name, f);\n          });\n        };\n    }\n  }\n\n  function processDir(currentDir, entries, callProcessed) {\n    if (aborted) return;\n    var total = entries.length\n      , processed = 0\n      , entryInfos = []\n      ;\n\n    fs.realpath(currentDir, function(err, realCurrentDir) {\n      if (aborted) return;\n      if (err) {\n        handleError(err);\n        callProcessed(entryInfos);\n        return;\n      }\n\n      var relDir = path.relative(realRoot, realCurrentDir);\n\n      if (entries.length === 0) {\n        callProcessed([]);\n      } else {\n        entries.forEach(function (entry) {\n\n          var fullPath = path.join(realCurrentDir, entry)\n            , relPath  = path.join(relDir, entry);\n\n          statfn(fullPath, function (err, stat) {\n            if (err) {\n              handleError(err);\n            } else {\n              entryInfos.push({\n                  name          :  entry\n                , path          :  relPath   // relative to root\n                , fullPath      :  fullPath\n\n                , parentDir     :  relDir    // relative to root\n                , fullParentDir :  realCurrentDir\n\n                , stat          :  stat\n              });\n            }\n            processed++;\n            if (processed === total) callProcessed(entryInfos);\n          });\n        });\n      }\n    });\n  }\n\n  function readdirRec(currentDir, depth, callCurrentDirProcessed) {\n    var args = arguments;\n    if (aborted) return;\n    if (paused) {\n      setImmediate(function () {\n        readdirRec.apply(null, args);\n      })\n      return;\n    }\n\n    fs.readdir(currentDir, function (err, entries) {\n      if (err) {\n        handleError(err);\n        callCurrentDirProcessed();\n        return;\n      }\n\n      processDir(currentDir, entries, function(entryInfos) {\n\n        var subdirs = entryInfos\n          .filter(function (ei) { return ei.stat.isDirectory() &amp;&amp; opts.directoryFilter(ei); });\n\n        subdirs.forEach(function (di) {\n          if(opts.entryType === &#039;directories&#039; || opts.entryType === &#039;both&#039; || opts.entryType === &#039;all&#039;) {\n            fileProcessed(di);\n          }\n          readdirResult.directories.push(di);\n        });\n\n        entryInfos\n          .filter(function(ei) {\n            var isCorrectType = opts.entryType === &#039;all&#039; ?\n              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();\n            return isCorrectType &amp;&amp; opts.fileFilter(ei);\n          })\n          .forEach(function (fi) {\n            if(opts.entryType === &#039;files&#039; || opts.entryType === &#039;both&#039; || opts.entryType === &#039;all&#039;) {\n              fileProcessed(fi);\n            }\n            readdirResult.files.push(fi);\n          });\n\n        var pendingSubdirs = subdirs.length;\n\n        // Be done if no more subfolders exist or we reached the maximum desired depth\n        if(pendingSubdirs === 0 || depth === opts.depth) {\n          callCurrentDirProcessed();\n        } else {\n          // recurse into subdirs, keeping track of which ones are done\n          // and call back once all are processed\n          subdirs.forEach(function (subdir) {\n            readdirRec(subdir.fullPath, depth + 1, function () {\n              pendingSubdirs = pendingSubdirs - 1;\n              if(pendingSubdirs === 0) {\n                callCurrentDirProcessed();\n              }\n            });\n          });\n        }\n      });\n    });\n  }\n\n  // Validate and normalize filters\n  try {\n    opts.fileFilter = normalizeFilter(opts.fileFilter);\n    opts.directoryFilter = normalizeFilter(opts.directoryFilter);\n  } catch (err) {\n    // if we detect illegal filters, bail out immediately\n    handleFatalError(err);\n    return stream;\n  }\n\n  // If filters were valid get on with the show\n  fs.realpath(opts.root, function(err, res) {\n    if (err) {\n      handleFatalError(err);\n      return stream;\n    }\n\n    realRoot = res;\n    readdirRec(opts.root, 0, function () {\n      // All errors are collected into the errors array\n      if (errors.length &gt; 0) {\n        allProcessed(errors, readdirResult);\n      } else {\n        allProcessed(null, readdirResult);\n      }\n    });\n  });\n\n  return stream;\n}\n\nmodule.exports = readdir;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readdirp/readdirp.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/readdirp/stream-api.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/readdirp/stream-api.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar stream = __webpack_require__(/*! readable-stream */ \&quot;./node_modules/readable-stream/readable.js\&quot;);\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\n\nvar Readable = stream.Readable;\n\nmodule.exports = ReaddirpReadable;\n\nutil.inherits(ReaddirpReadable, Readable);\n\nfunction ReaddirpReadable (opts) {\n  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);\n\n  opts = opts || {};\n\n  opts.objectMode = true;\n  Readable.call(this, opts);\n\n  // backpressure not implemented at this point\n  this.highWaterMark = Infinity;\n\n  this._destroyed = false;\n  this._paused = false;\n  this._warnings = [];\n  this._errors = [];\n\n  this._pauseResumeErrors();\n}\n\nvar proto = ReaddirpReadable.prototype;\n\nproto._pauseResumeErrors = function () {\n  var self = this;\n  self.on(&#039;pause&#039;, function () { self._paused = true });\n  self.on(&#039;resume&#039;, function () {\n    if (self._destroyed) return;\n    self._paused = false;\n\n    self._warnings.forEach(function (err) { self.emit(&#039;warn&#039;, err) });\n    self._warnings.length = 0;\n\n    self._errors.forEach(function (err) { self.emit(&#039;error&#039;, err) });\n    self._errors.length = 0;\n  })\n}\n\n// called for each entry\nproto._processEntry = function (entry) {\n  if (this._destroyed) return;\n  this.push(entry);\n}\n\nproto._read = function () { }\n\nproto.destroy = function () {\n  // when stream is destroyed it will emit nothing further, not even errors or warnings\n  this.push(null);\n  this.readable = false;\n  this._destroyed = true;\n  this.emit(&#039;close&#039;);\n}\n\nproto._done = function () {\n  this.push(null);\n}\n\n// we emit errors and warnings async since we may handle errors like invalid args\n// within the initial event loop before any event listeners subscribed\nproto._handleError = function (err) {\n  var self = this;\n  setImmediate(function () {\n    if (self._paused) return self._warnings.push(err);\n    if (!self._destroyed) self.emit(&#039;warn&#039;, err);\n  });\n}\n\nproto._handleFatalError = function (err) {\n  var self = this;\n  setImmediate(function () {\n    if (self._paused) return self._errors.push(err);\n    if (!self._destroyed) self.emit(&#039;error&#039;, err);\n  });\n}\n\nfunction createStreamAPI () {\n  var stream = new ReaddirpReadable();\n\n  return {\n      stream           :  stream\n    , processEntry     :  stream._processEntry.bind(stream)\n    , done             :  stream._done.bind(stream)\n    , handleError      :  stream._handleError.bind(stream)\n    , handleFatalError :  stream._handleFatalError.bind(stream)\n  };\n}\n\nmodule.exports = createStreamAPI;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/readdirp/stream-api.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/regex-not/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/regex-not/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/regex-not/node_modules/extend-shallow/index.js\&quot;);\nvar safe = __webpack_require__(/*! safe-regex */ \&quot;./node_modules/safe-regex/index.js\&quot;);\n\n/**\n * The main export is a function that takes a `pattern` string and an `options` object.\n *\n * ```js\n &amp; var not = require(&#039;regex-not&#039;);\n &amp; console.log(not(&#039;foo&#039;));\n &amp; //=&gt; /^(?:(?!^(?:foo)$).)*$/\n * ```\n *\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.\n * @api public\n */\n\nfunction toRegex(pattern, options) {\n  return new RegExp(toRegex.create(pattern, options));\n}\n\n/**\n * Create a regex-compatible string from the given `pattern` and `options`.\n *\n * ```js\n &amp; var not = require(&#039;regex-not&#039;);\n &amp; console.log(not.create(&#039;foo&#039;));\n &amp; //=&gt; &#039;^(?:(?!^(?:foo)$).)*$&#039;\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\ntoRegex.create = function(pattern, options) {\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  var opts = extend({}, options);\n  if (opts.contains === true) {\n    opts.strictNegate = false;\n  }\n\n  var open = opts.strictOpen !== false ? &#039;^&#039; : &#039;&#039;;\n  var close = opts.strictClose !== false ? &#039;$&#039; : &#039;&#039;;\n  var endChar = opts.endChar ? opts.endChar : &#039;+&#039;;\n  var str = pattern;\n\n  if (opts.strictNegate === false) {\n    str = &#039;(?:(?!(?:&#039; + pattern + &#039;)).)&#039; + endChar;\n  } else {\n    str = &#039;(?:(?!^(?:&#039; + pattern + &#039;)$).)&#039; + endChar;\n  }\n\n  var res = open + str + close;\n  if (opts.safe === true &amp;&amp; safe(res) === false) {\n    throw new Error(&#039;potentially unsafe regular expression: &#039; + res);\n  }\n\n  return res;\n};\n\n/**\n * Expose `toRegex`\n */\n\nmodule.exports = toRegex;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/regex-not/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/regex-not/node_modules/extend-shallow/index.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/regex-not/node_modules/extend-shallow/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isExtendable = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/regex-not/node_modules/is-extendable/index.js\&quot;);\nvar assignSymbols = __webpack_require__(/*! assign-symbols */ \&quot;./node_modules/assign-symbols/index.js\&quot;);\n\nmodule.exports = Object.assign || function(obj/*, objects*/) {\n  if (obj === null || typeof obj === &#039;undefined&#039;) {\n    throw new TypeError(&#039;Cannot convert undefined or null to object&#039;);\n  }\n  if (!isObject(obj)) {\n    obj = {};\n  }\n  for (var i = 1; i &lt; arguments.length; i++) {\n    var val = arguments[i];\n    if (isString(val)) {\n      val = toObject(val);\n    }\n    if (isObject(val)) {\n      assign(obj, val);\n      assignSymbols(obj, val);\n    }\n  }\n  return obj;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction isString(val) {\n  return (val &amp;&amp; typeof val === &#039;string&#039;);\n}\n\nfunction toObject(str) {\n  var obj = {};\n  for (var i in str) {\n    obj[i] = str[i];\n  }\n  return obj;\n}\n\nfunction isObject(val) {\n  return (val &amp;&amp; typeof val === &#039;object&#039;) || isExtendable(val);\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isEnum(obj, key) {\n  return Object.prototype.propertyIsEnumerable.call(obj, key);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/regex-not/node_modules/extend-shallow/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/regex-not/node_modules/is-extendable/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/regex-not/node_modules/is-extendable/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\n\nmodule.exports = function isExtendable(val) {\n  return isPlainObject(val) || typeof val === &#039;function&#039; || Array.isArray(val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/regex-not/node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/remove-trailing-separator/index.js&quot;:
/*!*********************************************************!*\
  !*** ./node_modules/remove-trailing-separator/index.js ***!
  \*********************************************************/
/***/ ((module) =&gt; {

eval(&quot;var isWin = process.platform === &#039;win32&#039;;\n\nmodule.exports = function (str) {\n\tvar i = str.length - 1;\n\tif (i &lt; 2) {\n\t\treturn str;\n\t}\n\twhile (isSeparator(str, i)) {\n\t\ti--;\n\t}\n\treturn str.substr(0, i + 1);\n};\n\nfunction isSeparator(str, i) {\n\tvar char = str[i];\n\treturn i &gt; 0 &amp;&amp; (char === &#039;/&#039; || (isWin &amp;&amp; char === &#039;\\\\&#039;));\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/remove-trailing-separator/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/repeat-element/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/repeat-element/index.js ***!
  \**********************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * repeat-element &lt;https://github.com/jonschlinkert/repeat-element&gt;\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Licensed under the MIT license.\n */\n\n\n\nmodule.exports = function repeat(ele, num) {\n  if (Array.prototype.fill) {\n    return new Array(num).fill(ele);\n  }\n\n  var arr = new Array(num);\n\n  for (var i = 0; i &lt; num; i++) {\n    arr[i] = ele;\n  }\n\n  return arr;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/repeat-element/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/repeat-string/index.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/repeat-string/index.js ***!
  \*********************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * repeat-string &lt;https://github.com/jonschlinkert/repeat-string&gt;\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\n/**\n * Results cache\n */\n\nvar res = &#039;&#039;;\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require(&#039;repeat-string&#039;);\n * repeat(&#039;A&#039;, 5);\n * //=&gt; AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === &#039;undefined&#039;) {\n    cache = str;\n    res = &#039;&#039;;\n  } else if (res.length &gt;= max) {\n    return res.substr(0, max);\n  }\n\n  while (max &gt; res.length &amp;&amp; num &gt; 1) {\n    if (num &amp; 1) {\n      res += str;\n    }\n\n    num &gt;&gt;= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/repeat-string/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/ret/lib/index.js&quot;:
/*!***************************************!*\
  !*** ./node_modules/ret/lib/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var util      = __webpack_require__(/*! ./util */ \&quot;./node_modules/ret/lib/util.js\&quot;);\nvar types     = __webpack_require__(/*! ./types */ \&quot;./node_modules/ret/lib/types.js\&quot;);\nvar sets      = __webpack_require__(/*! ./sets */ \&quot;./node_modules/ret/lib/sets.js\&quot;);\nvar positions = __webpack_require__(/*! ./positions */ \&quot;./node_modules/ret/lib/positions.js\&quot;);\n\n\nmodule.exports = function(regexpStr) {\n  var i = 0, l, c,\n      start = { type: types.ROOT, stack: []},\n\n      // Keep track of last clause/group and stack.\n      lastGroup = start,\n      last = start.stack,\n      groupStack = [];\n\n\n  var repeatErr = function(i) {\n    util.error(regexpStr, &#039;Nothing to repeat at column &#039; + (i - 1));\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i &lt; l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case &#039;\\\\&#039;:\n        c = str[i++];\n\n        switch (c) {\n          case &#039;b&#039;:\n            last.push(positions.wordBoundary());\n            break;\n\n          case &#039;B&#039;:\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case &#039;w&#039;:\n            last.push(sets.words());\n            break;\n\n          case &#039;W&#039;:\n            last.push(sets.notWords());\n            break;\n\n          case &#039;d&#039;:\n            last.push(sets.ints());\n            break;\n\n          case &#039;D&#039;:\n            last.push(sets.notInts());\n            break;\n\n          case &#039;s&#039;:\n            last.push(sets.whitespace());\n            break;\n\n          case &#039;S&#039;:\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it&#039;s a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case &#039;^&#039;:\n          last.push(positions.begin());\n        break;\n\n      case &#039;$&#039;:\n          last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case &#039;[&#039;:\n        // Check if this class is &#039;anti&#039; i.e. [^abc].\n        var not;\n        if (str[i] === &#039;^&#039;) {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not: not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case &#039;.&#039;:\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case &#039;(&#039;:\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === &#039;?&#039;) {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === &#039;=&#039;) {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === &#039;!&#039;) {\n            group.notFollowedBy = true;\n\n          } else if (c !== &#039;:&#039;) {\n            util.error(regexpStr,\n              &#039;Invalid group, character \\&#039;&#039; + c +\n              &#039;\\&#039; after \\&#039;?\\&#039; at column &#039; + (i - 1));\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case &#039;)&#039;:\n        if (groupStack.length === 0) {\n          util.error(regexpStr, &#039;Unmatched ) at column &#039; + (i - 1));\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case &#039;|&#039;:\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case &#039;{&#039;:\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min: min,\n            max: max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case &#039;?&#039;:\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case &#039;+&#039;:\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case &#039;*&#039;:\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, &#039;Unterminated group&#039;);\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/ret/lib/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/ret/lib/positions.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/ret/lib/positions.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;var types = __webpack_require__(/*! ./types */ \&quot;./node_modules/ret/lib/types.js\&quot;);\n\nexports.wordBoundary = function() {\n  return { type: types.POSITION, value: &#039;b&#039; };\n};\n\nexports.nonWordBoundary = function() {\n  return { type: types.POSITION, value: &#039;B&#039; };\n};\n\nexports.begin = function() {\n  return { type: types.POSITION, value: &#039;^&#039; };\n};\n\nexports.end = function() {\n  return { type: types.POSITION, value: &#039;$&#039; };\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/ret/lib/positions.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/ret/lib/sets.js&quot;:
/*!**************************************!*\
  !*** ./node_modules/ret/lib/sets.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;var types = __webpack_require__(/*! ./types */ \&quot;./node_modules/ret/lib/types.js\&quot;);\n\nvar INTS = function() {\n return [{ type: types.RANGE , from: 48, to: 57 }];\n};\n\nvar WORDS = function() {\n return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nvar WHITESPACE = function() {\n return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.CHAR, value: 6158 },\n    { type: types.CHAR, value: 8192 },\n    { type: types.CHAR, value: 8193 },\n    { type: types.CHAR, value: 8194 },\n    { type: types.CHAR, value: 8195 },\n    { type: types.CHAR, value: 8196 },\n    { type: types.CHAR, value: 8197 },\n    { type: types.CHAR, value: 8198 },\n    { type: types.CHAR, value: 8199 },\n    { type: types.CHAR, value: 8200 },\n    { type: types.CHAR, value: 8201 },\n    { type: types.CHAR, value: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nvar NOTANYCHAR = function() {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = function() {\n  return { type: types.SET, set: WORDS(), not: false };\n};\n\nexports.notWords = function() {\n  return { type: types.SET, set: WORDS(), not: true };\n};\n\nexports.ints = function() {\n  return { type: types.SET, set: INTS(), not: false };\n};\n\nexports.notInts = function() {\n  return { type: types.SET, set: INTS(), not: true };\n};\n\nexports.whitespace = function() {\n  return { type: types.SET, set: WHITESPACE(), not: false };\n};\n\nexports.notWhitespace = function() {\n  return { type: types.SET, set: WHITESPACE(), not: true };\n};\n\nexports.anyChar = function() {\n  return { type: types.SET, set: NOTANYCHAR(), not: true };\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/ret/lib/sets.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/ret/lib/types.js&quot;:
/*!***************************************!*\
  !*** ./node_modules/ret/lib/types.js ***!
  \***************************************/
/***/ ((module) =&gt; {

eval(&quot;module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/ret/lib/types.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/ret/lib/util.js&quot;:
/*!**************************************!*\
  !*** ./node_modules/ret/lib/util.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;var types = __webpack_require__(/*! ./types */ \&quot;./node_modules/ret/lib/types.js\&quot;);\nvar sets  = __webpack_require__(/*! ./sets */ \&quot;./node_modules/ret/lib/sets.js\&quot;);\n\n\n// All of these are private and only used by randexp.\n// It&#039;s assumed that they will always be called with the correct input.\n\nvar CTRL = &#039;@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?&#039;;\nvar SLSH = { &#039;0&#039;: 0, &#039;t&#039;: 9, &#039;n&#039;: 10, &#039;v&#039;: 11, &#039;f&#039;: 12, &#039;r&#039;: 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\\[\\\\\\]\\^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b     ? 8 :\n               a16   ? parseInt(a16, 16) :\n               b16   ? parseInt(b16, 16) :\n               c8    ? parseInt(c8,   8) :\n               dctrl ? CTRL.indexOf(dctrl) :\n               SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[\\[\\]{}\\^$.|?*+()]/.test(c)) {\n      c = &#039;\\\\&#039; + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.&lt;Array.&lt;Object&gt;, Number&gt;}\n */\nexports.tokenizeClass = function(str, regexpStr) {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?(.)/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n          to: rs[10].charCodeAt(0),\n      });\n\n    } else if (c = rs[12]) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, &#039;Unterminated character class&#039;);\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = function(regexp, msg) {\n  throw new SyntaxError(&#039;Invalid regular expression: /&#039; + regexp + &#039;/: &#039; + msg);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/ret/lib/util.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/safe-buffer/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

eval(&quot;/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \&quot;buffer\&quot;)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from &amp;&amp; Buffer.alloc &amp;&amp; Buffer.allocUnsafe &amp;&amp; Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require(&#039;buffer&#039;)\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === &#039;number&#039;) {\n    throw new TypeError(&#039;Argument must not be a number&#039;)\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== &#039;number&#039;) {\n    throw new TypeError(&#039;Argument must be a number&#039;)\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === &#039;string&#039;) {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== &#039;number&#039;) {\n    throw new TypeError(&#039;Argument must be a number&#039;)\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== &#039;number&#039;) {\n    throw new TypeError(&#039;Argument must be a number&#039;)\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/safe-buffer/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/safe-regex/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/safe-regex/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var parse = __webpack_require__(/*! ret */ \&quot;./node_modules/ret/lib/index.js\&quot;);\nvar types = parse.types;\n\nmodule.exports = function (re, opts) {\n    if (!opts) opts = {};\n    var replimit = opts.limit === undefined ? 25 : opts.limit;\n    \n    if (isRegExp(re)) re = re.source;\n    else if (typeof re !== &#039;string&#039;) re = String(re);\n    \n    try { re = parse(re) }\n    catch (err) { return false }\n    \n    var reps = 0;\n    return (function walk (node, starHeight) {\n        if (node.type === types.REPETITION) {\n            starHeight ++;\n            reps ++;\n            if (starHeight &gt; 1) return false;\n            if (reps &gt; replimit) return false;\n        }\n        \n        if (node.options) {\n            for (var i = 0, len = node.options.length; i &lt; len; i++) {\n                var ok = walk({ stack: node.options[i] }, starHeight);\n                if (!ok) return false;\n            }\n        }\n        var stack = node.stack || (node.value &amp;&amp; node.value.stack);\n        if (!stack) return true;\n        \n        for (var i = 0; i &lt; stack.length; i++) {\n            var ok = walk(stack[i], starHeight);\n            if (!ok) return false;\n        }\n        \n        return true;\n    })(re, 0);\n};\n\nfunction isRegExp (x) {\n    return {}.toString.call(x) === &#039;[object RegExp]&#039;;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/safe-regex/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/set-value/index.js&quot;:
/*!*****************************************!*\
  !*** ./node_modules/set-value/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * set-value &lt;https://github.com/jonschlinkert/set-value&gt;\n *\n * Copyright (c) 2014-2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar split = __webpack_require__(/*! split-string */ \&quot;./node_modules/split-string/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\nvar isObject = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/is-extendable/index.js\&quot;);\n\nmodule.exports = function(obj, prop, val) {\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(prop)) {\n    prop = [].concat.apply([], prop).join(&#039;.&#039;);\n  }\n\n  if (typeof prop !== &#039;string&#039;) {\n    return obj;\n  }\n\n  var keys = split(prop, {sep: &#039;.&#039;, brackets: true}).filter(isValidKey);\n  var len = keys.length;\n  var idx = -1;\n  var current = obj;\n\n  while (++idx &lt; len) {\n    var key = keys[idx];\n    if (idx !== len - 1) {\n      if (!isObject(current[key])) {\n        current[key] = {};\n      }\n      current = current[key];\n      continue;\n    }\n\n    if (isPlainObject(current[key]) &amp;&amp; isPlainObject(val)) {\n      current[key] = extend({}, current[key], val);\n    } else {\n      current[key] = val;\n    }\n  }\n\n  return obj;\n};\n\nfunction isValidKey(key) {\n  return key !== &#039;__proto__&#039; &amp;&amp; key !== &#039;constructor&#039; &amp;&amp; key !== &#039;prototype&#039;;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/set-value/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon-node/index.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/snapdragon-node/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/snapdragon-node/node_modules/define-property/index.js\&quot;);\nvar utils = __webpack_require__(/*! snapdragon-util */ \&quot;./node_modules/snapdragon-util/index.js\&quot;);\nvar ownNames;\n\n/**\n * Create a new AST `Node` with the given `val` and `type`.\n *\n * ```js\n * var node = new Node(&#039;*&#039;, &#039;Star&#039;);\n * var node = new Node({type: &#039;star&#039;, val: &#039;*&#039;});\n * ```\n * @name Node\n * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.\n * @param {String} `type` The node type to use when `val` is a string.\n * @return {Object} node instance\n * @api public\n */\n\nfunction Node(val, type, parent) {\n  if (typeof type !== &#039;string&#039;) {\n    parent = type;\n    type = null;\n  }\n\n  define(this, &#039;parent&#039;, parent);\n  define(this, &#039;isNode&#039;, true);\n  define(this, &#039;expect&#039;, null);\n\n  if (typeof type !== &#039;string&#039; &amp;&amp; isObject(val)) {\n    lazyKeys();\n    var keys = Object.keys(val);\n    for (var i = 0; i &lt; keys.length; i++) {\n      var key = keys[i];\n      if (ownNames.indexOf(key) === -1) {\n        this[key] = val[key];\n      }\n    }\n  } else {\n    this.type = type;\n    this.val = val;\n  }\n}\n\n/**\n * Returns true if the given value is a node.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var node = new Node({type: &#039;foo&#039;});\n * console.log(Node.isNode(node)); //=&gt; true\n * console.log(Node.isNode({})); //=&gt; false\n * ```\n * @param {Object} `node`\n * @returns {Boolean}\n * @api public\n */\n\nNode.isNode = function(node) {\n  return utils.isNode(node);\n};\n\n/**\n * Define a non-enumberable property on the node instance.\n * Useful for adding properties that shouldn&#039;t be extended\n * or visible during debugging.\n *\n * ```js\n * var node = new Node();\n * node.define(&#039;foo&#039;, &#039;something non-enumerable&#039;);\n * ```\n * @param {String} `name`\n * @param {any} `val`\n * @return {Object} returns the node instance\n * @api public\n */\n\nNode.prototype.define = function(name, val) {\n  define(this, name, val);\n  return this;\n};\n\n/**\n * Returns true if `node.val` is an empty string, or `node.nodes` does\n * not contain any non-empty text nodes.\n *\n * ```js\n * var node = new Node({type: &#039;text&#039;});\n * node.isEmpty(); //=&gt; true\n * node.val = &#039;foo&#039;;\n * node.isEmpty(); //=&gt; false\n * ```\n * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.\n * @return {Boolean}\n * @api public\n */\n\nNode.prototype.isEmpty = function(fn) {\n  return utils.isEmpty(this, fn);\n};\n\n/**\n * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and\n * set `foo` as `bar.parent`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * foo.push(bar);\n * ```\n * @param {Object} `node`\n * @return {Number} Returns the length of `node.nodes`\n * @api public\n */\n\nNode.prototype.push = function(node) {\n  assert(Node.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  define(node, &#039;parent&#039;, this);\n\n  this.nodes = this.nodes || [];\n  return this.nodes.push(node);\n};\n\n/**\n * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and\n * set `foo` as `bar.parent`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * foo.unshift(bar);\n * ```\n * @param {Object} `node`\n * @return {Number} Returns the length of `node.nodes`\n * @api public\n */\n\nNode.prototype.unshift = function(node) {\n  assert(Node.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  define(node, &#039;parent&#039;, this);\n\n  this.nodes = this.nodes || [];\n  return this.nodes.unshift(node);\n};\n\n/**\n * Pop a node from `node.nodes`.\n *\n * ```js\n * var node = new Node({type: &#039;foo&#039;});\n * node.push(new Node({type: &#039;a&#039;}));\n * node.push(new Node({type: &#039;b&#039;}));\n * node.push(new Node({type: &#039;c&#039;}));\n * node.push(new Node({type: &#039;d&#039;}));\n * console.log(node.nodes.length);\n * //=&gt; 4\n * node.pop();\n * console.log(node.nodes.length);\n * //=&gt; 3\n * ```\n * @return {Number} Returns the popped `node`\n * @api public\n */\n\nNode.prototype.pop = function() {\n  return this.nodes &amp;&amp; this.nodes.pop();\n};\n\n/**\n * Shift a node from `node.nodes`.\n *\n * ```js\n * var node = new Node({type: &#039;foo&#039;});\n * node.push(new Node({type: &#039;a&#039;}));\n * node.push(new Node({type: &#039;b&#039;}));\n * node.push(new Node({type: &#039;c&#039;}));\n * node.push(new Node({type: &#039;d&#039;}));\n * console.log(node.nodes.length);\n * //=&gt; 4\n * node.shift();\n * console.log(node.nodes.length);\n * //=&gt; 3\n * ```\n * @return {Object} Returns the shifted `node`\n * @api public\n */\n\nNode.prototype.shift = function() {\n  return this.nodes &amp;&amp; this.nodes.shift();\n};\n\n/**\n * Remove `node` from `node.nodes`.\n *\n * ```js\n * node.remove(childNode);\n * ```\n * @param {Object} `node`\n * @return {Object} Returns the removed node.\n * @api public\n */\n\nNode.prototype.remove = function(node) {\n  assert(Node.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  this.nodes = this.nodes || [];\n  var idx = node.index;\n  if (idx !== -1) {\n    node.index = -1;\n    return this.nodes.splice(idx, 1);\n  }\n  return null;\n};\n\n/**\n * Get the first child node from `node.nodes` that matches the given `type`.\n * If `type` is a number, the child node at that index is returned.\n *\n * ```js\n * var child = node.find(1); //&lt;= index of the node to get\n * var child = node.find(&#039;foo&#039;); //&lt;= node.type of a child node\n * var child = node.find(/^(foo|bar)$/); //&lt;= regex to match node.type\n * var child = node.find([&#039;foo&#039;, &#039;bar&#039;]); //&lt;= array of node.type(s)\n * ```\n * @param {String} `type`\n * @return {Object} Returns a child node or undefined.\n * @api public\n */\n\nNode.prototype.find = function(type) {\n  return utils.findNode(this.nodes, type);\n};\n\n/**\n * Return true if the node is the given `type`.\n *\n * ```js\n * var node = new Node({type: &#039;bar&#039;});\n * cosole.log(node.isType(&#039;foo&#039;));          // false\n * cosole.log(node.isType(/^(foo|bar)$/));  // true\n * cosole.log(node.isType([&#039;foo&#039;, &#039;bar&#039;])); // true\n * ```\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nNode.prototype.isType = function(type) {\n  return utils.isType(this, type);\n};\n\n/**\n * Return true if the `node.nodes` has the given `type`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * foo.push(bar);\n *\n * cosole.log(foo.hasType(&#039;qux&#039;));          // false\n * cosole.log(foo.hasType(/^(qux|bar)$/));  // true\n * cosole.log(foo.hasType([&#039;qux&#039;, &#039;bar&#039;])); // true\n * ```\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nNode.prototype.hasType = function(type) {\n  return utils.hasType(this, type);\n};\n\n/**\n * Get the siblings array, or `null` if it doesn&#039;t exist.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * foo.push(bar);\n * foo.push(baz);\n *\n * console.log(bar.siblings.length) // 2\n * console.log(baz.siblings.length) // 2\n * ```\n * @return {Array}\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;siblings&#039;, {\n  set: function() {\n    throw new Error(&#039;node.siblings is a getter and cannot be defined&#039;);\n  },\n  get: function() {\n    return this.parent ? this.parent.nodes : null;\n  }\n});\n\n/**\n * Get the node&#039;s current index from `node.parent.nodes`.\n * This should always be correct, even when the parent adds nodes.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * var qux = new Node({type: &#039;qux&#039;});\n * foo.push(bar);\n * foo.push(baz);\n * foo.unshift(qux);\n *\n * console.log(bar.index) // 1\n * console.log(baz.index) // 2\n * console.log(qux.index) // 0\n * ```\n * @return {Number}\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;index&#039;, {\n  set: function(index) {\n    define(this, &#039;idx&#039;, index);\n  },\n  get: function() {\n    if (!Array.isArray(this.siblings)) {\n      return -1;\n    }\n    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;\n    if (tok !== this) {\n      this.idx = this.siblings.indexOf(this);\n    }\n    return this.idx;\n  }\n});\n\n/**\n * Get the previous node from the siblings array or `null`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * foo.push(bar);\n * foo.push(baz);\n *\n * console.log(baz.prev.type) // &#039;bar&#039;\n * ```\n * @return {Object}\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;prev&#039;, {\n  set: function() {\n    throw new Error(&#039;node.prev is a getter and cannot be defined&#039;);\n  },\n  get: function() {\n    if (Array.isArray(this.siblings)) {\n      return this.siblings[this.index - 1] || this.parent.prev;\n    }\n    return null;\n  }\n});\n\n/**\n * Get the siblings array, or `null` if it doesn&#039;t exist.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * foo.push(bar);\n * foo.push(baz);\n *\n * console.log(bar.siblings.length) // 2\n * console.log(baz.siblings.length) // 2\n * ```\n * @return {Object}\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;next&#039;, {\n  set: function() {\n    throw new Error(&#039;node.next is a getter and cannot be defined&#039;);\n  },\n  get: function() {\n    if (Array.isArray(this.siblings)) {\n      return this.siblings[this.index + 1] || this.parent.next;\n    }\n    return null;\n  }\n});\n\n/**\n * Get the first node from `node.nodes`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * var qux = new Node({type: &#039;qux&#039;});\n * foo.push(bar);\n * foo.push(baz);\n * foo.push(qux);\n *\n * console.log(foo.first.type) // &#039;bar&#039;\n * ```\n * @return {Object} The first node, or undefiend\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;first&#039;, {\n  get: function() {\n    return this.nodes ? this.nodes[0] : null;\n  }\n});\n\n/**\n * Get the last node from `node.nodes`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * var qux = new Node({type: &#039;qux&#039;});\n * foo.push(bar);\n * foo.push(baz);\n * foo.push(qux);\n *\n * console.log(foo.last.type) // &#039;qux&#039;\n * ```\n * @return {Object} The last node, or undefiend\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;last&#039;, {\n  get: function() {\n    return this.nodes ? utils.last(this.nodes) : null;\n  }\n});\n\n/**\n * Get the last node from `node.nodes`.\n *\n * ```js\n * var foo = new Node({type: &#039;foo&#039;});\n * var bar = new Node({type: &#039;bar&#039;});\n * var baz = new Node({type: &#039;baz&#039;});\n * var qux = new Node({type: &#039;qux&#039;});\n * foo.push(bar);\n * foo.push(baz);\n * foo.push(qux);\n *\n * console.log(foo.last.type) // &#039;qux&#039;\n * ```\n * @return {Object} The last node, or undefiend\n * @api public\n */\n\nObject.defineProperty(Node.prototype, &#039;scope&#039;, {\n  get: function() {\n    if (this.isScope !== true) {\n      return this.parent ? this.parent.scope : this;\n    }\n    return this;\n  }\n});\n\n/**\n * Get own property names from Node prototype, but only the\n * first time `Node` is instantiated\n */\n\nfunction lazyKeys() {\n  if (!ownNames) {\n    ownNames = Object.getOwnPropertyNames(Node.prototype);\n  }\n}\n\n/**\n * Simplified assertion. Throws an error is `val` is falsey.\n */\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}\n\n/**\n * Expose `Node`\n */\n\nexports = module.exports = Node;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon-node/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon-node/node_modules/define-property/index.js&quot;:
/*!****************************************************************************!*\
  !*** ./node_modules/snapdragon-node/node_modules/define-property/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/is-descriptor/index.js\&quot;);\n\nmodule.exports = function defineProperty(obj, prop, val) {\n  if (typeof obj !== &#039;object&#039; &amp;&amp; typeof obj !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected an object or function.&#039;);\n  }\n\n  if (typeof prop !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected `prop` to be a string.&#039;);\n  }\n\n  if (isDescriptor(val) &amp;&amp; (&#039;set&#039; in val || &#039;get&#039; in val)) {\n    return Object.defineProperty(obj, prop, val);\n  }\n\n  return Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon-node/node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon-util/index.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/snapdragon-util/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/snapdragon-util/node_modules/kind-of/index.js\&quot;);\nvar utils = module.exports;\n\n/**\n * Returns true if the given value is a node.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var node = new Node({type: &#039;foo&#039;});\n * console.log(utils.isNode(node)); //=&gt; true\n * console.log(utils.isNode({})); //=&gt; false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Boolean}\n * @api public\n */\n\nutils.isNode = function(node) {\n  return typeOf(node) === &#039;object&#039; &amp;&amp; node.isNode === true;\n};\n\n/**\n * Emit an empty string for the given `node`.\n *\n * ```js\n * // do nothing for beginning-of-string\n * snapdragon.compiler.set(&#039;bos&#039;, utils.noop);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.noop = function(node) {\n  append(this, &#039;&#039;, node);\n};\n\n/**\n * Appdend `node.val` to `compiler.output`, exactly as it was created\n * by the parser.\n *\n * ```js\n * snapdragon.compiler.set(&#039;text&#039;, utils.identity);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.identity = function(node) {\n  append(this, node.val, node);\n};\n\n/**\n * Previously named `.emit`, this method appends the given `val`\n * to `compiler.output` for the given node. Useful when you know\n * what value should be appended advance, regardless of the actual\n * value of `node.val`.\n *\n * ```js\n * snapdragon.compiler\n *   .set(&#039;i&#039;, function(node) {\n *     this.mapVisit(node);\n *   })\n *   .set(&#039;i.open&#039;, utils.append(&#039;&lt;i&gt;&#039;))\n *   .set(&#039;i.close&#039;, utils.append(&#039;&lt;/i&gt;&#039;))\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Function} Returns a compiler middleware function.\n * @api public\n */\n\nutils.append = function(val) {\n  return function(node) {\n    append(this, val, node);\n  };\n};\n\n/**\n * Used in compiler middleware, this onverts an AST node into\n * an empty `text` node and deletes `node.nodes` if it exists.\n * The advantage of this method is that, as opposed to completely\n * removing the node, indices will not need to be re-calculated\n * in sibling nodes, and nothing is appended to the output.\n *\n * ```js\n * utils.toNoop(node);\n * // convert `node.nodes` to the given value instead of deleting it\n * utils.toNoop(node, []);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\n * @api public\n */\n\nutils.toNoop = function(node, nodes) {\n  if (nodes) {\n    node.nodes = nodes;\n  } else {\n    delete node.nodes;\n    node.type = &#039;text&#039;;\n    node.val = &#039;&#039;;\n  }\n};\n\n/**\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\n * automatically calls registered compilers, this allows you to pass a visitor\n * function.\n *\n * ```js\n * snapdragon.compiler.set(&#039;i&#039;, function(node) {\n *   utils.visit(node, function(childNode) {\n *     // do stuff with \&quot;childNode\&quot;\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Object} returns the node after recursively visiting all child nodes.\n * @api public\n */\n\nutils.visit = function(node, fn) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isFunction(fn), &#039;expected a visitor function&#039;);\n  fn(node);\n  return node.nodes ? utils.mapVisit(node, fn) : node;\n};\n\n/**\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\n * [visit](#visit), use this method if you do not want `fn` to be called on\n * the first node.\n *\n * ```js\n * snapdragon.compiler.set(&#039;i&#039;, function(node) {\n *   utils.mapVisit(node, function(childNode) {\n *     // do stuff with \&quot;childNode\&quot;\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Object} `options`\n * @param {Function} `fn`\n * @return {Object} returns the node\n * @api public\n */\n\nutils.mapVisit = function(node, fn) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isArray(node.nodes), &#039;expected node.nodes to be an array&#039;);\n  assert(isFunction(fn), &#039;expected a visitor function&#039;);\n\n  for (var i = 0; i &lt; node.nodes.length; i++) {\n    utils.visit(node.nodes[i], fn);\n  }\n  return node;\n};\n\n/**\n * Unshift an `*.open` node onto `node.nodes`.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * snapdragon.parser.set(&#039;brace&#039;, function(node) {\n *   var match = this.match(/^{/);\n *   if (match) {\n *     var parent = new Node({type: &#039;brace&#039;});\n *     utils.addOpen(parent, Node);\n *     console.log(parent.nodes[0]):\n *     // { type: &#039;brace.open&#039;, val: &#039;&#039; };\n *\n *     // push the parent \&quot;brace\&quot; node onto the stack\n *     this.push(parent);\n *\n *     // return the parent node, so it&#039;s also added to the AST\n *     return brace;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created opening node.\n * @api public\n */\n\nutils.addOpen = function(node, Node, val, filter) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isFunction(Node), &#039;expected Node to be a constructor function&#039;);\n\n  if (typeof val === &#039;function&#039;) {\n    filter = val;\n    val = &#039;&#039;;\n  }\n\n  if (typeof filter === &#039;function&#039; &amp;&amp; !filter(node)) return;\n  var open = new Node({ type: node.type + &#039;.open&#039;, val: val});\n  var unshift = node.unshift || node.unshiftNode;\n  if (typeof unshift === &#039;function&#039;) {\n    unshift.call(node, open);\n  } else {\n    utils.unshiftNode(node, open);\n  }\n  return open;\n};\n\n/**\n * Push a `*.close` node onto `node.nodes`.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * snapdragon.parser.set(&#039;brace&#039;, function(node) {\n *   var match = this.match(/^}/);\n *   if (match) {\n *     var parent = this.parent();\n *     if (parent.type !== &#039;brace&#039;) {\n *       throw new Error(&#039;missing opening: &#039; + &#039;}&#039;);\n *     }\n *\n *     utils.addClose(parent, Node);\n *     console.log(parent.nodes[parent.nodes.length - 1]):\n *     // { type: &#039;brace.close&#039;, val: &#039;&#039; };\n *\n *     // no need to return a node, since the parent\n *     // was already added to the AST\n *     return;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created closing node.\n * @api public\n */\n\nutils.addClose = function(node, Node, val, filter) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isFunction(Node), &#039;expected Node to be a constructor function&#039;);\n\n  if (typeof val === &#039;function&#039;) {\n    filter = val;\n    val = &#039;&#039;;\n  }\n\n  if (typeof filter === &#039;function&#039; &amp;&amp; !filter(node)) return;\n  var close = new Node({ type: node.type + &#039;.close&#039;, val: val});\n  var push = node.push || node.pushNode;\n  if (typeof push === &#039;function&#039;) {\n    push.call(node, close);\n  } else {\n    utils.pushNode(node, close);\n  }\n  return close;\n};\n\n/**\n * Wraps the given `node` with `*.open` and `*.close` nodes.\n *\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the node\n * @api public\n */\n\nutils.wrapNodes = function(node, Node, filter) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isFunction(Node), &#039;expected Node to be a constructor function&#039;);\n\n  utils.addOpen(node, Node, filter);\n  utils.addClose(node, Node, filter);\n  return node;\n};\n\n/**\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: &#039;foo&#039;});\n * var node = new Node({type: &#039;bar&#039;});\n * utils.pushNode(parent, node);\n * console.log(parent.nodes[0].type) // &#039;bar&#039;\n * console.log(node.parent.type) // &#039;foo&#039;\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object} Returns the child node\n * @api public\n */\n\nutils.pushNode = function(parent, node) {\n  assert(utils.isNode(parent), &#039;expected parent node to be an instance of Node&#039;);\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n\n  node.define(&#039;parent&#039;, parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.push(node);\n  return node;\n};\n\n/**\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: &#039;foo&#039;});\n * var node = new Node({type: &#039;bar&#039;});\n * utils.unshiftNode(parent, node);\n * console.log(parent.nodes[0].type) // &#039;bar&#039;\n * console.log(node.parent.type) // &#039;foo&#039;\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {undefined}\n * @api public\n */\n\nutils.unshiftNode = function(parent, node) {\n  assert(utils.isNode(parent), &#039;expected parent node to be an instance of Node&#039;);\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n\n  node.define(&#039;parent&#039;, parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.unshift(node);\n};\n\n/**\n * Pop the last `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: &#039;foo&#039;});\n * utils.pushNode(parent, new Node({type: &#039;foo&#039;}));\n * utils.pushNode(parent, new Node({type: &#039;bar&#039;}));\n * utils.pushNode(parent, new Node({type: &#039;baz&#039;}));\n * console.log(parent.nodes.length); //=&gt; 3\n * utils.popNode(parent);\n * console.log(parent.nodes.length); //=&gt; 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.popNode = function(node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  if (typeof node.pop === &#039;function&#039;) {\n    return node.pop();\n  }\n  return node.nodes &amp;&amp; node.nodes.pop();\n};\n\n/**\n * Shift the first `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: &#039;foo&#039;});\n * utils.pushNode(parent, new Node({type: &#039;foo&#039;}));\n * utils.pushNode(parent, new Node({type: &#039;bar&#039;}));\n * utils.pushNode(parent, new Node({type: &#039;baz&#039;}));\n * console.log(parent.nodes.length); //=&gt; 3\n * utils.shiftNode(parent);\n * console.log(parent.nodes.length); //=&gt; 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.shiftNode = function(node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  if (typeof node.shift === &#039;function&#039;) {\n    return node.shift();\n  }\n  return node.nodes &amp;&amp; node.nodes.shift();\n};\n\n/**\n * Remove the specified `node` from `parent.nodes`.\n *\n * ```js\n * var parent = new Node({type: &#039;abc&#039;});\n * var foo = new Node({type: &#039;foo&#039;});\n * utils.pushNode(parent, foo);\n * utils.pushNode(parent, new Node({type: &#039;bar&#039;}));\n * utils.pushNode(parent, new Node({type: &#039;baz&#039;}));\n * console.log(parent.nodes.length); //=&gt; 3\n * utils.removeNode(parent, foo);\n * console.log(parent.nodes.length); //=&gt; 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\n * @api public\n */\n\nutils.removeNode = function(parent, node) {\n  assert(utils.isNode(parent), &#039;expected parent.node to be an instance of Node&#039;);\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n\n  if (!parent.nodes) {\n    return null;\n  }\n\n  if (typeof parent.remove === &#039;function&#039;) {\n    return parent.remove(node);\n  }\n\n  var idx = parent.nodes.indexOf(node);\n  if (idx !== -1) {\n    return parent.nodes.splice(idx, 1);\n  }\n};\n\n/**\n * Returns true if `node.type` matches the given `type`. Throws a\n * `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var node = new Node({type: &#039;foo&#039;});\n * console.log(utils.isType(node, &#039;foo&#039;)); // false\n * console.log(utils.isType(node, &#039;bar&#039;)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isType = function(node, type) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  switch (typeOf(type)) {\n    case &#039;array&#039;:\n      var types = type.slice();\n      for (var i = 0; i &lt; types.length; i++) {\n        if (utils.isType(node, types[i])) {\n          return true;\n        }\n      }\n      return false;\n    case &#039;string&#039;:\n      return node.type === type;\n    case &#039;regexp&#039;:\n      return type.test(node.type);\n    default: {\n      throw new TypeError(&#039;expected \&quot;type\&quot; to be an array, string or regexp&#039;);\n    }\n  }\n};\n\n/**\n * Returns true if the given `node` has the given `type` in `node.nodes`.\n * Throws a `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var node = new Node({\n *   type: &#039;foo&#039;,\n *   nodes: [\n *     new Node({type: &#039;bar&#039;}),\n *     new Node({type: &#039;baz&#039;})\n *   ]\n * });\n * console.log(utils.hasType(node, &#039;xyz&#039;)); // false\n * console.log(utils.hasType(node, &#039;baz&#039;)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.hasType = function(node, type) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  if (!Array.isArray(node.nodes)) return false;\n  for (var i = 0; i &lt; node.nodes.length; i++) {\n    if (utils.isType(node.nodes[i], type)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns the first node from `node.nodes` of the given `type`\n *\n * ```js\n * var node = new Node({\n *   type: &#039;foo&#039;,\n *   nodes: [\n *     new Node({type: &#039;text&#039;, val: &#039;abc&#039;}),\n *     new Node({type: &#039;text&#039;, val: &#039;xyz&#039;})\n *   ]\n * });\n *\n * var textNode = utils.firstOfType(node.nodes, &#039;text&#039;);\n * console.log(textNode.val);\n * //=&gt; &#039;abc&#039;\n * ```\n * @param {Array} `nodes`\n * @param {String} `type`\n * @return {Object|undefined} Returns the first matching node or undefined.\n * @api public\n */\n\nutils.firstOfType = function(nodes, type) {\n  for (var i = 0; i &lt; nodes.length; i++) {\n    var node = nodes[i];\n    if (utils.isType(node, type)) {\n      return node;\n    }\n  }\n};\n\n/**\n * Returns the node at the specified index, or the first node of the\n * given `type` from `node.nodes`.\n *\n * ```js\n * var node = new Node({\n *   type: &#039;foo&#039;,\n *   nodes: [\n *     new Node({type: &#039;text&#039;, val: &#039;abc&#039;}),\n *     new Node({type: &#039;text&#039;, val: &#039;xyz&#039;})\n *   ]\n * });\n *\n * var nodeOne = utils.findNode(node.nodes, &#039;text&#039;);\n * console.log(nodeOne.val);\n * //=&gt; &#039;abc&#039;\n *\n * var nodeTwo = utils.findNode(node.nodes, 1);\n * console.log(nodeTwo.val);\n * //=&gt; &#039;xyz&#039;\n * ```\n *\n * @param {Array} `nodes`\n * @param {String|Number} `type` Node type or index.\n * @return {Object} Returns a node or undefined.\n * @api public\n */\n\nutils.findNode = function(nodes, type) {\n  if (!Array.isArray(nodes)) {\n    return null;\n  }\n  if (typeof type === &#039;number&#039;) {\n    return nodes[type];\n  }\n  return utils.firstOfType(nodes, type);\n};\n\n/**\n * Returns true if the given node is an \&quot;*.open\&quot; node.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var brace = new Node({type: &#039;brace&#039;});\n * var open = new Node({type: &#039;brace.open&#039;});\n * var close = new Node({type: &#039;brace.close&#039;});\n *\n * console.log(utils.isOpen(brace)); // false\n * console.log(utils.isOpen(open)); // true\n * console.log(utils.isOpen(close)); // false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isOpen = function(node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  return node.type.slice(-5) === &#039;.open&#039;;\n};\n\n/**\n * Returns true if the given node is a \&quot;*.close\&quot; node.\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var brace = new Node({type: &#039;brace&#039;});\n * var open = new Node({type: &#039;brace.open&#039;});\n * var close = new Node({type: &#039;brace.close&#039;});\n *\n * console.log(utils.isClose(brace)); // false\n * console.log(utils.isClose(open)); // false\n * console.log(utils.isClose(close)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isClose = function(node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  return node.type.slice(-6) === &#039;.close&#039;;\n};\n\n/**\n * Returns true if `node.nodes` **has** an `.open` node\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var brace = new Node({\n *   type: &#039;brace&#039;,\n *   nodes: []\n * });\n *\n * var open = new Node({type: &#039;brace.open&#039;});\n * console.log(utils.hasOpen(brace)); // false\n *\n * brace.pushNode(open);\n * console.log(utils.hasOpen(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpen = function(node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  var first = node.first || node.nodes ? node.nodes[0] : null;\n  if (utils.isNode(first)) {\n    return first.type === node.type + &#039;.open&#039;;\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` **has** a `.close` node\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var brace = new Node({\n *   type: &#039;brace&#039;,\n *   nodes: []\n * });\n *\n * var close = new Node({type: &#039;brace.close&#039;});\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(close);\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasClose = function(node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\n  if (utils.isNode(last)) {\n    return last.type === node.type + &#039;.close&#039;;\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\n *\n * ```js\n * var Node = require(&#039;snapdragon-node&#039;);\n * var brace = new Node({\n *   type: &#039;brace&#039;,\n *   nodes: []\n * });\n *\n * var open = new Node({type: &#039;brace.open&#039;});\n * var close = new Node({type: &#039;brace.close&#039;});\n * console.log(utils.hasOpen(brace)); // false\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(open);\n * brace.pushNode(close);\n * console.log(utils.hasOpen(brace)); // true\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpenAndClose = function(node) {\n  return utils.hasOpen(node) &amp;&amp; utils.hasClose(node);\n};\n\n/**\n * Push the given `node` onto the `state.inside` array for the\n * given type. This array is used as a specialized \&quot;stack\&quot; for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: &#039;brace&#039;});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=&gt; { brace: [{type: &#039;brace&#039;}] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.addType = function(state, node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isObject(state), &#039;expected state to be an object&#039;);\n\n  var type = node.parent\n    ? node.parent.type\n    : node.type.replace(/\\.open$/, &#039;&#039;);\n\n  if (!state.hasOwnProperty(&#039;inside&#039;)) {\n    state.inside = {};\n  }\n  if (!state.inside.hasOwnProperty(type)) {\n    state.inside[type] = [];\n  }\n\n  var arr = state.inside[type];\n  arr.push(node);\n  return arr;\n};\n\n/**\n * Remove the given `node` from the `state.inside` array for the\n * given type. This array is used as a specialized \&quot;stack\&quot; for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: &#039;brace&#039;});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=&gt; { brace: [{type: &#039;brace&#039;}] }\n * utils.removeType(state, node);\n * //=&gt; { brace: [] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.removeType = function(state, node) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isObject(state), &#039;expected state to be an object&#039;);\n\n  var type = node.parent\n    ? node.parent.type\n    : node.type.replace(/\\.close$/, &#039;&#039;);\n\n  if (state.inside.hasOwnProperty(type)) {\n    return state.inside[type].pop();\n  }\n};\n\n/**\n * Returns true if `node.val` is an empty string, or `node.nodes` does\n * not contain any non-empty text nodes.\n *\n * ```js\n * var node = new Node({type: &#039;text&#039;});\n * utils.isEmpty(node); //=&gt; true\n * node.val = &#039;foo&#039;;\n * utils.isEmpty(node); //=&gt; false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Boolean}\n * @api public\n */\n\nutils.isEmpty = function(node, fn) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n\n  if (!Array.isArray(node.nodes)) {\n    if (node.type !== &#039;text&#039;) {\n      return true;\n    }\n    if (typeof fn === &#039;function&#039;) {\n      return fn(node, node.parent);\n    }\n    return !utils.trim(node.val);\n  }\n\n  for (var i = 0; i &lt; node.nodes.length; i++) {\n    var child = node.nodes[i];\n    if (utils.isOpen(child) || utils.isClose(child)) {\n      continue;\n    }\n    if (!utils.isEmpty(child, fn)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if the `state.inside` stack for the given type exists\n * and has one or more nodes on it.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: &#039;brace&#039;});\n * console.log(utils.isInsideType(state, &#039;brace&#039;)); //=&gt; false\n * utils.addType(state, node);\n * console.log(utils.isInsideType(state, &#039;brace&#039;)); //=&gt; true\n * utils.removeType(state, node);\n * console.log(utils.isInsideType(state, &#039;brace&#039;)); //=&gt; false\n * ```\n * @param {Object} `state`\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isInsideType = function(state, type) {\n  assert(isObject(state), &#039;expected state to be an object&#039;);\n  assert(isString(type), &#039;expected type to be a string&#039;);\n\n  if (!state.hasOwnProperty(&#039;inside&#039;)) {\n    return false;\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    return false;\n  }\n\n  return state.inside[type].length &gt; 0;\n};\n\n/**\n * Returns true if `node` is either a child or grand-child of the given `type`,\n * or `state.inside[type]` is a non-empty array.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: &#039;brace&#039;});\n * var open = new Node({type: &#039;brace.open&#039;});\n * console.log(utils.isInside(state, open, &#039;brace&#039;)); //=&gt; false\n * utils.pushNode(node, open);\n * console.log(utils.isInside(state, open, &#039;brace&#039;)); //=&gt; true\n * ```\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type` The `node.type` to check for.\n * @return {Boolean}\n * @api public\n */\n\nutils.isInside = function(state, node, type) {\n  assert(utils.isNode(node), &#039;expected node to be an instance of Node&#039;);\n  assert(isObject(state), &#039;expected state to be an object&#039;);\n\n  if (Array.isArray(type)) {\n    for (var i = 0; i &lt; type.length; i++) {\n      if (utils.isInside(state, node, type[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var parent = node.parent;\n  if (typeof type === &#039;string&#039;) {\n    return (parent &amp;&amp; parent.type === type) || utils.isInsideType(state, type);\n  }\n\n  if (typeOf(type) === &#039;regexp&#039;) {\n    if (parent &amp;&amp; parent.type &amp;&amp; type.test(parent.type)) {\n      return true;\n    }\n\n    var keys = Object.keys(state.inside);\n    var len = keys.length;\n    var idx = -1;\n    while (++idx &lt; len) {\n      var key = keys[idx];\n      var val = state.inside[key];\n\n      if (Array.isArray(val) &amp;&amp; val.length !== 0 &amp;&amp; type.test(key)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Get the last `n` element from the given `array`. Used for getting\n * a node from `node.nodes.`\n *\n * @param {Array} `array`\n * @param {Number} `n`\n * @return {undefined}\n * @api public\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Cast the given `val` to an array.\n *\n * ```js\n * console.log(utils.arrayify(&#039;&#039;));\n * //=&gt; []\n * console.log(utils.arrayify(&#039;foo&#039;));\n * //=&gt; [&#039;foo&#039;]\n * console.log(utils.arrayify([&#039;foo&#039;]));\n * //=&gt; [&#039;foo&#039;]\n * ```\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === &#039;string&#039; &amp;&amp; val !== &#039;&#039;) {\n    return [val];\n  }\n  if (!Array.isArray(val)) {\n    return [];\n  }\n  return val;\n};\n\n/**\n * Convert the given `val` to a string by joining with `,`. Useful\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\n *\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.stringify = function(val) {\n  return utils.arrayify(val).join(&#039;,&#039;);\n};\n\n/**\n * Ensure that the given value is a string and call `.trim()` on it,\n * or return an empty string.\n *\n * @param {String} `str`\n * @return {String}\n * @api public\n */\n\nutils.trim = function(str) {\n  return typeof str === &#039;string&#039; ? str.trim() : &#039;&#039;;\n};\n\n/**\n * Return true if val is an object\n */\n\nfunction isObject(val) {\n  return typeOf(val) === &#039;object&#039;;\n}\n\n/**\n * Return true if val is a string\n */\n\nfunction isString(val) {\n  return typeof val === &#039;string&#039;;\n}\n\n/**\n * Return true if val is a function\n */\n\nfunction isFunction(val) {\n  return typeof val === &#039;function&#039;;\n}\n\n/**\n * Return true if val is an array\n */\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Shim to ensure the `.append` methods work with any version of snapdragon\n */\n\nfunction append(compiler, val, node) {\n  if (typeof compiler.append !== &#039;function&#039;) {\n    return compiler.emit(val, node);\n  }\n  return compiler.append(val, node);\n}\n\n/**\n * Simplified assertion. Throws an error is `val` is falsey.\n */\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon-util/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon-util/node_modules/kind-of/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/snapdragon-util/node_modules/kind-of/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon-util/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/index.js&quot;:
/*!******************************************!*\
  !*** ./node_modules/snapdragon/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar Base = __webpack_require__(/*! base */ \&quot;./node_modules/base/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\nvar Compiler = __webpack_require__(/*! ./lib/compiler */ \&quot;./node_modules/snapdragon/lib/compiler.js\&quot;);\nvar Parser = __webpack_require__(/*! ./lib/parser */ \&quot;./node_modules/snapdragon/lib/parser.js\&quot;);\nvar utils = __webpack_require__(/*! ./lib/utils */ \&quot;./node_modules/snapdragon/lib/utils.js\&quot;);\nvar regexCache = {};\nvar cache = {};\n\n/**\n * Create a new instance of `Snapdragon` with the given `options`.\n *\n * ```js\n * var snapdragon = new Snapdragon();\n * ```\n *\n * @param {Object} `options`\n * @api public\n */\n\nfunction Snapdragon(options) {\n  Base.call(this, null, options);\n  this.options = utils.extend({source: &#039;string&#039;}, this.options);\n  this.compiler = new Compiler(this.options);\n  this.parser = new Parser(this.options);\n\n  Object.defineProperty(this, &#039;compilers&#039;, {\n    get: function() {\n      return this.compiler.compilers;\n    }\n  });\n\n  Object.defineProperty(this, &#039;parsers&#039;, {\n    get: function() {\n      return this.parser.parsers;\n    }\n  });\n\n  Object.defineProperty(this, &#039;regex&#039;, {\n    get: function() {\n      return this.parser.regex;\n    }\n  });\n}\n\n/**\n * Inherit Base\n */\n\nBase.extend(Snapdragon);\n\n/**\n * Add a parser to `snapdragon.parsers` for capturing the given `type` using\n * the specified regex or parser function. A function is useful if you need\n * to customize how the token is created and/or have access to the parser\n * instance to check options, etc.\n *\n * ```js\n * snapdragon\n *   .capture(&#039;slash&#039;, /^\\//)\n *   .capture(&#039;dot&#039;, function() {\n *     var pos = this.position();\n *     var m = this.match(/^\\./);\n *     if (!m) return;\n *     return pos({\n *       type: &#039;dot&#039;,\n *       val: m[0]\n *     });\n *   });\n * ```\n * @param {String} `type`\n * @param {RegExp|Function} `regex`\n * @return {Object} Returns the parser instance for chaining\n * @api public\n */\n\nSnapdragon.prototype.capture = function() {\n  return this.parser.capture.apply(this.parser, arguments);\n};\n\n/**\n * Register a plugin `fn`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * snapdragon.use(function() {\n *   console.log(this);          //&lt;= snapdragon instance\n *   console.log(this.parser);   //&lt;= parser instance\n *   console.log(this.compiler); //&lt;= compiler instance\n * });\n * ```\n * @param {Object} `fn`\n * @api public\n */\n\nSnapdragon.prototype.use = function(fn) {\n  fn.call(this, this);\n  return this;\n};\n\n/**\n * Parse the given `str`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * // register parsers\n * snapdragon.parser.use(function() {});\n *\n * // parse\n * var ast = snapdragon.parse(&#039;foo/bar&#039;);\n * console.log(ast);\n * ```\n * @param {String} `str`\n * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.\n * @return {Object} Returns an AST.\n * @api public\n */\n\nSnapdragon.prototype.parse = function(str, options) {\n  this.options = utils.extend({}, this.options, options);\n  var parsed = this.parser.parse(str, this.options);\n\n  // add non-enumerable parser reference\n  define(parsed, &#039;parser&#039;, this.parser);\n  return parsed;\n};\n\n/**\n * Compile the given `AST`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * // register plugins\n * snapdragon.use(function() {});\n * // register parser plugins\n * snapdragon.parser.use(function() {});\n * // register compiler plugins\n * snapdragon.compiler.use(function() {});\n *\n * // parse\n * var ast = snapdragon.parse(&#039;foo/bar&#039;);\n *\n * // compile\n * var res = snapdragon.compile(ast);\n * console.log(res.output);\n * ```\n * @param {Object} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object with an `output` property with the rendered string.\n * @api public\n */\n\nSnapdragon.prototype.compile = function(ast, options) {\n  this.options = utils.extend({}, this.options, options);\n  var compiled = this.compiler.compile(ast, this.options);\n\n  // add non-enumerable compiler reference\n  define(compiled, &#039;compiler&#039;, this.compiler);\n  return compiled;\n};\n\n/**\n * Expose `Snapdragon`\n */\n\nmodule.exports = Snapdragon;\n\n/**\n * Expose `Parser` and `Compiler`\n */\n\nmodule.exports.Compiler = Compiler;\nmodule.exports.Parser = Parser;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/lib/compiler.js&quot;:
/*!*************************************************!*\
  !*** ./node_modules/snapdragon/lib/compiler.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar use = __webpack_require__(/*! use */ \&quot;./node_modules/use/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\nvar debug = __webpack_require__(/*! debug */ \&quot;./node_modules/debug/src/index.js\&quot;)(&#039;snapdragon:compiler&#039;);\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/snapdragon/lib/utils.js\&quot;);\n\n/**\n * Create a new `Compiler` with the given `options`.\n * @param {Object} `options`\n */\n\nfunction Compiler(options, state) {\n  debug(&#039;initializing&#039;, __filename);\n  this.options = utils.extend({source: &#039;string&#039;}, options);\n  this.state = state || {};\n  this.compilers = {};\n  this.output = &#039;&#039;;\n  this.set(&#039;eos&#039;, function(node) {\n    return this.emit(node.val, node);\n  });\n  this.set(&#039;noop&#039;, function(node) {\n    return this.emit(node.val, node);\n  });\n  this.set(&#039;bos&#039;, function(node) {\n    return this.emit(node.val, node);\n  });\n  use(this);\n}\n\n/**\n * Prototype methods\n */\n\nCompiler.prototype = {\n\n  /**\n   * Throw an error message with details including the cursor position.\n   * @param {String} `msg` Message to use in the Error.\n   */\n\n  error: function(msg, node) {\n    var pos = node.position || {start: {column: 0}};\n    var message = this.options.source + &#039; column:&#039; + pos.start.column + &#039;: &#039; + msg;\n\n    var err = new Error(message);\n    err.reason = msg;\n    err.column = pos.start.column;\n    err.source = this.pattern;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\n   * Define a non-enumberable property on the `Compiler` instance.\n   *\n   * ```js\n   * compiler.define(&#039;foo&#039;, &#039;bar&#039;);\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Compiler instance for chaining.\n   * @api public\n   */\n\n  define: function(key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\n   * Emit `node.val`\n   */\n\n  emit: function(str, node) {\n    this.output += str;\n    return str;\n  },\n\n  /**\n   * Add a compiler `fn` with the given `name`\n   */\n\n  set: function(name, fn) {\n    this.compilers[name] = fn;\n    return this;\n  },\n\n  /**\n   * Get compiler `name`.\n   */\n\n  get: function(name) {\n    return this.compilers[name];\n  },\n\n  /**\n   * Get the previous AST node.\n   */\n\n  prev: function(n) {\n    return this.ast.nodes[this.idx - (n || 1)] || { type: &#039;bos&#039;, val: &#039;&#039; };\n  },\n\n  /**\n   * Get the next AST node.\n   */\n\n  next: function(n) {\n    return this.ast.nodes[this.idx + (n || 1)] || { type: &#039;eos&#039;, val: &#039;&#039; };\n  },\n\n  /**\n   * Visit `node`.\n   */\n\n  visit: function(node, nodes, i) {\n    var fn = this.compilers[node.type];\n    this.idx = i;\n\n    if (typeof fn !== &#039;function&#039;) {\n      throw this.error(&#039;compiler \&quot;&#039; + node.type + &#039;\&quot; is not registered&#039;, node);\n    }\n    return fn.call(this, node, nodes, i);\n  },\n\n  /**\n   * Map visit over array of `nodes`.\n   */\n\n  mapVisit: function(nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError(&#039;expected an array&#039;);\n    }\n    var len = nodes.length;\n    var idx = -1;\n    while (++idx &lt; len) {\n      this.visit(nodes[idx], nodes, idx);\n    }\n    return this;\n  },\n\n  /**\n   * Compile `ast`.\n   */\n\n  compile: function(ast, options) {\n    var opts = utils.extend({}, this.options, options);\n    this.ast = ast;\n    this.parsingErrors = this.ast.errors;\n    this.output = &#039;&#039;;\n\n    // source map support\n    if (opts.sourcemap) {\n      var sourcemaps = __webpack_require__(/*! ./source-maps */ \&quot;./node_modules/snapdragon/lib/source-maps.js\&quot;);\n      sourcemaps(this);\n      this.mapVisit(this.ast.nodes);\n      this.applySourceMaps();\n      this.map = opts.sourcemap === &#039;generator&#039; ? this.map : this.map.toJSON();\n      return this;\n    }\n\n    this.mapVisit(this.ast.nodes);\n    return this;\n  }\n};\n\n/**\n * Expose `Compiler`\n */\n\nmodule.exports = Compiler;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/lib/compiler.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/lib/parser.js&quot;:
/*!***********************************************!*\
  !*** ./node_modules/snapdragon/lib/parser.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar use = __webpack_require__(/*! use */ \&quot;./node_modules/use/index.js\&quot;);\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\nvar Cache = __webpack_require__(/*! map-cache */ \&quot;./node_modules/map-cache/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\nvar debug = __webpack_require__(/*! debug */ \&quot;./node_modules/debug/src/index.js\&quot;)(&#039;snapdragon:parser&#039;);\nvar Position = __webpack_require__(/*! ./position */ \&quot;./node_modules/snapdragon/lib/position.js\&quot;);\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/snapdragon/lib/utils.js\&quot;);\n\n/**\n * Create a new `Parser` with the given `input` and `options`.\n * @param {String} `input`\n * @param {Object} `options`\n * @api public\n */\n\nfunction Parser(options) {\n  debug(&#039;initializing&#039;, __filename);\n  this.options = utils.extend({source: &#039;string&#039;}, options);\n  this.init(this.options);\n  use(this);\n}\n\n/**\n * Prototype methods\n */\n\nParser.prototype = {\n  constructor: Parser,\n\n  init: function(options) {\n    this.orig = &#039;&#039;;\n    this.input = &#039;&#039;;\n    this.parsed = &#039;&#039;;\n\n    this.column = 1;\n    this.line = 1;\n\n    this.regex = new Cache();\n    this.errors = this.errors || [];\n    this.parsers = this.parsers || {};\n    this.types = this.types || [];\n    this.sets = this.sets || {};\n    this.fns = this.fns || [];\n    this.currentType = &#039;root&#039;;\n\n    var pos = this.position();\n    this.bos = pos({type: &#039;bos&#039;, val: &#039;&#039;});\n\n    this.ast = {\n      type: &#039;root&#039;,\n      errors: this.errors,\n      nodes: [this.bos]\n    };\n\n    define(this.bos, &#039;parent&#039;, this.ast);\n    this.nodes = [this.ast];\n\n    this.count = 0;\n    this.setCount = 0;\n    this.stack = [];\n  },\n\n  /**\n   * Throw a formatted error with the cursor column and `msg`.\n   * @param {String} `msg` Message to use in the Error.\n   */\n\n  error: function(msg, node) {\n    var pos = node.position || {start: {column: 0, line: 0}};\n    var line = pos.start.line;\n    var column = pos.start.column;\n    var source = this.options.source;\n\n    var message = source + &#039; &lt;line:&#039; + line + &#039; column:&#039; + column + &#039;&gt;: &#039; + msg;\n    var err = new Error(message);\n    err.source = source;\n    err.reason = msg;\n    err.pos = pos;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\n   * Define a non-enumberable property on the `Parser` instance.\n   *\n   * ```js\n   * parser.define(&#039;foo&#039;, &#039;bar&#039;);\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Parser instance for chaining.\n   * @api public\n   */\n\n  define: function(key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  position: function() {\n    var start = { line: this.line, column: this.column };\n    var self = this;\n\n    return function(node) {\n      define(node, &#039;position&#039;, new Position(start, self));\n      return node;\n    };\n  },\n\n  /**\n   * Set parser `name` with the given `fn`\n   * @param {String} `name`\n   * @param {Function} `fn`\n   * @api public\n   */\n\n  set: function(type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n    this.parsers[type] = fn.bind(this);\n    return this;\n  },\n\n  /**\n   * Get parser `name`\n   * @param {String} `name`\n   * @api public\n   */\n\n  get: function(name) {\n    return this.parsers[name];\n  },\n\n  /**\n   * Push a `token` onto the `type` stack.\n   *\n   * @param {String} `type`\n   * @return {Object} `token`\n   * @api public\n   */\n\n  push: function(type, token) {\n    this.sets[type] = this.sets[type] || [];\n    this.count++;\n    this.stack.push(token);\n    return this.sets[type].push(token);\n  },\n\n  /**\n   * Pop a token off of the `type` stack\n   * @param {String} `type`\n   * @returns {Object} Returns a token\n   * @api public\n   */\n\n  pop: function(type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  },\n\n  /**\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\n   *\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isInside: function(type) {\n    this.sets[type] = this.sets[type] || [];\n    return this.sets[type].length &gt; 0;\n  },\n\n  /**\n   * Return true if `node` is the given `type`.\n   *\n   * ```js\n   * parser.isType(node, &#039;brace&#039;);\n   * ```\n   * @param {Object} `node`\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isType: function(node, type) {\n    return node &amp;&amp; node.type === type;\n  },\n\n  /**\n   * Get the previous AST node\n   * @return {Object}\n   */\n\n  prev: function(n) {\n    return this.stack.length &gt; 0\n      ? utils.last(this.stack, n)\n      : utils.last(this.nodes, n);\n  },\n\n  /**\n   * Update line and column based on `str`.\n   */\n\n  consume: function(len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Update column based on `str`.\n   */\n\n  updatePosition: function(str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf(&#039;\\n&#039;);\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  },\n\n  /**\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\n   * @param {RegExp} `regex`\n   * @return {Object}\n   */\n\n  match: function(regex) {\n    var m = regex.exec(this.input);\n    if (m) {\n      this.updatePosition(m[0], m[0].length);\n      return m;\n    }\n  },\n\n  /**\n   * Capture `type` with the given regex.\n   * @param {String} `type`\n   * @param {RegExp} `regex`\n   * @return {Function}\n   */\n\n  capture: function(type, regex) {\n    if (typeof regex === &#039;function&#039;) {\n      return this.set.apply(this, arguments);\n    }\n\n    this.regex.set(type, regex);\n    this.set(type, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(regex);\n      if (!m || !m[0]) return;\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        val: m[0],\n        parsed: parsed,\n        rest: this.input\n      });\n\n      if (m[1]) {\n        node.inner = m[1];\n      }\n\n      define(node, &#039;inside&#039;, this.stack.length &gt; 0);\n      define(node, &#039;parent&#039;, prev);\n      prev.nodes.push(node);\n    }.bind(this));\n    return this;\n  },\n\n  /**\n   * Create a parser with open and close for parens,\n   * brackets or braces\n   */\n\n  capturePair: function(type, openRegex, closeRegex, fn) {\n    this.sets[type] = this.sets[type] || [];\n\n    /**\n     * Open\n     */\n\n    this.set(type + &#039;.open&#039;, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(openRegex);\n      if (!m || !m[0]) return;\n\n      var val = m[0];\n      this.setCount++;\n      this.specialChars = true;\n      var open = pos({\n        type: type + &#039;.open&#039;,\n        val: val,\n        rest: this.input\n      });\n\n      if (typeof m[1] !== &#039;undefined&#039;) {\n        open.inner = m[1];\n      }\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        nodes: [open]\n      });\n\n      define(node, &#039;rest&#039;, this.input);\n      define(node, &#039;parsed&#039;, parsed);\n      define(node, &#039;prefix&#039;, m[1]);\n      define(node, &#039;parent&#039;, prev);\n      define(open, &#039;parent&#039;, node);\n\n      if (typeof fn === &#039;function&#039;) {\n        fn.call(this, open, node);\n      }\n\n      this.push(type, node);\n      prev.nodes.push(node);\n    });\n\n    /**\n     * Close\n     */\n\n    this.set(type + &#039;.close&#039;, function() {\n      var pos = this.position();\n      var m = this.match(closeRegex);\n      if (!m || !m[0]) return;\n\n      var parent = this.pop(type);\n      var node = pos({\n        type: type + &#039;.close&#039;,\n        rest: this.input,\n        suffix: m[1],\n        val: m[0]\n      });\n\n      if (!this.isType(parent, type)) {\n        if (this.options.strict) {\n          throw new Error(&#039;missing opening \&quot;&#039; + type + &#039;\&quot;&#039;);\n        }\n\n        this.setCount--;\n        node.escaped = true;\n        return node;\n      }\n\n      if (node.suffix === &#039;\\\\&#039;) {\n        parent.escaped = true;\n        node.escaped = true;\n      }\n\n      parent.nodes.push(node);\n      define(node, &#039;parent&#039;, parent);\n    });\n\n    return this;\n  },\n\n  /**\n   * Capture end-of-string\n   */\n\n  eos: function() {\n    var pos = this.position();\n    if (this.input) return;\n    var prev = this.prev();\n\n    while (prev.type !== &#039;root&#039; &amp;&amp; !prev.visited) {\n      if (this.options.strict === true) {\n        throw new SyntaxError(&#039;invalid syntax:&#039; + util.inspect(prev, null, 2));\n      }\n\n      if (!hasDelims(prev)) {\n        prev.parent.escaped = true;\n        prev.escaped = true;\n      }\n\n      visit(prev, function(node) {\n        if (!hasDelims(node.parent)) {\n          node.parent.escaped = true;\n          node.escaped = true;\n        }\n      });\n\n      prev = prev.parent;\n    }\n\n    var tok = pos({\n      type: &#039;eos&#039;,\n      val: this.append || &#039;&#039;\n    });\n\n    define(tok, &#039;parent&#039;, this.ast);\n    return tok;\n  },\n\n  /**\n   * Run parsers to advance the cursor position\n   */\n\n  next: function() {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx &lt; len) {\n      if ((tok = this.parsers[this.types[idx]].call(this))) {\n        define(tok, &#039;rest&#039;, this.input);\n        define(tok, &#039;parsed&#039;, parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Parse the given string.\n   * @return {Array}\n   */\n\n  parse: function(input) {\n    if (typeof input !== &#039;string&#039;) {\n      throw new TypeError(&#039;expected a string&#039;);\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input;\n\n      // get the next AST ndoe\n      var node = self.next();\n      if (node) {\n        var prev = self.prev();\n        if (prev) {\n          define(node, &#039;parent&#039;, prev);\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      }\n\n      // if we got here but input is not changed, throw an error\n      if (self.input &amp;&amp; input === self.input) {\n        throw new Error(&#039;no parsers registered for: \&quot;&#039; + self.input.slice(0, 5) + &#039;\&quot;&#039;);\n      }\n    }\n\n    while (this.input) parse();\n    if (this.stack.length &amp;&amp; this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error(&#039;missing opening &#039; + node.type + &#039;: \&quot;&#039; + this.orig + &#039;\&quot;&#039;);\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n    if (tok.type !== &#039;eos&#039;) {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }\n};\n\n/**\n * Visit `node` with the given `fn`\n */\n\nfunction visit(node, fn) {\n  if (!node.visited) {\n    define(node, &#039;visited&#039;, true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  return node;\n}\n\n/**\n * Map visit over array of `nodes`.\n */\n\nfunction mapVisit(nodes, fn) {\n  var len = nodes.length;\n  var idx = -1;\n  while (++idx &lt; len) {\n    visit(nodes[idx], fn);\n  }\n}\n\nfunction hasOpen(node) {\n  return node.nodes &amp;&amp; node.nodes[0].type === (node.type + &#039;.open&#039;);\n}\n\nfunction hasClose(node) {\n  return node.nodes &amp;&amp; utils.last(node.nodes).type === (node.type + &#039;.close&#039;);\n}\n\nfunction hasDelims(node) {\n  return hasOpen(node) &amp;&amp; hasClose(node);\n}\n\n/**\n * Expose `Parser`\n */\n\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/lib/parser.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/lib/position.js&quot;:
/*!*************************************************!*\
  !*** ./node_modules/snapdragon/lib/position.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\n\n/**\n * Store position for a node\n */\n\nmodule.exports = function Position(start, parser) {\n  this.start = start;\n  this.end = { line: parser.line, column: parser.column };\n  define(this, &#039;content&#039;, parser.orig);\n  define(this, &#039;source&#039;, parser.options.source);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/lib/position.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/lib/source-maps.js&quot;:
/*!****************************************************!*\
  !*** ./node_modules/snapdragon/lib/source-maps.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar fs = __webpack_require__(/*! fs */ \&quot;fs\&quot;);\nvar path = __webpack_require__(/*! path */ \&quot;path\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\nvar utils = __webpack_require__(/*! ./utils */ \&quot;./node_modules/snapdragon/lib/utils.js\&quot;);\n\n/**\n * Expose `mixin()`.\n * This code is based on `source-maps-support.js` in reworkcss/css\n * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js\n * Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\n */\n\nmodule.exports = mixin;\n\n/**\n * Mixin source map support into `compiler`.\n *\n * @param {Object} `compiler`\n * @api public\n */\n\nfunction mixin(compiler) {\n  define(compiler, &#039;_comment&#039;, compiler.comment);\n  compiler.map = new utils.SourceMap.SourceMapGenerator();\n  compiler.position = { line: 1, column: 1 };\n  compiler.content = {};\n  compiler.files = {};\n\n  for (var key in exports) {\n    define(compiler, key, exports[key]);\n  }\n}\n\n/**\n * Update position.\n *\n * @param {String} str\n */\n\nexports.updatePosition = function(str) {\n  var lines = str.match(/\\n/g);\n  if (lines) this.position.line += lines.length;\n  var i = str.lastIndexOf(&#039;\\n&#039;);\n  this.position.column = ~i ? str.length - i : this.position.column + str.length;\n};\n\n/**\n * Emit `str` with `position`.\n *\n * @param {String} str\n * @param {Object} [pos]\n * @return {String}\n */\n\nexports.emit = function(str, node) {\n  var position = node.position || {};\n  var source = position.source;\n  if (source) {\n    if (position.filepath) {\n      source = utils.unixify(position.filepath);\n    }\n\n    this.map.addMapping({\n      source: source,\n      generated: {\n        line: this.position.line,\n        column: Math.max(this.position.column - 1, 0)\n      },\n      original: {\n        line: position.start.line,\n        column: position.start.column - 1\n      }\n    });\n\n    if (position.content) {\n      this.addContent(source, position);\n    }\n    if (position.filepath) {\n      this.addFile(source, position);\n    }\n\n    this.updatePosition(str);\n    this.output += str;\n  }\n  return str;\n};\n\n/**\n * Adds a file to the source map output if it has not already been added\n * @param {String} `file`\n * @param {Object} `pos`\n */\n\nexports.addFile = function(file, position) {\n  if (typeof position.content !== &#039;string&#039;) return;\n  if (Object.prototype.hasOwnProperty.call(this.files, file)) return;\n  this.files[file] = position.content;\n};\n\n/**\n * Adds a content source to the source map output if it has not already been added\n * @param {String} `source`\n * @param {Object} `position`\n */\n\nexports.addContent = function(source, position) {\n  if (typeof position.content !== &#039;string&#039;) return;\n  if (Object.prototype.hasOwnProperty.call(this.content, source)) return;\n  this.map.setSourceContent(source, position.content);\n};\n\n/**\n * Applies any original source maps to the output and embeds the source file\n * contents in the source map.\n */\n\nexports.applySourceMaps = function() {\n  Object.keys(this.files).forEach(function(file) {\n    var content = this.files[file];\n    this.map.setSourceContent(file, content);\n\n    if (this.options.inputSourcemaps === true) {\n      var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);\n      if (originalMap) {\n        var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);\n        var relativeTo = originalMap.sourcesRelativeTo;\n        this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));\n      }\n    }\n  }, this);\n};\n\n/**\n * Process comments, drops sourceMap comments.\n * @param {Object} node\n */\n\nexports.comment = function(node) {\n  if (/^# sourceMappingURL=/.test(node.comment)) {\n    return this.emit(&#039;&#039;, node.position);\n  }\n  return this._comment(node);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/lib/source-maps.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/lib/utils.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/snapdragon/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\n/**\n * Module dependencies\n */\n\nexports.extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/extend-shallow/index.js\&quot;);\nexports.SourceMap = __webpack_require__(/*! source-map */ \&quot;./node_modules/snapdragon/node_modules/source-map/source-map.js\&quot;);\nexports.sourceMapResolve = __webpack_require__(/*! source-map-resolve */ \&quot;./node_modules/source-map-resolve/lib/source-map-resolve-node.js\&quot;);\n\n/**\n * Convert backslash in the given string to forward slashes\n */\n\nexports.unixify = function(fp) {\n  return fp.split(/\\\\+/).join(&#039;/&#039;);\n};\n\n/**\n * Return true if `val` is a non-empty string\n *\n * @param {String} `str`\n * @return {Boolean}\n */\n\nexports.isString = function(str) {\n  return str &amp;&amp; typeof str === &#039;string&#039;;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nexports.arrayify = function(val) {\n  if (typeof val === &#039;string&#039;) return [val];\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Get the last `n` element from the given `array`\n * @param {Array} `array`\n * @return {*}\n */\n\nexports.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/lib/utils.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/array-set.js&quot;:
/*!**************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/array-set.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(/*! ./util */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/util.js\&quot;);\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \&quot;undefined\&quot;;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i &lt; len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx &gt;= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error(&#039;\&quot;&#039; + aStr + &#039;\&quot; is not in the set.&#039;);\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx &gt;= 0 &amp;&amp; aIdx &lt; this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error(&#039;No element indexed by &#039; + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/array-set.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js&quot;:
/*!***************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = __webpack_require__(/*! ./base64 */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/base64.js\&quot;);\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 &lt;&lt; VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue &lt; 0\n    ? ((-aValue) &lt;&lt; 1) + 1\n    : (aValue &lt;&lt; 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue &amp; 1) === 1;\n  var shifted = aValue &gt;&gt; 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \&quot;\&quot;;\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq &amp; VLQ_BASE_MASK;\n    vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;\n    if (vlq &gt; 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq &gt; 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex &gt;= strLen) {\n      throw new Error(\&quot;Expected more digits in base 64 VLQ value.\&quot;);\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\&quot;Invalid base64 digit: \&quot; + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);\n    digit &amp;= VLQ_BASE_MASK;\n    result = result + (digit &lt;&lt; shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/base64.js&quot;:
/*!***********************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/base64.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = &#039;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#039;.split(&#039;&#039;);\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 &lt;= number &amp;&amp; number &lt; intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\&quot;Must be between 0 and 63: \&quot; + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // &#039;A&#039;\n  var bigZ = 90;     // &#039;Z&#039;\n\n  var littleA = 97;  // &#039;a&#039;\n  var littleZ = 122; // &#039;z&#039;\n\n  var zero = 48;     // &#039;0&#039;\n  var nine = 57;     // &#039;9&#039;\n\n  var plus = 43;     // &#039;+&#039;\n  var slash = 47;    // &#039;/&#039;\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/base64.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/binary-search.js&quot;:
/*!******************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/binary-search.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either &#039;binarySearch.GREATEST_LOWER_BOUND&#039; or\n *     &#039;binarySearch.LEAST_UPPER_BOUND&#039;. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp &gt; 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid &gt; 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh &lt; aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow &gt; 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow &lt; 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren&#039;t on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either &#039;binarySearch.GREATEST_LOWER_BOUND&#039; or\n *     &#039;binarySearch.LEAST_UPPER_BOUND&#039;. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to &#039;binarySearch.GREATEST_LOWER_BOUND&#039;.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index &lt; 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 &gt;= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/binary-search.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js&quot;:
/*!*****************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(/*! ./util */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/util.js\&quot;);\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) &lt;= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js&quot;:
/*!***************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don&#039;t self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM&#039;s C++ and\n// JIT&#039;d JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p &lt; r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j &lt; r; j++) {\n      if (comparator(ary[j], pivot) &lt;= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js&quot;:
/*!************************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = __webpack_require__(/*! ./util */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/util.js\&quot;);\nvar binarySearch = __webpack_require__(/*! ./binary-search */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/binary-search.js\&quot;);\nvar ArraySet = __webpack_require__(/*! ./array-set */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/array-set.js\&quot;).ArraySet;\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js\&quot;);\nvar quickSort = __webpack_require__(/*! ./quick-sort */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/quick-sort.js\&quot;).quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === &#039;string&#039;) {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}&#039;/, &#039;&#039;));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map&#039;s \&quot;mappings\&quot; attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, &#039;_generatedMappings&#039;, {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, &#039;_originalMappings&#039;, {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \&quot;;\&quot; || c === \&quot;,\&quot;;\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\&quot;Subclasses must implement _parseMappings\&quot;);\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file&#039;s line/column\n *        order or the original&#039;s source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\&quot;Unknown order of iteration.\&quot;);\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null &amp;&amp; sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, &#039;line&#039;);\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, &#039;source&#039;),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, &#039;column&#039;, 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \&quot;originalLine\&quot;,\n                                  \&quot;originalColumn\&quot;,\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index &gt;= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping &amp;&amp; mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, &#039;generatedLine&#039;, null),\n            column: util.getArg(mapping, &#039;generatedColumn&#039;, null),\n            lastColumn: util.getArg(mapping, &#039;lastGeneratedColumn&#039;, null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &amp;&amp;\n               mapping.originalLine === line &amp;&amp;\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, &#039;generatedLine&#039;, null),\n            column: util.getArg(mapping, &#039;generatedColumn&#039;, null),\n            lastColumn: util.getArg(mapping, &#039;lastGeneratedColumn&#039;, null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \&quot;out.js\&quot;,\n *       sourceRoot : \&quot;\&quot;,\n *       sources: [\&quot;foo.js\&quot;, \&quot;bar.js\&quot;],\n *       names: [\&quot;src\&quot;, \&quot;maps\&quot;, \&quot;are\&quot;, \&quot;fun\&quot;],\n *       mappings: \&quot;AA,AB;;ABCDE;\&quot;\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === &#039;string&#039;) {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}&#039;/, &#039;&#039;));\n  }\n\n  var version = util.getArg(sourceMap, &#039;version&#039;);\n  var sources = util.getArg(sourceMap, &#039;sources&#039;);\n  // Sass 3.3 leaves out the &#039;names&#039; array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, &#039;names&#039;, []);\n  var sourceRoot = util.getArg(sourceMap, &#039;sourceRoot&#039;, null);\n  var sourcesContent = util.getArg(sourceMap, &#039;sourcesContent&#039;, null);\n  var mappings = util.getArg(sourceMap, &#039;mappings&#039;);\n  var file = util.getArg(sourceMap, &#039;file&#039;, null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error(&#039;Unsupported version: &#039; + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \&quot;./foo.js\&quot; instead of\n    // \&quot;foo.js\&quot;.  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i &lt; length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, &#039;sources&#039;, {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index &lt; length) {\n      if (aStr.charAt(index) === &#039;;&#039;) {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === &#039;,&#039;) {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end &lt; length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index &lt; end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error(&#039;Found a source, but no line and column&#039;);\n          }\n\n          if (segment.length === 3) {\n            throw new Error(&#039;Found a source and line, but no column&#039;);\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length &gt; 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length &gt; 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === &#039;number&#039;) {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \&quot;needle\&quot; mapping that\n * we are searching for in the given \&quot;haystack\&quot; of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] &lt;= 0) {\n      throw new TypeError(&#039;Line must be greater than or equal to 1, got &#039;\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] &lt; 0) {\n      throw new TypeError(&#039;Column must be greater than or equal to 0, got &#039;\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index &lt; this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 &lt; this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source&#039;s line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either &#039;SourceMapConsumer.GREATEST_LOWER_BOUND&#039; or\n *     &#039;SourceMapConsumer.LEAST_UPPER_BOUND&#039;. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to &#039;SourceMapConsumer.GREATEST_LOWER_BOUND&#039;.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, &#039;line&#039;),\n      generatedColumn: util.getArg(aArgs, &#039;column&#039;)\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \&quot;generatedLine\&quot;,\n      \&quot;generatedColumn\&quot;,\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, &#039;bias&#039;, SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index &gt;= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, &#039;source&#039;, null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, &#039;name&#039;, null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, &#039;originalLine&#039;, null),\n          column: util.getArg(mapping, &#039;originalColumn&#039;, null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length &gt;= this._sources.size() &amp;&amp;\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        &amp;&amp; (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \&quot;\&quot;);\n      if (url.scheme == \&quot;file\&quot;\n          &amp;&amp; this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \&quot;/\&quot;)\n          &amp;&amp; this._sources.has(\&quot;/\&quot; + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\&quot;/\&quot; + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don&#039;t want to throw if we can&#039;t find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error(&#039;\&quot;&#039; + aSource + &#039;\&quot; is not in the SourceMap.&#039;);\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either &#039;SourceMapConsumer.GREATEST_LOWER_BOUND&#039; or\n *     &#039;SourceMapConsumer.LEAST_UPPER_BOUND&#039;. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to &#039;SourceMapConsumer.GREATEST_LOWER_BOUND&#039;.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, &#039;source&#039;);\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, &#039;line&#039;),\n      originalColumn: util.getArg(aArgs, &#039;column&#039;)\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \&quot;originalLine\&quot;,\n      \&quot;originalColumn\&quot;,\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, &#039;bias&#039;, SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index &gt;= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, &#039;generatedLine&#039;, null),\n          column: util.getArg(mapping, &#039;generatedColumn&#039;, null),\n          lastColumn: util.getArg(mapping, &#039;lastGeneratedColumn&#039;, null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \&quot;indexed\&quot; source maps (i.e. ones with a \&quot;sections\&quot; field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \&quot;sections\&quot; field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \&quot;line\&quot; and \&quot;column\&quot;\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn&#039;t have to be.\n *\n * Instead of the \&quot;map\&quot; field, it&#039;s also possible to have a \&quot;url\&quot; field\n * specifying a URL to retrieve a source map from, but that&#039;s currently\n * unsupported.\n *\n * Here&#039;s an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \&quot;url\&quot; field.\n *\n *  {\n *    version : 3,\n *    file: \&quot;app.js\&quot;,\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \&quot;section.js\&quot;,\n *        sources: [\&quot;foo.js\&quot;, \&quot;bar.js\&quot;],\n *        names: [\&quot;src\&quot;, \&quot;maps\&quot;, \&quot;are\&quot;, \&quot;fun\&quot;],\n *        mappings: \&quot;AAAA,E;;ABCDE;\&quot;\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === &#039;string&#039;) {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}&#039;/, &#039;&#039;));\n  }\n\n  var version = util.getArg(sourceMap, &#039;version&#039;);\n  var sections = util.getArg(sourceMap, &#039;sections&#039;);\n\n  if (version != this._version) {\n    throw new Error(&#039;Unsupported version: &#039; + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error(&#039;Support for url field in sections not implemented.&#039;);\n    }\n    var offset = util.getArg(s, &#039;offset&#039;);\n    var offsetLine = util.getArg(offset, &#039;line&#039;);\n    var offsetColumn = util.getArg(offset, &#039;column&#039;);\n\n    if (offsetLine &lt; lastOffset.line ||\n        (offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {\n      throw new Error(&#039;Section offsets must be ordered and non-overlapping.&#039;);\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, &#039;map&#039;))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, &#039;sources&#039;, {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i &lt; this._sections.length; i++) {\n      for (var j = 0; j &lt; this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source&#039;s line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, &#039;line&#039;),\n      generatedColumn: util.getArg(aArgs, &#039;column&#039;)\n    };\n\n    // Find the section containing the generated position we&#039;re trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i &lt; this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error(&#039;\&quot;&#039; + aSource + &#039;\&quot; is not in the SourceMap.&#039;);\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i &lt; this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, &#039;source&#039;)) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i &lt; this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j &lt; sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === &#039;number&#039;) {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js&quot;:
/*!*************************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/base64-vlq.js\&quot;);\nvar util = __webpack_require__(/*! ./util */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/util.js\&quot;);\nvar ArraySet = __webpack_require__(/*! ./array-set */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/array-set.js\&quot;).ArraySet;\nvar MappingList = __webpack_require__(/*! ./mapping-list */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/mapping-list.js\&quot;).MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, &#039;file&#039;, null);\n  this._sourceRoot = util.getArg(aArgs, &#039;sourceRoot&#039;, null);\n  this._skipValidation = util.getArg(aArgs, &#039;skipValidation&#039;, false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source&#039;s line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, &#039;generated&#039;);\n    var original = util.getArg(aArgs, &#039;original&#039;, null);\n    var source = util.getArg(aArgs, &#039;source&#039;, null);\n    var name = util.getArg(aArgs, &#039;name&#039;, null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null &amp;&amp; original.line,\n      originalColumn: original != null &amp;&amp; original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer&#039;s file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren&#039;t in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          &#039;SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, &#039; +\n          &#039;or the source map\\&#039;s \&quot;file\&quot; property. Both were omitted.&#039;\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \&quot;sourceFile\&quot; relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \&quot;sourceFile\&quot;\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile &amp;&amp; mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null &amp;&amp; !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null &amp;&amp; !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal &amp;&amp; typeof aOriginal.line !== &#039;number&#039; &amp;&amp; typeof aOriginal.column !== &#039;number&#039;) {\n        throw new Error(\n            &#039;original.line and original.column are not numbers -- you probably meant to omit &#039; +\n            &#039;the original mapping entirely and only map the generated position. If so, pass &#039; +\n            &#039;null for the original mapping instead of an object with empty or null values.&#039;\n        );\n    }\n\n    if (aGenerated &amp;&amp; &#039;line&#039; in aGenerated &amp;&amp; &#039;column&#039; in aGenerated\n        &amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0\n        &amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated &amp;&amp; &#039;line&#039; in aGenerated &amp;&amp; &#039;column&#039; in aGenerated\n             &amp;&amp; aOriginal &amp;&amp; &#039;line&#039; in aOriginal &amp;&amp; &#039;column&#039; in aOriginal\n             &amp;&amp; aGenerated.line &gt; 0 &amp;&amp; aGenerated.column &gt;= 0\n             &amp;&amp; aOriginal.line &gt; 0 &amp;&amp; aOriginal.column &gt;= 0\n             &amp;&amp; aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error(&#039;Invalid mapping: &#039; + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = &#039;&#039;;\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i &lt; len; i++) {\n      mapping = mappings[i];\n      next = &#039;&#039;\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += &#039;;&#039;;\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i &gt; 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += &#039;,&#039;;\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/source-node.js&quot;:
/*!****************************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/source-node.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js\&quot;).SourceMapGenerator;\nvar util = __webpack_require__(/*! ./util */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/util.js\&quot;);\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \&quot;$$$isSourceNode$$$\&quot;;\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source&#039;s filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \&quot;\&quot;;\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex &lt; remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \&quot;remainingLines\&quot;\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \&quot;lastMapping\&quot; to \&quot;mapping\&quot;:\n        // First check if there is a new line in between.\n        if (lastGeneratedLine &lt; mapping.generatedLine) {\n          // Associate first line with \&quot;lastMapping\&quot;\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \&quot;lastGeneratedColumn\&quot; and\n          // \&quot;mapping.generatedColumn\&quot; with \&quot;lastMapping\&quot;\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine &lt; mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn &lt; mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex &lt; remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \&quot;lastMapping\&quot;\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\&quot;\&quot;));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \&quot;string\&quot;) {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got \&quot; + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i &gt;= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \&quot;string\&quot;) {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got \&quot; + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source&#039;s line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i &lt; len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== &#039;&#039;) {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len &gt; 0) {\n    newChildren = [];\n    for (i = 0; i &lt; len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === &#039;string&#039;) {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(&#039;&#039;.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i &lt; len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i &lt; len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \&quot;\&quot;;\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \&quot;\&quot;,\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        &amp;&amp; original.line !== null\n        &amp;&amp; original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx &lt; length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/source-node.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/lib/util.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/lib/util.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) =&gt; {

eval(&quot;/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error(&#039;\&quot;&#039; + aName + &#039;\&quot; is a required argument.&#039;);\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = &#039;&#039;;\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + &#039;:&#039;;\n  }\n  url += &#039;//&#039;;\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + &#039;@&#039;;\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \&quot;:\&quot; + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary &#039;.&#039; parts.\n * - Removes unnecessary &#039;&lt;dir&gt;/..&#039; parts.\n *\n * Based on code in the Node.js &#039;path&#039; core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i &gt;= 0; i--) {\n    part = parts[i];\n    if (part === &#039;.&#039;) {\n      parts.splice(i, 1);\n    } else if (part === &#039;..&#039;) {\n      up++;\n    } else if (up &gt; 0) {\n      if (part === &#039;&#039;) {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all &#039;..&#039; parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(&#039;/&#039;);\n\n  if (path === &#039;&#039;) {\n    path = isAbsolute ? &#039;/&#039; : &#039;.&#039;;\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example &#039;http://&#039; and &#039;www.example.com&#039; is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \&quot;\&quot;) {\n    aRoot = \&quot;.\&quot;;\n  }\n  if (aPath === \&quot;\&quot;) {\n    aPath = \&quot;.\&quot;;\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || &#039;/&#039;;\n  }\n\n  // `join(foo, &#039;//www.example.org&#039;)`\n  if (aPathUrl &amp;&amp; !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join(&#039;http://&#039;, &#039;www.example.com&#039;)`\n  if (aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === &#039;/&#039;\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, &#039;&#039;) + &#039;/&#039; + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === &#039;/&#039; || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \&quot;\&quot;) {\n    aRoot = \&quot;.\&quot;;\n  }\n\n  aRoot = aRoot.replace(/\\/$/, &#039;&#039;);\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won&#039;t work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + &#039;/&#039;) !== 0) {\n    var index = aRoot.lastIndexOf(\&quot;/\&quot;);\n    if (index &lt; 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \&quot;../\&quot; for each component we removed from the root.\n  return Array(level + 1).join(\&quot;../\&quot;) + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !(&#039;__proto__&#039; in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return &#039;$&#039; + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length &lt; 9 /* \&quot;__proto__\&quot;.length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* &#039;_&#039; */ ||\n      s.charCodeAt(length - 2) !== 95  /* &#039;_&#039; */ ||\n      s.charCodeAt(length - 3) !== 111 /* &#039;o&#039; */ ||\n      s.charCodeAt(length - 4) !== 116 /* &#039;t&#039; */ ||\n      s.charCodeAt(length - 5) !== 111 /* &#039;o&#039; */ ||\n      s.charCodeAt(length - 6) !== 114 /* &#039;r&#039; */ ||\n      s.charCodeAt(length - 7) !== 112 /* &#039;p&#039; */ ||\n      s.charCodeAt(length - 8) !== 95  /* &#039;_&#039; */ ||\n      s.charCodeAt(length - 9) !== 95  /* &#039;_&#039; */) {\n    return false;\n  }\n\n  for (var i = length - 10; i &gt;= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* &#039;$&#039; */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 &gt; aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/lib/util.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/snapdragon/node_modules/source-map/source-map.js&quot;:
/*!***********************************************************************!*\
  !*** ./node_modules/snapdragon/node_modules/source-map/source-map.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/source-map-generator.js\&quot;).SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/source-map-consumer.js\&quot;).SourceMapConsumer;\nexports.SourceNode = __webpack_require__(/*! ./lib/source-node */ \&quot;./node_modules/snapdragon/node_modules/source-map/lib/source-node.js\&quot;).SourceNode;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/snapdragon/node_modules/source-map/source-map.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/source-map-resolve/lib/decode-uri-component.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/source-map-resolve/lib/decode-uri-component.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var decodeUriComponent = __webpack_require__(/*! decode-uri-component */ \&quot;./node_modules/decode-uri-component/index.js\&quot;)\n\nfunction customDecodeUriComponent(string) {\n  // `decodeUriComponent` turns `+` into ` `, but that&#039;s not wanted.\n  return decodeUriComponent(string.replace(/\\+/g, \&quot;%2B\&quot;))\n}\n\nmodule.exports = customDecodeUriComponent\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/source-map-resolve/lib/decode-uri-component.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/source-map-resolve/lib/resolve-url.js&quot;:
/*!************************************************************!*\
  !*** ./node_modules/source-map-resolve/lib/resolve-url.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var url = __webpack_require__(/*! url */ \&quot;url\&quot;)\n\nfunction resolveUrl(/* ...urls */) {\n  return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {\n    return url.resolve(resolved, nextUrl)\n  })\n}\n\nmodule.exports = resolveUrl\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/source-map-resolve/lib/resolve-url.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/source-map-resolve/lib/source-map-resolve-node.js&quot;:
/*!************************************************************************!*\
  !*** ./node_modules/source-map-resolve/lib/source-map-resolve-node.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var sourceMappingURL   = __webpack_require__(/*! source-map-url */ \&quot;./node_modules/source-map-url/source-map-url.js\&quot;)\n\nvar resolveUrl         = __webpack_require__(/*! ./resolve-url */ \&quot;./node_modules/source-map-resolve/lib/resolve-url.js\&quot;)\nvar decodeUriComponent = __webpack_require__(/*! ./decode-uri-component */ \&quot;./node_modules/source-map-resolve/lib/decode-uri-component.js\&quot;)\nvar urix               = __webpack_require__(/*! urix */ \&quot;./node_modules/urix/index.js\&quot;)\nvar atob               = __webpack_require__(/*! atob */ \&quot;./node_modules/atob/node-atob.js\&quot;)\n\n\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function() { callback(error, result) })\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}&#039;/, \&quot;\&quot;))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = decodeUriComponent(url)\n  try {\n    return String(read(readUrl))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\n\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl)\n  } catch (error) {\n    return callbackAsync(callback, error)\n  }\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData)\n  }\n  var readUrl = decodeUriComponent(mapData.url)\n  read(readUrl, function(error, result) {\n    if (error) {\n      error.sourceMapData = mapData\n      return callback(error)\n    }\n    mapData.map = String(result)\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData)\n    } catch (error) {\n      return callback(error)\n    }\n    callback(null, mapData)\n  })\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl)\n  if (!mapData || mapData.map) {\n    return mapData\n  }\n  mapData.map = readSync(read, mapData.url, mapData)\n  mapData.map = parseMapToJSON(mapData.map, mapData)\n  return mapData\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\n\n/**\n * The media type for JSON text is application/json.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n *\n * `text/json` is non-standard media type\n */\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/\n\n/**\n * JSON text exchanged between systems that are not part of a closed ecosystem\n * MUST be encoded using UTF-8.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n */\nvar jsonCharacterEncoding = \&quot;utf-8\&quot;\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64)\n  var len = binStr.length\n  var arr = new Uint8Array(len)\n  for (var i = 0; i &lt; len; i++) {\n    arr[i] = binStr.charCodeAt(i)\n  }\n  return arr\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \&quot;undefined\&quot; || typeof Uint8Array === \&quot;undefined\&quot;) {\n    return atob(b64)\n  }\n  var buf = base64ToBuf(b64);\n  // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\&quot;EncodingError\&quot;` value when an coding error is found.\n  var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = urix(codeUrl)\n\n  var url = sourceMappingURL.getFrom(code)\n  if (!url) {\n    return null\n  }\n\n  var dataUri = url.match(dataUriRegex)\n  if (dataUri) {\n    var mimeType = dataUri[1] || \&quot;text/plain\&quot;\n    var lastParameter = dataUri[2] || \&quot;\&quot;\n    var encoded = dataUri[3] || \&quot;\&quot;\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    }\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\&quot;Unuseful data uri mime type: \&quot; + mimeType)\n      error.sourceMapData = data\n      throw error\n    }\n    try {\n      data.map = parseMapToJSON(\n        lastParameter === \&quot;;base64\&quot; ? decodeBase64String(encoded) : decodeURIComponent(encoded),\n        data\n      )\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n    return data\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url)\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  }\n}\n\n\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \&quot;function\&quot;) {\n    callback = options\n    options = {}\n  }\n  var pending = map.sources ? map.sources.length : 0\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result)\n    return\n  }\n\n  var done = function() {\n    pending--\n    if (pending === 0) {\n      callback(null, result)\n    }\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (typeof sourceContent === \&quot;string\&quot;) {\n      result.sourcesContent[index] = sourceContent\n      callbackAsync(done, null)\n    } else {\n      var readUrl = decodeUriComponent(fullUrl)\n      read(readUrl, function(error, source) {\n        result.sourcesContent[index] = error ? error : String(source)\n        done()\n      })\n    }\n  })\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (!map.sources || map.sources.length === 0) {\n    return result\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (read !== null) {\n      if (typeof sourceContent === \&quot;string\&quot;) {\n        result.sourcesContent[index] = sourceContent\n      } else {\n        var readUrl = decodeUriComponent(fullUrl)\n        try {\n          result.sourcesContent[index] = String(read(readUrl))\n        } catch (error) {\n          result.sourcesContent[index] = error\n        }\n      }\n    }\n  })\n\n  return result\n}\n\nvar endingSlash = /\\/?$/\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {}\n  mapUrl = urix(mapUrl)\n  var fullUrl\n  var sourceContent\n  var sourceRoot\n  for (var index = 0, len = map.sources.length; index &lt; len; index++) {\n    sourceRoot = null\n    if (typeof options.sourceRoot === \&quot;string\&quot;) {\n      sourceRoot = options.sourceRoot\n    } else if (typeof map.sourceRoot === \&quot;string\&quot; &amp;&amp; options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot\n    }\n    // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n    if (sourceRoot === null || sourceRoot === &#039;&#039;) {\n      fullUrl = resolveUrl(mapUrl, map.sources[index])\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/&lt;source&gt;`, not `/scripts/&lt;source&gt;`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \&quot;/\&quot;), map.sources[index])\n    }\n    sourceContent = (map.sourcesContent || [])[index]\n    fn(fullUrl, sourceContent, index)\n  }\n}\n\n\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \&quot;function\&quot;) {\n    callback = options\n    options = {}\n  }\n  if (code === null) {\n    var mapUrl = codeUrl\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    var readUrl = decodeUriComponent(mapUrl)\n    read(readUrl, function(error, result) {\n      if (error) {\n        error.sourceMapData = data\n        return callback(error)\n      }\n      data.map = String(result)\n      try {\n        data.map = parseMapToJSON(data.map, data)\n      } catch (error) {\n        return callback(error)\n      }\n      _resolveSources(data)\n    })\n  } else {\n    resolveSourceMap(code, codeUrl, read, function(error, mapData) {\n      if (error) {\n        return callback(error)\n      }\n      if (!mapData) {\n        return callback(null, null)\n      }\n      _resolveSources(mapData)\n    })\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\n      if (error) {\n        return callback(error)\n      }\n      mapData.sourcesResolved = result.sourcesResolved\n      mapData.sourcesContent  = result.sourcesContent\n      callback(null, mapData)\n    })\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData\n  if (code === null) {\n    var mapUrl = codeUrl\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    mapData.map = readSync(read, mapUrl, mapData)\n    mapData.map = parseMapToJSON(mapData.map, mapData)\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read)\n    if (!mapData) {\n      return null\n    }\n  }\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\n  mapData.sourcesResolved = result.sourcesResolved\n  mapData.sourcesContent  = result.sourcesContent\n  return mapData\n}\n\n\n\nmodule.exports = {\n  resolveSourceMap:     resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources:       resolveSources,\n  resolveSourcesSync:   resolveSourcesSync,\n  resolve:              resolve,\n  resolveSync:          resolveSync,\n  parseMapToJSON:       parseMapToJSON\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/source-map-resolve/lib/source-map-resolve-node.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/source-map-url/source-map-url.js&quot;:
/*!*******************************************************!*\
  !*** ./node_modules/source-map-url/source-map-url.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(&quot;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\n\nvoid (function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === &#039;function&#039; ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n}(this, function() {\n\n  var innerRegex = /[#@] sourceMappingURL=([^\\s&#039;\&quot;]*)/\n\n  var regex = RegExp(\n    \&quot;(?:\&quot; +\n      \&quot;/\\\\*\&quot; +\n      \&quot;(?:\\\\s*\\r?\\n(?://)?)?\&quot; +\n      \&quot;(?:\&quot; + innerRegex.source + \&quot;)\&quot; +\n      \&quot;\\\\s*\&quot; +\n      \&quot;\\\\*/\&quot; +\n      \&quot;|\&quot; +\n      \&quot;//(?:\&quot; + innerRegex.source + \&quot;)\&quot; +\n    \&quot;)\&quot; +\n    \&quot;\\\\s*\&quot;\n  )\n\n  return {\n\n    regex: regex,\n    _innerRegex: innerRegex,\n\n    getFrom: function(code) {\n      var match = code.match(regex)\n      return (match ? match[1] || match[2] || \&quot;\&quot; : null)\n    },\n\n    existsIn: function(code) {\n      return regex.test(code)\n    },\n\n    removeFrom: function(code) {\n      return code.replace(regex, \&quot;\&quot;)\n    },\n\n    insertBefore: function(code, string) {\n      var match = code.match(regex)\n      if (match) {\n        return code.slice(0, match.index) + string + code.slice(match.index)\n      } else {\n        return code + string\n      }\n    }\n  }\n\n}));\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/source-map-url/source-map-url.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/split-string/index.js&quot;:
/*!********************************************!*\
  !*** ./node_modules/split-string/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * split-string &lt;https://github.com/jonschlinkert/split-string&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/split-string/node_modules/extend-shallow/index.js\&quot;);\n\nmodule.exports = function(str, options, fn) {\n  if (typeof str !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  if (typeof options === &#039;function&#039;) {\n    fn = options;\n    options = null;\n  }\n\n  // allow separator to be defined as a string\n  if (typeof options === &#039;string&#039;) {\n    options = { sep: options };\n  }\n\n  var opts = extend({sep: &#039;.&#039;}, options);\n  var quotes = opts.quotes || [&#039;\&quot;&#039;, \&quot;&#039;\&quot;, &#039;`&#039;];\n  var brackets;\n\n  if (opts.brackets === true) {\n    brackets = {\n      &#039;&lt;&#039;: &#039;&gt;&#039;,\n      &#039;(&#039;: &#039;)&#039;,\n      &#039;[&#039;: &#039;]&#039;,\n      &#039;{&#039;: &#039;}&#039;\n    };\n  } else if (opts.brackets) {\n    brackets = opts.brackets;\n  }\n\n  var tokens = [];\n  var stack = [];\n  var arr = [&#039;&#039;];\n  var sep = opts.sep;\n  var len = str.length;\n  var idx = -1;\n  var closeIdx;\n\n  function expected() {\n    if (brackets &amp;&amp; stack.length) {\n      return brackets[stack[stack.length - 1]];\n    }\n  }\n\n  while (++idx &lt; len) {\n    var ch = str[idx];\n    var next = str[idx + 1];\n    var tok = { val: ch, idx: idx, arr: arr, str: str };\n    tokens.push(tok);\n\n    if (ch === &#039;\\\\&#039;) {\n      tok.val = keepEscaping(opts, str, idx) === true ? (ch + next) : next;\n      tok.escaped = true;\n      if (typeof fn === &#039;function&#039;) {\n        fn(tok);\n      }\n      arr[arr.length - 1] += tok.val;\n      idx++;\n      continue;\n    }\n\n    if (brackets &amp;&amp; brackets[ch]) {\n      stack.push(ch);\n      var e = expected();\n      var i = idx + 1;\n\n      if (str.indexOf(e, i + 1) !== -1) {\n        while (stack.length &amp;&amp; i &lt; len) {\n          var s = str[++i];\n          if (s === &#039;\\\\&#039;) {\n            s++;\n            continue;\n          }\n\n          if (quotes.indexOf(s) !== -1) {\n            i = getClosingQuote(str, s, i + 1);\n            continue;\n          }\n\n          e = expected();\n          if (stack.length &amp;&amp; str.indexOf(e, i + 1) === -1) {\n            break;\n          }\n\n          if (brackets[s]) {\n            stack.push(s);\n            continue;\n          }\n\n          if (e === s) {\n            stack.pop();\n          }\n        }\n      }\n\n      closeIdx = i;\n      if (closeIdx === -1) {\n        arr[arr.length - 1] += ch;\n        continue;\n      }\n\n      ch = str.slice(idx, closeIdx + 1);\n      tok.val = ch;\n      tok.idx = idx = closeIdx;\n    }\n\n    if (quotes.indexOf(ch) !== -1) {\n      closeIdx = getClosingQuote(str, ch, idx + 1);\n      if (closeIdx === -1) {\n        arr[arr.length - 1] += ch;\n        continue;\n      }\n\n      if (keepQuotes(ch, opts) === true) {\n        ch = str.slice(idx, closeIdx + 1);\n      } else {\n        ch = str.slice(idx + 1, closeIdx);\n      }\n\n      tok.val = ch;\n      tok.idx = idx = closeIdx;\n    }\n\n    if (typeof fn === &#039;function&#039;) {\n      fn(tok, tokens);\n      ch = tok.val;\n      idx = tok.idx;\n    }\n\n    if (tok.val === sep &amp;&amp; tok.split !== false) {\n      arr.push(&#039;&#039;);\n      continue;\n    }\n\n    arr[arr.length - 1] += tok.val;\n  }\n\n  return arr;\n};\n\nfunction getClosingQuote(str, ch, i, brackets) {\n  var idx = str.indexOf(ch, i);\n  if (str.charAt(idx - 1) === &#039;\\\\&#039;) {\n    return getClosingQuote(str, ch, idx + 1);\n  }\n  return idx;\n}\n\nfunction keepQuotes(ch, opts) {\n  if (opts.keepDoubleQuotes === true &amp;&amp; ch === &#039;\&quot;&#039;) return true;\n  if (opts.keepSingleQuotes === true &amp;&amp; ch === \&quot;&#039;\&quot;) return true;\n  return opts.keepQuotes;\n}\n\nfunction keepEscaping(opts, str, idx) {\n  if (typeof opts.keepEscaping === &#039;function&#039;) {\n    return opts.keepEscaping(str, idx);\n  }\n  return opts.keepEscaping === true || str[idx + 1] === &#039;\\\\&#039;;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/split-string/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/split-string/node_modules/extend-shallow/index.js&quot;:
/*!************************************************************************!*\
  !*** ./node_modules/split-string/node_modules/extend-shallow/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isExtendable = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/split-string/node_modules/is-extendable/index.js\&quot;);\nvar assignSymbols = __webpack_require__(/*! assign-symbols */ \&quot;./node_modules/assign-symbols/index.js\&quot;);\n\nmodule.exports = Object.assign || function(obj/*, objects*/) {\n  if (obj === null || typeof obj === &#039;undefined&#039;) {\n    throw new TypeError(&#039;Cannot convert undefined or null to object&#039;);\n  }\n  if (!isObject(obj)) {\n    obj = {};\n  }\n  for (var i = 1; i &lt; arguments.length; i++) {\n    var val = arguments[i];\n    if (isString(val)) {\n      val = toObject(val);\n    }\n    if (isObject(val)) {\n      assign(obj, val);\n      assignSymbols(obj, val);\n    }\n  }\n  return obj;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction isString(val) {\n  return (val &amp;&amp; typeof val === &#039;string&#039;);\n}\n\nfunction toObject(str) {\n  var obj = {};\n  for (var i in str) {\n    obj[i] = str[i];\n  }\n  return obj;\n}\n\nfunction isObject(val) {\n  return (val &amp;&amp; typeof val === &#039;object&#039;) || isExtendable(val);\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isEnum(obj, key) {\n  return Object.prototype.propertyIsEnumerable.call(obj, key);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/split-string/node_modules/extend-shallow/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/split-string/node_modules/is-extendable/index.js&quot;:
/*!***********************************************************************!*\
  !*** ./node_modules/split-string/node_modules/is-extendable/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\n\nmodule.exports = function isExtendable(val) {\n  return isPlainObject(val) || typeof val === &#039;function&#039; || Array.isArray(val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/split-string/node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/static-extend/index.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/static-extend/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * static-extend &lt;https://github.com/jonschlinkert/static-extend&gt;\n *\n * Copyright (c) 2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar copy = __webpack_require__(/*! object-copy */ \&quot;./node_modules/object-copy/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/define-property/index.js\&quot;);\nvar util = __webpack_require__(/*! util */ \&quot;util\&quot;);\n\n/**\n * Returns a function for extending the static properties,\n * prototype properties, and descriptors from the `Parent`\n * constructor onto `Child` constructors.\n *\n * ```js\n * var extend = require(&#039;static-extend&#039;);\n * Parent.extend = extend(Parent);\n *\n * // optionally pass a custom merge function as the second arg\n * Parent.extend = extend(Parent, function(Child) {\n *   Child.prototype.mixin = function(key, val) {\n *     Child.prototype[key] = val;\n *   };\n * });\n *\n * // extend \&quot;child\&quot; constructors\n * Parent.extend(Child);\n *\n * // optionally define prototype methods as the second arg\n * Parent.extend(Child, {\n *   foo: function() {},\n *   bar: function() {}\n * });\n * ```\n * @param {Function} `Parent` Parent ctor\n * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.\n *   @param {Function} `Child` Child ctor\n *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.\n *   @return {Object}\n * @api public\n */\n\nfunction extend(Parent, extendFn) {\n  if (typeof Parent !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected Parent to be a function.&#039;);\n  }\n\n  return function(Ctor, proto) {\n    if (typeof Ctor !== &#039;function&#039;) {\n      throw new TypeError(&#039;expected Ctor to be a function.&#039;);\n    }\n\n    util.inherits(Ctor, Parent);\n    copy(Ctor, Parent);\n\n    // proto can be null or a plain object\n    if (typeof proto === &#039;object&#039;) {\n      var obj = Object.create(proto);\n\n      for (var k in obj) {\n        Ctor.prototype[k] = obj[k];\n      }\n    }\n\n    // keep a reference to the parent prototype\n    define(Ctor.prototype, &#039;_parent_&#039;, {\n      configurable: true,\n      set: function() {},\n      get: function() {\n        return Parent.prototype;\n      }\n    });\n\n    if (typeof extendFn === &#039;function&#039;) {\n      extendFn(Ctor, Parent);\n    }\n\n    Ctor.extend = extend(Ctor, extendFn);\n  };\n};\n\n/**\n * Expose `extend`\n */\n\nmodule.exports = extend;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/static-extend/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/string_decoder/lib/string_decoder.js&quot;:
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \&quot;Software\&quot;), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \&quot;AS IS\&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*&lt;replacement&gt;*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \&quot;./node_modules/safe-buffer/index.js\&quot;).Buffer;\n/*&lt;/replacement&gt;*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = &#039;&#039; + encoding;\n  switch (encoding &amp;&amp; encoding.toLowerCase()) {\n    case &#039;hex&#039;:case &#039;utf8&#039;:case &#039;utf-8&#039;:case &#039;ascii&#039;:case &#039;binary&#039;:case &#039;base64&#039;:case &#039;ucs2&#039;:case &#039;ucs-2&#039;:case &#039;utf16le&#039;:case &#039;utf-16le&#039;:case &#039;raw&#039;:\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return &#039;utf8&#039;;\n  var retried;\n  while (true) {\n    switch (enc) {\n      case &#039;utf8&#039;:\n      case &#039;utf-8&#039;:\n        return &#039;utf8&#039;;\n      case &#039;ucs2&#039;:\n      case &#039;ucs-2&#039;:\n      case &#039;utf16le&#039;:\n      case &#039;utf-16le&#039;:\n        return &#039;utf16le&#039;;\n      case &#039;latin1&#039;:\n      case &#039;binary&#039;:\n        return &#039;latin1&#039;;\n      case &#039;base64&#039;:\n      case &#039;ascii&#039;:\n      case &#039;hex&#039;:\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = (&#039;&#039; + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== &#039;string&#039; &amp;&amp; (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error(&#039;Unknown encoding: &#039; + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case &#039;utf16le&#039;:\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case &#039;utf8&#039;:\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case &#039;base64&#039;:\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return &#039;&#039;;\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return &#039;&#039;;\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i &lt; buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || &#039;&#039;;\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed &lt;= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it&#039;s ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte &lt;= 0x7F) return 0;else if (byte &gt;&gt; 5 === 0x06) return 2;else if (byte &gt;&gt; 4 === 0x0E) return 3;else if (byte &gt;&gt; 3 === 0x1E) return 4;\n  return byte &gt;&gt; 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j &lt; i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb &gt;= 0) {\n    if (nb &gt; 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j &lt; i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb &gt;= 0) {\n    if (nb &gt; 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j &lt; i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb &gt;= 0) {\n    if (nb &gt; 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \&quot;replace\&quot; the validated continuation bytes we&#039;ve seen so far with\n// a single UTF-8 replacement character (&#039;\\ufffd&#039;), to match v8&#039;s UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] &amp; 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return &#039;\\ufffd&#039;;\n  }\n  if (self.lastNeed &gt; 1 &amp;&amp; buf.length &gt; 1) {\n    if ((buf[1] &amp; 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return &#039;\\ufffd&#039;;\n    }\n    if (self.lastNeed &gt; 2 &amp;&amp; buf.length &gt; 2) {\n      if ((buf[2] &amp; 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return &#039;\\ufffd&#039;;\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed &lt;= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character&#039;s bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString(&#039;utf8&#039;, i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString(&#039;utf8&#039;, i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf &amp;&amp; buf.length ? this.write(buf) : &#039;&#039;;\n  if (this.lastNeed) return r + &#039;\\ufffd&#039;;\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString(&#039;utf16le&#039;, i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString(&#039;utf16le&#039;, i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf &amp;&amp; buf.length ? this.write(buf) : &#039;&#039;;\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString(&#039;utf16le&#039;, 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString(&#039;base64&#039;, i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString(&#039;base64&#039;, i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf &amp;&amp; buf.length ? this.write(buf) : &#039;&#039;;\n  if (this.lastNeed) return r + this.lastChar.toString(&#039;base64&#039;, 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf &amp;&amp; buf.length ? this.write(buf) : &#039;&#039;;\n}\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/string_decoder/lib/string_decoder.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-object-path/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/to-object-path/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * to-object-path &lt;https://github.com/jonschlinkert/to-object-path&gt;\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar typeOf = __webpack_require__(/*! kind-of */ \&quot;./node_modules/to-object-path/node_modules/kind-of/index.js\&quot;);\n\nmodule.exports = function toPath(args) {\n  if (typeOf(args) !== &#039;arguments&#039;) {\n    args = arguments;\n  }\n  return filter(args).join(&#039;.&#039;);\n};\n\nfunction filter(arr) {\n  var len = arr.length;\n  var idx = -1;\n  var res = [];\n\n  while (++idx &lt; len) {\n    var ele = arr[idx];\n    if (typeOf(ele) === &#039;arguments&#039; || Array.isArray(ele)) {\n      res.push.apply(res, filter(ele));\n    } else if (typeof ele === &#039;string&#039;) {\n      res.push(ele);\n    }\n  }\n  return res;\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-object-path/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-object-path/node_modules/kind-of/index.js&quot;:
/*!*******************************************************************!*\
  !*** ./node_modules/to-object-path/node_modules/kind-of/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;var isBuffer = __webpack_require__(/*! is-buffer */ \&quot;./node_modules/is-buffer/index.js\&quot;);\nvar toString = Object.prototype.toString;\n\n/**\n * Get the native `typeof` a value.\n *\n * @param  {*} `val`\n * @return {*} Native javascript type\n */\n\nmodule.exports = function kindOf(val) {\n  // primitivies\n  if (typeof val === &#039;undefined&#039;) {\n    return &#039;undefined&#039;;\n  }\n  if (val === null) {\n    return &#039;null&#039;;\n  }\n  if (val === true || val === false || val instanceof Boolean) {\n    return &#039;boolean&#039;;\n  }\n  if (typeof val === &#039;string&#039; || val instanceof String) {\n    return &#039;string&#039;;\n  }\n  if (typeof val === &#039;number&#039; || val instanceof Number) {\n    return &#039;number&#039;;\n  }\n\n  // functions\n  if (typeof val === &#039;function&#039; || val instanceof Function) {\n    return &#039;function&#039;;\n  }\n\n  // array\n  if (typeof Array.isArray !== &#039;undefined&#039; &amp;&amp; Array.isArray(val)) {\n    return &#039;array&#039;;\n  }\n\n  // check for instances of RegExp and Date before calling `toString`\n  if (val instanceof RegExp) {\n    return &#039;regexp&#039;;\n  }\n  if (val instanceof Date) {\n    return &#039;date&#039;;\n  }\n\n  // other objects\n  var type = toString.call(val);\n\n  if (type === &#039;[object RegExp]&#039;) {\n    return &#039;regexp&#039;;\n  }\n  if (type === &#039;[object Date]&#039;) {\n    return &#039;date&#039;;\n  }\n  if (type === &#039;[object Arguments]&#039;) {\n    return &#039;arguments&#039;;\n  }\n  if (type === &#039;[object Error]&#039;) {\n    return &#039;error&#039;;\n  }\n\n  // buffer\n  if (isBuffer(val)) {\n    return &#039;buffer&#039;;\n  }\n\n  // es6: Map, WeakMap, Set, WeakSet\n  if (type === &#039;[object Set]&#039;) {\n    return &#039;set&#039;;\n  }\n  if (type === &#039;[object WeakSet]&#039;) {\n    return &#039;weakset&#039;;\n  }\n  if (type === &#039;[object Map]&#039;) {\n    return &#039;map&#039;;\n  }\n  if (type === &#039;[object WeakMap]&#039;) {\n    return &#039;weakmap&#039;;\n  }\n  if (type === &#039;[object Symbol]&#039;) {\n    return &#039;symbol&#039;;\n  }\n\n  // typed arrays\n  if (type === &#039;[object Int8Array]&#039;) {\n    return &#039;int8array&#039;;\n  }\n  if (type === &#039;[object Uint8Array]&#039;) {\n    return &#039;uint8array&#039;;\n  }\n  if (type === &#039;[object Uint8ClampedArray]&#039;) {\n    return &#039;uint8clampedarray&#039;;\n  }\n  if (type === &#039;[object Int16Array]&#039;) {\n    return &#039;int16array&#039;;\n  }\n  if (type === &#039;[object Uint16Array]&#039;) {\n    return &#039;uint16array&#039;;\n  }\n  if (type === &#039;[object Int32Array]&#039;) {\n    return &#039;int32array&#039;;\n  }\n  if (type === &#039;[object Uint32Array]&#039;) {\n    return &#039;uint32array&#039;;\n  }\n  if (type === &#039;[object Float32Array]&#039;) {\n    return &#039;float32array&#039;;\n  }\n  if (type === &#039;[object Float64Array]&#039;) {\n    return &#039;float64array&#039;;\n  }\n\n  // must be a plain object\n  return &#039;object&#039;;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-object-path/node_modules/kind-of/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-regex-range/index.js&quot;:
/*!**********************************************!*\
  !*** ./node_modules/to-regex-range/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * to-regex-range &lt;https://github.com/jonschlinkert/to-regex-range&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar repeat = __webpack_require__(/*! repeat-string */ \&quot;./node_modules/repeat-string/index.js\&quot;);\nvar isNumber = __webpack_require__(/*! is-number */ \&quot;./node_modules/is-number/index.js\&quot;);\nvar cache = {};\n\nfunction toRegexRange(min, max, options) {\n  if (isNumber(min) === false) {\n    throw new RangeError(&#039;toRegexRange: first argument is invalid.&#039;);\n  }\n\n  if (typeof max === &#039;undefined&#039; || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new RangeError(&#039;toRegexRange: second argument is invalid.&#039;);\n  }\n\n  options = options || {};\n  var relax = String(options.relaxZeros);\n  var shorthand = String(options.shorthand);\n  var capture = String(options.capture);\n  var key = min + &#039;:&#039; + max + &#039;=&#039; + relax + shorthand + capture;\n  if (cache.hasOwnProperty(key)) {\n    return cache[key].result;\n  }\n\n  var a = Math.min(min, max);\n  var b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    var result = min + &#039;|&#039; + max;\n    if (options.capture) {\n      return &#039;(&#039; + result + &#039;)&#039;;\n    }\n    return result;\n  }\n\n  var isPadded = padding(min) || padding(max);\n  var positives = [];\n  var negatives = [];\n\n  var tok = {min: min, max: max, a: a, b: b};\n  if (isPadded) {\n    tok.isPadded = isPadded;\n    tok.maxLen = String(tok.max).length;\n  }\n\n  if (a &lt; 0) {\n    var newMin = b &lt; 0 ? Math.abs(b) : 1;\n    var newMax = Math.abs(a);\n    negatives = splitToPatterns(newMin, newMax, tok, options);\n    a = tok.a = 0;\n  }\n\n  if (b &gt;= 0) {\n    positives = splitToPatterns(a, b, tok, options);\n  }\n\n  tok.negatives = negatives;\n  tok.positives = positives;\n  tok.result = siftPatterns(negatives, positives, options);\n\n  if (options.capture &amp;&amp; (positives.length + negatives.length) &gt; 1) {\n    tok.result = &#039;(&#039; + tok.result + &#039;)&#039;;\n  }\n\n  cache[key] = tok;\n  return tok.result;\n}\n\nfunction siftPatterns(neg, pos, options) {\n  var onlyNegative = filterPatterns(neg, pos, &#039;-&#039;, false, options) || [];\n  var onlyPositive = filterPatterns(pos, neg, &#039;&#039;, false, options) || [];\n  var intersected = filterPatterns(neg, pos, &#039;-?&#039;, true, options) || [];\n  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join(&#039;|&#039;);\n}\n\nfunction splitToRanges(min, max) {\n  min = Number(min);\n  max = Number(max);\n\n  var nines = 1;\n  var stops = [max];\n  var stop = +countNines(min, nines);\n\n  while (min &lt;= stop &amp;&amp; stop &lt;= max) {\n    stops = push(stops, stop);\n    nines += 1;\n    stop = +countNines(min, nines);\n  }\n\n  var zeros = 1;\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min &lt; stop &amp;&amp; stop &lt;= max) {\n    stops = push(stops, stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {pattern: String(start), digits: []};\n  }\n\n  var zipped = zip(String(start), String(stop));\n  var len = zipped.length, i = -1;\n\n  var pattern = &#039;&#039;;\n  var digits = 0;\n\n  while (++i &lt; len) {\n    var numbers = zipped[i];\n    var startDigit = numbers[0];\n    var stopDigit = numbers[1];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== &#039;0&#039; || stopDigit !== &#039;9&#039;) {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      digits += 1;\n    }\n  }\n\n  if (digits) {\n    pattern += options.shorthand ? &#039;\\\\d&#039; : &#039;[0-9]&#039;;\n  }\n\n  return { pattern: pattern, digits: [digits] };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  var ranges = splitToRanges(min, max);\n  var len = ranges.length;\n  var idx = -1;\n\n  var tokens = [];\n  var start = min;\n  var prev;\n\n  while (++idx &lt; len) {\n    var range = ranges[idx];\n    var obj = rangeToPattern(start, range, options);\n    var zeros = &#039;&#039;;\n\n    if (!tok.isPadded &amp;&amp; prev &amp;&amp; prev.pattern === obj.pattern) {\n      if (prev.digits.length &gt; 1) {\n        prev.digits.pop();\n      }\n      prev.digits.push(obj.digits[0]);\n      prev.string = prev.pattern + toQuantifier(prev.digits);\n      start = range + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(range, tok);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);\n    tokens.push(obj);\n    start = range + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  var res = [];\n\n  for (var i = 0; i &lt; arr.length; i++) {\n    var tok = arr[i];\n    var ele = tok.string;\n\n    if (options.relaxZeros !== false) {\n      if (prefix === &#039;-&#039; &amp;&amp; ele.charAt(0) === &#039;0&#039;) {\n        if (ele.charAt(1) === &#039;{&#039;) {\n          ele = &#039;0*&#039; + ele.replace(/^0\\{\\d+\\}/, &#039;&#039;);\n        } else {\n          ele = &#039;0*&#039; + ele.slice(1);\n        }\n      }\n    }\n\n    if (!intersection &amp;&amp; !contains(comparison, &#039;string&#039;, ele)) {\n      res.push(prefix + ele);\n    }\n\n    if (intersection &amp;&amp; contains(comparison, &#039;string&#039;, ele)) {\n      res.push(prefix + ele);\n    }\n  }\n  return res;\n}\n\n/**\n * Zip strings (`for in` can be used on string characters)\n */\n\nfunction zip(a, b) {\n  var arr = [];\n  for (var ch in a) arr.push([a[ch], b[ch]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a &gt; b ? 1 : b &gt; a ? -1 : 0;\n}\n\nfunction push(arr, ele) {\n  if (arr.indexOf(ele) === -1) arr.push(ele);\n  return arr;\n}\n\nfunction contains(arr, key, val) {\n  for (var i = 0; i &lt; arr.length; i++) {\n    if (arr[i][key] === val) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction countNines(min, len) {\n  return String(min).slice(0, -len) + repeat(&#039;9&#039;, len);\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  var start = digits[0];\n  var stop = digits[1] ? (&#039;,&#039; + digits[1]) : &#039;&#039;;\n  if (!stop &amp;&amp; (!start || start === 1)) {\n    return &#039;&#039;;\n  }\n  return &#039;{&#039; + start + stop + &#039;}&#039;;\n}\n\nfunction toCharacterClass(a, b) {\n  return &#039;[&#039; + a + ((b - a === 1) ? &#039;&#039; : &#039;-&#039;) + b + &#039;]&#039;;\n}\n\nfunction padding(str) {\n  return /^-?(0+)\\d/.exec(str);\n}\n\nfunction padZeros(val, tok) {\n  if (tok.isPadded) {\n    var diff = Math.abs(tok.maxLen - String(val).length);\n    switch (diff) {\n      case 0:\n        return &#039;&#039;;\n      case 1:\n        return &#039;0&#039;;\n      default: {\n        return &#039;0{&#039; + diff + &#039;}&#039;;\n      }\n    }\n  }\n  return val;\n}\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-regex-range/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-regex/index.js&quot;:
/*!****************************************!*\
  !*** ./node_modules/to-regex/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar safe = __webpack_require__(/*! safe-regex */ \&quot;./node_modules/safe-regex/index.js\&quot;);\nvar define = __webpack_require__(/*! define-property */ \&quot;./node_modules/to-regex/node_modules/define-property/index.js\&quot;);\nvar extend = __webpack_require__(/*! extend-shallow */ \&quot;./node_modules/to-regex/node_modules/extend-shallow/index.js\&quot;);\nvar not = __webpack_require__(/*! regex-not */ \&quot;./node_modules/regex-not/index.js\&quot;);\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * Session cache\n */\n\nvar cache = {};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nmodule.exports = function(patterns, options) {\n  if (!Array.isArray(patterns)) {\n    return makeRe(patterns, options);\n  }\n  return makeRe(patterns.join(&#039;|&#039;), options);\n};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nfunction makeRe(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected a string&#039;);\n  }\n\n  if (pattern.length &gt; MAX_LENGTH) {\n    throw new Error(&#039;expected pattern to be less than &#039; + MAX_LENGTH + &#039; characters&#039;);\n  }\n\n  var key = pattern;\n  // do this before shallow cloning options, it&#039;s a lot faster\n  if (!options || (options &amp;&amp; options.cache !== false)) {\n    key = createKey(pattern, options);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n  }\n\n  var opts = extend({}, options);\n  if (opts.contains === true) {\n    if (opts.negate === true) {\n      opts.strictNegate = false;\n    } else {\n      opts.strict = false;\n    }\n  }\n\n  if (opts.strict === false) {\n    opts.strictOpen = false;\n    opts.strictClose = false;\n  }\n\n  var open = opts.strictOpen !== false ? &#039;^&#039; : &#039;&#039;;\n  var close = opts.strictClose !== false ? &#039;$&#039; : &#039;&#039;;\n  var flags = opts.flags || &#039;&#039;;\n  var regex;\n\n  if (opts.nocase === true &amp;&amp; !/i/.test(flags)) {\n    flags += &#039;i&#039;;\n  }\n\n  try {\n    if (opts.negate || typeof opts.strictNegate === &#039;boolean&#039;) {\n      pattern = not.create(pattern, opts);\n    }\n\n    var str = open + &#039;(?:&#039; + pattern + &#039;)&#039; + close;\n    regex = new RegExp(str, flags);\n\n    if (opts.safe === true &amp;&amp; safe(regex) === false) {\n      throw new Error(&#039;potentially unsafe regular expression: &#039; + regex.source);\n    }\n\n  } catch (err) {\n    if (opts.strictErrors === true || opts.safe === true) {\n      err.key = key;\n      err.pattern = pattern;\n      err.originalOptions = options;\n      err.createdOptions = opts;\n      throw err;\n    }\n\n    try {\n      regex = new RegExp(&#039;^&#039; + pattern.replace(/(\\W)/g, &#039;\\\\$1&#039;) + &#039;$&#039;);\n    } catch (err) {\n      regex = /.^/; //&lt;= match nothing\n    }\n  }\n\n  if (opts.cache !== false) {\n    memoize(regex, key, pattern, opts);\n  }\n  return regex;\n}\n\n/**\n * Memoize generated regex. This can result in dramatic speed improvements\n * and simplify debugging by adding options and pattern to the regex. It can be\n * disabled by passing setting `options.cache` to false.\n */\n\nfunction memoize(regex, key, pattern, options) {\n  define(regex, &#039;cached&#039;, true);\n  define(regex, &#039;pattern&#039;, pattern);\n  define(regex, &#039;options&#039;, options);\n  define(regex, &#039;key&#039;, key);\n  cache[key] = regex;\n}\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nfunction createKey(pattern, options) {\n  if (!options) return pattern;\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += &#039;;&#039; + prop + &#039;=&#039; + String(options[prop]);\n    }\n  }\n  return key;\n}\n\n/**\n * Expose `makeRe`\n */\n\nmodule.exports.makeRe = makeRe;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-regex/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-regex/node_modules/define-property/index.js&quot;:
/*!*********************************************************************!*\
  !*** ./node_modules/to-regex/node_modules/define-property/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * define-property &lt;https://github.com/jonschlinkert/define-property&gt;\n *\n * Copyright (c) 2015-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isobject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar isDescriptor = __webpack_require__(/*! is-descriptor */ \&quot;./node_modules/is-descriptor/index.js\&quot;);\nvar define = (typeof Reflect !== &#039;undefined&#039; &amp;&amp; Reflect.defineProperty)\n  ? Reflect.defineProperty\n  : Object.defineProperty;\n\nmodule.exports = function defineProperty(obj, key, val) {\n  if (!isobject(obj) &amp;&amp; typeof obj !== &#039;function&#039; &amp;&amp; !Array.isArray(obj)) {\n    throw new TypeError(&#039;expected an object, function, or array&#039;);\n  }\n\n  if (typeof key !== &#039;string&#039;) {\n    throw new TypeError(&#039;expected \&quot;key\&quot; to be a string&#039;);\n  }\n\n  if (isDescriptor(val)) {\n    define(obj, key, val);\n    return obj;\n  }\n\n  define(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: val\n  });\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-regex/node_modules/define-property/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-regex/node_modules/extend-shallow/index.js&quot;:
/*!********************************************************************!*\
  !*** ./node_modules/to-regex/node_modules/extend-shallow/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isExtendable = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/to-regex/node_modules/is-extendable/index.js\&quot;);\nvar assignSymbols = __webpack_require__(/*! assign-symbols */ \&quot;./node_modules/assign-symbols/index.js\&quot;);\n\nmodule.exports = Object.assign || function(obj/*, objects*/) {\n  if (obj === null || typeof obj === &#039;undefined&#039;) {\n    throw new TypeError(&#039;Cannot convert undefined or null to object&#039;);\n  }\n  if (!isObject(obj)) {\n    obj = {};\n  }\n  for (var i = 1; i &lt; arguments.length; i++) {\n    var val = arguments[i];\n    if (isString(val)) {\n      val = toObject(val);\n    }\n    if (isObject(val)) {\n      assign(obj, val);\n      assignSymbols(obj, val);\n    }\n  }\n  return obj;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\nfunction isString(val) {\n  return (val &amp;&amp; typeof val === &#039;string&#039;);\n}\n\nfunction toObject(str) {\n  var obj = {};\n  for (var i in str) {\n    obj[i] = str[i];\n  }\n  return obj;\n}\n\nfunction isObject(val) {\n  return (val &amp;&amp; typeof val === &#039;object&#039;) || isExtendable(val);\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isEnum(obj, key) {\n  return Object.prototype.propertyIsEnumerable.call(obj, key);\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-regex/node_modules/extend-shallow/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/to-regex/node_modules/is-extendable/index.js&quot;:
/*!*******************************************************************!*\
  !*** ./node_modules/to-regex/node_modules/is-extendable/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * is-extendable &lt;https://github.com/jonschlinkert/is-extendable&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \&quot;./node_modules/is-plain-object/index.js\&quot;);\n\nmodule.exports = function isExtendable(val) {\n  return isPlainObject(val) || typeof val === &#039;function&#039; || Array.isArray(val);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/to-regex/node_modules/is-extendable/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/union-value/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/union-value/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;\n\nvar isObject = __webpack_require__(/*! is-extendable */ \&quot;./node_modules/is-extendable/index.js\&quot;);\nvar union = __webpack_require__(/*! arr-union */ \&quot;./node_modules/arr-union/index.js\&quot;);\nvar get = __webpack_require__(/*! get-value */ \&quot;./node_modules/get-value/index.js\&quot;);\nvar set = __webpack_require__(/*! set-value */ \&quot;./node_modules/set-value/index.js\&quot;);\n\nmodule.exports = function unionValue(obj, prop, value) {\n  if (!isObject(obj)) {\n    throw new TypeError(&#039;union-value expects the first argument to be an object.&#039;);\n  }\n\n  if (typeof prop !== &#039;string&#039;) {\n    throw new TypeError(&#039;union-value expects `prop` to be a string.&#039;);\n  }\n\n  var arr = arrayify(get(obj, prop));\n  set(obj, prop, union(arr, arrayify(value)));\n  return obj;\n};\n\nfunction arrayify(val) {\n  if (val === null || typeof val === &#039;undefined&#039;) {\n    return [];\n  }\n  if (Array.isArray(val)) {\n    return val;\n  }\n  return [val];\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/union-value/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/unset-value/index.js&quot;:
/*!*******************************************!*\
  !*** ./node_modules/unset-value/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * unset-value &lt;https://github.com/jonschlinkert/unset-value&gt;\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/isobject/index.js\&quot;);\nvar has = __webpack_require__(/*! has-value */ \&quot;./node_modules/unset-value/node_modules/has-value/index.js\&quot;);\n\nmodule.exports = function unset(obj, prop) {\n  if (!isObject(obj)) {\n    throw new TypeError(&#039;expected an object.&#039;);\n  }\n  if (obj.hasOwnProperty(prop)) {\n    delete obj[prop];\n    return true;\n  }\n\n  if (has(obj, prop)) {\n    var segs = prop.split(&#039;.&#039;);\n    var last = segs.pop();\n    while (segs.length &amp;&amp; segs[segs.length - 1].slice(-1) === &#039;\\\\&#039;) {\n      last = segs.pop().slice(0, -1) + &#039;.&#039; + last;\n    }\n    while (segs.length) obj = obj[prop = segs.shift()];\n    return (delete obj[last]);\n  }\n  return true;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/unset-value/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/unset-value/node_modules/has-value/index.js&quot;:
/*!******************************************************************!*\
  !*** ./node_modules/unset-value/node_modules/has-value/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * has-value &lt;https://github.com/jonschlinkert/has-value&gt;\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \&quot;./node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js\&quot;);\nvar hasValues = __webpack_require__(/*! has-values */ \&quot;./node_modules/unset-value/node_modules/has-values/index.js\&quot;);\nvar get = __webpack_require__(/*! get-value */ \&quot;./node_modules/get-value/index.js\&quot;);\n\nmodule.exports = function(obj, prop, noZero) {\n  if (isObject(obj)) {\n    return hasValues(get(obj, prop), noZero);\n  }\n  return hasValues(obj, prop);\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/unset-value/node_modules/has-value/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js&quot;:
/*!****************************************************************************************!*\
  !*** ./node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * isobject &lt;https://github.com/jonschlinkert/isobject&gt;\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nvar isArray = __webpack_require__(/*! isarray */ \&quot;./node_modules/isarray/index.js\&quot;);\n\nmodule.exports = function isObject(val) {\n  return val != null &amp;&amp; typeof val === &#039;object&#039; &amp;&amp; isArray(val) === false;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/unset-value/node_modules/has-value/node_modules/isobject/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/unset-value/node_modules/has-values/index.js&quot;:
/*!*******************************************************************!*\
  !*** ./node_modules/unset-value/node_modules/has-values/index.js ***!
  \*******************************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * has-values &lt;https://github.com/jonschlinkert/has-values&gt;\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nmodule.exports = function hasValue(o, noZero) {\n  if (o === null || o === undefined) {\n    return false;\n  }\n\n  if (typeof o === &#039;boolean&#039;) {\n    return true;\n  }\n\n  if (typeof o === &#039;number&#039;) {\n    if (o === 0 &amp;&amp; noZero === true) {\n      return false;\n    }\n    return true;\n  }\n\n  if (o.length !== undefined) {\n    return o.length !== 0;\n  }\n\n  for (var key in o) {\n    if (o.hasOwnProperty(key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/unset-value/node_modules/has-values/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/upath/build/code/upath.js&quot;:
/*!************************************************!*\
  !*** ./node_modules/upath/build/code/upath.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {

eval(&quot;/**\n* upath http://github.com/anodynos/upath/\n*\n* A proxy to `path`, replacing `\\` with `/` for all results &amp; new methods to normalize &amp; join keeping leading `./` and add, change, default, trim file extensions.\n* Version 1.2.0 - Compiled on 2019-09-02 23:33:57\n* Repository git://github.com/anodynos/upath\n* Copyright(c) 2019 Angelos Pikoulas &lt;agelos.pikoulas@gmail.com&gt;\n* License MIT\n*/\n\n// Generated by uRequire v0.7.0-beta.33 target: &#039;lib&#039; template: &#039;nodejs&#039;\n\n\nvar VERSION = &#039;1.2.0&#039;; // injected by urequire-rc-inject-version\n\nvar extraFn, extraFunctions, isFunction, isString, isValidExt, name, path, propName, propValue, toUnix, upath, slice = [].slice, indexOf = [].indexOf || function (item) {\n    for (var i = 0, l = this.length; i &lt; l; i++) {\n      if (i in this &amp;&amp; this[i] === item)\n        return i;\n    }\n    return -1;\n  }, hasProp = {}.hasOwnProperty;\npath = __webpack_require__(/*! path */ \&quot;path\&quot;);\nisFunction = function (val) {\n  return val instanceof Function;\n};\nisString = function (val) {\n  return typeof val === \&quot;string\&quot; || !!val &amp;&amp; typeof val === \&quot;object\&quot; &amp;&amp; Object.prototype.toString.call(val) === \&quot;[object String]\&quot;;\n};\nupath = exports;\nupath.VERSION = typeof VERSION !== \&quot;undefined\&quot; &amp;&amp; VERSION !== null ? VERSION : \&quot;NO-VERSION\&quot;;\ntoUnix = function (p) {\n  var double;\n  p = p.replace(/\\\\/g, \&quot;/\&quot;);\n  double = /\\/\\//;\n  while (p.match(double)) {\n    p = p.replace(double, \&quot;/\&quot;);\n  }\n  return p;\n};\nfor (propName in path) {\n  propValue = path[propName];\n  if (isFunction(propValue)) {\n    upath[propName] = function (propName) {\n      return function () {\n        var args, result;\n        args = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];\n        args = args.map(function (p) {\n          if (isString(p)) {\n            return toUnix(p);\n          } else {\n            return p;\n          }\n        });\n        result = path[propName].apply(path, args);\n        if (isString(result)) {\n          return toUnix(result);\n        } else {\n          return result;\n        }\n      };\n    }(propName);\n  } else {\n    upath[propName] = propValue;\n  }\n}\nupath.sep = \&quot;/\&quot;;\nextraFunctions = {\n  toUnix: toUnix,\n  normalizeSafe: function (p) {\n    p = toUnix(p);\n    if (p.startsWith(\&quot;./\&quot;)) {\n      if (p.startsWith(\&quot;./..\&quot;) || p === \&quot;./\&quot;) {\n        return upath.normalize(p);\n      } else {\n        return \&quot;./\&quot; + upath.normalize(p);\n      }\n    } else {\n      return upath.normalize(p);\n    }\n  },\n  normalizeTrim: function (p) {\n    p = upath.normalizeSafe(p);\n    if (p.endsWith(\&quot;/\&quot;)) {\n      return p.slice(0, +(p.length - 2) + 1 || 9000000000);\n    } else {\n      return p;\n    }\n  },\n  joinSafe: function () {\n    var p, result;\n    p = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];\n    result = upath.join.apply(null, p);\n    if (p[0].startsWith(\&quot;./\&quot;) &amp;&amp; !result.startsWith(\&quot;./\&quot;)) {\n      result = \&quot;./\&quot; + result;\n    }\n    return result;\n  },\n  addExt: function (file, ext) {\n    if (!ext) {\n      return file;\n    } else {\n      if (ext[0] !== \&quot;.\&quot;) {\n        ext = \&quot;.\&quot; + ext;\n      }\n      return file + (file.endsWith(ext) ? \&quot;\&quot; : ext);\n    }\n  },\n  trimExt: function (filename, ignoreExts, maxSize) {\n    var oldExt;\n    if (maxSize == null) {\n      maxSize = 7;\n    }\n    oldExt = upath.extname(filename);\n    if (isValidExt(oldExt, ignoreExts, maxSize)) {\n      return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9000000000);\n    } else {\n      return filename;\n    }\n  },\n  removeExt: function (filename, ext) {\n    if (!ext) {\n      return filename;\n    } else {\n      ext = ext[0] === \&quot;.\&quot; ? ext : \&quot;.\&quot; + ext;\n      if (upath.extname(filename) === ext) {\n        return upath.trimExt(filename);\n      } else {\n        return filename;\n      }\n    }\n  },\n  changeExt: function (filename, ext, ignoreExts, maxSize) {\n    if (maxSize == null) {\n      maxSize = 7;\n    }\n    return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? \&quot;\&quot; : ext[0] === \&quot;.\&quot; ? ext : \&quot;.\&quot; + ext);\n  },\n  defaultExt: function (filename, ext, ignoreExts, maxSize) {\n    var oldExt;\n    if (maxSize == null) {\n      maxSize = 7;\n    }\n    oldExt = upath.extname(filename);\n    if (isValidExt(oldExt, ignoreExts, maxSize)) {\n      return filename;\n    } else {\n      return upath.addExt(filename, ext);\n    }\n  }\n};\nisValidExt = function (ext, ignoreExts, maxSize) {\n  if (ignoreExts == null) {\n    ignoreExts = [];\n  }\n  return ext &amp;&amp; ext.length &lt;= maxSize &amp;&amp; indexOf.call(ignoreExts.map(function (e) {\n    return (e &amp;&amp; e[0] !== \&quot;.\&quot; ? \&quot;.\&quot; : \&quot;\&quot;) + e;\n  }), ext) &lt; 0;\n};\nfor (name in extraFunctions) {\n  if (!hasProp.call(extraFunctions, name))\n    continue;\n  extraFn = extraFunctions[name];\n  if (upath[name] !== void 0) {\n    throw new Error(\&quot;path.\&quot; + name + \&quot; already exists.\&quot;);\n  } else {\n    upath[name] = extraFn;\n  }\n}\n\n;\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/upath/build/code/upath.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/urix/index.js&quot;:
/*!************************************!*\
  !*** ./node_modules/urix/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;// Copyright 2014 Simon Lydell\r\n// X11 (“MIT”) Licensed. (See LICENSE.)\r\n\r\nvar path = __webpack_require__(/*! path */ \&quot;path\&quot;)\r\n\r\n\&quot;use strict\&quot;\r\n\r\nfunction urix(aPath) {\r\n  if (path.sep === \&quot;\\\\\&quot;) {\r\n    return aPath\r\n      .replace(/\\\\/g, \&quot;/\&quot;)\r\n      .replace(/^[a-z]:\\/?/i, \&quot;/\&quot;)\r\n  }\r\n  return aPath\r\n}\r\n\r\nmodule.exports = urix\r\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/urix/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/use/index.js&quot;:
/*!***********************************!*\
  !*** ./node_modules/use/index.js ***!
  \***********************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;/*!\n * use &lt;https://github.com/jonschlinkert/use&gt;\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function base(app, options) {\n  if (!isObject(app) &amp;&amp; typeof app !== &#039;function&#039;) {\n    throw new TypeError(&#039;expected an object or function&#039;);\n  }\n\n  var opts = isObject(options) ? options : {};\n  var prop = typeof opts.prop === &#039;string&#039; ? opts.prop : &#039;fns&#039;;\n  if (!Array.isArray(app[prop])) {\n    define(app, prop, []);\n  }\n\n  /**\n   * Define a plugin function to be passed to use. The only\n   * parameter exposed to the plugin is `app`, the object or function.\n   * passed to `use(app)`. `app` is also exposed as `this` in plugins.\n   *\n   * Additionally, **if a plugin returns a function, the function will\n   * be pushed onto the `fns` array**, allowing the plugin to be\n   * called at a later point by the `run` method.\n   *\n   * ```js\n   * var use = require(&#039;use&#039;);\n   *\n   * // define a plugin\n   * function foo(app) {\n   *   // do stuff\n   * }\n   *\n   * var app = function(){};\n   * use(app);\n   *\n   * // register plugins\n   * app.use(foo);\n   * app.use(bar);\n   * app.use(baz);\n   * ```\n   * @name .use\n   * @param {Function} `fn` plugin function to call\n   * @api public\n   */\n\n  define(app, &#039;use&#039;, use);\n\n  /**\n   * Run all plugins on `fns`. Any plugin that returns a function\n   * when called by `use` is pushed onto the `fns` array.\n   *\n   * ```js\n   * var config = {};\n   * app.run(config);\n   * ```\n   * @name .run\n   * @param {Object} `value` Object to be modified by plugins.\n   * @return {Object} Returns the object passed to `run`\n   * @api public\n   */\n\n  define(app, &#039;run&#039;, function(val) {\n    if (!isObject(val)) return;\n\n    if (!val.use || !val.run) {\n      define(val, prop, val[prop] || []);\n      define(val, &#039;use&#039;, use);\n    }\n\n    if (!val[prop] || val[prop].indexOf(base) === -1) {\n      val.use(base);\n    }\n\n    var self = this || app;\n    var fns = self[prop];\n    var len = fns.length;\n    var idx = -1;\n\n    while (++idx &lt; len) {\n      val.use(fns[idx]);\n    }\n    return val;\n  });\n\n  /**\n   * Call plugin `fn`. If a function is returned push it into the\n   * `fns` array to be called by the `run` method.\n   */\n\n  function use(type, fn, options) {\n    var offset = 1;\n\n    if (typeof type === &#039;string&#039; || Array.isArray(type)) {\n      fn = wrap(type, fn);\n      offset++;\n    } else {\n      options = fn;\n      fn = type;\n    }\n\n    if (typeof fn !== &#039;function&#039;) {\n      throw new TypeError(&#039;expected a function&#039;);\n    }\n\n    var self = this || app;\n    var fns = self[prop];\n\n    var args = [].slice.call(arguments, offset);\n    args.unshift(self);\n\n    if (typeof opts.hook === &#039;function&#039;) {\n      opts.hook.apply(self, args);\n    }\n\n    var val = fn.apply(self, args);\n    if (typeof val === &#039;function&#039; &amp;&amp; fns.indexOf(val) === -1) {\n      fns.push(val);\n    }\n    return self;\n  }\n\n  /**\n   * Wrap a named plugin function so that it&#039;s only called on objects of the\n   * given `type`\n   *\n   * @param {String} `type`\n   * @param {Function} `fn` Plugin function\n   * @return {Function}\n   */\n\n  function wrap(type, fn) {\n    return function plugin() {\n      return this.type === type ? fn.apply(this, arguments) : plugin;\n    };\n  }\n\n  return app;\n};\n\nfunction isObject(val) {\n  return val &amp;&amp; typeof val === &#039;object&#039; &amp;&amp; !Array.isArray(val);\n}\n\nfunction define(obj, key, val) {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    writable: true,\n    value: val\n  });\n}\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/use/index.js?&quot;);

/***/ }),

/***/ &quot;./node_modules/util-deprecate/node.js&quot;:
/*!*********************************************!*\
  !*** ./node_modules/util-deprecate/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {

eval(&quot;\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = __webpack_require__(/*! util */ \&quot;util\&quot;).deprecate;\n\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/util-deprecate/node.js?&quot;);

/***/ }),

/***/ &quot;assert&quot;:
/*!*************************!*\
  !*** external &quot;assert&quot; ***!
  \*************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;assert&quot;);

/***/ }),

/***/ &quot;buffer&quot;:
/*!*************************!*\
  !*** external &quot;buffer&quot; ***!
  \*************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;buffer&quot;);

/***/ }),

/***/ &quot;constants&quot;:
/*!****************************!*\
  !*** external &quot;constants&quot; ***!
  \****************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;constants&quot;);

/***/ }),

/***/ &quot;events&quot;:
/*!*************************!*\
  !*** external &quot;events&quot; ***!
  \*************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;events&quot;);

/***/ }),

/***/ &quot;fs&quot;:
/*!*********************!*\
  !*** external &quot;fs&quot; ***!
  \*********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;fs&quot;);

/***/ }),

/***/ &quot;net&quot;:
/*!**********************!*\
  !*** external &quot;net&quot; ***!
  \**********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;net&quot;);

/***/ }),

/***/ &quot;os&quot;:
/*!*********************!*\
  !*** external &quot;os&quot; ***!
  \*********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;os&quot;);

/***/ }),

/***/ &quot;path&quot;:
/*!***********************!*\
  !*** external &quot;path&quot; ***!
  \***********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;path&quot;);

/***/ }),

/***/ &quot;stream&quot;:
/*!*************************!*\
  !*** external &quot;stream&quot; ***!
  \*************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;stream&quot;);

/***/ }),

/***/ &quot;tty&quot;:
/*!**********************!*\
  !*** external &quot;tty&quot; ***!
  \**********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;tty&quot;);

/***/ }),

/***/ &quot;url&quot;:
/*!**********************!*\
  !*** external &quot;url&quot; ***!
  \**********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;url&quot;);

/***/ }),

/***/ &quot;util&quot;:
/*!***********************!*\
  !*** external &quot;util&quot; ***!
  \***********************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
module.exports = require(&quot;util&quot;);

/***/ }),

/***/ &quot;./node_modules/binary-extensions/binary-extensions.json&quot;:
/*!***************************************************************!*\
  !*** ./node_modules/binary-extensions/binary-extensions.json ***!
  \***************************************************************/
/***/ ((module) =&gt; {

&quot;use strict&quot;;
eval(&quot;module.exports = JSON.parse(&#039;[\&quot;3dm\&quot;,\&quot;3ds\&quot;,\&quot;3g2\&quot;,\&quot;3gp\&quot;,\&quot;7z\&quot;,\&quot;a\&quot;,\&quot;aac\&quot;,\&quot;adp\&quot;,\&quot;ai\&quot;,\&quot;aif\&quot;,\&quot;aiff\&quot;,\&quot;alz\&quot;,\&quot;ape\&quot;,\&quot;apk\&quot;,\&quot;ar\&quot;,\&quot;arj\&quot;,\&quot;asf\&quot;,\&quot;au\&quot;,\&quot;avi\&quot;,\&quot;bak\&quot;,\&quot;baml\&quot;,\&quot;bh\&quot;,\&quot;bin\&quot;,\&quot;bk\&quot;,\&quot;bmp\&quot;,\&quot;btif\&quot;,\&quot;bz2\&quot;,\&quot;bzip2\&quot;,\&quot;cab\&quot;,\&quot;caf\&quot;,\&quot;cgm\&quot;,\&quot;class\&quot;,\&quot;cmx\&quot;,\&quot;cpio\&quot;,\&quot;cr2\&quot;,\&quot;cur\&quot;,\&quot;dat\&quot;,\&quot;dcm\&quot;,\&quot;deb\&quot;,\&quot;dex\&quot;,\&quot;djvu\&quot;,\&quot;dll\&quot;,\&quot;dmg\&quot;,\&quot;dng\&quot;,\&quot;doc\&quot;,\&quot;docm\&quot;,\&quot;docx\&quot;,\&quot;dot\&quot;,\&quot;dotm\&quot;,\&quot;dra\&quot;,\&quot;DS_Store\&quot;,\&quot;dsk\&quot;,\&quot;dts\&quot;,\&quot;dtshd\&quot;,\&quot;dvb\&quot;,\&quot;dwg\&quot;,\&quot;dxf\&quot;,\&quot;ecelp4800\&quot;,\&quot;ecelp7470\&quot;,\&quot;ecelp9600\&quot;,\&quot;egg\&quot;,\&quot;eol\&quot;,\&quot;eot\&quot;,\&quot;epub\&quot;,\&quot;exe\&quot;,\&quot;f4v\&quot;,\&quot;fbs\&quot;,\&quot;fh\&quot;,\&quot;fla\&quot;,\&quot;flac\&quot;,\&quot;fli\&quot;,\&quot;flv\&quot;,\&quot;fpx\&quot;,\&quot;fst\&quot;,\&quot;fvt\&quot;,\&quot;g3\&quot;,\&quot;gh\&quot;,\&quot;gif\&quot;,\&quot;graffle\&quot;,\&quot;gz\&quot;,\&quot;gzip\&quot;,\&quot;h261\&quot;,\&quot;h263\&quot;,\&quot;h264\&quot;,\&quot;icns\&quot;,\&quot;ico\&quot;,\&quot;ief\&quot;,\&quot;img\&quot;,\&quot;ipa\&quot;,\&quot;iso\&quot;,\&quot;jar\&quot;,\&quot;jpeg\&quot;,\&quot;jpg\&quot;,\&quot;jpgv\&quot;,\&quot;jpm\&quot;,\&quot;jxr\&quot;,\&quot;key\&quot;,\&quot;ktx\&quot;,\&quot;lha\&quot;,\&quot;lib\&quot;,\&quot;lvp\&quot;,\&quot;lz\&quot;,\&quot;lzh\&quot;,\&quot;lzma\&quot;,\&quot;lzo\&quot;,\&quot;m3u\&quot;,\&quot;m4a\&quot;,\&quot;m4v\&quot;,\&quot;mar\&quot;,\&quot;mdi\&quot;,\&quot;mht\&quot;,\&quot;mid\&quot;,\&quot;midi\&quot;,\&quot;mj2\&quot;,\&quot;mka\&quot;,\&quot;mkv\&quot;,\&quot;mmr\&quot;,\&quot;mng\&quot;,\&quot;mobi\&quot;,\&quot;mov\&quot;,\&quot;movie\&quot;,\&quot;mp3\&quot;,\&quot;mp4\&quot;,\&quot;mp4a\&quot;,\&quot;mpeg\&quot;,\&quot;mpg\&quot;,\&quot;mpga\&quot;,\&quot;mxu\&quot;,\&quot;nef\&quot;,\&quot;npx\&quot;,\&quot;numbers\&quot;,\&quot;nupkg\&quot;,\&quot;o\&quot;,\&quot;oga\&quot;,\&quot;ogg\&quot;,\&quot;ogv\&quot;,\&quot;otf\&quot;,\&quot;pages\&quot;,\&quot;pbm\&quot;,\&quot;pcx\&quot;,\&quot;pdb\&quot;,\&quot;pdf\&quot;,\&quot;pea\&quot;,\&quot;pgm\&quot;,\&quot;pic\&quot;,\&quot;png\&quot;,\&quot;pnm\&quot;,\&quot;pot\&quot;,\&quot;potm\&quot;,\&quot;potx\&quot;,\&quot;ppa\&quot;,\&quot;ppam\&quot;,\&quot;ppm\&quot;,\&quot;pps\&quot;,\&quot;ppsm\&quot;,\&quot;ppsx\&quot;,\&quot;ppt\&quot;,\&quot;pptm\&quot;,\&quot;pptx\&quot;,\&quot;psd\&quot;,\&quot;pya\&quot;,\&quot;pyc\&quot;,\&quot;pyo\&quot;,\&quot;pyv\&quot;,\&quot;qt\&quot;,\&quot;rar\&quot;,\&quot;ras\&quot;,\&quot;raw\&quot;,\&quot;resources\&quot;,\&quot;rgb\&quot;,\&quot;rip\&quot;,\&quot;rlc\&quot;,\&quot;rmf\&quot;,\&quot;rmvb\&quot;,\&quot;rtf\&quot;,\&quot;rz\&quot;,\&quot;s3m\&quot;,\&quot;s7z\&quot;,\&quot;scpt\&quot;,\&quot;sgi\&quot;,\&quot;shar\&quot;,\&quot;sil\&quot;,\&quot;sketch\&quot;,\&quot;slk\&quot;,\&quot;smv\&quot;,\&quot;snk\&quot;,\&quot;so\&quot;,\&quot;stl\&quot;,\&quot;suo\&quot;,\&quot;sub\&quot;,\&quot;swf\&quot;,\&quot;tar\&quot;,\&quot;tbz\&quot;,\&quot;tbz2\&quot;,\&quot;tga\&quot;,\&quot;tgz\&quot;,\&quot;thmx\&quot;,\&quot;tif\&quot;,\&quot;tiff\&quot;,\&quot;tlz\&quot;,\&quot;ttc\&quot;,\&quot;ttf\&quot;,\&quot;txz\&quot;,\&quot;udf\&quot;,\&quot;uvh\&quot;,\&quot;uvi\&quot;,\&quot;uvm\&quot;,\&quot;uvp\&quot;,\&quot;uvs\&quot;,\&quot;uvu\&quot;,\&quot;viv\&quot;,\&quot;vob\&quot;,\&quot;war\&quot;,\&quot;wav\&quot;,\&quot;wax\&quot;,\&quot;wbmp\&quot;,\&quot;wdp\&quot;,\&quot;weba\&quot;,\&quot;webm\&quot;,\&quot;webp\&quot;,\&quot;whl\&quot;,\&quot;wim\&quot;,\&quot;wm\&quot;,\&quot;wma\&quot;,\&quot;wmv\&quot;,\&quot;wmx\&quot;,\&quot;woff\&quot;,\&quot;woff2\&quot;,\&quot;wrm\&quot;,\&quot;wvx\&quot;,\&quot;xbm\&quot;,\&quot;xif\&quot;,\&quot;xla\&quot;,\&quot;xlam\&quot;,\&quot;xls\&quot;,\&quot;xlsb\&quot;,\&quot;xlsm\&quot;,\&quot;xlsx\&quot;,\&quot;xlt\&quot;,\&quot;xltm\&quot;,\&quot;xltx\&quot;,\&quot;xm\&quot;,\&quot;xmind\&quot;,\&quot;xpi\&quot;,\&quot;xpm\&quot;,\&quot;xwd\&quot;,\&quot;xz\&quot;,\&quot;z\&quot;,\&quot;zip\&quot;,\&quot;zipx\&quot;]&#039;);\n\n//# sourceURL=webpack://@nicolo-ribaudo/chokidar-2/./node_modules/binary-extensions/binary-extensions.json?&quot;);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can&#039;t be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__(&quot;./chokidar/index.js&quot;);
/******/ 	
/******/ })()
;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
