<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ace-builds/src-noconflict/worker-yaml.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ace-builds/src-noconflict/worker-yaml.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">5820</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">241.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">88.50</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;no use strict&quot;;
!(function(window) {
if (typeof window.window != &quot;undefined&quot; &amp;&amp; window.document)
    return;
if (window.require &amp;&amp; window.define)
    return;

if (!window.console) {
    window.console = function() {
        var msgs = Array.prototype.slice.call(arguments, 0);
        postMessage({type: &quot;log&quot;, data: msgs});
    };
    window.console.error =
    window.console.warn = 
    window.console.log =
    window.console.trace = window.console;
}
window.window = window;
window.ace = window;

window.onerror = function(message, file, line, col, err) {
    postMessage({type: &quot;error&quot;, data: {
        message: message,
        data: err &amp;&amp; err.data,
        file: file,
        line: line, 
        col: col,
        stack: err &amp;&amp; err.stack
    }});
};

window.normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf(&quot;!&quot;) !== -1) {
        var chunks = moduleName.split(&quot;!&quot;);
        return window.normalizeModule(parentId, chunks[0]) + &quot;!&quot; + window.normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == &quot;.&quot;) {
        var base = parentId.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;);
        moduleName = (base ? base + &quot;/&quot; : &quot;&quot;) + moduleName;
        
        while (moduleName.indexOf(&quot;.&quot;) !== -1 &amp;&amp; previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/^\.\//, &quot;&quot;).replace(/\/\.\//, &quot;/&quot;).replace(/[^\/]+\/\.\.\//, &quot;&quot;);
        }
    }
    
    return moduleName;
};

window.require = function require(parentId, id) {
    if (!id) {
        id = parentId;
        parentId = null;
    }
    if (!id.charAt)
        throw new Error(&quot;worker.js require() accepts only (parentId, id) as arguments&quot;);

    id = window.normalizeModule(parentId, id);

    var module = window.require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.initialized = true;
            module.exports = module.factory().exports;
        }
        return module.exports;
    }
   
    if (!window.require.tlns)
        return console.log(&quot;unable to load &quot; + id);
    
    var path = resolveModuleId(id, window.require.tlns);
    if (path.slice(-3) != &quot;.js&quot;) path += &quot;.js&quot;;
    
    window.require.id = id;
    window.require.modules[id] = {}; // prevent infinite loop on broken modules
    importScripts(path);
    return window.require(parentId, id);
};
function resolveModuleId(id, paths) {
    var testPath = id, tail = &quot;&quot;;
    while (testPath) {
        var alias = paths[testPath];
        if (typeof alias == &quot;string&quot;) {
            return alias + tail;
        } else if (alias) {
            return  alias.location.replace(/\/*$/, &quot;/&quot;) + (tail || alias.main || alias.name);
        } else if (alias === false) {
            return &quot;&quot;;
        }
        var i = testPath.lastIndexOf(&quot;/&quot;);
        if (i === -1) break;
        tail = testPath.substr(i) + tail;
        testPath = testPath.slice(0, i);
    }
    return id;
}
window.require.modules = {};
window.require.tlns = {};

window.define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
        if (typeof id != &quot;string&quot;) {
            deps = id;
            id = window.require.id;
        }
    } else if (arguments.length == 1) {
        factory = id;
        deps = [];
        id = window.require.id;
    }
    
    if (typeof factory != &quot;function&quot;) {
        window.require.modules[id] = {
            exports: factory,
            initialized: true
        };
        return;
    }

    if (!deps.length)
        // If there is no dependencies, we inject &quot;require&quot;, &quot;exports&quot; and
        // &quot;module&quot; as dependencies, to provide CommonJS compatibility.
        deps = [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;];

    var req = function(childId) {
        return window.require(id, childId);
    };

    window.require.modules[id] = {
        exports: {},
        factory: function() {
            var module = this;
            var returnExports = factory.apply(this, deps.slice(0, factory.length).map(function(dep) {
                switch (dep) {
                    // Because &quot;require&quot;, &quot;exports&quot; and &quot;module&quot; aren&#039;t actual
                    // dependencies, we must handle them seperately.
                    case &quot;require&quot;: return req;
                    case &quot;exports&quot;: return module.exports;
                    case &quot;module&quot;:  return module;
                    // But for all other dependencies, we can just go ahead and
                    // require them.
                    default:        return req(dep);
                }
            }));
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};
window.define.amd = {};
window.require.tlns = {};
window.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {
    for (var i in topLevelNamespaces)
        this.require.tlns[i] = topLevelNamespaces[i];
};

window.initSender = function initSender() {

    var EventEmitter = window.require(&quot;ace/lib/event_emitter&quot;).EventEmitter;
    var oop = window.require(&quot;ace/lib/oop&quot;);
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: &quot;call&quot;,
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: &quot;event&quot;,
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
};

var main = window.main = null;
var sender = window.sender = null;

window.onmessage = function(e) {
    var msg = e.data;
    if (msg.event &amp;&amp; sender) {
        sender._signal(msg.event, msg.data);
    }
    else if (msg.command) {
        if (main[msg.command])
            main[msg.command].apply(main, msg.args);
        else if (window[msg.command])
            window[msg.command].apply(window, msg.args);
        else
            throw new Error(&quot;Unknown command:&quot; + msg.command);
    }
    else if (msg.init) {
        window.initBaseUrls(msg.tlns);
        sender = window.sender = window.initSender();
        var clazz = this.require(msg.module)[msg.classname];
        main = window.main = new clazz(sender);
    }
};
})(this);

ace.define(&quot;ace/lib/oop&quot;,[], function(require, exports, module){&quot;use strict&quot;;
exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};
exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};
exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
};

});

ace.define(&quot;ace/apply_delta&quot;,[], function(require, exports, module){&quot;use strict&quot;;
function throwDeltaError(delta, errorText) {
    console.log(&quot;Invalid Delta:&quot;, delta);
    throw &quot;Invalid Delta: &quot; + errorText;
}
function positionInDocument(docLines, position) {
    return position.row &gt;= 0 &amp;&amp; position.row &lt; docLines.length &amp;&amp;
        position.column &gt;= 0 &amp;&amp; position.column &lt;= docLines[position.row].length;
}
function validateDelta(docLines, delta) {
    if (delta.action != &quot;insert&quot; &amp;&amp; delta.action != &quot;remove&quot;)
        throwDeltaError(delta, &quot;delta.action must be &#039;insert&#039; or &#039;remove&#039;&quot;);
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, &quot;delta.lines must be an Array&quot;);
    if (!delta.start || !delta.end)
        throwDeltaError(delta, &quot;delta.start/end must be an present&quot;);
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, &quot;delta.start must be contained in document&quot;);
    var end = delta.end;
    if (delta.action == &quot;remove&quot; &amp;&amp; !positionInDocument(docLines, end))
        throwDeltaError(delta, &quot;delta.end must contained in document for &#039;remove&#039; actions&quot;);
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, &quot;delta.range must match delta lines&quot;);
}
exports.applyDelta = function (docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || &quot;&quot;;
    switch (delta.action) {
        case &quot;insert&quot;:
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            }
            else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case &quot;remove&quot;:
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            }
            else {
                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
    }
};

});

ace.define(&quot;ace/lib/event_emitter&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var EventEmitter = {};
var stopPropagation = function () { this.propagationStopped = true; };
var preventDefault = function () { this.defaultPrevented = true; };
EventEmitter._emit =
    EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length &amp;&amp; !defaultHandler)
            return;
        if (typeof e != &quot;object&quot; || !e)
            e = {};
        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i &lt; listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        if (defaultHandler &amp;&amp; !e.defaultPrevented)
            return defaultHandler(e, this);
    };
EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0; i &lt; listeners.length; i++)
        listeners[i](e, this);
};
EventEmitter.once = function (eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        return new Promise(function (resolve) {
            callback = resolve;
        });
    }
};
EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = { _disabled_: {} };
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    }
    else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};
EventEmitter.on =
    EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? &quot;unshift&quot; : &quot;push&quot;](callback);
        return callback;
    };
EventEmitter.off =
    EventEmitter.removeListener =
        EventEmitter.removeEventListener = function (eventName, callback) {
            this._eventRegistry = this._eventRegistry || {};
            var listeners = this._eventRegistry[eventName];
            if (!listeners)
                return;
            var index = listeners.indexOf(callback);
            if (index !== -1)
                listeners.splice(index, 1);
        };
EventEmitter.removeAllListeners = function (eventName) {
    if (!eventName)
        this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry)
        this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers)
        this._defaultHandlers[eventName] = undefined;
};
exports.EventEmitter = EventEmitter;

});

ace.define(&quot;ace/range&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var Range = /** @class */ (function () {
    function Range(startRow, startColumn, endRow, endColumn) {
        this.start = {
            row: startRow,
            column: startColumn
        };
        this.end = {
            row: endRow,
            column: endColumn
        };
    }
    Range.prototype.isEqual = function (range) {
        return this.start.row === range.start.row &amp;&amp;
            this.end.row === range.end.row &amp;&amp;
            this.start.column === range.start.column &amp;&amp;
            this.end.column === range.end.column;
    };
    Range.prototype.toString = function () {
        return (&quot;Range: [&quot; + this.start.row + &quot;/&quot; + this.start.column +
            &quot;] -&gt; [&quot; + this.end.row + &quot;/&quot; + this.end.column + &quot;]&quot;);
    };
    Range.prototype.contains = function (row, column) {
        return this.compare(row, column) == 0;
    };
    Range.prototype.compareRange = function (range) {
        var cmp, end = range.end, start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            }
            else if (cmp == 0) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else if (cmp == -1) {
            return -2;
        }
        else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            }
            else if (cmp == 1) {
                return 42;
            }
            else {
                return 0;
            }
        }
    };
    Range.prototype.comparePoint = function (p) {
        return this.compare(p.row, p.column);
    };
    Range.prototype.containsRange = function (range) {
        return this.comparePoint(range.start) == 0 &amp;&amp; this.comparePoint(range.end) == 0;
    };
    Range.prototype.intersects = function (range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    Range.prototype.isEnd = function (row, column) {
        return this.end.row == row &amp;&amp; this.end.column == column;
    };
    Range.prototype.isStart = function (row, column) {
        return this.start.row == row &amp;&amp; this.start.column == column;
    };
    Range.prototype.setStart = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.start.column = row.column;
            this.start.row = row.row;
        }
        else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    Range.prototype.setEnd = function (row, column) {
        if (typeof row == &quot;object&quot;) {
            this.end.column = row.column;
            this.end.row = row.row;
        }
        else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    Range.prototype.inside = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Range.prototype.insideStart = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Range.prototype.insideEnd = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Range.prototype.compare = function (row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column &lt; this.start.column ? -1 : (column &gt; this.end.column ? 1 : 0);
            }
        }
        if (row &lt; this.start.row)
            return -1;
        if (row &gt; this.end.row)
            return 1;
        if (this.start.row === row)
            return column &gt;= this.start.column ? 0 : -1;
        if (this.end.row === row)
            return column &lt;= this.end.column ? 0 : 1;
        return 0;
    };
    Range.prototype.compareStart = function (row, column) {
        if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    Range.prototype.compareEnd = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else {
            return this.compare(row, column);
        }
    };
    Range.prototype.compareInside = function (row, column) {
        if (this.end.row == row &amp;&amp; this.end.column == column) {
            return 1;
        }
        else if (this.start.row == row &amp;&amp; this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    Range.prototype.clipRows = function (firstRow, lastRow) {
        if (this.end.row &gt; lastRow)
            var end = { row: lastRow + 1, column: 0 };
        else if (this.end.row &lt; firstRow)
            var end = { row: firstRow, column: 0 };
        if (this.start.row &gt; lastRow)
            var start = { row: lastRow + 1, column: 0 };
        else if (this.start.row &lt; firstRow)
            var start = { row: firstRow, column: 0 };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    Range.prototype.extend = function (row, column) {
        var cmp = this.compare(row, column);
        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = { row: row, column: column };
        else
            var end = { row: row, column: column };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    Range.prototype.isEmpty = function () {
        return (this.start.row === this.end.row &amp;&amp; this.start.column === this.end.column);
    };
    Range.prototype.isMultiLine = function () {
        return (this.start.row !== this.end.row);
    };
    Range.prototype.clone = function () {
        return Range.fromPoints(this.start, this.end);
    };
    Range.prototype.collapseRows = function () {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    Range.prototype.toScreenRange = function (session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };
    Range.prototype.moveBy = function (row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };
    return Range;
}());
Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
exports.Range = Range;

});

ace.define(&quot;ace/anchor&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Anchor = /** @class */ (function () {
    function Anchor(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);
        if (typeof row != &quot;number&quot;)
            this.setPosition(row.row, row.column);
        else
            this.setPosition(row, column);
    }
    Anchor.prototype.getPosition = function () {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    Anchor.prototype.getDocument = function () {
        return this.document;
    };
    Anchor.prototype.onChange = function (delta) {
        if (delta.start.row == delta.end.row &amp;&amp; delta.start.row != this.row)
            return;
        if (delta.start.row &gt; this.row)
            return;
        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    Anchor.prototype.setPosition = function (row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        if (this.row == pos.row &amp;&amp; this.column == pos.column)
            return;
        var old = {
            row: this.row,
            column: this.column
        };
        this.row = pos.row;
        this.column = pos.column;
        this._signal(&quot;change&quot;, {
            old: old,
            value: pos
        });
    };
    Anchor.prototype.detach = function () {
        this.document.off(&quot;change&quot;, this.$onChange);
    };
    Anchor.prototype.attach = function (doc) {
        this.document = doc || this.document;
        this.document.on(&quot;change&quot;, this.$onChange);
    };
    Anchor.prototype.$clipPositionToDocument = function (row, column) {
        var pos = {};
        if (row &gt;= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row &lt; 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column &lt; 0)
            pos.column = 0;
        return pos;
    };
    return Anchor;
}());
Anchor.prototype.$insertRight = false;
oop.implement(Anchor.prototype, EventEmitter);
function $pointsInOrder(point1, point2, equalPointsInOrder) {
    var bColIsAfter = equalPointsInOrder ? point1.column &lt;= point2.column : point1.column &lt; point2.column;
    return (point1.row &lt; point2.row) || (point1.row == point2.row &amp;&amp; bColIsAfter);
}
function $getTransformedPoint(delta, point, moveIfEqual) {
    var deltaIsInsert = delta.action == &quot;insert&quot;;
    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
    var deltaStart = delta.start;
    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
            row: point.row,
            column: point.column
        };
    }
    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
    }
    return {
        row: deltaStart.row,
        column: deltaStart.column
    };
}
exports.Anchor = Anchor;

});

ace.define(&quot;ace/document&quot;,[], function(require, exports, module){&quot;use strict&quot;;
var oop = require(&quot;./lib/oop&quot;);
var applyDelta = require(&quot;./apply_delta&quot;).applyDelta;
var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
var Range = require(&quot;./range&quot;).Range;
var Anchor = require(&quot;./anchor&quot;).Anchor;
var Document = /** @class */ (function () {
    function Document(textOrLines) {
        this.$lines = [&quot;&quot;];
        if (textOrLines.length === 0) {
            this.$lines = [&quot;&quot;];
        }
        else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
        }
        else {
            this.insert({ row: 0, column: 0 }, textOrLines);
        }
    }
    Document.prototype.setValue = function (text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({ row: 0, column: 0 }, text || &quot;&quot;);
    };
    Document.prototype.getValue = function () {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    Document.prototype.createAnchor = function (row, column) {
        return new Anchor(this, row, column);
    };
    Document.prototype.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : &quot;\n&quot;;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    Document.prototype.getNewLineCharacter = function () {
        switch (this.$newLineMode) {
            case &quot;windows&quot;:
                return &quot;\r\n&quot;;
            case &quot;unix&quot;:
                return &quot;\n&quot;;
            default:
                return this.$autoNewLine || &quot;\n&quot;;
        }
    };
    Document.prototype.setNewLineMode = function (newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;
        this.$newLineMode = newLineMode;
        this._signal(&quot;changeNewLineMode&quot;);
    };
    Document.prototype.getNewLineMode = function () {
        return this.$newLineMode;
    };
    Document.prototype.isNewLine = function (text) {
        return (text == &quot;\r\n&quot; || text == &quot;\r&quot; || text == &quot;\n&quot;);
    };
    Document.prototype.getLine = function (row) {
        return this.$lines[row] || &quot;&quot;;
    };
    Document.prototype.getLines = function (firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    Document.prototype.getAllLines = function () {
        return this.getLines(0, this.getLength());
    };
    Document.prototype.getLength = function () {
        return this.$lines.length;
    };
    Document.prototype.getTextRange = function (range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    Document.prototype.getLinesForRange = function (range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        }
        else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || &quot;&quot;).substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    Document.prototype.insertLines = function (row, lines) {
        console.warn(&quot;Use of document.insertLines is deprecated. Use the insertFullLines method instead.&quot;);
        return this.insertFullLines(row, lines);
    };
    Document.prototype.removeLines = function (firstRow, lastRow) {
        console.warn(&quot;Use of document.removeLines is deprecated. Use the removeFullLines method instead.&quot;);
        return this.removeFullLines(firstRow, lastRow);
    };
    Document.prototype.insertNewLine = function (position) {
        console.warn(&quot;Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [&#039;&#039;, &#039;&#039;]) instead.&quot;);
        return this.insertMergedLines(position, [&quot;&quot;, &quot;&quot;]);
    };
    Document.prototype.insert = function (position, text) {
        if (this.getLength() &lt;= 1)
            this.$detectNewLine(text);
        return this.insertMergedLines(position, this.$split(text));
    };
    Document.prototype.insertInLine = function (position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: [text]
        }, true);
        return this.clonePos(end);
    };
    Document.prototype.clippedPos = function (row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        }
        else if (row &lt; 0) {
            row = 0;
        }
        else if (row &gt;= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return { row: row, column: column };
    };
    Document.prototype.clonePos = function (pos) {
        return { row: pos.row, column: pos.column };
    };
    Document.prototype.pos = function (row, column) {
        return { row: row, column: column };
    };
    Document.prototype.$clipPosition = function (position) {
        var length = this.getLength();
        if (position.row &gt;= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        }
        else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    Document.prototype.insertFullLines = function (row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row &lt; this.getLength()) {
            lines = lines.concat([&quot;&quot;]);
            column = 0;
        }
        else {
            lines = [&quot;&quot;].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({ row: row, column: column }, lines);
    };
    Document.prototype.insertMergedLines = function (position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;insert&quot;,
            lines: lines
        });
        return this.clonePos(end);
    };
    Document.prototype.remove = function (range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        });
        return this.clonePos(start);
    };
    Document.prototype.removeInLine = function (row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
            start: start,
            end: end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange({ start: start, end: end })
        }, true);
        return this.clonePos(start);
    };
    Document.prototype.removeFullLines = function (firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 &amp;&amp; firstRow &gt; 0;
        var deleteLastNewLine = lastRow &lt; this.getLength() - 1;
        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: &quot;remove&quot;,
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    Document.prototype.removeNewLine = function (row) {
        if (row &lt; this.getLength() - 1 &amp;&amp; row &gt;= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: &quot;remove&quot;,
                lines: [&quot;&quot;, &quot;&quot;]
            });
        }
    };
    Document.prototype.replace = function (range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 &amp;&amp; range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;
        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        return end;
    };
    Document.prototype.applyDeltas = function (deltas) {
        for (var i = 0; i &lt; deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    Document.prototype.revertDeltas = function (deltas) {
        for (var i = deltas.length - 1; i &gt;= 0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    Document.prototype.applyDelta = function (delta, doNotValidate) {
        var isInsert = delta.action == &quot;insert&quot;;
        if (isInsert ? delta.lines.length &lt;= 1 &amp;&amp; !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        if (isInsert &amp;&amp; delta.lines.length &gt; 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal(&quot;change&quot;, delta);
        }
    };
    Document.prototype.$safeApplyDelta = function (delta) {
        var docLength = this.$lines.length;
        if (delta.action == &quot;remove&quot; &amp;&amp; delta.start.row &lt; docLength &amp;&amp; delta.end.row &lt; docLength
            || delta.action == &quot;insert&quot; &amp;&amp; delta.start.row &lt;= docLength) {
            this.applyDelta(delta);
        }
    };
    Document.prototype.$splitAndapplyLargeDelta = function (delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row;
        var column = delta.start.column;
        for (var from = 0, to = 0; from &lt; l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push(&quot;&quot;);
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    Document.prototype.revertDelta = function (delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == &quot;insert&quot; ? &quot;remove&quot; : &quot;insert&quot;),
            lines: delta.lines.slice()
        });
    };
    Document.prototype.indexToPosition = function (index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i &lt; l; i++) {
            index -= lines[i].length + newlineLength;
            if (index &lt; 0)
                return { row: i, column: index + lines[i].length + newlineLength };
        }
        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
    };
    Document.prototype.positionToIndex = function (pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i &lt; row; ++i)
            index += lines[i].length + newlineLength;
        return index + pos.column;
    };
    Document.prototype.$split = function (text) {
        return text.split(/\r\n|\r|\n/);
    };
    return Document;
}());
Document.prototype.$autoNewLine = &quot;&quot;;
Document.prototype.$newLineMode = &quot;auto&quot;;
oop.implement(Document.prototype, EventEmitter);
exports.Document = Document;

});

ace.define(&quot;ace/lib/deep_copy&quot;,[], function(require, exports, module){exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== &quot;object&quot; || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key &lt; obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== &quot;[object Object]&quot;)
        return obj;
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

});

ace.define(&quot;ace/lib/lang&quot;,[], function(require, exports, module){&quot;use strict&quot;;
exports.last = function (a) {
    return a[a.length - 1];
};
exports.stringReverse = function (string) {
    return string.split(&quot;&quot;).reverse().join(&quot;&quot;);
};
exports.stringRepeat = function (string, count) {
    var result = &#039;&#039;;
    while (count &gt; 0) {
        if (count &amp; 1)
            result += string;
        if (count &gt;&gt;= 1)
            string += string;
    }
    return result;
};
var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;
exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, &#039;&#039;);
};
exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, &#039;&#039;);
};
exports.copyObject = function (obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};
exports.copyArray = function (array) {
    var copy = [];
    for (var i = 0, l = array.length; i &lt; l; i++) {
        if (array[i] &amp;&amp; typeof array[i] == &quot;object&quot;)
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};
exports.deepCopy = require(&quot;./deep_copy&quot;).deepCopy;
exports.arrayToMap = function (arr) {
    var map = {};
    for (var i = 0; i &lt; arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;
};
exports.createMap = function (props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function (array, value) {
    for (var i = 0; i &lt;= array.length; i++) {
        if (value === array[i]) {
            array.splice(i, 1);
        }
    }
};
exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, &#039;\\$1&#039;);
};
exports.escapeHTML = function (str) {
    return (&quot;&quot; + str).replace(/&amp;/g, &quot;&amp;#38;&quot;).replace(/&quot;/g, &quot;&amp;#34;&quot;).replace(/&#039;/g, &quot;&amp;#39;&quot;).replace(/&lt;/g, &quot;&amp;#60;&quot;);
};
exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
        matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
        });
    });
    return matches;
};
exports.deferredCall = function (fcn) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var deferred = function (timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };
    deferred.schedule = deferred;
    deferred.call = function () {
        this.cancel();
        fcn();
        return deferred;
    };
    deferred.cancel = function () {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    deferred.isPending = function () {
        return timer;
    };
    return deferred;
};
exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var _self = function (timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.delay = function (timeout) {
        timer &amp;&amp; clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;
    _self.call = function () {
        this.cancel();
        fcn();
    };
    _self.cancel = function () {
        timer &amp;&amp; clearTimeout(timer);
        timer = null;
    };
    _self.isPending = function () {
        return timer;
    };
    return _self;
};
exports.supportsLookbehind = function () {
    try {
        new RegExp(&#039;(?&lt;=.)&#039;);
    }
    catch (e) {
        return false;
    }
    return true;
};
exports.skipEmptyMatch = function (line, last, supportsUnicodeFlag) {
    return supportsUnicodeFlag &amp;&amp; line.codePointAt(last) &gt; 0xffff ? 2 : 1;
};

});

ace.define(&quot;ace/worker/mirror&quot;,[], function(require, exports, module) {
&quot;use strict&quot;;

var Document = require(&quot;../document&quot;).Document;
var lang = require(&quot;../lib/lang&quot;);
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document(&quot;&quot;);
    
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on(&quot;change&quot;, function(e) {
        var data = e.data;
        if (data[0].start) {
            doc.applyDeltas(data);
        } else {
            for (var i = 0; i &lt; data.length; i += 2) {
                var d, err; 
                if (Array.isArray(data[i+1])) {
                    d = {action: &quot;insert&quot;, start: data[i], lines: data[i+1]};
                } else {
                    d = {action: &quot;remove&quot;, start: data[i], end: data[i+1]};
                }
                
                if ((d.action == &quot;insert&quot; ? d.start : d.end).row &gt;= doc.$lines.length) {
                    err = new Error(&quot;Invalid delta&quot;);
                    err.data = {
                        path: _self.$path,
                        linesLength: doc.$lines.length,
                        start: d.start,
                        end: d.end
                    };
                    throw err;
                }

                doc.applyDelta(d, true);
            }
        }
        if (_self.$timeout)
            return deferredUpdate.schedule(_self.$timeout);
        _self.onUpdate();
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
    };
    
    this.isPending = function() {
        return this.deferredUpdate.isPending();
    };
    
}).call(Mirror.prototype);

});

ace.define(&quot;ace/mode/yaml/yaml-lint&quot;,[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == &quot;function&quot;) {
        m = name; deps = [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]; name = $build_deps$.module.id
    }
    if (typeof name !== &quot;string&quot;) {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
   var ret = typeof m == &quot;function&quot; ?
       m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
   if (ret != undefined) $build_deps$.module.exports = ret;
}
define.amd = true;(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f();}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f);}else{var g;if(typeof window!==&quot;undefined&quot;){g=window;}else if(typeof global!==&quot;undefined&quot;){g=global;}else if(typeof self!==&quot;undefined&quot;){g=self;}else{g=this;}g.lint = f();}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=typeof require==&quot;function&quot;&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module &#039;&quot;+i+&quot;&#039;&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u=typeof require==&quot;function&quot;&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o;}return r;})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
var fs = require(&#039;fs&#039;);
var merge = require(&#039;lodash.merge&#039;);
var yaml = require(&#039;js-yaml&#039;);

var DEFAULT_LINT_OPTION = {
  schema: &#039;DEFAULT_SAFE_SCHEMA&#039;
};

function lint(content, opts, cb) {

  var options = merge({}, DEFAULT_LINT_OPTION, opts);
  try {
    yaml.safeLoad(content, {
      schema: yaml[options.schema]
    });
    cb();
  } catch (e) {
    cb(e);
  }
}

module.exports = {
  lint: lint
};

},{&quot;fs&quot;:1,&quot;js-yaml&quot;:3,&quot;lodash.merge&quot;:33}],3:[function(require,module,exports){
&#039;use strict&#039;;


var yaml = require(&#039;./lib/js-yaml.js&#039;);


module.exports = yaml;

},{&quot;./lib/js-yaml.js&quot;:4}],4:[function(require,module,exports){
&#039;use strict&#039;;


var loader = require(&#039;./js-yaml/loader&#039;);
var dumper = require(&#039;./js-yaml/dumper&#039;);


function deprecated(name) {
  return function () {
    throw new Error(&#039;Function &#039; + name + &#039; is deprecated and cannot be used.&#039;);
  };
}


module.exports.Type                = require(&#039;./js-yaml/type&#039;);
module.exports.Schema              = require(&#039;./js-yaml/schema&#039;);
module.exports.FAILSAFE_SCHEMA     = require(&#039;./js-yaml/schema/failsafe&#039;);
module.exports.JSON_SCHEMA         = require(&#039;./js-yaml/schema/json&#039;);
module.exports.CORE_SCHEMA         = require(&#039;./js-yaml/schema/core&#039;);
module.exports.DEFAULT_SAFE_SCHEMA = require(&#039;./js-yaml/schema/default_safe&#039;);
module.exports.DEFAULT_FULL_SCHEMA = require(&#039;./js-yaml/schema/default_full&#039;);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require(&#039;./js-yaml/exception&#039;);
module.exports.MINIMAL_SCHEMA = require(&#039;./js-yaml/schema/failsafe&#039;);
module.exports.SAFE_SCHEMA    = require(&#039;./js-yaml/schema/default_safe&#039;);
module.exports.DEFAULT_SCHEMA = require(&#039;./js-yaml/schema/default_full&#039;);
module.exports.scan           = deprecated(&#039;scan&#039;);
module.exports.parse          = deprecated(&#039;parse&#039;);
module.exports.compose        = deprecated(&#039;compose&#039;);
module.exports.addConstructor = deprecated(&#039;addConstructor&#039;);

},{&quot;./js-yaml/dumper&quot;:6,&quot;./js-yaml/exception&quot;:7,&quot;./js-yaml/loader&quot;:8,&quot;./js-yaml/schema&quot;:10,&quot;./js-yaml/schema/core&quot;:11,&quot;./js-yaml/schema/default_full&quot;:12,&quot;./js-yaml/schema/default_safe&quot;:13,&quot;./js-yaml/schema/failsafe&quot;:14,&quot;./js-yaml/schema/json&quot;:15,&quot;./js-yaml/type&quot;:16}],5:[function(require,module,exports){
&#039;use strict&#039;;


function isNothing(subject) {
  return (typeof subject === &#039;undefined&#039;) || (subject === null);
}


function isObject(subject) {
  return (typeof subject === &#039;object&#039;) &amp;&amp; (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index &lt; length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = &#039;&#039;, cycle;

  for (cycle = 0; cycle &lt; count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) &amp;&amp; (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],6:[function(require,module,exports){
&#039;use strict&#039;;

var common              = require(&#039;./common&#039;);
var YAMLException       = require(&#039;./exception&#039;);
var DEFAULT_FULL_SCHEMA = require(&#039;./schema/default_full&#039;);
var DEFAULT_SAFE_SCHEMA = require(&#039;./schema/default_safe&#039;);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09;
var CHAR_LINE_FEED            = 0x0A;
var CHAR_SPACE                = 0x20;
var CHAR_EXCLAMATION          = 0x21;
var CHAR_DOUBLE_QUOTE         = 0x22;
var CHAR_SHARP                = 0x23;
var CHAR_PERCENT              = 0x25;
var CHAR_AMPERSAND            = 0x26;
var CHAR_SINGLE_QUOTE         = 0x27;
var CHAR_ASTERISK             = 0x2A;
var CHAR_COMMA                = 0x2C;
var CHAR_MINUS                = 0x2D;
var CHAR_COLON                = 0x3A;
var CHAR_GREATER_THAN         = 0x3E;
var CHAR_QUESTION             = 0x3F;
var CHAR_COMMERCIAL_AT        = 0x40;
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B;
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
var CHAR_GRAVE_ACCENT         = 0x60;
var CHAR_LEFT_CURLY_BRACKET   = 0x7B;
var CHAR_VERTICAL_LINE        = 0x7C;
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D;

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = &#039;\\0&#039;;
ESCAPE_SEQUENCES[0x07]   = &#039;\\a&#039;;
ESCAPE_SEQUENCES[0x08]   = &#039;\\b&#039;;
ESCAPE_SEQUENCES[0x09]   = &#039;\\t&#039;;
ESCAPE_SEQUENCES[0x0A]   = &#039;\\n&#039;;
ESCAPE_SEQUENCES[0x0B]   = &#039;\\v&#039;;
ESCAPE_SEQUENCES[0x0C]   = &#039;\\f&#039;;
ESCAPE_SEQUENCES[0x0D]   = &#039;\\r&#039;;
ESCAPE_SEQUENCES[0x1B]   = &#039;\\e&#039;;
ESCAPE_SEQUENCES[0x22]   = &#039;\\&quot;&#039;;
ESCAPE_SEQUENCES[0x5C]   = &#039;\\\\&#039;;
ESCAPE_SEQUENCES[0x85]   = &#039;\\N&#039;;
ESCAPE_SEQUENCES[0xA0]   = &#039;\\_&#039;;
ESCAPE_SEQUENCES[0x2028] = &#039;\\L&#039;;
ESCAPE_SEQUENCES[0x2029] = &#039;\\P&#039;;

var DEPRECATED_BOOLEANS_SYNTAX = [
  &#039;y&#039;, &#039;Y&#039;, &#039;yes&#039;, &#039;Yes&#039;, &#039;YES&#039;, &#039;on&#039;, &#039;On&#039;, &#039;ON&#039;,
  &#039;n&#039;, &#039;N&#039;, &#039;no&#039;, &#039;No&#039;, &#039;NO&#039;, &#039;off&#039;, &#039;Off&#039;, &#039;OFF&#039;
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index &lt; length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === &#039;!!&#039;) {
      tag = &#039;tag:yaml.org,2002:&#039; + tag.slice(2);
    }
    type = schema.compiledTypeMap[&#039;fallback&#039;][tag];

    if (type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character &lt;= 0xFF) {
    handle = &#039;x&#039;;
    length = 2;
  } else if (character &lt;= 0xFFFF) {
    handle = &#039;u&#039;;
    length = 4;
  } else if (character &lt;= 0xFFFFFFFF) {
    handle = &#039;U&#039;;
    length = 8;
  } else {
    throw new YAMLException(&#039;code point within a string may not be greater than 0xFFFFFFFF&#039;);
  }

  return &#039;\\&#039; + handle + common.repeat(&#039;0&#039;, length - string.length) + string;
}

function State(options) {
  this.schema        = options[&#039;schema&#039;] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options[&#039;indent&#039;] || 2));
  this.noArrayIndent = options[&#039;noArrayIndent&#039;] || false;
  this.skipInvalid   = options[&#039;skipInvalid&#039;] || false;
  this.flowLevel     = (common.isNothing(options[&#039;flowLevel&#039;]) ? -1 : options[&#039;flowLevel&#039;]);
  this.styleMap      = compileStyleMap(this.schema, options[&#039;styles&#039;] || null);
  this.sortKeys      = options[&#039;sortKeys&#039;] || false;
  this.lineWidth     = options[&#039;lineWidth&#039;] || 80;
  this.noRefs        = options[&#039;noRefs&#039;] || false;
  this.noCompatMode  = options[&#039;noCompatMode&#039;] || false;
  this.condenseFlow  = options[&#039;condenseFlow&#039;] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = &#039;&#039;;

  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(&#039; &#039;, spaces),
      position = 0,
      next = -1,
      result = &#039;&#039;,
      line,
      length = string.length;

  while (position &lt; length) {
    next = string.indexOf(&#039;\n&#039;, position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length &amp;&amp; line !== &#039;\n&#039;) result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return &#039;\n&#039; + common.repeat(&#039; &#039;, state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index &lt; length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return  (c &gt;= 0x00020 &amp;&amp; c &lt;= 0x00007E)
      || ((c &gt;= 0x000A1 &amp;&amp; c &lt;= 0x00D7FF) &amp;&amp; c !== 0x2028 &amp;&amp; c !== 0x2029)
      || ((c &gt;= 0x0E000 &amp;&amp; c &lt;= 0x00FFFD) &amp;&amp; c !== 0xFEFF /* BOM */)
      ||  (c &gt;= 0x10000 &amp;&amp; c &lt;= 0x10FFFF);
}
function isPlainSafe(c) {
  return isPrintable(c) &amp;&amp; c !== 0xFEFF
    &amp;&amp; c !== CHAR_COMMA
    &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_COLON
    &amp;&amp; c !== CHAR_SHARP;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) &amp;&amp; c !== 0xFEFF
    &amp;&amp; !isWhitespace(c) // - s-white
    &amp;&amp; c !== CHAR_MINUS
    &amp;&amp; c !== CHAR_QUESTION
    &amp;&amp; c !== CHAR_COLON
    &amp;&amp; c !== CHAR_COMMA
    &amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET
    &amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET
    &amp;&amp; c !== CHAR_SHARP
    &amp;&amp; c !== CHAR_AMPERSAND
    &amp;&amp; c !== CHAR_ASTERISK
    &amp;&amp; c !== CHAR_EXCLAMATION
    &amp;&amp; c !== CHAR_VERTICAL_LINE
    &amp;&amp; c !== CHAR_GREATER_THAN
    &amp;&amp; c !== CHAR_SINGLE_QUOTE
    &amp;&amp; c !== CHAR_DOUBLE_QUOTE
    &amp;&amp; c !== CHAR_PERCENT
    &amp;&amp; c !== CHAR_COMMERCIAL_AT
    &amp;&amp; c !== CHAR_GRAVE_ACCENT;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          &amp;&amp; !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    for (i = 0; i &lt; string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain &amp;&amp; isPlainSafe(char);
    }
  } else {
    for (i = 0; i &lt; string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
             string[previousLineBreak + 1] !== &#039; &#039;);
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain &amp;&amp; isPlainSafe(char);
    }
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;
      (i - previousLineBreak - 1 &gt; lineWidth &amp;&amp;
       string[previousLineBreak + 1] !== &#039; &#039;));
  }
  if (!hasLineBreak &amp;&amp; !hasFoldableLine) {
    return plain &amp;&amp; !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  if (indentPerLevel &gt; 9 &amp;&amp; needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return &quot;&#039;&#039;&quot;;
    }
    if (!state.noCompatMode &amp;&amp;
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return &quot;&#039;&quot; + string + &quot;&#039;&quot;;
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey
      || (state.flowLevel &gt; -1 &amp;&amp; level &gt;= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return &quot;&#039;&quot; + string.replace(/&#039;/g, &quot;&#039;&#039;&quot;) + &quot;&#039;&quot;;
      case STYLE_LITERAL:
        return &#039;|&#039; + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return &#039;&gt;&#039; + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return &#039;&quot;&#039; + escapeString(string, lineWidth) + &#039;&quot;&#039;;
      default:
        throw new YAMLException(&#039;impossible error: invalid scalar style&#039;);
    }
  }());
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : &#039;&#039;;
  var clip =          string[string.length - 1] === &#039;\n&#039;;
  var keep = clip &amp;&amp; (string[string.length - 2] === &#039;\n&#039; || string === &#039;\n&#039;);
  var chomp = keep ? &#039;+&#039; : (clip ? &#039;&#039; : &#039;-&#039;);

  return indentIndicator + chomp + &#039;\n&#039;;
}
function dropEndingNewline(string) {
  return string[string.length - 1] === &#039;\n&#039; ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = (function () {
    var nextLF = string.indexOf(&#039;\n&#039;);
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  var prevMoreIndented = string[0] === &#039;\n&#039; || string[0] === &#039; &#039;;
  var moreIndented;
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === &#039; &#039;);
    result += prefix
      + (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== &#039;&#039;
        ? &#039;\n&#039; : &#039;&#039;)
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}
function foldLine(line, width) {
  if (line === &#039;&#039; || line[0] === &#039; &#039;) return line;
  var breakRe = / [^ ]/g; // note: the match index will always be &lt;= length-2.
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = &#039;&#039;;
  while ((match = breakRe.exec(line))) {
    next = match.index;
    if (next - start &gt; width) {
      end = (curr &gt; start) ? curr : next; // derive end &lt;= length-2
      result += &#039;\n&#039; + line.slice(start, end);
      start = end + 1;                    // derive start &lt;= length-1
    }
    curr = next;
  }
  result += &#039;\n&#039;;
  if (line.length - start &gt; width &amp;&amp; curr &gt; start) {
    result += line.slice(start, curr) + &#039;\n&#039; + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}
function escapeString(string) {
  var result = &#039;&#039;;
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i &lt; string.length; i++) {
    char = string.charCodeAt(i);
    if (char &gt;= 0xD800 &amp;&amp; char &lt;= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar &gt;= 0xDC00 &amp;&amp; nextChar &lt;= 0xDFFF/* low surrogate */) {
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq &amp;&amp; isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = &#039;&#039;,
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += &#039;,&#039; + (!state.condenseFlow ? &#039; &#039; : &#039;&#039;);
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = &#039;[&#039; + _result + &#039;]&#039;;
}

function writeBlockSequence(state, level, object, compact) {
  var _result = &#039;&#039;,
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += &#039;-&#039;;
      } else {
        _result += &#039;- &#039;;
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || &#039;[]&#039;; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = &#039;&#039;,
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
    pairBuffer = state.condenseFlow ? &#039;&quot;&#039; : &#039;&#039;;

    if (index !== 0) pairBuffer += &#039;, &#039;;

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length &gt; 1024) pairBuffer += &#039;? &#039;;

    pairBuffer += state.dump + (state.condenseFlow ? &#039;&quot;&#039; : &#039;&#039;) + &#039;:&#039; + (state.condenseFlow ? &#039;&#039; : &#039; &#039;);

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = &#039;{&#039; + _result + &#039;}&#039;;
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = &#039;&#039;,
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === &#039;function&#039;) {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new YAMLException(&#039;sortKeys must be a boolean or a function&#039;);
  }

  for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
    pairBuffer = &#039;&#039;;

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) ||
                   (state.dump &amp;&amp; state.dump.length &gt; 1024);

    if (explicitPair) {
      if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += &#039;?&#039;;
      } else {
        pairBuffer += &#039;? &#039;;
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += &#039;:&#039;;
    } else {
      pairBuffer += &#039;: &#039;;
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || &#039;{}&#039;; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index &lt; length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &amp;&amp;
        (!type.instanceOf || ((typeof object === &#039;object&#039;) &amp;&amp; (object instanceof type.instanceOf))) &amp;&amp;
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : &#039;?&#039;;

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === &#039;[object Function]&#039;) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException(&#039;!&lt;&#039; + type.tag + &#039;&gt; tag resolver accepts not &quot;&#039; + style + &#039;&quot; style&#039;);
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel &lt; 0 || state.flowLevel &gt; level);
  }

  var objectOrArray = type === &#039;[object Object]&#039; || type === &#039;[object Array]&#039;,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) || duplicate || (state.indent !== 2 &amp;&amp; level &gt; 0)) {
    compact = false;
  }

  if (duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {
    state.dump = &#039;*ref_&#039; + duplicateIndex;
  } else {
    if (objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === &#039;[object Object]&#039;) {
      if (block &amp;&amp; (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
        }
      }
    } else if (type === &#039;[object Array]&#039;) {
      var arrayLevel = (state.noArrayIndent &amp;&amp; (level &gt; 0)) ? level - 1 : level;
      if (block &amp;&amp; (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = &#039;&amp;ref_&#039; + duplicateIndex + &#039; &#039; + state.dump;
        }
      }
    } else if (type === &#039;[object String]&#039;) {
      if (state.tag !== &#039;?&#039;) {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException(&#039;unacceptable kind of an object to dump &#039; + type);
    }

    if (state.tag !== null &amp;&amp; state.tag !== &#039;?&#039;) {
      state.dump = &#039;!&lt;&#039; + state.tag + &#039;&gt; &#039; + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index &lt; length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null &amp;&amp; typeof object === &#039;object&#039;) {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index &lt; length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + &#039;\n&#039;;

  return &#039;&#039;;
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{&quot;./common&quot;:5,&quot;./exception&quot;:7,&quot;./schema/default_full&quot;:12,&quot;./schema/default_safe&quot;:13}],7:[function(require,module,exports){
&#039;use strict&#039;;

function YAMLException(reason, mark) {
  Error.call(this);

  this.name = &#039;YAMLException&#039;;
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || &#039;(unknown reason)&#039;) + (this.mark ? &#039; &#039; + this.mark.toString() : &#039;&#039;);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack || &#039;&#039;;
  }
}
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + &#039;: &#039;;

  result += this.reason || &#039;(unknown reason)&#039;;

  if (!compact &amp;&amp; this.mark) {
    result += &#039; &#039; + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],8:[function(require,module,exports){
&#039;use strict&#039;;

var common              = require(&#039;./common&#039;);
var YAMLException       = require(&#039;./exception&#039;);
var Mark                = require(&#039;./mark&#039;);
var DEFAULT_SAFE_SCHEMA = require(&#039;./schema/default_safe&#039;);
var DEFAULT_FULL_SCHEMA = require(&#039;./schema/default_full&#039;);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&amp;=\+\$,_\.!~\*&#039;\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((c/* 0 */ &gt;= 0x30) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
    return c - 0x30;
  }
  lc = c | 0x20;

  if ((lc/* a */ &gt;= 0x61) &amp;&amp; (lc &lt;= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((c/* 0 */ &gt;= 0x30) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return (c === 0x30/* 0 */) ? &#039;\x00&#039; :
        (c === 0x61/* a */) ? &#039;\x07&#039; :
        (c === 0x62/* b */) ? &#039;\x08&#039; :
        (c === 0x74/* t */) ? &#039;\x09&#039; :
        (c === 0x09/* Tab */) ? &#039;\x09&#039; :
        (c === 0x6E/* n */) ? &#039;\x0A&#039; :
        (c === 0x76/* v */) ? &#039;\x0B&#039; :
        (c === 0x66/* f */) ? &#039;\x0C&#039; :
        (c === 0x72/* r */) ? &#039;\x0D&#039; :
        (c === 0x65/* e */) ? &#039;\x1B&#039; :
        (c === 0x20/* Space */) ? &#039; &#039; :
        (c === 0x22/* &quot; */) ? &#039;\x22&#039; :
        (c === 0x2F/* / */) ? &#039;/&#039; :
        (c === 0x5C/* \ */) ? &#039;\x5C&#039; :
        (c === 0x4E/* N */) ? &#039;\x85&#039; :
        (c === 0x5F/* _ */) ? &#039;\xA0&#039; :
        (c === 0x4C/* L */) ? &#039;\u2028&#039; :
        (c === 0x50/* P */) ? &#039;\u2029&#039; : &#039;&#039;;
}

function charFromCodepoint(c) {
  if (c &lt;= 0xFFFF) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    ((c - 0x010000) &gt;&gt; 10) + 0xD800,
    ((c - 0x010000) &amp; 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i &lt; 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options[&#039;filename&#039;]  || null;
  this.schema    = options[&#039;schema&#039;]    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options[&#039;onWarning&#039;] || null;
  this.legacy    = options[&#039;legacy&#039;]    || false;
  this.json      = options[&#039;json&#039;]      || false;
  this.listener  = options[&#039;listener&#039;]  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, &#039;duplication of %YAML directive&#039;);
    }

    if (args.length !== 1) {
      throwError(state, &#039;YAML directive accepts exactly one argument&#039;);
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, &#039;ill-formed argument of the YAML directive&#039;);
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, &#039;unacceptable YAML version of the document&#039;);
    }

    state.version = args[0];
    state.checkLineBreaks = (minor &lt; 2);

    if (minor !== 1 &amp;&amp; minor !== 2) {
      throwWarning(state, &#039;unsupported YAML version of the document&#039;);
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, &#039;TAG directive accepts exactly two arguments&#039;);
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, &#039;ill-formed tag handle (first argument) of the TAG directive&#039;);
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, &#039;there is a previously declared suffix for &quot;&#039; + handle + &#039;&quot; tag handle&#039;);
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, &#039;ill-formed tag prefix (second argument) of the TAG directive&#039;);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start &lt; end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position &lt; _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (_character &gt;= 0x20 &amp;&amp; _character &lt;= 0x10FFFF))) {
          throwError(state, &#039;expected valid JSON character&#039;);
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, &#039;the stream contains non-printable characters&#039;);
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, &#039;cannot merge mappings; the provided source object is unacceptable&#039;);
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index &lt; quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === &#039;tag:yaml.org,2002:merge&#039;) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index &lt; quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &amp;&amp;
        !_hasOwnProperty.call(overridableKeys, keyNode) &amp;&amp;
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, &#039;duplicated mapping key&#039;);
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, &#039;a line break is expected&#039;);
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments &amp;&amp; ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ &amp;&amp; ch !== 0x0D/* CR */ &amp;&amp; ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 &amp;&amp; lineBreaks !== 0 &amp;&amp; state.lineIndent &lt; checkIndent) {
    throwWarning(state, &#039;deficient indentation&#039;);
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &amp;&amp;
      ch === state.input.charCodeAt(_position + 1) &amp;&amp;
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += &#039; &#039;;
  } else if (count &gt; 1) {
    state.result += common.repeat(&#039;\n&#039;, count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* &amp; */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* &gt; */    ||
      ch === 0x27/* &#039; */    ||
      ch === 0x22/* &quot; */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) ||
               withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent &gt;= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* &#039; */) {
    return false;
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* &#039; */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* &#039; */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
      throwError(state, &#039;unexpected end of the document within a single quoted scalar&#039;);

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, &#039;unexpected end of the stream within a single quoted scalar&#039;);
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* &quot; */) {
    return false;
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* &quot; */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch &lt; 256 &amp;&amp; simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) &gt; 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength &gt; 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) &gt;= 0) {
            hexResult = (hexResult &lt;&lt; 4) + tmp;

          } else {
            throwError(state, &#039;expected hexadecimal character&#039;);
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, &#039;unknown escape sequence&#039;);
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
      throwError(state, &#039;unexpected end of the document within a double quoted scalar&#039;);

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, &#039;unexpected end of the stream within a double quoted scalar&#039;);
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? &#039;mapping&#039; : &#039;sequence&#039;;
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, &#039;missed comma between flow collection entries&#039;);
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) &amp;&amp; ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, &#039;unexpected end of the stream within a flow collection&#039;);
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* &gt; */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = &#039;scalar&#039;;
  state.result = &#039;&#039;;

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, &#039;repeat of a chomping mode identifier&#039;);
      }

    } else if ((tmp = fromDecimalCode(ch)) &gt;= 0) {
      if (tmp === 0) {
        throwError(state, &#039;bad explicit indentation width of a block scalar; it cannot be less than one&#039;);
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, &#039;repeat of an indentation width identifier&#039;);
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) &amp;&amp; (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent &lt; textIndent) &amp;&amp;
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent &amp;&amp; state.lineIndent &gt; textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent &lt; textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += &#039;\n&#039;;
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat(&#039;\n&#039;, emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += &#039; &#039;;
        }
      } else {
        state.result += common.repeat(&#039;\n&#039;, emptyLines);
      }
    } else {
      state.result += common.repeat(&#039;\n&#039;, didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) &amp;&amp; (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent &lt;= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== 0)) {
      throwError(state, &#039;bad indentation of a sequence entry&#039;);
    } else if (state.lineIndent &lt; nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = &#039;sequence&#039;;
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) &amp;&amp; is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, &#039;incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line&#039;);
      }

      state.position += 1;
      ch = following;
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, &#039;a whitespace character is expected after the key-value separator within a block mapping&#039;);
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, &#039;can not read an implicit mapping pair; a colon is missed&#039;);

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, &#039;can not read a block mapping entry; a multiline key may not be an implicit key&#039;);

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }
    if (state.line === _line || state.lineIndent &gt; nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent &gt; nodeIndent &amp;&amp; (ch !== 0)) {
      throwError(state, &#039;bad indentation of a mapping entry&#039;);
    } else if (state.lineIndent &lt; nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = &#039;mapping&#039;;
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, &#039;duplication of a tag property&#039;);
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* &lt; */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = &#039;!!&#039;;
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = &#039;!&#039;;
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 &amp;&amp; ch !== 0x3E/* &gt; */);

    if (state.position &lt; state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, &#039;unexpected end of the stream within a verbatim tag&#039;);
    }
  } else {
    while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, &#039;named tag handle cannot contain such characters&#039;);
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, &#039;tag suffix cannot contain exclamation marks&#039;);
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, &#039;tag suffix cannot contain flow indicator characters&#039;);
    }
  }

  if (tagName &amp;&amp; !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, &#039;tag name cannot contain such characters: &#039; + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === &#039;!&#039;) {
    state.tag = &#039;!&#039; + tagName;

  } else if (tagHandle === &#039;!!&#039;) {
    state.tag = &#039;tag:yaml.org,2002:&#039; + tagName;

  } else {
    throwError(state, &#039;undeclared tag handle &quot;&#039; + tagHandle + &#039;&quot;&#039;);
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* &amp; */) return false;

  if (state.anchor !== null) {
    throwError(state, &#039;duplication of an anchor property&#039;);
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, &#039;name of an anchor node must contain at least one character&#039;);
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, &#039;name of an alias node must contain at least one character&#039;);
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, &#039;unidentified alias &quot;&#039; + alias + &#039;&quot;&#039;);
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this&gt;parent, 0: this=parent, -1: this&lt;parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener(&#039;open&#039;, state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent &gt; parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent &lt; parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent &gt; parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent &lt; parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &amp;&amp;
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars &amp;&amp; readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, &#039;alias node should not have any properties&#039;);
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = &#039;?&#039;;
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections &amp;&amp; readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null &amp;&amp; state.tag !== &#039;!&#039;) {
    if (state.tag === &#039;?&#039;) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex &lt; typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || &#039;fallback&#039;], state.tag)) {
      type = state.typeMap[state.kind || &#039;fallback&#039;][state.tag];

      if (state.result !== null &amp;&amp; type.kind !== state.kind) {
        throwError(state, &#039;unacceptable node kind for !&lt;&#039; + state.tag + &#039;&gt; tag; it should be &quot;&#039; + type.kind + &#039;&quot;, not &quot;&#039; + state.kind + &#039;&quot;&#039;);
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, &#039;cannot resolve a node with !&lt;&#039; + state.tag + &#039;&gt; explicit tag&#039;);
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, &#039;unknown tag !&lt;&#039; + state.tag + &#039;&gt;&#039;);
    }
  }

  if (state.listener !== null) {
    state.listener(&#039;close&#039;, state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent &gt; 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length &lt; 1) {
      throwError(state, &#039;directive name must not be less than one character in length&#039;);
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 &amp;&amp; !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 &amp;&amp; !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, &#039;unknown document directive &quot;&#039; + directiveName + &#039;&quot;&#039;);
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &amp;&amp;
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &amp;&amp;
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &amp;&amp;
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, &#039;directives end mark is expected&#039;);
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &amp;&amp;
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, &#039;non-ASCII line breaks are interpreted as content&#039;);
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position &lt; (state.length - 1)) {
    throwError(state, &#039;end of the stream or a document separator is expected&#039;);
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &amp;&amp;
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += &#039;\n&#039;;
    }
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);
  state.input += &#039;\0&#039;;

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position &lt; (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== &#039;function&#039;) {
    return documents;
  }

  for (index = 0, length = documents.length; index &lt; length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException(&#039;expected a single document in the stream, but found more&#039;);
}


function safeLoadAll(input, output, options) {
  if (typeof output === &#039;function&#039;) {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{&quot;./common&quot;:5,&quot;./exception&quot;:7,&quot;./mark&quot;:9,&quot;./schema/default_full&quot;:12,&quot;./schema/default_safe&quot;:13}],9:[function(require,module,exports){
&#039;use strict&#039;;


var common = require(&#039;./common&#039;);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = &#039;&#039;;
  start = this.position;

  while (start &gt; 0 &amp;&amp; &#039;\x00\r\n\x85\u2028\u2029&#039;.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start &gt; (maxLength / 2 - 1)) {
      head = &#039; ... &#039;;
      start += 5;
      break;
    }
  }

  tail = &#039;&#039;;
  end = this.position;

  while (end &lt; this.buffer.length &amp;&amp; &#039;\x00\r\n\x85\u2028\u2029&#039;.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position &gt; (maxLength / 2 - 1)) {
      tail = &#039; ... &#039;;
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(&#039; &#039;, indent) + head + snippet + tail + &#039;\n&#039; +
         common.repeat(&#039; &#039;, indent + this.position - start + head.length) + &#039;^&#039;;
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = &#039;&#039;;

  if (this.name) {
    where += &#039;in &quot;&#039; + this.name + &#039;&quot; &#039;;
  }

  where += &#039;at line &#039; + (this.line + 1) + &#039;, column &#039; + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += &#039;:\n&#039; + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{&quot;./common&quot;:5}],10:[function(require,module,exports){
&#039;use strict&#039;;

var common        = require(&#039;./common&#039;);
var YAMLException = require(&#039;./exception&#039;);
var Type          = require(&#039;./type&#039;);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &amp;&amp; previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result[&#039;fallback&#039;][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index &lt; length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind &amp;&amp; type.loadKind !== &#039;scalar&#039;) {
      throw new YAMLException(&#039;There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.&#039;);
    }
  });

  this.compiledImplicit = compileList(this, &#039;implicit&#039;, []);
  this.compiledExplicit = compileList(this, &#039;explicit&#039;, []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException(&#039;Wrong number of arguments for Schema.create function&#039;);
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException(&#039;Specified list of super schemas (or a single Schema object) contains a non-Schema object.&#039;);
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException(&#039;Specified list of YAML types (or a single Type object) contains a non-Type object.&#039;);
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{&quot;./common&quot;:5,&quot;./exception&quot;:7,&quot;./type&quot;:16}],11:[function(require,module,exports){


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  include: [
    require(&#039;./json&#039;)
  ]
});

},{&quot;../schema&quot;:10,&quot;./json&quot;:15}],12:[function(require,module,exports){


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require(&#039;./default_safe&#039;)
  ],
  explicit: [
    require(&#039;../type/js/undefined&#039;),
    require(&#039;../type/js/regexp&#039;),
    require(&#039;../type/js/function&#039;)
  ]
});

},{&quot;../schema&quot;:10,&quot;../type/js/function&quot;:21,&quot;../type/js/regexp&quot;:22,&quot;../type/js/undefined&quot;:23,&quot;./default_safe&quot;:13}],13:[function(require,module,exports){


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  include: [
    require(&#039;./core&#039;)
  ],
  implicit: [
    require(&#039;../type/timestamp&#039;),
    require(&#039;../type/merge&#039;)
  ],
  explicit: [
    require(&#039;../type/binary&#039;),
    require(&#039;../type/omap&#039;),
    require(&#039;../type/pairs&#039;),
    require(&#039;../type/set&#039;)
  ]
});

},{&quot;../schema&quot;:10,&quot;../type/binary&quot;:17,&quot;../type/merge&quot;:25,&quot;../type/omap&quot;:27,&quot;../type/pairs&quot;:28,&quot;../type/set&quot;:30,&quot;../type/timestamp&quot;:32,&quot;./core&quot;:11}],14:[function(require,module,exports){


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  explicit: [
    require(&#039;../type/str&#039;),
    require(&#039;../type/seq&#039;),
    require(&#039;../type/map&#039;)
  ]
});

},{&quot;../schema&quot;:10,&quot;../type/map&quot;:24,&quot;../type/seq&quot;:29,&quot;../type/str&quot;:31}],15:[function(require,module,exports){


&#039;use strict&#039;;


var Schema = require(&#039;../schema&#039;);


module.exports = new Schema({
  include: [
    require(&#039;./failsafe&#039;)
  ],
  implicit: [
    require(&#039;../type/null&#039;),
    require(&#039;../type/bool&#039;),
    require(&#039;../type/int&#039;),
    require(&#039;../type/float&#039;)
  ]
});

},{&quot;../schema&quot;:10,&quot;../type/bool&quot;:18,&quot;../type/float&quot;:19,&quot;../type/int&quot;:20,&quot;../type/null&quot;:26,&quot;./failsafe&quot;:14}],16:[function(require,module,exports){
&#039;use strict&#039;;

var YAMLException = require(&#039;./exception&#039;);

var TYPE_CONSTRUCTOR_OPTIONS = [
  &#039;kind&#039;,
  &#039;resolve&#039;,
  &#039;construct&#039;,
  &#039;instanceOf&#039;,
  &#039;predicate&#039;,
  &#039;represent&#039;,
  &#039;defaultStyle&#039;,
  &#039;styleAliases&#039;
];

var YAML_NODE_KINDS = [
  &#039;scalar&#039;,
  &#039;sequence&#039;,
  &#039;mapping&#039;
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException(&#039;Unknown option &quot;&#039; + name + &#039;&quot; is met in definition of &quot;&#039; + tag + &#039;&quot; YAML type.&#039;);
    }
  });
  this.tag          = tag;
  this.kind         = options[&#039;kind&#039;]         || null;
  this.resolve      = options[&#039;resolve&#039;]      || function () { return true; };
  this.construct    = options[&#039;construct&#039;]    || function (data) { return data; };
  this.instanceOf   = options[&#039;instanceOf&#039;]   || null;
  this.predicate    = options[&#039;predicate&#039;]    || null;
  this.represent    = options[&#039;represent&#039;]    || null;
  this.defaultStyle = options[&#039;defaultStyle&#039;] || null;
  this.styleAliases = compileStyleAliases(options[&#039;styleAliases&#039;] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException(&#039;Unknown kind &quot;&#039; + this.kind + &#039;&quot; is specified for &quot;&#039; + tag + &#039;&quot; YAML type.&#039;);
  }
}

module.exports = Type;

},{&quot;./exception&quot;:7}],17:[function(require,module,exports){
&#039;use strict&#039;;

var NodeBuffer;

try {
  var _require = require;
  NodeBuffer = _require(&#039;buffer&#039;).Buffer;
} catch (__) {}

var Type       = require(&#039;../type&#039;);
var BASE64_MAP = &#039;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r&#039;;


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
  for (idx = 0; idx &lt; max; idx++) {
    code = map.indexOf(data.charAt(idx));
    if (code &gt; 64) continue;
    if (code &lt; 0) return false;

    bitlen += 6;
  }
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, &#039;&#039;), // remove CR/LF &amp; padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  for (idx = 0; idx &lt; max; idx++) {
    if ((idx % 4 === 0) &amp;&amp; idx) {
      result.push((bits &gt;&gt; 16) &amp; 0xFF);
      result.push((bits &gt;&gt; 8) &amp; 0xFF);
      result.push(bits &amp; 0xFF);
    }

    bits = (bits &lt;&lt; 6) | map.indexOf(input.charAt(idx));
  }

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits &gt;&gt; 16) &amp; 0xFF);
    result.push((bits &gt;&gt; 8) &amp; 0xFF);
    result.push(bits &amp; 0xFF);
  } else if (tailbits === 18) {
    result.push((bits &gt;&gt; 10) &amp; 0xFF);
    result.push((bits &gt;&gt; 2) &amp; 0xFF);
  } else if (tailbits === 12) {
    result.push((bits &gt;&gt; 4) &amp; 0xFF);
  }
  if (NodeBuffer) {
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = &#039;&#039;, bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  for (idx = 0; idx &lt; max; idx++) {
    if ((idx % 3 === 0) &amp;&amp; idx) {
      result += map[(bits &gt;&gt; 18) &amp; 0x3F];
      result += map[(bits &gt;&gt; 12) &amp; 0x3F];
      result += map[(bits &gt;&gt; 6) &amp; 0x3F];
      result += map[bits &amp; 0x3F];
    }

    bits = (bits &lt;&lt; 8) + object[idx];
  }

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits &gt;&gt; 18) &amp; 0x3F];
    result += map[(bits &gt;&gt; 12) &amp; 0x3F];
    result += map[(bits &gt;&gt; 6) &amp; 0x3F];
    result += map[bits &amp; 0x3F];
  } else if (tail === 2) {
    result += map[(bits &gt;&gt; 10) &amp; 0x3F];
    result += map[(bits &gt;&gt; 4) &amp; 0x3F];
    result += map[(bits &lt;&lt; 2) &amp; 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits &gt;&gt; 2) &amp; 0x3F];
    result += map[(bits &lt;&lt; 4) &amp; 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer &amp;&amp; NodeBuffer.isBuffer(object);
}

module.exports = new Type(&#039;tag:yaml.org,2002:binary&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{&quot;../type&quot;:16}],18:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 &amp;&amp; (data === &#039;true&#039; || data === &#039;True&#039; || data === &#039;TRUE&#039;)) ||
         (max === 5 &amp;&amp; (data === &#039;false&#039; || data === &#039;False&#039; || data === &#039;FALSE&#039;));
}

function constructYamlBoolean(data) {
  return data === &#039;true&#039; ||
         data === &#039;True&#039; ||
         data === &#039;TRUE&#039;;
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === &#039;[object Boolean]&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:bool&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? &#039;true&#039; : &#039;false&#039;; },
    uppercase: function (object) { return object ? &#039;TRUE&#039; : &#039;FALSE&#039;; },
    camelcase: function (object) { return object ? &#039;True&#039; : &#039;False&#039;; }
  },
  defaultStyle: &#039;lowercase&#039;
});

},{&quot;../type&quot;:16}],19:[function(require,module,exports){
&#039;use strict&#039;;

var common = require(&#039;../common&#039;);
var Type   = require(&#039;../type&#039;);

var YAML_FLOAT_PATTERN = new RegExp(
  &#039;^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?&#039; +
  &#039;|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?&#039; +
  &#039;|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*&#039; +
  &#039;|[-+]?\\.(?:inf|Inf|INF)&#039; +
  &#039;|\\.(?:nan|NaN|NAN))$&#039;);

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      data[data.length - 1] === &#039;_&#039;) {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, &#039;&#039;).toLowerCase();
  sign   = value[0] === &#039;-&#039; ? -1 : 1;
  digits = [];

  if (&#039;+-&#039;.indexOf(value[0]) &gt;= 0) {
    value = value.slice(1);
  }

  if (value === &#039;.inf&#039;) {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === &#039;.nan&#039;) {
    return NaN;

  } else if (value.indexOf(&#039;:&#039;) &gt;= 0) {
    value.split(&#039;:&#039;).forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case &#039;lowercase&#039;: return &#039;.nan&#039;;
      case &#039;uppercase&#039;: return &#039;.NAN&#039;;
      case &#039;camelcase&#039;: return &#039;.NaN&#039;;
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case &#039;lowercase&#039;: return &#039;.inf&#039;;
      case &#039;uppercase&#039;: return &#039;.INF&#039;;
      case &#039;camelcase&#039;: return &#039;.Inf&#039;;
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case &#039;lowercase&#039;: return &#039;-.inf&#039;;
      case &#039;uppercase&#039;: return &#039;-.INF&#039;;
      case &#039;camelcase&#039;: return &#039;-.Inf&#039;;
    }
  } else if (common.isNegativeZero(object)) {
    return &#039;-0.0&#039;;
  }

  res = object.toString(10);

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(&#039;e&#039;, &#039;.e&#039;) : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === &#039;[object Number]&#039;) &amp;&amp;
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type(&#039;tag:yaml.org,2002:float&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: &#039;lowercase&#039;
});

},{&quot;../common&quot;:5,&quot;../type&quot;:16}],20:[function(require,module,exports){
&#039;use strict&#039;;

var common = require(&#039;../common&#039;);
var Type   = require(&#039;../type&#039;);

function isHexCode(c) {
  return ((c/* 0 */ &gt;= 0x30) &amp;&amp; (c &lt;= 0x39/* 9 */)) ||
         ((c/* A */ &gt;= 0x41) &amp;&amp; (c &lt;= 0x46/* F */)) ||
         ((c/* a */ &gt;= 0x61) &amp;&amp; (c &lt;= 0x66/* f */));
}

function isOctCode(c) {
  return ((c/* 0 */ &gt;= 0x30) &amp;&amp; (c &lt;= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((c/* 0 */ &gt;= 0x30) &amp;&amp; (c &lt;= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];
  if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
    ch = data[++index];
  }

  if (ch === &#039;0&#039;) {
    if (index + 1 === max) return true;
    ch = data[++index];

    if (ch === &#039;b&#039;) {
      index++;

      for (; index &lt; max; index++) {
        ch = data[index];
        if (ch === &#039;_&#039;) continue;
        if (ch !== &#039;0&#039; &amp;&amp; ch !== &#039;1&#039;) return false;
        hasDigits = true;
      }
      return hasDigits &amp;&amp; ch !== &#039;_&#039;;
    }


    if (ch === &#039;x&#039;) {
      index++;

      for (; index &lt; max; index++) {
        ch = data[index];
        if (ch === &#039;_&#039;) continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits &amp;&amp; ch !== &#039;_&#039;;
    }
    for (; index &lt; max; index++) {
      ch = data[index];
      if (ch === &#039;_&#039;) continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits &amp;&amp; ch !== &#039;_&#039;;
  }
  if (ch === &#039;_&#039;) return false;

  for (; index &lt; max; index++) {
    ch = data[index];
    if (ch === &#039;_&#039;) continue;
    if (ch === &#039;:&#039;) break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === &#039;_&#039;) return false;
  if (ch !== &#039;:&#039;) return true;
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf(&#039;_&#039;) !== -1) {
    value = value.replace(/_/g, &#039;&#039;);
  }

  ch = value[0];

  if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
    if (ch === &#039;-&#039;) sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === &#039;0&#039;) return 0;

  if (ch === &#039;0&#039;) {
    if (value[1] === &#039;b&#039;) return sign * parseInt(value.slice(2), 2);
    if (value[1] === &#039;x&#039;) return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(&#039;:&#039;) !== -1) {
    value.split(&#039;:&#039;).forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === &#039;[object Number]&#039; &amp;&amp;
         (object % 1 === 0 &amp;&amp; !common.isNegativeZero(object));
}

module.exports = new Type(&#039;tag:yaml.org,2002:int&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj &gt;= 0 ? &#039;0b&#039; + obj.toString(2) : &#039;-0b&#039; + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj &gt;= 0 ? &#039;0&#039;  + obj.toString(8) : &#039;-0&#039;  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    hexadecimal: function (obj) { return obj &gt;= 0 ? &#039;0x&#039; + obj.toString(16).toUpperCase() :  &#039;-0x&#039; + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: &#039;decimal&#039;,
  styleAliases: {
    binary:      [ 2,  &#039;bin&#039; ],
    octal:       [ 8,  &#039;oct&#039; ],
    decimal:     [ 10, &#039;dec&#039; ],
    hexadecimal: [ 16, &#039;hex&#039; ]
  }
});

},{&quot;../common&quot;:5,&quot;../type&quot;:16}],21:[function(require,module,exports){
&#039;use strict&#039;;

var esprima;
try {
  var _require = require;
  esprima = _require(&#039;esprima&#039;);
} catch (_) {
  if (typeof window !== &#039;undefined&#039;) esprima = window.esprima;
}

var Type = require(&#039;../../type&#039;);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = &#039;(&#039; + data + &#039;)&#039;,
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== &#039;Program&#039;             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== &#039;ExpressionStatement&#039; ||
        (ast.body[0].expression.type !== &#039;ArrowFunctionExpression&#039; &amp;&amp;
          ast.body[0].expression.type !== &#039;FunctionExpression&#039;)) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  return function() {}
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === &#039;[object Function]&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:js/function&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{&quot;../../type&quot;:16}],22:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../../type&#039;);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = &#039;&#039;;
  if (regexp[0] === &#039;/&#039;) {
    if (tail) modifiers = tail[1];

    if (modifiers.length &gt; 3) return false;
    if (regexp[regexp.length - modifiers.length - 1] !== &#039;/&#039;) return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = &#039;&#039;;
  if (regexp[0] === &#039;/&#039;) {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = &#039;/&#039; + object.source + &#039;/&#039;;

  if (object.global) result += &#039;g&#039;;
  if (object.multiline) result += &#039;m&#039;;
  if (object.ignoreCase) result += &#039;i&#039;;

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === &#039;[object RegExp]&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:js/regexp&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{&quot;../../type&quot;:16}],23:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../../type&#039;);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  return undefined;
}

function representJavascriptUndefined() {
  return &#039;&#039;;
}

function isUndefined(object) {
  return typeof object === &#039;undefined&#039;;
}

module.exports = new Type(&#039;tag:yaml.org,2002:js/undefined&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{&quot;../../type&quot;:16}],24:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

module.exports = new Type(&#039;tag:yaml.org,2002:map&#039;, {
  kind: &#039;mapping&#039;,
  construct: function (data) { return data !== null ? data : {}; }
});

},{&quot;../type&quot;:16}],25:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

function resolveYamlMerge(data) {
  return data === &#039;&lt;&lt;&#039; || data === null;
}

module.exports = new Type(&#039;tag:yaml.org,2002:merge&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlMerge
});

},{&quot;../type&quot;:16}],26:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 &amp;&amp; data === &#039;~&#039;) ||
         (max === 4 &amp;&amp; (data === &#039;null&#039; || data === &#039;Null&#039; || data === &#039;NULL&#039;));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type(&#039;tag:yaml.org,2002:null&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return &#039;~&#039;;    },
    lowercase: function () { return &#039;null&#039;; },
    uppercase: function () { return &#039;NULL&#039;; },
    camelcase: function () { return &#039;Null&#039;; }
  },
  defaultStyle: &#039;lowercase&#039;
});

},{&quot;../type&quot;:16}],27:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== &#039;[object Object]&#039;) return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type(&#039;tag:yaml.org,2002:omap&#039;, {
  kind: &#039;sequence&#039;,
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{&quot;../type&quot;:16}],28:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== &#039;[object Object]&#039;) return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index &lt; length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type(&#039;tag:yaml.org,2002:pairs&#039;, {
  kind: &#039;sequence&#039;,
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{&quot;../type&quot;:16}],29:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

module.exports = new Type(&#039;tag:yaml.org,2002:seq&#039;, {
  kind: &#039;sequence&#039;,
  construct: function (data) { return data !== null ? data : []; }
});

},{&quot;../type&quot;:16}],30:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type(&#039;tag:yaml.org,2002:set&#039;, {
  kind: &#039;mapping&#039;,
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{&quot;../type&quot;:16}],31:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

module.exports = new Type(&#039;tag:yaml.org,2002:str&#039;, {
  kind: &#039;scalar&#039;,
  construct: function (data) { return data !== null ? data : &#039;&#039;; }
});

},{&quot;../type&quot;:16}],32:[function(require,module,exports){
&#039;use strict&#039;;

var Type = require(&#039;../type&#039;);

var YAML_DATE_REGEXP = new RegExp(
  &#039;^([0-9][0-9][0-9][0-9])&#039;          + // [1] year
  &#039;-([0-9][0-9])&#039;                    + // [2] month
  &#039;-([0-9][0-9])$&#039;);                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  &#039;^([0-9][0-9][0-9][0-9])&#039;          + // [1] year
  &#039;-([0-9][0-9]?)&#039;                   + // [2] month
  &#039;-([0-9][0-9]?)&#039;                   + // [3] day
  &#039;(?:[Tt]|[ \\t]+)&#039;                 + // ...
  &#039;([0-9][0-9]?)&#039;                    + // [4] hour
  &#039;:([0-9][0-9])&#039;                    + // [5] minute
  &#039;:([0-9][0-9])&#039;                    + // [6] second
  &#039;(?:\\.([0-9]*))?&#039;                 + // [7] fraction
  &#039;(?:[ \\t]*(Z|([-+])([0-9][0-9]?)&#039; + // [8] tz [9] tz_sign [10] tz_hour
  &#039;(?::([0-9][0-9]))?))?$&#039;);           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error(&#039;Date resolve error&#039;);

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length &lt; 3) { // milli-seconds
      fraction += &#039;0&#039;;
    }
    fraction = +fraction;
  }

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === &#039;-&#039;) delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type(&#039;tag:yaml.org,2002:timestamp&#039;, {
  kind: &#039;scalar&#039;,
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{&quot;../type&quot;:16}],33:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var HASH_UNDEFINED = &#039;__lodash_hash_undefined__&#039;;
var HOT_COUNT = 800,
    HOT_SPAN = 16;
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = &#039;[object Arguments]&#039;,
    arrayTag = &#039;[object Array]&#039;,
    asyncTag = &#039;[object AsyncFunction]&#039;,
    boolTag = &#039;[object Boolean]&#039;,
    dateTag = &#039;[object Date]&#039;,
    errorTag = &#039;[object Error]&#039;,
    funcTag = &#039;[object Function]&#039;,
    genTag = &#039;[object GeneratorFunction]&#039;,
    mapTag = &#039;[object Map]&#039;,
    numberTag = &#039;[object Number]&#039;,
    nullTag = &#039;[object Null]&#039;,
    objectTag = &#039;[object Object]&#039;,
    proxyTag = &#039;[object Proxy]&#039;,
    regexpTag = &#039;[object RegExp]&#039;,
    setTag = &#039;[object Set]&#039;,
    stringTag = &#039;[object String]&#039;,
    undefinedTag = &#039;[object Undefined]&#039;,
    weakMapTag = &#039;[object WeakMap]&#039;;

var arrayBufferTag = &#039;[object ArrayBuffer]&#039;,
    dataViewTag = &#039;[object DataView]&#039;,
    float32Tag = &#039;[object Float32Array]&#039;,
    float64Tag = &#039;[object Float64Array]&#039;,
    int8Tag = &#039;[object Int8Array]&#039;,
    int16Tag = &#039;[object Int16Array]&#039;,
    int32Tag = &#039;[object Int32Array]&#039;,
    uint8Tag = &#039;[object Uint8Array]&#039;,
    uint8ClampedTag = &#039;[object Uint8ClampedArray]&#039;,
    uint16Tag = &#039;[object Uint16Array]&#039;,
    uint32Tag = &#039;[object Uint32Array]&#039;;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;
var freeGlobal = typeof global == &#039;object&#039; &amp;&amp; global &amp;&amp; global.Object === Object &amp;&amp; global;
var freeSelf = typeof self == &#039;object&#039; &amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self;
var root = freeGlobal || freeSelf || Function(&#039;return this&#039;)();
var freeExports = typeof exports == &#039;object&#039; &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;
var freeModule = freeExports &amp;&amp; typeof module == &#039;object&#039; &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; module;
var moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports;
var freeProcess = moduleExports &amp;&amp; freeGlobal.process;
var nodeUtil = (function() {
  try {
    return freeProcess &amp;&amp; freeProcess.binding &amp;&amp; freeProcess.binding(&#039;util&#039;);
  } catch (e) {}
}());
var nodeIsTypedArray = nodeUtil &amp;&amp; nodeUtil.isTypedArray;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index &lt; n) {
    result[index] = iteratee(index);
  }
  return result;
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
function getValue(object, key) {
  return object == null ? undefined : object[key];
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function safeGet(object, key) {
  return key == &#039;__proto__&#039;
    ? undefined
    : object[key];
}
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;
var coreJsData = root[&#039;__core-js_shared__&#039;];
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData &amp;&amp; coreJsData.keys &amp;&amp; coreJsData.keys.IE_PROTO || &#039;&#039;);
  return uid ? (&#039;Symbol(src)_1.&#039; + uid) : &#039;&#039;;
}());
var nativeObjectToString = objectProto.toString;
var objectCtorString = funcToString.call(Object);
var reIsNative = RegExp(&#039;^&#039; +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, &#039;\\$&amp;&#039;)
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, &#039;$1.*?&#039;) + &#039;$&#039;
);
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, &#039;defineProperty&#039;);
    func({}, &#039;&#039;, {});
    return func;
  } catch (e) {}
}());
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;
var Map = getNative(root, &#039;Map&#039;),
    nativeCreate = getNative(Object, &#039;create&#039;);
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index &lt; length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) &amp;&amp; delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate &amp;&amp; value === undefined) ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype[&#039;delete&#039;] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index &lt; length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index &lt; 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index &lt; 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) &gt; -1;
}
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index &lt; 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype[&#039;delete&#039;] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index &lt; length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    &#039;hash&#039;: new Hash,
    &#039;map&#039;: new (Map || ListCache),
    &#039;string&#039;: new Hash
  };
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)[&#039;delete&#039;](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype[&#039;delete&#039;] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__,
      result = data[&#039;delete&#039;](key);

  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length &lt; LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype[&#039;delete&#039;] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr &amp;&amp; isArguments(value),
      isBuff = !isArr &amp;&amp; !isArg &amp;&amp; isBuffer(value),
      isType = !isArr &amp;&amp; !isArg &amp;&amp; !isBuff &amp;&amp; isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &amp;&amp;
        !(skipIndexes &amp;&amp; (
           key == &#039;length&#039; ||
           (isBuff &amp;&amp; (key == &#039;offset&#039; || key == &#039;parent&#039;)) ||
           (isType &amp;&amp; (key == &#039;buffer&#039; || key == &#039;byteLength&#039; || key == &#039;byteOffset&#039;)) ||
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}
function assignMergeValue(object, key, value) {
  if ((value !== undefined &amp;&amp; !eq(object[key], value)) ||
      (value === undefined &amp;&amp; !(key in object))) {
    baseAssignValue(object, key, value);
  }
}
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) &amp;&amp; eq(objValue, value)) ||
      (value === undefined &amp;&amp; !(key in object))) {
    baseAssignValue(object, key, value);
  }
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseAssignValue(object, key, value) {
  if (key == &#039;__proto__&#039; &amp;&amp; defineProperty) {
    defineProperty(object, key, {
      &#039;configurable&#039;: true,
      &#039;enumerable&#039;: true,
      &#039;value&#039;: value,
      &#039;writable&#039;: true
    });
  } else {
    object[key] = value;
  }
}
var baseFor = createBaseFor();
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag &amp;&amp; symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}
function baseIsArguments(value) {
  return isObjectLike(value) &amp;&amp; baseGetTag(value) == argsTag;
}
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
  return isObjectLike(value) &amp;&amp;
    isLength(value.length) &amp;&amp; !!typedArrayTags[baseGetTag(value)];
}
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == &#039;constructor&#039; &amp;&amp; (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + &#039;&#039;), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + &#039;&#039;), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr &amp;&amp; isBuffer(srcValue),
        isTyped = !isArr &amp;&amp; !isBuff &amp;&amp; isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex &amp;&amp; isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack[&#039;delete&#039;](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + &#039;&#039;);
}
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, &#039;toString&#039;, {
    &#039;configurable&#039;: true,
    &#039;enumerable&#039;: false,
    &#039;value&#039;: constant(string),
    &#039;writable&#039;: true
  });
};
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index &lt; length) {
    array[index] = source[index];
  }
  return array;
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index &lt; length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length &gt; 1 ? sources[length - 1] : undefined,
        guard = length &gt; 2 ? sources[2] : undefined;

    customizer = (assigner.length &gt; 3 &amp;&amp; typeof customizer == &#039;function&#039;)
      ? (length--, customizer)
      : undefined;

    if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length &lt; 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index &lt; length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == &#039;string&#039; ? &#039;string&#039; : &#039;hash&#039;]
    : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function initCloneObject(object) {
  return (typeof object.constructor == &#039;function&#039; &amp;&amp; !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &amp;&amp;
    (type == &#039;number&#039; ||
      (type != &#039;symbol&#039; &amp;&amp; reIsUint.test(value))) &amp;&amp;
        (value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length);
}
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == &#039;number&#039;
        ? (isArrayLike(object) &amp;&amp; isIndex(index, object.length))
        : (type == &#039;string&#039; &amp;&amp; index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}
function isKeyable(value) {
  var type = typeof value;
  return (type == &#039;string&#039; || type == &#039;number&#039; || type == &#039;symbol&#039; || type == &#039;boolean&#039;)
    ? (value !== &#039;__proto__&#039;)
    : (value === null);
}
function isMasked(func) {
  return !!maskSrcKey &amp;&amp; (maskSrcKey in func);
}
function isPrototype(value) {
  var Ctor = value &amp;&amp; value.constructor,
      proto = (typeof Ctor == &#039;function&#039; &amp;&amp; Ctor.prototype) || objectProto;

  return value === proto;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
function objectToString(value) {
  return nativeObjectToString.call(value);
}
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index &lt; length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index &lt; start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var setToString = shortOut(baseSetToString);
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining &gt; 0) {
      if (++count &gt;= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + &#039;&#039;);
    } catch (e) {}
  }
  return &#039;&#039;;
}
function eq(value, other) {
  return value === other || (value !== value &amp;&amp; other !== other);
}
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) &amp;&amp; hasOwnProperty.call(value, &#039;callee&#039;) &amp;&amp;
    !propertyIsEnumerable.call(value, &#039;callee&#039;);
};
var isArray = Array.isArray;
function isArrayLike(value) {
  return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) &amp;&amp; isArrayLike(value);
}
var isBuffer = nativeIsBuffer || stubFalse;
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
function isLength(value) {
  return typeof value == &#039;number&#039; &amp;&amp;
    value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER;
}
function isObject(value) {
  var type = typeof value;
  return value != null &amp;&amp; (type == &#039;object&#039; || type == &#039;function&#039;);
}
function isObjectLike(value) {
  return value != null &amp;&amp; typeof value == &#039;object&#039;;
}
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, &#039;constructor&#039;) &amp;&amp; proto.constructor;
  return typeof Ctor == &#039;function&#039; &amp;&amp; Ctor instanceof Ctor &amp;&amp;
    funcToString.call(Ctor) == objectCtorString;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
function constant(value) {
  return function() {
    return value;
  };
}
function identity(value) {
  return value;
}
function stubFalse() {
  return false;
}

module.exports = merge;

}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {});
},{}]},{},[2])(2);
});
});

ace.define(&quot;ace/mode/yaml_worker&quot;,[], function(require, exports) {
&quot;use strict&quot;;

var oop = require(&quot;../lib/oop&quot;);
var Mirror = require(&quot;../worker/mirror&quot;).Mirror;
var lint = require(&quot;./yaml/yaml-lint&quot;).lint;

var YamlWorker = exports.YamlWorker = function(sender) {
    Mirror.call(this, sender);
    this.setTimeout(500);
    this.setOptions();
};

oop.inherits(YamlWorker, Mirror);

(function() {
    this.setOptions = function() {
        this.doc.getValue() &amp;&amp; this.deferredUpdate.schedule(100);
    };

    this.changeOptions = function(newOptions) {
        oop.mixin(this.options, newOptions);
        this.doc.getValue() &amp;&amp; this.deferredUpdate.schedule(100);
    };

    this.onUpdate = function() {
        var _this = this;
        var value = this.doc.getValue();
        var errors = [];

        lint(value, {}, function(error) {
            if (!error) {
                _this.sender.emit(&quot;annotate&quot;, errors);
                return;
            }
            var markDefined = !!error.mark;
            errors.push({
                row: markDefined ? error.mark.line : 0,
                column: markDefined ? error.mark.column : 0,
                text: error.reason,
                type: &#039;error&#039;,
                raw: error
            });

            _this.sender.emit(&quot;annotate&quot;, errors);
        });
    };

}).call(YamlWorker.prototype);

});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
