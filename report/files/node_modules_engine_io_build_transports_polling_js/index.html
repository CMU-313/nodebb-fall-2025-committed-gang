<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/engine.io/build/transports/polling.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/engine.io/build/transports/polling.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.08</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">333</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">44.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.60</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.Polling = void 0;
const transport_1 = require(&quot;../transport&quot;);
const zlib_1 = require(&quot;zlib&quot;);
const accepts = require(&quot;accepts&quot;);
const debug_1 = require(&quot;debug&quot;);
const debug = (0, debug_1.default)(&quot;engine:polling&quot;);
const compressionMethods = {
    gzip: zlib_1.createGzip,
    deflate: zlib_1.createDeflate,
};
class Polling extends transport_1.Transport {
    /**
     * HTTP polling constructor.
     */
    constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
    }
    /**
     * Transport name
     */
    get name() {
        return &quot;polling&quot;;
    }
    /**
     * Overrides onRequest.
     *
     * @param {EngineRequest} req
     * @package
     */
    onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if (&quot;GET&quot; === req.method) {
            this.onPollRequest(req, res);
        }
        else if (&quot;POST&quot; === req.method) {
            this.onDataRequest(req, res);
        }
        else {
            res.writeHead(500);
            res.end();
        }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @private
     */
    onPollRequest(req, res) {
        if (this.req) {
            debug(&quot;request overlap&quot;);
            // assert: this.res, &#039;.req and .res should be (un)set together&#039;
            this.onError(&quot;overlap from client&quot;);
            res.writeHead(400);
            res.end();
            return;
        }
        debug(&quot;setting request&quot;);
        this.req = req;
        this.res = res;
        const onClose = () =&gt; {
            this.onError(&quot;poll connection closed prematurely&quot;);
        };
        const cleanup = () =&gt; {
            req.removeListener(&quot;close&quot;, onClose);
            this.req = this.res = null;
        };
        req.cleanup = cleanup;
        req.on(&quot;close&quot;, onClose);
        this.writable = true;
        this.emit(&quot;ready&quot;);
        // if we&#039;re still writable but had a pending close, trigger an empty send
        if (this.writable &amp;&amp; this.shouldClose) {
            debug(&quot;triggering empty send to append close packet&quot;);
            this.send([{ type: &quot;noop&quot; }]);
        }
    }
    /**
     * The client sends a request with data.
     *
     * @private
     */
    onDataRequest(req, res) {
        if (this.dataReq) {
            // assert: this.dataRes, &#039;.dataReq and .dataRes should be (un)set together&#039;
            this.onError(&quot;data request overlap from client&quot;);
            res.writeHead(400);
            res.end();
            return;
        }
        const isBinary = &quot;application/octet-stream&quot; === req.headers[&quot;content-type&quot;];
        if (isBinary &amp;&amp; this.protocol === 4) {
            return this.onError(&quot;invalid content&quot;);
        }
        this.dataReq = req;
        this.dataRes = res;
        let chunks = isBinary ? Buffer.concat([]) : &quot;&quot;;
        const cleanup = () =&gt; {
            req.removeListener(&quot;data&quot;, onData);
            req.removeListener(&quot;end&quot;, onEnd);
            req.removeListener(&quot;close&quot;, onClose);
            this.dataReq = this.dataRes = chunks = null;
        };
        const onClose = () =&gt; {
            cleanup();
            this.onError(&quot;data request connection closed prematurely&quot;);
        };
        const onData = (data) =&gt; {
            let contentLength;
            if (isBinary) {
                chunks = Buffer.concat([chunks, data]);
                contentLength = chunks.length;
            }
            else {
                chunks += data;
                contentLength = Buffer.byteLength(chunks);
            }
            if (contentLength &gt; this.maxHttpBufferSize) {
                res.writeHead(413).end();
                cleanup();
            }
        };
        const onEnd = () =&gt; {
            this.onData(chunks);
            const headers = {
                // text/html is required instead of text/plain to avoid an
                // unwanted download dialog on certain user-agents (GH-43)
                &quot;Content-Type&quot;: &quot;text/html&quot;,
                &quot;Content-Length&quot;: &quot;2&quot;,
            };
            res.writeHead(200, this.headers(req, headers));
            res.end(&quot;ok&quot;);
            cleanup();
        };
        req.on(&quot;close&quot;, onClose);
        if (!isBinary)
            req.setEncoding(&quot;utf8&quot;);
        req.on(&quot;data&quot;, onData);
        req.on(&quot;end&quot;, onEnd);
    }
    /**
     * Processes the incoming data payload.
     *
     * @param data - encoded payload
     * @protected
     */
    onData(data) {
        debug(&#039;received &quot;%s&quot;&#039;, data);
        const callback = (packet) =&gt; {
            if (&quot;close&quot; === packet.type) {
                debug(&quot;got xhr close packet&quot;);
                this.onClose();
                return false;
            }
            this.onPacket(packet);
        };
        if (this.protocol === 3) {
            this.parser.decodePayload(data, callback);
        }
        else {
            this.parser.decodePayload(data).forEach(callback);
        }
    }
    /**
     * Overrides onClose.
     *
     * @private
     */
    onClose() {
        if (this.writable) {
            // close pending poll request
            this.send([{ type: &quot;noop&quot; }]);
        }
        super.onClose();
    }
    send(packets) {
        this.writable = false;
        if (this.shouldClose) {
            debug(&quot;appending close packet to payload&quot;);
            packets.push({ type: &quot;close&quot; });
            this.shouldClose();
            this.shouldClose = null;
        }
        const doWrite = (data) =&gt; {
            const compress = packets.some((packet) =&gt; {
                return packet.options &amp;&amp; packet.options.compress;
            });
            this.write(data, { compress });
        };
        if (this.protocol === 3) {
            this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        }
        else {
            this.parser.encodePayload(packets, doWrite);
        }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @private
     */
    write(data, options) {
        debug(&#039;writing &quot;%s&quot;&#039;, data);
        this.doWrite(data, options, () =&gt; {
            this.req.cleanup();
            this.emit(&quot;drain&quot;);
        });
    }
    /**
     * Performs the write.
     *
     * @protected
     */
    doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === &quot;string&quot;;
        const contentType = isString
            ? &quot;text/plain; charset=UTF-8&quot;
            : &quot;application/octet-stream&quot;;
        const headers = {
            &quot;Content-Type&quot;: contentType,
        };
        const respond = (data) =&gt; {
            headers[&quot;Content-Length&quot;] =
                &quot;string&quot; === typeof data ? Buffer.byteLength(data) : data.length;
            this.res.writeHead(200, this.headers(this.req, headers));
            this.res.end(data);
            callback();
        };
        if (!this.httpCompression || !options.compress) {
            respond(data);
            return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len &lt; this.httpCompression.threshold) {
            respond(data);
            return;
        }
        const encoding = accepts(this.req).encodings([&quot;gzip&quot;, &quot;deflate&quot;]);
        if (!encoding) {
            respond(data);
            return;
        }
        this.compress(data, encoding, (err, data) =&gt; {
            if (err) {
                this.res.writeHead(500);
                this.res.end();
                callback(err);
                return;
            }
            headers[&quot;Content-Encoding&quot;] = encoding;
            respond(data);
        });
    }
    /**
     * Compresses data.
     *
     * @private
     */
    compress(data, encoding, callback) {
        debug(&quot;compressing&quot;);
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression)
            .on(&quot;error&quot;, callback)
            .on(&quot;data&quot;, function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
        })
            .on(&quot;end&quot;, function () {
            callback(null, Buffer.concat(buffers, nread));
        })
            .end(data);
    }
    /**
     * Closes the transport.
     *
     * @private
     */
    doClose(fn) {
        debug(&quot;closing&quot;);
        let closeTimeoutTimer;
        if (this.dataReq) {
            debug(&quot;aborting ongoing data request&quot;);
            this.dataReq.destroy();
        }
        const onClose = () =&gt; {
            clearTimeout(closeTimeoutTimer);
            fn();
            this.onClose();
        };
        if (this.writable) {
            debug(&quot;transport writable - closing right away&quot;);
            this.send([{ type: &quot;close&quot; }]);
            onClose();
        }
        else if (this.discarded) {
            debug(&quot;transport discarded - closing right away&quot;);
            onClose();
        }
        else {
            debug(&quot;transport not writable - buffering orderly close&quot;);
            this.shouldClose = onClose;
            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
    }
    /**
     * Returns headers for a response.
     *
     * @param {http.IncomingMessage} req
     * @param {Object} headers - extra headers
     * @private
     */
    headers(req, headers = {}) {
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers[&quot;user-agent&quot;];
        if (ua &amp;&amp; (~ua.indexOf(&quot;;MSIE&quot;) || ~ua.indexOf(&quot;Trident/&quot;))) {
            headers[&quot;X-XSS-Protection&quot;] = &quot;0&quot;;
        }
        headers[&quot;cache-control&quot;] = &quot;no-store&quot;;
        this.emit(&quot;headers&quot;, headers, req);
        return headers;
    }
}
exports.Polling = Polling;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
