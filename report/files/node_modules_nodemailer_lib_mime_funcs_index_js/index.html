<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodemailer/lib/mime-funcs/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodemailer/lib/mime-funcs/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">626</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">122.58</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.16</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint no-control-regex:0 */

&#039;use strict&#039;;

const base64 = require(&#039;../base64&#039;);
const qp = require(&#039;../qp&#039;);
const mimeTypes = require(&#039;./mime-types&#039;);

module.exports = {
    /**
     * Checks if a value is plaintext string (uses only printable 7bit chars)
     *
     * @param {String} value String to be tested
     * @returns {Boolean} true if it is a plaintext string
     */
    isPlainText(value, isParam) {
        const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f&quot;\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
        if (typeof value !== &#039;string&#039; || re.test(value)) {
            return false;
        } else {
            return true;
        }
    },

    /**
     * Checks if a multi line string containes lines longer than the selected value.
     *
     * Useful when detecting if a mail message needs any processing at all â€“
     * if only plaintext characters are used and lines are short, then there is
     * no need to encode the values in any way. If the value is plaintext but has
     * longer lines then allowed, then use format=flowed
     *
     * @param {Number} lineLength Max line length to check for
     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
     */
    hasLongerLines(str, lineLength) {
        if (str.length &gt; 128 * 1024) {
            // do not test strings longer than 128kB
            return true;
        }
        return new RegExp(&#039;^.{&#039; + (lineLength + 1) + &#039;,}&#039;, &#039;m&#039;).test(str);
    },

    /**
     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding=&#039;Q&#039; Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @return {String} Single or several mime words joined together
     */
    encodeWord(data, mimeWordEncoding, maxLength) {
        mimeWordEncoding = (mimeWordEncoding || &#039;Q&#039;).toString().toUpperCase().trim().charAt(0);
        maxLength = maxLength || 0;

        let encodedStr;
        let toCharset = &#039;UTF-8&#039;;

        if (maxLength &amp;&amp; maxLength &gt; 7 + toCharset.length) {
            maxLength -= 7 + toCharset.length;
        }

        if (mimeWordEncoding === &#039;Q&#039;) {
            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
            encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, chr =&gt; {
                let ord = chr.charCodeAt(0).toString(16).toUpperCase();
                if (chr === &#039; &#039;) {
                    return &#039;_&#039;;
                } else {
                    return &#039;=&#039; + (ord.length === 1 ? &#039;0&#039; + ord : ord);
                }
            });
        } else if (mimeWordEncoding === &#039;B&#039;) {
            encodedStr = typeof data === &#039;string&#039; ? data : base64.encode(data);
            maxLength = maxLength ? Math.max(3, ((maxLength - (maxLength % 4)) / 4) * 3) : 0;
        }

        if (maxLength &amp;&amp; (mimeWordEncoding !== &#039;B&#039; ? encodedStr : base64.encode(data)).length &gt; maxLength) {
            if (mimeWordEncoding === &#039;Q&#039;) {
                encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join(&#039;?= =?&#039; + toCharset + &#039;?&#039; + mimeWordEncoding + &#039;?&#039;);
            } else {
                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences
                let parts = [];
                let lpart = &#039;&#039;;
                for (let i = 0, len = encodedStr.length; i &lt; len; i++) {
                    let chr = encodedStr.charAt(i);

                    if (/[\ud83c\ud83d\ud83e]/.test(chr) &amp;&amp; i &lt; len - 1) {
                        // composite emoji byte, so add the next byte as well
                        chr += encodedStr.charAt(++i);
                    }

                    // check if we can add this character to the existing string
                    // without breaking byte length limit
                    if (Buffer.byteLength(lpart + chr) &lt;= maxLength || i === 0) {
                        lpart += chr;
                    } else {
                        // we hit the length limit, so push the existing string and start over
                        parts.push(base64.encode(lpart));
                        lpart = chr;
                    }
                }
                if (lpart) {
                    parts.push(base64.encode(lpart));
                }

                if (parts.length &gt; 1) {
                    encodedStr = parts.join(&#039;?= =?&#039; + toCharset + &#039;?&#039; + mimeWordEncoding + &#039;?&#039;);
                } else {
                    encodedStr = parts.join(&#039;&#039;);
                }
            }
        } else if (mimeWordEncoding === &#039;B&#039;) {
            encodedStr = base64.encode(data);
        }

        return &#039;=?&#039; + toCharset + &#039;?&#039; + mimeWordEncoding + &#039;?&#039; + encodedStr + (encodedStr.substr(-2) === &#039;?=&#039; ? &#039;&#039; : &#039;?=&#039;);
    },

    /**
     * Finds word sequences with non ascii text and converts these to mime words
     *
     * @param {String} value String to be encoded
     * @param {String} mimeWordEncoding=&#039;Q&#039; Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
     * @return {String} String with possible mime words
     */
    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
        maxLength = maxLength || 0;

        let encodedValue;

        // find first word with a non-printable ascii or special symbol in it
        let firstMatch = value.match(/(?:^|\s)([^\s]*[&quot;\u0080-\uFFFF])/);
        if (!firstMatch) {
            return value;
        }

        if (encodeAll) {
            // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything

            return this.encodeWord(value, mimeWordEncoding, maxLength);
        }

        // find the last word with a non-printable ascii in it
        let lastMatch = value.match(/([&quot;\u0080-\uFFFF][^\s]*)[^&quot;\u0080-\uFFFF]*$/);
        if (!lastMatch) {
            // should not happen
            return value;
        }

        let startIndex =
            firstMatch.index +
            (
                firstMatch[0].match(/[^\s]/) || {
                    index: 0
                }
            ).index;
        let endIndex = lastMatch.index + (lastMatch[1] || &#039;&#039;).length;

        encodedValue =
            (startIndex ? value.substr(0, startIndex) : &#039;&#039;) +
            this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || &#039;Q&#039;, maxLength) +
            (endIndex &lt; value.length ? value.substr(endIndex) : &#039;&#039;);

        return encodedValue;
    },

    /**
     * Joins parsed header value together as &#039;value; param1=value1; param2=value2&#039;
     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
     * @param {Object} structured Parsed header value
     * @return {String} joined header value
     */
    buildHeaderValue(structured) {
        let paramsArray = [];

        Object.keys(structured.params || {}).forEach(param =&gt; {
            // filename might include unicode characters so it is a special case
            // other values probably do not
            let value = structured.params[param];
            if (!this.isPlainText(value, true) || value.length &gt;= 75) {
                this.buildHeaderParam(param, value, 50).forEach(encodedParam =&gt; {
                    if (!/[\s&quot;\\;:/=(),&lt;&gt;@[\]?]|^[-&#039;]|&#039;$/.test(encodedParam.value) || encodedParam.key.substr(-1) === &#039;*&#039;) {
                        paramsArray.push(encodedParam.key + &#039;=&#039; + encodedParam.value);
                    } else {
                        paramsArray.push(encodedParam.key + &#039;=&#039; + JSON.stringify(encodedParam.value));
                    }
                });
            } else if (/[\s&#039;&quot;\\;:/=(),&lt;&gt;@[\]?]|^-/.test(value)) {
                paramsArray.push(param + &#039;=&#039; + JSON.stringify(value));
            } else {
                paramsArray.push(param + &#039;=&#039; + value);
            }
        });

        return structured.value + (paramsArray.length ? &#039;; &#039; + paramsArray.join(&#039;; &#039;) : &#039;&#039;);
    },

    /**
     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
     * Useful for splitting long parameter values.
     *
     * For example
     *      title=&quot;unicode string&quot;
     * becomes
     *     title*0*=utf-8&#039;&#039;unicode
     *     title*1*=%20string
     *
     * @param {String|Buffer} data String to be encoded
     * @param {Number} [maxLength=50] Max length for generated chunks
     * @param {String} [fromCharset=&#039;UTF-8&#039;] Source sharacter set
     * @return {Array} A list of encoded keys and headers
     */
    buildHeaderParam(key, data, maxLength) {
        let list = [];
        let encodedStr = typeof data === &#039;string&#039; ? data : (data || &#039;&#039;).toString();
        let encodedStrArr;
        let chr, ord;
        let line;
        let startPos = 0;
        let i, len;

        maxLength = maxLength || 50;

        // process ascii only text
        if (this.isPlainText(data, true)) {
            // check if conversion is even needed
            if (encodedStr.length &lt;= maxLength) {
                return [
                    {
                        key,
                        value: encodedStr
                    }
                ];
            }

            encodedStr = encodedStr.replace(new RegExp(&#039;.{&#039; + maxLength + &#039;}&#039;, &#039;g&#039;), str =&gt; {
                list.push({
                    line: str
                });
                return &#039;&#039;;
            });

            if (encodedStr) {
                list.push({
                    line: encodedStr
                });
            }
        } else {
            if (/[\uD800-\uDBFF]/.test(encodedStr)) {
                // string containts surrogate pairs, so normalize it to an array of bytes
                encodedStrArr = [];
                for (i = 0, len = encodedStr.length; i &lt; len; i++) {
                    chr = encodedStr.charAt(i);
                    ord = chr.charCodeAt(0);
                    if (ord &gt;= 0xd800 &amp;&amp; ord &lt;= 0xdbff &amp;&amp; i &lt; len - 1) {
                        chr += encodedStr.charAt(i + 1);
                        encodedStrArr.push(chr);
                        i++;
                    } else {
                        encodedStrArr.push(chr);
                    }
                }
                encodedStr = encodedStrArr;
            }

            // first line includes the charset and language info and needs to be encoded
            // even if it does not contain any unicode characters
            line = &#039;utf-8\x27\x27&#039;;
            let encoded = true;
            startPos = 0;

            // process text with unicode or special chars
            for (i = 0, len = encodedStr.length; i &lt; len; i++) {
                chr = encodedStr[i];

                if (encoded) {
                    chr = this.safeEncodeURIComponent(chr);
                } else {
                    // try to urlencode current char
                    chr = chr === &#039; &#039; ? chr : this.safeEncodeURIComponent(chr);
                    // By default it is not required to encode a line, the need
                    // only appears when the string contains unicode or special chars
                    // in this case we start processing the line over and encode all chars
                    if (chr !== encodedStr[i]) {
                        // Check if it is even possible to add the encoded char to the line
                        // If not, there is no reason to use this line, just push it to the list
                        // and start a new line with the char that needs encoding
                        if ((this.safeEncodeURIComponent(line) + chr).length &gt;= maxLength) {
                            list.push({
                                line,
                                encoded
                            });
                            line = &#039;&#039;;
                            startPos = i - 1;
                        } else {
                            encoded = true;
                            i = startPos;
                            line = &#039;&#039;;
                            continue;
                        }
                    }
                }

                // if the line is already too long, push it to the list and start a new one
                if ((line + chr).length &gt;= maxLength) {
                    list.push({
                        line,
                        encoded
                    });
                    line = chr = encodedStr[i] === &#039; &#039; ? &#039; &#039; : this.safeEncodeURIComponent(encodedStr[i]);
                    if (chr === encodedStr[i]) {
                        encoded = false;
                        startPos = i - 1;
                    } else {
                        encoded = true;
                    }
                } else {
                    line += chr;
                }
            }

            if (line) {
                list.push({
                    line,
                    encoded
                });
            }
        }

        return list.map((item, i) =&gt; ({
            // encoded lines: {name}*{part}*
            // unencoded lines: {name}*{part}
            // if any line needs to be encoded then the first line (part==0) is always encoded
            key: key + &#039;*&#039; + i + (item.encoded ? &#039;*&#039; : &#039;&#039;),
            value: item.line
        }));
    },

    /**
     * Parses a header value with key=value arguments into a structured
     * object.
     *
     *   parseHeaderValue(&#039;content-type: text/plain; CHARSET=&#039;UTF-8&#039;&#039;) -&gt;
     *   {
     *     &#039;value&#039;: &#039;text/plain&#039;,
     *     &#039;params&#039;: {
     *       &#039;charset&#039;: &#039;UTF-8&#039;
     *     }
     *   }
     *
     * @param {String} str Header value
     * @return {Object} Header value as a parsed structure
     */
    parseHeaderValue(str) {
        let response = {
            value: false,
            params: {}
        };
        let key = false;
        let value = &#039;&#039;;
        let type = &#039;value&#039;;
        let quote = false;
        let escaped = false;
        let chr;

        for (let i = 0, len = str.length; i &lt; len; i++) {
            chr = str.charAt(i);
            if (type === &#039;key&#039;) {
                if (chr === &#039;=&#039;) {
                    key = value.trim().toLowerCase();
                    type = &#039;value&#039;;
                    value = &#039;&#039;;
                    continue;
                }
                value += chr;
            } else {
                if (escaped) {
                    value += chr;
                } else if (chr === &#039;\\&#039;) {
                    escaped = true;
                    continue;
                } else if (quote &amp;&amp; chr === quote) {
                    quote = false;
                } else if (!quote &amp;&amp; chr === &#039;&quot;&#039;) {
                    quote = chr;
                } else if (!quote &amp;&amp; chr === &#039;;&#039;) {
                    if (key === false) {
                        response.value = value.trim();
                    } else {
                        response.params[key] = value.trim();
                    }
                    type = &#039;key&#039;;
                    value = &#039;&#039;;
                } else {
                    value += chr;
                }
                escaped = false;
            }
        }

        if (type === &#039;value&#039;) {
            if (key === false) {
                response.value = value.trim();
            } else {
                response.params[key] = value.trim();
            }
        } else if (value.trim()) {
            response.params[value.trim().toLowerCase()] = &#039;&#039;;
        }

        // handle parameter value continuations
        // https://tools.ietf.org/html/rfc2231#section-3

        // preprocess values
        Object.keys(response.params).forEach(key =&gt; {
            let actualKey, nr, match, value;
            if ((match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/))) {
                actualKey = key.substr(0, match.index);
                nr = Number(match[2] || match[3]) || 0;

                if (!response.params[actualKey] || typeof response.params[actualKey] !== &#039;object&#039;) {
                    response.params[actualKey] = {
                        charset: false,
                        values: []
                    };
                }

                value = response.params[key];

                if (nr === 0 &amp;&amp; match[0].substr(-1) === &#039;*&#039; &amp;&amp; (match = value.match(/^([^&#039;]*)&#039;[^&#039;]*&#039;(.*)$/))) {
                    response.params[actualKey].charset = match[1] || &#039;iso-8859-1&#039;;
                    value = match[2];
                }

                response.params[actualKey].values[nr] = value;

                // remove the old reference
                delete response.params[key];
            }
        });

        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
        Object.keys(response.params).forEach(key =&gt; {
            let value;
            if (response.params[key] &amp;&amp; Array.isArray(response.params[key].values)) {
                value = response.params[key].values.map(val =&gt; val || &#039;&#039;).join(&#039;&#039;);

                if (response.params[key].charset) {
                    // convert &quot;%AB&quot; to &quot;=?charset?Q?=AB?=&quot;
                    response.params[key] =
                        &#039;=?&#039; +
                        response.params[key].charset +
                        &#039;?Q?&#039; +
                        value
                            // fix invalidly encoded chars
                            .replace(/[=?_\s]/g, s =&gt; {
                                let c = s.charCodeAt(0).toString(16);
                                if (s === &#039; &#039;) {
                                    return &#039;_&#039;;
                                } else {
                                    return &#039;%&#039; + (c.length &lt; 2 ? &#039;0&#039; : &#039;&#039;) + c;
                                }
                            })
                            // change from urlencoding to percent encoding
                            .replace(/%/g, &#039;=&#039;) +
                        &#039;?=&#039;;
                } else {
                    response.params[key] = value;
                }
            }
        });

        return response;
    },

    /**
     * Returns file extension for a content type string. If no suitable extensions
     * are found, &#039;bin&#039; is used as the default extension
     *
     * @param {String} mimeType Content type to be checked for
     * @return {String} File extension
     */
    detectExtension: mimeType =&gt; mimeTypes.detectExtension(mimeType),

    /**
     * Returns content type for a file extension. If no suitable content types
     * are found, &#039;application/octet-stream&#039; is used as the default content type
     *
     * @param {String} extension Extension to be checked for
     * @return {String} File extension
     */
    detectMimeType: extension =&gt; mimeTypes.detectMimeType(extension),

    /**
     * Folds long lines, useful for folding header lines (afterSpace=false) and
     * flowed text (afterSpace=true)
     *
     * @param {String} str String to be folded
     * @param {Number} [lineLength=76] Maximum length of a line
     * @param {Boolean} afterSpace If true, leave a space in th end of a line
     * @return {String} String with folded lines
     */
    foldLines(str, lineLength, afterSpace) {
        str = (str || &#039;&#039;).toString();
        lineLength = lineLength || 76;

        let pos = 0,
            len = str.length,
            result = &#039;&#039;,
            line,
            match;

        while (pos &lt; len) {
            line = str.substr(pos, lineLength);
            if (line.length &lt; lineLength) {
                result += line;
                break;
            }
            if ((match = line.match(/^[^\n\r]*(\r?\n|\r)/))) {
                line = match[0];
                result += line;
                pos += line.length;
                continue;
            } else if ((match = line.match(/(\s+)[^\s]*$/)) &amp;&amp; match[0].length - (afterSpace ? (match[1] || &#039;&#039;).length : 0) &lt; line.length) {
                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || &#039;&#039;).length : 0)));
            } else if ((match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/))) {
                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || &#039;&#039;).length : 0));
            }

            result += line;
            pos += line.length;
            if (pos &lt; len) {
                result += &#039;\r\n&#039;;
            }
        }

        return result;
    },

    /**
     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
     *
     * @param {String} str Mime encoded string to be split up
     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
     * @return {Array} Split string
     */
    splitMimeEncodedString: (str, maxlen) =&gt; {
        let curLine,
            match,
            chr,
            done,
            lines = [];

        // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
        maxlen = Math.max(maxlen || 0, 12);

        while (str.length) {
            curLine = str.substr(0, maxlen);

            // move incomplete escaped char back to main
            if ((match = curLine.match(/[=][0-9A-F]?$/i))) {
                curLine = curLine.substr(0, match.index);
            }

            done = false;
            while (!done) {
                done = true;
                // check if not middle of a unicode char sequence
                if ((match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i))) {
                    chr = parseInt(match[1], 16);
                    // invalid sequence, move one char back anc recheck
                    if (chr &lt; 0xc2 &amp;&amp; chr &gt; 0x7f) {
                        curLine = curLine.substr(0, curLine.length - 3);
                        done = false;
                    }
                }
            }

            if (curLine.length) {
                lines.push(curLine);
            }
            str = str.substr(curLine.length);
        }

        return lines;
    },

    encodeURICharComponent: chr =&gt; {
        let res = &#039;&#039;;
        let ord = chr.charCodeAt(0).toString(16).toUpperCase();

        if (ord.length % 2) {
            ord = &#039;0&#039; + ord;
        }

        if (ord.length &gt; 2) {
            for (let i = 0, len = ord.length / 2; i &lt; len; i++) {
                res += &#039;%&#039; + ord.substr(i, 2);
            }
        } else {
            res += &#039;%&#039; + ord;
        }

        return res;
    },

    safeEncodeURIComponent(str) {
        str = (str || &#039;&#039;).toString();

        try {
            // might throw if we try to encode invalid sequences, eg. partial emoji
            str = encodeURIComponent(str);
        } catch (E) {
            // should never run
            return str.replace(/[^\x00-\x1F *&#039;()&lt;&gt;@,;:\\&quot;[\]?=\u007F-\uFFFF]+/g, &#039;&#039;);
        }

        // ensure chars that are not handled by encodeURICompent are converted as well
        return str.replace(/[\x00-\x1F *&#039;()&lt;&gt;@,;:\\&quot;[\]?=\u007F-\uFFFF]/g, chr =&gt; this.encodeURICharComponent(chr));
    }
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
