<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sshpk/lib/formats/pem.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sshpk/lib/formats/pem.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">44.94</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">291</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">48.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2018 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = require(&#039;assert-plus&#039;);
var asn1 = require(&#039;asn1&#039;);
var crypto = require(&#039;crypto&#039;);
var Buffer = require(&#039;safer-buffer&#039;).Buffer;
var algs = require(&#039;../algs&#039;);
var utils = require(&#039;../utils&#039;);
var Key = require(&#039;../key&#039;);
var PrivateKey = require(&#039;../private-key&#039;);

var pkcs1 = require(&#039;./pkcs1&#039;);
var pkcs8 = require(&#039;./pkcs8&#039;);
var sshpriv = require(&#039;./ssh-private&#039;);
var rfc4253 = require(&#039;./rfc4253&#039;);

var errors = require(&#039;../errors&#039;);

var OID_PBES2 = &#039;1.2.840.113549.1.5.13&#039;;
var OID_PBKDF2 = &#039;1.2.840.113549.1.5.12&#039;;

var OID_TO_CIPHER = {
	&#039;1.2.840.113549.3.7&#039;: &#039;3des-cbc&#039;,
	&#039;2.16.840.1.101.3.4.1.2&#039;: &#039;aes128-cbc&#039;,
	&#039;2.16.840.1.101.3.4.1.42&#039;: &#039;aes256-cbc&#039;
};
var CIPHER_TO_OID = {};
Object.keys(OID_TO_CIPHER).forEach(function (k) {
	CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
});

var OID_TO_HASH = {
	&#039;1.2.840.113549.2.7&#039;: &#039;sha1&#039;,
	&#039;1.2.840.113549.2.9&#039;: &#039;sha256&#039;,
	&#039;1.2.840.113549.2.11&#039;: &#039;sha512&#039;
};
var HASH_TO_OID = {};
Object.keys(OID_TO_HASH).forEach(function (k) {
	HASH_TO_OID[OID_TO_HASH[k]] = k;
});

/*
 * For reading we support both PKCS#1 and PKCS#8. If we find a private key,
 * we just take the public component of it and use that.
 */
function read(buf, options, forceType) {
	var input = buf;
	if (typeof (buf) !== &#039;string&#039;) {
		assert.buffer(buf, &#039;buf&#039;);
		buf = buf.toString(&#039;ascii&#039;);
	}

	var lines = buf.trim().split(/[\r\n]+/g);

	var m;
	var si = -1;
	while (!m &amp;&amp; si &lt; lines.length) {
		m = lines[++si].match(/*JSSTYLED*/
		    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	}
	assert.ok(m, &#039;invalid PEM header&#039;);

	var m2;
	var ei = lines.length;
	while (!m2 &amp;&amp; ei &gt; 0) {
		m2 = lines[--ei].match(/*JSSTYLED*/
		    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	}
	assert.ok(m2, &#039;invalid PEM footer&#039;);

	/* Begin and end banners must match key type */
	assert.equal(m[2], m2[2]);
	var type = m[2].toLowerCase();

	var alg;
	if (m[1]) {
		/* They also must match algorithms, if given */
		assert.equal(m[1], m2[1], &#039;PEM header and footer mismatch&#039;);
		alg = m[1].trim();
	}

	lines = lines.slice(si, ei + 1);

	var headers = {};
	while (true) {
		lines = lines.slice(1);
		m = lines[0].match(/*JSSTYLED*/
		    /^([A-Za-z0-9-]+): (.+)$/);
		if (!m)
			break;
		headers[m[1].toLowerCase()] = m[2];
	}

	/* Chop off the first and last lines */
	lines = lines.slice(0, -1).join(&#039;&#039;);
	buf = Buffer.from(lines, &#039;base64&#039;);

	var cipher, key, iv;
	if (headers[&#039;proc-type&#039;]) {
		var parts = headers[&#039;proc-type&#039;].split(&#039;,&#039;);
		if (parts[0] === &#039;4&#039; &amp;&amp; parts[1] === &#039;ENCRYPTED&#039;) {
			if (typeof (options.passphrase) === &#039;string&#039;) {
				options.passphrase = Buffer.from(
				    options.passphrase, &#039;utf-8&#039;);
			}
			if (!Buffer.isBuffer(options.passphrase)) {
				throw (new errors.KeyEncryptedError(
				    options.filename, &#039;PEM&#039;));
			} else {
				parts = headers[&#039;dek-info&#039;].split(&#039;,&#039;);
				assert.ok(parts.length === 2);
				cipher = parts[0].toLowerCase();
				iv = Buffer.from(parts[1], &#039;hex&#039;);
				key = utils.opensslKeyDeriv(cipher, iv,
				    options.passphrase, 1).key;
			}
		}
	}

	if (alg &amp;&amp; alg.toLowerCase() === &#039;encrypted&#039;) {
		var eder = new asn1.BerReader(buf);
		var pbesEnd;
		eder.readSequence();

		eder.readSequence();
		pbesEnd = eder.offset + eder.length;

		var method = eder.readOID();
		if (method !== OID_PBES2) {
			throw (new Error(&#039;Unsupported PEM/PKCS8 encryption &#039; +
			    &#039;scheme: &#039; + method));
		}

		eder.readSequence();	/* PBES2-params */

		eder.readSequence();	/* keyDerivationFunc */
		var kdfEnd = eder.offset + eder.length;
		var kdfOid = eder.readOID();
		if (kdfOid !== OID_PBKDF2)
			throw (new Error(&#039;Unsupported PBES2 KDF: &#039; + kdfOid));
		eder.readSequence();
		var salt = eder.readString(asn1.Ber.OctetString, true);
		var iterations = eder.readInt();
		var hashAlg = &#039;sha1&#039;;
		if (eder.offset &lt; kdfEnd) {
			eder.readSequence();
			var hashAlgOid = eder.readOID();
			hashAlg = OID_TO_HASH[hashAlgOid];
			if (hashAlg === undefined) {
				throw (new Error(&#039;Unsupported PBKDF2 hash: &#039; +
				    hashAlgOid));
			}
		}
		eder._offset = kdfEnd;

		eder.readSequence();	/* encryptionScheme */
		var cipherOid = eder.readOID();
		cipher = OID_TO_CIPHER[cipherOid];
		if (cipher === undefined) {
			throw (new Error(&#039;Unsupported PBES2 cipher: &#039; +
			    cipherOid));
		}
		iv = eder.readString(asn1.Ber.OctetString, true);

		eder._offset = pbesEnd;
		buf = eder.readString(asn1.Ber.OctetString, true);

		if (typeof (options.passphrase) === &#039;string&#039;) {
			options.passphrase = Buffer.from(
			    options.passphrase, &#039;utf-8&#039;);
		}
		if (!Buffer.isBuffer(options.passphrase)) {
			throw (new errors.KeyEncryptedError(
			    options.filename, &#039;PEM&#039;));
		}

		var cinfo = utils.opensshCipherInfo(cipher);

		cipher = cinfo.opensslName;
		key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,
		    options.passphrase);
		alg = undefined;
	}

	if (cipher &amp;&amp; key &amp;&amp; iv) {
		var cipherStream = crypto.createDecipheriv(cipher, key, iv);
		var chunk, chunks = [];
		cipherStream.once(&#039;error&#039;, function (e) {
			if (e.toString().indexOf(&#039;bad decrypt&#039;) !== -1) {
				throw (new Error(&#039;Incorrect passphrase &#039; +
				    &#039;supplied, could not decrypt key&#039;));
			}
			throw (e);
		});
		cipherStream.write(buf);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		buf = Buffer.concat(chunks);
	}

	/* The new OpenSSH internal format abuses PEM headers */
	if (alg &amp;&amp; alg.toLowerCase() === &#039;openssh&#039;)
		return (sshpriv.readSSHPrivate(type, buf, options));
	if (alg &amp;&amp; alg.toLowerCase() === &#039;ssh2&#039;)
		return (rfc4253.readType(type, buf, options));

	var der = new asn1.BerReader(buf);
	der.originalInput = input;

	/*
	 * All of the PEM file types start with a sequence tag, so chop it
	 * off here
	 */
	der.readSequence();

	/* PKCS#1 type keys name an algorithm in the banner explicitly */
	if (alg) {
		if (forceType)
			assert.strictEqual(forceType, &#039;pkcs1&#039;);
		return (pkcs1.readPkcs1(alg, type, der));
	} else {
		if (forceType)
			assert.strictEqual(forceType, &#039;pkcs8&#039;);
		return (pkcs8.readPkcs8(alg, type, der));
	}
}

function write(key, options, type) {
	assert.object(key);

	var alg = {
	    &#039;ecdsa&#039;: &#039;EC&#039;,
	    &#039;rsa&#039;: &#039;RSA&#039;,
	    &#039;dsa&#039;: &#039;DSA&#039;,
	    &#039;ed25519&#039;: &#039;EdDSA&#039;
	}[key.type];
	var header;

	var der = new asn1.BerWriter();

	if (PrivateKey.isPrivateKey(key)) {
		if (type &amp;&amp; type === &#039;pkcs8&#039;) {
			header = &#039;PRIVATE KEY&#039;;
			pkcs8.writePkcs8(der, key);
		} else {
			if (type)
				assert.strictEqual(type, &#039;pkcs1&#039;);
			header = alg + &#039; PRIVATE KEY&#039;;
			pkcs1.writePkcs1(der, key);
		}

	} else if (Key.isKey(key)) {
		if (type &amp;&amp; type === &#039;pkcs1&#039;) {
			header = alg + &#039; PUBLIC KEY&#039;;
			pkcs1.writePkcs1(der, key);
		} else {
			if (type)
				assert.strictEqual(type, &#039;pkcs8&#039;);
			header = &#039;PUBLIC KEY&#039;;
			pkcs8.writePkcs8(der, key);
		}

	} else {
		throw (new Error(&#039;key is not a Key or PrivateKey&#039;));
	}

	var tmp = der.buffer.toString(&#039;base64&#039;);
	var len = tmp.length + (tmp.length / 64) +
	    18 + 16 + header.length*2 + 10;
	var buf = Buffer.alloc(len);
	var o = 0;
	o += buf.write(&#039;-----BEGIN &#039; + header + &#039;-----\n&#039;, o);
	for (var i = 0; i &lt; tmp.length; ) {
		var limit = i + 64;
		if (limit &gt; tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write(&#039;-----END &#039; + header + &#039;-----\n&#039;, o);

	return (buf.slice(0, o));
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
