<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@stylistic/eslint-plugin-js/dist/rules/keyword-spacing.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@stylistic/eslint-plugin-js/dist/rules/keyword-spacing.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">338</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">64.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.95</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { K as KEYWORDS_JS, c as createRule, n as isNotOpeningParenToken, i as isTokenOnSameLine, E as isKeywordToken } from &#039;../utils.js&#039;;
import &#039;eslint-visitor-keys&#039;;
import &#039;espree&#039;;

const PREV_TOKEN = /^[)\]}&gt;]$/u;
const NEXT_TOKEN = /^(?:[([{&lt;~!]|\+\+?|--?)$/u;
const PREV_TOKEN_M = /^[)\]}&gt;*]$/u;
const NEXT_TOKEN_M = /^[{*]$/u;
const TEMPLATE_OPEN_PAREN = /\$\{$/u;
const TEMPLATE_CLOSE_PAREN = /^\}/u;
const CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;
const KEYS = KEYWORDS_JS.concat([&quot;as&quot;, &quot;async&quot;, &quot;await&quot;, &quot;from&quot;, &quot;get&quot;, &quot;let&quot;, &quot;of&quot;, &quot;satisfies&quot;, &quot;set&quot;, &quot;yield&quot;]);
(function() {
  KEYS.sort();
  for (let i = 1; i &lt; KEYS.length; ++i) {
    if (KEYS[i] === KEYS[i - 1])
      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
  }
})();
function isOpenParenOfTemplate(token) {
  return token.type === &quot;Template&quot; &amp;&amp; TEMPLATE_OPEN_PAREN.test(token.value);
}
function isCloseParenOfTemplate(token) {
  return token.type === &quot;Template&quot; &amp;&amp; TEMPLATE_CLOSE_PAREN.test(token.value);
}
var keywordSpacing = createRule({
  name: &quot;keyword-spacing&quot;,
  package: &quot;js&quot;,
  meta: {
    type: &quot;layout&quot;,
    docs: {
      description: &quot;Enforce consistent spacing before and after keywords&quot;
    },
    fixable: &quot;whitespace&quot;,
    schema: [
      {
        type: &quot;object&quot;,
        properties: {
          before: { type: &quot;boolean&quot;, default: true },
          after: { type: &quot;boolean&quot;, default: true },
          overrides: {
            type: &quot;object&quot;,
            properties: KEYS.reduce((retv, key) =&gt; {
              retv[key] = {
                type: &quot;object&quot;,
                properties: {
                  before: { type: &quot;boolean&quot; },
                  after: { type: &quot;boolean&quot; }
                },
                additionalProperties: false
              };
              return retv;
            }, {}),
            additionalProperties: false
          }
        },
        additionalProperties: false
      }
    ],
    messages: {
      expectedBefore: &#039;Expected space(s) before &quot;{{value}}&quot;.&#039;,
      expectedAfter: &#039;Expected space(s) after &quot;{{value}}&quot;.&#039;,
      unexpectedBefore: &#039;Unexpected space(s) before &quot;{{value}}&quot;.&#039;,
      unexpectedAfter: &#039;Unexpected space(s) after &quot;{{value}}&quot;.&#039;
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    const tokensToIgnore = /* @__PURE__ */ new WeakSet();
    function expectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken &amp;&amp; (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &amp;&amp; !isOpenParenOfTemplate(prevToken) &amp;&amp; !tokensToIgnore.has(prevToken) &amp;&amp; isTokenOnSameLine(prevToken, token) &amp;&amp; !sourceCode.isSpaceBetween(prevToken, token)) {
        context.report({
          loc: token.loc,
          messageId: &quot;expectedBefore&quot;,
          // @ts-expect-error index signature for string is missing
          data: token,
          fix(fixer) {
            return fixer.insertTextBefore(token, &quot; &quot;);
          }
        });
      }
    }
    function unexpectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken &amp;&amp; (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &amp;&amp; !isOpenParenOfTemplate(prevToken) &amp;&amp; !tokensToIgnore.has(prevToken) &amp;&amp; isTokenOnSameLine(prevToken, token) &amp;&amp; sourceCode.isSpaceBetween(prevToken, token)) {
        context.report({
          loc: { start: prevToken.loc.end, end: token.loc.start },
          messageId: &quot;unexpectedBefore&quot;,
          // @ts-expect-error index signature for string is missing
          data: token,
          fix(fixer) {
            return fixer.removeRange([prevToken.range[1], token.range[0]]);
          }
        });
      }
    }
    function expectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken &amp;&amp; (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &amp;&amp; !isCloseParenOfTemplate(nextToken) &amp;&amp; !tokensToIgnore.has(nextToken) &amp;&amp; isTokenOnSameLine(token, nextToken) &amp;&amp; !sourceCode.isSpaceBetween(token, nextToken)) {
        context.report({
          loc: token.loc,
          messageId: &quot;expectedAfter&quot;,
          // @ts-expect-error index signature for string is missing
          data: token,
          fix(fixer) {
            return fixer.insertTextAfter(token, &quot; &quot;);
          }
        });
      }
    }
    function unexpectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken &amp;&amp; (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &amp;&amp; !isCloseParenOfTemplate(nextToken) &amp;&amp; !tokensToIgnore.has(nextToken) &amp;&amp; isTokenOnSameLine(token, nextToken) &amp;&amp; sourceCode.isSpaceBetween(token, nextToken)) {
        context.report({
          loc: { start: token.loc.end, end: nextToken.loc.start },
          messageId: &quot;unexpectedAfter&quot;,
          // @ts-expect-error index signature for string is missing
          data: token,
          fix(fixer) {
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      }
    }
    function parseOptions(options = {}) {
      const before = options.before !== false;
      const after = options.after !== false;
      const defaultValue = {
        before: before ? expectSpaceBefore : unexpectSpaceBefore,
        after: after ? expectSpaceAfter : unexpectSpaceAfter
      };
      const overrides = options &amp;&amp; options.overrides || {};
      const retv = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i &lt; KEYS.length; ++i) {
        const key = KEYS[i];
        const override = overrides[key];
        if (override) {
          const thisBefore = &quot;before&quot; in override ? override.before : before;
          const thisAfter = &quot;after&quot; in override ? override.after : after;
          retv[key] = {
            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
          };
        } else {
          retv[key] = defaultValue;
        }
      }
      return retv;
    }
    const checkMethodMap = parseOptions(context.options[0]);
    function checkSpacingBefore(token, pattern) {
      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
    }
    function checkSpacingAfter(token, pattern) {
      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
    }
    function checkSpacingAround(token) {
      checkSpacingBefore(token);
      checkSpacingAfter(token);
    }
    function checkSpacingAroundFirstToken(node) {
      const firstToken = node &amp;&amp; sourceCode.getFirstToken(node);
      if (firstToken &amp;&amp; firstToken.type === &quot;Keyword&quot;)
        checkSpacingAround(firstToken);
    }
    function checkSpacingBeforeFirstToken(node) {
      const firstToken = node &amp;&amp; sourceCode.getFirstToken(node);
      if (firstToken &amp;&amp; firstToken.type === &quot;Keyword&quot;)
        checkSpacingBefore(firstToken);
    }
    function checkSpacingAroundTokenBefore(node) {
      if (node) {
        const token = sourceCode.getTokenBefore(node, isKeywordToken);
        if (token)
          checkSpacingAround(token);
      }
    }
    function checkSpacingForFunction(node) {
      const firstToken = node &amp;&amp; sourceCode.getFirstToken(node);
      if (firstToken &amp;&amp; (firstToken.type === &quot;Keyword&quot; &amp;&amp; firstToken.value === &quot;function&quot; || firstToken.value === &quot;async&quot;)) {
        checkSpacingBefore(firstToken);
      }
    }
    function checkSpacingForClass(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.superClass);
    }
    function checkSpacingForIfStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.alternate);
    }
    function checkSpacingForTryStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundFirstToken(node.handler);
      checkSpacingAroundTokenBefore(node.finalizer);
    }
    function checkSpacingForDoWhileStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.test);
    }
    function checkSpacingForForInStatement(node) {
      checkSpacingAroundFirstToken(node);
      const inToken = sourceCode.getTokenBefore(node.right, isNotOpeningParenToken);
      const previousToken = sourceCode.getTokenBefore(inToken);
      if (previousToken.type !== &quot;PrivateIdentifier&quot;)
        checkSpacingBefore(inToken);
      checkSpacingAfter(inToken);
    }
    function checkSpacingForForOfStatement(node) {
      if (node.await) {
        checkSpacingBefore(sourceCode.getFirstToken(node, 0));
        checkSpacingAfter(sourceCode.getFirstToken(node, 1));
      } else {
        checkSpacingAroundFirstToken(node);
      }
      const ofToken = sourceCode.getTokenBefore(node.right, isNotOpeningParenToken);
      const previousToken = sourceCode.getTokenBefore(ofToken);
      if (previousToken.type !== &quot;PrivateIdentifier&quot;)
        checkSpacingBefore(ofToken);
      checkSpacingAfter(ofToken);
    }
    function checkSpacingForModuleDeclaration(node) {
      const firstToken = sourceCode.getFirstToken(node);
      checkSpacingBefore(firstToken, PREV_TOKEN_M);
      checkSpacingAfter(firstToken, NEXT_TOKEN_M);
      if (node.type === &quot;ExportDefaultDeclaration&quot;)
        checkSpacingAround(sourceCode.getTokenAfter(firstToken));
      if (node.type === &quot;ExportAllDeclaration&quot; &amp;&amp; node.exported) {
        const asToken = sourceCode.getTokenBefore(node.exported);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
        checkSpacingAfter(asToken, NEXT_TOKEN_M);
      }
      if (&quot;source&quot; in node &amp;&amp; node.source) {
        const fromToken = sourceCode.getTokenBefore(node.source);
        checkSpacingBefore(fromToken, PREV_TOKEN_M);
        checkSpacingAfter(fromToken, NEXT_TOKEN_M);
      }
    }
    function checkSpacingForImportSpecifier(node) {
      if (node.imported.range[0] !== node.local.range[0]) {
        const asToken = sourceCode.getTokenBefore(node.local);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
      }
    }
    function checkSpacingForExportSpecifier(node) {
      if (node.local.range[0] !== node.exported.range[0]) {
        const asToken = sourceCode.getTokenBefore(node.exported);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
        checkSpacingAfter(asToken, NEXT_TOKEN_M);
      }
    }
    function checkSpacingForImportNamespaceSpecifier(node) {
      const asToken = sourceCode.getFirstToken(node, 1);
      checkSpacingBefore(asToken, PREV_TOKEN_M);
    }
    function checkSpacingForProperty(node) {
      if (&quot;static&quot; in node &amp;&amp; node.static)
        checkSpacingAroundFirstToken(node);
      if (node.kind === &quot;get&quot; || node.kind === &quot;set&quot; || (&quot;method&quot; in node &amp;&amp; node.method || node.type === &quot;MethodDefinition&quot;) &amp;&amp; &quot;async&quot; in node.value &amp;&amp; node.value.async) {
        const token = sourceCode.getTokenBefore(
          node.key,
          (tok) =&gt; {
            switch (tok.value) {
              case &quot;get&quot;:
              case &quot;set&quot;:
              case &quot;async&quot;:
                return true;
              default:
                return false;
            }
          }
        );
        if (!token)
          throw new Error(&quot;Failed to find token get, set, or async beside method name&quot;);
        checkSpacingAround(token);
      }
    }
    function checkSpacingForAwaitExpression(node) {
      checkSpacingBefore(sourceCode.getFirstToken(node));
    }
    return {
      // Statements
      &quot;DebuggerStatement&quot;: checkSpacingAroundFirstToken,
      &quot;WithStatement&quot;: checkSpacingAroundFirstToken,
      // Statements - Control flow
      &quot;BreakStatement&quot;: checkSpacingAroundFirstToken,
      &quot;ContinueStatement&quot;: checkSpacingAroundFirstToken,
      &quot;ReturnStatement&quot;: checkSpacingAroundFirstToken,
      &quot;ThrowStatement&quot;: checkSpacingAroundFirstToken,
      &quot;TryStatement&quot;: checkSpacingForTryStatement,
      // Statements - Choice
      &quot;IfStatement&quot;: checkSpacingForIfStatement,
      &quot;SwitchStatement&quot;: checkSpacingAroundFirstToken,
      &quot;SwitchCase&quot;: checkSpacingAroundFirstToken,
      // Statements - Loops
      &quot;DoWhileStatement&quot;: checkSpacingForDoWhileStatement,
      &quot;ForInStatement&quot;: checkSpacingForForInStatement,
      &quot;ForOfStatement&quot;: checkSpacingForForOfStatement,
      &quot;ForStatement&quot;: checkSpacingAroundFirstToken,
      &quot;WhileStatement&quot;: checkSpacingAroundFirstToken,
      // Statements - Declarations
      &quot;ClassDeclaration&quot;: checkSpacingForClass,
      &quot;ExportNamedDeclaration&quot;: checkSpacingForModuleDeclaration,
      &quot;ExportDefaultDeclaration&quot;: checkSpacingForModuleDeclaration,
      &quot;ExportAllDeclaration&quot;: checkSpacingForModuleDeclaration,
      &quot;FunctionDeclaration&quot;: checkSpacingForFunction,
      &quot;ImportDeclaration&quot;: checkSpacingForModuleDeclaration,
      &quot;VariableDeclaration&quot;: checkSpacingAroundFirstToken,
      // Expressions
      &quot;ArrowFunctionExpression&quot;: checkSpacingForFunction,
      &quot;AwaitExpression&quot;: checkSpacingForAwaitExpression,
      &quot;ClassExpression&quot;: checkSpacingForClass,
      &quot;FunctionExpression&quot;: checkSpacingForFunction,
      &quot;NewExpression&quot;: checkSpacingBeforeFirstToken,
      &quot;Super&quot;: checkSpacingBeforeFirstToken,
      &quot;ThisExpression&quot;: checkSpacingBeforeFirstToken,
      &quot;UnaryExpression&quot;: checkSpacingBeforeFirstToken,
      &quot;YieldExpression&quot;: checkSpacingBeforeFirstToken,
      // Others
      &quot;ImportSpecifier&quot;: checkSpacingForImportSpecifier,
      &quot;ExportSpecifier&quot;: checkSpacingForExportSpecifier,
      &quot;ImportNamespaceSpecifier&quot;: checkSpacingForImportNamespaceSpecifier,
      &quot;MethodDefinition&quot;: checkSpacingForProperty,
      &quot;PropertyDefinition&quot;: checkSpacingForProperty,
      &quot;StaticBlock&quot;: checkSpacingAroundFirstToken,
      &quot;Property&quot;: checkSpacingForProperty,
      // To avoid conflicts with `space-infix-ops`, e.g. `a &gt; this.b`
      &quot;BinaryExpression[operator=&#039;&gt;&#039;]&quot;: function(node) {
        const operatorToken = sourceCode.getTokenBefore(node.right, isNotOpeningParenToken);
        tokensToIgnore.add(operatorToken);
      }
    };
  }
});

export { keywordSpacing as default };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
