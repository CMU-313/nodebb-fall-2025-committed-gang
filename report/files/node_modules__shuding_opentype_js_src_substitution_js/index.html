<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@shuding/opentype.js/src/substitution.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@shuding/opentype.js/src/substitution.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">448</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">112.70</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.49</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.

import check from &#039;./check&#039;;
import Layout from &#039;./layout&#039;;

/**
 * @exports opentype.Substitution
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
function Substitution(font) {
    Layout.call(this, font, &#039;gsub&#039;);
}

// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    const n = ar1.length;
    if (n !== ar2.length) {
        return false;
    }
    for (let i = 0; i &lt; n; i++) {
        if (ar1[i] !== ar2[i]) {
            return false;
        }
    }
    return true;
}

// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    const subtables = lookupTable.subtables;
    for (let i = 0; i &lt; subtables.length; i++) {
        const subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}

Substitution.prototype = Layout.prototype;

/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */
Substitution.prototype.createDefaultTable = function () {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [
            {
                tag: &#039;DFLT&#039;,
                script: {
                    defaultLangSys: {
                        reserved: 0,
                        reqFeatureIndex: 0xffff,
                        featureIndexes: [],
                    },
                    langSysRecords: [],
                },
            },
        ],
        features: [],
        lookups: [],
    };
};

/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 * @param {string} feature - 4-character feature name (&#039;aalt&#039;, &#039;salt&#039;, &#039;ss01&#039;...)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getSingle = function (feature, script, language) {
    const substitutions = [];
    const lookupTables = this.getLookupTables(script, language, feature, 1);
    for (let idx = 0; idx &lt; lookupTables.length; idx++) {
        const subtables = lookupTables[idx].subtables;
        for (let i = 0; i &lt; subtables.length; i++) {
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            let j;
            if (subtable.substFormat === 1) {
                const delta = subtable.deltaGlyphId;
                for (j = 0; j &lt; glyphs.length; j++) {
                    const glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                const substitute = subtable.substitute;
                for (j = 0; j &lt; glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};

/**
 * List all multiple substitutions (lookup type 2) for a given script, language, and feature.
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 * @param {string} feature - 4-character feature name (&#039;ccmp&#039;, &#039;stch&#039;)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getMultiple = function (feature, script, language) {
    const substitutions = [];
    const lookupTables = this.getLookupTables(script, language, feature, 2);
    for (let idx = 0; idx &lt; lookupTables.length; idx++) {
        const subtables = lookupTables[idx].subtables;
        for (let i = 0; i &lt; subtables.length; i++) {
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            let j;

            for (j = 0; j &lt; glyphs.length; j++) {
                const glyph = glyphs[j];
                const replacements = subtable.sequences[j];
                substitutions.push({ sub: glyph, by: replacements });
            }
        }
    }
    return substitutions;
};

/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 * @param {string} feature - 4-character feature name (&#039;aalt&#039;, &#039;salt&#039;...)
 * @return {Array} alternates - The list of alternates
 */
Substitution.prototype.getAlternates = function (feature, script, language) {
    const alternates = [];
    const lookupTables = this.getLookupTables(script, language, feature, 3);
    for (let idx = 0; idx &lt; lookupTables.length; idx++) {
        const subtables = lookupTables[idx].subtables;
        for (let i = 0; i &lt; subtables.length; i++) {
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            const alternateSets = subtable.alternateSets;
            for (let j = 0; j &lt; glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};

/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name (&#039;liga&#039;, &#039;rlig&#039;, &#039;dlig&#039;...)
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 * @return {Array} ligatures - The list of ligatures.
 */
Substitution.prototype.getLigatures = function (feature, script, language) {
    const ligatures = [];
    const lookupTables = this.getLookupTables(script, language, feature, 4);
    for (let idx = 0; idx &lt; lookupTables.length; idx++) {
        const subtables = lookupTables[idx].subtables;
        for (let i = 0; i &lt; subtables.length; i++) {
            const subtable = subtables[i];
            const glyphs = this.expandCoverage(subtable.coverage);
            const ligatureSets = subtable.ligatureSets;
            for (let j = 0; j &lt; glyphs.length; j++) {
                const startGlyph = glyphs[j];
                const ligSet = ligatureSets[j];
                for (let k = 0; k &lt; ligSet.length; k++) {
                    const lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph,
                    });
                }
            }
        }
    }
    return ligatures;
};

/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name (&#039;liga&#039;, &#039;rlig&#039;, &#039;dlig&#039;...)
 * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 */
Substitution.prototype.addSingle = function (
    feature,
    substitution,
    script,
    language
) {
    const lookupTable = this.getLookupTables(
        script,
        language,
        feature,
        1,
        true
    )[0];
    const subtable = getSubstFormat(lookupTable, 2, {
        // lookup type 1 subtable, format 2, coverage format 1
        substFormat: 2,
        coverage: { format: 1, glyphs: [] },
        substitute: [],
    });
    check.assert(
        subtable.coverage.format === 1,
        &#039;Single: unable to modify coverage table format &#039; +
            subtable.coverage.format
    );
    const coverageGlyph = substitution.sub;
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos &lt; 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};

/**
 * Add or modify a multiple substitution (lookup type 2)
 * @param {string} feature - 4-letter feature name (&#039;ccmp&#039;, &#039;stch&#039;)
 * @param {Object} substitution - { sub: id, by: [id] } for format 2.
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 */
Substitution.prototype.addMultiple = function (
    feature,
    substitution,
    script,
    language
) {
    check.assert(
        substitution.by instanceof Array &amp;&amp; substitution.by.length &gt; 1,
        &#039;Multiple: &quot;by&quot; must be an array of two or more ids&#039;
    );
    const lookupTable = this.getLookupTables(
        script,
        language,
        feature,
        2,
        true
    )[0];
    const subtable = getSubstFormat(lookupTable, 1, {
        // lookup type 2 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: { format: 1, glyphs: [] },
        sequences: [],
    });
    check.assert(
        subtable.coverage.format === 1,
        &#039;Multiple: unable to modify coverage table format &#039; +
            subtable.coverage.format
    );
    const coverageGlyph = substitution.sub;
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos &lt; 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.sequences.splice(pos, 0, 0);
    }
    subtable.sequences[pos] = substitution.by;
};

/**
 * Add or modify an alternate substitution (lookup type 3)
 * @param {string} feature - 4-letter feature name (&#039;liga&#039;, &#039;rlig&#039;, &#039;dlig&#039;...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 */
Substitution.prototype.addAlternate = function (
    feature,
    substitution,
    script,
    language
) {
    const lookupTable = this.getLookupTables(
        script,
        language,
        feature,
        3,
        true
    )[0];
    const subtable = getSubstFormat(lookupTable, 1, {
        // lookup type 3 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: { format: 1, glyphs: [] },
        alternateSets: [],
    });
    check.assert(
        subtable.coverage.format === 1,
        &#039;Alternate: unable to modify coverage table format &#039; +
            subtable.coverage.format
    );
    const coverageGlyph = substitution.sub;
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos &lt; 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};

/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name (&#039;liga&#039;, &#039;rlig&#039;, &#039;dlig&#039;...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 */
Substitution.prototype.addLigature = function (
    feature,
    ligature,
    script,
    language
) {
    const lookupTable = this.getLookupTables(
        script,
        language,
        feature,
        4,
        true
    )[0];
    let subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {
            // lookup type 4 subtable, format 1, coverage format 1
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: [],
        };
        lookupTable.subtables[0] = subtable;
    }
    check.assert(
        subtable.coverage.format === 1,
        &#039;Ligature: unable to modify coverage table format &#039; +
            subtable.coverage.format
    );
    const coverageGlyph = ligature.sub[0];
    const ligComponents = ligature.sub.slice(1);
    const ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents,
    };
    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos &gt;= 0) {
        // ligatureSet already exists
        const ligatureSet = subtable.ligatureSets[pos];
        for (let i = 0; i &lt; ligatureSet.length; i++) {
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};

/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getFeature = function (feature, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case &#039;aalt&#039;:
        case &#039;salt&#039;:
            return this.getSingle(feature, script, language).concat(
                this.getAlternates(feature, script, language)
            );
        case &#039;dlig&#039;:
        case &#039;liga&#039;:
        case &#039;rlig&#039;:
            return this.getLigatures(feature, script, language);
        case &#039;ccmp&#039;:
            return this.getMultiple(feature, script, language).concat(
                this.getLigatures(feature, script, language)
            );
        case &#039;stch&#039;:
            return this.getMultiple(feature, script, language);
    }
    return undefined;
};

/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script=&#039;DFLT&#039;]
 * @param {string} [language=&#039;dflt&#039;]
 */
Substitution.prototype.add = function (feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case &#039;aalt&#039;:
        case &#039;salt&#039;:
            if (typeof sub.by === &#039;number&#039;) {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case &#039;dlig&#039;:
        case &#039;liga&#039;:
        case &#039;rlig&#039;:
            return this.addLigature(feature, sub, script, language);
        case &#039;ccmp&#039;:
            if (sub.by instanceof Array) {
                return this.addMultiple(feature, sub, script, language);
            }
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};

export default Substitution;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
