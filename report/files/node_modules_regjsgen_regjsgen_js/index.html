<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/regjsgen/regjsgen.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/regjsgen/regjsgen.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">426</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">59.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * regjsgen 0.8.0
 * Copyright 2014-2023 Benjamin Tan &lt;https://ofcr.se/&gt;
 * Available under the MIT license &lt;https://github.com/bnjmnt4n/regjsgen/blob/main/LICENSE-MIT.txt&gt;
 */
;(function() {
  &#039;use strict&#039;;

  // Used to determine if values are of the language type `Object`.
  var objectTypes = {
    &#039;function&#039;: true,
    &#039;object&#039;: true
  };

  // Used as a reference to the global object.
  var root = (objectTypes[typeof window] &amp;&amp; window) || this;

  // Detect free variable `exports`.
  var freeExports = objectTypes[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  // Detect free variable `module`.
  var hasFreeModule = objectTypes[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType;

  // Detect free variable `global` from Node.js or Browserified code and use it as `root`.
  var freeGlobal = freeExports &amp;&amp; hasFreeModule &amp;&amp; typeof global == &#039;object&#039; &amp;&amp; global;
  if (freeGlobal &amp;&amp; (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  // Used to check objects for own properties.
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /*--------------------------------------------------------------------------*/

  // Generates a string based on the given code point.
  // Based on https://mths.be/fromcodepoint by @mathias.
  function fromCodePoint() {
    var codePoint = Number(arguments[0]);

    if (
      !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
      codePoint &lt; 0 || // not a valid Unicode code point
      codePoint &gt; 0x10FFFF || // not a valid Unicode code point
      Math.floor(codePoint) != codePoint // not an integer
    ) {
      throw RangeError(&#039;Invalid code point: &#039; + codePoint);
    }

    if (codePoint &lt;= 0xFFFF) {
      // BMP code point
      return String.fromCharCode(codePoint);
    } else {
      // Astral code point; split in surrogate halves
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      codePoint -= 0x10000;
      var highSurrogate = (codePoint &gt;&gt; 10) + 0xD800;
      var lowSurrogate = (codePoint % 0x400) + 0xDC00;
      return String.fromCharCode(highSurrogate, lowSurrogate);
    }
  }

  /*--------------------------------------------------------------------------*/

  // Ensures that nodes have the correct types.
  var assertTypeRegexMap = {};
  function assertType(type, expected) {
    if (expected.indexOf(&#039;|&#039;) == -1) {
      if (type == expected) {
        return;
      }

      throw Error(&#039;Invalid node type: &#039; + type + &#039;; expected type: &#039; + expected);
    }

    expected = hasOwnProperty.call(assertTypeRegexMap, expected)
      ? assertTypeRegexMap[expected]
      : (assertTypeRegexMap[expected] = RegExp(&#039;^(?:&#039; + expected + &#039;)$&#039;));

    if (expected.test(type)) {
      return;
    }

    throw Error(&#039;Invalid node type: &#039; + type + &#039;; expected types: &#039; + expected);
  }

  /*--------------------------------------------------------------------------*/

  // Generates a regular expression string based on an AST.
  function generate(node) {
    var type = node.type;

    if (hasOwnProperty.call(generators, type)) {
      return generators[type](node);
    }

    throw Error(&#039;Invalid node type: &#039; + type);
  }

  // Constructs a string by concatentating the output of each term.
  function generateSequence(generator, terms, /* optional */  separator) {
    var i = -1,
        length = terms.length,
        result = &#039;&#039;,
        term;

    while (++i &lt; length) {
      term = terms[i];

      if (separator &amp;&amp; i &gt; 0) result += separator;

      // Ensure that `\0` null escapes followed by number symbols are not
      // treated as backreferences.
      if (
        i + 1 &lt; length &amp;&amp;
        terms[i].type == &#039;value&#039; &amp;&amp;
        terms[i].kind == &#039;null&#039; &amp;&amp;
        terms[i + 1].type == &#039;value&#039; &amp;&amp;
        terms[i + 1].kind == &#039;symbol&#039; &amp;&amp;
        terms[i + 1].codePoint &gt;= 48 &amp;&amp;
        terms[i + 1].codePoint &lt;= 57
      ) {
        result += &#039;\\000&#039;;
        continue;
      }

      result += generator(term);
    }

    return result;
  }

  /*--------------------------------------------------------------------------*/

  function generateAlternative(node) {
    assertType(node.type, &#039;alternative&#039;);

    return generateSequence(generateTerm, node.body);
  }

  function generateAnchor(node) {
    assertType(node.type, &#039;anchor&#039;);

    switch (node.kind) {
      case &#039;start&#039;:
        return &#039;^&#039;;
      case &#039;end&#039;:
        return &#039;$&#039;;
      case &#039;boundary&#039;:
        return &#039;\\b&#039;;
      case &#039;not-boundary&#039;:
        return &#039;\\B&#039;;
      default:
        throw Error(&#039;Invalid assertion&#039;);
    }
  }

  var atomType = &#039;anchor|characterClass|characterClassEscape|dot|group|reference|unicodePropertyEscape|value&#039;;

  function generateAtom(node) {
    assertType(node.type, atomType);

    return generate(node);
  }

  function generateCharacterClass(node) {
    assertType(node.type, &#039;characterClass&#039;);

    var kind = node.kind;
    var separator = kind === &#039;intersection&#039; ? &#039;&amp;&amp;&#039; : kind === &#039;subtraction&#039; ? &#039;--&#039; : &#039;&#039;;

    return &#039;[&#039; +
      (node.negative ? &#039;^&#039; : &#039;&#039;) +
      generateSequence(generateClassAtom, node.body, separator) +
    &#039;]&#039;;
  }

  function generateCharacterClassEscape(node) {
    assertType(node.type, &#039;characterClassEscape&#039;);

    return &#039;\\&#039; + node.value;
  }

  function generateCharacterClassRange(node) {
    assertType(node.type, &#039;characterClassRange&#039;);

    var min = node.min,
        max = node.max;

    if (min.type == &#039;characterClassRange&#039; || max.type == &#039;characterClassRange&#039;) {
      throw Error(&#039;Invalid character class range&#039;);
    }

    return generateClassAtom(min) + &#039;-&#039; + generateClassAtom(max);
  }

  function generateClassAtom(node) {
    assertType(node.type, &#039;anchor|characterClass|characterClassEscape|characterClassRange|dot|value|unicodePropertyEscape|classStrings&#039;);

    return generate(node);
  }

  function generateClassStrings(node) {
    assertType(node.type, &#039;classStrings&#039;);

    return &#039;\\q{&#039; + generateSequence(generateClassString, node.strings, &#039;|&#039;) + &#039;}&#039;;
  }

  function generateClassString(node) {
    assertType(node.type, &#039;classString&#039;);

    return generateSequence(generate, node.characters);
  }

  function generateDisjunction(node) {
    assertType(node.type, &#039;disjunction&#039;);

    return generateSequence(generate, node.body, &#039;|&#039;);
  }


  function generateDot(node) {
    assertType(node.type, &#039;dot&#039;);

    return &#039;.&#039;;
  }

  function generateGroup(node) {
    assertType(node.type, &#039;group&#039;);

    var result = &#039;&#039;;

    switch (node.behavior) {
      case &#039;normal&#039;:
        if (node.name) {
          result += &#039;?&lt;&#039; + generateIdentifier(node.name) + &#039;&gt;&#039;;
        }
        break;
      case &#039;ignore&#039;:
        if (node.modifierFlags) {
          result += &#039;?&#039;;
          if (node.modifierFlags.enabling) result += node.modifierFlags.enabling;
          if (node.modifierFlags.disabling) result += &quot;-&quot; + node.modifierFlags.disabling;
          result += &#039;:&#039;;
        } else {
          result += &#039;?:&#039;;
        }
        break;
      case &#039;lookahead&#039;:
        result += &#039;?=&#039;;
        break;
      case &#039;negativeLookahead&#039;:
        result += &#039;?!&#039;;
        break;
      case &#039;lookbehind&#039;:
        result += &#039;?&lt;=&#039;;
        break;
      case &#039;negativeLookbehind&#039;:
        result += &#039;?&lt;!&#039;;
        break;
      default:
        throw Error(&#039;Invalid behaviour: &#039; + node.behaviour);
    }

    result += generateSequence(generate, node.body);

    return &#039;(&#039; + result + &#039;)&#039;;
  }

  function generateIdentifier(node) {
    assertType(node.type, &#039;identifier&#039;);

    return node.value;
  }

  function generateQuantifier(node) {
    assertType(node.type, &#039;quantifier&#039;);

    var quantifier = &#039;&#039;,
        min = node.min,
        max = node.max;

    if (max == null) {
      if (min == 0) {
        quantifier = &#039;*&#039;;
      } else if (min == 1) {
        quantifier = &#039;+&#039;;
      } else {
        quantifier = &#039;{&#039; + min + &#039;,}&#039;;
      }
    } else if (min == max) {
      quantifier = &#039;{&#039; + min + &#039;}&#039;;
    } else if (min == 0 &amp;&amp; max == 1) {
      quantifier = &#039;?&#039;;
    } else {
      quantifier = &#039;{&#039; + min + &#039;,&#039; + max + &#039;}&#039;;
    }

    if (!node.greedy) {
      quantifier += &#039;?&#039;;
    }

    return generateAtom(node.body[0]) + quantifier;
  }

  function generateReference(node) {
    assertType(node.type, &#039;reference&#039;);

    if (node.matchIndex) {
      return &#039;\\&#039; + node.matchIndex;
    }
    if (node.name) {
      return &#039;\\k&lt;&#039; + generateIdentifier(node.name) + &#039;&gt;&#039;;
    }

    throw new Error(&#039;Unknown reference type&#039;);
  }

  function generateTerm(node) {
    assertType(node.type, atomType + &#039;|empty|quantifier&#039;);

    return generate(node);
  }

  function generateUnicodePropertyEscape(node) {
    assertType(node.type, &#039;unicodePropertyEscape&#039;);

    return &#039;\\&#039; + (node.negative ? &#039;P&#039; : &#039;p&#039;) + &#039;{&#039; + node.value + &#039;}&#039;;
  }

  function generateValue(node) {
    assertType(node.type, &#039;value&#039;);

    var kind = node.kind,
        codePoint = node.codePoint;

    if (typeof codePoint != &#039;number&#039;) {
      throw new Error(&#039;Invalid code point: &#039; + codePoint);
    }

    switch (kind) {
      case &#039;controlLetter&#039;:
        return &#039;\\c&#039; + fromCodePoint(codePoint + 64);
      case &#039;hexadecimalEscape&#039;:
        return &#039;\\x&#039; + (&#039;00&#039; + codePoint.toString(16).toUpperCase()).slice(-2);
      case &#039;identifier&#039;:
        return &#039;\\&#039; + fromCodePoint(codePoint);
      case &#039;null&#039;:
        return &#039;\\&#039; + codePoint;
      case &#039;octal&#039;:
        return &#039;\\&#039; + (&#039;000&#039; + codePoint.toString(8)).slice(-3);
      case &#039;singleEscape&#039;:
        switch (codePoint) {
          case 0x0008:
            return &#039;\\b&#039;;
          case 0x0009:
            return &#039;\\t&#039;;
          case 0x000A:
            return &#039;\\n&#039;;
          case 0x000B:
            return &#039;\\v&#039;;
          case 0x000C:
            return &#039;\\f&#039;;
          case 0x000D:
            return &#039;\\r&#039;;
          case 0x002D:
            return &#039;\\-&#039;;
          default:
            throw Error(&#039;Invalid code point: &#039; + codePoint);
        }
      case &#039;symbol&#039;:
        return fromCodePoint(codePoint);
      case &#039;unicodeEscape&#039;:
        return &#039;\\u&#039; + (&#039;0000&#039; + codePoint.toString(16).toUpperCase()).slice(-4);
      case &#039;unicodeCodePointEscape&#039;:
        return &#039;\\u{&#039; + codePoint.toString(16).toUpperCase() + &#039;}&#039;;
      default:
        throw Error(&#039;Unsupported node kind: &#039; + kind);
    }
  }

  /*--------------------------------------------------------------------------*/

  // Used to generate strings for each node type.
  var generators = {
    &#039;alternative&#039;: generateAlternative,
    &#039;anchor&#039;: generateAnchor,
    &#039;characterClass&#039;: generateCharacterClass,
    &#039;characterClassEscape&#039;: generateCharacterClassEscape,
    &#039;characterClassRange&#039;: generateCharacterClassRange,
    &#039;classStrings&#039;: generateClassStrings,
    &#039;disjunction&#039;: generateDisjunction,
    &#039;dot&#039;: generateDot,
    &#039;group&#039;: generateGroup,
    &#039;quantifier&#039;: generateQuantifier,
    &#039;reference&#039;: generateReference,
    &#039;unicodePropertyEscape&#039;: generateUnicodePropertyEscape,
    &#039;value&#039;: generateValue
  };

  /*--------------------------------------------------------------------------*/

  // Export regjsgen.
  var regjsgen = {
    &#039;generate&#039;: generate
  };

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == &#039;function&#039; &amp;&amp; typeof define.amd == &#039;object&#039; &amp;&amp; define.amd) {
    // Define as an anonymous module so it can be aliased through path mapping.
    define(function() {
      return regjsgen;
    });

    root.regjsgen = regjsgen;
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports &amp;&amp; hasFreeModule) {
    // Export for CommonJS support.
    freeExports.generate = generate;
  }
  else {
    // Export to the global object.
    root.regjsgen = regjsgen;
  }
}.call(this));
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
