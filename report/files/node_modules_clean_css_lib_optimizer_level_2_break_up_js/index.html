<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/clean-css/lib/optimizer/level-2/break-up.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/clean-css/lib/optimizer/level-2/break-up.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">49.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">645</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">149.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var InvalidPropertyError = require(&#039;./invalid-property-error&#039;);

var wrapSingle = require(&#039;../wrap-for-optimizing&#039;).single;

var Token = require(&#039;../../tokenizer/token&#039;);
var Marker = require(&#039;../../tokenizer/marker&#039;);

var formatPosition = require(&#039;../../utils/format-position&#039;);

function _anyIsInherit(values) {
  var i, l;

  for (i = 0, l = values.length; i &lt; l; i++) {
    if (values[i][1] == &#039;inherit&#039;) {
      return true;
    }
  }

  return false;
}

function _colorFilter(validator) {
  return function (value) {
    return value[1] == &#039;invert&#039; || validator.isColor(value[1]) || validator.isPrefixed(value[1]);
  };
}

function _styleFilter(validator) {
  return function (value) {
    return value[1] != &#039;inherit&#039; &amp;&amp; validator.isStyleKeyword(value[1]) &amp;&amp; !validator.isColorFunction(value[1]);
  };
}

function _wrapDefault(name, property, compactable) {
  var descriptor = compactable[name];
  if (descriptor.doubleValues &amp;&amp; descriptor.defaultValue.length == 2) {
    return wrapSingle([
      Token.PROPERTY,
      [Token.PROPERTY_NAME, name],
      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]],
      [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]
    ]);
  } else if (descriptor.doubleValues &amp;&amp; descriptor.defaultValue.length == 1) {
    return wrapSingle([
      Token.PROPERTY,
      [Token.PROPERTY_NAME, name],
      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]
    ]);
  } else {
    return wrapSingle([
      Token.PROPERTY,
      [Token.PROPERTY_NAME, name],
      [Token.PROPERTY_VALUE, descriptor.defaultValue]
    ]);
  }
}

function _widthFilter(validator) {
  return function (value) {
    return value[1] != &#039;inherit&#039; &amp;&amp;
      (validator.isWidth(value[1]) || validator.isUnit(value[1]) &amp;&amp; !validator.isDynamicUnit(value[1])) &amp;&amp;
      !validator.isStyleKeyword(value[1]) &amp;&amp;
      !validator.isColorFunction(value[1]);
  };
}

function animation(property, compactable, validator) {
  var duration = _wrapDefault(property.name + &#039;-duration&#039;, property, compactable);
  var timing = _wrapDefault(property.name + &#039;-timing-function&#039;, property, compactable);
  var delay = _wrapDefault(property.name + &#039;-delay&#039;, property, compactable);
  var iteration = _wrapDefault(property.name + &#039;-iteration-count&#039;, property, compactable);
  var direction = _wrapDefault(property.name + &#039;-direction&#039;, property, compactable);
  var fill = _wrapDefault(property.name + &#039;-fill-mode&#039;, property, compactable);
  var play = _wrapDefault(property.name + &#039;-play-state&#039;, property, compactable);
  var name = _wrapDefault(property.name + &#039;-name&#039;, property, compactable);
  var components = [duration, timing, delay, iteration, direction, fill, play, name];
  var values = property.value;
  var value;
  var durationSet = false;
  var timingSet = false;
  var delaySet = false;
  var iterationSet = false;
  var directionSet = false;
  var fillSet = false;
  var playSet = false;
  var nameSet = false;
  var i;
  var l;

  if (property.value.length == 1 &amp;&amp; property.value[0][1] == &#039;inherit&#039;) {
    duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;
    return components;
  }

  if (values.length &gt; 1 &amp;&amp; _anyIsInherit(values)) {
    throw new InvalidPropertyError(&#039;Invalid animation values at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  for (i = 0, l = values.length; i &lt; l; i++) {
    value = values[i];

    if (validator.isTime(value[1]) &amp;&amp; !durationSet) {
      duration.value = [value];
      durationSet = true;
    } else if (validator.isTime(value[1]) &amp;&amp; !delaySet) {
      delay.value = [value];
      delaySet = true;
    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) &amp;&amp; !timingSet) {
      timing.value = [value];
      timingSet = true;
    } else if ((validator.isAnimationIterationCountKeyword(value[1]) || validator.isPositiveNumber(value[1])) &amp;&amp; !iterationSet) {
      iteration.value = [value];
      iterationSet = true;
    } else if (validator.isAnimationDirectionKeyword(value[1]) &amp;&amp; !directionSet) {
      direction.value = [value];
      directionSet = true;
    } else if (validator.isAnimationFillModeKeyword(value[1]) &amp;&amp; !fillSet) {
      fill.value = [value];
      fillSet = true;
    } else if (validator.isAnimationPlayStateKeyword(value[1]) &amp;&amp; !playSet) {
      play.value = [value];
      playSet = true;
    } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) &amp;&amp; !nameSet) {
      name.value = [value];
      nameSet = true;
    } else {
      throw new InvalidPropertyError(&#039;Invalid animation value at &#039; + formatPosition(value[2][0]) + &#039;. Ignoring.&#039;);
    }
  }

  return components;
}

function background(property, compactable, validator) {
  var image = _wrapDefault(&#039;background-image&#039;, property, compactable);
  var position = _wrapDefault(&#039;background-position&#039;, property, compactable);
  var size = _wrapDefault(&#039;background-size&#039;, property, compactable);
  var repeat = _wrapDefault(&#039;background-repeat&#039;, property, compactable);
  var attachment = _wrapDefault(&#039;background-attachment&#039;, property, compactable);
  var origin = _wrapDefault(&#039;background-origin&#039;, property, compactable);
  var clip = _wrapDefault(&#039;background-clip&#039;, property, compactable);
  var color = _wrapDefault(&#039;background-color&#039;, property, compactable);
  var components = [image, position, size, repeat, attachment, origin, clip, color];
  var values = property.value;

  var positionSet = false;
  var clipSet = false;
  var originSet = false;
  var repeatSet = false;

  var anyValueSet = false;

  if (property.value.length == 1 &amp;&amp; property.value[0][1] == &#039;inherit&#039;) {
    // NOTE: &#039;inherit&#039; is not a valid value for background-attachment
    color.value = image.value =  repeat.value = position.value = size.value = origin.value = clip.value = property.value;
    return components;
  }

  if (property.value.length == 1 &amp;&amp; property.value[0][1] == &#039;0 0&#039;) {
    return components;
  }

  for (var i = values.length - 1; i &gt;= 0; i--) {
    var value = values[i];

    if (validator.isBackgroundAttachmentKeyword(value[1])) {
      attachment.value = [value];
      anyValueSet = true;
    } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {
      if (clipSet) {
        origin.value = [value];
        originSet = true;
      } else {
        clip.value = [value];
        clipSet = true;
      }
      anyValueSet = true;
    } else if (validator.isBackgroundRepeatKeyword(value[1])) {
      if (repeatSet) {
        repeat.value.unshift(value);
      } else {
        repeat.value = [value];
        repeatSet = true;
      }
      anyValueSet = true;
    } else if (validator.isBackgroundPositionKeyword(value[1]) || validator.isBackgroundSizeKeyword(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) {
      if (i &gt; 0) {
        var previousValue = values[i - 1];

        if (previousValue[1] == Marker.FORWARD_SLASH) {
          size.value = [value];
        } else if (i &gt; 1 &amp;&amp; values[i - 2][1] == Marker.FORWARD_SLASH) {
          size.value = [previousValue, value];
          i -= 2;
        } else {
          if (!positionSet)
            position.value = [];

          position.value.unshift(value);
          positionSet = true;
        }
      } else {
        if (!positionSet)
          position.value = [];

        position.value.unshift(value);
        positionSet = true;
      }
      anyValueSet = true;
    } else if ((color.value[0][1] == compactable[color.name].defaultValue || color.value[0][1] == &#039;none&#039;) &amp;&amp; (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {
      color.value = [value];
      anyValueSet = true;
    } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {
      image.value = [value];
      anyValueSet = true;
    }
  }

  if (clipSet &amp;&amp; !originSet)
    origin.value = clip.value.slice(0);

  if (!anyValueSet) {
    throw new InvalidPropertyError(&#039;Invalid background value at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  return components;
}

function borderRadius(property, compactable) {
  var values = property.value;
  var splitAt = -1;

  for (var i = 0, l = values.length; i &lt; l; i++) {
    if (values[i][1] == Marker.FORWARD_SLASH) {
      splitAt = i;
      break;
    }
  }

  if (splitAt === 0 || splitAt === values.length - 1) {
    throw new InvalidPropertyError(&#039;Invalid border-radius value at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  var target = _wrapDefault(property.name, property, compactable);
  target.value = splitAt &gt; -1 ?
    values.slice(0, splitAt) :
    values.slice(0);
  target.components = fourValues(target, compactable);

  var remainder = _wrapDefault(property.name, property, compactable);
  remainder.value = splitAt &gt; -1 ?
    values.slice(splitAt + 1) :
    values.slice(0);
  remainder.components = fourValues(remainder, compactable);

  for (var j = 0; j &lt; 4; j++) {
    target.components[j].multiplex = true;
    target.components[j].value = target.components[j].value.concat(remainder.components[j].value);
  }

  return target.components;
}

function font(property, compactable, validator) {
  var style = _wrapDefault(&#039;font-style&#039;, property, compactable);
  var variant = _wrapDefault(&#039;font-variant&#039;, property, compactable);
  var weight = _wrapDefault(&#039;font-weight&#039;, property, compactable);
  var stretch = _wrapDefault(&#039;font-stretch&#039;, property, compactable);
  var size = _wrapDefault(&#039;font-size&#039;, property, compactable);
  var height = _wrapDefault(&#039;line-height&#039;, property, compactable);
  var family = _wrapDefault(&#039;font-family&#039;, property, compactable);
  var components = [style, variant, weight, stretch, size, height, family];
  var values = property.value;
  var fuzzyMatched = 4; // style, variant, weight, and stretch
  var index = 0;
  var isStretchSet = false;
  var isStretchValid;
  var isStyleSet = false;
  var isStyleValid;
  var isVariantSet = false;
  var isVariantValid;
  var isWeightSet = false;
  var isWeightValid;
  var isSizeSet = false;
  var appendableFamilyName = false;

  if (!values[index]) {
    throw new InvalidPropertyError(&#039;Missing font values at &#039; + formatPosition(property.all[property.position][1][2][0]) + &#039;. Ignoring.&#039;);
  }

  if (values.length == 1 &amp;&amp; values[0][1] == &#039;inherit&#039;) {
    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
    return components;
  }

  if (values.length == 1 &amp;&amp; (validator.isFontKeyword(values[0][1]) || validator.isGlobal(values[0][1]) || validator.isPrefixed(values[0][1]))) {
    values[0][1] = Marker.INTERNAL + values[0][1];
    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
    return components;
  }

  if (values.length &lt; 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {
    throw new InvalidPropertyError(&#039;Invalid font values at &#039; + formatPosition(property.all[property.position][1][2][0]) + &#039;. Ignoring.&#039;);
  }

  if (values.length &gt; 1 &amp;&amp; _anyIsInherit(values)) {
    throw new InvalidPropertyError(&#039;Invalid font values at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  // fuzzy match style, variant, weight, and stretch on first elements
  while (index &lt; fuzzyMatched) {
    isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
    isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
    isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
    isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);

    if (isStyleValid &amp;&amp; !isStyleSet) {
      style.value = [values[index]];
      isStyleSet = true;
    } else if (isVariantValid &amp;&amp; !isVariantSet) {
      variant.value = [values[index]];
      isVariantSet = true;
    } else if (isWeightValid &amp;&amp; !isWeightSet) {
      weight.value = [values[index]];
      isWeightSet = true;
    } else if (isStretchValid &amp;&amp; !isStretchSet) {
      stretch.value = [values[index]];
      isStretchSet = true;
    } else if (isStyleValid &amp;&amp; isStyleSet || isVariantValid &amp;&amp; isVariantSet || isWeightValid &amp;&amp; isWeightSet || isStretchValid &amp;&amp; isStretchSet) {
      throw new InvalidPropertyError(&#039;Invalid font style / variant / weight / stretch value at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
    } else {
      break;
    }

    index++;
  }

  // now comes font-size ...
  if (validator.isFontSizeKeyword(values[index][1]) || validator.isUnit(values[index][1]) &amp;&amp; !validator.isDynamicUnit(values[index][1])) {
    size.value = [values[index]];
    isSizeSet = true;
    index++;
  } else {
    throw new InvalidPropertyError(&#039;Missing font size at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  if (!values[index]) {
    throw new InvalidPropertyError(&#039;Missing font family at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  // ... and perhaps line-height
  if (isSizeSet &amp;&amp; values[index] &amp;&amp; values[index][1] == Marker.FORWARD_SLASH &amp;&amp; values[index + 1] &amp;&amp; (validator.isLineHeightKeyword(values[index + 1][1]) || validator.isUnit(values[index + 1][1]) || validator.isNumber(values[index + 1][1]))) {
    height.value = [values[index + 1]];
    index++;
    index++;
  }

  // ... and whatever comes next is font-family
  family.value = [];

  while (values[index]) {
    if (values[index][1] == Marker.COMMA) {
      appendableFamilyName = false;
    } else {
      if (appendableFamilyName) {
        family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];
      } else {
        family.value.push(values[index]);
      }

      appendableFamilyName = true;
    }

    index++;
  }

  if (family.value.length === 0) {
    throw new InvalidPropertyError(&#039;Missing font family at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  return components;
}

function _anyIsFontSize(values, validator) {
  var value;
  var i, l;

  for (i = 0, l = values.length; i &lt; l; i++) {
    value = values[i];

    if (validator.isFontSizeKeyword(value[1]) || validator.isUnit(value[1]) &amp;&amp; !validator.isDynamicUnit(value[1]) || validator.isFunction(value[1])) {
      return true;
    }
  }

  return false;
}

function _anyIsFontFamily(values, validator) {
  var value;
  var i, l;

  for (i = 0, l = values.length; i &lt; l; i++) {
    value = values[i];

    if (validator.isIdentifier(value[1])) {
      return true;
    }
  }

  return false;
}

function fourValues(property, compactable) {
  var componentNames = compactable[property.name].components;
  var components = [];
  var value = property.value;

  if (value.length &lt; 1)
    return [];

  if (value.length &lt; 2)
    value[1] = value[0].slice(0);
  if (value.length &lt; 3)
    value[2] = value[0].slice(0);
  if (value.length &lt; 4)
    value[3] = value[1].slice(0);

  for (var i = componentNames.length - 1; i &gt;= 0; i--) {
    var component = wrapSingle([
      Token.PROPERTY,
      [Token.PROPERTY_NAME, componentNames[i]]
    ]);
    component.value = [value[i]];
    components.unshift(component);
  }

  return components;
}

function multiplex(splitWith) {
  return function (property, compactable, validator) {
    var splitsAt = [];
    var values = property.value;
    var i, j, l, m;

    // find split commas
    for (i = 0, l = values.length; i &lt; l; i++) {
      if (values[i][1] == &#039;,&#039;)
        splitsAt.push(i);
    }

    if (splitsAt.length === 0)
      return splitWith(property, compactable, validator);

    var splitComponents = [];

    // split over commas, and into components
    for (i = 0, l = splitsAt.length; i &lt;= l; i++) {
      var from = i === 0 ? 0 : splitsAt[i - 1] + 1;
      var to = i &lt; l ? splitsAt[i] : values.length;

      var _property = _wrapDefault(property.name, property, compactable);
      _property.value = values.slice(from, to);

      splitComponents.push(splitWith(_property, compactable, validator));
    }

    var components = splitComponents[0];

    // group component values from each split
    for (i = 0, l = components.length; i &lt; l; i++) {
      components[i].multiplex = true;

      for (j = 1, m = splitComponents.length; j &lt; m; j++) {
        components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
        Array.prototype.push.apply(components[i].value, splitComponents[j][i].value);
      }
    }

    return components;
  };
}

function listStyle(property, compactable, validator) {
  var type = _wrapDefault(&#039;list-style-type&#039;, property, compactable);
  var position = _wrapDefault(&#039;list-style-position&#039;, property, compactable);
  var image = _wrapDefault(&#039;list-style-image&#039;, property, compactable);
  var components = [type, position, image];

  if (property.value.length == 1 &amp;&amp; property.value[0][1] == &#039;inherit&#039;) {
    type.value = position.value = image.value = [property.value[0]];
    return components;
  }

  var values = property.value.slice(0);
  var total = values.length;
  var index = 0;

  // `image` first...
  for (index = 0, total = values.length; index &lt; total; index++) {
    if (validator.isUrl(values[index][1]) || values[index][1] == &#039;0&#039;) {
      image.value = [values[index]];
      values.splice(index, 1);
      break;
    }
  }

  // ... then `position`
  for (index = 0, total = values.length; index &lt; total; index++) {
    if (validator.isListStylePositionKeyword(values[index][1])) {
      position.value = [values[index]];
      values.splice(index, 1);
      break;
    }
  }

  // ... and what&#039;s left is a `type`
  if (values.length &gt; 0 &amp;&amp; (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {
    type.value = [values[0]];
  }

  return components;
}

function transition(property, compactable, validator) {
  var prop = _wrapDefault(property.name + &#039;-property&#039;, property, compactable);
  var duration = _wrapDefault(property.name + &#039;-duration&#039;, property, compactable);
  var timing = _wrapDefault(property.name + &#039;-timing-function&#039;, property, compactable);
  var delay = _wrapDefault(property.name + &#039;-delay&#039;, property, compactable);
  var components = [prop, duration, timing, delay];
  var values = property.value;
  var value;
  var durationSet = false;
  var delaySet = false;
  var propSet = false;
  var timingSet = false;
  var i;
  var l;

  if (property.value.length == 1 &amp;&amp; property.value[0][1] == &#039;inherit&#039;) {
    prop.value = duration.value = timing.value = delay.value = property.value;
    return components;
  }

  if (values.length &gt; 1 &amp;&amp; _anyIsInherit(values)) {
    throw new InvalidPropertyError(&#039;Invalid animation values at &#039; + formatPosition(values[0][2][0]) + &#039;. Ignoring.&#039;);
  }

  for (i = 0, l = values.length; i &lt; l; i++) {
    value = values[i];

    if (validator.isTime(value[1]) &amp;&amp; !durationSet) {
      duration.value = [value];
      durationSet = true;
    } else if (validator.isTime(value[1]) &amp;&amp; !delaySet) {
      delay.value = [value];
      delaySet = true;
    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) &amp;&amp; !timingSet) {
      timing.value = [value];
      timingSet = true;
    } else if (validator.isIdentifier(value[1]) &amp;&amp; !propSet) {
      prop.value = [value];
      propSet = true;
    } else {
      throw new InvalidPropertyError(&#039;Invalid animation value at &#039; + formatPosition(value[2][0]) + &#039;. Ignoring.&#039;);
    }
  }

  return components;
}

function widthStyleColor(property, compactable, validator) {
  var descriptor = compactable[property.name];
  var components = [
    _wrapDefault(descriptor.components[0], property, compactable),
    _wrapDefault(descriptor.components[1], property, compactable),
    _wrapDefault(descriptor.components[2], property, compactable)
  ];
  var color, style, width;

  for (var i = 0; i &lt; 3; i++) {
    var component = components[i];

    if (component.name.indexOf(&#039;color&#039;) &gt; 0)
      color = component;
    else if (component.name.indexOf(&#039;style&#039;) &gt; 0)
      style = component;
    else
      width = component;
  }

  if ((property.value.length == 1 &amp;&amp; property.value[0][1] == &#039;inherit&#039;) ||
      (property.value.length == 3 &amp;&amp; property.value[0][1] == &#039;inherit&#039; &amp;&amp; property.value[1][1] == &#039;inherit&#039; &amp;&amp; property.value[2][1] == &#039;inherit&#039;)) {
    color.value = style.value = width.value = [property.value[0]];
    return components;
  }

  var values = property.value.slice(0);
  var match, matches;

  // NOTE: usually users don&#039;t follow the required order of parts in this shorthand,
  // so we&#039;ll try to parse it caring as little about order as possible

  if (values.length &gt; 0) {
    matches = values.filter(_widthFilter(validator));
    match = matches.length &gt; 1 &amp;&amp; (matches[0][1] == &#039;none&#039; || matches[0][1] == &#039;auto&#039;) ? matches[1] : matches[0];
    if (match) {
      width.value = [match];
      values.splice(values.indexOf(match), 1);
    }
  }

  if (values.length &gt; 0) {
    match = values.filter(_styleFilter(validator))[0];
    if (match) {
      style.value = [match];
      values.splice(values.indexOf(match), 1);
    }
  }

  if (values.length &gt; 0) {
    match = values.filter(_colorFilter(validator))[0];
    if (match) {
      color.value = [match];
      values.splice(values.indexOf(match), 1);
    }
  }

  return components;
}

module.exports = {
  animation: animation,
  background: background,
  border: widthStyleColor,
  borderRadius: borderRadius,
  font: font,
  fourValues: fourValues,
  listStyle: listStyle,
  multiplex: multiplex,
  outline: widthStyleColor,
  transition: transition
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
