<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/qs/test/stringify.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/qs/test/stringify.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1307</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">104.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">24.48</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var test = require(&#039;tape&#039;);
var qs = require(&#039;../&#039;);
var utils = require(&#039;../lib/utils&#039;);
var iconv = require(&#039;iconv-lite&#039;);
var SaferBuffer = require(&#039;safer-buffer&#039;).Buffer;
var hasSymbols = require(&#039;has-symbols&#039;);
var mockProperty = require(&#039;mock-property&#039;);
var emptyTestCases = require(&#039;./empty-keys-cases&#039;).emptyTestCases;
var hasProto = require(&#039;has-proto&#039;)();
var hasBigInt = require(&#039;has-bigints&#039;)();

test(&#039;stringify()&#039;, function (t) {
    t.test(&#039;stringifies a querystring object&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: 1 }), &#039;a=1&#039;);
        st.equal(qs.stringify({ a: 1, b: 2 }), &#039;a=1&amp;b=2&#039;);
        st.equal(qs.stringify({ a: &#039;A_Z&#039; }), &#039;a=A_Z&#039;);
        st.equal(qs.stringify({ a: &#039;‚Ç¨&#039; }), &#039;a=%E2%82%AC&#039;);
        st.equal(qs.stringify({ a: &#039;ÓÄÄ&#039; }), &#039;a=%EE%80%80&#039;);
        st.equal(qs.stringify({ a: &#039;◊ê&#039; }), &#039;a=%D7%90&#039;);
        st.equal(qs.stringify({ a: &#039;êê∑&#039; }), &#039;a=%F0%90%90%B7&#039;);
        st.end();
    });

    t.test(&#039;stringifies falsy values&#039;, function (st) {
        st.equal(qs.stringify(undefined), &#039;&#039;);
        st.equal(qs.stringify(null), &#039;&#039;);
        st.equal(qs.stringify(null, { strictNullHandling: true }), &#039;&#039;);
        st.equal(qs.stringify(false), &#039;&#039;);
        st.equal(qs.stringify(0), &#039;&#039;);
        st.end();
    });

    t.test(&#039;stringifies symbols&#039;, { skip: !hasSymbols() }, function (st) {
        st.equal(qs.stringify(Symbol.iterator), &#039;&#039;);
        st.equal(qs.stringify([Symbol.iterator]), &#039;0=Symbol%28Symbol.iterator%29&#039;);
        st.equal(qs.stringify({ a: Symbol.iterator }), &#039;a=Symbol%28Symbol.iterator%29&#039;);
        st.equal(
            qs.stringify({ a: [Symbol.iterator] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }),
            &#039;a[]=Symbol%28Symbol.iterator%29&#039;
        );
        st.end();
    });

    t.test(&#039;stringifies bigints&#039;, { skip: !hasBigInt }, function (st) {
        var three = BigInt(3);
        var encodeWithN = function (value, defaultEncoder, charset) {
            var result = defaultEncoder(value, defaultEncoder, charset);
            return typeof value === &#039;bigint&#039; ? result + &#039;n&#039; : result;
        };
        st.equal(qs.stringify(three), &#039;&#039;);
        st.equal(qs.stringify([three]), &#039;0=3&#039;);
        st.equal(qs.stringify([three], { encoder: encodeWithN }), &#039;0=3n&#039;);
        st.equal(qs.stringify({ a: three }), &#039;a=3&#039;);
        st.equal(qs.stringify({ a: three }, { encoder: encodeWithN }), &#039;a=3n&#039;);
        st.equal(
            qs.stringify({ a: [three] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }),
            &#039;a[]=3&#039;
        );
        st.equal(
            qs.stringify({ a: [three] }, { encodeValuesOnly: true, encoder: encodeWithN, arrayFormat: &#039;brackets&#039; }),
            &#039;a[]=3n&#039;
        );
        st.end();
    });

    t.test(&#039;encodes dot in key of object when encodeDotInKeys and allowDots is provided&#039;, function (st) {
        st.equal(
            qs.stringify(
                { &#039;name.obj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: false, encodeDotInKeys: false }
            ),
            &#039;name.obj%5Bfirst%5D=John&amp;name.obj%5Blast%5D=Doe&#039;,
            &#039;with allowDots false and encodeDotInKeys false&#039;
        );
        st.equal(
            qs.stringify(
                { &#039;name.obj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: true, encodeDotInKeys: false }
            ),
            &#039;name.obj.first=John&amp;name.obj.last=Doe&#039;,
            &#039;with allowDots true and encodeDotInKeys false&#039;
        );
        st.equal(
            qs.stringify(
                { &#039;name.obj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: false, encodeDotInKeys: true }
            ),
            &#039;name%252Eobj%5Bfirst%5D=John&amp;name%252Eobj%5Blast%5D=Doe&#039;,
            &#039;with allowDots false and encodeDotInKeys true&#039;
        );
        st.equal(
            qs.stringify(
                { &#039;name.obj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: true, encodeDotInKeys: true }
            ),
            &#039;name%252Eobj.first=John&amp;name%252Eobj.last=Doe&#039;,
            &#039;with allowDots true and encodeDotInKeys true&#039;
        );

        st.equal(
            qs.stringify(
                { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: false, encodeDotInKeys: false }
            ),
            &#039;name.obj.subobject%5Bfirst.godly.name%5D=John&amp;name.obj.subobject%5Blast%5D=Doe&#039;,
            &#039;with allowDots false and encodeDotInKeys false&#039;
        );
        st.equal(
            qs.stringify(
                { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: true, encodeDotInKeys: false }
            ),
            &#039;name.obj.subobject.first.godly.name=John&amp;name.obj.subobject.last=Doe&#039;,
            &#039;with allowDots false and encodeDotInKeys false&#039;
        );
        st.equal(
            qs.stringify(
                { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: false, encodeDotInKeys: true }
            ),
            &#039;name%252Eobj%252Esubobject%5Bfirst.godly.name%5D=John&amp;name%252Eobj%252Esubobject%5Blast%5D=Doe&#039;,
            &#039;with allowDots false and encodeDotInKeys true&#039;
        );
        st.equal(
            qs.stringify(
                { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
                { allowDots: true, encodeDotInKeys: true }
            ),
            &#039;name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&amp;name%252Eobj%252Esubobject.last=Doe&#039;,
            &#039;with allowDots true and encodeDotInKeys true&#039;
        );

        st.end();
    });

    t.test(&#039;should encode dot in key of object, and automatically set allowDots to `true` when encodeDotInKeys is true and allowDots in undefined&#039;, function (st) {
        st.equal(
            qs.stringify(
                { &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } },
                { encodeDotInKeys: true }
            ),
            &#039;name%252Eobj%252Esubobject.first%252Egodly%252Ename=John&amp;name%252Eobj%252Esubobject.last=Doe&#039;,
            &#039;with allowDots undefined and encodeDotInKeys true&#039;
        );
        st.end();
    });

    t.test(&#039;should encode dot in key of object when encodeDotInKeys and allowDots is provided, and nothing else when encodeValuesOnly is provided&#039;, function (st) {
        st.equal(
            qs.stringify({ &#039;name.obj&#039;: { first: &#039;John&#039;, last: &#039;Doe&#039; } }, {
                encodeDotInKeys: true, allowDots: true, encodeValuesOnly: true
            }),
            &#039;name%2Eobj.first=John&amp;name%2Eobj.last=Doe&#039;
        );

        st.equal(
            qs.stringify({ &#039;name.obj.subobject&#039;: { &#039;first.godly.name&#039;: &#039;John&#039;, last: &#039;Doe&#039; } }, { allowDots: true, encodeDotInKeys: true, encodeValuesOnly: true }),
            &#039;name%2Eobj%2Esubobject.first%2Egodly%2Ename=John&amp;name%2Eobj%2Esubobject.last=Doe&#039;
        );

        st.end();
    });

    t.test(&#039;throws when `commaRoundTrip` is not a boolean&#039;, function (st) {
        st[&#039;throws&#039;](
            function () { qs.stringify({}, { commaRoundTrip: &#039;not a boolean&#039; }); },
            TypeError,
            &#039;throws when `commaRoundTrip` is not a boolean&#039;
        );

        st.end();
    });

    t.test(&#039;throws when `encodeDotInKeys` is not a boolean&#039;, function (st) {
        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { encodeDotInKeys: &#039;foobar&#039; }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { encodeDotInKeys: 0 }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { encodeDotInKeys: NaN }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { encodeDotInKeys: null }); },
            TypeError
        );

        st.end();
    });

    t.test(&#039;adds query prefix&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }, { addQueryPrefix: true }), &#039;?a=b&#039;);
        st.end();
    });

    t.test(&#039;with query prefix, outputs blank string given an empty object&#039;, function (st) {
        st.equal(qs.stringify({}, { addQueryPrefix: true }), &#039;&#039;);
        st.end();
    });

    t.test(&#039;stringifies nested falsy values&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: { c: null } } }), &#039;a%5Bb%5D%5Bc%5D=&#039;);
        st.equal(qs.stringify({ a: { b: { c: null } } }, { strictNullHandling: true }), &#039;a%5Bb%5D%5Bc%5D&#039;);
        st.equal(qs.stringify({ a: { b: { c: false } } }), &#039;a%5Bb%5D%5Bc%5D=false&#039;);
        st.end();
    });

    t.test(&#039;stringifies a nested object&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }), &#039;a%5Bb%5D=c&#039;);
        st.equal(qs.stringify({ a: { b: { c: { d: &#039;e&#039; } } } }), &#039;a%5Bb%5D%5Bc%5D%5Bd%5D=e&#039;);
        st.end();
    });

    t.test(&#039;`allowDots` option: stringifies a nested object with dots notation&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }, { allowDots: true }), &#039;a.b=c&#039;);
        st.equal(qs.stringify({ a: { b: { c: { d: &#039;e&#039; } } } }, { allowDots: true }), &#039;a.b.c.d=e&#039;);
        st.end();
    });

    t.test(&#039;stringifies an array value&#039;, function (st) {
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { arrayFormat: &#039;indices&#039; }),
            &#039;a%5B0%5D=b&amp;a%5B1%5D=c&amp;a%5B2%5D=d&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { arrayFormat: &#039;brackets&#039; }),
            &#039;a%5B%5D=b&amp;a%5B%5D=c&amp;a%5B%5D=d&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { arrayFormat: &#039;comma&#039; }),
            &#039;a=b%2Cc%2Cd&#039;,
            &#039;comma =&gt; comma&#039;
        );
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { arrayFormat: &#039;comma&#039;, commaRoundTrip: true }),
            &#039;a=b%2Cc%2Cd&#039;,
            &#039;comma round trip =&gt; comma&#039;
        );
        st.equal(
            qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }),
            &#039;a%5B0%5D=b&amp;a%5B1%5D=c&amp;a%5B2%5D=d&#039;,
            &#039;default =&gt; indices&#039;
        );
        st.end();
    });

    t.test(&#039;`skipNulls` option&#039;, function (st) {
        st.equal(
            qs.stringify({ a: &#039;b&#039;, c: null }, { skipNulls: true }),
            &#039;a=b&#039;,
            &#039;omits nulls when asked&#039;
        );

        st.equal(
            qs.stringify({ a: { b: &#039;c&#039;, d: null } }, { skipNulls: true }),
            &#039;a%5Bb%5D=c&#039;,
            &#039;omits nested nulls when asked&#039;
        );

        st.end();
    });

    t.test(&#039;omits array indices when asked&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] }, { indices: false }), &#039;a=b&amp;a=c&amp;a=d&#039;);

        st.end();
    });

    t.test(&#039;omits object key/value pair when value is empty array&#039;, function (st) {
        st.equal(qs.stringify({ a: [], b: &#039;zz&#039; }), &#039;b=zz&#039;);

        st.end();
    });

    t.test(&#039;should not omit object key/value pair when value is empty array and when asked&#039;, function (st) {
        st.equal(qs.stringify({ a: [], b: &#039;zz&#039; }), &#039;b=zz&#039;);
        st.equal(qs.stringify({ a: [], b: &#039;zz&#039; }, { allowEmptyArrays: false }), &#039;b=zz&#039;);
        st.equal(qs.stringify({ a: [], b: &#039;zz&#039; }, { allowEmptyArrays: true }), &#039;a[]&amp;b=zz&#039;);

        st.end();
    });

    t.test(&#039;should throw when allowEmptyArrays is not of type boolean&#039;, function (st) {
        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { allowEmptyArrays: &#039;foobar&#039; }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { allowEmptyArrays: 0 }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { allowEmptyArrays: NaN }); },
            TypeError
        );

        st[&#039;throws&#039;](
            function () { qs.stringify({ a: [], b: &#039;zz&#039; }, { allowEmptyArrays: null }); },
            TypeError
        );

        st.end();
    });

    t.test(&#039;allowEmptyArrays + strictNullHandling&#039;, function (st) {
        st.equal(
            qs.stringify(
                { testEmptyArray: [] },
                { strictNullHandling: true, allowEmptyArrays: true }
            ),
            &#039;testEmptyArray[]&#039;
        );

        st.end();
    });

    t.test(&#039;stringifies an array value with one item vs multiple items&#039;, function (st) {
        st.test(&#039;non-array item&#039;, function (s2t) {
            s2t.equal(qs.stringify({ a: &#039;c&#039; }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a=c&#039;);
            s2t.equal(qs.stringify({ a: &#039;c&#039; }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a=c&#039;);
            s2t.equal(qs.stringify({ a: &#039;c&#039; }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a=c&#039;);
            s2t.equal(qs.stringify({ a: &#039;c&#039; }, { encodeValuesOnly: true }), &#039;a=c&#039;);

            s2t.end();
        });

        st.test(&#039;array with a single item&#039;, function (s2t) {
            s2t.equal(qs.stringify({ a: [&#039;c&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[0]=c&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[]=c&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a=c&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039;, commaRoundTrip: true }), &#039;a[]=c&#039;); // so it parses back as an array
            s2t.equal(qs.stringify({ a: [&#039;c&#039;] }, { encodeValuesOnly: true }), &#039;a[0]=c&#039;);

            s2t.end();
        });

        st.test(&#039;array with multiple items&#039;, function (s2t) {
            s2t.equal(qs.stringify({ a: [&#039;c&#039;, &#039;d&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[0]=c&amp;a[1]=d&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;, &#039;d&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[]=c&amp;a[]=d&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;, &#039;d&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a=c,d&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;, &#039;d&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039;, commaRoundTrip: true }), &#039;a=c,d&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c&#039;, &#039;d&#039;] }, { encodeValuesOnly: true }), &#039;a[0]=c&amp;a[1]=d&#039;);

            s2t.end();
        });

        st.test(&#039;array with multiple items with a comma inside&#039;, function (s2t) {
            s2t.equal(qs.stringify({ a: [&#039;c,d&#039;, &#039;e&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a=c%2Cd,e&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c,d&#039;, &#039;e&#039;] }, { arrayFormat: &#039;comma&#039; }), &#039;a=c%2Cd%2Ce&#039;);

            s2t.equal(qs.stringify({ a: [&#039;c,d&#039;, &#039;e&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039;, commaRoundTrip: true }), &#039;a=c%2Cd,e&#039;);
            s2t.equal(qs.stringify({ a: [&#039;c,d&#039;, &#039;e&#039;] }, { arrayFormat: &#039;comma&#039;, commaRoundTrip: true }), &#039;a=c%2Cd%2Ce&#039;);

            s2t.end();
        });

        st.end();
    });

    t.test(&#039;stringifies a nested array value&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[b][0]=c&amp;a[b][1]=d&#039;);
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[b][]=c&amp;a[b][]=d&#039;);
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a[b]=c,d&#039;);
        st.equal(qs.stringify({ a: { b: [&#039;c&#039;, &#039;d&#039;] } }, { encodeValuesOnly: true }), &#039;a[b][0]=c&amp;a[b][1]=d&#039;);
        st.end();
    });

    t.test(&#039;stringifies comma and empty array values&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;a[0]=,&amp;a[1]=&amp;a[2]=c,d%&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: false, arrayFormat: &#039;brackets&#039; }), &#039;a[]=,&amp;a[]=&amp;a[]=c,d%&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: false, arrayFormat: &#039;comma&#039; }), &#039;a=,,,c,d%&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: false, arrayFormat: &#039;repeat&#039; }), &#039;a=,&amp;a=&amp;a=c,d%&#039;);

        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[0]=%2C&amp;a[1]=&amp;a[2]=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[]=%2C&amp;a[]=&amp;a[]=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a=%2C,,c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }), &#039;a=%2C&amp;a=&amp;a=c%2Cd%25&#039;);

        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;indices&#039; }), &#039;a%5B0%5D=%2C&amp;a%5B1%5D=&amp;a%5B2%5D=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;brackets&#039; }), &#039;a%5B%5D=%2C&amp;a%5B%5D=&amp;a%5B%5D=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;comma&#039; }), &#039;a=%2C%2C%2Cc%2Cd%25&#039;);
        st.equal(qs.stringify({ a: [&#039;,&#039;, &#039;&#039;, &#039;c,d%&#039;] }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;repeat&#039; }), &#039;a=%2C&amp;a=&amp;a=c%2Cd%25&#039;);

        st.end();
    });

    t.test(&#039;stringifies comma and empty non-array values&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;a=,&amp;b=&amp;c=c,d%&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: false, arrayFormat: &#039;brackets&#039; }), &#039;a=,&amp;b=&amp;c=c,d%&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: false, arrayFormat: &#039;comma&#039; }), &#039;a=,&amp;b=&amp;c=c,d%&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: false, arrayFormat: &#039;repeat&#039; }), &#039;a=,&amp;b=&amp;c=c,d%&#039;);

        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);

        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;indices&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;brackets&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;comma&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);
        st.equal(qs.stringify({ a: &#039;,&#039;, b: &#039;&#039;, c: &#039;c,d%&#039; }, { encode: true, encodeValuesOnly: false, arrayFormat: &#039;repeat&#039; }), &#039;a=%2C&amp;b=&amp;c=c%2Cd%25&#039;);

        st.end();
    });

    t.test(&#039;stringifies a nested array value with dots notation&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a.b[0]=c&amp;a.b[1]=d&#039;,
            &#039;indices: stringifies with dots + indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a.b[]=c&amp;a.b[]=d&#039;,
            &#039;brackets: stringifies with dots + brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }
            ),
            &#039;a.b=c,d&#039;,
            &#039;comma: stringifies with dots + comma&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [&#039;c&#039;, &#039;d&#039;] } },
                { allowDots: true, encodeValuesOnly: true }
            ),
            &#039;a.b[0]=c&amp;a.b[1]=d&#039;,
            &#039;default: stringifies with dots + indices&#039;
        );
        st.end();
    });

    t.test(&#039;stringifies an object inside an array&#039;, function (st) {
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }, { arrayFormat: &#039;indices&#039;, encodeValuesOnly: true }),
            &#039;a[0][b]=c&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }, { arrayFormat: &#039;repeat&#039;, encodeValuesOnly: true }),
            &#039;a[b]=c&#039;,
            &#039;repeat =&gt; repeat&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }, { arrayFormat: &#039;brackets&#039;, encodeValuesOnly: true }),
            &#039;a[][b]=c&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: &#039;c&#039; }] }, { encodeValuesOnly: true }),
            &#039;a[0][b]=c&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: &#039;indices&#039;, encodeValuesOnly: true }),
            &#039;a[0][b][c][0]=1&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: &#039;repeat&#039;, encodeValuesOnly: true }),
            &#039;a[b][c]=1&#039;,
            &#039;repeat =&gt; repeat&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { arrayFormat: &#039;brackets&#039;, encodeValuesOnly: true }),
            &#039;a[][b][c][]=1&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: { c: [1] } }] }, { encodeValuesOnly: true }),
            &#039;a[0][b][c][0]=1&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;stringifies an array with mixed objects and primitives&#039;, function (st) {
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }),
            &#039;a[0][b]=1&amp;a[1]=2&amp;a[2]=3&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }),
            &#039;a[][b]=1&amp;a[]=2&amp;a[]=3&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true, arrayFormat: &#039;comma&#039; }),
            &#039;???&#039;,
            &#039;brackets =&gt; brackets&#039;,
            { skip: &#039;TODO: figure out what this should do&#039; }
        );
        st.equal(
            qs.stringify({ a: [{ b: 1 }, 2, 3] }, { encodeValuesOnly: true }),
            &#039;a[0][b]=1&amp;a[1]=2&amp;a[2]=3&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;stringifies an object inside an array with dots notation&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: [{ b: &#039;c&#039; }] },
                { allowDots: true, encode: false, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a[0].b=c&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: &#039;c&#039; }] },
                { allowDots: true, encode: false, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a[].b=c&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: &#039;c&#039; }] },
                { allowDots: true, encode: false }
            ),
            &#039;a[0].b=c&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a[0].b.c[0]=1&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a[].b.c[]=1&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: [{ b: { c: [1] } }] },
                { allowDots: true, encode: false }
            ),
            &#039;a[0].b.c[0]=1&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;does not omit object keys when indices = false&#039;, function (st) {
        st.equal(qs.stringify({ a: [{ b: &#039;c&#039; }] }, { indices: false }), &#039;a%5Bb%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses indices notation for arrays when indices=true&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { indices: true }), &#039;a%5B0%5D=b&amp;a%5B1%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses indices notation for arrays when no arrayFormat is specified&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }), &#039;a%5B0%5D=b&amp;a%5B1%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses indices notation for arrays when arrayFormat=indices&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { arrayFormat: &#039;indices&#039; }), &#039;a%5B0%5D=b&amp;a%5B1%5D=c&#039;);
        st.end();
    });

    t.test(&#039;uses repeat notation for arrays when arrayFormat=repeat&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { arrayFormat: &#039;repeat&#039; }), &#039;a=b&amp;a=c&#039;);
        st.end();
    });

    t.test(&#039;uses brackets notation for arrays when arrayFormat=brackets&#039;, function (st) {
        st.equal(qs.stringify({ a: [&#039;b&#039;, &#039;c&#039;] }, { arrayFormat: &#039;brackets&#039; }), &#039;a%5B%5D=b&amp;a%5B%5D=c&#039;);
        st.end();
    });

    t.test(&#039;stringifies a complicated object&#039;, function (st) {
        st.equal(qs.stringify({ a: { b: &#039;c&#039;, d: &#039;e&#039; } }), &#039;a%5Bb%5D=c&amp;a%5Bd%5D=e&#039;);
        st.end();
    });

    t.test(&#039;stringifies an empty value&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;&#039; }), &#039;a=&#039;);
        st.equal(qs.stringify({ a: null }, { strictNullHandling: true }), &#039;a&#039;);

        st.equal(qs.stringify({ a: &#039;&#039;, b: &#039;&#039; }), &#039;a=&amp;b=&#039;);
        st.equal(qs.stringify({ a: null, b: &#039;&#039; }, { strictNullHandling: true }), &#039;a&amp;b=&#039;);

        st.equal(qs.stringify({ a: { b: &#039;&#039; } }), &#039;a%5Bb%5D=&#039;);
        st.equal(qs.stringify({ a: { b: null } }, { strictNullHandling: true }), &#039;a%5Bb%5D&#039;);
        st.equal(qs.stringify({ a: { b: null } }, { strictNullHandling: false }), &#039;a%5Bb%5D=&#039;);

        st.end();
    });

    t.test(&#039;stringifies an empty array in different arrayFormat&#039;, function (st) {
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false }), &#039;b[0]=&amp;c=c&#039;);
        // arrayFormat default
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;b[0]=&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;brackets&#039; }), &#039;b[]=&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;repeat&#039; }), &#039;b=&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;comma&#039; }), &#039;b=&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;comma&#039;, commaRoundTrip: true }), &#039;b[]=&amp;c=c&#039;);
        // with strictNullHandling
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;indices&#039;, strictNullHandling: true }), &#039;b[0]&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;brackets&#039;, strictNullHandling: true }), &#039;b[]&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;repeat&#039;, strictNullHandling: true }), &#039;b&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;comma&#039;, strictNullHandling: true }), &#039;b&amp;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;comma&#039;, strictNullHandling: true, commaRoundTrip: true }), &#039;b[]&amp;c=c&#039;);
        // with skipNulls
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;indices&#039;, skipNulls: true }), &#039;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;brackets&#039;, skipNulls: true }), &#039;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;repeat&#039;, skipNulls: true }), &#039;c=c&#039;);
        st.equal(qs.stringify({ a: [], b: [null], c: &#039;c&#039; }, { encode: false, arrayFormat: &#039;comma&#039;, skipNulls: true }), &#039;c=c&#039;);

        st.end();
    });

    t.test(&#039;stringifies a null object&#039;, { skip: !hasProto }, function (st) {
        st.equal(qs.stringify({ __proto__: null, a: &#039;b&#039; }), &#039;a=b&#039;);
        st.end();
    });

    t.test(&#039;returns an empty string for invalid input&#039;, function (st) {
        st.equal(qs.stringify(undefined), &#039;&#039;);
        st.equal(qs.stringify(false), &#039;&#039;);
        st.equal(qs.stringify(null), &#039;&#039;);
        st.equal(qs.stringify(&#039;&#039;), &#039;&#039;);
        st.end();
    });

    t.test(&#039;stringifies an object with a null object as a child&#039;, { skip: !hasProto }, function (st) {
        st.equal(qs.stringify({ a: { __proto__: null, b: &#039;c&#039; } }), &#039;a%5Bb%5D=c&#039;);
        st.end();
    });

    t.test(&#039;drops keys with a value of undefined&#039;, function (st) {
        st.equal(qs.stringify({ a: undefined }), &#039;&#039;);

        st.equal(qs.stringify({ a: { b: undefined, c: null } }, { strictNullHandling: true }), &#039;a%5Bc%5D&#039;);
        st.equal(qs.stringify({ a: { b: undefined, c: null } }, { strictNullHandling: false }), &#039;a%5Bc%5D=&#039;);
        st.equal(qs.stringify({ a: { b: undefined, c: &#039;&#039; } }), &#039;a%5Bc%5D=&#039;);
        st.end();
    });

    t.test(&#039;url encodes values&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }), &#039;a=b%20c&#039;);
        st.end();
    });

    t.test(&#039;stringifies a date&#039;, function (st) {
        var now = new Date();
        var str = &#039;a=&#039; + encodeURIComponent(now.toISOString());
        st.equal(qs.stringify({ a: now }), str);
        st.end();
    });

    t.test(&#039;stringifies the weird object from qs&#039;, function (st) {
        st.equal(qs.stringify({ &#039;my weird field&#039;: &#039;~q1!2&quot;\&#039;w$5&amp;7/z8)?&#039; }), &#039;my%20weird%20field=~q1%212%22%27w%245%267%2Fz8%29%3F&#039;);
        st.end();
    });

    t.test(&#039;skips properties that are part of the object prototype&#039;, function (st) {
        st.intercept(Object.prototype, &#039;crash&#039;, { value: &#039;test&#039; });

        st.equal(qs.stringify({ a: &#039;b&#039; }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }), &#039;a%5Bb%5D=c&#039;);

        st.end();
    });

    t.test(&#039;stringifies boolean values&#039;, function (st) {
        st.equal(qs.stringify({ a: true }), &#039;a=true&#039;);
        st.equal(qs.stringify({ a: { b: true } }), &#039;a%5Bb%5D=true&#039;);
        st.equal(qs.stringify({ b: false }), &#039;b=false&#039;);
        st.equal(qs.stringify({ b: { c: false } }), &#039;b%5Bc%5D=false&#039;);
        st.end();
    });

    t.test(&#039;stringifies buffer values&#039;, function (st) {
        st.equal(qs.stringify({ a: SaferBuffer.from(&#039;test&#039;) }), &#039;a=test&#039;);
        st.equal(qs.stringify({ a: { b: SaferBuffer.from(&#039;test&#039;) } }), &#039;a%5Bb%5D=test&#039;);
        st.end();
    });

    t.test(&#039;stringifies an object using an alternative delimiter&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039;, c: &#039;d&#039; }, { delimiter: &#039;;&#039; }), &#039;a=b;c=d&#039;);
        st.end();
    });

    t.test(&#039;does not blow up when Buffer global is missing&#039;, function (st) {
        var restore = mockProperty(global, &#039;Buffer&#039;, { &#039;delete&#039;: true });

        var result = qs.stringify({ a: &#039;b&#039;, c: &#039;d&#039; });

        restore();

        st.equal(result, &#039;a=b&amp;c=d&#039;);
        st.end();
    });

    t.test(&#039;does not crash when parsing circular references&#039;, function (st) {
        var a = {};
        a.b = a;

        st[&#039;throws&#039;](
            function () { qs.stringify({ &#039;foo[bar]&#039;: &#039;baz&#039;, &#039;foo[baz]&#039;: a }); },
            /RangeError: Cyclic object value/,
            &#039;cyclic values throw&#039;
        );

        var circular = {
            a: &#039;value&#039;
        };
        circular.a = circular;
        st[&#039;throws&#039;](
            function () { qs.stringify(circular); },
            /RangeError: Cyclic object value/,
            &#039;cyclic values throw&#039;
        );

        var arr = [&#039;a&#039;];
        st.doesNotThrow(
            function () { qs.stringify({ x: arr, y: arr }); },
            &#039;non-cyclic values do not throw&#039;
        );

        st.end();
    });

    t.test(&#039;non-circular duplicated references can still work&#039;, function (st) {
        var hourOfDay = {
            &#039;function&#039;: &#039;hour_of_day&#039;
        };

        var p1 = {
            &#039;function&#039;: &#039;gte&#039;,
            arguments: [hourOfDay, 0]
        };
        var p2 = {
            &#039;function&#039;: &#039;lte&#039;,
            arguments: [hourOfDay, 23]
        };

        st.equal(
            qs.stringify({ filters: { $and: [p1, p2] } }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }),
            &#039;filters[$and][0][function]=gte&amp;filters[$and][0][arguments][0][function]=hour_of_day&amp;filters[$and][0][arguments][1]=0&amp;filters[$and][1][function]=lte&amp;filters[$and][1][arguments][0][function]=hour_of_day&amp;filters[$and][1][arguments][1]=23&#039;
        );
        st.equal(
            qs.stringify({ filters: { $and: [p1, p2] } }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }),
            &#039;filters[$and][][function]=gte&amp;filters[$and][][arguments][][function]=hour_of_day&amp;filters[$and][][arguments][]=0&amp;filters[$and][][function]=lte&amp;filters[$and][][arguments][][function]=hour_of_day&amp;filters[$and][][arguments][]=23&#039;
        );
        st.equal(
            qs.stringify({ filters: { $and: [p1, p2] } }, { encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }),
            &#039;filters[$and][function]=gte&amp;filters[$and][arguments][function]=hour_of_day&amp;filters[$and][arguments]=0&amp;filters[$and][function]=lte&amp;filters[$and][arguments][function]=hour_of_day&amp;filters[$and][arguments]=23&#039;
        );

        st.end();
    });

    t.test(&#039;selects properties when filter=array&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }, { filter: [&#039;a&#039;] }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: 1 }, { filter: [] }), &#039;&#039;);

        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: &#039;d&#039; }, c: &#039;f&#039; },
                { filter: [&#039;a&#039;, &#039;b&#039;, 0, 2], arrayFormat: &#039;indices&#039; }
            ),
            &#039;a%5Bb%5D%5B0%5D=1&amp;a%5Bb%5D%5B2%5D=3&#039;,
            &#039;indices =&gt; indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: &#039;d&#039; }, c: &#039;f&#039; },
                { filter: [&#039;a&#039;, &#039;b&#039;, 0, 2], arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a%5Bb%5D%5B%5D=1&amp;a%5Bb%5D%5B%5D=3&#039;,
            &#039;brackets =&gt; brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: { b: [1, 2, 3, 4], c: &#039;d&#039; }, c: &#039;f&#039; },
                { filter: [&#039;a&#039;, &#039;b&#039;, 0, 2] }
            ),
            &#039;a%5Bb%5D%5B0%5D=1&amp;a%5Bb%5D%5B2%5D=3&#039;,
            &#039;default =&gt; indices&#039;
        );

        st.end();
    });

    t.test(&#039;supports custom representations when filter=function&#039;, function (st) {
        var calls = 0;
        var obj = { a: &#039;b&#039;, c: &#039;d&#039;, e: { f: new Date(1257894000000) } };
        var filterFunc = function (prefix, value) {
            calls += 1;
            if (calls === 1) {
                st.equal(prefix, &#039;&#039;, &#039;prefix is empty&#039;);
                st.equal(value, obj);
            } else if (prefix === &#039;c&#039;) {
                return void 0;
            } else if (value instanceof Date) {
                st.equal(prefix, &#039;e[f]&#039;);
                return value.getTime();
            }
            return value;
        };

        st.equal(qs.stringify(obj, { filter: filterFunc }), &#039;a=b&amp;e%5Bf%5D=1257894000000&#039;);
        st.equal(calls, 5);
        st.end();
    });

    t.test(&#039;can disable uri encoding&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b&#039; }, { encode: false }), &#039;a=b&#039;);
        st.equal(qs.stringify({ a: { b: &#039;c&#039; } }, { encode: false }), &#039;a[b]=c&#039;);
        st.equal(qs.stringify({ a: &#039;b&#039;, c: null }, { strictNullHandling: true, encode: false }), &#039;a=b&amp;c&#039;);
        st.end();
    });

    t.test(&#039;can sort the keys&#039;, function (st) {
        var sort = function (a, b) {
            return a.localeCompare(b);
        };
        st.equal(qs.stringify({ a: &#039;c&#039;, z: &#039;y&#039;, b: &#039;f&#039; }, { sort: sort }), &#039;a=c&amp;b=f&amp;z=y&#039;);
        st.equal(qs.stringify({ a: &#039;c&#039;, z: { j: &#039;a&#039;, i: &#039;b&#039; }, b: &#039;f&#039; }, { sort: sort }), &#039;a=c&amp;b=f&amp;z%5Bi%5D=b&amp;z%5Bj%5D=a&#039;);
        st.end();
    });

    t.test(&#039;can sort the keys at depth 3 or more too&#039;, function (st) {
        var sort = function (a, b) {
            return a.localeCompare(b);
        };
        st.equal(
            qs.stringify(
                { a: &#039;a&#039;, z: { zj: { zjb: &#039;zjb&#039;, zja: &#039;zja&#039; }, zi: { zib: &#039;zib&#039;, zia: &#039;zia&#039; } }, b: &#039;b&#039; },
                { sort: sort, encode: false }
            ),
            &#039;a=a&amp;b=b&amp;z[zi][zia]=zia&amp;z[zi][zib]=zib&amp;z[zj][zja]=zja&amp;z[zj][zjb]=zjb&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;a&#039;, z: { zj: { zjb: &#039;zjb&#039;, zja: &#039;zja&#039; }, zi: { zib: &#039;zib&#039;, zia: &#039;zia&#039; } }, b: &#039;b&#039; },
                { sort: null, encode: false }
            ),
            &#039;a=a&amp;z[zj][zjb]=zjb&amp;z[zj][zja]=zja&amp;z[zi][zib]=zib&amp;z[zi][zia]=zia&amp;b=b&#039;
        );
        st.end();
    });

    t.test(&#039;can stringify with custom encoding&#039;, function (st) {
        st.equal(qs.stringify({ Áúå: &#039;Â§ßÈò™Â∫ú&#039;, &#039;&#039;: &#039;&#039; }, {
            encoder: function (str) {
                if (str.length === 0) {
                    return &#039;&#039;;
                }
                var buf = iconv.encode(str, &#039;shiftjis&#039;);
                var result = [];
                for (var i = 0; i &lt; buf.length; ++i) {
                    result.push(buf.readUInt8(i).toString(16));
                }
                return &#039;%&#039; + result.join(&#039;%&#039;);
            }
        }), &#039;%8c%a7=%91%e5%8d%e3%95%7b&amp;=&#039;);
        st.end();
    });

    t.test(&#039;receives the default encoder as a second argument&#039;, function (st) {
        st.plan(8);

        qs.stringify({ a: 1, b: new Date(), c: true, d: [1] }, {
            encoder: function (str) {
                st.match(typeof str, /^(?:string|number|boolean)$/);
                return &#039;&#039;;
            }
        });

        st.end();
    });

    t.test(&#039;receives the default encoder as a second argument&#039;, function (st) {
        st.plan(2);

        qs.stringify({ a: 1 }, {
            encoder: function (str, defaultEncoder) {
                st.equal(defaultEncoder, utils.encode);
            }
        });

        st.end();
    });

    t.test(&#039;throws error with wrong encoder&#039;, function (st) {
        st[&#039;throws&#039;](function () {
            qs.stringify({}, { encoder: &#039;string&#039; });
        }, new TypeError(&#039;Encoder has to be a function.&#039;));
        st.end();
    });

    t.test(&#039;can use custom encoder for a buffer object&#039;, { skip: typeof Buffer === &#039;undefined&#039; }, function (st) {
        st.equal(qs.stringify({ a: SaferBuffer.from([1]) }, {
            encoder: function (buffer) {
                if (typeof buffer === &#039;string&#039;) {
                    return buffer;
                }
                return String.fromCharCode(buffer.readUInt8(0) + 97);
            }
        }), &#039;a=b&#039;);

        st.equal(qs.stringify({ a: SaferBuffer.from(&#039;a b&#039;) }, {
            encoder: function (buffer) {
                return buffer;
            }
        }), &#039;a=a b&#039;);
        st.end();
    });

    t.test(&#039;serializeDate option&#039;, function (st) {
        var date = new Date();
        st.equal(
            qs.stringify({ a: date }),
            &#039;a=&#039; + date.toISOString().replace(/:/g, &#039;%3A&#039;),
            &#039;default is toISOString&#039;
        );

        var mutatedDate = new Date();
        mutatedDate.toISOString = function () {
            throw new SyntaxError();
        };
        st[&#039;throws&#039;](function () {
            mutatedDate.toISOString();
        }, SyntaxError);
        st.equal(
            qs.stringify({ a: mutatedDate }),
            &#039;a=&#039; + Date.prototype.toISOString.call(mutatedDate).replace(/:/g, &#039;%3A&#039;),
            &#039;toISOString works even when method is not locally present&#039;
        );

        var specificDate = new Date(6);
        st.equal(
            qs.stringify(
                { a: specificDate },
                { serializeDate: function (d) { return d.getTime() * 7; } }
            ),
            &#039;a=42&#039;,
            &#039;custom serializeDate function called&#039;
        );

        st.equal(
            qs.stringify(
                { a: [date] },
                {
                    serializeDate: function (d) { return d.getTime(); },
                    arrayFormat: &#039;comma&#039;
                }
            ),
            &#039;a=&#039; + date.getTime(),
            &#039;works with arrayFormat comma&#039;
        );
        st.equal(
            qs.stringify(
                { a: [date] },
                {
                    serializeDate: function (d) { return d.getTime(); },
                    arrayFormat: &#039;comma&#039;,
                    commaRoundTrip: true
                }
            ),
            &#039;a%5B%5D=&#039; + date.getTime(),
            &#039;works with arrayFormat comma&#039;
        );

        st.end();
    });

    t.test(&#039;RFC 1738 serialization&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }, { format: qs.formats.RFC1738 }), &#039;a=b+c&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: &#039;c d&#039; }, { format: qs.formats.RFC1738 }), &#039;a+b=c+d&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: SaferBuffer.from(&#039;a b&#039;) }, { format: qs.formats.RFC1738 }), &#039;a+b=a+b&#039;);

        st.equal(qs.stringify({ &#039;foo(ref)&#039;: &#039;bar&#039; }, { format: qs.formats.RFC1738 }), &#039;foo(ref)=bar&#039;);

        st.end();
    });

    t.test(&#039;RFC 3986 spaces serialization&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }, { format: qs.formats.RFC3986 }), &#039;a=b%20c&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: &#039;c d&#039; }, { format: qs.formats.RFC3986 }), &#039;a%20b=c%20d&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: SaferBuffer.from(&#039;a b&#039;) }, { format: qs.formats.RFC3986 }), &#039;a%20b=a%20b&#039;);

        st.end();
    });

    t.test(&#039;Backward compatibility to RFC 3986&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;b c&#039; }), &#039;a=b%20c&#039;);
        st.equal(qs.stringify({ &#039;a b&#039;: SaferBuffer.from(&#039;a b&#039;) }), &#039;a%20b=a%20b&#039;);

        st.end();
    });

    t.test(&#039;Edge cases and unknown formats&#039;, function (st) {
        [&#039;UFO1234&#039;, false, 1234, null, {}, []].forEach(function (format) {
            st[&#039;throws&#039;](
                function () {
                    qs.stringify({ a: &#039;b c&#039; }, { format: format });
                },
                new TypeError(&#039;Unknown format option provided.&#039;)
            );
        });
        st.end();
    });

    t.test(&#039;encodeValuesOnly&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e=f&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }
            ),
            &#039;a=b&amp;c[0]=d&amp;c[1]=e%3Df&amp;f[0][0]=g&amp;f[1][0]=h&#039;,
            &#039;encodeValuesOnly + indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e=f&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a=b&amp;c[]=d&amp;c[]=e%3Df&amp;f[][]=g&amp;f[][]=h&#039;,
            &#039;encodeValuesOnly + brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e=f&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }
            ),
            &#039;a=b&amp;c=d&amp;c=e%3Df&amp;f=g&amp;f=h&#039;,
            &#039;encodeValuesOnly + repeat&#039;
        );

        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { arrayFormat: &#039;indices&#039; }
            ),
            &#039;a=b&amp;c%5B0%5D=d&amp;c%5B1%5D=e&amp;f%5B0%5D%5B0%5D=g&amp;f%5B1%5D%5B0%5D=h&#039;,
            &#039;no encodeValuesOnly + indices&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { arrayFormat: &#039;brackets&#039; }
            ),
            &#039;a=b&amp;c%5B%5D=d&amp;c%5B%5D=e&amp;f%5B%5D%5B%5D=g&amp;f%5B%5D%5B%5D=h&#039;,
            &#039;no encodeValuesOnly + brackets&#039;
        );
        st.equal(
            qs.stringify(
                { a: &#039;b&#039;, c: [&#039;d&#039;, &#039;e&#039;], f: [[&#039;g&#039;], [&#039;h&#039;]] },
                { arrayFormat: &#039;repeat&#039; }
            ),
            &#039;a=b&amp;c=d&amp;c=e&amp;f=g&amp;f=h&#039;,
            &#039;no encodeValuesOnly + repeat&#039;
        );

        st.end();
    });

    t.test(&#039;encodeValuesOnly - strictNullHandling&#039;, function (st) {
        st.equal(
            qs.stringify(
                { a: { b: null } },
                { encodeValuesOnly: true, strictNullHandling: true }
            ),
            &#039;a[b]&#039;
        );
        st.end();
    });

    t.test(&#039;throws if an invalid charset is specified&#039;, function (st) {
        st[&#039;throws&#039;](function () {
            qs.stringify({ a: &#039;b&#039; }, { charset: &#039;foobar&#039; });
        }, new TypeError(&#039;The charset option must be either utf-8, iso-8859-1, or undefined&#039;));
        st.end();
    });

    t.test(&#039;respects a charset of iso-8859-1&#039;, function (st) {
        st.equal(qs.stringify({ √¶: &#039;√¶&#039; }, { charset: &#039;iso-8859-1&#039; }), &#039;%E6=%E6&#039;);
        st.end();
    });

    t.test(&#039;encodes unrepresentable chars as numeric entities in iso-8859-1 mode&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;‚ò∫&#039; }, { charset: &#039;iso-8859-1&#039; }), &#039;a=%26%239786%3B&#039;);
        st.end();
    });

    t.test(&#039;respects an explicit charset of utf-8 (the default)&#039;, function (st) {
        st.equal(qs.stringify({ a: &#039;√¶&#039; }, { charset: &#039;utf-8&#039; }), &#039;a=%C3%A6&#039;);
        st.end();
    });

    t.test(&#039;`charsetSentinel` option&#039;, function (st) {
        st.equal(
            qs.stringify({ a: &#039;√¶&#039; }, { charsetSentinel: true, charset: &#039;utf-8&#039; }),
            &#039;utf8=%E2%9C%93&amp;a=%C3%A6&#039;,
            &#039;adds the right sentinel when instructed to and the charset is utf-8&#039;
        );

        st.equal(
            qs.stringify({ a: &#039;√¶&#039; }, { charsetSentinel: true, charset: &#039;iso-8859-1&#039; }),
            &#039;utf8=%26%2310003%3B&amp;a=%E6&#039;,
            &#039;adds the right sentinel when instructed to and the charset is iso-8859-1&#039;
        );

        st.end();
    });

    t.test(&#039;does not mutate the options argument&#039;, function (st) {
        var options = {};
        qs.stringify({}, options);
        st.deepEqual(options, {});
        st.end();
    });

    t.test(&#039;strictNullHandling works with custom filter&#039;, function (st) {
        var filter = function (prefix, value) {
            return value;
        };

        var options = { strictNullHandling: true, filter: filter };
        st.equal(qs.stringify({ key: null }, options), &#039;key&#039;);
        st.end();
    });

    t.test(&#039;strictNullHandling works with null serializeDate&#039;, function (st) {
        var serializeDate = function () {
            return null;
        };
        var options = { strictNullHandling: true, serializeDate: serializeDate };
        var date = new Date();
        st.equal(qs.stringify({ key: date }, options), &#039;key&#039;);
        st.end();
    });

    t.test(&#039;allows for encoding keys and values differently&#039;, function (st) {
        var encoder = function (str, defaultEncoder, charset, type) {
            if (type === &#039;key&#039;) {
                return defaultEncoder(str, defaultEncoder, charset, type).toLowerCase();
            }
            if (type === &#039;value&#039;) {
                return defaultEncoder(str, defaultEncoder, charset, type).toUpperCase();
            }
            throw &#039;this should never happen! type: &#039; + type;
        };

        st.deepEqual(qs.stringify({ KeY: &#039;vAlUe&#039; }, { encoder: encoder }), &#039;key=VALUE&#039;);
        st.end();
    });

    t.test(&#039;objects inside arrays&#039;, function (st) {
        var obj = { a: { b: { c: &#039;d&#039;, e: &#039;f&#039; } } };
        var withArray = { a: { b: [{ c: &#039;d&#039;, e: &#039;f&#039; }] } };

        st.equal(qs.stringify(obj, { encode: false }), &#039;a[b][c]=d&amp;a[b][e]=f&#039;, &#039;no array, no arrayFormat&#039;);
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: &#039;brackets&#039; }), &#039;a[b][c]=d&amp;a[b][e]=f&#039;, &#039;no array, bracket&#039;);
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;a[b][c]=d&amp;a[b][e]=f&#039;, &#039;no array, indices&#039;);
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: &#039;repeat&#039; }), &#039;a[b][c]=d&amp;a[b][e]=f&#039;, &#039;no array, repeat&#039;);
        st.equal(qs.stringify(obj, { encode: false, arrayFormat: &#039;comma&#039; }), &#039;a[b][c]=d&amp;a[b][e]=f&#039;, &#039;no array, comma&#039;);

        st.equal(qs.stringify(withArray, { encode: false }), &#039;a[b][0][c]=d&amp;a[b][0][e]=f&#039;, &#039;array, no arrayFormat&#039;);
        st.equal(qs.stringify(withArray, { encode: false, arrayFormat: &#039;brackets&#039; }), &#039;a[b][][c]=d&amp;a[b][][e]=f&#039;, &#039;array, bracket&#039;);
        st.equal(qs.stringify(withArray, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;a[b][0][c]=d&amp;a[b][0][e]=f&#039;, &#039;array, indices&#039;);
        st.equal(qs.stringify(withArray, { encode: false, arrayFormat: &#039;repeat&#039; }), &#039;a[b][c]=d&amp;a[b][e]=f&#039;, &#039;array, repeat&#039;);
        st.equal(
            qs.stringify(withArray, { encode: false, arrayFormat: &#039;comma&#039; }),
            &#039;???&#039;,
            &#039;array, comma&#039;,
            { skip: &#039;TODO: figure out what this should do&#039; }
        );

        st.end();
    });

    t.test(&#039;stringifies sparse arrays&#039;, function (st) {
        /* eslint no-sparse-arrays: 0 */
        st.equal(qs.stringify({ a: [, &#039;2&#039;, , , &#039;1&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[1]=2&amp;a[4]=1&#039;);
        st.equal(qs.stringify({ a: [, &#039;2&#039;, , , &#039;1&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[]=2&amp;a[]=1&#039;);
        st.equal(qs.stringify({ a: [, &#039;2&#039;, , , &#039;1&#039;] }, { encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }), &#039;a=2&amp;a=1&#039;);

        st.equal(qs.stringify({ a: [, { b: [, , { c: &#039;1&#039; }] }] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[1][b][2][c]=1&#039;);
        st.equal(qs.stringify({ a: [, { b: [, , { c: &#039;1&#039; }] }] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[][b][][c]=1&#039;);
        st.equal(qs.stringify({ a: [, { b: [, , { c: &#039;1&#039; }] }] }, { encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }), &#039;a[b][c]=1&#039;);

        st.equal(qs.stringify({ a: [, [, , [, , , { c: &#039;1&#039; }]]] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[1][2][3][c]=1&#039;);
        st.equal(qs.stringify({ a: [, [, , [, , , { c: &#039;1&#039; }]]] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[][][][c]=1&#039;);
        st.equal(qs.stringify({ a: [, [, , [, , , { c: &#039;1&#039; }]]] }, { encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }), &#039;a[c]=1&#039;);

        st.equal(qs.stringify({ a: [, [, , [, , , { c: [, &#039;1&#039;] }]]] }, { encodeValuesOnly: true, arrayFormat: &#039;indices&#039; }), &#039;a[1][2][3][c][1]=1&#039;);
        st.equal(qs.stringify({ a: [, [, , [, , , { c: [, &#039;1&#039;] }]]] }, { encodeValuesOnly: true, arrayFormat: &#039;brackets&#039; }), &#039;a[][][][c][]=1&#039;);
        st.equal(qs.stringify({ a: [, [, , [, , , { c: [, &#039;1&#039;] }]]] }, { encodeValuesOnly: true, arrayFormat: &#039;repeat&#039; }), &#039;a[c]=1&#039;);

        st.end();
    });

    t.test(&#039;encodes a very long string&#039;, function (st) {
        var chars = [];
        var expected = [];
        for (var i = 0; i &lt; 5e3; i++) {
            chars.push(&#039; &#039; + i);

            expected.push(&#039;%20&#039; + i);
        }

        var obj = {
            foo: chars.join(&#039;&#039;)
        };

        st.equal(
            qs.stringify(obj, { arrayFormat: &#039;brackets&#039;, charset: &#039;utf-8&#039; }),
            &#039;foo=&#039; + expected.join(&#039;&#039;)
        );

        st.end();
    });

    t.end();
});

test(&#039;stringifies empty keys&#039;, function (t) {
    emptyTestCases.forEach(function (testCase) {
        t.test(&#039;stringifies an object with empty string key with &#039; + testCase.input, function (st) {
            st.deepEqual(
                qs.stringify(testCase.withEmptyKeys, { encode: false, arrayFormat: &#039;indices&#039; }),
                testCase.stringifyOutput.indices,
                &#039;test case: &#039; + testCase.input + &#039;, indices&#039;
            );
            st.deepEqual(
                qs.stringify(testCase.withEmptyKeys, { encode: false, arrayFormat: &#039;brackets&#039; }),
                testCase.stringifyOutput.brackets,
                &#039;test case: &#039; + testCase.input + &#039;, brackets&#039;
            );
            st.deepEqual(
                qs.stringify(testCase.withEmptyKeys, { encode: false, arrayFormat: &#039;repeat&#039; }),
                testCase.stringifyOutput.repeat,
                &#039;test case: &#039; + testCase.input + &#039;, repeat&#039;
            );

            st.end();
        });
    });

    t.test(&#039;edge case with object/arrays&#039;, function (st) {
        st.deepEqual(qs.stringify({ &#039;&#039;: { &#039;&#039;: [2, 3] } }, { encode: false }), &#039;[][0]=2&amp;[][1]=3&#039;);
        st.deepEqual(qs.stringify({ &#039;&#039;: { &#039;&#039;: [2, 3], a: 2 } }, { encode: false }), &#039;[][0]=2&amp;[][1]=3&amp;[a]=2&#039;);
        st.deepEqual(qs.stringify({ &#039;&#039;: { &#039;&#039;: [2, 3] } }, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;[][0]=2&amp;[][1]=3&#039;);
        st.deepEqual(qs.stringify({ &#039;&#039;: { &#039;&#039;: [2, 3], a: 2 } }, { encode: false, arrayFormat: &#039;indices&#039; }), &#039;[][0]=2&amp;[][1]=3&amp;[a]=2&#039;);

        st.end();
    });

    t.test(&#039;stringifies non-string keys&#039;, function (st) {
        var actual = qs.stringify({ a: &#039;b&#039;, &#039;false&#039;: {} }, {
            filter: [&#039;a&#039;, false, null],
            allowDots: true,
            encodeDotInKeys: true
        });

        st.equal(actual, &#039;a=b&#039;, &#039;stringifies correctly&#039;);

        st.end();
    });
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
