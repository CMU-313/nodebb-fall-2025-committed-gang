<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/yoda.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/yoda.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">363</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">34.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.90</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to require or disallow yoda comparisons
 * @author Nicholas C. Zakas
 */
&quot;use strict&quot;;

//--------------------------------------------------------------------------
// Requirements
//--------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//--------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------

/**
 * Determines whether an operator is a comparison operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether or not it is a comparison operator.
 */
function isComparisonOperator(operator) {
	return /^(==|===|!=|!==|&lt;|&gt;|&lt;=|&gt;=)$/u.test(operator);
}

/**
 * Determines whether an operator is an equality operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether or not it is an equality operator.
 */
function isEqualityOperator(operator) {
	return /^(==|===)$/u.test(operator);
}

/**
 * Determines whether an operator is one used in a range test.
 * Allowed operators are `&lt;` and `&lt;=`.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether the operator is used in range tests.
 */
function isRangeTestOperator(operator) {
	return [&quot;&lt;&quot;, &quot;&lt;=&quot;].includes(operator);
}

/**
 * Determines whether a non-Literal node is a negative number that should be
 * treated as if it were a single Literal node.
 * @param {ASTNode} node Node to test.
 * @returns {boolean} True if the node is a negative number that looks like a
 *                    real literal and should be treated as such.
 */
function isNegativeNumericLiteral(node) {
	return (
		node.type === &quot;UnaryExpression&quot; &amp;&amp;
		node.operator === &quot;-&quot; &amp;&amp;
		node.prefix &amp;&amp;
		astUtils.isNumericLiteral(node.argument)
	);
}

/**
 * Determines whether a non-Literal node should be treated as a single Literal node.
 * @param {ASTNode} node Node to test
 * @returns {boolean} True if the node should be treated as a single Literal node.
 */
function looksLikeLiteral(node) {
	return (
		isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node)
	);
}

/**
 * Attempts to derive a Literal node from nodes that are treated like literals.
 * @param {ASTNode} node Node to normalize.
 * @returns {ASTNode} One of the following options.
 *  1. The original node if the node is already a Literal
 *  2. A normalized Literal node with the negative number as the value if the
 *     node represents a negative number literal.
 *  3. A normalized Literal node with the string as the value if the node is
 *     a Template Literal without expression.
 *  4. Otherwise `null`.
 */
function getNormalizedLiteral(node) {
	if (node.type === &quot;Literal&quot;) {
		return node;
	}

	if (isNegativeNumericLiteral(node)) {
		return {
			type: &quot;Literal&quot;,
			value: -node.argument.value,
			raw: `-${node.argument.value}`,
		};
	}

	if (astUtils.isStaticTemplateLiteral(node)) {
		return {
			type: &quot;Literal&quot;,
			value: node.quasis[0].value.cooked,
			raw: node.quasis[0].value.raw,
		};
	}

	return null;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		defaultOptions: [
			&quot;never&quot;,
			{
				exceptRange: false,
				onlyEquality: false,
			},
		],

		docs: {
			description: &#039;Require or disallow &quot;Yoda&quot; conditions&#039;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/yoda&quot;,
		},

		schema: [
			{
				enum: [&quot;always&quot;, &quot;never&quot;],
			},
			{
				type: &quot;object&quot;,
				properties: {
					exceptRange: {
						type: &quot;boolean&quot;,
					},
					onlyEquality: {
						type: &quot;boolean&quot;,
					},
				},
				additionalProperties: false,
			},
		],

		fixable: &quot;code&quot;,
		messages: {
			expected:
				&quot;Expected literal to be on the {{expectedSide}} side of {{operator}}.&quot;,
		},
	},

	create(context) {
		const [when, { exceptRange, onlyEquality }] = context.options;
		const always = when === &quot;always&quot;;
		const sourceCode = context.sourceCode;

		/**
		 * Determines whether node represents a range test.
		 * A range test is a &quot;between&quot; test like `(0 &lt;= x &amp;&amp; x &lt; 1)` or an &quot;outside&quot;
		 * test like `(x &lt; 0 || 1 &lt;= x)`. It must be wrapped in parentheses, and
		 * both operators must be `&lt;` or `&lt;=`. Finally, the literal on the left side
		 * must be less than or equal to the literal on the right side so that the
		 * test makes any sense.
		 * @param {ASTNode} node LogicalExpression node to test.
		 * @returns {boolean} Whether node is a range test.
		 */
		function isRangeTest(node) {
			const left = node.left,
				right = node.right;

			/**
			 * Determines whether node is of the form `0 &lt;= x &amp;&amp; x &lt; 1`.
			 * @returns {boolean} Whether node is a &quot;between&quot; range test.
			 */
			function isBetweenTest() {
				if (
					node.operator === &quot;&amp;&amp;&quot; &amp;&amp;
					astUtils.isSameReference(left.right, right.left)
				) {
					const leftLiteral = getNormalizedLiteral(left.left);
					const rightLiteral = getNormalizedLiteral(right.right);

					if (leftLiteral === null &amp;&amp; rightLiteral === null) {
						return false;
					}

					if (rightLiteral === null || leftLiteral === null) {
						return true;
					}

					if (leftLiteral.value &lt;= rightLiteral.value) {
						return true;
					}
				}
				return false;
			}

			/**
			 * Determines whether node is of the form `x &lt; 0 || 1 &lt;= x`.
			 * @returns {boolean} Whether node is an &quot;outside&quot; range test.
			 */
			function isOutsideTest() {
				if (
					node.operator === &quot;||&quot; &amp;&amp;
					astUtils.isSameReference(left.left, right.right)
				) {
					const leftLiteral = getNormalizedLiteral(left.right);
					const rightLiteral = getNormalizedLiteral(right.left);

					if (leftLiteral === null &amp;&amp; rightLiteral === null) {
						return false;
					}

					if (rightLiteral === null || leftLiteral === null) {
						return true;
					}

					if (leftLiteral.value &lt;= rightLiteral.value) {
						return true;
					}
				}

				return false;
			}

			/**
			 * Determines whether node is wrapped in parentheses.
			 * @returns {boolean} Whether node is preceded immediately by an open
			 *                    paren token and followed immediately by a close
			 *                    paren token.
			 */
			function isParenWrapped() {
				return astUtils.isParenthesised(sourceCode, node);
			}

			return (
				node.type === &quot;LogicalExpression&quot; &amp;&amp;
				left.type === &quot;BinaryExpression&quot; &amp;&amp;
				right.type === &quot;BinaryExpression&quot; &amp;&amp;
				isRangeTestOperator(left.operator) &amp;&amp;
				isRangeTestOperator(right.operator) &amp;&amp;
				(isBetweenTest() || isOutsideTest()) &amp;&amp;
				isParenWrapped()
			);
		}

		const OPERATOR_FLIP_MAP = {
			&quot;===&quot;: &quot;===&quot;,
			&quot;!==&quot;: &quot;!==&quot;,
			&quot;==&quot;: &quot;==&quot;,
			&quot;!=&quot;: &quot;!=&quot;,
			&quot;&lt;&quot;: &quot;&gt;&quot;,
			&quot;&gt;&quot;: &quot;&lt;&quot;,
			&quot;&lt;=&quot;: &quot;&gt;=&quot;,
			&quot;&gt;=&quot;: &quot;&lt;=&quot;,
		};

		/**
		 * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.
		 * @param {ASTNode} node The BinaryExpression node
		 * @returns {string} A string representation of the node with the sides and operator flipped
		 */
		function getFlippedString(node) {
			const operatorToken = sourceCode.getFirstTokenBetween(
				node.left,
				node.right,
				token =&gt; token.value === node.operator,
			);
			const lastLeftToken = sourceCode.getTokenBefore(operatorToken);
			const firstRightToken = sourceCode.getTokenAfter(operatorToken);

			const source = sourceCode.getText();

			const leftText = source.slice(
				node.range[0],
				lastLeftToken.range[1],
			);
			const textBeforeOperator = source.slice(
				lastLeftToken.range[1],
				operatorToken.range[0],
			);
			const textAfterOperator = source.slice(
				operatorToken.range[1],
				firstRightToken.range[0],
			);
			const rightText = source.slice(
				firstRightToken.range[0],
				node.range[1],
			);

			const tokenBefore = sourceCode.getTokenBefore(node);
			const tokenAfter = sourceCode.getTokenAfter(node);
			let prefix = &quot;&quot;;
			let suffix = &quot;&quot;;

			if (
				tokenBefore &amp;&amp;
				tokenBefore.range[1] === node.range[0] &amp;&amp;
				!astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)
			) {
				prefix = &quot; &quot;;
			}

			if (
				tokenAfter &amp;&amp;
				node.range[1] === tokenAfter.range[0] &amp;&amp;
				!astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)
			) {
				suffix = &quot; &quot;;
			}

			return (
				prefix +
				rightText +
				textBeforeOperator +
				OPERATOR_FLIP_MAP[operatorToken.value] +
				textAfterOperator +
				leftText +
				suffix
			);
		}

		//--------------------------------------------------------------------------
		// Public
		//--------------------------------------------------------------------------

		return {
			BinaryExpression(node) {
				const expectedLiteral = always ? node.left : node.right;
				const expectedNonLiteral = always ? node.right : node.left;

				// If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.
				if (
					(expectedNonLiteral.type === &quot;Literal&quot; ||
						looksLikeLiteral(expectedNonLiteral)) &amp;&amp;
					!(
						expectedLiteral.type === &quot;Literal&quot; ||
						looksLikeLiteral(expectedLiteral)
					) &amp;&amp;
					!(!isEqualityOperator(node.operator) &amp;&amp; onlyEquality) &amp;&amp;
					isComparisonOperator(node.operator) &amp;&amp;
					!(exceptRange &amp;&amp; isRangeTest(node.parent))
				) {
					context.report({
						node,
						messageId: &quot;expected&quot;,
						data: {
							operator: node.operator,
							expectedSide: always ? &quot;left&quot; : &quot;right&quot;,
						},
						fix: fixer =&gt;
							fixer.replaceText(node, getFlippedString(node)),
					});
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
