<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fill-range/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fill-range/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">249</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.80</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * fill-range &lt;https://github.com/jonschlinkert/fill-range&gt;
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */

&#039;use strict&#039;;

const util = require(&#039;util&#039;);
const toRegexRange = require(&#039;to-regex-range&#039;);

const isObject = val =&gt; val !== null &amp;&amp; typeof val === &#039;object&#039; &amp;&amp; !Array.isArray(val);

const transform = toNumber =&gt; {
  return value =&gt; toNumber === true ? Number(value) : String(value);
};

const isValidValue = value =&gt; {
  return typeof value === &#039;number&#039; || (typeof value === &#039;string&#039; &amp;&amp; value !== &#039;&#039;);
};

const isNumber = num =&gt; Number.isInteger(+num);

const zeros = input =&gt; {
  let value = `${input}`;
  let index = -1;
  if (value[0] === &#039;-&#039;) value = value.slice(1);
  if (value === &#039;0&#039;) return false;
  while (value[++index] === &#039;0&#039;);
  return index &gt; 0;
};

const stringify = (start, end, options) =&gt; {
  if (typeof start === &#039;string&#039; || typeof end === &#039;string&#039;) {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) =&gt; {
  if (maxLength &gt; 0) {
    let dash = input[0] === &#039;-&#039; ? &#039;-&#039; : &#039;&#039;;
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, &#039;0&#039;));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) =&gt; {
  let negative = input[0] === &#039;-&#039; ? &#039;-&#039; : &#039;&#039;;
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length &lt; maxLength) input = &#039;0&#039; + input;
  return negative ? (&#039;-&#039; + input) : input;
};

const toSequence = (parts, options, maxLen) =&gt; {
  parts.negatives.sort((a, b) =&gt; a &lt; b ? -1 : a &gt; b ? 1 : 0);
  parts.positives.sort((a, b) =&gt; a &lt; b ? -1 : a &gt; b ? 1 : 0);

  let prefix = options.capture ? &#039;&#039; : &#039;?:&#039;;
  let positives = &#039;&#039;;
  let negatives = &#039;&#039;;
  let result;

  if (parts.positives.length) {
    positives = parts.positives.map(v =&gt; toMaxLen(String(v), maxLen)).join(&#039;|&#039;);
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.map(v =&gt; toMaxLen(String(v), maxLen)).join(&#039;|&#039;)})`;
  }

  if (positives &amp;&amp; negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) =&gt; {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) =&gt; {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? &#039;&#039; : &#039;?:&#039;;
    return wrap ? `(${prefix}${start.join(&#039;|&#039;)})` : start.join(&#039;|&#039;);
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) =&gt; {
  return new RangeError(&#039;Invalid range arguments: &#039; + util.inspect(...args));
};

const invalidRange = (start, end, options) =&gt; {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) =&gt; {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step &quot;${step}&quot; to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) =&gt; {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a &gt; b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false &amp;&amp; stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex &amp;&amp; step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num =&gt; parts[num &lt; 0 ? &#039;negatives&#039; : &#039;positives&#039;].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a &gt;= b : a &lt;= b) {
    if (options.toRegex === true &amp;&amp; step &gt; 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step &gt; 1
      ? toSequence(parts, options, maxLen)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) =&gt; {
  if ((!isNumber(start) &amp;&amp; start.length &gt; 1) || (!isNumber(end) &amp;&amp; end.length &gt; 1)) {
    return invalidRange(start, end, options);
  }

  let format = options.transform || (val =&gt; String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a &gt; b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex &amp;&amp; step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a &gt;= b : a &lt;= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) =&gt; {
  if (end == null &amp;&amp; isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === &#039;function&#039;) {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null &amp;&amp; !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) &amp;&amp; isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
