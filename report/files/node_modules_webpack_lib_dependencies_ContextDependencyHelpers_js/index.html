<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">46.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">270</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">58.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.72</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { parseResource } = require(&quot;../util/identifier&quot;);

/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).ModuleOptionsNormalized} ModuleOptions */
/** @typedef {import(&quot;../Dependency&quot;).DependencyLocation} DependencyLocation */
/** @typedef {import(&quot;../javascript/BasicEvaluatedExpression&quot;)} BasicEvaluatedExpression */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;)} JavascriptParser */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).Range} Range */
/** @typedef {import(&quot;./ContextDependency&quot;)} ContextDependency */
/** @typedef {import(&quot;./ContextDependency&quot;).ContextDependencyOptions} ContextDependencyOptions */

/**
 * Escapes regular expression metacharacters
 * @param {string} str String to quote
 * @returns {string} Escaped string
 */
const quoteMeta = str =&gt; str.replace(/[-[\]\\/{}()*+?.^$|]/g, &quot;\\$&amp;&quot;);

/**
 * @param {string} prefix prefix
 * @returns {{prefix: string, context: string}} result
 */
const splitContextFromPrefix = prefix =&gt; {
	const idx = prefix.lastIndexOf(&quot;/&quot;);
	let context = &quot;.&quot;;
	if (idx &gt;= 0) {
		context = prefix.slice(0, idx);
		prefix = `.${prefix.slice(idx)}`;
	}
	return {
		context,
		prefix
	};
};

/** @typedef {Partial&lt;Omit&lt;ContextDependencyOptions, &quot;resource&quot;&gt;&gt;} PartialContextDependencyOptions */
/** @typedef {{ new(options: ContextDependencyOptions, range: Range, valueRange: Range, ...args: any[]): ContextDependency }} ContextDependencyConstructor */

/**
 * @param {ContextDependencyConstructor} Dep the Dependency class
 * @param {Range} range source range
 * @param {BasicEvaluatedExpression} param context param
 * @param {Expression} expr expr
 * @param {Pick&lt;JavascriptParserOptions, `${&quot;expr&quot;|&quot;wrapped&quot;}Context${&quot;Critical&quot;|&quot;Recursive&quot;|&quot;RegExp&quot;}` | &quot;exprContextRequest&quot;&gt;} options options for context creation
 * @param {PartialContextDependencyOptions} contextOptions options for the ContextModule
 * @param {JavascriptParser} parser the parser
 * @param {...EXPECTED_ANY} depArgs depArgs
 * @returns {ContextDependency} the created Dependency
 */
module.exports.create = (
	Dep,
	range,
	param,
	expr,
	options,
	contextOptions,
	parser,
	...depArgs
) =&gt; {
	if (param.isTemplateString()) {
		const quasis = /** @type {BasicEvaluatedExpression[]} */ (param.quasis);
		const prefixRaw = /** @type {string} */ (quasis[0].string);
		const postfixRaw =
			/** @type {string} */
			(quasis.length &gt; 1 ? quasis[quasis.length - 1].string : &quot;&quot;);

		const valueRange = /** @type {Range} */ (param.range);
		const { context, prefix } = splitContextFromPrefix(prefixRaw);
		const {
			path: postfix,
			query,
			fragment
		} = parseResource(postfixRaw, parser);

		// When there are more than two quasis, the generated RegExp can be more precise
		// We join the quasis with the expression regexp
		const innerQuasis = quasis.slice(1, -1);
		const innerRegExp =
			/** @type {RegExp} */ (options.wrappedContextRegExp).source +
			innerQuasis
				.map(
					q =&gt;
						quoteMeta(/** @type {string} */ (q.string)) +
						/** @type {RegExp} */ (options.wrappedContextRegExp).source
				)
				.join(&quot;&quot;);

		// Example: `./context/pre${e}inner${e}inner2${e}post?query#frag`
		// context: &quot;./context&quot;
		// prefix: &quot;./pre&quot;
		// innerQuasis: [BEE(&quot;inner&quot;), BEE(&quot;inner2&quot;)]
		// (BEE = BasicEvaluatedExpression)
		// postfix: &quot;post&quot;
		// query: &quot;?query&quot;
		// fragment: &quot;#frag&quot;
		// regExp: /^\.\/pre.*inner.*inner2.*post$/
		const regExp = new RegExp(
			`^${quoteMeta(prefix)}${innerRegExp}${quoteMeta(postfix)}$`
		);
		const dep = new Dep(
			{
				request: context + query + fragment,
				recursive: /** @type {boolean} */ (options.wrappedContextRecursive),
				regExp,
				mode: &quot;sync&quot;,
				...contextOptions
			},
			range,
			valueRange,
			...depArgs
		);
		dep.loc = /** @type {DependencyLocation} */ (expr.loc);

		/** @type {{ value: string, range: Range }[]} */
		const replaces = [];
		const parts = /** @type {BasicEvaluatedExpression[]} */ (param.parts);

		for (const [i, part] of parts.entries()) {
			if (i % 2 === 0) {
				// Quasis or merged quasi
				let range = /** @type {Range} */ (part.range);
				let value = /** @type {string} */ (part.string);
				if (param.templateStringKind === &quot;cooked&quot;) {
					value = JSON.stringify(value);
					value = value.slice(1, -1);
				}
				if (i === 0) {
					// prefix
					value = prefix;
					range = [
						/** @type {Range} */ (param.range)[0],
						/** @type {Range} */ (part.range)[1]
					];
					value =
						(param.templateStringKind === &quot;cooked&quot; ? &quot;`&quot; : &quot;String.raw`&quot;) +
						value;
				} else if (i === parts.length - 1) {
					// postfix
					value = postfix;
					range = [
						/** @type {Range} */ (part.range)[0],
						/** @type {Range} */ (param.range)[1]
					];
					value = `${value}\``;
				} else if (
					part.expression &amp;&amp;
					part.expression.type === &quot;TemplateElement&quot; &amp;&amp;
					part.expression.value.raw === value
				) {
					// Shortcut when it&#039;s a single quasi and doesn&#039;t need to be replaced
					continue;
				}
				replaces.push({
					range,
					value
				});
			} else {
				// Expression
				parser.walkExpression(
					/** @type {Expression} */
					(part.expression)
				);
			}
		}

		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &amp;&amp;
			&quot;a part of the request of a dependency is an expression&quot;;
		return dep;
	} else if (
		param.isWrapped() &amp;&amp;
		((param.prefix &amp;&amp; param.prefix.isString()) ||
			(param.postfix &amp;&amp; param.postfix.isString()))
	) {
		const prefixRaw =
			/** @type {string} */
			(param.prefix &amp;&amp; param.prefix.isString() ? param.prefix.string : &quot;&quot;);
		const postfixRaw =
			/** @type {string} */
			(param.postfix &amp;&amp; param.postfix.isString() ? param.postfix.string : &quot;&quot;);
		const prefixRange =
			param.prefix &amp;&amp; param.prefix.isString() ? param.prefix.range : null;
		const postfixRange =
			param.postfix &amp;&amp; param.postfix.isString() ? param.postfix.range : null;
		const valueRange = /** @type {Range} */ (param.range);
		const { context, prefix } = splitContextFromPrefix(prefixRaw);
		const {
			path: postfix,
			query,
			fragment
		} = parseResource(postfixRaw, parser);
		const regExp = new RegExp(
			`^${quoteMeta(prefix)}${
				/** @type {RegExp} */ (options.wrappedContextRegExp).source
			}${quoteMeta(postfix)}$`
		);
		const dep = new Dep(
			{
				request: context + query + fragment,
				recursive: /** @type {boolean} */ (options.wrappedContextRecursive),
				regExp,
				mode: &quot;sync&quot;,
				...contextOptions
			},
			range,
			valueRange,
			...depArgs
		);
		dep.loc = /** @type {DependencyLocation} */ (expr.loc);
		const replaces = [];
		if (prefixRange) {
			replaces.push({
				range: prefixRange,
				value: JSON.stringify(prefix)
			});
		}
		if (postfixRange) {
			replaces.push({
				range: postfixRange,
				value: JSON.stringify(postfix)
			});
		}
		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &amp;&amp;
			&quot;a part of the request of a dependency is an expression&quot;;

		if (parser &amp;&amp; param.wrappedInnerExpressions) {
			for (const part of param.wrappedInnerExpressions) {
				if (part.expression)
					parser.walkExpression(
						/** @type {Expression} */
						(part.expression)
					);
			}
		}

		return dep;
	}
	const dep = new Dep(
		{
			request: /** @type {string} */ (options.exprContextRequest),
			recursive: /** @type {boolean} */ (options.exprContextRecursive),
			regExp: /** @type {RegExp} */ (options.exprContextRegExp),
			mode: &quot;sync&quot;,
			...contextOptions
		},
		range,
		/** @type {Range} */ (param.range),
		...depArgs
	);
	dep.loc = /** @type {DependencyLocation} */ (expr.loc);
	dep.critical =
		options.exprContextCritical &amp;&amp;
		&quot;the request of a dependency is an expression&quot;;

	parser.walkExpression(/** @type {Expression} */ (param.expression));

	return dep;
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
