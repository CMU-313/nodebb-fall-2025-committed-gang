<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/build/SignedData.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/build/SignedData.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1114</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">111.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.57</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;); } }; }();

var _asn1js = require(&quot;asn1js&quot;);

var asn1js = _interopRequireWildcard(_asn1js);

var _pvutils = require(&quot;pvutils&quot;);

var _common = require(&quot;./common.js&quot;);

var _AlgorithmIdentifier = require(&quot;./AlgorithmIdentifier.js&quot;);

var _AlgorithmIdentifier2 = _interopRequireDefault(_AlgorithmIdentifier);

var _EncapsulatedContentInfo = require(&quot;./EncapsulatedContentInfo.js&quot;);

var _EncapsulatedContentInfo2 = _interopRequireDefault(_EncapsulatedContentInfo);

var _Certificate = require(&quot;./Certificate.js&quot;);

var _Certificate2 = _interopRequireDefault(_Certificate);

var _CertificateRevocationList = require(&quot;./CertificateRevocationList.js&quot;);

var _CertificateRevocationList2 = _interopRequireDefault(_CertificateRevocationList);

var _OtherRevocationInfoFormat = require(&quot;./OtherRevocationInfoFormat.js&quot;);

var _OtherRevocationInfoFormat2 = _interopRequireDefault(_OtherRevocationInfoFormat);

var _SignerInfo = require(&quot;./SignerInfo.js&quot;);

var _SignerInfo2 = _interopRequireDefault(_SignerInfo);

var _CertificateSet = require(&quot;./CertificateSet.js&quot;);

var _CertificateSet2 = _interopRequireDefault(_CertificateSet);

var _RevocationInfoChoices = require(&quot;./RevocationInfoChoices.js&quot;);

var _RevocationInfoChoices2 = _interopRequireDefault(_RevocationInfoChoices);

var _IssuerAndSerialNumber = require(&quot;./IssuerAndSerialNumber.js&quot;);

var _IssuerAndSerialNumber2 = _interopRequireDefault(_IssuerAndSerialNumber);

var _TSTInfo = require(&quot;./TSTInfo.js&quot;);

var _TSTInfo2 = _interopRequireDefault(_TSTInfo);

var _CertificateChainValidationEngine = require(&quot;./CertificateChainValidationEngine.js&quot;);

var _CertificateChainValidationEngine2 = _interopRequireDefault(_CertificateChainValidationEngine);

var _BasicOCSPResponse = require(&quot;./BasicOCSPResponse.js&quot;);

var _BasicOCSPResponse2 = _interopRequireDefault(_BasicOCSPResponse);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//**************************************************************************************
/**
 * Class from RFC5652
 */
class SignedData {
	//**********************************************************************************
	/**
  * Constructor for SignedData class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {number}
   * @description version
   */
		this.version = (0, _pvutils.getParametersValue)(parameters, &quot;version&quot;, SignedData.defaultValues(&quot;version&quot;));
		/**
   * @type {Array.&lt;AlgorithmIdentifier&gt;}
   * @description digestAlgorithms
   */
		this.digestAlgorithms = (0, _pvutils.getParametersValue)(parameters, &quot;digestAlgorithms&quot;, SignedData.defaultValues(&quot;digestAlgorithms&quot;));
		/**
   * @type {EncapsulatedContentInfo}
   * @description encapContentInfo
   */
		this.encapContentInfo = (0, _pvutils.getParametersValue)(parameters, &quot;encapContentInfo&quot;, SignedData.defaultValues(&quot;encapContentInfo&quot;));

		if (&quot;certificates&quot; in parameters)
			/**
    * @type {Array.&lt;Certificate|OtherCertificateFormat&gt;}
    * @description certificates
    */
			this.certificates = (0, _pvutils.getParametersValue)(parameters, &quot;certificates&quot;, SignedData.defaultValues(&quot;certificates&quot;));

		if (&quot;crls&quot; in parameters)
			/**
    * @type {Array.&lt;CertificateRevocationList|OtherRevocationInfoFormat&gt;}
    * @description crls
    */
			this.crls = (0, _pvutils.getParametersValue)(parameters, &quot;crls&quot;, SignedData.defaultValues(&quot;crls&quot;));

		if (&quot;ocsps&quot; in parameters)
			/**
    * @type {Array.&lt;BasicOCSPResponse&gt;}
    * @description crls
    */
			this.ocsps = (0, _pvutils.getParametersValue)(parameters, &quot;ocsps&quot;, SignedData.defaultValues(&quot;ocsps&quot;));

		/**
   * @type {Array.&lt;SignerInfo&gt;}
   * @description signerInfos
   */
		this.signerInfos = (0, _pvutils.getParametersValue)(parameters, &quot;signerInfos&quot;, SignedData.defaultValues(&quot;signerInfos&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;version&quot;:
				return 0;
			case &quot;digestAlgorithms&quot;:
				return [];
			case &quot;encapContentInfo&quot;:
				return new _EncapsulatedContentInfo2.default();
			case &quot;certificates&quot;:
				return [];
			case &quot;crls&quot;:
				return [];
			case &quot;ocsps&quot;:
				return [];
			case &quot;signerInfos&quot;:
				return [];
			default:
				throw new Error(`Invalid member name for SignedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Compare values with default values for all class members
  * @param {string} memberName String name for a class member
  * @param {*} memberValue Value to compare with default value
  */
	static compareWithDefault(memberName, memberValue) {
		switch (memberName) {
			case &quot;version&quot;:
				return memberValue === SignedData.defaultValues(&quot;version&quot;);
			case &quot;encapContentInfo&quot;:
				return new _EncapsulatedContentInfo2.default();
			case &quot;digestAlgorithms&quot;:
			case &quot;certificates&quot;:
			case &quot;crls&quot;:
			case &quot;ocsps&quot;:
			case &quot;signerInfos&quot;:
				return memberValue.length === 0;
			default:
				throw new Error(`Invalid member name for SignedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		//SignedData ::= SEQUENCE {
		//    version CMSVersion,
		//    digestAlgorithms DigestAlgorithmIdentifiers,
		//    encapContentInfo EncapsulatedContentInfo,
		//    certificates [0] IMPLICIT CertificateSet OPTIONAL,
		//    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
		//    signerInfos SignerInfos }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [optional]
   * @property {string} [digestAlgorithms]
   * @property {string} [encapContentInfo]
   * @property {string} [certificates]
   * @property {string} [crls]
   * @property {string} [signerInfos]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		if (&quot;optional&quot; in names === false) names.optional = false;

		return new asn1js.Sequence({
			name: names.blockName || &quot;SignedData&quot;,
			optional: names.optional,
			value: [new asn1js.Integer({ name: names.version || &quot;SignedData.version&quot; }), new asn1js.Set({
				value: [new asn1js.Repeated({
					name: names.digestAlgorithms || &quot;SignedData.digestAlgorithms&quot;,
					value: _AlgorithmIdentifier2.default.schema()
				})]
			}), _EncapsulatedContentInfo2.default.schema(names.encapContentInfo || {
				names: {
					blockName: &quot;SignedData.encapContentInfo&quot;
				}
			}), new asn1js.Constructed({
				name: names.certificates || &quot;SignedData.certificates&quot;,
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: _CertificateSet2.default.schema().valueBlock.value
			}), // IMPLICIT CertificateSet
			new asn1js.Constructed({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: _RevocationInfoChoices2.default.schema(names.crls || {
					names: {
						crls: &quot;SignedData.crls&quot;
					}
				}).valueBlock.value
			}), // IMPLICIT RevocationInfoChoices
			new asn1js.Set({
				value: [new asn1js.Repeated({
					name: names.signerInfos || &quot;SignedData.signerInfos&quot;,
					value: _SignerInfo2.default.schema()
				})]
			})]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;SignedData.version&quot;, &quot;SignedData.digestAlgorithms&quot;, &quot;SignedData.encapContentInfo&quot;, &quot;SignedData.certificates&quot;, &quot;SignedData.crls&quot;, &quot;SignedData.signerInfos&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, SignedData.schema());

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for SignedData&quot;);
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result[&quot;SignedData.version&quot;].valueBlock.valueDec;

		if (&quot;SignedData.digestAlgorithms&quot; in asn1.result) // Could be empty SET of digest algorithms
			this.digestAlgorithms = Array.from(asn1.result[&quot;SignedData.digestAlgorithms&quot;], algorithm =&gt; new _AlgorithmIdentifier2.default({ schema: algorithm }));

		this.encapContentInfo = new _EncapsulatedContentInfo2.default({ schema: asn1.result[&quot;SignedData.encapContentInfo&quot;] });

		if (&quot;SignedData.certificates&quot; in asn1.result) {
			const certificateSet = new _CertificateSet2.default({
				schema: new asn1js.Set({
					value: asn1.result[&quot;SignedData.certificates&quot;].valueBlock.value
				})
			});
			this.certificates = certificateSet.certificates.slice(0); // Copy all just for making comfortable access
		}

		if (&quot;SignedData.crls&quot; in asn1.result) {
			this.crls = Array.from(asn1.result[&quot;SignedData.crls&quot;], crl =&gt; {
				if (crl.idBlock.tagClass === 1) return new _CertificateRevocationList2.default({ schema: crl });

				//region Create SEQUENCE from [1]
				crl.idBlock.tagClass = 1; // UNIVERSAL
				crl.idBlock.tagNumber = 16; // SEQUENCE
				//endregion

				return new _OtherRevocationInfoFormat2.default({ schema: crl });
			});
		}

		if (&quot;SignedData.signerInfos&quot; in asn1.result) // Could be empty SET SignerInfos
			this.signerInfos = Array.from(asn1.result[&quot;SignedData.signerInfos&quot;], signerInfoSchema =&gt; new _SignerInfo2.default({ schema: signerInfoSchema }));
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema(encodeFlag = false) {
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js.Integer({ value: this.version }));

		//region Create array of digest algorithms
		outputArray.push(new asn1js.Set({
			value: Array.from(this.digestAlgorithms, algorithm =&gt; algorithm.toSchema(encodeFlag))
		}));
		//endregion

		outputArray.push(this.encapContentInfo.toSchema());

		if (&quot;certificates&quot; in this) {
			const certificateSet = new _CertificateSet2.default({ certificates: this.certificates });
			const certificateSetSchema = certificateSet.toSchema();

			outputArray.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3,
					tagNumber: 0
				},
				value: certificateSetSchema.valueBlock.value
			}));
		}

		if (&quot;crls&quot; in this) {
			outputArray.push(new asn1js.Constructed({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.crls, crl =&gt; {
					if (crl instanceof _OtherRevocationInfoFormat2.default) {
						const crlSchema = crl.toSchema(encodeFlag);

						crlSchema.idBlock.tagClass = 3;
						crlSchema.idBlock.tagNumber = 1;

						return crlSchema;
					}

					return crl.toSchema(encodeFlag);
				})
			}));
		}

		//region Create array of signer infos
		outputArray.push(new asn1js.Set({
			value: Array.from(this.signerInfos, signerInfo =&gt; signerInfo.toSchema(encodeFlag))
		}));
		//endregion
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return new asn1js.Sequence({
			value: outputArray
		});
		//endregion
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		const _object = {
			version: this.version,
			digestAlgorithms: Array.from(this.digestAlgorithms, algorithm =&gt; algorithm.toJSON()),
			encapContentInfo: this.encapContentInfo.toJSON()
		};

		if (&quot;certificates&quot; in this) _object.certificates = Array.from(this.certificates, certificate =&gt; certificate.toJSON());

		if (&quot;crls&quot; in this) _object.crls = Array.from(this.crls, crl =&gt; crl.toJSON());

		_object.signerInfos = Array.from(this.signerInfos, signerInfo =&gt; signerInfo.toJSON());

		return _object;
	}
	//**********************************************************************************
	/**
  * Verify current SignedData value
  * @param signer
  * @param data
  * @param trustedCerts
  * @param checkDate
  * @param checkChain
  * @param includeSignerCertificate
  * @param extendedMode
  * @param findOrigin
  * @param findIssuer
  * @returns {*}
  */
	verify({
		signer = -1,
		data = new ArrayBuffer(0),
		trustedCerts = [],
		checkDate = new Date(),
		checkChain = false,
		extendedMode = false,
		findOrigin = null,
		findIssuer = null
	} = {}) {
		//region Global variables
		let sequence = Promise.resolve();

		let messageDigestValue = new ArrayBuffer(0);

		let shaAlgorithm = &quot;&quot;;

		let signerCertificate = {};

		let timestampSerial = null;

		let certificatePath = [];

		const engine = (0, _common.getEngine)();
		//endregion

		//region Get a &quot;crypto&quot; extension
		const crypto = (0, _common.getCrypto)();
		if (typeof crypto === &quot;undefined&quot;) return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion

		//region Get a signer number
		if (signer === -1) {
			if (extendedMode) {
				return Promise.reject({
					date: checkDate,
					code: 1,
					message: &quot;Unable to get signer index from input parameters&quot;,
					signatureVerified: null,
					signerCertificate: null,
					signerCertificateVerified: null
				});
			}

			return Promise.reject(&quot;Unable to get signer index from input parameters&quot;);
		}
		//endregion

		//region Check that certificates field was included in signed data
		if (&quot;certificates&quot; in this === false) {
			if (extendedMode) {
				return Promise.reject({
					date: checkDate,
					code: 2,
					message: &quot;No certificates attached to this signed data&quot;,
					signatureVerified: null,
					signerCertificate: null,
					signerCertificateVerified: null
				});
			}

			return Promise.reject(&quot;No certificates attached to this signed data&quot;);
		}
		//endregion

		//region Find a certificate for specified signer
		if (this.signerInfos[signer].sid instanceof _IssuerAndSerialNumber2.default) {
			sequence = sequence.then(() =&gt; {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.certificates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						const certificate = _step.value;

						if (certificate instanceof _Certificate2.default === false) continue;

						if (certificate.issuer.isEqual(this.signerInfos[signer].sid.issuer) &amp;&amp; certificate.serialNumber.isEqual(this.signerInfos[signer].sid.serialNumber)) {
							signerCertificate = certificate;
							return Promise.resolve();
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				if (extendedMode) {
					return Promise.reject({
						date: checkDate,
						code: 3,
						message: &quot;Unable to find signer certificate&quot;,
						signatureVerified: null,
						signerCertificate: null,
						signerCertificateVerified: null
					});
				}

				return Promise.reject(&quot;Unable to find signer certificate&quot;);
			});
		} else // Find by SubjectKeyIdentifier
			{
				sequence = sequence.then(() =&gt; Promise.all(Array.from(this.certificates.filter(certificate =&gt; certificate instanceof _Certificate2.default), certificate =&gt; crypto.digest({ name: &quot;sha-1&quot; }, new Uint8Array(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results =&gt; {
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = this.certificates.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							const _ref = _step2.value;

							var _ref2 = _slicedToArray(_ref, 2);

							const index = _ref2[0];
							const certificate = _ref2[1];

							if (certificate instanceof _Certificate2.default === false) continue;

							if ((0, _pvutils.isEqualBuffer)(results[index], this.signerInfos[signer].sid.valueBlock.valueHex)) {
								signerCertificate = certificate;
								return Promise.resolve();
							}
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 3,
							message: &quot;Unable to find signer certificate&quot;,
							signatureVerified: null,
							signerCertificate: null,
							signerCertificateVerified: null
						});
					}

					return Promise.reject(&quot;Unable to find signer certificate&quot;);
				}, () =&gt; {
					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 3,
							message: &quot;Unable to find signer certificate&quot;,
							signatureVerified: null,
							signerCertificate: null,
							signerCertificateVerified: null
						});
					}

					return Promise.reject(&quot;Unable to find signer certificate&quot;);
				}));
			}
		//endregion

		//region Verify internal digest in case of &quot;tSTInfo&quot; content type
		sequence = sequence.then(() =&gt; {
			if (this.encapContentInfo.eContentType === &quot;1.2.840.113549.1.9.16.1.4&quot;) {
				//region Check &quot;eContent&quot; precense
				if (&quot;eContent&quot; in this.encapContentInfo === false) return false;
				//endregion

				//region Initialize TST_INFO value
				const asn1 = asn1js.fromBER(this.encapContentInfo.eContent.valueBlock.valueHex);
				let tstInfo;

				try {
					tstInfo = new _TSTInfo2.default({ schema: asn1.result });
				} catch (ex) {
					return false;
				}
				//endregion

				//region Change &quot;checkDate&quot; and append &quot;timestampSerial&quot;
				checkDate = tstInfo.genTime;
				timestampSerial = tstInfo.serialNumber.valueBlock.valueHex;
				//endregion

				//region Check that we do have detached data content
				if (data.byteLength === 0) {
					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 4,
							message: &quot;Missed detached data input array&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: null
						});
					}

					return Promise.reject(&quot;Missed detached data input array&quot;);
				}
				//endregion

				return tstInfo.verify({ data });
			}

			return true;
		});
		//endregion

		//region Make additional verification for signer&#039;s certificate
		function checkCA(cert) {
			/// &lt;param name=&quot;cert&quot; type=&quot;in_window.org.pkijs.simpl.CERT&quot;&gt;Certificate to find CA flag for&lt;/param&gt;

			//region Do not include signer&#039;s certificate
			if (cert.issuer.isEqual(signerCertificate.issuer) === true &amp;&amp; cert.serialNumber.isEqual(signerCertificate.serialNumber) === true) return null;
			//endregion

			let isCA = false;

			if (&quot;extensions&quot; in cert) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = cert.extensions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						const extension = _step3.value;

						if (extension.extnID === &quot;2.5.29.19&quot;) // BasicConstraints
							{
								if (&quot;cA&quot; in extension.parsedValue) {
									if (extension.parsedValue.cA === true) isCA = true;
								}
							}
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}

			if (isCA) return cert;

			return null;
		}

		if (checkChain) {
			sequence = sequence.then(result =&gt; {
				//region Verify result of previous operation
				if (result === false) return false;
				//endregion

				const promiseResults = Array.from(this.certificates.filter(certificate =&gt; certificate instanceof _Certificate2.default), certificate =&gt; checkCA(certificate));

				const certificateChainValidationEngineParameters = {
					checkDate,
					certs: Array.from(promiseResults.filter(_result =&gt; _result !== null)),
					trustedCerts
				};

				if (findIssuer !== null) certificateChainValidationEngineParameters.findIssuer = findIssuer;

				if (findOrigin !== null) certificateChainValidationEngineParameters.findOrigin = findOrigin;

				const certificateChainEngine = new _CertificateChainValidationEngine2.default(certificateChainValidationEngineParameters);

				certificateChainEngine.certs.push(signerCertificate);

				if (&quot;crls&quot; in this) {
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = this.crls[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							const crl = _step4.value;

							if (crl instanceof _CertificateRevocationList2.default) certificateChainEngine.crls.push(crl);else // Assumed &quot;revocation value&quot; has &quot;OtherRevocationInfoFormat&quot;
								{
									if (crl.otherRevInfoFormat === &quot;1.3.6.1.5.5.7.48.1.1&quot;) // Basic OCSP response
										certificateChainEngine.ocsps.push(new _BasicOCSPResponse2.default({ schema: crl.otherRevInfo }));
								}
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}

				if (&quot;ocsps&quot; in this) certificateChainEngine.ocsps.push(...this.ocsps);

				return certificateChainEngine.verify().then(verificationResult =&gt; {
					if (&quot;certificatePath&quot; in verificationResult) certificatePath = verificationResult.certificatePath;

					if (verificationResult.result === true) return Promise.resolve(true);

					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 5,
							message: `Validation of signer&#039;s certificate failed: ${verificationResult.resultMessage}`,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: false
						});
					}

					return Promise.reject(&quot;Validation of signer&#039;s certificate failed&quot;);
				}, error =&gt; {
					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 5,
							message: `Validation of signer&#039;s certificate failed with error: ${error instanceof Object ? error.resultMessage : error}`,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: false
						});
					}

					return Promise.reject(`Validation of signer&#039;s certificate failed with error: ${error instanceof Object ? error.resultMessage : error}`);
				});
			});
		}
		//endregion

		//region Find signer&#039;s hashing algorithm
		sequence = sequence.then(result =&gt; {
			//region Verify result of previous operation
			if (result === false) return false;
			//endregion

			const signerInfoHashAlgorithm = (0, _common.getAlgorithmByOID)(this.signerInfos[signer].digestAlgorithm.algorithmId);
			if (&quot;name&quot; in signerInfoHashAlgorithm === false) {
				if (extendedMode) {
					return Promise.reject({
						date: checkDate,
						code: 7,
						message: `Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`,
						signatureVerified: null,
						signerCertificate,
						signerCertificateVerified: true
					});
				}

				return Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`);
			}

			shaAlgorithm = signerInfoHashAlgorithm.name;

			return true;
		});
		//endregion

		//region Create correct data block for verification
		sequence = sequence.then(result =&gt; {
			//region Verify result of previous operation
			if (result === false) return false;
			//endregion

			if (&quot;eContent&quot; in this.encapContentInfo) // Attached data
				{
					if (this.encapContentInfo.eContent.idBlock.tagClass === 1 &amp;&amp; this.encapContentInfo.eContent.idBlock.tagNumber === 4) {
						if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;else {
							var _iteratorNormalCompletion5 = true;
							var _didIteratorError5 = false;
							var _iteratorError5 = undefined;

							try {
								for (var _iterator5 = this.encapContentInfo.eContent.valueBlock.value[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
									const contentValue = _step5.value;

									data = (0, _pvutils.utilConcatBuf)(data, contentValue.valueBlock.valueHex);
								}
							} catch (err) {
								_didIteratorError5 = true;
								_iteratorError5 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) {
										_iterator5.return();
									}
								} finally {
									if (_didIteratorError5) {
										throw _iteratorError5;
									}
								}
							}
						}
					} else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
				} else // Detached data
				{
					if (data.byteLength === 0) // Check that &quot;data&quot; already provided by function parameter
						{
							if (extendedMode) {
								return Promise.reject({
									date: checkDate,
									code: 8,
									message: &quot;Missed detached data input array&quot;,
									signatureVerified: null,
									signerCertificate,
									signerCertificateVerified: true
								});
							}

							return Promise.reject(&quot;Missed detached data input array&quot;);
						}
				}

			if (&quot;signedAttrs&quot; in this.signerInfos[signer]) {
				//region Check mandatory attributes
				let foundContentType = false;
				let foundMessageDigest = false;

				var _iteratorNormalCompletion6 = true;
				var _didIteratorError6 = false;
				var _iteratorError6 = undefined;

				try {
					for (var _iterator6 = this.signerInfos[signer].signedAttrs.attributes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
						const attribute = _step6.value;

						//region Check that &quot;content-type&quot; attribute exists
						if (attribute.type === &quot;1.2.840.113549.1.9.3&quot;) foundContentType = true;
						//endregion

						//region Check that &quot;message-digest&quot; attribute exists
						if (attribute.type === &quot;1.2.840.113549.1.9.4&quot;) {
							foundMessageDigest = true;
							messageDigestValue = attribute.values[0].valueBlock.valueHex;
						}
						//endregion

						//region Speed-up searching
						if (foundContentType &amp;&amp; foundMessageDigest) break;
						//endregion
					}
				} catch (err) {
					_didIteratorError6 = true;
					_iteratorError6 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion6 &amp;&amp; _iterator6.return) {
							_iterator6.return();
						}
					} finally {
						if (_didIteratorError6) {
							throw _iteratorError6;
						}
					}
				}

				if (foundContentType === false) {
					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 9,
							message: &quot;Attribute \&quot;content-type\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}

					return Promise.reject(&quot;Attribute \&quot;content-type\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;);
				}

				if (foundMessageDigest === false) {
					if (extendedMode) {
						return Promise.reject({
							date: checkDate,
							code: 10,
							message: &quot;Attribute \&quot;message-digest\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}

					return Promise.reject(&quot;Attribute \&quot;message-digest\&quot; is a mandatory attribute for \&quot;signed attributes\&quot;&quot;);
				}
				//endregion
			}

			return true;
		});
		//endregion

		//region Verify &quot;message-digest&quot; attribute in case of &quot;signedAttrs&quot;
		sequence = sequence.then(result =&gt; {
			//region Verify result of previous operation
			if (result === false) return false;
			//endregion

			if (&quot;signedAttrs&quot; in this.signerInfos[signer]) return crypto.digest(shaAlgorithm, new Uint8Array(data));

			return true;
		}).then(
		/**
   * @param {ArrayBuffer} result
   */
		result =&gt; {
			//region Verify result of previous operation
			if (result === false) return false;
			//endregion

			if (&quot;signedAttrs&quot; in this.signerInfos[signer]) {
				if ((0, _pvutils.isEqualBuffer)(result, messageDigestValue)) {
					data = this.signerInfos[signer].signedAttrs.encodedValue;
					return true;
				}

				return false;
			}

			return true;
		});
		//endregion

		sequence = sequence.then(result =&gt; {
			//region Verify result of previous operation
			if (result === false) return false;
			//endregion

			return engine.subtle.verifyWithPublicKey(data, this.signerInfos[signer].signature, signerCertificate.subjectPublicKeyInfo, signerCertificate.signatureAlgorithm, shaAlgorithm);
		});

		//region Make a final result
		sequence = sequence.then(result =&gt; {
			if (extendedMode) {
				return {
					date: checkDate,
					code: 14,
					message: &quot;&quot;,
					signatureVerified: result,
					signerCertificate,
					timestampSerial,
					signerCertificateVerified: true,
					certificatePath
				};
			}

			return result;
		}, error =&gt; {
			if (extendedMode) {
				if (&quot;code&quot; in error) return Promise.reject(error);

				return Promise.reject({
					date: checkDate,
					code: 15,
					message: `Error during verification: ${error.message}`,
					signatureVerified: null,
					signerCertificate,
					timestampSerial,
					signerCertificateVerified: true
				});
			}

			return Promise.reject(error);
		});
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
  * Signing current SignedData
  * @param {key} privateKey Private key for &quot;subjectPublicKeyInfo&quot; structure
  * @param {number} signerIndex Index number (starting from 0) of signer index to make signature for
  * @param {string} [hashAlgorithm=&quot;SHA-1&quot;] Hashing algorithm. Default SHA-1
  * @param {ArrayBuffer} [data] Detached data
  * @returns {*}
  */
	sign(privateKey, signerIndex, hashAlgorithm = &quot;SHA-1&quot;, data = new ArrayBuffer(0)) {
		//region Initial checking
		if (typeof privateKey === &quot;undefined&quot;) return Promise.reject(&quot;Need to provide a private key for signing&quot;);
		//endregion

		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;

		const engine = (0, _common.getEngine)();
		//endregion

		//region Simple check for supported algorithm
		const hashAlgorithmOID = (0, _common.getOIDByAlgorithm)({ name: hashAlgorithm });
		if (hashAlgorithmOID === &quot;&quot;) return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
		//endregion

		//region Append information about hash algorithm
		if (this.digestAlgorithms.filter(algorithm =&gt; algorithm.algorithmId === hashAlgorithmOID).length === 0) {
			this.digestAlgorithms.push(new _AlgorithmIdentifier2.default({
				algorithmId: hashAlgorithmOID,
				algorithmParams: new asn1js.Null()
			}));
		}

		this.signerInfos[signerIndex].digestAlgorithm = new _AlgorithmIdentifier2.default({
			algorithmId: hashAlgorithmOID,
			algorithmParams: new asn1js.Null()
		});
		//endregion

		//region Get a &quot;default parameters&quot; for current algorithm and set correct signature algorithm
		sequence = sequence.then(() =&gt; engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));

		sequence = sequence.then(result =&gt; {
			parameters = result.parameters;
			this.signerInfos[signerIndex].signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion

		//region Create TBS data for signing
		sequence = sequence.then(() =&gt; {
			if (&quot;signedAttrs&quot; in this.signerInfos[signerIndex]) {
				if (this.signerInfos[signerIndex].signedAttrs.encodedValue.byteLength !== 0) data = this.signerInfos[signerIndex].signedAttrs.encodedValue;else {
					data = this.signerInfos[signerIndex].signedAttrs.toSchema(true).toBER(false);

					//region Change type from &quot;[0]&quot; to &quot;SET&quot; acordingly to standard
					const view = new Uint8Array(data);
					view[0] = 0x31;
					//endregion
				}
			} else {
				if (&quot;eContent&quot; in this.encapContentInfo) // Attached data
					{
						if (this.encapContentInfo.eContent.idBlock.tagClass === 1 &amp;&amp; this.encapContentInfo.eContent.idBlock.tagNumber === 4) {
							if (this.encapContentInfo.eContent.idBlock.isConstructed === false) data = this.encapContentInfo.eContent.valueBlock.valueHex;else {
								var _iteratorNormalCompletion7 = true;
								var _didIteratorError7 = false;
								var _iteratorError7 = undefined;

								try {
									for (var _iterator7 = this.encapContentInfo.eContent.valueBlock.value[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
										const content = _step7.value;

										data = (0, _pvutils.utilConcatBuf)(data, content.valueBlock.valueHex);
									}
								} catch (err) {
									_didIteratorError7 = true;
									_iteratorError7 = err;
								} finally {
									try {
										if (!_iteratorNormalCompletion7 &amp;&amp; _iterator7.return) {
											_iterator7.return();
										}
									} finally {
										if (_didIteratorError7) {
											throw _iteratorError7;
										}
									}
								}
							}
						} else data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
					} else // Detached data
					{
						if (data.byteLength === 0) // Check that &quot;data&quot; already provided by function parameter
							return Promise.reject(&quot;Missed detached data input array&quot;);
					}
			}

			return Promise.resolve();
		});
		//endregion

		//region Signing TBS data on provided private key
		sequence = sequence.then(() =&gt; engine.subtle.signWithPrivateKey(data, privateKey, parameters));

		sequence = sequence.then(result =&gt; {
			this.signerInfos[signerIndex].signature = new asn1js.OctetString({ valueHex: result });

			return result;
		});
		//endregion

		return sequence;
	}
	//**********************************************************************************
}
exports.default = SignedData; //**************************************************************************************
//# sourceMappingURL=SignedData.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
