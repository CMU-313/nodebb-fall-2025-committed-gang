<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@bufbuild/protobuf/dist/esm/reflect/path.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@bufbuild/protobuf/dist/esm/reflect/path.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">370</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.71</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ScalarType, } from &quot;../descriptors.js&quot;;
/**
 * Create a PathBuilder.
 */
export function buildPath(schema) {
    return new PathBuilderImpl(schema, schema, []);
}
/**
 * Parse a Path from a string.
 *
 * Throws an InvalidPathError if the path is invalid.
 *
 * Note that a Registry must be provided via the options argument to parse
 * paths that refer to an extension.
 */
export function parsePath(schema, path, options) {
    var _a, _b;
    const builder = new PathBuilderImpl(schema, schema, []);
    const err = (message, i) =&gt; new InvalidPathError(schema, message + &quot; at column &quot; + (i + 1), path);
    for (let i = 0; i &lt; path.length;) {
        const token = nextToken(i, path);
        const left = builder.getLeft();
        let right = undefined;
        if (&quot;field&quot; in token) {
            right =
                (left === null || left === void 0 ? void 0 : left.kind) != &quot;message&quot;
                    ? undefined
                    : ((_a = left.fields.find((field) =&gt; field.name === token.field)) !== null &amp;&amp; _a !== void 0 ? _a : left.oneofs.find((oneof) =&gt; oneof.name === token.field));
            if (!right) {
                throw err(`Unknown field &quot;${token.field}&quot;`, i);
            }
        }
        else if (&quot;ext&quot; in token) {
            right = (_b = options === null || options === void 0 ? void 0 : options.registry) === null || _b === void 0 ? void 0 : _b.getExtension(token.ext);
            if (!right) {
                throw err(`Unknown extension &quot;${token.ext}&quot;`, i);
            }
        }
        else if (&quot;val&quot; in token) {
            // list or map
            right =
                (left === null || left === void 0 ? void 0 : left.kind) == &quot;field&quot; &amp;&amp;
                    left.fieldKind == &quot;list&quot; &amp;&amp;
                    typeof token.val == &quot;bigint&quot;
                    ? { kind: &quot;list_sub&quot;, index: Number(token.val) }
                    : { kind: &quot;map_sub&quot;, key: token.val };
        }
        else if (&quot;err&quot; in token) {
            throw err(token.err, token.i);
        }
        if (right) {
            try {
                builder.add([right]);
            }
            catch (e) {
                throw err(e instanceof InvalidPathError ? e.message : String(e), i);
            }
        }
        i = token.i;
    }
    return builder.toPath();
}
/**
 * Stringify a path.
 */
export function pathToString(path) {
    const str = [];
    for (const ele of path) {
        switch (ele.kind) {
            case &quot;field&quot;:
            case &quot;oneof&quot;:
                if (str.length &gt; 0) {
                    str.push(&quot;.&quot;);
                }
                str.push(ele.name);
                break;
            case &quot;extension&quot;:
                str.push(&quot;[&quot;, ele.typeName, &quot;]&quot;);
                break;
            case &quot;list_sub&quot;:
                str.push(&quot;[&quot;, ele.index, &quot;]&quot;);
                break;
            case &quot;map_sub&quot;:
                if (typeof ele.key == &quot;string&quot;) {
                    str.push(&#039;[&quot;&#039;, ele.key
                        .split(&quot;\\&quot;)
                        .join(&quot;\\\\&quot;)
                        .split(&#039;&quot;&#039;)
                        .join(&#039;\\&quot;&#039;)
                        .split(&quot;\r&quot;)
                        .join(&quot;\\r&quot;)
                        .split(&quot;\n&quot;)
                        .join(&quot;\\n&quot;), &#039;&quot;]&#039;);
                }
                else {
                    str.push(&quot;[&quot;, ele.key, &quot;]&quot;);
                }
                break;
        }
    }
    return str.join(&quot;&quot;);
}
/**
 * InvalidPathError is thrown for invalid Paths, for example during parsing from
 * a string, or when a new Path is built.
 */
export class InvalidPathError extends Error {
    constructor(schema, message, path) {
        super(message);
        this.name = &quot;InvalidPathError&quot;;
        this.schema = schema;
        this.path = path;
        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
class PathBuilderImpl {
    constructor(schema, left, path) {
        this.schema = schema;
        this.left = left;
        this.path = path;
    }
    getLeft() {
        return this.left;
    }
    field(field) {
        return this.push(field);
    }
    oneof(oneof) {
        return this.push(oneof);
    }
    extension(extension) {
        return this.push(extension);
    }
    list(index) {
        return this.push({ kind: &quot;list_sub&quot;, index });
    }
    map(key) {
        return this.push({ kind: &quot;map_sub&quot;, key });
    }
    add(pathOrBuilder) {
        const path = Array.isArray(pathOrBuilder)
            ? pathOrBuilder
            : pathOrBuilder.toPath();
        const l = this.path.length;
        try {
            for (const ele of path) {
                this.push(ele);
            }
        }
        catch (e) {
            // undo pushes
            this.path.splice(l);
            throw e;
        }
        return this;
    }
    toPath() {
        return this.path.concat();
    }
    clone() {
        return new PathBuilderImpl(this.schema, this.left, this.path.concat());
    }
    push(ele) {
        switch (ele.kind) {
            case &quot;field&quot;:
                if (!this.left ||
                    this.left.kind != &quot;message&quot; ||
                    this.left.typeName != ele.parent.typeName) {
                    throw this.err(&quot;field access&quot;);
                }
                this.path.push(ele);
                this.left =
                    ele.fieldKind == &quot;message&quot;
                        ? ele.message
                        : ele.fieldKind == &quot;list&quot; || ele.fieldKind == &quot;map&quot;
                            ? ele
                            : undefined;
                return this;
            case &quot;oneof&quot;:
                if (!this.left ||
                    this.left.kind != &quot;message&quot; ||
                    this.left.typeName != ele.parent.typeName) {
                    throw this.err(&quot;oneof access&quot;);
                }
                this.path.push(ele);
                this.left = undefined;
                return this;
            case &quot;extension&quot;:
                if (!this.left ||
                    this.left.kind != &quot;message&quot; ||
                    this.left.typeName != ele.extendee.typeName) {
                    throw this.err(&quot;extension access&quot;);
                }
                this.path.push(ele);
                this.left = ele.fieldKind == &quot;message&quot; ? ele.message : undefined;
                return this;
            case &quot;list_sub&quot;:
                if (!this.left ||
                    this.left.kind != &quot;field&quot; ||
                    this.left.fieldKind != &quot;list&quot;) {
                    throw this.err(&quot;list access&quot;);
                }
                if (ele.index &lt; 0 || !Number.isInteger(ele.index)) {
                    throw this.err(&quot;list index&quot;);
                }
                this.path.push(ele);
                this.left =
                    this.left.listKind == &quot;message&quot; ? this.left.message : undefined;
                return this;
            case &quot;map_sub&quot;:
                if (!this.left ||
                    this.left.kind != &quot;field&quot; ||
                    this.left.fieldKind != &quot;map&quot;) {
                    throw this.err(&quot;map access&quot;);
                }
                if (!checkKeyType(ele.key, this.left.mapKey)) {
                    throw this.err(&quot;map key&quot;);
                }
                this.path.push(ele);
                this.left =
                    this.left.mapKind == &quot;message&quot; ? this.left.message : undefined;
                return this;
        }
    }
    err(what) {
        return new InvalidPathError(this.schema, &quot;Invalid &quot; + what, this.path);
    }
}
function checkKeyType(key, type) {
    switch (type) {
        case ScalarType.STRING:
            return typeof key == &quot;string&quot;;
        case ScalarType.INT32:
        case ScalarType.UINT32:
        case ScalarType.SINT32:
        case ScalarType.SFIXED32:
        case ScalarType.FIXED32:
            return typeof key == &quot;number&quot;;
        case ScalarType.UINT64:
        case ScalarType.INT64:
        case ScalarType.FIXED64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
            return typeof key == &quot;bigint&quot;;
        case ScalarType.BOOL:
            return typeof key == &quot;boolean&quot;;
    }
}
function nextToken(i, path) {
    const re_extension = /^[A-Za-z_][A-Za-z_0-9]*(?:\.[A-Za-z_][A-Za-z_0-9]*)*$/;
    const re_field = /^[A-Za-z_][A-Za-z_0-9]*$/;
    if (path[i] == &quot;[&quot;) {
        i++;
        while (path[i] == &quot; &quot;) {
            // skip leading whitespace
            i++;
        }
        if (i &gt;= path.length) {
            return { err: &quot;Premature end&quot;, i: path.length - 1 };
        }
        let token;
        if (path[i] == `&quot;`) {
            // string literal
            i++;
            let val = &quot;&quot;;
            for (;;) {
                if (path[i] == `&quot;`) {
                    // end of string literal
                    i++;
                    break;
                }
                if (path[i] == &quot;\\&quot;) {
                    switch (path[i + 1]) {
                        case `&quot;`:
                        case &quot;\\&quot;:
                            val += path[i + 1];
                            break;
                        case &quot;r&quot;:
                            val += &quot;\r&quot;;
                            break;
                        case &quot;n&quot;:
                            val += &quot;\n&quot;;
                            break;
                        default:
                            return { err: &quot;Invalid escape sequence&quot;, i };
                    }
                    i++;
                }
                else {
                    val += path[i];
                }
                if (i &gt;= path.length) {
                    return { err: &quot;Premature end of string&quot;, i: path.length - 1 };
                }
                i++;
            }
            token = { val };
        }
        else if (path[i].match(/\d/)) {
            // integer literal
            const start = i;
            while (i &lt; path.length &amp;&amp; /\d/.test(path[i])) {
                i++;
            }
            token = { val: BigInt(path.substring(start, i)) };
        }
        else if (path[i] == &quot;]&quot;) {
            return { err: &quot;Premature ]&quot;, i };
        }
        else {
            // extension identifier or bool literal
            const start = i;
            while (i &lt; path.length &amp;&amp; path[i] != &quot; &quot; &amp;&amp; path[i] != &quot;]&quot;) {
                i++;
            }
            const name = path.substring(start, i);
            if (name === &quot;true&quot;) {
                token = { val: true };
            }
            else if (name === &quot;false&quot;) {
                token = { val: false };
            }
            else if (re_extension.test(name)) {
                token = { ext: name };
            }
            else {
                return { err: &quot;Invalid ident&quot;, i: start };
            }
        }
        while (path[i] == &quot; &quot;) {
            // skip trailing whitespace
            i++;
        }
        if (path[i] != &quot;]&quot;) {
            return { err: &quot;Missing ]&quot;, i };
        }
        i++;
        return Object.assign(Object.assign({}, token), { i });
    }
    // field identifier
    if (i &gt; 0) {
        if (path[i] != &quot;.&quot;) {
            return { err: `Expected &quot;.&quot;`, i };
        }
        i++;
    }
    const start = i;
    while (i &lt; path.length &amp;&amp; path[i] != &quot;.&quot; &amp;&amp; path[i] != &quot;[&quot;) {
        i++;
    }
    const field = path.substring(start, i);
    return re_field.test(field)
        ? { field, i }
        : { err: &quot;Invalid ident&quot;, i: start };
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
