<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/NormalModuleFactory.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/NormalModuleFactory.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.35</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1332</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">84.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.48</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { getContext } = require(&quot;loader-runner&quot;);
const asyncLib = require(&quot;neo-async&quot;);
const {
	AsyncSeriesBailHook,
	SyncWaterfallHook,
	SyncBailHook,
	SyncHook,
	HookMap
} = require(&quot;tapable&quot;);
const ChunkGraph = require(&quot;./ChunkGraph&quot;);
const Module = require(&quot;./Module&quot;);
const ModuleFactory = require(&quot;./ModuleFactory&quot;);
const ModuleGraph = require(&quot;./ModuleGraph&quot;);
const { JAVASCRIPT_MODULE_TYPE_AUTO } = require(&quot;./ModuleTypeConstants&quot;);
const NormalModule = require(&quot;./NormalModule&quot;);
const BasicEffectRulePlugin = require(&quot;./rules/BasicEffectRulePlugin&quot;);
const BasicMatcherRulePlugin = require(&quot;./rules/BasicMatcherRulePlugin&quot;);
const ObjectMatcherRulePlugin = require(&quot;./rules/ObjectMatcherRulePlugin&quot;);
const RuleSetCompiler = require(&quot;./rules/RuleSetCompiler&quot;);
const UseEffectRulePlugin = require(&quot;./rules/UseEffectRulePlugin&quot;);
const LazySet = require(&quot;./util/LazySet&quot;);
const { getScheme } = require(&quot;./util/URLAbsoluteSpecifier&quot;);
const { cachedCleverMerge, cachedSetProperty } = require(&quot;./util/cleverMerge&quot;);
const { join } = require(&quot;./util/fs&quot;);
const {
	parseResource,
	parseResourceWithoutFragment
} = require(&quot;./util/identifier&quot;);

/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).ModuleOptionsNormalized} ModuleOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).RuleSetRule} RuleSetRule */
/** @typedef {import(&quot;./Generator&quot;)} Generator */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryCallback} ModuleFactoryCallback */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryCreateData} ModuleFactoryCreateData */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryCreateDataContextInfo} ModuleFactoryCreateDataContextInfo */
/** @typedef {import(&quot;./ModuleFactory&quot;).ModuleFactoryResult} ModuleFactoryResult */
/** @typedef {import(&quot;./NormalModule&quot;).GeneratorOptions} GeneratorOptions */
/** @typedef {import(&quot;./NormalModule&quot;).LoaderItem} LoaderItem */
/** @typedef {import(&quot;./NormalModule&quot;).NormalModuleCreateData} NormalModuleCreateData */
/** @typedef {import(&quot;./NormalModule&quot;).ParserOptions} ParserOptions */
/** @typedef {import(&quot;./Parser&quot;)} Parser */
/** @typedef {import(&quot;./ResolverFactory&quot;)} ResolverFactory */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolveContext} ResolveContext */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolveRequest} ResolveRequest */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolverWithOptions} ResolverWithOptions */
/** @typedef {import(&quot;./dependencies/ModuleDependency&quot;)} ModuleDependency */
/** @typedef {import(&quot;./javascript/JavascriptParser&quot;).ImportAttributes} ImportAttributes */
/** @typedef {import(&quot;./rules/RuleSetCompiler&quot;).RuleSetRules} RuleSetRules */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/** @typedef {import(&quot;./util/identifier&quot;).AssociatedObjectForCache} AssociatedObjectForCache */

/** @typedef {Pick&lt;RuleSetRule, &#039;type&#039; | &#039;sideEffects&#039; | &#039;parser&#039; | &#039;generator&#039; | &#039;resolve&#039; | &#039;layer&#039;&gt;} ModuleSettings */
/** @typedef {Partial&lt;NormalModuleCreateData &amp; { settings: ModuleSettings }&gt;} CreateData */

/**
 * @typedef {object} ResolveData
 * @property {ModuleFactoryCreateData[&quot;contextInfo&quot;]} contextInfo
 * @property {ModuleFactoryCreateData[&quot;resolveOptions&quot;]} resolveOptions
 * @property {string} context
 * @property {string} request
 * @property {ImportAttributes | undefined} assertions
 * @property {ModuleDependency[]} dependencies
 * @property {string} dependencyType
 * @property {CreateData} createData
 * @property {LazySet&lt;string&gt;} fileDependencies
 * @property {LazySet&lt;string&gt;} missingDependencies
 * @property {LazySet&lt;string&gt;} contextDependencies
 * @property {Module=} ignoredModule
 * @property {boolean} cacheable allow to use the unsafe cache
 */

/**
 * @typedef {object} ResourceData
 * @property {string} resource
 * @property {string=} path
 * @property {string=} query
 * @property {string=} fragment
 * @property {string=} context
 */

/** @typedef {ResourceData &amp; { data: Record&lt;string, EXPECTED_ANY&gt; }} ResourceDataWithData */

/**
 * @typedef {object} ParsedLoaderRequest
 * @property {string} loader loader
 * @property {string|undefined} options options
 */

/**
 * @template T
 * @callback Callback
 * @param {(Error | null)=} err
 * @param {T=} stats
 * @returns {void}
 */

const EMPTY_RESOLVE_OPTIONS = {};
/** @type {ParserOptions} */
const EMPTY_PARSER_OPTIONS = {};
/** @type {GeneratorOptions} */
const EMPTY_GENERATOR_OPTIONS = {};
/** @type {ParsedLoaderRequest[]} */
const EMPTY_ELEMENTS = [];

const MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;
const LEADING_DOT_EXTENSION_REGEX = /^[^.]/;

/**
 * @param {LoaderItem} data data
 * @returns {string} ident
 */
const loaderToIdent = data =&gt; {
	if (!data.options) {
		return data.loader;
	}
	if (typeof data.options === &quot;string&quot;) {
		return `${data.loader}?${data.options}`;
	}
	if (typeof data.options !== &quot;object&quot;) {
		throw new Error(&quot;loader options must be string or object&quot;);
	}
	if (data.ident) {
		return `${data.loader}??${data.ident}`;
	}
	return `${data.loader}?${JSON.stringify(data.options)}`;
};

/**
 * @param {LoaderItem[]} loaders loaders
 * @param {string} resource resource
 * @returns {string} stringified loaders and resource
 */
const stringifyLoadersAndResource = (loaders, resource) =&gt; {
	let str = &quot;&quot;;
	for (const loader of loaders) {
		str += `${loaderToIdent(loader)}!`;
	}
	return str + resource;
};

/**
 * @param {number} times times
 * @param {(err?: null | Error) =&gt; void} callback callback
 * @returns {(err?: null | Error) =&gt; void} callback
 */
const needCalls = (times, callback) =&gt; err =&gt; {
	if (--times === 0) {
		return callback(err);
	}
	if (err &amp;&amp; times &gt; 0) {
		times = Number.NaN;
		return callback(err);
	}
};

/**
 * @template T
 * @template O
 * @param {T} globalOptions global options
 * @param {string} type type
 * @param {O} localOptions local options
 * @returns {T &amp; O | T | O} result
 */
const mergeGlobalOptions = (globalOptions, type, localOptions) =&gt; {
	const parts = type.split(&quot;/&quot;);
	let result;
	let current = &quot;&quot;;
	for (const part of parts) {
		current = current ? `${current}/${part}` : part;
		const options =
			/** @type {T} */
			(globalOptions[/** @type {keyof T} */ (current)]);
		if (typeof options === &quot;object&quot;) {
			result =
				result === undefined ? options : cachedCleverMerge(result, options);
		}
	}
	if (result === undefined) {
		return localOptions;
	}
	return cachedCleverMerge(result, localOptions);
};

// TODO webpack 6 remove
/**
 * @template {import(&quot;tapable&quot;).Hook&lt;EXPECTED_ANY, EXPECTED_ANY&gt;} T
 * @param {string} name name
 * @param {T} hook hook
 * @returns {string} result
 */
const deprecationChangedHookMessage = (name, hook) =&gt; {
	const names = hook.taps.map(tapped =&gt; tapped.name).join(&quot;, &quot;);

	return (
		`NormalModuleFactory.${name} (${names}) is no longer a waterfall hook, but a bailing hook instead. ` +
		&quot;Do not return the passed object, but modify it instead. &quot; +
		&quot;Returning false will ignore the request and results in no module created.&quot;
	);
};

const ruleSetCompiler = new RuleSetCompiler([
	new BasicMatcherRulePlugin(&quot;test&quot;, &quot;resource&quot;),
	new BasicMatcherRulePlugin(&quot;scheme&quot;),
	new BasicMatcherRulePlugin(&quot;mimetype&quot;),
	new BasicMatcherRulePlugin(&quot;dependency&quot;),
	new BasicMatcherRulePlugin(&quot;include&quot;, &quot;resource&quot;),
	new BasicMatcherRulePlugin(&quot;exclude&quot;, &quot;resource&quot;, true),
	new BasicMatcherRulePlugin(&quot;resource&quot;),
	new BasicMatcherRulePlugin(&quot;resourceQuery&quot;),
	new BasicMatcherRulePlugin(&quot;resourceFragment&quot;),
	new BasicMatcherRulePlugin(&quot;realResource&quot;),
	new BasicMatcherRulePlugin(&quot;issuer&quot;),
	new BasicMatcherRulePlugin(&quot;compiler&quot;),
	new BasicMatcherRulePlugin(&quot;issuerLayer&quot;),
	new ObjectMatcherRulePlugin(&quot;assert&quot;, &quot;assertions&quot;, value =&gt; {
		if (value) {
			return (
				/** @type {ImportAttributes} */ (value)._isLegacyAssert !== undefined
			);
		}

		return false;
	}),
	new ObjectMatcherRulePlugin(&quot;with&quot;, &quot;assertions&quot;, value =&gt; {
		if (value) {
			return !(/** @type {ImportAttributes} */ (value)._isLegacyAssert);
		}
		return false;
	}),
	new ObjectMatcherRulePlugin(&quot;descriptionData&quot;),
	new BasicEffectRulePlugin(&quot;type&quot;),
	new BasicEffectRulePlugin(&quot;sideEffects&quot;),
	new BasicEffectRulePlugin(&quot;parser&quot;),
	new BasicEffectRulePlugin(&quot;resolve&quot;),
	new BasicEffectRulePlugin(&quot;generator&quot;),
	new BasicEffectRulePlugin(&quot;layer&quot;),
	new UseEffectRulePlugin()
]);

class NormalModuleFactory extends ModuleFactory {
	/**
	 * @param {object} param params
	 * @param {string=} param.context context
	 * @param {InputFileSystem} param.fs file system
	 * @param {ResolverFactory} param.resolverFactory resolverFactory
	 * @param {ModuleOptions} param.options options
	 * @param {AssociatedObjectForCache} param.associatedObjectForCache an object to which the cache will be attached
	 * @param {boolean=} param.layers enable layers
	 */
	constructor({
		context,
		fs,
		resolverFactory,
		options,
		associatedObjectForCache,
		layers = false
	}) {
		super();
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesBailHook&lt;[ResolveData], Module | false | void&gt;} */
			resolve: new AsyncSeriesBailHook([&quot;resolveData&quot;]),
			/** @type {HookMap&lt;AsyncSeriesBailHook&lt;[ResourceDataWithData, ResolveData], true | void&gt;&gt;} */
			resolveForScheme: new HookMap(
				() =&gt; new AsyncSeriesBailHook([&quot;resourceData&quot;, &quot;resolveData&quot;])
			),
			/** @type {HookMap&lt;AsyncSeriesBailHook&lt;[ResourceDataWithData, ResolveData], true | void&gt;&gt;} */
			resolveInScheme: new HookMap(
				() =&gt; new AsyncSeriesBailHook([&quot;resourceData&quot;, &quot;resolveData&quot;])
			),
			/** @type {AsyncSeriesBailHook&lt;[ResolveData], Module | undefined&gt;} */
			factorize: new AsyncSeriesBailHook([&quot;resolveData&quot;]),
			/** @type {AsyncSeriesBailHook&lt;[ResolveData], false | void&gt;} */
			beforeResolve: new AsyncSeriesBailHook([&quot;resolveData&quot;]),
			/** @type {AsyncSeriesBailHook&lt;[ResolveData], false | void&gt;} */
			afterResolve: new AsyncSeriesBailHook([&quot;resolveData&quot;]),
			/** @type {AsyncSeriesBailHook&lt;[CreateData, ResolveData], Module | void&gt;} */
			createModule: new AsyncSeriesBailHook([&quot;createData&quot;, &quot;resolveData&quot;]),
			/** @type {SyncWaterfallHook&lt;[Module, CreateData, ResolveData]&gt;} */
			module: new SyncWaterfallHook([&quot;module&quot;, &quot;createData&quot;, &quot;resolveData&quot;]),
			/** @type {HookMap&lt;SyncBailHook&lt;[ParserOptions], Parser | void&gt;&gt;} */
			createParser: new HookMap(() =&gt; new SyncBailHook([&quot;parserOptions&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[TODO, ParserOptions], void&gt;&gt;} */
			parser: new HookMap(() =&gt; new SyncHook([&quot;parser&quot;, &quot;parserOptions&quot;])),
			/** @type {HookMap&lt;SyncBailHook&lt;[GeneratorOptions], Generator | void&gt;&gt;} */
			createGenerator: new HookMap(
				() =&gt; new SyncBailHook([&quot;generatorOptions&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[TODO, GeneratorOptions], void&gt;&gt;} */
			generator: new HookMap(
				() =&gt; new SyncHook([&quot;generator&quot;, &quot;generatorOptions&quot;])
			),
			/** @type {HookMap&lt;SyncBailHook&lt;[TODO, ResolveData], Module | void&gt;&gt;} */
			createModuleClass: new HookMap(
				() =&gt; new SyncBailHook([&quot;createData&quot;, &quot;resolveData&quot;])
			)
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = ruleSetCompiler.compile([
			{
				rules: /** @type {RuleSetRules} */ (options.defaultRules)
			},
			{
				rules: /** @type {RuleSetRules} */ (options.rules)
			}
		]);
		this.context = context || &quot;&quot;;
		this.fs = fs;
		this._globalParserOptions = options.parser;
		this._globalGeneratorOptions = options.generator;
		/** @type {Map&lt;string, WeakMap&lt;ParserOptions, Parser&gt;&gt;} */
		this.parserCache = new Map();
		/** @type {Map&lt;string, WeakMap&lt;GeneratorOptions, Generator&gt;&gt;} */
		this.generatorCache = new Map();
		/** @type {Set&lt;Module&gt;} */
		this._restoredUnsafeCacheEntries = new Set();

		const cacheParseResource = parseResource.bindCache(
			associatedObjectForCache
		);
		const cachedParseResourceWithoutFragment =
			parseResourceWithoutFragment.bindCache(associatedObjectForCache);
		this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment;

		this.hooks.factorize.tapAsync(
			{
				name: &quot;NormalModuleFactory&quot;,
				stage: 100
			},
			(resolveData, callback) =&gt; {
				this.hooks.resolve.callAsync(resolveData, (err, result) =&gt; {
					if (err) return callback(err);

					// Ignored
					if (result === false) return callback();

					// direct module
					if (result instanceof Module) return callback(null, result);

					if (typeof result === &quot;object&quot;)
						throw new Error(
							`${deprecationChangedHookMessage(
								&quot;resolve&quot;,
								this.hooks.resolve
							)} Returning a Module object will result in this module used as result.`
						);

					this.hooks.afterResolve.callAsync(resolveData, (err, result) =&gt; {
						if (err) return callback(err);

						if (typeof result === &quot;object&quot;)
							throw new Error(
								deprecationChangedHookMessage(
									&quot;afterResolve&quot;,
									this.hooks.afterResolve
								)
							);

						// Ignored
						if (result === false) return callback();

						const createData = resolveData.createData;

						this.hooks.createModule.callAsync(
							createData,
							resolveData,
							(err, createdModule) =&gt; {
								if (!createdModule) {
									if (!resolveData.request) {
										return callback(new Error(&quot;Empty dependency (no request)&quot;));
									}

									// TODO webpack 6 make it required and move javascript/wasm/asset properties to own module
									createdModule = this.hooks.createModuleClass
										.for(
											/** @type {ModuleSettings} */
											(createData.settings).type
										)
										.call(createData, resolveData);

									if (!createdModule) {
										createdModule = /** @type {Module} */ (
											new NormalModule(
												/** @type {NormalModuleCreateData} */
												(createData)
											)
										);
									}
								}

								createdModule = this.hooks.module.call(
									createdModule,
									createData,
									resolveData
								);

								return callback(null, createdModule);
							}
						);
					});
				});
			}
		);
		this.hooks.resolve.tapAsync(
			{
				name: &quot;NormalModuleFactory&quot;,
				stage: 100
			},
			(data, callback) =&gt; {
				const {
					contextInfo,
					context,
					dependencies,
					dependencyType,
					request,
					assertions,
					resolveOptions,
					fileDependencies,
					missingDependencies,
					contextDependencies
				} = data;
				const loaderResolver = this.getResolver(&quot;loader&quot;);

				/** @type {ResourceData | undefined} */
				let matchResourceData;
				/** @type {string} */
				let unresolvedResource;
				/** @type {ParsedLoaderRequest[]} */
				let elements;
				let noPreAutoLoaders = false;
				let noAutoLoaders = false;
				let noPrePostAutoLoaders = false;

				const contextScheme = getScheme(context);
				/** @type {string | undefined} */
				let scheme = getScheme(request);

				if (!scheme) {
					/** @type {string} */
					let requestWithoutMatchResource = request;
					const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
					if (matchResourceMatch) {
						let matchResource = matchResourceMatch[1];
						if (matchResource.charCodeAt(0) === 46) {
							// 46 === &quot;.&quot;, 47 === &quot;/&quot;
							const secondChar = matchResource.charCodeAt(1);
							if (
								secondChar === 47 ||
								(secondChar === 46 &amp;&amp; matchResource.charCodeAt(2) === 47)
							) {
								// if matchResources startsWith ../ or ./
								matchResource = join(this.fs, context, matchResource);
							}
						}

						matchResourceData = {
							resource: matchResource,
							.../** @type {TODO} */ (cacheParseResource(matchResource))
						};
						requestWithoutMatchResource = request.slice(
							matchResourceMatch[0].length
						);
					}

					scheme = getScheme(requestWithoutMatchResource);

					if (!scheme &amp;&amp; !contextScheme) {
						const firstChar = requestWithoutMatchResource.charCodeAt(0);
						const secondChar = requestWithoutMatchResource.charCodeAt(1);
						noPreAutoLoaders = firstChar === 45 &amp;&amp; secondChar === 33; // startsWith &quot;-!&quot;
						noAutoLoaders = noPreAutoLoaders || firstChar === 33; // startsWith &quot;!&quot;
						noPrePostAutoLoaders = firstChar === 33 &amp;&amp; secondChar === 33; // startsWith &quot;!!&quot;;
						const rawElements = requestWithoutMatchResource
							.slice(
								noPreAutoLoaders || noPrePostAutoLoaders
									? 2
									: noAutoLoaders
										? 1
										: 0
							)
							.split(/!+/);
						unresolvedResource = /** @type {string} */ (rawElements.pop());
						elements = rawElements.map(el =&gt; {
							const { path, query } = cachedParseResourceWithoutFragment(el);
							return {
								loader: path,
								options: query ? query.slice(1) : undefined
							};
						});
						scheme = getScheme(unresolvedResource);
					} else {
						unresolvedResource = requestWithoutMatchResource;
						elements = EMPTY_ELEMENTS;
					}
				} else {
					unresolvedResource = request;
					elements = EMPTY_ELEMENTS;
				}

				/** @type {ResolveContext} */
				const resolveContext = {
					fileDependencies,
					missingDependencies,
					contextDependencies
				};

				/** @type {ResourceDataWithData} */
				let resourceData;

				/** @type {undefined | LoaderItem[]} */
				let loaders;

				const continueCallback = needCalls(2, err =&gt; {
					if (err) return callback(err);

					// translate option idents
					try {
						for (const item of /** @type {LoaderItem[]} */ (loaders)) {
							if (typeof item.options === &quot;string&quot; &amp;&amp; item.options[0] === &quot;?&quot;) {
								const ident = item.options.slice(1);
								if (ident === &quot;[[missing ident]]&quot;) {
									throw new Error(
										&quot;No ident is provided by referenced loader. &quot; +
											&quot;When using a function for Rule.use in config you need to &quot; +
											&quot;provide an &#039;ident&#039; property for referenced loader options.&quot;
									);
								}
								item.options = this.ruleSet.references.get(ident);
								if (item.options === undefined) {
									throw new Error(
										&quot;Invalid ident is provided by referenced loader&quot;
									);
								}
								item.ident = ident;
							}
						}
					} catch (identErr) {
						return callback(/** @type {Error} */ (identErr));
					}

					if (!resourceData) {
						// ignored
						return callback(
							null,
							/** @type {TODO} */
							(dependencies[0].createIgnoredModule(context))
						);
					}

					const userRequest =
						(matchResourceData !== undefined
							? `${matchResourceData.resource}!=!`
							: &quot;&quot;) +
						stringifyLoadersAndResource(
							/** @type {LoaderItem[]} */ (loaders),
							resourceData.resource
						);

					/** @type {ModuleSettings} */
					const settings = {};
					const useLoadersPost = [];
					const useLoaders = [];
					const useLoadersPre = [];

					// handle .webpack[] suffix
					let resource;
					let match;
					if (
						matchResourceData &amp;&amp;
						typeof (resource = matchResourceData.resource) === &quot;string&quot; &amp;&amp;
						(match = /\.webpack\[([^\]]+)\]$/.exec(resource))
					) {
						settings.type = match[1];
						matchResourceData.resource = matchResourceData.resource.slice(
							0,
							-settings.type.length - 10
						);
					} else {
						settings.type = JAVASCRIPT_MODULE_TYPE_AUTO;
						const resourceDataForRules = matchResourceData || resourceData;
						const result = this.ruleSet.exec({
							resource: resourceDataForRules.path,
							realResource: resourceData.path,
							resourceQuery: resourceDataForRules.query,
							resourceFragment: resourceDataForRules.fragment,
							scheme,
							assertions,
							mimetype: matchResourceData
								? &quot;&quot;
								: resourceData.data.mimetype || &quot;&quot;,
							dependency: dependencyType,
							descriptionData: matchResourceData
								? undefined
								: resourceData.data.descriptionFileData,
							issuer: contextInfo.issuer,
							compiler: contextInfo.compiler,
							issuerLayer: contextInfo.issuerLayer || &quot;&quot;
						});
						for (const r of result) {
							// https://github.com/webpack/webpack/issues/16466
							// if a request exists PrePostAutoLoaders, should disable modifying Rule.type
							if (r.type === &quot;type&quot; &amp;&amp; noPrePostAutoLoaders) {
								continue;
							}
							if (r.type === &quot;use&quot;) {
								if (!noAutoLoaders &amp;&amp; !noPrePostAutoLoaders) {
									useLoaders.push(r.value);
								}
							} else if (r.type === &quot;use-post&quot;) {
								if (!noPrePostAutoLoaders) {
									useLoadersPost.push(r.value);
								}
							} else if (r.type === &quot;use-pre&quot;) {
								if (!noPreAutoLoaders &amp;&amp; !noPrePostAutoLoaders) {
									useLoadersPre.push(r.value);
								}
							} else if (
								typeof r.value === &quot;object&quot; &amp;&amp;
								r.value !== null &amp;&amp;
								typeof settings[
									/** @type {keyof ModuleSettings} */ (r.type)
								] === &quot;object&quot; &amp;&amp;
								settings[/** @type {keyof ModuleSettings} */ (r.type)] !== null
							) {
								const type = /** @type {keyof ModuleSettings} */ (r.type);
								/** @type {TODO} */
								(settings)[type] = cachedCleverMerge(settings[type], r.value);
							} else {
								const type = /** @type {keyof ModuleSettings} */ (r.type);
								/** @type {TODO} */
								(settings)[type] = r.value;
							}
						}
					}

					/** @type {undefined | LoaderItem[]} */
					let postLoaders;
					/** @type {undefined | LoaderItem[]} */
					let normalLoaders;
					/** @type {undefined | LoaderItem[]} */
					let preLoaders;

					const continueCallback = needCalls(3, err =&gt; {
						if (err) {
							return callback(err);
						}
						const allLoaders = /** @type {LoaderItem[]} */ (postLoaders);
						if (matchResourceData === undefined) {
							for (const loader of /** @type {LoaderItem[]} */ (loaders))
								allLoaders.push(loader);
							for (const loader of /** @type {LoaderItem[]} */ (normalLoaders))
								allLoaders.push(loader);
						} else {
							for (const loader of /** @type {LoaderItem[]} */ (normalLoaders))
								allLoaders.push(loader);
							for (const loader of /** @type {LoaderItem[]} */ (loaders))
								allLoaders.push(loader);
						}
						for (const loader of /** @type {LoaderItem[]} */ (preLoaders))
							allLoaders.push(loader);
						const type = /** @type {string} */ (settings.type);
						const resolveOptions = settings.resolve;
						const layer = settings.layer;
						if (layer !== undefined &amp;&amp; !layers) {
							return callback(
								new Error(
									&quot;&#039;Rule.layer&#039; is only allowed when &#039;experiments.layers&#039; is enabled&quot;
								)
							);
						}
						try {
							Object.assign(data.createData, {
								layer:
									layer === undefined ? contextInfo.issuerLayer || null : layer,
								request: stringifyLoadersAndResource(
									allLoaders,
									resourceData.resource
								),
								userRequest,
								rawRequest: request,
								loaders: allLoaders,
								resource: resourceData.resource,
								context:
									resourceData.context || getContext(resourceData.resource),
								matchResource: matchResourceData
									? matchResourceData.resource
									: undefined,
								resourceResolveData: resourceData.data,
								settings,
								type,
								parser: this.getParser(type, settings.parser),
								parserOptions: settings.parser,
								generator: this.getGenerator(type, settings.generator),
								generatorOptions: settings.generator,
								resolveOptions
							});
						} catch (createDataErr) {
							return callback(/** @type {Error} */ (createDataErr));
						}
						callback();
					});
					this.resolveRequestArray(
						contextInfo,
						this.context,
						useLoadersPost,
						loaderResolver,
						resolveContext,
						(err, result) =&gt; {
							postLoaders = result;
							continueCallback(err);
						}
					);
					this.resolveRequestArray(
						contextInfo,
						this.context,
						useLoaders,
						loaderResolver,
						resolveContext,
						(err, result) =&gt; {
							normalLoaders = result;
							continueCallback(err);
						}
					);
					this.resolveRequestArray(
						contextInfo,
						this.context,
						useLoadersPre,
						loaderResolver,
						resolveContext,
						(err, result) =&gt; {
							preLoaders = result;
							continueCallback(err);
						}
					);
				});

				this.resolveRequestArray(
					contextInfo,
					contextScheme ? this.context : context,
					/** @type {LoaderItem[]} */ (elements),
					loaderResolver,
					resolveContext,
					(err, result) =&gt; {
						if (err) return continueCallback(err);
						loaders = result;
						continueCallback();
					}
				);

				/**
				 * @param {string} context context
				 */
				const defaultResolve = context =&gt; {
					if (/^($|\?)/.test(unresolvedResource)) {
						resourceData = {
							resource: unresolvedResource,
							data: {},
							.../** @type {TODO} */ (cacheParseResource(unresolvedResource))
						};
						continueCallback();
					}

					// resource without scheme and with path
					else {
						const normalResolver = this.getResolver(
							&quot;normal&quot;,
							dependencyType
								? cachedSetProperty(
										resolveOptions || EMPTY_RESOLVE_OPTIONS,
										&quot;dependencyType&quot;,
										dependencyType
									)
								: resolveOptions
						);
						this.resolveResource(
							contextInfo,
							context,
							unresolvedResource,
							normalResolver,
							resolveContext,
							(err, _resolvedResource, resolvedResourceResolveData) =&gt; {
								if (err) return continueCallback(err);
								if (_resolvedResource !== false) {
									const resolvedResource =
										/** @type {string} */
										(_resolvedResource);
									resourceData = {
										resource: resolvedResource,
										data:
											/** @type {ResolveRequest} */
											(resolvedResourceResolveData),
										.../** @type {TODO} */
										(cacheParseResource(resolvedResource))
									};
								}
								continueCallback();
							}
						);
					}
				};

				// resource with scheme
				if (scheme) {
					resourceData = {
						resource: unresolvedResource,
						data: {},
						path: undefined,
						query: undefined,
						fragment: undefined,
						context: undefined
					};
					this.hooks.resolveForScheme
						.for(scheme)
						.callAsync(resourceData, data, err =&gt; {
							if (err) return continueCallback(err);
							continueCallback();
						});
				}

				// resource within scheme
				else if (contextScheme) {
					resourceData = {
						resource: unresolvedResource,
						data: {},
						path: undefined,
						query: undefined,
						fragment: undefined,
						context: undefined
					};
					this.hooks.resolveInScheme
						.for(contextScheme)
						.callAsync(resourceData, data, (err, handled) =&gt; {
							if (err) return continueCallback(err);
							if (!handled) return defaultResolve(this.context);
							continueCallback();
						});
				}

				// resource without scheme and without path
				else defaultResolve(context);
			}
		);
	}

	cleanupForCache() {
		for (const module of this._restoredUnsafeCacheEntries) {
			ChunkGraph.clearChunkGraphForModule(module);
			ModuleGraph.clearModuleGraphForModule(module);
			module.cleanupForCache();
		}
	}

	/**
	 * @param {ModuleFactoryCreateData} data data object
	 * @param {ModuleFactoryCallback} callback callback
	 * @returns {void}
	 */
	create(data, callback) {
		const dependencies = /** @type {ModuleDependency[]} */ (data.dependencies);
		const context = data.context || this.context;
		const resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;
		const dependency = dependencies[0];
		const request = dependency.request;
		const assertions = dependency.assertions;
		const dependencyType = dependency.category || &quot;&quot;;
		const contextInfo = data.contextInfo;
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		/** @type {ResolveData} */
		const resolveData = {
			contextInfo,
			resolveOptions,
			context,
			request,
			assertions,
			dependencies,
			dependencyType,
			fileDependencies,
			missingDependencies,
			contextDependencies,
			createData: {},
			cacheable: true
		};
		this.hooks.beforeResolve.callAsync(resolveData, (err, result) =&gt; {
			if (err) {
				return callback(err, {
					fileDependencies,
					missingDependencies,
					contextDependencies,
					cacheable: false
				});
			}

			// Ignored
			if (result === false) {
				/** @type {ModuleFactoryResult} * */
				const factoryResult = {
					fileDependencies,
					missingDependencies,
					contextDependencies,
					cacheable: resolveData.cacheable
				};

				if (resolveData.ignoredModule) {
					factoryResult.module = resolveData.ignoredModule;
				}

				return callback(null, factoryResult);
			}

			if (typeof result === &quot;object&quot;)
				throw new Error(
					deprecationChangedHookMessage(
						&quot;beforeResolve&quot;,
						this.hooks.beforeResolve
					)
				);

			this.hooks.factorize.callAsync(resolveData, (err, module) =&gt; {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies,
						cacheable: false
					});
				}

				/** @type {ModuleFactoryResult} * */
				const factoryResult = {
					module,
					fileDependencies,
					missingDependencies,
					contextDependencies,
					cacheable: resolveData.cacheable
				};

				callback(null, factoryResult);
			});
		});
	}

	/**
	 * @param {ModuleFactoryCreateDataContextInfo} contextInfo context info
	 * @param {string} context context
	 * @param {string} unresolvedResource unresolved resource
	 * @param {ResolverWithOptions} resolver resolver
	 * @param {ResolveContext} resolveContext resolver context
	 * @param {(err: null | Error, res?: string | false, req?: ResolveRequest) =&gt; void} callback callback
	 */
	resolveResource(
		contextInfo,
		context,
		unresolvedResource,
		resolver,
		resolveContext,
		callback
	) {
		resolver.resolve(
			contextInfo,
			context,
			unresolvedResource,
			resolveContext,
			(err, resolvedResource, resolvedResourceResolveData) =&gt; {
				if (err) {
					return this._resolveResourceErrorHints(
						err,
						contextInfo,
						context,
						unresolvedResource,
						resolver,
						resolveContext,
						(err2, hints) =&gt; {
							if (err2) {
								err.message += `
A fatal error happened during resolving additional hints for this error: ${err2.message}`;
								err.stack += `

A fatal error happened during resolving additional hints for this error:
${err2.stack}`;
								return callback(err);
							}
							if (hints &amp;&amp; hints.length &gt; 0) {
								err.message += `
${hints.join(&quot;\n\n&quot;)}`;
							}

							// Check if the extension is missing a leading dot (e.g. &quot;js&quot; instead of &quot;.js&quot;)
							let appendResolveExtensionsHint = false;
							const specifiedExtensions = Array.from(
								resolver.options.extensions
							);
							const expectedExtensions = specifiedExtensions.map(extension =&gt; {
								if (LEADING_DOT_EXTENSION_REGEX.test(extension)) {
									appendResolveExtensionsHint = true;
									return `.${extension}`;
								}
								return extension;
							});
							if (appendResolveExtensionsHint) {
								err.message += `\nDid you miss the leading dot in &#039;resolve.extensions&#039;? Did you mean &#039;${JSON.stringify(
									expectedExtensions
								)}&#039; instead of &#039;${JSON.stringify(specifiedExtensions)}&#039;?`;
							}

							callback(err);
						}
					);
				}
				callback(err, resolvedResource, resolvedResourceResolveData);
			}
		);
	}

	/**
	 * @param {Error} error error
	 * @param {ModuleFactoryCreateDataContextInfo} contextInfo context info
	 * @param {string} context context
	 * @param {string} unresolvedResource unresolved resource
	 * @param {ResolverWithOptions} resolver resolver
	 * @param {ResolveContext} resolveContext resolver context
	 * @param {Callback&lt;string[]&gt;} callback callback
	 * @private
	 */
	_resolveResourceErrorHints(
		error,
		contextInfo,
		context,
		unresolvedResource,
		resolver,
		resolveContext,
		callback
	) {
		asyncLib.parallel(
			[
				callback =&gt; {
					if (!resolver.options.fullySpecified) return callback();
					resolver
						.withOptions({
							fullySpecified: false
						})
						.resolve(
							contextInfo,
							context,
							unresolvedResource,
							resolveContext,
							(err, resolvedResource) =&gt; {
								if (!err &amp;&amp; resolvedResource) {
									const resource = parseResource(resolvedResource).path.replace(
										/^.*[\\/]/,
										&quot;&quot;
									);
									return callback(
										null,
										`Did you mean &#039;${resource}&#039;?
BREAKING CHANGE: The request &#039;${unresolvedResource}&#039; failed to resolve only because it was resolved as fully specified
(probably because the origin is strict EcmaScript Module, e. g. a module with javascript mimetype, a &#039;*.mjs&#039; file, or a &#039;*.js&#039; file where the package.json contains &#039;&quot;type&quot;: &quot;module&quot;&#039;).
The extension in the request is mandatory for it to be fully specified.
Add the extension to the request.`
									);
								}
								callback();
							}
						);
				},
				callback =&gt; {
					if (!resolver.options.enforceExtension) return callback();
					resolver
						.withOptions({
							enforceExtension: false,
							extensions: []
						})
						.resolve(
							contextInfo,
							context,
							unresolvedResource,
							resolveContext,
							(err, resolvedResource) =&gt; {
								if (!err &amp;&amp; resolvedResource) {
									let hint = &quot;&quot;;
									const match = /(\.[^.]+)(\?|$)/.exec(unresolvedResource);
									if (match) {
										const fixedRequest = unresolvedResource.replace(
											/(\.[^.]+)(\?|$)/,
											&quot;$2&quot;
										);
										hint = resolver.options.extensions.has(match[1])
											? `Did you mean &#039;${fixedRequest}&#039;?`
											: `Did you mean &#039;${fixedRequest}&#039;? Also note that &#039;${match[1]}&#039; is not in &#039;resolve.extensions&#039; yet and need to be added for this to work?`;
									} else {
										hint =
											&quot;Did you mean to omit the extension or to remove &#039;resolve.enforceExtension&#039;?&quot;;
									}
									return callback(
										null,
										`The request &#039;${unresolvedResource}&#039; failed to resolve only because &#039;resolve.enforceExtension&#039; was specified.
${hint}
Including the extension in the request is no longer possible. Did you mean to enforce including the extension in requests with &#039;resolve.extensions: []&#039; instead?`
									);
								}
								callback();
							}
						);
				},
				callback =&gt; {
					if (
						/^\.\.?\//.test(unresolvedResource) ||
						resolver.options.preferRelative
					) {
						return callback();
					}
					resolver.resolve(
						contextInfo,
						context,
						`./${unresolvedResource}`,
						resolveContext,
						(err, resolvedResource) =&gt; {
							if (err || !resolvedResource) return callback();
							const moduleDirectories = resolver.options.modules
								.map(m =&gt; (Array.isArray(m) ? m.join(&quot;, &quot;) : m))
								.join(&quot;, &quot;);
							callback(
								null,
								`Did you mean &#039;./${unresolvedResource}&#039;?
Requests that should resolve in the current directory need to start with &#039;./&#039;.
Requests that start with a name are treated as module requests and resolve within module directories (${moduleDirectories}).
If changing the source code is not an option there is also a resolve options called &#039;preferRelative&#039; which tries to resolve these kind of requests in the current directory too.`
							);
						}
					);
				}
			],
			(err, hints) =&gt; {
				if (err) return callback(err);
				callback(null, /** @type {string[]} */ (hints).filter(Boolean));
			}
		);
	}

	/**
	 * @param {ModuleFactoryCreateDataContextInfo} contextInfo context info
	 * @param {string} context context
	 * @param {LoaderItem[]} array array
	 * @param {ResolverWithOptions} resolver resolver
	 * @param {ResolveContext} resolveContext resolve context
	 * @param {Callback&lt;LoaderItem[]&gt;} callback callback
	 * @returns {void} result
	 */
	resolveRequestArray(
		contextInfo,
		context,
		array,
		resolver,
		resolveContext,
		callback
	) {
		// LoaderItem
		if (array.length === 0) return callback(null, array);
		asyncLib.map(
			array,
			(item, callback) =&gt; {
				resolver.resolve(
					contextInfo,
					context,
					item.loader,
					resolveContext,
					(err, result, resolveRequest) =&gt; {
						if (
							err &amp;&amp;
							/^[^/]*$/.test(item.loader) &amp;&amp;
							!item.loader.endsWith(&quot;-loader&quot;)
						) {
							return resolver.resolve(
								contextInfo,
								context,
								`${item.loader}-loader`,
								resolveContext,
								err2 =&gt; {
									if (!err2) {
										err.message =
											`${err.message}\n` +
											&quot;BREAKING CHANGE: It&#039;s no longer allowed to omit the &#039;-loader&#039; suffix when using loaders.\n&quot; +
											`                 You need to specify &#039;${item.loader}-loader&#039; instead of &#039;${item.loader}&#039;,\n` +
											&quot;                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed&quot;;
									}
									callback(err);
								}
							);
						}
						if (err) return callback(err);

						const parsedResult = this._parseResourceWithoutFragment(
							/** @type {string} */ (result)
						);

						const type = /\.mjs$/i.test(parsedResult.path)
							? &quot;module&quot;
							: /\.cjs$/i.test(parsedResult.path)
								? &quot;commonjs&quot;
								: /** @type {ResolveRequest} */
									(resolveRequest).descriptionFileData === undefined
									? undefined
									: /** @type {ResolveRequest} */
										(resolveRequest).descriptionFileData.type;
						const resolved = {
							loader: parsedResult.path,
							type,
							options:
								item.options === undefined
									? parsedResult.query
										? parsedResult.query.slice(1)
										: undefined
									: item.options,
							ident:
								item.options === undefined
									? undefined
									: /** @type {string} */ (item.ident)
						};

						return callback(null, /** @type {LoaderItem} */ (resolved));
					}
				);
			},
			/** @type {Callback&lt;TODO&gt;} */ (callback)
		);
	}

	/**
	 * @param {string} type type
	 * @param {ParserOptions} parserOptions parser options
	 * @returns {Parser} parser
	 */
	getParser(type, parserOptions = EMPTY_PARSER_OPTIONS) {
		let cache = this.parserCache.get(type);

		if (cache === undefined) {
			cache = new WeakMap();
			this.parserCache.set(type, cache);
		}

		let parser = cache.get(parserOptions);

		if (parser === undefined) {
			parser = this.createParser(type, parserOptions);
			cache.set(parserOptions, parser);
		}

		return parser;
	}

	/**
	 * @param {string} type type
	 * @param {ParserOptions} parserOptions parser options
	 * @returns {Parser} parser
	 */
	createParser(type, parserOptions = {}) {
		parserOptions = mergeGlobalOptions(
			this._globalParserOptions,
			type,
			parserOptions
		);
		const parser = this.hooks.createParser.for(type).call(parserOptions);
		if (!parser) {
			throw new Error(`No parser registered for ${type}`);
		}
		this.hooks.parser.for(type).call(parser, parserOptions);
		return parser;
	}

	/**
	 * @param {string} type type of generator
	 * @param {GeneratorOptions} generatorOptions generator options
	 * @returns {Generator} generator
	 */
	getGenerator(type, generatorOptions = EMPTY_GENERATOR_OPTIONS) {
		let cache = this.generatorCache.get(type);

		if (cache === undefined) {
			cache = new WeakMap();
			this.generatorCache.set(type, cache);
		}

		let generator = cache.get(generatorOptions);

		if (generator === undefined) {
			generator = this.createGenerator(type, generatorOptions);
			cache.set(generatorOptions, generator);
		}

		return generator;
	}

	/**
	 * @param {string} type type of generator
	 * @param {GeneratorOptions} generatorOptions generator options
	 * @returns {Generator} generator
	 */
	createGenerator(type, generatorOptions = {}) {
		generatorOptions = mergeGlobalOptions(
			this._globalGeneratorOptions,
			type,
			generatorOptions
		);
		const generator = this.hooks.createGenerator
			.for(type)
			.call(generatorOptions);
		if (!generator) {
			throw new Error(`No generator registered for ${type}`);
		}
		this.hooks.generator.for(type).call(generator, generatorOptions);
		return generator;
	}

	/**
	 * @param {Parameters&lt;ResolverFactory[&quot;get&quot;]&gt;[0]} type type of resolver
	 * @param {Parameters&lt;ResolverFactory[&quot;get&quot;]&gt;[1]=} resolveOptions options
	 * @returns {ReturnType&lt;ResolverFactory[&quot;get&quot;]&gt;} the resolver
	 */
	getResolver(type, resolveOptions) {
		return this.resolverFactory.get(type, resolveOptions);
	}
}

module.exports = NormalModuleFactory;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
