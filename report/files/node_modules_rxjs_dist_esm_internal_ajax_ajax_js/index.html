<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/rxjs/dist/esm/internal/ajax/ajax.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/rxjs/dist/esm/internal/ajax/ajax.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">236</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">66.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { map } from &#039;../operators/map&#039;;
import { Observable } from &#039;../Observable&#039;;
import { AjaxResponse } from &#039;./AjaxResponse&#039;;
import { AjaxTimeoutError, AjaxError } from &#039;./errors&#039;;
function ajaxGet(url, headers) {
    return ajax({ method: &#039;GET&#039;, url, headers });
}
function ajaxPost(url, body, headers) {
    return ajax({ method: &#039;POST&#039;, url, body, headers });
}
function ajaxDelete(url, headers) {
    return ajax({ method: &#039;DELETE&#039;, url, headers });
}
function ajaxPut(url, body, headers) {
    return ajax({ method: &#039;PUT&#039;, url, body, headers });
}
function ajaxPatch(url, body, headers) {
    return ajax({ method: &#039;PATCH&#039;, url, body, headers });
}
const mapResponse = map((x) =&gt; x.response);
function ajaxGetJSON(url, headers) {
    return mapResponse(ajax({
        method: &#039;GET&#039;,
        url,
        headers,
    }));
}
export const ajax = (() =&gt; {
    const create = (urlOrConfig) =&gt; {
        const config = typeof urlOrConfig === &#039;string&#039;
            ? {
                url: urlOrConfig,
            }
            : urlOrConfig;
        return fromAjax(config);
    };
    create.get = ajaxGet;
    create.post = ajaxPost;
    create.delete = ajaxDelete;
    create.put = ajaxPut;
    create.patch = ajaxPatch;
    create.getJSON = ajaxGetJSON;
    return create;
})();
const UPLOAD = &#039;upload&#039;;
const DOWNLOAD = &#039;download&#039;;
const LOADSTART = &#039;loadstart&#039;;
const PROGRESS = &#039;progress&#039;;
const LOAD = &#039;load&#039;;
export function fromAjax(init) {
    return new Observable((destination) =&gt; {
        var _a, _b;
        const config = Object.assign({ async: true, crossDomain: false, withCredentials: false, method: &#039;GET&#039;, timeout: 0, responseType: &#039;json&#039; }, init);
        const { queryParams, body: configuredBody, headers: configuredHeaders } = config;
        let url = config.url;
        if (!url) {
            throw new TypeError(&#039;url is required&#039;);
        }
        if (queryParams) {
            let searchParams;
            if (url.includes(&#039;?&#039;)) {
                const parts = url.split(&#039;?&#039;);
                if (2 &lt; parts.length) {
                    throw new TypeError(&#039;invalid url&#039;);
                }
                searchParams = new URLSearchParams(parts[1]);
                new URLSearchParams(queryParams).forEach((value, key) =&gt; searchParams.set(key, value));
                url = parts[0] + &#039;?&#039; + searchParams;
            }
            else {
                searchParams = new URLSearchParams(queryParams);
                url = url + &#039;?&#039; + searchParams;
            }
        }
        const headers = {};
        if (configuredHeaders) {
            for (const key in configuredHeaders) {
                if (configuredHeaders.hasOwnProperty(key)) {
                    headers[key.toLowerCase()] = configuredHeaders[key];
                }
            }
        }
        const crossDomain = config.crossDomain;
        if (!crossDomain &amp;&amp; !(&#039;x-requested-with&#039; in headers)) {
            headers[&#039;x-requested-with&#039;] = &#039;XMLHttpRequest&#039;;
        }
        const { withCredentials, xsrfCookieName, xsrfHeaderName } = config;
        if ((withCredentials || !crossDomain) &amp;&amp; xsrfCookieName &amp;&amp; xsrfHeaderName) {
            const xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp(`(^|;\\s*)(${xsrfCookieName})=([^;]*)`))) === null || _a === void 0 ? void 0 : _a.pop()) !== null &amp;&amp; _b !== void 0 ? _b : &#039;&#039;;
            if (xsrfCookie) {
                headers[xsrfHeaderName] = xsrfCookie;
            }
        }
        const body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);
        const _request = Object.assign(Object.assign({}, config), { url,
            headers,
            body });
        let xhr;
        xhr = init.createXHR ? init.createXHR() : new XMLHttpRequest();
        {
            const { progressSubscriber, includeDownloadProgress = false, includeUploadProgress = false } = init;
            const addErrorEvent = (type, errorFactory) =&gt; {
                xhr.addEventListener(type, () =&gt; {
                    var _a;
                    const error = errorFactory();
                    (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber, error);
                    destination.error(error);
                });
            };
            addErrorEvent(&#039;timeout&#039;, () =&gt; new AjaxTimeoutError(xhr, _request));
            addErrorEvent(&#039;abort&#039;, () =&gt; new AjaxError(&#039;aborted&#039;, xhr, _request));
            const createResponse = (direction, event) =&gt; new AjaxResponse(event, xhr, _request, `${direction}_${event.type}`);
            const addProgressEvent = (target, type, direction) =&gt; {
                target.addEventListener(type, (event) =&gt; {
                    destination.next(createResponse(direction, event));
                });
            };
            if (includeUploadProgress) {
                [LOADSTART, PROGRESS, LOAD].forEach((type) =&gt; addProgressEvent(xhr.upload, type, UPLOAD));
            }
            if (progressSubscriber) {
                [LOADSTART, PROGRESS].forEach((type) =&gt; xhr.upload.addEventListener(type, (e) =&gt; { var _a; return (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.next) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber, e); }));
            }
            if (includeDownloadProgress) {
                [LOADSTART, PROGRESS].forEach((type) =&gt; addProgressEvent(xhr, type, DOWNLOAD));
            }
            const emitError = (status) =&gt; {
                const msg = &#039;ajax error&#039; + (status ? &#039; &#039; + status : &#039;&#039;);
                destination.error(new AjaxError(msg, xhr, _request));
            };
            xhr.addEventListener(&#039;error&#039;, (e) =&gt; {
                var _a;
                (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber, e);
                emitError();
            });
            xhr.addEventListener(LOAD, (event) =&gt; {
                var _a, _b;
                const { status } = xhr;
                if (status &lt; 400) {
                    (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.complete) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber);
                    let response;
                    try {
                        response = createResponse(DOWNLOAD, event);
                    }
                    catch (err) {
                        destination.error(err);
                        return;
                    }
                    destination.next(response);
                    destination.complete();
                }
                else {
                    (_b = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.error) === null || _b === void 0 ? void 0 : _b.call(progressSubscriber, event);
                    emitError(status);
                }
            });
        }
        const { user, method, async } = _request;
        if (user) {
            xhr.open(method, url, async, user, _request.password);
        }
        else {
            xhr.open(method, url, async);
        }
        if (async) {
            xhr.timeout = _request.timeout;
            xhr.responseType = _request.responseType;
        }
        if (&#039;withCredentials&#039; in xhr) {
            xhr.withCredentials = _request.withCredentials;
        }
        for (const key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        if (body) {
            xhr.send(body);
        }
        else {
            xhr.send();
        }
        return () =&gt; {
            if (xhr &amp;&amp; xhr.readyState !== 4) {
                xhr.abort();
            }
        };
    });
}
function extractContentTypeAndMaybeSerializeBody(body, headers) {
    var _a;
    if (!body ||
        typeof body === &#039;string&#039; ||
        isFormData(body) ||
        isURLSearchParams(body) ||
        isArrayBuffer(body) ||
        isFile(body) ||
        isBlob(body) ||
        isReadableStream(body)) {
        return body;
    }
    if (isArrayBufferView(body)) {
        return body.buffer;
    }
    if (typeof body === &#039;object&#039;) {
        headers[&#039;content-type&#039;] = (_a = headers[&#039;content-type&#039;]) !== null &amp;&amp; _a !== void 0 ? _a : &#039;application/json;charset=utf-8&#039;;
        return JSON.stringify(body);
    }
    throw new TypeError(&#039;Unknown body type&#039;);
}
const _toString = Object.prototype.toString;
function toStringCheck(obj, name) {
    return _toString.call(obj) === `[object ${name}]`;
}
function isArrayBuffer(body) {
    return toStringCheck(body, &#039;ArrayBuffer&#039;);
}
function isFile(body) {
    return toStringCheck(body, &#039;File&#039;);
}
function isBlob(body) {
    return toStringCheck(body, &#039;Blob&#039;);
}
function isArrayBufferView(body) {
    return typeof ArrayBuffer !== &#039;undefined&#039; &amp;&amp; ArrayBuffer.isView(body);
}
function isFormData(body) {
    return typeof FormData !== &#039;undefined&#039; &amp;&amp; body instanceof FormData;
}
function isURLSearchParams(body) {
    return typeof URLSearchParams !== &#039;undefined&#039; &amp;&amp; body instanceof URLSearchParams;
}
function isReadableStream(body) {
    return typeof ReadableStream !== &#039;undefined&#039; &amp;&amp; body instanceof ReadableStream;
}
//# sourceMappingURL=ajax.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
