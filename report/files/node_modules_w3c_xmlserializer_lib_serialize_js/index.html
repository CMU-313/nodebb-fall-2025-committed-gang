<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/w3c-xmlserializer/lib/serialize.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/w3c-xmlserializer/lib/serialize.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">366</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.67</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const xnv = require(&quot;xml-name-validator&quot;);

const attributeUtils = require(&quot;./attributes&quot;);
const { NAMESPACES, VOID_ELEMENTS, NODE_TYPES } = require(&quot;./constants&quot;);

const XML_CHAR = /^(\x09|\x0A|\x0D|[\x20-\uD7FF]|[\uE000-\uFFFD]|[\u{10000}-\u{10FFFF}])*$/u;
const PUBID_CHAR = /^(\x20|\x0D|\x0A|[a-zA-Z0-9]|[-&#039;()+,./:=?;!*#@$_%])*$/u;

function asciiCaseInsensitiveMatch(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i &lt; a.length; ++i) {
    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {
      return false;
    }
  }

  return true;
}

function recordNamespaceInformation(element, map, prefixMap) {
  let defaultNamespaceAttrValue = null;
  for (let i = 0; i &lt; element.attributes.length; ++i) {
    const attr = element.attributes[i];
    if (attr.namespaceURI === NAMESPACES.XMLNS) {
      if (attr.prefix === null) {
        defaultNamespaceAttrValue = attr.value;
        continue;
      }
      let namespaceDefinition = attr.value;
      if (namespaceDefinition === NAMESPACES.XML) {
        continue;
      }
      // This is exactly the other way than the spec says, but that&#039;s intended.
      // All the maps coalesce null to the empty string (explained in the
      // spec), so instead of doing that every time, just do it once here.
      if (namespaceDefinition === null) {
        namespaceDefinition = &quot;&quot;;
      }

      if (
        namespaceDefinition in map &amp;&amp;
        map[namespaceDefinition].includes(attr.localName)
      ) {
        continue;
      }
      if (!(namespaceDefinition in map)) {
        map[namespaceDefinition] = [];
      }
      map[namespaceDefinition].push(attr.localName);
      prefixMap[attr.localName] = namespaceDefinition;
    }
  }
  return defaultNamespaceAttrValue;
}

function serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed &amp;&amp; !PUBID_CHAR.test(node.publicId)) {
    throw new Error(&quot;Failed to serialize XML: document type node publicId is not well-formed.&quot;);
  }

  if (
    requireWellFormed &amp;&amp;
    (!XML_CHAR.test(node.systemId) ||
      (node.systemId.includes(&#039;&quot;&#039;) &amp;&amp; node.systemId.includes(&quot;&#039;&quot;)))
  ) {
    throw new Error(&quot;Failed to serialize XML: document type node systemId is not well-formed.&quot;);
  }

  let markup = `&lt;!DOCTYPE ${node.name}`;
  if (node.publicId !== &quot;&quot;) {
    markup += ` PUBLIC &quot;${node.publicId}&quot;`;
  } else if (node.systemId !== &quot;&quot;) {
    markup += &quot; SYSTEM&quot;;
  }
  if (node.systemId !== &quot;&quot;) {
    markup += ` &quot;${node.systemId}&quot;`;
  }
  return `${markup}&gt;`;
}

function serializeProcessingInstruction(
  node,
  namespace,
  prefixMap,
  requireWellFormed
) {
  if (
    requireWellFormed &amp;&amp;
    (node.target.includes(&quot;:&quot;) || asciiCaseInsensitiveMatch(node.target, &quot;xml&quot;))
  ) {
    throw new Error(&quot;Failed to serialize XML: processing instruction node target is not well-formed.&quot;);
  }
  if (
    requireWellFormed &amp;&amp;
    (!XML_CHAR.test(node.data) || node.data.includes(&quot;?&gt;&quot;))
  ) {
    throw new Error(&quot;Failed to serialize XML: processing instruction node data is not well-formed.&quot;);
  }
  return `&lt;?${node.target} ${node.data}?&gt;`;
}

function serializeDocument(
  node,
  namespace,
  prefixMap,
  requireWellFormed,
  refs
) {
  if (requireWellFormed &amp;&amp; node.documentElement === null) {
    throw new Error(&quot;Failed to serialize XML: document does not have a document element.&quot;);
  }
  let serializedDocument = &quot;&quot;;
  for (const child of node.childNodes) {
    serializedDocument += xmlSerialization(
      child,
      namespace,
      prefixMap,
      requireWellFormed,
      refs
    );
  }
  return serializedDocument;
}

function serializeDocumentFragment(
  node,
  namespace,
  prefixMap,
  requireWellFormed,
  refs
) {
  let markup = &quot;&quot;;
  for (const child of node.childNodes) {
    markup += xmlSerialization(
      child,
      namespace,
      prefixMap,
      requireWellFormed,
      refs
    );
  }
  return markup;
}

function serializeText(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed &amp;&amp; !XML_CHAR.test(node.data)) {
    throw new Error(&quot;Failed to serialize XML: text node data is not well-formed.&quot;);
  }

  return node.data
    .replace(/&amp;/ug, &quot;&amp;amp;&quot;)
    .replace(/&lt;/ug, &quot;&amp;lt;&quot;)
    .replace(/&gt;/ug, &quot;&amp;gt;&quot;);
}

function serializeComment(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed &amp;&amp; !XML_CHAR.test(node.data)) {
    throw new Error(&quot;Failed to serialize XML: comment node data is not well-formed.&quot;);
  }

  if (
    requireWellFormed &amp;&amp;
    (node.data.includes(&quot;--&quot;) || node.data.endsWith(&quot;-&quot;))
  ) {
    throw new Error(&quot;Failed to serialize XML: found hyphens in illegal places in comment node data.&quot;);
  }
  return `&lt;!--${node.data}--&gt;`;
}

function serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {
  if (
    requireWellFormed &amp;&amp;
    (node.localName.includes(&quot;:&quot;) || !xnv.name(node.localName))
  ) {
    throw new Error(&quot;Failed to serialize XML: element node localName is not a valid XML name.&quot;);
  }
  let markup = &quot;&lt;&quot;;
  let qualifiedName = &quot;&quot;;
  let skipEndTag = false;
  let ignoreNamespaceDefinitionAttr = false;
  const map = { ...prefixMap };
  const localPrefixesMap = Object.create(null);
  const localDefaultNamespace = recordNamespaceInformation(
    node,
    map,
    localPrefixesMap
  );
  let inheritedNs = namespace;
  const ns = node.namespaceURI;
  if (inheritedNs === ns) {
    if (localDefaultNamespace !== null) {
      ignoreNamespaceDefinitionAttr = true;
    }
    if (ns === NAMESPACES.XML) {
      qualifiedName = `xml:${node.localName}`;
    } else {
      qualifiedName = node.localName;
    }
    markup += qualifiedName;
  } else {
    let { prefix } = node;
    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);
    if (prefix === &quot;xmlns&quot;) {
      if (requireWellFormed) {
        throw new Error(&quot;Failed to serialize XML: element nodes can&#039;t have a prefix of \&quot;xmlns\&quot;.&quot;);
      }
      candidatePrefix = &quot;xmlns&quot;;
    }
    if (candidatePrefix !== null) {
      qualifiedName = `${candidatePrefix}:${node.localName}`;
      if (
        localDefaultNamespace !== null &amp;&amp;
        localDefaultNamespace !== NAMESPACES.XML
      ) {
        inheritedNs =
          localDefaultNamespace === &quot;&quot; ? null : localDefaultNamespace;
      }
      markup += qualifiedName;
    } else if (prefix !== null) {
      if (prefix in localPrefixesMap) {
        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);
      }
      if (map[ns]) {
        map[ns].push(prefix);
      } else {
        map[ns] = [prefix];
      }
      qualifiedName = `${prefix}:${node.localName}`;
      markup += `${qualifiedName} xmlns:${prefix}=&quot;${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}&quot;`;
      if (localDefaultNamespace !== null) {
        inheritedNs =
          localDefaultNamespace === &quot;&quot; ? null : localDefaultNamespace;
      }
    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {
      ignoreNamespaceDefinitionAttr = true;
      qualifiedName = node.localName;
      inheritedNs = ns;
      markup += `${qualifiedName} xmlns=&quot;${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}&quot;`;
    } else {
      qualifiedName = node.localName;
      inheritedNs = ns;
      markup += qualifiedName;
    }
  }

  markup += attributeUtils.serializeAttributes(
    node,
    map,
    localPrefixesMap,
    ignoreNamespaceDefinitionAttr,
    requireWellFormed,
    refs
  );

  if (
    ns === NAMESPACES.HTML &amp;&amp;
    node.childNodes.length === 0 &amp;&amp;
    VOID_ELEMENTS.has(node.localName)
  ) {
    markup += &quot; /&quot;;
    skipEndTag = true;
  } else if (ns !== NAMESPACES.HTML &amp;&amp; node.childNodes.length === 0) {
    markup += &quot;/&quot;;
    skipEndTag = true;
  }
  markup += &quot;&gt;&quot;;
  if (skipEndTag) {
    return markup;
  }

  if (ns === NAMESPACES.HTML &amp;&amp; node.localName === &quot;template&quot;) {
    markup += xmlSerialization(
      node.content,
      inheritedNs,
      map,
      requireWellFormed,
      refs
    );
  } else {
    for (const child of node.childNodes) {
      markup += xmlSerialization(
        child,
        inheritedNs,
        map,
        requireWellFormed,
        refs
      );
    }
  }
  markup += `&lt;/${qualifiedName}&gt;`;
  return markup;
}

function serializeCDATASection(node) {
  return `&lt;![CDATA[${node.data}]]&gt;`;
}

/**
 * @param {{prefixIndex: number}} refs
 */
function xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {
  switch (node.nodeType) {
    case NODE_TYPES.ELEMENT_NODE:
      return serializeElement(
        node,
        namespace,
        prefixMap,
        requireWellFormed,
        refs
      );
    case NODE_TYPES.DOCUMENT_NODE:
      return serializeDocument(
        node,
        namespace,
        prefixMap,
        requireWellFormed,
        refs
      );
    case NODE_TYPES.COMMENT_NODE:
      return serializeComment(node, namespace, prefixMap, requireWellFormed);
    case NODE_TYPES.TEXT_NODE:
      return serializeText(node, namespace, prefixMap, requireWellFormed);
    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:
      return serializeDocumentFragment(
        node,
        namespace,
        prefixMap,
        requireWellFormed,
        refs
      );
    case NODE_TYPES.DOCUMENT_TYPE_NODE:
      return serializeDocumentType(
        node,
        namespace,
        prefixMap,
        requireWellFormed
      );
    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:
      return serializeProcessingInstruction(
        node,
        namespace,
        prefixMap,
        requireWellFormed
      );
    case NODE_TYPES.ATTRIBUTE_NODE:
      return &quot;&quot;;
    case NODE_TYPES.CDATA_SECTION_NODE:
      return serializeCDATASection(node);
    default:
      throw new TypeError(&quot;Failed to serialize XML: only Nodes can be serialized.&quot;);
  }
}

module.exports = (root, { requireWellFormed = false } = {}) =&gt; {
  const namespacePrefixMap = Object.create(null);
  namespacePrefixMap[&quot;http://www.w3.org/XML/1998/namespace&quot;] = [&quot;xml&quot;];
  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {
    prefixIndex: 1
  });
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
