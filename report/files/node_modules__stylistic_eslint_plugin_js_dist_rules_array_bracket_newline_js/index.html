<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@stylistic/eslint-plugin-js/dist/rules/array-bracket-newline.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@stylistic/eslint-plugin-js/dist/rules/array-bracket-newline.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">150</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">40.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.47</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { c as createRule, i as isTokenOnSameLine, a as isCommentToken } from &#039;../utils.js&#039;;
import &#039;eslint-visitor-keys&#039;;
import &#039;espree&#039;;

var arrayBracketNewline = createRule({
  name: &quot;array-bracket-newline&quot;,
  package: &quot;js&quot;,
  meta: {
    type: &quot;layout&quot;,
    docs: {
      description: &quot;Enforce linebreaks after opening and before closing array brackets&quot;
    },
    fixable: &quot;whitespace&quot;,
    schema: [
      {
        oneOf: [
          {
            type: &quot;string&quot;,
            enum: [&quot;always&quot;, &quot;never&quot;, &quot;consistent&quot;]
          },
          {
            type: &quot;object&quot;,
            properties: {
              multiline: {
                type: &quot;boolean&quot;
              },
              minItems: {
                type: [&quot;integer&quot;, &quot;null&quot;],
                minimum: 0
              }
            },
            additionalProperties: false
          }
        ]
      }
    ],
    messages: {
      unexpectedOpeningLinebreak: &quot;There should be no linebreak after &#039;[&#039;.&quot;,
      unexpectedClosingLinebreak: &quot;There should be no linebreak before &#039;]&#039;.&quot;,
      missingOpeningLinebreak: &quot;A linebreak is required after &#039;[&#039;.&quot;,
      missingClosingLinebreak: &quot;A linebreak is required before &#039;]&#039;.&quot;
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    function normalizeOptionValue(option) {
      let consistent = false;
      let multiline = false;
      let minItems = 0;
      if (option) {
        if (option === &quot;consistent&quot;) {
          consistent = true;
          minItems = Number.POSITIVE_INFINITY;
        } else if (option === &quot;always&quot; || typeof option !== &quot;string&quot; &amp;&amp; option.minItems === 0) {
          minItems = 0;
        } else if (option === &quot;never&quot;) {
          minItems = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(option.multiline);
          minItems = option.minItems || Number.POSITIVE_INFINITY;
        }
      } else {
        consistent = false;
        multiline = true;
        minItems = Number.POSITIVE_INFINITY;
      }
      return { consistent, multiline, minItems };
    }
    function normalizeOptions(options) {
      const value = normalizeOptionValue(options);
      return { ArrayExpression: value, ArrayPattern: value };
    }
    function reportNoBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: &quot;unexpectedOpeningLinebreak&quot;,
        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });
          if (!nextToken || isCommentToken(nextToken))
            return null;
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }
    function reportNoEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: &quot;unexpectedClosingLinebreak&quot;,
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });
          if (!previousToken || isCommentToken(previousToken))
            return null;
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }
    function reportRequiredBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: &quot;missingOpeningLinebreak&quot;,
        fix(fixer) {
          return fixer.insertTextAfter(token, &quot;\n&quot;);
        }
      });
    }
    function reportRequiredEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: &quot;missingClosingLinebreak&quot;,
        fix(fixer) {
          return fixer.insertTextBefore(token, &quot;\n&quot;);
        }
      });
    }
    function check(node) {
      const elements = node.elements;
      const normalizedOptions = normalizeOptions(context.options[0]);
      const options = normalizedOptions[node.type];
      const openBracket = sourceCode.getFirstToken(node);
      const closeBracket = sourceCode.getLastToken(node);
      const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });
      const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });
      const first = sourceCode.getTokenAfter(openBracket);
      const last = sourceCode.getTokenBefore(closeBracket);
      const needsLinebreaks = elements.length &gt;= options.minItems || options.multiline &amp;&amp; elements.length &gt; 0 &amp;&amp; firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 &amp;&amp; firstIncComment.type === &quot;Block&quot; &amp;&amp; firstIncComment.loc.start.line !== lastIncComment.loc.end.line &amp;&amp; firstIncComment === lastIncComment || options.consistent &amp;&amp; openBracket.loc.end.line !== first.loc.start.line;
      if (needsLinebreaks) {
        if (isTokenOnSameLine(openBracket, first))
          reportRequiredBeginningLinebreak(node, openBracket);
        if (isTokenOnSameLine(last, closeBracket))
          reportRequiredEndingLinebreak(node, closeBracket);
      } else {
        if (!isTokenOnSameLine(openBracket, first))
          reportNoBeginningLinebreak(node, openBracket);
        if (!isTokenOnSameLine(last, closeBracket))
          reportNoEndingLinebreak(node, closeBracket);
      }
    }
    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }
});

export { arrayBracketNewline as default };
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
