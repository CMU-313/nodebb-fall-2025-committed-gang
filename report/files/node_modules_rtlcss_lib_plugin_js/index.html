<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/rtlcss/lib/plugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/rtlcss/lib/plugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">87.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">544</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">118.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

const config = require(&#039;./config.js&#039;)
const util = require(&#039;./util.js&#039;)

module.exports = {
  name: &#039;rtlcss&#039;,
  priority: 100,
  directives: {
    control: {
      ignore: {
        expect: { atrule: true, comment: true, decl: true, rule: true },
        endNode: null,
        begin (node, metadata, context) {
          // find the ending node in case of self-closing directive
          if (this.endNode === null &amp;&amp; metadata.begin &amp;&amp; metadata.end) {
            let n = node
            while (n &amp;&amp; n.nodes) {
              n = n.nodes[n.nodes.length - 1]
            }

            this.endNode = n
          }

          return node.type !== &#039;comment&#039; || !/^\s*!?\s*rtl:end:ignore/.test(node.text)
        },
        end (node, metadata, context) {
          // end if:
          //  1. block directive and the node is comment
          //  2. self-closing directive and node is endNode
          if ((metadata.begin !== metadata.end &amp;&amp; node.type === &#039;comment&#039;) || (metadata.begin &amp;&amp; metadata.end &amp;&amp; node === this.endNode)) {
            // clear ending node
            this.endNode = null
            return true
          }

          return false
        }
      },
      rename: {
        expect: { rule: true },
        begin (node, metadata, context) {
          node.selector = context.util.applyStringMap(node.selector, false)
          return false
        },
        end (node, context) {
          return true
        }
      },
      raw: {
        expect: { self: true },
        begin (node, metadata, context) {
          const nodes = context.postcss.parse(metadata.param, { from: node.source.input.from })
          nodes.walk((node) =&gt; {
            node[context.symbol] = true
          })
          node.parent.insertBefore(node, nodes)
          return true
        },
        end (node, context) {
          return true
        }
      },
      remove: {
        expect: { atrule: true, rule: true, decl: true },
        begin (node, metadata, context) {
          let prevent = false
          switch (node.type) {
            case &#039;atrule&#039;:
            case &#039;rule&#039;:
            case &#039;decl&#039;:
              prevent = true
              node.remove()
          }

          return prevent
        },
        end (node, metadata, context) {
          return true
        }
      },
      options: {
        expect: { self: true },
        stack: [],
        begin (node, metadata, context) {
          this.stack.push(util.extend({}, context.config))
          let options
          try {
            options = JSON.parse(metadata.param)
          } catch (e) {
            throw node.error(&#039;Invalid options object&#039;, { details: e })
          }

          context.config = config.configure(options, context.config.plugins)
          context.util = util.configure(context.config)
          return true
        },
        end (node, metadata, context) {
          const config = this.stack.pop()
          if (config &amp;&amp; !metadata.begin) {
            context.config = config
            context.util = util.configure(context.config)
          }

          return true
        }
      },
      config: {
        expect: { self: true },
        stack: [],
        begin (node, metadata, context) {
          this.stack.push(util.extend({}, context.config))
          let configuration
          try {
            configuration = eval(`(${metadata.param})`) // eslint-disable-line no-eval
          } catch (e) {
            throw node.error(&#039;Invalid config object&#039;, { details: e })
          }

          context.config = config.configure(configuration.options, configuration.plugins)
          context.util = util.configure(context.config)
          return true
        },
        end (node, metadata, context) {
          const config = this.stack.pop()
          if (config &amp;&amp; !metadata.begin) {
            context.config = config
            context.util = util.configure(context.config)
          }

          return true
        }
      }
    },
    value: [
      {
        name: &#039;ignore&#039;,
        action (decl, expr, context) {
          return true
        }
      },
      {
        name: &#039;prepend&#039;,
        action (decl, expr, context) {
          let prefix = &#039;&#039;
          const hasRawValue = decl.raws.value &amp;&amp; decl.raws.value.raw
          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : decl.value}${decl.important ? decl.raws.important.substr(9).trim() : &#039;&#039;}`
          raw.replace(expr, (m, v) =&gt; {
            prefix += v
          })
          decl.value = hasRawValue
            ? (decl.raws.value.raw = prefix + decl.raws.value.raw)
            : prefix + decl.value
          return true
        }
      },
      {
        name: &#039;append&#039;,
        action (decl, expr, context) {
          let suffix = &#039;&#039;
          const hasRawValue = decl.raws.value &amp;&amp; decl.raws.value.raw
          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : decl.value}${decl.important ? decl.raws.important.substr(9).trim() : &#039;&#039;}`
          raw.replace(expr, (m, v) =&gt; {
            suffix = v + suffix
          })
          decl.value = hasRawValue ? (decl.raws.value.raw += suffix) : decl.value + suffix
          return true
        }
      },
      {
        name: &#039;insert&#039;,
        action (decl, expr, context) {
          const hasRawValue = decl.raws.value &amp;&amp; decl.raws.value.raw
          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : decl.value}${decl.important ? decl.raws.important.substr(9).trim() : &#039;&#039;}`
          const result = raw.replace(expr, (match, value) =&gt; value + match)
          decl.value = hasRawValue ? (decl.raws.value.raw = result) : result
          return true
        }
      },
      {
        name: &#039;&#039;,
        action (decl, expr, context) {
          const hasRawValue = decl.raws.value &amp;&amp; decl.raws.value.raw
          const raw = `${decl.raws.between.substr(1).trim()}${hasRawValue ? decl.raws.value.raw : &#039;&#039;}${decl.important ? decl.raws.important.substr(9).trim() : &#039;&#039;}`
          raw.replace(expr, (match, value) =&gt; {
            decl.value = hasRawValue
              ? (decl.raws.value.raw = value + match)
              : value
          })
          return true
        }
      }
    ]
  },
  processors: [
    {
      name: &#039;variable&#039;,
      expr: /^--/im,
      action (prop, value) {
        return { prop, value }
      }
    },
    {
      name: &#039;direction&#039;,
      expr: /direction/im,
      action (prop, value, context) {
        return { prop, value: context.util.swapLtrRtl(value) }
      }
    },
    {
      name: &#039;left&#039;,
      expr: /left/im,
      action (prop, value, context) {
        return { prop: prop.replace(this.expr, &#039;right&#039;), value }
      }
    },
    {
      name: &#039;right&#039;,
      expr: /right/im,
      action (prop, value, context) {
        return { prop: prop.replace(this.expr, &#039;left&#039;), value }
      }
    },
    {
      name: &#039;four-value syntax&#039;,
      expr: /^(margin|padding|border-(color|style|width))$/ig,
      cache: null,
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            match: /[^\s\uFFFD]+/g
          }
        }

        const state = context.util.guardFunctions(value)
        const result = state.value.match(this.cache.match)
        if (result &amp;&amp; result.length === 4 &amp;&amp; (state.store.length &gt; 0 || result[1] !== result[3])) {
          let i = 0
          state.value = state.value.replace(this.cache.match, () =&gt; result[(4 - i++) % 4])
        }

        return { prop, value: context.util.unguardFunctions(state) }
      }
    },
    {
      name: &#039;border radius&#039;,
      expr: /border-radius/ig,
      cache: null,
      flip (value) {
        const parts = value.match(this.cache.match)
        if (!parts) return value

        let i
        switch (parts.length) {
          case 2:
            i = 1
            if (parts[0] !== parts[1]) {
              value = value.replace(this.cache.match, () =&gt; parts[i--])
            }

            break
          case 3:
            // preserve leading whitespace.
            value = value.replace(this.cache.white, (m) =&gt; `${m + parts[1]} `)
            break
          case 4:
            i = 0
            if (parts[0] !== parts[1] || parts[2] !== parts[3]) {
              value = value.replace(this.cache.match, () =&gt; parts[(5 - i++) % 4])
            }

            break
        }

        return value
      },
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            match: /[^\s\uFFFD]+/g,
            slash: /[^/]+/g,
            white: /(^\s*)/
          }
        }

        const state = context.util.guardFunctions(value)
        state.value = state.value.replace(this.cache.slash, (m) =&gt; this.flip(m))
        return { prop, value: context.util.unguardFunctions(state) }
      }
    },
    {
      name: &#039;shadow&#039;,
      expr: /shadow/ig,
      cache: null,
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            replace: /[^,]+/g
          }
        }

        const colorSafe = context.util.guardHexColors(value)
        const funcSafe = context.util.guardFunctions(colorSafe.value)
        funcSafe.value = funcSafe.value.replace(this.cache.replace, (m) =&gt; context.util.negate(m))
        colorSafe.value = context.util.unguardFunctions(funcSafe)
        return { prop, value: context.util.unguardHexColors(colorSafe) }
      }
    },
    {
      name: &#039;transform and perspective origin&#039;,
      expr: /(?:transform|perspective)-origin/ig,
      cache: null,
      flip (value, context) {
        if (value === &#039;0&#039;) {
          value = &#039;100%&#039;
        } else if (value.match(this.cache.percent)) {
          value = context.util.complement(value)
        } else if (value.match(this.cache.length)) {
          value = context.util.flipLength(value)
        }

        return value
      },
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            match: context.util.regex([&#039;func&#039;, &#039;percent&#039;, &#039;length&#039;], &#039;g&#039;),
            percent: context.util.regex([&#039;func&#039;, &#039;percent&#039;], &#039;i&#039;),
            length: context.util.regex([&#039;length&#039;], &#039;gi&#039;),
            xKeyword: /(left|right|center)/i
          }
        }

        if (value.match(this.cache.xKeyword)) {
          value = context.util.swapLeftRight(value)
        } else {
          const state = context.util.guardFunctions(value)
          const parts = state.value.match(this.cache.match)
          if (parts &amp;&amp; parts.length &gt; 0) {
            parts[0] = this.flip(parts[0], context)
            state.value = state.value.replace(this.cache.match, () =&gt; parts.shift())
            value = context.util.unguardFunctions(state)
          }
        }

        return { prop, value }
      }
    },
    {
      name: &#039;transform&#039;,
      expr: /^(?!text-).*?transform$/ig,
      cache: null,
      flip (value, process, context) {
        let i = 0
        return value.replace(this.cache.unit, (num) =&gt; process(++i, num))
      },
      flipMatrix (value, context) {
        return this.flip(
          value,
          (i, num) =&gt; i === 2 || i === 3 || i === 5 ? context.util.negate(num) : num,
          context
        )
      },
      flipMatrix3D (value, context) {
        return this.flip(
          value,
          (i, num) =&gt; i === 2 || i === 4 || i === 5 || i === 13 ? context.util.negate(num) : num,
          context
        )
      },
      flipRotate3D (value, context) {
        return this.flip(
          value,
          (i, num) =&gt; i === 1 || i === 4 ? context.util.negate(num) : num,
          context
        )
      },
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            negatable: /((translate)(x|3d)?|rotate(z|y)?)$/ig,
            unit: context.util.regex([&#039;func&#039;, &#039;number&#039;], &#039;g&#039;),
            matrix: /matrix$/i,
            matrix3D: /matrix3d$/i,
            skewXY: /skew(x|y)?$/i,
            rotate3D: /rotate3d$/i
          }
        }

        const state = context.util.guardFunctions(value)
        return {
          prop,
          value: context.util.unguardFunctions(state, (v, n) =&gt; {
            if (n.length === 0) return v

            if (n.match(this.cache.matrix3D)) {
              v = this.flipMatrix3D(v, context)
            } else if (n.match(this.cache.matrix)) {
              v = this.flipMatrix(v, context)
            } else if (n.match(this.cache.rotate3D)) {
              v = this.flipRotate3D(v, context)
            } else if (n.match(this.cache.skewXY)) {
              v = context.util.negateAll(v)
            } else if (n.match(this.cache.negatable)) {
              v = context.util.negate(v)
            }

            return v
          })
        }
      }
    },
    {
      name: &#039;transition&#039;,
      expr: /transition(-property)?$/i,
      action (prop, value, context) {
        return { prop, value: context.util.swapLeftRight(value) }
      }
    },
    {
      name: &#039;background&#039;,
      expr: /(background|object)(-position(-x)?|-image)?$/i,
      cache: null,
      flip (value, context, isPositionX) {
        const state = util.saveTokens(value, true)
        const parts = state.value.match(this.cache.match)

        if (!parts || parts.length === 0) return util.restoreTokens(state)

        const keywords = (state.value.match(this.cache.position) || &#039;&#039;).length
        if (/* edge offsets */ parts.length &gt;= 3 || /* keywords only */ keywords === 2) {
          state.value = util.swapLeftRight(state.value)
        } else {
          if (parts[0] === &#039;0&#039;) {
            parts[0] = &#039;100%&#039;
          } else if (parts[0].match(this.cache.percent)) {
            parts[0] = context.util.complement(parts[0])
          } else if (parts[0].match(this.cache.length)) {
            if (isPositionX) {
              parts[0] = context.util.flipLength(parts[0])
            } else if (parts.length === 1) { // X 50% ==&gt; left X top 50%
              parts[0] = `right ${parts[0]} top 50%`
            } else if (!keywords &amp;&amp; parts.length === 2) { // X Y ==&gt; left X top Y
              parts[0] = `right ${parts[0]}`
              parts[1] = `top ${parts[1]}`
            }
          } else {
            parts[0] = context.util.swapLeftRight(parts[0])
          }
          state.value = state.value.replace(this.cache.match, () =&gt; parts.shift())
        }

        return util.restoreTokens(state)
      },
      update (context, value, name) {
        if (name.match(this.cache.gradient)) {
          value = context.util.swapLeftRight(value)
          if (value.match(this.cache.angle)) {
            value = context.util.negate(value)
          }
        } else if ((context.config.processUrls === true || context.config.processUrls.decl === true) &amp;&amp; name.match(this.cache.url)) {
          value = context.util.applyStringMap(value, true)
        }
        return value
      },
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            match: context.util.regex([&#039;position&#039;, &#039;percent&#039;, &#039;length&#039;, &#039;calc&#039;], &#039;ig&#039;),
            percent: context.util.regex([&#039;func&#039;, &#039;percent&#039;], &#039;i&#039;),
            position: context.util.regex([&#039;position&#039;], &#039;g&#039;),
            length: context.util.regex([&#039;length&#039;], &#039;gi&#039;),
            gradient: /gradient$/i,
            angle: /\d+(deg|g?rad|turn)/i,
            url: /^url/i
          }
        }

        const colorSafe = context.util.guardHexColors(value)
        const funcSafe = context.util.guardFunctions(colorSafe.value)
        const parts = funcSafe.value.split(&#039;,&#039;)
        const lprop = prop.toLowerCase()
        if (lprop !== &#039;background-image&#039;) {
          for (let x = 0; x &lt; parts.length; x++) {
            parts[x] = this.flip(parts[x], context, lprop.endsWith(&#039;-x&#039;))
          }
        }

        funcSafe.value = parts.join(&#039;,&#039;)
        colorSafe.value = context.util.unguardFunctions(funcSafe, this.update.bind(this, context))
        return {
          prop,
          value: context.util.unguardHexColors(colorSafe)
        }
      }
    },
    {
      name: &#039;keyword&#039;,
      expr: /float|clear|text-align|justify-(content|items|self)/i,
      action (prop, value, context) {
        return { prop, value: context.util.swapLeftRight(value) }
      }
    },
    {
      name: &#039;cursor&#039;,
      expr: /cursor/i,
      cache: null,
      update (context, value, name) {
        return (context.config.processUrls === true || context.config.processUrls.decl === true) &amp;&amp; name.match(this.cache.url)
          ? context.util.applyStringMap(value, true)
          : value
      },
      flip (value) {
        return value.replace(this.cache.replace, (s, m) =&gt; {
          return s.replace(m, m.replace(this.cache.e, &#039;*&#039;)
            .replace(this.cache.w, &#039;e&#039;)
            .replace(this.cache.star, &#039;w&#039;))
        })
      },
      action (prop, value, context) {
        if (this.cache === null) {
          this.cache = {
            replace: /\b(ne|nw|se|sw|nesw|nwse)-resize/ig,
            url: /^url/i,
            e: /e/i,
            w: /w/i,
            star: /\*/i
          }
        }

        const state = context.util.guardFunctions(value)
        state.value = state.value.split(&#039;,&#039;)
          .map((part) =&gt; this.flip(part))
          .join(&#039;,&#039;)

        return {
          prop,
          value: context.util.unguardFunctions(state, this.update.bind(this, context))
        }
      }
    }
  ]
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
