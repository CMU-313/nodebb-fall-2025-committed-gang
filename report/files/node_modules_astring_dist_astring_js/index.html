<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/astring/dist/astring.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/astring/dist/astring.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1254</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">153.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">16.49</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.generate = generate;
exports.baseGenerator = exports.GENERATOR = exports.EXPRESSIONS_PRECEDENCE = exports.NEEDS_PARENTHESES = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

function _defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var stringify = JSON.stringify;

if (!String.prototype.repeat) {
  throw new Error(&#039;String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation&#039;);
}

if (!String.prototype.endsWith) {
  throw new Error(&#039;String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation&#039;);
}

var OPERATOR_PRECEDENCE = {
  &#039;||&#039;: 2,
  &#039;??&#039;: 3,
  &#039;&amp;&amp;&#039;: 4,
  &#039;|&#039;: 5,
  &#039;^&#039;: 6,
  &#039;&amp;&#039;: 7,
  &#039;==&#039;: 8,
  &#039;!=&#039;: 8,
  &#039;===&#039;: 8,
  &#039;!==&#039;: 8,
  &#039;&lt;&#039;: 9,
  &#039;&gt;&#039;: 9,
  &#039;&lt;=&#039;: 9,
  &#039;&gt;=&#039;: 9,
  &quot;in&quot;: 9,
  &quot;instanceof&quot;: 9,
  &#039;&lt;&lt;&#039;: 10,
  &#039;&gt;&gt;&#039;: 10,
  &#039;&gt;&gt;&gt;&#039;: 10,
  &#039;+&#039;: 11,
  &#039;-&#039;: 11,
  &#039;*&#039;: 12,
  &#039;%&#039;: 12,
  &#039;/&#039;: 12,
  &#039;**&#039;: 13
};
var NEEDS_PARENTHESES = 17;
exports.NEEDS_PARENTHESES = NEEDS_PARENTHESES;
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  PrivateIdentifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  ChainExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  ArrowFunctionExpression: NEEDS_PARENTHESES,
  ClassExpression: NEEDS_PARENTHESES,
  FunctionExpression: NEEDS_PARENTHESES,
  ObjectExpression: NEEDS_PARENTHESES,
  UpdateExpression: 16,
  UnaryExpression: 15,
  AwaitExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
exports.EXPRESSIONS_PRECEDENCE = EXPRESSIONS_PRECEDENCE;

function formatSequence(state, nodes) {
  var generator = state.generator;
  state.write(&#039;(&#039;);

  if (nodes != null &amp;&amp; nodes.length &gt; 0) {
    generator[nodes[0].type](nodes[0], state);
    var length = nodes.length;

    for (var i = 1; i &lt; length; i++) {
      var param = nodes[i];
      state.write(&#039;, &#039;);
      generator[param.type](param, state);
    }
  }

  state.write(&#039;)&#039;);
}

function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
  var nodePrecedence = state.expressionsPrecedence[node.type];

  if (nodePrecedence === NEEDS_PARENTHESES) {
    return true;
  }

  var parentNodePrecedence = state.expressionsPrecedence[parentNode.type];

  if (nodePrecedence !== parentNodePrecedence) {
    return !isRightHand &amp;&amp; nodePrecedence === 15 &amp;&amp; parentNodePrecedence === 14 &amp;&amp; parentNode.operator === &#039;**&#039; || nodePrecedence &lt; parentNodePrecedence;
  }

  if (nodePrecedence !== 13 &amp;&amp; nodePrecedence !== 14) {
    return false;
  }

  if (node.operator === &#039;**&#039; &amp;&amp; parentNode.operator === &#039;**&#039;) {
    return !isRightHand;
  }

  if (nodePrecedence === 13 &amp;&amp; parentNodePrecedence === 13 &amp;&amp; (node.operator === &#039;??&#039; || parentNode.operator === &#039;??&#039;)) {
    return true;
  }

  if (isRightHand) {
    return OPERATOR_PRECEDENCE[node.operator] &lt;= OPERATOR_PRECEDENCE[parentNode.operator];
  }

  return OPERATOR_PRECEDENCE[node.operator] &lt; OPERATOR_PRECEDENCE[parentNode.operator];
}

function formatExpression(state, node, parentNode, isRightHand) {
  var generator = state.generator;

  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
    state.write(&#039;(&#039;);
    generator[node.type](node, state);
    state.write(&#039;)&#039;);
  } else {
    generator[node.type](node, state);
  }
}

function reindent(state, text, indent, lineEnd) {
  var lines = text.split(&#039;\n&#039;);
  var end = lines.length - 1;
  state.write(lines[0].trim());

  if (end &gt; 0) {
    state.write(lineEnd);

    for (var i = 1; i &lt; end; i++) {
      state.write(indent + lines[i].trim() + lineEnd);
    }

    state.write(indent + lines[end].trim());
  }
}

function formatComments(state, comments, indent, lineEnd) {
  var length = comments.length;

  for (var i = 0; i &lt; length; i++) {
    var comment = comments[i];
    state.write(indent);

    if (comment.type[0] === &#039;L&#039;) {
      state.write(&#039;// &#039; + comment.value.trim() + &#039;\n&#039;, comment);
    } else {
      state.write(&#039;/*&#039;);
      reindent(state, comment.value, indent, lineEnd);
      state.write(&#039;*/&#039; + lineEnd);
    }
  }
}

function hasCallExpression(node) {
  var currentNode = node;

  while (currentNode != null) {
    var _currentNode = currentNode,
        type = _currentNode.type;

    if (type[0] === &#039;C&#039; &amp;&amp; type[1] === &#039;a&#039;) {
      return true;
    } else if (type[0] === &#039;M&#039; &amp;&amp; type[1] === &#039;e&#039; &amp;&amp; type[2] === &#039;m&#039;) {
      currentNode = currentNode.object;
    } else {
      return false;
    }
  }
}

function formatVariableDeclaration(state, node) {
  var generator = state.generator;
  var declarations = node.declarations;
  state.write(node.kind + &#039; &#039;);
  var length = declarations.length;

  if (length &gt; 0) {
    generator.VariableDeclarator(declarations[0], state);

    for (var i = 1; i &lt; length; i++) {
      state.write(&#039;, &#039;);
      generator.VariableDeclarator(declarations[i], state);
    }
  }
}

var ForInStatement, FunctionDeclaration, RestElement, BinaryExpression, ArrayExpression, BlockStatement;
var GENERATOR = {
  Program: function Program(node, state) {
    var indent = state.indent.repeat(state.indentLevel);
    var lineEnd = state.lineEnd,
        writeComments = state.writeComments;

    if (writeComments &amp;&amp; node.comments != null) {
      formatComments(state, node.comments, indent, lineEnd);
    }

    var statements = node.body;
    var length = statements.length;

    for (var i = 0; i &lt; length; i++) {
      var statement = statements[i];

      if (writeComments &amp;&amp; statement.comments != null) {
        formatComments(state, statement.comments, indent, lineEnd);
      }

      state.write(indent);
      this[statement.type](statement, state);
      state.write(lineEnd);
    }

    if (writeComments &amp;&amp; node.trailingComments != null) {
      formatComments(state, node.trailingComments, indent, lineEnd);
    }
  },
  BlockStatement: BlockStatement = function BlockStatement(node, state) {
    var indent = state.indent.repeat(state.indentLevel++);
    var lineEnd = state.lineEnd,
        writeComments = state.writeComments;
    var statementIndent = indent + state.indent;
    state.write(&#039;{&#039;);
    var statements = node.body;

    if (statements != null &amp;&amp; statements.length &gt; 0) {
      state.write(lineEnd);

      if (writeComments &amp;&amp; node.comments != null) {
        formatComments(state, node.comments, statementIndent, lineEnd);
      }

      var length = statements.length;

      for (var i = 0; i &lt; length; i++) {
        var statement = statements[i];

        if (writeComments &amp;&amp; statement.comments != null) {
          formatComments(state, statement.comments, statementIndent, lineEnd);
        }

        state.write(statementIndent);
        this[statement.type](statement, state);
        state.write(lineEnd);
      }

      state.write(indent);
    } else {
      if (writeComments &amp;&amp; node.comments != null) {
        state.write(lineEnd);
        formatComments(state, node.comments, statementIndent, lineEnd);
        state.write(indent);
      }
    }

    if (writeComments &amp;&amp; node.trailingComments != null) {
      formatComments(state, node.trailingComments, statementIndent, lineEnd);
    }

    state.write(&#039;}&#039;);
    state.indentLevel--;
  },
  ClassBody: BlockStatement,
  StaticBlock: function StaticBlock(node, state) {
    state.write(&#039;static &#039;);
    this.BlockStatement(node, state);
  },
  EmptyStatement: function EmptyStatement(node, state) {
    state.write(&#039;;&#039;);
  },
  ExpressionStatement: function ExpressionStatement(node, state) {
    var precedence = state.expressionsPrecedence[node.expression.type];

    if (precedence === NEEDS_PARENTHESES || precedence === 3 &amp;&amp; node.expression.left.type[0] === &#039;O&#039;) {
      state.write(&#039;(&#039;);
      this[node.expression.type](node.expression, state);
      state.write(&#039;)&#039;);
    } else {
      this[node.expression.type](node.expression, state);
    }

    state.write(&#039;;&#039;);
  },
  IfStatement: function IfStatement(node, state) {
    state.write(&#039;if (&#039;);
    this[node.test.type](node.test, state);
    state.write(&#039;) &#039;);
    this[node.consequent.type](node.consequent, state);

    if (node.alternate != null) {
      state.write(&#039; else &#039;);
      this[node.alternate.type](node.alternate, state);
    }
  },
  LabeledStatement: function LabeledStatement(node, state) {
    this[node.label.type](node.label, state);
    state.write(&#039;: &#039;);
    this[node.body.type](node.body, state);
  },
  BreakStatement: function BreakStatement(node, state) {
    state.write(&#039;break&#039;);

    if (node.label != null) {
      state.write(&#039; &#039;);
      this[node.label.type](node.label, state);
    }

    state.write(&#039;;&#039;);
  },
  ContinueStatement: function ContinueStatement(node, state) {
    state.write(&#039;continue&#039;);

    if (node.label != null) {
      state.write(&#039; &#039;);
      this[node.label.type](node.label, state);
    }

    state.write(&#039;;&#039;);
  },
  WithStatement: function WithStatement(node, state) {
    state.write(&#039;with (&#039;);
    this[node.object.type](node.object, state);
    state.write(&#039;) &#039;);
    this[node.body.type](node.body, state);
  },
  SwitchStatement: function SwitchStatement(node, state) {
    var indent = state.indent.repeat(state.indentLevel++);
    var lineEnd = state.lineEnd,
        writeComments = state.writeComments;
    state.indentLevel++;
    var caseIndent = indent + state.indent;
    var statementIndent = caseIndent + state.indent;
    state.write(&#039;switch (&#039;);
    this[node.discriminant.type](node.discriminant, state);
    state.write(&#039;) {&#039; + lineEnd);
    var occurences = node.cases;
    var occurencesCount = occurences.length;

    for (var i = 0; i &lt; occurencesCount; i++) {
      var occurence = occurences[i];

      if (writeComments &amp;&amp; occurence.comments != null) {
        formatComments(state, occurence.comments, caseIndent, lineEnd);
      }

      if (occurence.test) {
        state.write(caseIndent + &#039;case &#039;);
        this[occurence.test.type](occurence.test, state);
        state.write(&#039;:&#039; + lineEnd);
      } else {
        state.write(caseIndent + &#039;default:&#039; + lineEnd);
      }

      var consequent = occurence.consequent;
      var consequentCount = consequent.length;

      for (var _i = 0; _i &lt; consequentCount; _i++) {
        var statement = consequent[_i];

        if (writeComments &amp;&amp; statement.comments != null) {
          formatComments(state, statement.comments, statementIndent, lineEnd);
        }

        state.write(statementIndent);
        this[statement.type](statement, state);
        state.write(lineEnd);
      }
    }

    state.indentLevel -= 2;
    state.write(indent + &#039;}&#039;);
  },
  ReturnStatement: function ReturnStatement(node, state) {
    state.write(&#039;return&#039;);

    if (node.argument) {
      state.write(&#039; &#039;);
      this[node.argument.type](node.argument, state);
    }

    state.write(&#039;;&#039;);
  },
  ThrowStatement: function ThrowStatement(node, state) {
    state.write(&#039;throw &#039;);
    this[node.argument.type](node.argument, state);
    state.write(&#039;;&#039;);
  },
  TryStatement: function TryStatement(node, state) {
    state.write(&#039;try &#039;);
    this[node.block.type](node.block, state);

    if (node.handler) {
      var handler = node.handler;

      if (handler.param == null) {
        state.write(&#039; catch &#039;);
      } else {
        state.write(&#039; catch (&#039;);
        this[handler.param.type](handler.param, state);
        state.write(&#039;) &#039;);
      }

      this[handler.body.type](handler.body, state);
    }

    if (node.finalizer) {
      state.write(&#039; finally &#039;);
      this[node.finalizer.type](node.finalizer, state);
    }
  },
  WhileStatement: function WhileStatement(node, state) {
    state.write(&#039;while (&#039;);
    this[node.test.type](node.test, state);
    state.write(&#039;) &#039;);
    this[node.body.type](node.body, state);
  },
  DoWhileStatement: function DoWhileStatement(node, state) {
    state.write(&#039;do &#039;);
    this[node.body.type](node.body, state);
    state.write(&#039; while (&#039;);
    this[node.test.type](node.test, state);
    state.write(&#039;);&#039;);
  },
  ForStatement: function ForStatement(node, state) {
    state.write(&#039;for (&#039;);

    if (node.init != null) {
      var init = node.init;

      if (init.type[0] === &#039;V&#039;) {
        formatVariableDeclaration(state, init);
      } else {
        this[init.type](init, state);
      }
    }

    state.write(&#039;; &#039;);

    if (node.test) {
      this[node.test.type](node.test, state);
    }

    state.write(&#039;; &#039;);

    if (node.update) {
      this[node.update.type](node.update, state);
    }

    state.write(&#039;) &#039;);
    this[node.body.type](node.body, state);
  },
  ForInStatement: ForInStatement = function ForInStatement(node, state) {
    state.write(&quot;for &quot;.concat(node[&quot;await&quot;] ? &#039;await &#039; : &#039;&#039;, &quot;(&quot;));
    var left = node.left;

    if (left.type[0] === &#039;V&#039;) {
      formatVariableDeclaration(state, left);
    } else {
      this[left.type](left, state);
    }

    state.write(node.type[3] === &#039;I&#039; ? &#039; in &#039; : &#039; of &#039;);
    this[node.right.type](node.right, state);
    state.write(&#039;) &#039;);
    this[node.body.type](node.body, state);
  },
  ForOfStatement: ForInStatement,
  DebuggerStatement: function DebuggerStatement(node, state) {
    state.write(&#039;debugger;&#039;, node);
  },
  FunctionDeclaration: FunctionDeclaration = function FunctionDeclaration(node, state) {
    state.write((node.async ? &#039;async &#039; : &#039;&#039;) + (node.generator ? &#039;function* &#039; : &#039;function &#039;) + (node.id ? node.id.name : &#039;&#039;), node);
    formatSequence(state, node.params);
    state.write(&#039; &#039;);
    this[node.body.type](node.body, state);
  },
  FunctionExpression: FunctionDeclaration,
  VariableDeclaration: function VariableDeclaration(node, state) {
    formatVariableDeclaration(state, node);
    state.write(&#039;;&#039;);
  },
  VariableDeclarator: function VariableDeclarator(node, state) {
    this[node.id.type](node.id, state);

    if (node.init != null) {
      state.write(&#039; = &#039;);
      this[node.init.type](node.init, state);
    }
  },
  ClassDeclaration: function ClassDeclaration(node, state) {
    state.write(&#039;class &#039; + (node.id ? &quot;&quot;.concat(node.id.name, &quot; &quot;) : &#039;&#039;), node);

    if (node.superClass) {
      state.write(&#039;extends &#039;);
      var superClass = node.superClass;
      var type = superClass.type;
      var precedence = state.expressionsPrecedence[type];

      if ((type[0] !== &#039;C&#039; || type[1] !== &#039;l&#039; || type[5] !== &#039;E&#039;) &amp;&amp; (precedence === NEEDS_PARENTHESES || precedence &lt; state.expressionsPrecedence.ClassExpression)) {
        state.write(&#039;(&#039;);
        this[node.superClass.type](superClass, state);
        state.write(&#039;)&#039;);
      } else {
        this[superClass.type](superClass, state);
      }

      state.write(&#039; &#039;);
    }

    this.ClassBody(node.body, state);
  },
  ImportDeclaration: function ImportDeclaration(node, state) {
    state.write(&#039;import &#039;);
    var specifiers = node.specifiers,
        attributes = node.attributes;
    var length = specifiers.length;
    var i = 0;

    if (length &gt; 0) {
      for (; i &lt; length;) {
        if (i &gt; 0) {
          state.write(&#039;, &#039;);
        }

        var specifier = specifiers[i];
        var type = specifier.type[6];

        if (type === &#039;D&#039;) {
          state.write(specifier.local.name, specifier);
          i++;
        } else if (type === &#039;N&#039;) {
          state.write(&#039;* as &#039; + specifier.local.name, specifier);
          i++;
        } else {
          break;
        }
      }

      if (i &lt; length) {
        state.write(&#039;{&#039;);

        for (;;) {
          var _specifier = specifiers[i];
          var name = _specifier.imported.name;
          state.write(name, _specifier);

          if (name !== _specifier.local.name) {
            state.write(&#039; as &#039; + _specifier.local.name);
          }

          if (++i &lt; length) {
            state.write(&#039;, &#039;);
          } else {
            break;
          }
        }

        state.write(&#039;}&#039;);
      }

      state.write(&#039; from &#039;);
    }

    this.Literal(node.source, state);

    if (attributes &amp;&amp; attributes.length &gt; 0) {
      state.write(&#039; with { &#039;);

      for (var _i2 = 0; _i2 &lt; attributes.length; _i2++) {
        this.ImportAttribute(attributes[_i2], state);
        if (_i2 &lt; attributes.length - 1) state.write(&#039;, &#039;);
      }

      state.write(&#039; }&#039;);
    }

    state.write(&#039;;&#039;);
  },
  ImportAttribute: function ImportAttribute(node, state) {
    this.Identifier(node.key, state);
    state.write(&#039;: &#039;);
    this.Literal(node.value, state);
  },
  ImportExpression: function ImportExpression(node, state) {
    state.write(&#039;import(&#039;);
    this[node.source.type](node.source, state);
    state.write(&#039;)&#039;);
  },
  ExportDefaultDeclaration: function ExportDefaultDeclaration(node, state) {
    state.write(&#039;export default &#039;);
    this[node.declaration.type](node.declaration, state);

    if (state.expressionsPrecedence[node.declaration.type] != null &amp;&amp; node.declaration.type[0] !== &#039;F&#039;) {
      state.write(&#039;;&#039;);
    }
  },
  ExportNamedDeclaration: function ExportNamedDeclaration(node, state) {
    state.write(&#039;export &#039;);

    if (node.declaration) {
      this[node.declaration.type](node.declaration, state);
    } else {
      state.write(&#039;{&#039;);
      var specifiers = node.specifiers,
          length = specifiers.length;

      if (length &gt; 0) {
        for (var i = 0;;) {
          var specifier = specifiers[i];
          var name = specifier.local.name;
          state.write(name, specifier);

          if (name !== specifier.exported.name) {
            state.write(&#039; as &#039; + specifier.exported.name);
          }

          if (++i &lt; length) {
            state.write(&#039;, &#039;);
          } else {
            break;
          }
        }
      }

      state.write(&#039;}&#039;);

      if (node.source) {
        state.write(&#039; from &#039;);
        this.Literal(node.source, state);
      }

      if (node.attributes &amp;&amp; node.attributes.length &gt; 0) {
        state.write(&#039; with { &#039;);

        for (var _i3 = 0; _i3 &lt; node.attributes.length; _i3++) {
          this.ImportAttribute(node.attributes[_i3], state);
          if (_i3 &lt; node.attributes.length - 1) state.write(&#039;, &#039;);
        }

        state.write(&#039; }&#039;);
      }

      state.write(&#039;;&#039;);
    }
  },
  ExportAllDeclaration: function ExportAllDeclaration(node, state) {
    if (node.exported != null) {
      state.write(&#039;export * as &#039; + node.exported.name + &#039; from &#039;);
    } else {
      state.write(&#039;export * from &#039;);
    }

    this.Literal(node.source, state);

    if (node.attributes &amp;&amp; node.attributes.length &gt; 0) {
      state.write(&#039; with { &#039;);

      for (var i = 0; i &lt; node.attributes.length; i++) {
        this.ImportAttribute(node.attributes[i], state);
        if (i &lt; node.attributes.length - 1) state.write(&#039;, &#039;);
      }

      state.write(&#039; }&#039;);
    }

    state.write(&#039;;&#039;);
  },
  MethodDefinition: function MethodDefinition(node, state) {
    if (node[&quot;static&quot;]) {
      state.write(&#039;static &#039;);
    }

    var kind = node.kind[0];

    if (kind === &#039;g&#039; || kind === &#039;s&#039;) {
      state.write(node.kind + &#039; &#039;);
    }

    if (node.value.async) {
      state.write(&#039;async &#039;);
    }

    if (node.value.generator) {
      state.write(&#039;*&#039;);
    }

    if (node.computed) {
      state.write(&#039;[&#039;);
      this[node.key.type](node.key, state);
      state.write(&#039;]&#039;);
    } else {
      this[node.key.type](node.key, state);
    }

    formatSequence(state, node.value.params);
    state.write(&#039; &#039;);
    this[node.value.body.type](node.value.body, state);
  },
  ClassExpression: function ClassExpression(node, state) {
    this.ClassDeclaration(node, state);
  },
  ArrowFunctionExpression: function ArrowFunctionExpression(node, state) {
    state.write(node.async ? &#039;async &#039; : &#039;&#039;, node);
    var params = node.params;

    if (params != null) {
      if (params.length === 1 &amp;&amp; params[0].type[0] === &#039;I&#039;) {
        state.write(params[0].name, params[0]);
      } else {
        formatSequence(state, node.params);
      }
    }

    state.write(&#039; =&gt; &#039;);

    if (node.body.type[0] === &#039;O&#039;) {
      state.write(&#039;(&#039;);
      this.ObjectExpression(node.body, state);
      state.write(&#039;)&#039;);
    } else {
      this[node.body.type](node.body, state);
    }
  },
  ThisExpression: function ThisExpression(node, state) {
    state.write(&#039;this&#039;, node);
  },
  Super: function Super(node, state) {
    state.write(&#039;super&#039;, node);
  },
  RestElement: RestElement = function RestElement(node, state) {
    state.write(&#039;...&#039;);
    this[node.argument.type](node.argument, state);
  },
  SpreadElement: RestElement,
  YieldExpression: function YieldExpression(node, state) {
    state.write(node.delegate ? &#039;yield*&#039; : &#039;yield&#039;);

    if (node.argument) {
      state.write(&#039; &#039;);
      this[node.argument.type](node.argument, state);
    }
  },
  AwaitExpression: function AwaitExpression(node, state) {
    state.write(&#039;await &#039;, node);
    formatExpression(state, node.argument, node);
  },
  TemplateLiteral: function TemplateLiteral(node, state) {
    var quasis = node.quasis,
        expressions = node.expressions;
    state.write(&#039;`&#039;);
    var length = expressions.length;

    for (var i = 0; i &lt; length; i++) {
      var expression = expressions[i];
      var _quasi = quasis[i];
      state.write(_quasi.value.raw, _quasi);
      state.write(&#039;${&#039;);
      this[expression.type](expression, state);
      state.write(&#039;}&#039;);
    }

    var quasi = quasis[quasis.length - 1];
    state.write(quasi.value.raw, quasi);
    state.write(&#039;`&#039;);
  },
  TemplateElement: function TemplateElement(node, state) {
    state.write(node.value.raw, node);
  },
  TaggedTemplateExpression: function TaggedTemplateExpression(node, state) {
    formatExpression(state, node.tag, node);
    this[node.quasi.type](node.quasi, state);
  },
  ArrayExpression: ArrayExpression = function ArrayExpression(node, state) {
    state.write(&#039;[&#039;);

    if (node.elements.length &gt; 0) {
      var elements = node.elements,
          length = elements.length;

      for (var i = 0;;) {
        var element = elements[i];

        if (element != null) {
          this[element.type](element, state);
        }

        if (++i &lt; length) {
          state.write(&#039;, &#039;);
        } else {
          if (element == null) {
            state.write(&#039;, &#039;);
          }

          break;
        }
      }
    }

    state.write(&#039;]&#039;);
  },
  ArrayPattern: ArrayExpression,
  ObjectExpression: function ObjectExpression(node, state) {
    var indent = state.indent.repeat(state.indentLevel++);
    var lineEnd = state.lineEnd,
        writeComments = state.writeComments;
    var propertyIndent = indent + state.indent;
    state.write(&#039;{&#039;);

    if (node.properties.length &gt; 0) {
      state.write(lineEnd);

      if (writeComments &amp;&amp; node.comments != null) {
        formatComments(state, node.comments, propertyIndent, lineEnd);
      }

      var comma = &#039;,&#039; + lineEnd;
      var properties = node.properties,
          length = properties.length;

      for (var i = 0;;) {
        var property = properties[i];

        if (writeComments &amp;&amp; property.comments != null) {
          formatComments(state, property.comments, propertyIndent, lineEnd);
        }

        state.write(propertyIndent);
        this[property.type](property, state);

        if (++i &lt; length) {
          state.write(comma);
        } else {
          break;
        }
      }

      state.write(lineEnd);

      if (writeComments &amp;&amp; node.trailingComments != null) {
        formatComments(state, node.trailingComments, propertyIndent, lineEnd);
      }

      state.write(indent + &#039;}&#039;);
    } else if (writeComments) {
      if (node.comments != null) {
        state.write(lineEnd);
        formatComments(state, node.comments, propertyIndent, lineEnd);

        if (node.trailingComments != null) {
          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
        }

        state.write(indent + &#039;}&#039;);
      } else if (node.trailingComments != null) {
        state.write(lineEnd);
        formatComments(state, node.trailingComments, propertyIndent, lineEnd);
        state.write(indent + &#039;}&#039;);
      } else {
        state.write(&#039;}&#039;);
      }
    } else {
      state.write(&#039;}&#039;);
    }

    state.indentLevel--;
  },
  Property: function Property(node, state) {
    if (node.method || node.kind[0] !== &#039;i&#039;) {
      this.MethodDefinition(node, state);
    } else {
      if (!node.shorthand) {
        if (node.computed) {
          state.write(&#039;[&#039;);
          this[node.key.type](node.key, state);
          state.write(&#039;]&#039;);
        } else {
          this[node.key.type](node.key, state);
        }

        state.write(&#039;: &#039;);
      }

      this[node.value.type](node.value, state);
    }
  },
  PropertyDefinition: function PropertyDefinition(node, state) {
    if (node[&quot;static&quot;]) {
      state.write(&#039;static &#039;);
    }

    if (node.computed) {
      state.write(&#039;[&#039;);
    }

    this[node.key.type](node.key, state);

    if (node.computed) {
      state.write(&#039;]&#039;);
    }

    if (node.value == null) {
      if (node.key.type[0] !== &#039;F&#039;) {
        state.write(&#039;;&#039;);
      }

      return;
    }

    state.write(&#039; = &#039;);
    this[node.value.type](node.value, state);
    state.write(&#039;;&#039;);
  },
  ObjectPattern: function ObjectPattern(node, state) {
    state.write(&#039;{&#039;);

    if (node.properties.length &gt; 0) {
      var properties = node.properties,
          length = properties.length;

      for (var i = 0;;) {
        this[properties[i].type](properties[i], state);

        if (++i &lt; length) {
          state.write(&#039;, &#039;);
        } else {
          break;
        }
      }
    }

    state.write(&#039;}&#039;);
  },
  SequenceExpression: function SequenceExpression(node, state) {
    formatSequence(state, node.expressions);
  },
  UnaryExpression: function UnaryExpression(node, state) {
    if (node.prefix) {
      var operator = node.operator,
          argument = node.argument,
          type = node.argument.type;
      state.write(operator);
      var needsParentheses = expressionNeedsParenthesis(state, argument, node);

      if (!needsParentheses &amp;&amp; (operator.length &gt; 1 || type[0] === &#039;U&#039; &amp;&amp; (type[1] === &#039;n&#039; || type[1] === &#039;p&#039;) &amp;&amp; argument.prefix &amp;&amp; argument.operator[0] === operator &amp;&amp; (operator === &#039;+&#039; || operator === &#039;-&#039;))) {
        state.write(&#039; &#039;);
      }

      if (needsParentheses) {
        state.write(operator.length &gt; 1 ? &#039; (&#039; : &#039;(&#039;);
        this[type](argument, state);
        state.write(&#039;)&#039;);
      } else {
        this[type](argument, state);
      }
    } else {
      this[node.argument.type](node.argument, state);
      state.write(node.operator);
    }
  },
  UpdateExpression: function UpdateExpression(node, state) {
    if (node.prefix) {
      state.write(node.operator);
      this[node.argument.type](node.argument, state);
    } else {
      this[node.argument.type](node.argument, state);
      state.write(node.operator);
    }
  },
  AssignmentExpression: function AssignmentExpression(node, state) {
    this[node.left.type](node.left, state);
    state.write(&#039; &#039; + node.operator + &#039; &#039;);
    this[node.right.type](node.right, state);
  },
  AssignmentPattern: function AssignmentPattern(node, state) {
    this[node.left.type](node.left, state);
    state.write(&#039; = &#039;);
    this[node.right.type](node.right, state);
  },
  BinaryExpression: BinaryExpression = function BinaryExpression(node, state) {
    var isIn = node.operator === &#039;in&#039;;

    if (isIn) {
      state.write(&#039;(&#039;);
    }

    formatExpression(state, node.left, node, false);
    state.write(&#039; &#039; + node.operator + &#039; &#039;);
    formatExpression(state, node.right, node, true);

    if (isIn) {
      state.write(&#039;)&#039;);
    }
  },
  LogicalExpression: BinaryExpression,
  ConditionalExpression: function ConditionalExpression(node, state) {
    var test = node.test;
    var precedence = state.expressionsPrecedence[test.type];

    if (precedence === NEEDS_PARENTHESES || precedence &lt;= state.expressionsPrecedence.ConditionalExpression) {
      state.write(&#039;(&#039;);
      this[test.type](test, state);
      state.write(&#039;)&#039;);
    } else {
      this[test.type](test, state);
    }

    state.write(&#039; ? &#039;);
    this[node.consequent.type](node.consequent, state);
    state.write(&#039; : &#039;);
    this[node.alternate.type](node.alternate, state);
  },
  NewExpression: function NewExpression(node, state) {
    state.write(&#039;new &#039;);
    var precedence = state.expressionsPrecedence[node.callee.type];

    if (precedence === NEEDS_PARENTHESES || precedence &lt; state.expressionsPrecedence.CallExpression || hasCallExpression(node.callee)) {
      state.write(&#039;(&#039;);
      this[node.callee.type](node.callee, state);
      state.write(&#039;)&#039;);
    } else {
      this[node.callee.type](node.callee, state);
    }

    formatSequence(state, node[&#039;arguments&#039;]);
  },
  CallExpression: function CallExpression(node, state) {
    var precedence = state.expressionsPrecedence[node.callee.type];

    if (precedence === NEEDS_PARENTHESES || precedence &lt; state.expressionsPrecedence.CallExpression) {
      state.write(&#039;(&#039;);
      this[node.callee.type](node.callee, state);
      state.write(&#039;)&#039;);
    } else {
      this[node.callee.type](node.callee, state);
    }

    if (node.optional) {
      state.write(&#039;?.&#039;);
    }

    formatSequence(state, node[&#039;arguments&#039;]);
  },
  ChainExpression: function ChainExpression(node, state) {
    this[node.expression.type](node.expression, state);
  },
  MemberExpression: function MemberExpression(node, state) {
    var precedence = state.expressionsPrecedence[node.object.type];

    if (precedence === NEEDS_PARENTHESES || precedence &lt; state.expressionsPrecedence.MemberExpression) {
      state.write(&#039;(&#039;);
      this[node.object.type](node.object, state);
      state.write(&#039;)&#039;);
    } else {
      this[node.object.type](node.object, state);
    }

    if (node.computed) {
      if (node.optional) {
        state.write(&#039;?.&#039;);
      }

      state.write(&#039;[&#039;);
      this[node.property.type](node.property, state);
      state.write(&#039;]&#039;);
    } else {
      if (node.optional) {
        state.write(&#039;?.&#039;);
      } else {
        state.write(&#039;.&#039;);
      }

      this[node.property.type](node.property, state);
    }
  },
  MetaProperty: function MetaProperty(node, state) {
    state.write(node.meta.name + &#039;.&#039; + node.property.name, node);
  },
  Identifier: function Identifier(node, state) {
    state.write(node.name, node);
  },
  PrivateIdentifier: function PrivateIdentifier(node, state) {
    state.write(&quot;#&quot;.concat(node.name), node);
  },
  Literal: function Literal(node, state) {
    if (node.raw != null) {
      state.write(node.raw, node);
    } else if (node.regex != null) {
      this.RegExpLiteral(node, state);
    } else if (node.bigint != null) {
      state.write(node.bigint + &#039;n&#039;, node);
    } else {
      state.write(stringify(node.value), node);
    }
  },
  RegExpLiteral: function RegExpLiteral(node, state) {
    var regex = node.regex;
    state.write(&quot;/&quot;.concat(regex.pattern, &quot;/&quot;).concat(regex.flags), node);
  }
};
exports.GENERATOR = GENERATOR;
var EMPTY_OBJECT = {};
var baseGenerator = GENERATOR;
exports.baseGenerator = baseGenerator;

var State = function () {
  function State(options) {
    _classCallCheck(this, State);

    var setup = options == null ? EMPTY_OBJECT : options;
    this.output = &#039;&#039;;

    if (setup.output != null) {
      this.output = setup.output;
      this.write = this.writeToStream;
    } else {
      this.output = &#039;&#039;;
    }

    this.generator = setup.generator != null ? setup.generator : GENERATOR;
    this.expressionsPrecedence = setup.expressionsPrecedence != null ? setup.expressionsPrecedence : EXPRESSIONS_PRECEDENCE;
    this.indent = setup.indent != null ? setup.indent : &#039;  &#039;;
    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : &#039;\n&#039;;
    this.indentLevel = setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
    this.writeComments = setup.comments ? setup.comments : false;

    if (setup.sourceMap != null) {
      this.write = setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
      this.sourceMap = setup.sourceMap;
      this.line = 1;
      this.column = 0;
      this.lineEndSize = this.lineEnd.split(&#039;\n&#039;).length - 1;
      this.mapping = {
        original: null,
        generated: this,
        name: undefined,
        source: setup.sourceMap.file || setup.sourceMap._file
      };
    }
  }

  _createClass(State, [{
    key: &quot;write&quot;,
    value: function write(code) {
      this.output += code;
    }
  }, {
    key: &quot;writeToStream&quot;,
    value: function writeToStream(code) {
      this.output.write(code);
    }
  }, {
    key: &quot;writeAndMap&quot;,
    value: function writeAndMap(code, node) {
      this.output += code;
      this.map(code, node);
    }
  }, {
    key: &quot;writeToStreamAndMap&quot;,
    value: function writeToStreamAndMap(code, node) {
      this.output.write(code);
      this.map(code, node);
    }
  }, {
    key: &quot;map&quot;,
    value: function map(code, node) {
      if (node != null) {
        var type = node.type;

        if (type[0] === &#039;L&#039; &amp;&amp; type[2] === &#039;n&#039;) {
          this.column = 0;
          this.line++;
          return;
        }

        if (node.loc != null) {
          var mapping = this.mapping;
          mapping.original = node.loc.start;
          mapping.name = node.name;
          this.sourceMap.addMapping(mapping);
        }

        if (type[0] === &#039;T&#039; &amp;&amp; type[8] === &#039;E&#039; || type[0] === &#039;L&#039; &amp;&amp; type[1] === &#039;i&#039; &amp;&amp; typeof node.value === &#039;string&#039;) {
          var _length = code.length;
          var column = this.column,
              line = this.line;

          for (var i = 0; i &lt; _length; i++) {
            if (code[i] === &#039;\n&#039;) {
              column = 0;
              line++;
            } else {
              column++;
            }
          }

          this.column = column;
          this.line = line;
          return;
        }
      }

      var length = code.length;
      var lineEnd = this.lineEnd;

      if (length &gt; 0) {
        if (this.lineEndSize &gt; 0 &amp;&amp; (lineEnd.length === 1 ? code[length - 1] === lineEnd : code.endsWith(lineEnd))) {
          this.line += this.lineEndSize;
          this.column = 0;
        } else {
          this.column += length;
        }
      }
    }
  }, {
    key: &quot;toString&quot;,
    value: function toString() {
      return this.output;
    }
  }]);

  return State;
}();

function generate(node, options) {
  var state = new State(options);
  state.generator[node.type](node, state);
  return state.output;
}

//# sourceMappingURL=astring.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
