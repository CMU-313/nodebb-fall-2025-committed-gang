<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/bl/test/indexOf.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/bl/test/indexOf.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">48.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">493</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">96.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.66</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

const tape = require(&#039;tape&#039;)
const BufferList = require(&#039;../&#039;)
const { Buffer } = require(&#039;buffer&#039;)

tape(&#039;indexOf single byte needle&#039;, (t) =&gt; {
  const bl = new BufferList([&#039;abcdefg&#039;, &#039;abcdefg&#039;, &#039;12345&#039;])

  t.equal(bl.indexOf(&#039;e&#039;), 4)
  t.equal(bl.indexOf(&#039;e&#039;, 5), 11)
  t.equal(bl.indexOf(&#039;e&#039;, 12), -1)
  t.equal(bl.indexOf(&#039;5&#039;), 18)

  t.end()
})

tape(&#039;indexOf multiple byte needle&#039;, (t) =&gt; {
  const bl = new BufferList([&#039;abcdefg&#039;, &#039;abcdefg&#039;])

  t.equal(bl.indexOf(&#039;ef&#039;), 4)
  t.equal(bl.indexOf(&#039;ef&#039;, 5), 11)

  t.end()
})

tape(&#039;indexOf multiple byte needles across buffer boundaries&#039;, (t) =&gt; {
  const bl = new BufferList([&#039;abcdefg&#039;, &#039;abcdefg&#039;])

  t.equal(bl.indexOf(&#039;fgabc&#039;), 5)

  t.end()
})

tape(&#039;indexOf takes a Uint8Array search&#039;, (t) =&gt; {
  const bl = new BufferList([&#039;abcdefg&#039;, &#039;abcdefg&#039;])
  const search = new Uint8Array([102, 103, 97, 98, 99]) // fgabc

  t.equal(bl.indexOf(search), 5)

  t.end()
})

tape(&#039;indexOf takes a buffer list search&#039;, (t) =&gt; {
  const bl = new BufferList([&#039;abcdefg&#039;, &#039;abcdefg&#039;])
  const search = new BufferList(&#039;fgabc&#039;)

  t.equal(bl.indexOf(search), 5)

  t.end()
})

tape(&#039;indexOf a zero byte needle&#039;, (t) =&gt; {
  const b = new BufferList(&#039;abcdef&#039;)
  const bufEmpty = Buffer.from(&#039;&#039;)

  t.equal(b.indexOf(&#039;&#039;), 0)
  t.equal(b.indexOf(&#039;&#039;, 1), 1)
  t.equal(b.indexOf(&#039;&#039;, b.length + 1), b.length)
  t.equal(b.indexOf(&#039;&#039;, Infinity), b.length)
  t.equal(b.indexOf(bufEmpty), 0)
  t.equal(b.indexOf(bufEmpty, 1), 1)
  t.equal(b.indexOf(bufEmpty, b.length + 1), b.length)
  t.equal(b.indexOf(bufEmpty, Infinity), b.length)

  t.end()
})

tape(&#039;indexOf buffers smaller and larger than the needle&#039;, (t) =&gt; {
  const bl = new BufferList([&#039;abcdefg&#039;, &#039;a&#039;, &#039;bcdefg&#039;, &#039;a&#039;, &#039;bcfgab&#039;])

  t.equal(bl.indexOf(&#039;fgabc&#039;), 5)
  t.equal(bl.indexOf(&#039;fgabc&#039;, 6), 12)
  t.equal(bl.indexOf(&#039;fgabc&#039;, 13), -1)

  t.end()
})

// only present in node 6+
;(process.version.substr(1).split(&#039;.&#039;)[0] &gt;= 6) &amp;&amp; tape(&#039;indexOf latin1 and binary encoding&#039;, (t) =&gt; {
  const b = new BufferList(&#039;abcdef&#039;)

  // test latin1 encoding
  t.equal(
    new BufferList(Buffer.from(b.toString(&#039;latin1&#039;), &#039;latin1&#039;))
      .indexOf(&#039;d&#039;, 0, &#039;latin1&#039;),
    3
  )
  t.equal(
    new BufferList(Buffer.from(b.toString(&#039;latin1&#039;), &#039;latin1&#039;))
      .indexOf(Buffer.from(&#039;d&#039;, &#039;latin1&#039;), 0, &#039;latin1&#039;),
    3
  )
  t.equal(
    new BufferList(Buffer.from(&#039;aa\u00e8aa&#039;, &#039;latin1&#039;))
      .indexOf(&#039;\u00e8&#039;, &#039;latin1&#039;),
    2
  )
  t.equal(
    new BufferList(Buffer.from(&#039;\u00e8&#039;, &#039;latin1&#039;))
      .indexOf(&#039;\u00e8&#039;, &#039;latin1&#039;),
    0
  )
  t.equal(
    new BufferList(Buffer.from(&#039;\u00e8&#039;, &#039;latin1&#039;))
      .indexOf(Buffer.from(&#039;\u00e8&#039;, &#039;latin1&#039;), &#039;latin1&#039;),
    0
  )

  // test binary encoding
  t.equal(
    new BufferList(Buffer.from(b.toString(&#039;binary&#039;), &#039;binary&#039;))
      .indexOf(&#039;d&#039;, 0, &#039;binary&#039;),
    3
  )
  t.equal(
    new BufferList(Buffer.from(b.toString(&#039;binary&#039;), &#039;binary&#039;))
      .indexOf(Buffer.from(&#039;d&#039;, &#039;binary&#039;), 0, &#039;binary&#039;),
    3
  )
  t.equal(
    new BufferList(Buffer.from(&#039;aa\u00e8aa&#039;, &#039;binary&#039;))
      .indexOf(&#039;\u00e8&#039;, &#039;binary&#039;),
    2
  )
  t.equal(
    new BufferList(Buffer.from(&#039;\u00e8&#039;, &#039;binary&#039;))
      .indexOf(&#039;\u00e8&#039;, &#039;binary&#039;),
    0
  )
  t.equal(
    new BufferList(Buffer.from(&#039;\u00e8&#039;, &#039;binary&#039;))
      .indexOf(Buffer.from(&#039;\u00e8&#039;, &#039;binary&#039;), &#039;binary&#039;),
    0
  )

  t.end()
})

tape(&#039;indexOf the entire nodejs10 buffer test suite&#039;, (t) =&gt; {
  const b = new BufferList(&#039;abcdef&#039;)
  const bufA = Buffer.from(&#039;a&#039;)
  const bufBc = Buffer.from(&#039;bc&#039;)
  const bufF = Buffer.from(&#039;f&#039;)
  const bufZ = Buffer.from(&#039;z&#039;)

  const stringComparison = &#039;abcdef&#039;

  t.equal(b.indexOf(&#039;a&#039;), 0)
  t.equal(b.indexOf(&#039;a&#039;, 1), -1)
  t.equal(b.indexOf(&#039;a&#039;, -1), -1)
  t.equal(b.indexOf(&#039;a&#039;, -4), -1)
  t.equal(b.indexOf(&#039;a&#039;, -b.length), 0)
  t.equal(b.indexOf(&#039;a&#039;, NaN), 0)
  t.equal(b.indexOf(&#039;a&#039;, -Infinity), 0)
  t.equal(b.indexOf(&#039;a&#039;, Infinity), -1)
  t.equal(b.indexOf(&#039;bc&#039;), 1)
  t.equal(b.indexOf(&#039;bc&#039;, 2), -1)
  t.equal(b.indexOf(&#039;bc&#039;, -1), -1)
  t.equal(b.indexOf(&#039;bc&#039;, -3), -1)
  t.equal(b.indexOf(&#039;bc&#039;, -5), 1)
  t.equal(b.indexOf(&#039;bc&#039;, NaN), 1)
  t.equal(b.indexOf(&#039;bc&#039;, -Infinity), 1)
  t.equal(b.indexOf(&#039;bc&#039;, Infinity), -1)
  t.equal(b.indexOf(&#039;f&#039;), b.length - 1)
  t.equal(b.indexOf(&#039;z&#039;), -1)

  // empty search tests
  t.equal(b.indexOf(bufA), 0)
  t.equal(b.indexOf(bufA, 1), -1)
  t.equal(b.indexOf(bufA, -1), -1)
  t.equal(b.indexOf(bufA, -4), -1)
  t.equal(b.indexOf(bufA, -b.length), 0)
  t.equal(b.indexOf(bufA, NaN), 0)
  t.equal(b.indexOf(bufA, -Infinity), 0)
  t.equal(b.indexOf(bufA, Infinity), -1)
  t.equal(b.indexOf(bufBc), 1)
  t.equal(b.indexOf(bufBc, 2), -1)
  t.equal(b.indexOf(bufBc, -1), -1)
  t.equal(b.indexOf(bufBc, -3), -1)
  t.equal(b.indexOf(bufBc, -5), 1)
  t.equal(b.indexOf(bufBc, NaN), 1)
  t.equal(b.indexOf(bufBc, -Infinity), 1)
  t.equal(b.indexOf(bufBc, Infinity), -1)
  t.equal(b.indexOf(bufF), b.length - 1)
  t.equal(b.indexOf(bufZ), -1)
  t.equal(b.indexOf(0x61), 0)
  t.equal(b.indexOf(0x61, 1), -1)
  t.equal(b.indexOf(0x61, -1), -1)
  t.equal(b.indexOf(0x61, -4), -1)
  t.equal(b.indexOf(0x61, -b.length), 0)
  t.equal(b.indexOf(0x61, NaN), 0)
  t.equal(b.indexOf(0x61, -Infinity), 0)
  t.equal(b.indexOf(0x61, Infinity), -1)
  t.equal(b.indexOf(0x0), -1)

  // test offsets
  t.equal(b.indexOf(&#039;d&#039;, 2), 3)
  t.equal(b.indexOf(&#039;f&#039;, 5), 5)
  t.equal(b.indexOf(&#039;f&#039;, -1), 5)
  t.equal(b.indexOf(&#039;f&#039;, 6), -1)

  t.equal(b.indexOf(Buffer.from(&#039;d&#039;), 2), 3)
  t.equal(b.indexOf(Buffer.from(&#039;f&#039;), 5), 5)
  t.equal(b.indexOf(Buffer.from(&#039;f&#039;), -1), 5)
  t.equal(b.indexOf(Buffer.from(&#039;f&#039;), 6), -1)

  t.equal(Buffer.from(&#039;ff&#039;).indexOf(Buffer.from(&#039;f&#039;), 1, &#039;ucs2&#039;), -1)

  // test invalid and uppercase encoding
  t.equal(b.indexOf(&#039;b&#039;, &#039;utf8&#039;), 1)
  t.equal(b.indexOf(&#039;b&#039;, &#039;UTF8&#039;), 1)
  t.equal(b.indexOf(&#039;62&#039;, &#039;HEX&#039;), 1)
  t.throws(() =&gt; b.indexOf(&#039;bad&#039;, &#039;enc&#039;), TypeError)

  // test hex encoding
  t.equal(
    Buffer.from(b.toString(&#039;hex&#039;), &#039;hex&#039;)
      .indexOf(&#039;64&#039;, 0, &#039;hex&#039;),
    3
  )
  t.equal(
    Buffer.from(b.toString(&#039;hex&#039;), &#039;hex&#039;)
      .indexOf(Buffer.from(&#039;64&#039;, &#039;hex&#039;), 0, &#039;hex&#039;),
    3
  )

  // test base64 encoding
  t.equal(
    Buffer.from(b.toString(&#039;base64&#039;), &#039;base64&#039;)
      .indexOf(&#039;ZA==&#039;, 0, &#039;base64&#039;),
    3
  )
  t.equal(
    Buffer.from(b.toString(&#039;base64&#039;), &#039;base64&#039;)
      .indexOf(Buffer.from(&#039;ZA==&#039;, &#039;base64&#039;), 0, &#039;base64&#039;),
    3
  )

  // test ascii encoding
  t.equal(
    Buffer.from(b.toString(&#039;ascii&#039;), &#039;ascii&#039;)
      .indexOf(&#039;d&#039;, 0, &#039;ascii&#039;),
    3
  )
  t.equal(
    Buffer.from(b.toString(&#039;ascii&#039;), &#039;ascii&#039;)
      .indexOf(Buffer.from(&#039;d&#039;, &#039;ascii&#039;), 0, &#039;ascii&#039;),
    3
  )

  // test optional offset with passed encoding
  t.equal(Buffer.from(&#039;aaaa0&#039;).indexOf(&#039;30&#039;, &#039;hex&#039;), 4)
  t.equal(Buffer.from(&#039;aaaa00a&#039;).indexOf(&#039;3030&#039;, &#039;hex&#039;), 4)

  {
    // test usc2 encoding
    const twoByteString = Buffer.from(&#039;\u039a\u0391\u03a3\u03a3\u0395&#039;, &#039;ucs2&#039;)

    t.equal(8, twoByteString.indexOf(&#039;\u0395&#039;, 4, &#039;ucs2&#039;))
    t.equal(6, twoByteString.indexOf(&#039;\u03a3&#039;, -4, &#039;ucs2&#039;))
    t.equal(4, twoByteString.indexOf(&#039;\u03a3&#039;, -6, &#039;ucs2&#039;))
    t.equal(4, twoByteString.indexOf(
      Buffer.from(&#039;\u03a3&#039;, &#039;ucs2&#039;), -6, &#039;ucs2&#039;))
    t.equal(-1, twoByteString.indexOf(&#039;\u03a3&#039;, -2, &#039;ucs2&#039;))
  }

  const mixedByteStringUcs2 =
      Buffer.from(&#039;\u039a\u0391abc\u03a3\u03a3\u0395&#039;, &#039;ucs2&#039;)

  t.equal(6, mixedByteStringUcs2.indexOf(&#039;bc&#039;, 0, &#039;ucs2&#039;))
  t.equal(10, mixedByteStringUcs2.indexOf(&#039;\u03a3&#039;, 0, &#039;ucs2&#039;))
  t.equal(-1, mixedByteStringUcs2.indexOf(&#039;\u0396&#039;, 0, &#039;ucs2&#039;))

  t.equal(
    6, mixedByteStringUcs2.indexOf(Buffer.from(&#039;bc&#039;, &#039;ucs2&#039;), 0, &#039;ucs2&#039;))
  t.equal(
    10, mixedByteStringUcs2.indexOf(Buffer.from(&#039;\u03a3&#039;, &#039;ucs2&#039;), 0, &#039;ucs2&#039;))
  t.equal(
    -1, mixedByteStringUcs2.indexOf(Buffer.from(&#039;\u0396&#039;, &#039;ucs2&#039;), 0, &#039;ucs2&#039;))

  {
    const twoByteString = Buffer.from(&#039;\u039a\u0391\u03a3\u03a3\u0395&#039;, &#039;ucs2&#039;)

    // Test single char pattern
    t.equal(0, twoByteString.indexOf(&#039;\u039a&#039;, 0, &#039;ucs2&#039;))
    let index = twoByteString.indexOf(&#039;\u0391&#039;, 0, &#039;ucs2&#039;)
    t.equal(2, index, `Alpha - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u03a3&#039;, 0, &#039;ucs2&#039;)
    t.equal(4, index, `First Sigma - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u03a3&#039;, 6, &#039;ucs2&#039;)
    t.equal(6, index, `Second Sigma - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u0395&#039;, 0, &#039;ucs2&#039;)
    t.equal(8, index, `Epsilon - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u0392&#039;, 0, &#039;ucs2&#039;)
    t.equal(-1, index, `Not beta - at index ${index}`)

    // Test multi-char pattern
    index = twoByteString.indexOf(&#039;\u039a\u0391&#039;, 0, &#039;ucs2&#039;)
    t.equal(0, index, `Lambda Alpha - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u0391\u03a3&#039;, 0, &#039;ucs2&#039;)
    t.equal(2, index, `Alpha Sigma - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u03a3\u03a3&#039;, 0, &#039;ucs2&#039;)
    t.equal(4, index, `Sigma Sigma - at index ${index}`)
    index = twoByteString.indexOf(&#039;\u03a3\u0395&#039;, 0, &#039;ucs2&#039;)
    t.equal(6, index, `Sigma Epsilon - at index ${index}`)
  }

  const mixedByteStringUtf8 = Buffer.from(&#039;\u039a\u0391abc\u03a3\u03a3\u0395&#039;)

  t.equal(5, mixedByteStringUtf8.indexOf(&#039;bc&#039;))
  t.equal(5, mixedByteStringUtf8.indexOf(&#039;bc&#039;, 5))
  t.equal(5, mixedByteStringUtf8.indexOf(&#039;bc&#039;, -8))
  t.equal(7, mixedByteStringUtf8.indexOf(&#039;\u03a3&#039;))
  t.equal(-1, mixedByteStringUtf8.indexOf(&#039;\u0396&#039;))

  // Test complex string indexOf algorithms. Only trigger for long strings.
  // Long string that isn&#039;t a simple repeat of a shorter string.
  let longString = &#039;A&#039;
  for (let i = 66; i &lt; 76; i++) { // from &#039;B&#039; to &#039;K&#039;
    longString = longString + String.fromCharCode(i) + longString
  }

  const longBufferString = Buffer.from(longString)

  // pattern of 15 chars, repeated every 16 chars in long
  let pattern = &#039;ABACABADABACABA&#039;
  for (let i = 0; i &lt; longBufferString.length - pattern.length; i += 7) {
    const index = longBufferString.indexOf(pattern, i)
    t.equal((i + 15) &amp; ~0xf, index,
      `Long ABACABA...-string at index ${i}`)
  }

  let index = longBufferString.indexOf(&#039;AJABACA&#039;)
  t.equal(510, index, `Long AJABACA, First J - at index ${index}`)
  index = longBufferString.indexOf(&#039;AJABACA&#039;, 511)
  t.equal(1534, index, `Long AJABACA, Second J - at index ${index}`)

  pattern = &#039;JABACABADABACABA&#039;
  index = longBufferString.indexOf(pattern)
  t.equal(511, index, `Long JABACABA..., First J - at index ${index}`)
  index = longBufferString.indexOf(pattern, 512)
  t.equal(
    1535, index, `Long JABACABA..., Second J - at index ${index}`)

  // Search for a non-ASCII string in a pure ASCII string.
  const asciiString = Buffer.from(
    &#039;somethingnotatallsinisterwhichalsoworks&#039;)
  t.equal(-1, asciiString.indexOf(&#039;\x2061&#039;))
  t.equal(3, asciiString.indexOf(&#039;eth&#039;, 0))

  // Search in string containing many non-ASCII chars.
  const allCodePoints = []
  for (let i = 0; i &lt; 65536; i++) {
    allCodePoints[i] = i
  }

  const allCharsString = String.fromCharCode.apply(String, allCodePoints)
  const allCharsBufferUtf8 = Buffer.from(allCharsString)
  const allCharsBufferUcs2 = Buffer.from(allCharsString, &#039;ucs2&#039;)

  // Search for string long enough to trigger complex search with ASCII pattern
  // and UC16 subject.
  t.equal(-1, allCharsBufferUtf8.indexOf(&#039;notfound&#039;))
  t.equal(-1, allCharsBufferUcs2.indexOf(&#039;notfound&#039;))

  // Needle is longer than haystack, but only because it&#039;s encoded as UTF-16
  t.equal(Buffer.from(&#039;aaaa&#039;).indexOf(&#039;a&#039;.repeat(4), &#039;ucs2&#039;), -1)

  t.equal(Buffer.from(&#039;aaaa&#039;).indexOf(&#039;a&#039;.repeat(4), &#039;utf8&#039;), 0)
  t.equal(Buffer.from(&#039;aaaa&#039;).indexOf(&#039;你好&#039;, &#039;ucs2&#039;), -1)

  // Haystack has odd length, but the needle is UCS2.
  t.equal(Buffer.from(&#039;aaaaa&#039;).indexOf(&#039;b&#039;, &#039;ucs2&#039;), -1)

  {
    // Find substrings in Utf8.
    const lengths = [1, 3, 15] // Single char, simple and complex.
    const indices = [0x5, 0x60, 0x400, 0x680, 0x7ee, 0xFF02, 0x16610, 0x2f77b]
    for (let lengthIndex = 0; lengthIndex &lt; lengths.length; lengthIndex++) {
      for (let i = 0; i &lt; indices.length; i++) {
        const index = indices[i]
        let length = lengths[lengthIndex]

        if (index + length &gt; 0x7F) {
          length = 2 * length
        }

        if (index + length &gt; 0x7FF) {
          length = 3 * length
        }

        if (index + length &gt; 0xFFFF) {
          length = 4 * length
        }

        const patternBufferUtf8 = allCharsBufferUtf8.slice(index, index + length)
        t.equal(index, allCharsBufferUtf8.indexOf(patternBufferUtf8))

        const patternStringUtf8 = patternBufferUtf8.toString()
        t.equal(index, allCharsBufferUtf8.indexOf(patternStringUtf8))
      }
    }
  }

  {
    // Find substrings in Usc2.
    const lengths = [2, 4, 16] // Single char, simple and complex.
    const indices = [0x5, 0x65, 0x105, 0x205, 0x285, 0x2005, 0x2085, 0xfff0]

    for (let lengthIndex = 0; lengthIndex &lt; lengths.length; lengthIndex++) {
      for (let i = 0; i &lt; indices.length; i++) {
        const index = indices[i] * 2
        const length = lengths[lengthIndex]

        const patternBufferUcs2 =
            allCharsBufferUcs2.slice(index, index + length)
        t.equal(
          index, allCharsBufferUcs2.indexOf(patternBufferUcs2, 0, &#039;ucs2&#039;))

        const patternStringUcs2 = patternBufferUcs2.toString(&#039;ucs2&#039;)
        t.equal(
          index, allCharsBufferUcs2.indexOf(patternStringUcs2, 0, &#039;ucs2&#039;))
      }
    }
  }

  [
    () =&gt; {},
    {},
    []
  ].forEach((val) =&gt; {
    t.throws(() =&gt; b.indexOf(val), TypeError, `&quot;${JSON.stringify(val)}&quot; should throw`)
  })

  // Test weird offset arguments.
  // The following offsets coerce to NaN or 0, searching the whole Buffer
  t.equal(b.indexOf(&#039;b&#039;, undefined), 1)
  t.equal(b.indexOf(&#039;b&#039;, {}), 1)
  t.equal(b.indexOf(&#039;b&#039;, 0), 1)
  t.equal(b.indexOf(&#039;b&#039;, null), 1)
  t.equal(b.indexOf(&#039;b&#039;, []), 1)

  // The following offset coerces to 2, in other words +[2] === 2
  t.equal(b.indexOf(&#039;b&#039;, [2]), -1)

  // Behavior should match String.indexOf()
  t.equal(
    b.indexOf(&#039;b&#039;, undefined),
    stringComparison.indexOf(&#039;b&#039;, undefined))
  t.equal(
    b.indexOf(&#039;b&#039;, {}),
    stringComparison.indexOf(&#039;b&#039;, {}))
  t.equal(
    b.indexOf(&#039;b&#039;, 0),
    stringComparison.indexOf(&#039;b&#039;, 0))
  t.equal(
    b.indexOf(&#039;b&#039;, null),
    stringComparison.indexOf(&#039;b&#039;, null))
  t.equal(
    b.indexOf(&#039;b&#039;, []),
    stringComparison.indexOf(&#039;b&#039;, []))
  t.equal(
    b.indexOf(&#039;b&#039;, [2]),
    stringComparison.indexOf(&#039;b&#039;, [2]))

  // test truncation of Number arguments to uint8
  {
    const buf = Buffer.from(&#039;this is a test&#039;)

    t.equal(buf.indexOf(0x6973), 3)
    t.equal(buf.indexOf(0x697320), 4)
    t.equal(buf.indexOf(0x69732069), 2)
    t.equal(buf.indexOf(0x697374657374), 0)
    t.equal(buf.indexOf(0x69737374), 0)
    t.equal(buf.indexOf(0x69737465), 11)
    t.equal(buf.indexOf(0x69737465), 11)
    t.equal(buf.indexOf(-140), 0)
    t.equal(buf.indexOf(-152), 1)
    t.equal(buf.indexOf(0xff), -1)
    t.equal(buf.indexOf(0xffff), -1)
  }

  // Test that Uint8Array arguments are okay.
  {
    const needle = new Uint8Array([0x66, 0x6f, 0x6f])
    const haystack = new BufferList(Buffer.from(&#039;a foo b foo&#039;))
    t.equal(haystack.indexOf(needle), 2)
  }

  t.end()
})
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
