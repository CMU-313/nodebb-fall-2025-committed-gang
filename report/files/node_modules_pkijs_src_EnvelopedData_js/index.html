<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/src/EnvelopedData.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/src/EnvelopedData.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1713</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">178.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import * as asn1js from &quot;asn1js&quot;;
import { getParametersValue, utilConcatBuf, clearProps } from &quot;pvutils&quot;;
import { getOIDByAlgorithm, getRandomValues, getCrypto, getAlgorithmByOID, kdf } from &quot;./common.js&quot;;
import OriginatorInfo from &quot;./OriginatorInfo.js&quot;;
import RecipientInfo from &quot;./RecipientInfo.js&quot;;
import EncryptedContentInfo from &quot;./EncryptedContentInfo.js&quot;;
import Attribute from &quot;./Attribute.js&quot;;
import AlgorithmIdentifier from &quot;./AlgorithmIdentifier.js&quot;;
import RSAESOAEPParams from &quot;./RSAESOAEPParams.js&quot;;
import KeyTransRecipientInfo from &quot;./KeyTransRecipientInfo.js&quot;;
import IssuerAndSerialNumber from &quot;./IssuerAndSerialNumber.js&quot;;
import RecipientEncryptedKey from &quot;./RecipientEncryptedKey.js&quot;;
import KeyAgreeRecipientIdentifier from &quot;./KeyAgreeRecipientIdentifier.js&quot;;
import KeyAgreeRecipientInfo from &quot;./KeyAgreeRecipientInfo.js&quot;;
import RecipientEncryptedKeys from &quot;./RecipientEncryptedKeys.js&quot;;
import KEKRecipientInfo from &quot;./KEKRecipientInfo.js&quot;;
import KEKIdentifier from &quot;./KEKIdentifier.js&quot;;
import PBKDF2Params from &quot;./PBKDF2Params.js&quot;;
import PasswordRecipientinfo from &quot;./PasswordRecipientinfo.js&quot;;
import ECCCMSSharedInfo from &quot;./ECCCMSSharedInfo.js&quot;;
import OriginatorIdentifierOrKey from &quot;./OriginatorIdentifierOrKey.js&quot;;
import OriginatorPublicKey from &quot;./OriginatorPublicKey.js&quot;;
//**************************************************************************************
/**
 * Class from RFC5652
 */
export default class EnvelopedData 
{
	//**********************************************************************************
	/**
	 * Constructor for EnvelopedData class
	 * @param {Object} [parameters={}]
	 * @property {Object} [schema] asn1js parsed value
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @description version
		 */
		this.version = getParametersValue(parameters, &quot;version&quot;, EnvelopedData.defaultValues(&quot;version&quot;));
		
		if(&quot;originatorInfo&quot; in parameters)
			/**
			 * @type {OriginatorInfo}
			 * @description originatorInfo
			 */
			this.originatorInfo = getParametersValue(parameters, &quot;originatorInfo&quot;, EnvelopedData.defaultValues(&quot;originatorInfo&quot;));
		
		/**
		 * @type {Array.&lt;RecipientInfo&gt;}
		 * @description recipientInfos
		 */
		this.recipientInfos = getParametersValue(parameters, &quot;recipientInfos&quot;, EnvelopedData.defaultValues(&quot;recipientInfos&quot;));
		/**
		 * @type {EncryptedContentInfo}
		 * @description encryptedContentInfo
		 */
		this.encryptedContentInfo = getParametersValue(parameters, &quot;encryptedContentInfo&quot;, EnvelopedData.defaultValues(&quot;encryptedContentInfo&quot;));
		
		if(&quot;unprotectedAttrs&quot; in parameters)
			/**
			 * @type {Array.&lt;Attribute&gt;}
			 * @description unprotectedAttrs
			 */
			this.unprotectedAttrs = getParametersValue(parameters, &quot;unprotectedAttrs&quot;, EnvelopedData.defaultValues(&quot;unprotectedAttrs&quot;));
		//endregion
		
		//region If input argument array contains &quot;schema&quot; for this object
		if(&quot;schema&quot; in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case &quot;version&quot;:
				return 0;
			case &quot;originatorInfo&quot;:
				return new OriginatorInfo();
			case &quot;recipientInfos&quot;:
				return [];
			case &quot;encryptedContentInfo&quot;:
				return new EncryptedContentInfo();
			case &quot;unprotectedAttrs&quot;:
				return [];
			default:
				throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case &quot;version&quot;:
				return (memberValue === EnvelopedData.defaultValues(memberName));
			case &quot;originatorInfo&quot;:
				return ((memberValue.certs.certificates.length === 0) &amp;&amp; (memberValue.crls.crls.length === 0));
			case &quot;recipientInfos&quot;:
			case &quot;unprotectedAttrs&quot;:
				return (memberValue.length === 0);
			case &quot;encryptedContentInfo&quot;:
				return ((EncryptedContentInfo.compareWithDefault(&quot;contentType&quot;, memberValue.contentType)) &amp;&amp;
				(EncryptedContentInfo.compareWithDefault(&quot;contentEncryptionAlgorithm&quot;, memberValue.contentEncryptionAlgorithm) &amp;&amp;
				(EncryptedContentInfo.compareWithDefault(&quot;encryptedContent&quot;, memberValue.encryptedContent))));
			default:
				throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of asn1js schema for current class
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		//EnvelopedData ::= SEQUENCE {
		//    version CMSVersion,
		//    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
		//    recipientInfos RecipientInfos,
		//    encryptedContentInfo EncryptedContentInfo,
		//    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
		
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [originatorInfo]
		 * @property {string} [recipientInfos]
		 * @property {string} [encryptedContentInfo]
		 * @property {string} [unprotectedAttrs]
		 */
		const names = getParametersValue(parameters, &quot;names&quot;, {});
		
		return (new asn1js.Sequence({
			name: (names.blockName || &quot;&quot;),
			value: [
				new asn1js.Integer({ name: (names.version || &quot;&quot;) }),
				new asn1js.Constructed({
					name: (names.originatorInfo || &quot;&quot;),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: OriginatorInfo.schema().valueBlock.value
				}),
				new asn1js.Set({
					value: [
						new asn1js.Repeated({
							name: (names.recipientInfos || &quot;&quot;),
							value: RecipientInfo.schema()
						})
					]
				}),
				EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
				new asn1js.Constructed({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js.Repeated({
							name: (names.unprotectedAttrs || &quot;&quot;),
							value: Attribute.schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		clearProps(schema, [
			&quot;version&quot;,
			&quot;originatorInfo&quot;,
			&quot;recipientInfos&quot;,
			&quot;encryptedContentInfo&quot;,
			&quot;unprotectedAttrs&quot;
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema,
			schema,
			EnvelopedData.schema({
				names: {
					version: &quot;version&quot;,
					originatorInfo: &quot;originatorInfo&quot;,
					recipientInfos: &quot;recipientInfos&quot;,
					encryptedContentInfo: {
						names: {
							blockName: &quot;encryptedContentInfo&quot;
						}
					},
					unprotectedAttrs: &quot;unprotectedAttrs&quot;
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error(&quot;Object&#039;s schema was not verified against input data for EnvelopedData&quot;);
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		
		if(&quot;originatorInfo&quot; in asn1.result)
		{
			this.originatorInfo = new OriginatorInfo({
				schema: new asn1js.Sequence({
					value: asn1.result.originatorInfo.valueBlock.value
				})
			});
		}
		
		this.recipientInfos = Array.from(asn1.result.recipientInfos, element =&gt; new RecipientInfo({ schema: element }));
		this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
		
		if(&quot;unprotectedAttrs&quot; in asn1.result)
			this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element =&gt; new Attribute({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(new asn1js.Integer({ value: this.version }));
		
		if(&quot;originatorInfo&quot; in this)
		{
			outputArray.push(new asn1js.Constructed({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: this.originatorInfo.toSchema().valueBlock.value
			}));
		}
		
		outputArray.push(new asn1js.Set({
			value: Array.from(this.recipientInfos, element =&gt; element.toSchema())
		}));
		
		outputArray.push(this.encryptedContentInfo.toSchema());
		
		if(&quot;unprotectedAttrs&quot; in this)
		{
			outputArray.push(new asn1js.Constructed({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.unprotectedAttrs, element =&gt; element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js.Sequence({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version
		};
		
		if(&quot;originatorInfo&quot; in this)
			_object.originatorInfo = this.originatorInfo.toJSON();
		
		_object.recipientInfos = Array.from(this.recipientInfos, element =&gt; element.toJSON());
		_object.encryptedContentInfo = this.encryptedContentInfo.toJSON();
		
		if(&quot;unprotectedAttrs&quot; in this)
			_object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element =&gt; element.toJSON());
		
		return _object;
	}
	//**********************************************************************************
	/**
	 * Helpers function for filling &quot;RecipientInfo&quot; based on recipient&#039;s certificate.
	 * Problem with WebCrypto is that for RSA certificates we have only one option - &quot;key transport&quot; and
	 * for ECC certificates we also have one option - &quot;key agreement&quot;. As soon as Google will implement
	 * DH algorithm it would be possible to use &quot;key agreement&quot; also for RSA certificates.
	 * @param {Certificate} [certificate] Recipient&#039;s certificate
	 * @param {Object} [parameters] Additional parameters neccessary for &quot;fine tunning&quot; of encryption process
	 * @param {number} [variant] Variant = 1 is for &quot;key transport&quot;, variant = 2 is for &quot;key agreement&quot;. In fact the &quot;variant&quot; is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: &quot;key transport&quot; for RSA and &quot;key agreement&quot; for ECC certificates.
	 */
	addRecipientByCertificate(certificate, parameters, variant)
	{
		//region Initial variables 
		const encryptionParameters = parameters || {};
		//endregion 
		
		//region Check type of certificate
		if(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(&quot;1.2.840.113549&quot;) !== (-1))
			variant = 1; // For the moment it is the only variant for RSA-based certificates
		else
		{
			if(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(&quot;1.2.840.10045&quot;) !== (-1))
				variant = 2; // For the moment it is the only variant for ECC-based certificates
			else
				throw new Error(`Unknown type of certificate&#039;s public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
		}
		//endregion 
		
		//region Initialize encryption parameters 
		if((&quot;oaepHashAlgorithm&quot; in encryptionParameters) === false)
			encryptionParameters.oaepHashAlgorithm = &quot;SHA-512&quot;;
		
		if((&quot;kdfAlgorithm&quot; in encryptionParameters) === false)
			encryptionParameters.kdfAlgorithm = &quot;SHA-512&quot;;
		
		if((&quot;kekEncryptionLength&quot; in encryptionParameters) === false)
			encryptionParameters.kekEncryptionLength = 256;
		//endregion 
		
		//region Add new &quot;recipient&quot; depends on &quot;variant&quot; and certificate type 
		switch(variant)
		{
			case 1: // Key transport scheme
				{
				//region keyEncryptionAlgorithm
					const oaepOID = getOIDByAlgorithm({
						name: &quot;RSA-OAEP&quot;
					});
					if(oaepOID === &quot;&quot;)
						throw new Error(&quot;Can not find OID for OAEP&quot;);
				//endregion
				
				//region RSAES-OAEP-params
					const hashOID = getOIDByAlgorithm({
						name: encryptionParameters.oaepHashAlgorithm
					});
					if(hashOID === &quot;&quot;)
						throw new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);
				
					const hashAlgorithm = new AlgorithmIdentifier({
						algorithmId: hashOID,
						algorithmParams: new asn1js.Null()
					});
				
					const rsaOAEPParams = new RSAESOAEPParams({
						hashAlgorithm,
						maskGenAlgorithm: new AlgorithmIdentifier({
							algorithmId: &quot;1.2.840.113549.1.1.8&quot;, // id-mgf1
							algorithmParams: hashAlgorithm.toSchema()
						})
					});
				//endregion
				
				//region KeyTransRecipientInfo
					const keyInfo = new KeyTransRecipientInfo({
						version: 0,
						rid: new IssuerAndSerialNumber({
							issuer: certificate.issuer,
							serialNumber: certificate.serialNumber
						}),
						keyEncryptionAlgorithm: new AlgorithmIdentifier({
							algorithmId: oaepOID,
							algorithmParams: rsaOAEPParams.toSchema()
						}),
						recipientCertificate: certificate
					// &quot;encryptedKey&quot; will be calculated in &quot;encrypt&quot; function
					});
				//endregion
				
				//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new RecipientInfo({
						variant: 1,
						value: keyInfo
					}));
				//endregion
				}
				break;
			case 2: // Key agreement scheme
				{
				//region RecipientEncryptedKey
					const encryptedKey = new RecipientEncryptedKey({
						rid: new KeyAgreeRecipientIdentifier({
							variant: 1,
							value: new IssuerAndSerialNumber({
								issuer: certificate.issuer,
								serialNumber: certificate.serialNumber
							})
						})
					// &quot;encryptedKey&quot; will be calculated in &quot;encrypt&quot; function
					});
				//endregion
				
				//region keyEncryptionAlgorithm
					const aesKWoid = getOIDByAlgorithm({
						name: &quot;AES-KW&quot;,
						length: encryptionParameters.kekEncryptionLength
					});
					if(aesKWoid === &quot;&quot;)
						throw new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);
				
					const aesKW = new AlgorithmIdentifier({
						algorithmId: aesKWoid,
						algorithmParams: new asn1js.Null()
					});
				//endregion
				
				//region KeyAgreeRecipientInfo
					const ecdhOID = getOIDByAlgorithm({
						name: &quot;ECDH&quot;,
						kdf: encryptionParameters.kdfAlgorithm
					});
					if(ecdhOID === &quot;&quot;)
						throw new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`);
				
				// In fact there is no need in so long UKM, but RFC2631
				// has requirement that &quot;UserKeyMaterial&quot; must be 512 bits long
					const ukmBuffer = new ArrayBuffer(64);
					const ukmView = new Uint8Array(ukmBuffer);
					getRandomValues(ukmView); // Generate random values in 64 bytes long buffer
				
					const keyInfo = new KeyAgreeRecipientInfo({
						version: 3,
						// &quot;originator&quot; will be calculated in &quot;encrypt&quot; function because ephemeral key would be generated there
						ukm: new asn1js.OctetString({ valueHex: ukmBuffer }),
						keyEncryptionAlgorithm: new AlgorithmIdentifier({
							algorithmId: ecdhOID,
							algorithmParams: aesKW.toSchema()
						}),
						recipientEncryptedKeys: new RecipientEncryptedKeys({
							encryptedKeys: [encryptedKey]
						}),
						recipientCertificate: certificate
					});
				//endregion
				
				//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new RecipientInfo({
						variant: 2,
						value: keyInfo
					}));
				//endregion
				}
				break;
			default:
				throw new Error(`Unknown &quot;variant&quot; value: ${variant}`);
		}
		//endregion 
		
		return true;
	}
	//**********************************************************************************
	/**
	 * Add recipient based on pre-defined data like password or KEK
	 * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data
	 * @param {Object} parameters Additional parameters neccessary for &quot;fine tunning&quot; of encryption process
	 * @param {number} variant Variant = 1 for pre-defined &quot;key encryption key&quot; (KEK). Variant = 2 for password-based encryption.
	 */
	addRecipientByPreDefinedData(preDefinedData, parameters, variant)
	{
		//region Initial variables
		const encryptionParameters = parameters || {};
		//endregion
		
		//region Check initial parameters
		if((preDefinedData instanceof ArrayBuffer) === false)
			throw new Error(&quot;Please pass \&quot;preDefinedData\&quot; in ArrayBuffer type&quot;);
		
		if(preDefinedData.byteLength === 0)
			throw new Error(&quot;Pre-defined data could have zero length&quot;);
		//endregion
		
		//region Initialize encryption parameters
		if((&quot;keyIdentifier&quot; in encryptionParameters) === false)
		{
			const keyIdentifierBuffer = new ArrayBuffer(16);
			const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
			getRandomValues(keyIdentifierView);
			
			encryptionParameters.keyIdentifier = keyIdentifierBuffer;
		}
		
		if((&quot;hmacHashAlgorithm&quot; in encryptionParameters) === false)
			encryptionParameters.hmacHashAlgorithm = &quot;SHA-512&quot;;
		
		if((&quot;iterationCount&quot; in encryptionParameters) === false)
			encryptionParameters.iterationCount = 2048;
		
		if((&quot;keyEncryptionAlgorithm&quot; in encryptionParameters) === false)
		{
			encryptionParameters.keyEncryptionAlgorithm = {
				name: &quot;AES-KW&quot;,
				length: 256
			};
		}
		
		if((&quot;keyEncryptionAlgorithmParams&quot; in encryptionParameters) === false)
			encryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null();
		//endregion
		
		//region Add new recipient based on passed variant
		switch(variant)
		{
			case 1: // KEKRecipientInfo
				{
				//region keyEncryptionAlgorithm
					const kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);
					if(kekOID === &quot;&quot;)
						throw new Error(&quot;Incorrect value for \&quot;keyEncryptionAlgorithm\&quot;&quot;);
				//endregion
				
				//region KEKRecipientInfo
					const keyInfo = new KEKRecipientInfo({
						version: 4,
						kekid: new KEKIdentifier({
							keyIdentifier: new asn1js.OctetString({ valueHex: encryptionParameters.keyIdentifier })
						}),
						keyEncryptionAlgorithm: new AlgorithmIdentifier({
							algorithmId: kekOID,
							/*
							 For AES-KW params are NULL, but for other algorithm could another situation.
							 */
							algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
						}),
						preDefinedKEK: preDefinedData
					// &quot;encryptedKey&quot; would be set in &quot;ecrypt&quot; function
					});
				//endregion
				
				//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new RecipientInfo({
						variant: 3,
						value: keyInfo
					}));
				//endregion
				}
				break;
			case 2: // PasswordRecipientinfo
				{
				//region keyDerivationAlgorithm
					const pbkdf2OID = getOIDByAlgorithm({
						name: &quot;PBKDF2&quot;
					});
					if(pbkdf2OID === &quot;&quot;)
						throw new Error(&quot;Can not find OID for PBKDF2&quot;);
				//endregion
				
				//region Salt
					const saltBuffer = new ArrayBuffer(64);
					const saltView = new Uint8Array(saltBuffer);
					getRandomValues(saltView);
				//endregion
				
				//region HMAC-based algorithm
					const hmacOID = getOIDByAlgorithm({
						name: &quot;HMAC&quot;,
						hash: {
							name: encryptionParameters.hmacHashAlgorithm
						}
					});
					if(hmacOID === &quot;&quot;)
						throw new Error(`Incorrect value for &quot;hmacHashAlgorithm&quot;: ${encryptionParameters.hmacHashAlgorithm}`);
				//endregion
				
				//region PBKDF2-params
					const pbkdf2Params = new PBKDF2Params({
						salt: new asn1js.OctetString({ valueHex: saltBuffer }),
						iterationCount: encryptionParameters.iterationCount,
						prf: new AlgorithmIdentifier({
							algorithmId: hmacOID,
							algorithmParams: new asn1js.Null()
						})
					});
				//endregion
				
				//region keyEncryptionAlgorithm
					const kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);
					if(kekOID === &quot;&quot;)
						throw new Error(&quot;Incorrect value for \&quot;keyEncryptionAlgorithm\&quot;&quot;);
				//endregion
				
				//region PasswordRecipientinfo
					const keyInfo = new PasswordRecipientinfo({
						version: 0,
						keyDerivationAlgorithm: new AlgorithmIdentifier({
							algorithmId: pbkdf2OID,
							algorithmParams: pbkdf2Params.toSchema()
						}),
						keyEncryptionAlgorithm: new AlgorithmIdentifier({
							algorithmId: kekOID,
							/*
							 For AES-KW params are NULL, but for other algorithm could be another situation.
							 */
							algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
						}),
						password: preDefinedData
					// &quot;encryptedKey&quot; would be set in &quot;ecrypt&quot; function
					});
				//endregion
				
				//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new RecipientInfo({
						variant: 4,
						value: keyInfo
					}));
				//endregion
				}
				break;
			default:
				throw new Error(`Unknown value for &quot;variant&quot;: ${variant}`);
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Create a new CMS Enveloped Data content with encrypted data
	 * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only &quot;AES-CBC&quot; or &quot;AES-GCM&quot; algorithms.
	 * @param {ArrayBuffer} contentToEncrypt Content to encrypt
	 * @returns {Promise}
	 */
	encrypt(contentEncryptionAlgorithm, contentToEncrypt)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		
		const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
		const ivView = new Uint8Array(ivBuffer);
		getRandomValues(ivView);
		
		const contentView = new Uint8Array(contentToEncrypt);
		
		let sessionKey;
		let encryptedContent;
		let exportedSessionKey;
		
		const recipientsPromises = [];
		
		const _this = this;
		//endregion
		
		//region Check for input parameters
		const contentEncryptionOID = getOIDByAlgorithm(contentEncryptionAlgorithm);
		if(contentEncryptionOID === &quot;&quot;)
			return Promise.reject(&quot;Wrong \&quot;contentEncryptionAlgorithm\&quot; value&quot;);
		//endregion
		
		//region Get a &quot;crypto&quot; extension
		const crypto = getCrypto();
		if(typeof crypto === &quot;undefined&quot;)
			return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion
		
		//region Generate new content encryption key
		sequence = sequence.then(() =&gt;
			crypto.generateKey(contentEncryptionAlgorithm, true, [&quot;encrypt&quot;]));
		//endregion
		//region Encrypt content
		sequence = sequence.then(result =&gt;
		{
			sessionKey = result;
			
			return crypto.encrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			},
			sessionKey,
			contentView);
		}, error =&gt;
			Promise.reject(error));
		//endregion
		//region Export raw content of content encryption key
		sequence = sequence.then(result =&gt;
		{
			//region Create output OCTETSTRING with encrypted content
			encryptedContent = result;
			//endregion
				
			return crypto.exportKey(&quot;raw&quot;, sessionKey);
		}, error =&gt;
			Promise.reject(error)
		).then(result =&gt;
		{
			exportedSessionKey = result;
			
			return true;
		}, error =&gt;
			Promise.reject(error));
		//endregion
		//region Append common information to CMS_ENVELOPED_DATA
		sequence = sequence.then(() =&gt;
		{
			this.version = 2;
			this.encryptedContentInfo = new EncryptedContentInfo({
				contentType: &quot;1.2.840.113549.1.7.1&quot;, // &quot;data&quot;
				contentEncryptionAlgorithm: new AlgorithmIdentifier({
					algorithmId: contentEncryptionOID,
					algorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })
				}),
				encryptedContent: new asn1js.OctetString({ valueHex: encryptedContent })
			});
		}, error =&gt;
			Promise.reject(error));
		//endregion
		
		//region Special sub-functions to work with each recipient&#039;s type
		function SubKeyAgreeRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			
			let ecdhPublicKey;
			let ecdhPrivateKey;
			
			let recipientCurve;
			let recipientCurveLength;
			
			let exportedECDHPublicKey;
			//endregion
			
			//region Get &quot;namedCurve&quot; parameter from recipient&#039;s certificate
			currentSequence = currentSequence.then(() =&gt;
			{
				const curveObject = _this.recipientInfos[index].value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
				
				if((curveObject instanceof asn1js.ObjectIdentifier) === false)
					return Promise.reject(`Incorrect &quot;recipientCertificate&quot; for index ${index}`);
				
				const curveOID = curveObject.valueBlock.toString();
				
				switch(curveOID)
				{
					case &quot;1.2.840.10045.3.1.7&quot;:
						recipientCurve = &quot;P-256&quot;;
						recipientCurveLength = 256;
						break;
					case &quot;1.3.132.0.34&quot;:
						recipientCurve = &quot;P-384&quot;;
						recipientCurveLength = 384;
						break;
					case &quot;1.3.132.0.35&quot;:
						recipientCurve = &quot;P-521&quot;;
						recipientCurveLength = 528;
						break;
					default:
						return Promise.reject(`Incorrect curve OID for index ${index}`);
				}
				
				return recipientCurve;
			}, error =&gt;
				Promise.reject(error));
			//endregion
			
			//region Generate ephemeral ECDH key
			currentSequence = currentSequence.then(result =&gt;
				crypto.generateKey({
					name: &quot;ECDH&quot;,
					namedCurve: result
				},
				true,
				[&quot;deriveBits&quot;]),
			error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Export public key of ephemeral ECDH key pair
			currentSequence = currentSequence.then(result =&gt;
			{
				ecdhPublicKey = result.publicKey;
				ecdhPrivateKey = result.privateKey;
					
				return crypto.exportKey(&quot;spki&quot;, ecdhPublicKey);
			},
			error =&gt;
				Promise.reject(error));
			//endregion
			
			//region Import recipient&#039;s public key
			currentSequence = currentSequence.then(result =&gt;
			{
				exportedECDHPublicKey = result;
				
				return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
					algorithm: {
						algorithm: {
							name: &quot;ECDH&quot;,
							namedCurve: recipientCurve
						},
						usages: []
					}
				});
			}, error =&gt;
				Promise.reject(error));
			//endregion
			//region Create shared secret
			currentSequence = currentSequence.then(result =&gt; crypto.deriveBits({
				name: &quot;ECDH&quot;,
				public: result
			},
			ecdhPrivateKey,
			recipientCurveLength),
			error =&gt;
				Promise.reject(error));
			//endregion
			
			//region Apply KDF function to shared secret
			currentSequence = currentSequence.then(
				/**
				 * @param {ArrayBuffer} result
				 */
				result =&gt;
				{
					//region Get length of used AES-KW algorithm
					const aesKWAlgorithm = new AlgorithmIdentifier({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });
					
					const KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);
					if((&quot;name&quot; in KWalgorithm) === false)
						return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
					//endregion
					
					//region Translate AES-KW length to ArrayBuffer
					let kwLength = KWalgorithm.length;
					
					const kwLengthBuffer = new ArrayBuffer(4);
					const kwLengthView = new Uint8Array(kwLengthBuffer);
					
					for(let j = 3; j &gt;= 0; j--)
					{
						kwLengthView[j] = kwLength;
						kwLength &gt;&gt;= 8;
					}
					//endregion
					
					//region Create and encode &quot;ECC-CMS-SharedInfo&quot; structure
					const eccInfo = new ECCCMSSharedInfo({
						keyInfo: new AlgorithmIdentifier({
							algorithmId: aesKWAlgorithm.algorithmId,
							/*
							 Initially RFC5753 says that AES algorithms have absent parameters.
							 But since early implementations all put NULL here. Thus, in order to be
							 &quot;backward compatible&quot;, index also put NULL here.
							 */
							algorithmParams: new asn1js.Null()
						}),
						entityUInfo: _this.recipientInfos[index].value.ukm,
						suppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })
					});
					
					const encodedInfo = eccInfo.toSchema().toBER(false);
					//endregion
					
					//region Get SHA algorithm used together with ECDH
					const ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
					if((&quot;name&quot; in ecdhAlgorithm) === false)
						return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
					//endregion
					
					return kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
				},
				error =&gt;
					Promise.reject(error));
			//endregion
			//region Import AES-KW key from result of KDF function
			currentSequence = currentSequence.then(result =&gt;
				crypto.importKey(&quot;raw&quot;, result, { name: &quot;AES-KW&quot; }, true, [&quot;wrapKey&quot;]),
			error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Finally wrap session key by using AES-KW algorithm
			currentSequence = currentSequence.then(result =&gt; crypto.wrapKey(&quot;raw&quot;, sessionKey, result, { name: &quot;AES-KW&quot; }),
				error =&gt;
					Promise.reject(error)
			);
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt;
			{
				//region OriginatorIdentifierOrKey
				const asn1 = asn1js.fromBER(exportedECDHPublicKey);
					
				const originator = new OriginatorIdentifierOrKey();
				originator.variant = 3;
				originator.value = new OriginatorPublicKey({ schema: asn1.result });
				// There is option when we can stay with ECParameters, but here index prefer to avoid the params
				if(&quot;algorithmParams&quot; in originator.value.algorithm)
					delete originator.value.algorithm.algorithmParams;
					
				_this.recipientInfos[index].value.originator = originator;
				//endregion
					
				//region RecipientEncryptedKey
				/*
				 We will not support using of same ephemeral key for many recipients
				 */
				_this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		function SubKeyTransRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion
			
			//region Get recipient&#039;s public key
			currentSequence = currentSequence.then(() =&gt;
			{
				//region Get current used SHA algorithm
				const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
				const rsaOAEPParams = new RSAESOAEPParams({ schema });
				
				const hashAlgorithm = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
				if((&quot;name&quot; in hashAlgorithm) === false)
					return Promise.reject(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
				//endregion
				
				return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
					algorithm: {
						algorithm: {
							name: &quot;RSA-OAEP&quot;,
							hash: {
								name: hashAlgorithm.name
							}
						},
						usages: [&quot;encrypt&quot;, &quot;wrapKey&quot;]
					}
				});
			}, error =&gt;
				Promise.reject(error));
			//endregion
			//region Encrypt early exported session key on recipient&#039;s public key
			currentSequence = currentSequence.then(result =&gt;
				crypto.encrypt(result.algorithm, result, exportedSessionKey),
			error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt;
			{
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		function SubKEKRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let kekAlgorithm;
			//endregion
			
			//region Import KEK from pre-defined data
			currentSequence = currentSequence.then(() =&gt;
			{
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
					//endregion
					
				return crypto.importKey(&quot;raw&quot;,
					new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK),
					kekAlgorithm,
					true,
					[&quot;wrapKey&quot;]); // Too specific for AES-KW
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			//region Wrap previously exported session key
			currentSequence = currentSequence.then(result =&gt;
				crypto.wrapKey(&quot;raw&quot;, sessionKey, result, kekAlgorithm),
			error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt;
			{
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		function SubPasswordRecipientinfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let pbkdf2Params;
			let kekAlgorithm;
			//endregion
			
			//region Check that we have encoded &quot;keyDerivationAlgorithm&quot; plus &quot;PBKDF2_params&quot; in there
			currentSequence = currentSequence.then(() =&gt;
			{
				if((&quot;keyDerivationAlgorithm&quot; in _this.recipientInfos[index].value) === false)
					return Promise.reject(&quot;Please append encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
					
				if((&quot;algorithmParams&quot; in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)
					return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
					
				try
				{
					pbkdf2Params = new PBKDF2Params({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });
				}
				catch(ex)
				{
					return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
				}
					
				return Promise.resolve();
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Derive PBKDF2 key from &quot;password&quot; buffer
			currentSequence = currentSequence.then(() =&gt;
			{
				const passwordView = new Uint8Array(_this.recipientInfos[index].value.password);
					
				return crypto.importKey(&quot;raw&quot;,
					passwordView,
					&quot;PBKDF2&quot;,
					false,
					[&quot;deriveKey&quot;]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Derive key for &quot;keyEncryptionAlgorithm&quot;
			currentSequence = currentSequence.then(result =&gt;
			{
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion
				
				//region Get HMAC hash algorithm
				let hmacHashAlgorithm = &quot;SHA-1&quot;;
					
				if(&quot;prf&quot; in pbkdf2Params)
				{
					const algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
					if((&quot;name&quot; in algorithm) === false)
						return Promise.reject(&quot;Incorrect OID for HMAC hash algorithm&quot;);
						
					hmacHashAlgorithm = algorithm.hash.name;
				}
				//endregion
				
				//region Get PBKDF2 &quot;salt&quot; value
				const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
				//endregion
					
				//region Get PBKDF2 iterations count
				const iterations = pbkdf2Params.iterationCount;
				//endregion
					
				return crypto.deriveKey({
					name: &quot;PBKDF2&quot;,
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations
				},
				result,
				kekAlgorithm,
				true,
				[&quot;wrapKey&quot;]); // Usages are too specific for KEK algorithm
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Wrap previously exported session key (Also too specific for KEK algorithm)
			currentSequence = currentSequence.then(result =&gt;
				crypto.wrapKey(&quot;raw&quot;, sessionKey, result, kekAlgorithm),
			error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt;
			{
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		//endregion
		
		//region Create special routines for each &quot;recipient&quot;
		sequence = sequence.then(() =&gt;
		{
			for(let i = 0; i &lt; this.recipientInfos.length; i++)
			{
				//region Initial variables
				let currentSequence = Promise.resolve();
				//endregion
					
				switch(this.recipientInfos[i].variant)
				{
					case 1: // KeyTransRecipientInfo
						currentSequence = SubKeyTransRecipientInfo(i);
						break;
					case 2: // KeyAgreeRecipientInfo
						currentSequence = SubKeyAgreeRecipientInfo(i);
						break;
					case 3: // KEKRecipientInfo
						currentSequence = SubKEKRecipientInfo(i);
						break;
					case 4: // PasswordRecipientinfo
						currentSequence = SubPasswordRecipientinfo(i);
						break;
					default:
						return Promise.reject(`Uknown recipient type in array with index ${i}`);
				}
					
				recipientsPromises.push(currentSequence);
			}
				
			return Promise.all(recipientsPromises);
		}, error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Decrypt existing CMS Enveloped Data content
	 * @param {number} recipientIndex Index of recipient
	 * @param {Object} parameters Additional parameters
	 * @returns {Promise}
	 */
	decrypt(recipientIndex, parameters)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		
		const decryptionParameters = parameters || {};
		
		const _this = this;
		//endregion
		
		//region Check for input parameters
		if((recipientIndex + 1) &gt; this.recipientInfos.length)
			return Promise.reject(`Maximum value for &quot;index&quot; is: ${this.recipientInfos.length - 1}`);
		//endregion
		
		//region Get a &quot;crypto&quot; extension
		const crypto = getCrypto();
		if(typeof crypto === &quot;undefined&quot;)
			return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion
		
		//region Special sub-functions to work with each recipient&#039;s type
		function SubKeyAgreeRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			
			let recipientCurve;
			let recipientCurveLength;
			
			let curveOID;
			
			let ecdhPrivateKey;
			//endregion
			
			//region Get &quot;namedCurve&quot; parameter from recipient&#039;s certificate
			currentSequence = currentSequence.then(() =&gt;
			{
				if((&quot;recipientCertificate&quot; in decryptionParameters) === false)
					return Promise.reject(&quot;Parameter \&quot;recipientCertificate\&quot; is mandatory for \&quot;KeyAgreeRecipientInfo\&quot;&quot;);
					
				if((&quot;recipientPrivateKey&quot; in decryptionParameters) === false)
					return Promise.reject(&quot;Parameter \&quot;recipientPrivateKey\&quot; is mandatory for \&quot;KeyAgreeRecipientInfo\&quot;&quot;);
					
				const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
					
				if((curveObject instanceof asn1js.ObjectIdentifier) === false)
					return Promise.reject(`Incorrect &quot;recipientCertificate&quot; for index ${index}`);
					
				curveOID = curveObject.valueBlock.toString();
					
				switch(curveOID)
				{
					case &quot;1.2.840.10045.3.1.7&quot;:
						recipientCurve = &quot;P-256&quot;;
						recipientCurveLength = 256;
						break;
					case &quot;1.3.132.0.34&quot;:
						recipientCurve = &quot;P-384&quot;;
						recipientCurveLength = 384;
						break;
					case &quot;1.3.132.0.35&quot;:
						recipientCurve = &quot;P-521&quot;;
						recipientCurveLength = 528;
						break;
					default:
						return Promise.reject(`Incorrect curve OID for index ${index}`);
				}
					
				return crypto.importKey(&quot;pkcs8&quot;,
					decryptionParameters.recipientPrivateKey,
					{
						name: &quot;ECDH&quot;,
						namedCurve: recipientCurve
					},
					true,
					[&quot;deriveBits&quot;]
				);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Import sender&#039;s ephemeral public key
			currentSequence = currentSequence.then(result =&gt;
			{
				ecdhPrivateKey = result;
					
				//region Change &quot;OriginatorPublicKey&quot; if &quot;curve&quot; parameter absent
				if((&quot;algorithmParams&quot; in _this.recipientInfos[index].value.originator.value.algorithm) === false)
					_this.recipientInfos[index].value.originator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({ value: curveOID });
				//endregion
				
				//region Create ArrayBuffer with sender&#039;s public key
				const buffer = _this.recipientInfos[index].value.originator.value.toSchema().toBER(false);
				//endregion
					
				return crypto.importKey(&quot;spki&quot;,
					buffer,
					{
						name: &quot;ECDH&quot;,
						namedCurve: recipientCurve
					},
					true,
					[]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Create shared secret
			currentSequence = currentSequence.then(result =&gt;
				crypto.deriveBits({
					name: &quot;ECDH&quot;,
					public: result
				},
				ecdhPrivateKey,
				recipientCurveLength),
			error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Apply KDF function to shared secret
			currentSequence = currentSequence.then(
				/**
				 * @param {ArrayBuffer} result
				 */
				result =&gt;
				{
					//region Get length of used AES-KW algorithm
					const aesKWAlgorithm = new AlgorithmIdentifier({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });
					
					const KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);
					if((&quot;name&quot; in KWalgorithm) === false)
						return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
						//endregion
						
						//region Translate AES-KW length to ArrayBuffer
					let kwLength = KWalgorithm.length;
					
					const kwLengthBuffer = new ArrayBuffer(4);
					const kwLengthView = new Uint8Array(kwLengthBuffer);
					
					for(let j = 3; j &gt;= 0; j--)
					{
						kwLengthView[j] = kwLength;
						kwLength &gt;&gt;= 8;
					}
					//endregion
					
					//region Create and encode &quot;ECC-CMS-SharedInfo&quot; structure
					const eccInfo = new ECCCMSSharedInfo({
						keyInfo: new AlgorithmIdentifier({
							algorithmId: aesKWAlgorithm.algorithmId,
							/*
							 Initially RFC5753 says that AES algorithms have absent parameters.
							 But since early implementations all put NULL here. Thus, in order to be
							 &quot;backward compatible&quot;, index also put NULL here.
							 */
							algorithmParams: new asn1js.Null()
						}),
						entityUInfo: _this.recipientInfos[index].value.ukm,
						suppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })
					});
					
					const encodedInfo = eccInfo.toSchema().toBER(false);
					//endregion
					
					//region Get SHA algorithm used together with ECDH
					const ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
					if((&quot;name&quot; in ecdhAlgorithm) === false)
						return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
						//endregion
						
					return kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
				},
				error =&gt;
					Promise.reject(error)
			);
			//endregion
			//region Import AES-KW key from result of KDF function
			currentSequence = currentSequence.then(result =&gt;
				crypto.importKey(&quot;raw&quot;,
					result,
					{ name: &quot;AES-KW&quot; },
					true,
					[&quot;unwrapKey&quot;]),
			error =&gt; Promise.reject(error)
			);
			//endregion
			//region Finally unwrap session key
			currentSequence = currentSequence.then(result =&gt;
			{
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
					//endregion
					
				return crypto.unwrapKey(&quot;raw&quot;,
					_this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex,
					result,
					{ name: &quot;AES-KW&quot; },
					contentEncryptionAlgorithm,
					true,
					[&quot;decrypt&quot;]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		function SubKeyTransRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion
			
			//region Import recipient&#039;s private key
			currentSequence = currentSequence.then(() =&gt;
			{
				if((&quot;recipientPrivateKey&quot; in decryptionParameters) === false)
					return Promise.reject(&quot;Parameter \&quot;recipientPrivateKey\&quot; is mandatory for \&quot;KeyTransRecipientInfo\&quot;&quot;);
					
					//region Get current used SHA algorithm
				const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
				const rsaOAEPParams = new RSAESOAEPParams({ schema });
					
				const hashAlgorithm = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
				if((&quot;name&quot; in hashAlgorithm) === false)
					return Promise.reject(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
					//endregion
					
				return crypto.importKey(&quot;pkcs8&quot;,
					decryptionParameters.recipientPrivateKey,
					{
						name: &quot;RSA-OAEP&quot;,
						hash: {
							name: hashAlgorithm.name
						}
					},
					true,
					[&quot;decrypt&quot;]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Decrypt encrypted session key
			currentSequence = currentSequence.then(result =&gt;
				crypto.decrypt(result.algorithm,
					result,
					_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex
				), error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Import decrypted session key
			currentSequence = currentSequence.then(result =&gt;
			{
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion
					
				return crypto.importKey(&quot;raw&quot;,
					result,
					contentEncryptionAlgorithm,
					true,
					[&quot;decrypt&quot;]
				);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		function SubKEKRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let kekAlgorithm;
			//endregion
			
			//region Import KEK from pre-defined data
			currentSequence = currentSequence.then(() =&gt;
			{
				if((&quot;preDefinedData&quot; in decryptionParameters) === false)
					return Promise.reject(&quot;Parameter \&quot;preDefinedData\&quot; is mandatory for \&quot;KEKRecipientInfo\&quot;&quot;);
					
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion
					
				return crypto.importKey(&quot;raw&quot;,
					decryptionParameters.preDefinedData,
					kekAlgorithm,
					true,
					[&quot;unwrapKey&quot;]); // Too specific for AES-KW
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Unwrap previously exported session key
			currentSequence = currentSequence.then(result =&gt;
			{
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion
					
				return crypto.unwrapKey(&quot;raw&quot;,
					_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,
					result,
					kekAlgorithm,
					contentEncryptionAlgorithm,
					true,
					[&quot;decrypt&quot;]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		function SubPasswordRecipientinfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let pbkdf2Params;
			let kekAlgorithm;
			//endregion
			
			//region Derive PBKDF2 key from &quot;password&quot; buffer
			currentSequence = currentSequence.then(() =&gt;
			{
				if((&quot;preDefinedData&quot; in decryptionParameters) === false)
					return Promise.reject(&quot;Parameter \&quot;preDefinedData\&quot; is mandatory for \&quot;KEKRecipientInfo\&quot;&quot;);
					
				if((&quot;keyDerivationAlgorithm&quot; in _this.recipientInfos[index].value) === false)
					return Promise.reject(&quot;Please append encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
					
				if((&quot;algorithmParams&quot; in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)
					return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
					
				try
				{
					pbkdf2Params = new PBKDF2Params({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });
				}
				catch(ex)
				{
					return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
				}
					
				return crypto.importKey(&quot;raw&quot;,
					decryptionParameters.preDefinedData,
					&quot;PBKDF2&quot;,
					false,
					[&quot;deriveKey&quot;]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Derive key for &quot;keyEncryptionAlgorithm&quot;
			currentSequence = currentSequence.then(result =&gt;
			{
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion
				
				//region Get HMAC hash algorithm
				let hmacHashAlgorithm = &quot;SHA-1&quot;;
					
				if(&quot;prf&quot; in pbkdf2Params)
				{
					const algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
					if((&quot;name&quot; in algorithm) === false)
						return Promise.reject(&quot;Incorrect OID for HMAC hash algorithm&quot;);
						
					hmacHashAlgorithm = algorithm.hash.name;
				}
				//endregion
				
				//region Get PBKDF2 &quot;salt&quot; value
				const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
				//endregion
					
				//region Get PBKDF2 iterations count
				const iterations = pbkdf2Params.iterationCount;
				//endregion
					
				return crypto.deriveKey({
					name: &quot;PBKDF2&quot;,
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations
				},
				result,
				kekAlgorithm,
				true,
				[&quot;unwrapKey&quot;]); // Usages are too specific for KEK algorithm
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			//region Unwrap previously exported session key
			currentSequence = currentSequence.then(result =&gt;
			{
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if((&quot;name&quot; in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
					//endregion
					
				return crypto.unwrapKey(&quot;raw&quot;,
					_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,
					result,
					kekAlgorithm,
					contentEncryptionAlgorithm,
					true,
					[&quot;decrypt&quot;]);
			}, error =&gt;
				Promise.reject(error)
			);
			//endregion
			
			return currentSequence;
		}
		
		//endregion
		
		//region Perform steps, specific to each type of session key encryption
		sequence = sequence.then(() =&gt;
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion
				
			switch(this.recipientInfos[recipientIndex].variant)
			{
				case 1: // KeyTransRecipientInfo
					currentSequence = SubKeyTransRecipientInfo(recipientIndex);
					break;
				case 2: // KeyAgreeRecipientInfo
					currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);
					break;
				case 3: // KEKRecipientInfo
					currentSequence = SubKEKRecipientInfo(recipientIndex);
					break;
				case 4: // PasswordRecipientinfo
					currentSequence = SubPasswordRecipientinfo(recipientIndex);
					break;
				default:
					return Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);
			}
				
			return currentSequence;
		}, error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		//region Finally decrypt data by session key
		sequence = sequence.then(result =&gt;
		{
			//region Get WebCrypto form of content encryption algorithm
			const contentEncryptionAlgorithm = getAlgorithmByOID(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
			if((&quot;name&quot; in contentEncryptionAlgorithm) === false)
				return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
			//endregion
			
			//region Get &quot;intialization vector&quot; for content encryption algorithm
			const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
			const ivView = new Uint8Array(ivBuffer);
			//endregion
			
			//region Create correct data block for decryption
			let dataBuffer = new ArrayBuffer(0);
				
			if(this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)
				dataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
			else
			{
				for(const content of this.encryptedContentInfo.encryptedContent.valueBlock.value)
					dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);
			}
			//endregion
				
			return crypto.decrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			},
			result,
			dataBuffer);
		}, error =&gt;
			Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
