<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/one-var.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/one-var.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.41</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">718</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.94</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview A rule to control the use of single variable declarations.
 * @author Ian Christian Myers
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determines whether the given node is in a statement list.
 * @param {ASTNode} node node to check
 * @returns {boolean} `true` if the given node is in a statement list
 */
function isInStatementList(node) {
	return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		docs: {
			description:
				&quot;Enforce variables to be declared either together or separately in functions&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/one-var&quot;,
		},

		fixable: &quot;code&quot;,

		schema: [
			{
				oneOf: [
					{
						enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
					},
					{
						type: &quot;object&quot;,
						properties: {
							separateRequires: {
								type: &quot;boolean&quot;,
							},
							var: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
							let: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
							const: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
							using: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
							awaitUsing: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
						},
						additionalProperties: false,
					},
					{
						type: &quot;object&quot;,
						properties: {
							initialized: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
							uninitialized: {
								enum: [&quot;always&quot;, &quot;never&quot;, &quot;consecutive&quot;],
							},
						},
						additionalProperties: false,
					},
				],
			},
		],

		messages: {
			combineUninitialized:
				&quot;Combine this with the previous &#039;{{type}}&#039; statement with uninitialized variables.&quot;,
			combineInitialized:
				&quot;Combine this with the previous &#039;{{type}}&#039; statement with initialized variables.&quot;,
			splitUninitialized:
				&quot;Split uninitialized &#039;{{type}}&#039; declarations into multiple statements.&quot;,
			splitInitialized:
				&quot;Split initialized &#039;{{type}}&#039; declarations into multiple statements.&quot;,
			splitRequires:
				&quot;Split requires to be separated into a single block.&quot;,
			combine: &quot;Combine this with the previous &#039;{{type}}&#039; statement.&quot;,
			split: &quot;Split &#039;{{type}}&#039; declarations into multiple statements.&quot;,
		},
	},

	create(context) {
		const MODE_ALWAYS = &quot;always&quot;;
		const MODE_NEVER = &quot;never&quot;;
		const MODE_CONSECUTIVE = &quot;consecutive&quot;;
		const mode = context.options[0] || MODE_ALWAYS;

		const options = {};

		if (typeof mode === &quot;string&quot;) {
			// simple options configuration with just a string
			options.var = { uninitialized: mode, initialized: mode };
			options.let = { uninitialized: mode, initialized: mode };
			options.const = { uninitialized: mode, initialized: mode };
			options.using = { uninitialized: mode, initialized: mode };
			options.awaitUsing = { uninitialized: mode, initialized: mode };
		} else if (typeof mode === &quot;object&quot;) {
			// options configuration is an object
			options.separateRequires = !!mode.separateRequires;
			options.var = { uninitialized: mode.var, initialized: mode.var };
			options.let = { uninitialized: mode.let, initialized: mode.let };
			options.const = {
				uninitialized: mode.const,
				initialized: mode.const,
			};
			options.using = {
				uninitialized: mode.using,
				initialized: mode.using,
			};
			options.awaitUsing = {
				uninitialized: mode.awaitUsing,
				initialized: mode.awaitUsing,
			};
			if (Object.hasOwn(mode, &quot;uninitialized&quot;)) {
				options.var.uninitialized = mode.uninitialized;
				options.let.uninitialized = mode.uninitialized;
				options.const.uninitialized = mode.uninitialized;
				options.using.uninitialized = mode.uninitialized;
				options.awaitUsing.uninitialized = mode.uninitialized;
			}
			if (Object.hasOwn(mode, &quot;initialized&quot;)) {
				options.var.initialized = mode.initialized;
				options.let.initialized = mode.initialized;
				options.const.initialized = mode.initialized;
				options.using.initialized = mode.initialized;
				options.awaitUsing.initialized = mode.initialized;
			}
		}

		const sourceCode = context.sourceCode;

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		const functionStack = [];
		const blockStack = [];

		/**
		 * Increments the blockStack counter.
		 * @returns {void}
		 * @private
		 */
		function startBlock() {
			blockStack.push({
				let: { initialized: false, uninitialized: false },
				const: { initialized: false, uninitialized: false },
				using: { initialized: false, uninitialized: false },
				awaitUsing: { initialized: false, uninitialized: false },
			});
		}

		/**
		 * Increments the functionStack counter.
		 * @returns {void}
		 * @private
		 */
		function startFunction() {
			functionStack.push({ initialized: false, uninitialized: false });
			startBlock();
		}

		/**
		 * Decrements the blockStack counter.
		 * @returns {void}
		 * @private
		 */
		function endBlock() {
			blockStack.pop();
		}

		/**
		 * Decrements the functionStack counter.
		 * @returns {void}
		 * @private
		 */
		function endFunction() {
			functionStack.pop();
			endBlock();
		}

		/**
		 * Check if a variable declaration is a require.
		 * @param {ASTNode} decl variable declaration Node
		 * @returns {bool} if decl is a require, return true; else return false.
		 * @private
		 */
		function isRequire(decl) {
			return (
				decl.init &amp;&amp;
				decl.init.type === &quot;CallExpression&quot; &amp;&amp;
				decl.init.callee.name === &quot;require&quot;
			);
		}

		/**
		 * Records whether initialized/uninitialized/required variables are defined in current scope.
		 * @param {string} statementType one of: &quot;var&quot;, &quot;let&quot;, &quot;const&quot;, &quot;using&quot;, or &quot;awaitUsing&quot;
		 * @param {ASTNode[]} declarations List of declarations
		 * @param {Object} currentScope The scope being investigated
		 * @returns {void}
		 * @private
		 */
		function recordTypes(statementType, declarations, currentScope) {
			for (let i = 0; i &lt; declarations.length; i++) {
				if (declarations[i].init === null) {
					if (
						options[statementType] &amp;&amp;
						options[statementType].uninitialized === MODE_ALWAYS
					) {
						currentScope.uninitialized = true;
					}
				} else {
					if (
						options[statementType] &amp;&amp;
						options[statementType].initialized === MODE_ALWAYS
					) {
						if (
							options.separateRequires &amp;&amp;
							isRequire(declarations[i])
						) {
							currentScope.required = true;
						} else {
							currentScope.initialized = true;
						}
					}
				}
			}
		}

		/**
		 * Determines the current scope (function or block)
		 * @param {string} statementType one of: &quot;var&quot;, &quot;let&quot;, &quot;const&quot;, &quot;using&quot;, or &quot;awaitUsing&quot;
		 * @returns {Object} The scope associated with statementType
		 */
		function getCurrentScope(statementType) {
			let currentScope;

			if (statementType === &quot;var&quot;) {
				currentScope = functionStack.at(-1);
			} else if (statementType === &quot;let&quot;) {
				currentScope = blockStack.at(-1).let;
			} else if (statementType === &quot;const&quot;) {
				currentScope = blockStack.at(-1).const;
			} else if (statementType === &quot;using&quot;) {
				currentScope = blockStack.at(-1).using;
			} else if (statementType === &quot;awaitUsing&quot;) {
				currentScope = blockStack.at(-1).awaitUsing;
			}
			return currentScope;
		}

		/**
		 * Counts the number of initialized and uninitialized declarations in a list of declarations
		 * @param {ASTNode[]} declarations List of declarations
		 * @returns {Object} Counts of &#039;uninitialized&#039; and &#039;initialized&#039; declarations
		 * @private
		 */
		function countDeclarations(declarations) {
			const counts = { uninitialized: 0, initialized: 0 };

			for (let i = 0; i &lt; declarations.length; i++) {
				if (declarations[i].init === null) {
					counts.uninitialized++;
				} else {
					counts.initialized++;
				}
			}
			return counts;
		}

		/**
		 * Determines if there is more than one var statement in the current scope.
		 * @param {string} statementType one of: &quot;var&quot;, &quot;let&quot;, &quot;const&quot;, &quot;using&quot;, or &quot;awaitUsing&quot;
		 * @param {ASTNode[]} declarations List of declarations
		 * @returns {boolean} Returns true if it is the first var declaration, false if not.
		 * @private
		 */
		function hasOnlyOneStatement(statementType, declarations) {
			const declarationCounts = countDeclarations(declarations);
			const currentOptions = options[statementType] || {};
			const currentScope = getCurrentScope(statementType);
			const hasRequires = declarations.some(isRequire);

			if (
				currentOptions.uninitialized === MODE_ALWAYS &amp;&amp;
				currentOptions.initialized === MODE_ALWAYS
			) {
				if (currentScope.uninitialized || currentScope.initialized) {
					if (!hasRequires) {
						return false;
					}
				}
			}

			if (declarationCounts.uninitialized &gt; 0) {
				if (
					currentOptions.uninitialized === MODE_ALWAYS &amp;&amp;
					currentScope.uninitialized
				) {
					return false;
				}
			}
			if (declarationCounts.initialized &gt; 0) {
				if (
					currentOptions.initialized === MODE_ALWAYS &amp;&amp;
					currentScope.initialized
				) {
					if (!hasRequires) {
						return false;
					}
				}
			}
			if (currentScope.required &amp;&amp; hasRequires) {
				return false;
			}
			recordTypes(statementType, declarations, currentScope);
			return true;
		}

		/**
		 * Fixer to join VariableDeclaration&#039;s into a single declaration
		 * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join
		 * @returns {Function} The fixer function
		 */
		function joinDeclarations(declarations) {
			const declaration = declarations[0];
			const body = Array.isArray(declaration.parent.parent.body)
				? declaration.parent.parent.body
				: [];
			const currentIndex = body.findIndex(
				node =&gt; node.range[0] === declaration.parent.range[0],
			);
			const previousNode = body[currentIndex - 1];

			return function* joinDeclarationsFixer(fixer) {
				const type = sourceCode.getFirstToken(declaration.parent);
				const beforeType = sourceCode.getTokenBefore(type);

				if (
					previousNode &amp;&amp;
					previousNode.kind === declaration.parent.kind
				) {
					if (beforeType.value === &quot;;&quot;) {
						yield fixer.replaceText(beforeType, &quot;,&quot;);
					} else {
						yield fixer.insertTextAfter(beforeType, &quot;,&quot;);
					}

					if (declaration.parent.kind === &quot;await using&quot;) {
						const usingToken = sourceCode.getTokenAfter(type);
						yield fixer.remove(usingToken);
					}

					yield fixer.replaceText(type, &quot;&quot;);
				}
			};
		}

		/**
		 * Fixer to split a VariableDeclaration into individual declarations
		 * @param {VariableDeclaration} declaration The `VariableDeclaration` to split
		 * @returns {Function|null} The fixer function
		 */
		function splitDeclarations(declaration) {
			const { parent } = declaration;

			// don&#039;t autofix code such as: if (foo) var x, y;
			if (
				!isInStatementList(
					parent.type === &quot;ExportNamedDeclaration&quot;
						? parent
						: declaration,
				)
			) {
				return null;
			}

			return fixer =&gt;
				declaration.declarations
					.map(declarator =&gt; {
						const tokenAfterDeclarator =
							sourceCode.getTokenAfter(declarator);

						if (tokenAfterDeclarator === null) {
							return null;
						}

						const afterComma = sourceCode.getTokenAfter(
							tokenAfterDeclarator,
							{ includeComments: true },
						);

						if (tokenAfterDeclarator.value !== &quot;,&quot;) {
							return null;
						}

						const exportPlacement =
							declaration.parent.type === &quot;ExportNamedDeclaration&quot;
								? &quot;export &quot;
								: &quot;&quot;;

						/*
						 * `var x,y`
						 * tokenAfterDeclarator ^^ afterComma
						 */
						if (
							afterComma.range[0] ===
							tokenAfterDeclarator.range[1]
						) {
							return fixer.replaceText(
								tokenAfterDeclarator,
								`; ${exportPlacement}${declaration.kind} `,
							);
						}

						/*
						 * `var x,
						 * tokenAfterDeclarator ^
						 *      y`
						 *      ^ afterComma
						 */
						if (
							afterComma.loc.start.line &gt;
								tokenAfterDeclarator.loc.end.line ||
							afterComma.type === &quot;Line&quot; ||
							afterComma.type === &quot;Block&quot;
						) {
							let lastComment = afterComma;

							while (
								lastComment.type === &quot;Line&quot; ||
								lastComment.type === &quot;Block&quot;
							) {
								lastComment = sourceCode.getTokenAfter(
									lastComment,
									{ includeComments: true },
								);
							}

							return fixer.replaceTextRange(
								[
									tokenAfterDeclarator.range[0],
									lastComment.range[0],
								],
								`;${sourceCode.text.slice(
									tokenAfterDeclarator.range[1],
									lastComment.range[0],
								)}${exportPlacement}${declaration.kind} `,
							);
						}

						return fixer.replaceText(
							tokenAfterDeclarator,
							`; ${exportPlacement}${declaration.kind}`,
						);
					})
					.filter(x =&gt; x);
		}

		/**
		 * Checks a given VariableDeclaration node for errors.
		 * @param {ASTNode} node The VariableDeclaration node to check
		 * @returns {void}
		 * @private
		 */
		function checkVariableDeclaration(node) {
			const parent = node.parent;
			const type = node.kind;
			const key = type === &quot;await using&quot; ? &quot;awaitUsing&quot; : type;

			if (!options[key]) {
				return;
			}

			const declarations = node.declarations;
			const declarationCounts = countDeclarations(declarations);
			const mixedRequires =
				declarations.some(isRequire) &amp;&amp; !declarations.every(isRequire);

			if (options[key].initialized === MODE_ALWAYS) {
				if (options.separateRequires &amp;&amp; mixedRequires) {
					context.report({
						node,
						messageId: &quot;splitRequires&quot;,
					});
				}
			}

			// consecutive
			const nodeIndex =
				(parent.body &amp;&amp;
					parent.body.length &gt; 0 &amp;&amp;
					parent.body.indexOf(node)) ||
				0;

			if (nodeIndex &gt; 0) {
				const previousNode = parent.body[nodeIndex - 1];
				const isPreviousNodeDeclaration =
					previousNode.type === &quot;VariableDeclaration&quot;;
				const declarationsWithPrevious = declarations.concat(
					previousNode.declarations || [],
				);

				if (
					isPreviousNodeDeclaration &amp;&amp;
					previousNode.kind === type &amp;&amp;
					!(
						declarationsWithPrevious.some(isRequire) &amp;&amp;
						!declarationsWithPrevious.every(isRequire)
					)
				) {
					const previousDeclCounts = countDeclarations(
						previousNode.declarations,
					);

					if (
						options[key].initialized === MODE_CONSECUTIVE &amp;&amp;
						options[key].uninitialized === MODE_CONSECUTIVE
					) {
						context.report({
							node,
							messageId: &quot;combine&quot;,
							data: {
								type,
							},
							fix: joinDeclarations(declarations),
						});
					} else if (
						options[key].initialized === MODE_CONSECUTIVE &amp;&amp;
						declarationCounts.initialized &gt; 0 &amp;&amp;
						previousDeclCounts.initialized &gt; 0
					) {
						context.report({
							node,
							messageId: &quot;combineInitialized&quot;,
							data: {
								type,
							},
							fix: joinDeclarations(declarations),
						});
					} else if (
						options[key].uninitialized === MODE_CONSECUTIVE &amp;&amp;
						declarationCounts.uninitialized &gt; 0 &amp;&amp;
						previousDeclCounts.uninitialized &gt; 0
					) {
						context.report({
							node,
							messageId: &quot;combineUninitialized&quot;,
							data: {
								type,
							},
							fix: joinDeclarations(declarations),
						});
					}
				}
			}

			// always
			if (!hasOnlyOneStatement(key, declarations)) {
				if (
					options[key].initialized === MODE_ALWAYS &amp;&amp;
					options[key].uninitialized === MODE_ALWAYS
				) {
					context.report({
						node,
						messageId: &quot;combine&quot;,
						data: {
							type,
						},
						fix: joinDeclarations(declarations),
					});
				} else {
					if (
						options[key].initialized === MODE_ALWAYS &amp;&amp;
						declarationCounts.initialized &gt; 0
					) {
						context.report({
							node,
							messageId: &quot;combineInitialized&quot;,
							data: {
								type,
							},
							fix: joinDeclarations(declarations),
						});
					}
					if (
						options[key].uninitialized === MODE_ALWAYS &amp;&amp;
						declarationCounts.uninitialized &gt; 0
					) {
						if (
							node.parent.left === node &amp;&amp;
							(node.parent.type === &quot;ForInStatement&quot; ||
								node.parent.type === &quot;ForOfStatement&quot;)
						) {
							return;
						}
						context.report({
							node,
							messageId: &quot;combineUninitialized&quot;,
							data: {
								type,
							},
							fix: joinDeclarations(declarations),
						});
					}
				}
			}

			// never
			if (parent.type !== &quot;ForStatement&quot; || parent.init !== node) {
				const totalDeclarations =
					declarationCounts.uninitialized +
					declarationCounts.initialized;

				if (totalDeclarations &gt; 1) {
					if (
						options[key].initialized === MODE_NEVER &amp;&amp;
						options[key].uninitialized === MODE_NEVER
					) {
						// both initialized and uninitialized
						context.report({
							node,
							messageId: &quot;split&quot;,
							data: {
								type,
							},
							fix: splitDeclarations(node),
						});
					} else if (
						options[key].initialized === MODE_NEVER &amp;&amp;
						declarationCounts.initialized &gt; 0
					) {
						// initialized
						context.report({
							node,
							messageId: &quot;splitInitialized&quot;,
							data: {
								type,
							},
							fix: splitDeclarations(node),
						});
					} else if (
						options[key].uninitialized === MODE_NEVER &amp;&amp;
						declarationCounts.uninitialized &gt; 0
					) {
						// uninitialized
						context.report({
							node,
							messageId: &quot;splitUninitialized&quot;,
							data: {
								type,
							},
							fix: splitDeclarations(node),
						});
					}
				}
			}
		}

		//--------------------------------------------------------------------------
		// Public API
		//--------------------------------------------------------------------------

		return {
			Program: startFunction,
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,
			StaticBlock: startFunction, // StaticBlock creates a new scope for `var` variables

			BlockStatement: startBlock,
			ForStatement: startBlock,
			ForInStatement: startBlock,
			ForOfStatement: startBlock,
			SwitchStatement: startBlock,
			VariableDeclaration: checkVariableDeclaration,
			&quot;ForStatement:exit&quot;: endBlock,
			&quot;ForOfStatement:exit&quot;: endBlock,
			&quot;ForInStatement:exit&quot;: endBlock,
			&quot;SwitchStatement:exit&quot;: endBlock,
			&quot;BlockStatement:exit&quot;: endBlock,

			&quot;Program:exit&quot;: endFunction,
			&quot;FunctionDeclaration:exit&quot;: endFunction,
			&quot;FunctionExpression:exit&quot;: endFunction,
			&quot;ArrowFunctionExpression:exit&quot;: endFunction,
			&quot;StaticBlock:exit&quot;: endFunction,
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
