<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/clean-css/lib/tokenizer/tokenize.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/clean-css/lib/tokenizer/tokenize.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">37.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">572</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">142.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.84</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var Marker = require(&#039;./marker&#039;);
var Token = require(&#039;./token&#039;);

var formatPosition = require(&#039;../utils/format-position&#039;);

var Level = {
  BLOCK: &#039;block&#039;,
  COMMENT: &#039;comment&#039;,
  DOUBLE_QUOTE: &#039;double-quote&#039;,
  RULE: &#039;rule&#039;,
  SINGLE_QUOTE: &#039;single-quote&#039;
};

var AT_RULES = [
  &#039;@charset&#039;,
  &#039;@import&#039;
];

var BLOCK_RULES = [
  &#039;@-moz-document&#039;,
  &#039;@document&#039;,
  &#039;@-moz-keyframes&#039;,
  &#039;@-ms-keyframes&#039;,
  &#039;@-o-keyframes&#039;,
  &#039;@-webkit-keyframes&#039;,
  &#039;@keyframes&#039;,
  &#039;@media&#039;,
  &#039;@supports&#039;
];

var IGNORE_END_COMMENT_PATTERN = /\/\* clean\-css ignore:end \*\/$/;
var IGNORE_START_COMMENT_PATTERN = /^\/\* clean\-css ignore:start \*\//;

var PAGE_MARGIN_BOXES = [
  &#039;@bottom-center&#039;,
  &#039;@bottom-left&#039;,
  &#039;@bottom-left-corner&#039;,
  &#039;@bottom-right&#039;,
  &#039;@bottom-right-corner&#039;,
  &#039;@left-bottom&#039;,
  &#039;@left-middle&#039;,
  &#039;@left-top&#039;,
  &#039;@right-bottom&#039;,
  &#039;@right-middle&#039;,
  &#039;@right-top&#039;,
  &#039;@top-center&#039;,
  &#039;@top-left&#039;,
  &#039;@top-left-corner&#039;,
  &#039;@top-right&#039;,
  &#039;@top-right-corner&#039;
];

var EXTRA_PAGE_BOXES = [
  &#039;@footnote&#039;,
  &#039;@footnotes&#039;,
  &#039;@left&#039;,
  &#039;@page-float-bottom&#039;,
  &#039;@page-float-top&#039;,
  &#039;@right&#039;
];

var REPEAT_PATTERN = /^\[\s{0,31}\d+\s{0,31}\]$/;
var RULE_WORD_SEPARATOR_PATTERN = /[\s\(]/;
var TAIL_BROKEN_VALUE_PATTERN = /[\s|\}]*$/;

function tokenize(source, externalContext) {
  var internalContext = {
    level: Level.BLOCK,
    position: {
      source: externalContext.source || undefined,
      line: 1,
      column: 0,
      index: 0
    }
  };

  return intoTokens(source, externalContext, internalContext, false);
}

function intoTokens(source, externalContext, internalContext, isNested) {
  var allTokens = [];
  var newTokens = allTokens;
  var lastToken;
  var ruleToken;
  var ruleTokens = [];
  var propertyToken;
  var metadata;
  var metadatas = [];
  var level = internalContext.level;
  var levels = [];
  var buffer = [];
  var buffers = [];
  var serializedBuffer;
  var serializedBufferPart;
  var roundBracketLevel = 0;
  var isQuoted;
  var isSpace;
  var isNewLineNix;
  var isNewLineWin;
  var isCarriageReturn;
  var isCommentStart;
  var wasCommentStart = false;
  var isCommentEnd;
  var wasCommentEnd = false;
  var isCommentEndMarker;
  var isEscaped;
  var wasEscaped = false;
  var isRaw = false;
  var seekingValue = false;
  var seekingPropertyBlockClosing = false;
  var position = internalContext.position;
  var lastCommentStartAt;

  for (; position.index &lt; source.length; position.index++) {
    var character = source[position.index];

    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;
    isSpace = character == Marker.SPACE || character == Marker.TAB;
    isNewLineNix = character == Marker.NEW_LINE_NIX;
    isNewLineWin = character == Marker.NEW_LINE_NIX &amp;&amp; source[position.index - 1] == Marker.CARRIAGE_RETURN;
    isCarriageReturn = character == Marker.CARRIAGE_RETURN &amp;&amp; source[position.index + 1] &amp;&amp; source[position.index + 1] != Marker.NEW_LINE_NIX;
    isCommentStart = !wasCommentEnd &amp;&amp; level != Level.COMMENT &amp;&amp; !isQuoted &amp;&amp; character == Marker.ASTERISK &amp;&amp; source[position.index - 1] == Marker.FORWARD_SLASH;
    isCommentEndMarker = !wasCommentStart &amp;&amp; !isQuoted &amp;&amp; character == Marker.FORWARD_SLASH &amp;&amp; source[position.index - 1] == Marker.ASTERISK;
    isCommentEnd = level == Level.COMMENT &amp;&amp; isCommentEndMarker;
    roundBracketLevel = Math.max(roundBracketLevel, 0);

    metadata = buffer.length === 0 ?
      [position.line, position.column, position.source] :
      metadata;

    if (isEscaped) {
      // previous character was a backslash
      buffer.push(character);
    } else if (!isCommentEnd &amp;&amp; level == Level.COMMENT) {
      buffer.push(character);
    } else if (!isCommentStart &amp;&amp; !isCommentEnd &amp;&amp; isRaw) {
      buffer.push(character);
    } else if (isCommentStart &amp;&amp; (level == Level.BLOCK || level == Level.RULE) &amp;&amp; buffer.length &gt; 1) {
      // comment start within block preceded by some content, e.g. div/*&lt;--
      metadatas.push(metadata);
      buffer.push(character);
      buffers.push(buffer.slice(0, buffer.length - 2));

      buffer = buffer.slice(buffer.length - 2);
      metadata = [position.line, position.column - 1, position.source];

      levels.push(level);
      level = Level.COMMENT;
    } else if (isCommentStart) {
      // comment start, e.g. /*&lt;--
      levels.push(level);
      level = Level.COMMENT;
      buffer.push(character);
    } else if (isCommentEnd &amp;&amp; isIgnoreStartComment(buffer)) {
      // ignore:start comment end, e.g. /* clean-css ignore:start */&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim() + character;
      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
      newTokens.push(lastToken);

      isRaw = true;
      metadata = metadatas.pop() || null;
      buffer = buffers.pop() || [];
    } else if (isCommentEnd &amp;&amp; isIgnoreEndComment(buffer)) {
      // ignore:start comment end, e.g. /* clean-css ignore:end */&lt;--
      serializedBuffer = buffer.join(&#039;&#039;) + character;
      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);

      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);
      lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
      newTokens.push(lastToken);

      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);
      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];
      lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
      newTokens.push(lastToken);

      isRaw = false;
      level = levels.pop();
      metadata = metadatas.pop() || null;
      buffer = buffers.pop() || [];
    } else if (isCommentEnd) {
      // comment end, e.g. /* comment */&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim() + character;
      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
      newTokens.push(lastToken);

      level = levels.pop();
      metadata = metadatas.pop() || null;
      buffer = buffers.pop() || [];
    } else if (isCommentEndMarker &amp;&amp; source[position.index + 1] != Marker.ASTERISK) {
      externalContext.warnings.push(&#039;Unexpected \&#039;*/\&#039; at &#039; + formatPosition([position.line, position.column, position.source]) + &#039;.&#039;);
      buffer = [];
    } else if (character == Marker.SINGLE_QUOTE &amp;&amp; !isQuoted) {
      // single quotation start, e.g. a[href^=&#039;https&lt;--
      levels.push(level);
      level = Level.SINGLE_QUOTE;
      buffer.push(character);
    } else if (character == Marker.SINGLE_QUOTE &amp;&amp; level == Level.SINGLE_QUOTE) {
      // single quotation end, e.g. a[href^=&#039;https&#039;&lt;--
      level = levels.pop();
      buffer.push(character);
    } else if (character == Marker.DOUBLE_QUOTE &amp;&amp; !isQuoted) {
      // double quotation start, e.g. a[href^=&quot;&lt;--
      levels.push(level);
      level = Level.DOUBLE_QUOTE;
      buffer.push(character);
    } else if (character == Marker.DOUBLE_QUOTE &amp;&amp; level == Level.DOUBLE_QUOTE) {
      // double quotation end, e.g. a[href^=&quot;https&quot;&lt;--
      level = levels.pop();
      buffer.push(character);
    } else if (!isCommentStart &amp;&amp; !isCommentEnd &amp;&amp; character != Marker.CLOSE_ROUND_BRACKET &amp;&amp; character != Marker.OPEN_ROUND_BRACKET &amp;&amp; level != Level.COMMENT &amp;&amp; !isQuoted &amp;&amp; roundBracketLevel &gt; 0) {
      // character inside any function, e.g. hsla(.&lt;--
      buffer.push(character);
    } else if (character == Marker.OPEN_ROUND_BRACKET &amp;&amp; !isQuoted &amp;&amp; level != Level.COMMENT &amp;&amp; !seekingValue) {
      // round open bracket, e.g. @import url(&lt;--
      buffer.push(character);

      roundBracketLevel++;
    } else if (character == Marker.CLOSE_ROUND_BRACKET &amp;&amp; !isQuoted &amp;&amp; level != Level.COMMENT &amp;&amp; !seekingValue) {
      // round open bracket, e.g. @import url(test.css)&lt;--
      buffer.push(character);

      roundBracketLevel--;
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.BLOCK &amp;&amp; buffer[0] == Marker.AT) {
      // semicolon ending rule at block level, e.g. @import &#039;...&#039;;&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      buffer = [];
    } else if (character == Marker.COMMA &amp;&amp; level == Level.BLOCK &amp;&amp; ruleToken) {
      // comma separator at block level, e.g. a,div,&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);

      buffer = [];
    } else if (character == Marker.COMMA &amp;&amp; level == Level.BLOCK &amp;&amp; tokenTypeFrom(buffer) == Token.AT_RULE) {
      // comma separator at block level, e.g. @import url(...) screen,&lt;--
      // keep iterating as end semicolon will create the token
      buffer.push(character);
    } else if (character == Marker.COMMA &amp;&amp; level == Level.BLOCK) {
      // comma separator at block level, e.g. a,&lt;--
      ruleToken = [tokenTypeFrom(buffer), [], []];
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);

      buffer = [];
    } else if (character == Marker.OPEN_CURLY_BRACKET &amp;&amp; level == Level.BLOCK &amp;&amp; ruleToken &amp;&amp; ruleToken[0] == Token.NESTED_BLOCK) {
      // open brace opening at-rule at block level, e.g. @media{&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      allTokens.push(ruleToken);

      levels.push(level);
      position.column++;
      position.index++;
      buffer = [];

      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
      ruleToken = null;
    } else if (character == Marker.OPEN_CURLY_BRACKET &amp;&amp; level == Level.BLOCK &amp;&amp; tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {
      // open brace opening at-rule at block level, e.g. @media{&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];
      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      allTokens.push(ruleToken);

      levels.push(level);
      position.column++;
      position.index++;
      buffer = [];

      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
      ruleToken = null;
    } else if (character == Marker.OPEN_CURLY_BRACKET &amp;&amp; level == Level.BLOCK) {
      // open brace opening rule at block level, e.g. div{&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];
      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
      newTokens = ruleToken[2];
      allTokens.push(ruleToken);

      levels.push(level);
      level = Level.RULE;
      buffer = [];
    } else if (character == Marker.OPEN_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; seekingValue) {
      // open brace opening rule at rule level, e.g. div{--variable:{&lt;--
      ruleTokens.push(ruleToken);
      ruleToken = [Token.PROPERTY_BLOCK, []];
      propertyToken.push(ruleToken);
      newTokens = ruleToken[1];

      levels.push(level);
      level = Level.RULE;
      seekingValue = false;
    } else if (character == Marker.OPEN_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; isPageMarginBox(buffer)) {
      // open brace opening page-margin box at rule level, e.g. @page{@top-center{&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleTokens.push(ruleToken);
      ruleToken = [Token.AT_RULE_BLOCK, [], []];
      ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      newTokens.push(ruleToken);
      newTokens = ruleToken[2];

      levels.push(level);
      level = Level.RULE;
      buffer = [];
    } else if (character == Marker.COLON &amp;&amp; level == Level.RULE &amp;&amp; !seekingValue) {
      // colon at rule level, e.g. a{color:&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];
      newTokens.push(propertyToken);

      seekingValue = true;
      buffer = [];
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; ruleTokens.length &gt; 0 &amp;&amp; buffer.length &gt; 0 &amp;&amp; buffer[0] == Marker.AT) {
      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      buffer = [];
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; buffer.length &gt; 0) {
      // semicolon at rule level, e.g. a{color:red;&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      propertyToken = null;
      seekingValue = false;
      buffer = [];
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; buffer.length === 0) {
      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);&lt;--
      propertyToken = null;
      seekingValue = false;
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.RULE &amp;&amp; buffer.length &gt; 0 &amp;&amp; buffer[0] == Marker.AT) {
      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);&lt;--
      serializedBuffer = buffer.join(&#039;&#039;);
      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      seekingValue = false;
      buffer = [];
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.RULE &amp;&amp; seekingPropertyBlockClosing) {
      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};&lt;--
      seekingPropertyBlockClosing = false;
      buffer = [];
    } else if (character == Marker.SEMICOLON &amp;&amp; level == Level.RULE &amp;&amp; buffer.length === 0) {
      // stray semicolon at rule level, e.g. a{;&lt;--
      // noop
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; seekingValue &amp;&amp; buffer.length &gt; 0 &amp;&amp; ruleTokens.length &gt; 0) {
      // close brace at rule level, e.g. a{--color:{color:red}&lt;--
      serializedBuffer = buffer.join(&#039;&#039;);
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      propertyToken = null;
      ruleToken = ruleTokens.pop();
      newTokens = ruleToken[2];

      level = levels.pop();
      seekingValue = false;
      buffer = [];
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; buffer.length &gt; 0 &amp;&amp; buffer[0] == Marker.AT &amp;&amp; ruleTokens.length &gt; 0) {
      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}&lt;--
      serializedBuffer = buffer.join(&#039;&#039;);
      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      propertyToken = null;
      ruleToken = ruleTokens.pop();
      newTokens = ruleToken[2];

      level = levels.pop();
      seekingValue = false;
      buffer = [];
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; ruleTokens.length &gt; 0) {
      // close brace at rule level after space, e.g. a{--color:{color:red }&lt;--
      propertyToken = null;
      ruleToken = ruleTokens.pop();
      newTokens = ruleToken[2];

      level = levels.pop();
      seekingValue = false;
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; propertyToken &amp;&amp; buffer.length &gt; 0) {
      // close brace at rule level, e.g. a{color:red}&lt;--
      serializedBuffer = buffer.join(&#039;&#039;);
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      propertyToken = null;
      ruleToken = ruleTokens.pop();
      newTokens = allTokens;

      level = levels.pop();
      seekingValue = false;
      buffer = [];
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; buffer.length &gt; 0 &amp;&amp; buffer[0] == Marker.AT) {
      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}&lt;--
      propertyToken = null;
      ruleToken = null;
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      newTokens = allTokens;

      level = levels.pop();
      seekingValue = false;
      buffer = [];
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; levels[levels.length - 1] == Level.RULE) {
      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}&lt;--
      propertyToken = null;
      ruleToken = ruleTokens.pop();
      newTokens = ruleToken[2];

      level = levels.pop();
      seekingValue = false;
      seekingPropertyBlockClosing = true;
      buffer = [];
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.RULE) {
      // close brace after a rule, e.g. a{color:red;}&lt;--
      propertyToken = null;
      ruleToken = null;
      newTokens = allTokens;

      level = levels.pop();
      seekingValue = false;
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.BLOCK &amp;&amp; !isNested &amp;&amp; position.index &lt;= source.length - 1) {
      // stray close brace at block level, e.g. a{color:red}color:blue}&lt;--
      externalContext.warnings.push(&#039;Unexpected \&#039;}\&#039; at &#039; + formatPosition([position.line, position.column, position.source]) + &#039;.&#039;);
      buffer.push(character);
    } else if (character == Marker.CLOSE_CURLY_BRACKET &amp;&amp; level == Level.BLOCK) {
      // close brace at block level, e.g. @media screen {...}&lt;--
      break;
    } else if (character == Marker.OPEN_ROUND_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; seekingValue) {
      // round open bracket, e.g. a{color:hsla(&lt;--
      buffer.push(character);
      roundBracketLevel++;
    } else if (character == Marker.CLOSE_ROUND_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; seekingValue &amp;&amp; roundBracketLevel == 1) {
      // round close bracket, e.g. a{color:hsla(0,0%,0%)&lt;--
      buffer.push(character);
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      roundBracketLevel--;
      buffer = [];
    } else if (character == Marker.CLOSE_ROUND_BRACKET &amp;&amp; level == Level.RULE &amp;&amp; seekingValue) {
      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)&lt;--
      buffer.push(character);
      roundBracketLevel--;
    } else if (character == Marker.FORWARD_SLASH &amp;&amp; source[position.index + 1] != Marker.ASTERISK &amp;&amp; level == Level.RULE &amp;&amp; seekingValue &amp;&amp; buffer.length &gt; 0) {
      // forward slash within a property, e.g. a{background:url(image.png) 0 0/&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

      buffer = [];
    } else if (character == Marker.FORWARD_SLASH &amp;&amp; source[position.index + 1] != Marker.ASTERISK &amp;&amp; level == Level.RULE &amp;&amp; seekingValue) {
      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /&lt;--
      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

      buffer = [];
    } else if (character == Marker.COMMA &amp;&amp; level == Level.RULE &amp;&amp; seekingValue &amp;&amp; buffer.length &gt; 0) {
      // comma within a property, e.g. a{background:url(image.png),&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

      buffer = [];
    } else if (character == Marker.COMMA &amp;&amp; level == Level.RULE &amp;&amp; seekingValue) {
      // comma within a property after space, e.g. a{background:url(image.png) ,&lt;--
      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);

      buffer = [];
    } else if (character == Marker.CLOSE_SQUARE_BRACKET &amp;&amp; propertyToken &amp;&amp; propertyToken.length &gt; 1 &amp;&amp; buffer.length &gt; 0 &amp;&amp; isRepeatToken(buffer)) {
      buffer.push(character);
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken[propertyToken.length - 1][1] += serializedBuffer;

      buffer = [];
    } else if ((isSpace || (isNewLineNix &amp;&amp; !isNewLineWin)) &amp;&amp; level == Level.RULE &amp;&amp; seekingValue &amp;&amp; propertyToken &amp;&amp; buffer.length &gt; 0) {
      // space or *nix newline within property, e.g. a{margin:0 &lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      buffer = [];
    } else if (isNewLineWin &amp;&amp; level == Level.RULE &amp;&amp; seekingValue &amp;&amp; propertyToken &amp;&amp; buffer.length &gt; 1) {
      // win newline within property, e.g. a{margin:0\r\n&lt;--
      serializedBuffer = buffer.join(&#039;&#039;).trim();
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

      buffer = [];
    } else if (isNewLineWin &amp;&amp; level == Level.RULE &amp;&amp; seekingValue) {
      // win newline
      buffer = [];
    } else if (buffer.length == 1 &amp;&amp; isNewLineWin) {
      // ignore windows newline which is composed of two characters
      buffer.pop();
    } else if (buffer.length &gt; 0 || !isSpace &amp;&amp; !isNewLineNix &amp;&amp; !isNewLineWin &amp;&amp; !isCarriageReturn) {
      // any character
      buffer.push(character);
    }

    wasEscaped = isEscaped;
    isEscaped = !wasEscaped &amp;&amp; character == Marker.BACK_SLASH;
    wasCommentStart = isCommentStart;
    wasCommentEnd = isCommentEnd;

    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;
    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;
  }

  if (seekingValue) {
    externalContext.warnings.push(&#039;Missing \&#039;}\&#039; at &#039; + formatPosition([position.line, position.column, position.source]) + &#039;.&#039;);
  }

  if (seekingValue &amp;&amp; buffer.length &gt; 0) {
    serializedBuffer = buffer.join(&#039;&#039;).replace(TAIL_BROKEN_VALUE_PATTERN, &#039;&#039;);
    propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);

    buffer = [];
  }

  if (buffer.length &gt; 0) {
    externalContext.warnings.push(&#039;Invalid character(s) \&#039;&#039; + buffer.join(&#039;&#039;) + &#039;\&#039; at &#039; + formatPosition(metadata) + &#039;. Ignoring.&#039;);
  }

  return allTokens;
}

function isIgnoreStartComment(buffer) {
  return IGNORE_START_COMMENT_PATTERN.test(buffer.join(&#039;&#039;) + Marker.FORWARD_SLASH);
}

function isIgnoreEndComment(buffer) {
  return IGNORE_END_COMMENT_PATTERN.test(buffer.join(&#039;&#039;) + Marker.FORWARD_SLASH);
}

function originalMetadata(metadata, value, externalContext, selectorFallbacks) {
  var source = metadata[2];

  return externalContext.inputSourceMapTracker.isTracking(source) ?
    externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) :
    metadata;
}

function tokenTypeFrom(buffer) {
  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;
  var ruleWord = buffer.join(&#039;&#039;).split(RULE_WORD_SEPARATOR_PATTERN)[0];

  if (isAtRule &amp;&amp; BLOCK_RULES.indexOf(ruleWord) &gt; -1) {
    return Token.NESTED_BLOCK;
  } else if (isAtRule &amp;&amp; AT_RULES.indexOf(ruleWord) &gt; -1) {
    return Token.AT_RULE;
  } else if (isAtRule) {
    return Token.AT_RULE_BLOCK;
  } else {
    return Token.RULE;
  }
}

function tokenScopeFrom(tokenType) {
  if (tokenType == Token.RULE) {
    return Token.RULE_SCOPE;
  } else if (tokenType == Token.NESTED_BLOCK) {
    return Token.NESTED_BLOCK_SCOPE;
  } else if (tokenType == Token.AT_RULE_BLOCK) {
    return Token.AT_RULE_BLOCK_SCOPE;
  }
}

function isPageMarginBox(buffer) {
  var serializedBuffer = buffer.join(&#039;&#039;).trim();

  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) &gt; -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) &gt; -1;
}

function isRepeatToken(buffer) {
  return REPEAT_PATTERN.test(buffer.join(&#039;&#039;) + Marker.CLOSE_SQUARE_BRACKET);
}

module.exports = tokenize;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
