<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/func-name-matching.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/func-name-matching.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">339</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">43.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.95</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.
 * @author Annie Zhang, Pavel Strashkin
 */

&quot;use strict&quot;;

//--------------------------------------------------------------------------
// Requirements
//--------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);
const esutils = require(&quot;esutils&quot;);

//--------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------

/**
 * Determines if a pattern is `module.exports` or `module[&quot;exports&quot;]`
 * @param {ASTNode} pattern The left side of the AssignmentExpression
 * @returns {boolean} True if the pattern is `module.exports` or `module[&quot;exports&quot;]`
 */
function isModuleExports(pattern) {
	if (
		pattern.type === &quot;MemberExpression&quot; &amp;&amp;
		pattern.object.type === &quot;Identifier&quot; &amp;&amp;
		pattern.object.name === &quot;module&quot;
	) {
		// module.exports
		if (
			pattern.property.type === &quot;Identifier&quot; &amp;&amp;
			pattern.property.name === &quot;exports&quot;
		) {
			return true;
		}

		// module[&quot;exports&quot;]
		if (
			pattern.property.type === &quot;Literal&quot; &amp;&amp;
			pattern.property.value === &quot;exports&quot;
		) {
			return true;
		}
	}
	return false;
}

/**
 * Determines if a string name is a valid identifier
 * @param {string} name The string to be checked
 * @param {number} ecmaVersion The ECMAScript version if specified in the parserOptions config
 * @returns {boolean} True if the string is a valid identifier
 */
function isIdentifier(name, ecmaVersion) {
	if (ecmaVersion &gt;= 2015) {
		return esutils.keyword.isIdentifierES6(name);
	}
	return esutils.keyword.isIdentifierES5(name);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const alwaysOrNever = { enum: [&quot;always&quot;, &quot;never&quot;] };
const optionsObject = {
	type: &quot;object&quot;,
	properties: {
		considerPropertyDescriptor: {
			type: &quot;boolean&quot;,
		},
		includeCommonJSModuleExports: {
			type: &quot;boolean&quot;,
		},
	},
	additionalProperties: false,
};

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		docs: {
			description:
				&quot;Require function names to match the name of the variable or property to which they are assigned&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/func-name-matching&quot;,
		},

		schema: {
			anyOf: [
				{
					type: &quot;array&quot;,
					additionalItems: false,
					items: [alwaysOrNever, optionsObject],
				},
				{
					type: &quot;array&quot;,
					additionalItems: false,
					items: [optionsObject],
				},
			],
		},

		messages: {
			matchProperty:
				&quot;Function name `{{funcName}}` should match property name `{{name}}`.&quot;,
			matchVariable:
				&quot;Function name `{{funcName}}` should match variable name `{{name}}`.&quot;,
			notMatchProperty:
				&quot;Function name `{{funcName}}` should not match property name `{{name}}`.&quot;,
			notMatchVariable:
				&quot;Function name `{{funcName}}` should not match variable name `{{name}}`.&quot;,
		},
	},

	create(context) {
		const options =
			(typeof context.options[0] === &quot;object&quot;
				? context.options[0]
				: context.options[1]) || {};
		const nameMatches =
			typeof context.options[0] === &quot;string&quot;
				? context.options[0]
				: &quot;always&quot;;
		const considerPropertyDescriptor = options.considerPropertyDescriptor;
		const includeModuleExports = options.includeCommonJSModuleExports;
		const ecmaVersion = context.languageOptions.ecmaVersion;

		/**
		 * Check whether node is a certain CallExpression.
		 * @param {string} objName object name
		 * @param {string} funcName function name
		 * @param {ASTNode} node The node to check
		 * @returns {boolean} `true` if node matches CallExpression
		 */
		function isPropertyCall(objName, funcName, node) {
			if (!node) {
				return false;
			}
			return (
				node.type === &quot;CallExpression&quot; &amp;&amp;
				astUtils.isSpecificMemberAccess(node.callee, objName, funcName)
			);
		}

		/**
		 * Compares identifiers based on the nameMatches option
		 * @param {string} x the first identifier
		 * @param {string} y the second identifier
		 * @returns {boolean} whether the two identifiers should warn.
		 */
		function shouldWarn(x, y) {
			return (
				(nameMatches === &quot;always&quot; &amp;&amp; x !== y) ||
				(nameMatches === &quot;never&quot; &amp;&amp; x === y)
			);
		}

		/**
		 * Reports
		 * @param {ASTNode} node The node to report
		 * @param {string} name The variable or property name
		 * @param {string} funcName The function name
		 * @param {boolean} isProp True if the reported node is a property assignment
		 * @returns {void}
		 */
		function report(node, name, funcName, isProp) {
			let messageId;

			if (nameMatches === &quot;always&quot; &amp;&amp; isProp) {
				messageId = &quot;matchProperty&quot;;
			} else if (nameMatches === &quot;always&quot;) {
				messageId = &quot;matchVariable&quot;;
			} else if (isProp) {
				messageId = &quot;notMatchProperty&quot;;
			} else {
				messageId = &quot;notMatchVariable&quot;;
			}
			context.report({
				node,
				messageId,
				data: {
					name,
					funcName,
				},
			});
		}

		/**
		 * Determines whether a given node is a string literal
		 * @param {ASTNode} node The node to check
		 * @returns {boolean} `true` if the node is a string literal
		 */
		function isStringLiteral(node) {
			return node.type === &quot;Literal&quot; &amp;&amp; typeof node.value === &quot;string&quot;;
		}

		//--------------------------------------------------------------------------
		// Public
		//--------------------------------------------------------------------------

		return {
			VariableDeclarator(node) {
				if (
					!node.init ||
					node.init.type !== &quot;FunctionExpression&quot; ||
					node.id.type !== &quot;Identifier&quot;
				) {
					return;
				}
				if (
					node.init.id &amp;&amp;
					shouldWarn(node.id.name, node.init.id.name)
				) {
					report(node, node.id.name, node.init.id.name, false);
				}
			},

			AssignmentExpression(node) {
				if (
					node.right.type !== &quot;FunctionExpression&quot; ||
					(node.left.computed &amp;&amp;
						node.left.property.type !== &quot;Literal&quot;) ||
					(!includeModuleExports &amp;&amp; isModuleExports(node.left)) ||
					(node.left.type !== &quot;Identifier&quot; &amp;&amp;
						node.left.type !== &quot;MemberExpression&quot;)
				) {
					return;
				}

				const isProp = node.left.type === &quot;MemberExpression&quot;;
				const name = isProp
					? astUtils.getStaticPropertyName(node.left)
					: node.left.name;

				if (
					node.right.id &amp;&amp;
					name &amp;&amp;
					isIdentifier(name) &amp;&amp;
					shouldWarn(name, node.right.id.name)
				) {
					report(node, name, node.right.id.name, isProp);
				}
			},

			&quot;Property, PropertyDefinition[value]&quot;(node) {
				if (
					!(node.value.type === &quot;FunctionExpression&quot; &amp;&amp; node.value.id)
				) {
					return;
				}

				if (node.key.type === &quot;Identifier&quot; &amp;&amp; !node.computed) {
					const functionName = node.value.id.name;
					let propertyName = node.key.name;

					if (
						considerPropertyDescriptor &amp;&amp;
						propertyName === &quot;value&quot; &amp;&amp;
						node.parent.type === &quot;ObjectExpression&quot;
					) {
						if (
							isPropertyCall(
								&quot;Object&quot;,
								&quot;defineProperty&quot;,
								node.parent.parent,
							) ||
							isPropertyCall(
								&quot;Reflect&quot;,
								&quot;defineProperty&quot;,
								node.parent.parent,
							)
						) {
							const property = node.parent.parent.arguments[1];

							if (
								isStringLiteral(property) &amp;&amp;
								shouldWarn(property.value, functionName)
							) {
								report(
									node,
									property.value,
									functionName,
									true,
								);
							}
						} else if (
							isPropertyCall(
								&quot;Object&quot;,
								&quot;defineProperties&quot;,
								node.parent.parent.parent.parent,
							)
						) {
							propertyName = node.parent.parent.key.name;
							if (
								!node.parent.parent.computed &amp;&amp;
								shouldWarn(propertyName, functionName)
							) {
								report(node, propertyName, functionName, true);
							}
						} else if (
							isPropertyCall(
								&quot;Object&quot;,
								&quot;create&quot;,
								node.parent.parent.parent.parent,
							)
						) {
							propertyName = node.parent.parent.key.name;
							if (
								!node.parent.parent.computed &amp;&amp;
								shouldWarn(propertyName, functionName)
							) {
								report(node, propertyName, functionName, true);
							}
						} else if (shouldWarn(propertyName, functionName)) {
							report(node, propertyName, functionName, true);
						}
					} else if (shouldWarn(propertyName, functionName)) {
						report(node, propertyName, functionName, true);
					}
					return;
				}

				if (
					isStringLiteral(node.key) &amp;&amp;
					isIdentifier(node.key.value, ecmaVersion) &amp;&amp;
					shouldWarn(node.key.value, node.value.id.name)
				) {
					report(node, node.key.value, node.value.id.name, true);
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
