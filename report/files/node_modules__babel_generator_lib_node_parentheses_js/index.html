<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/@babel/generator/lib/node/parentheses.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/@babel/generator/lib/node/parentheses.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">263</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.23</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.AssignmentExpression = AssignmentExpression;
exports.Binary = Binary;
exports.BinaryExpression = BinaryExpression;
exports.ClassExpression = ClassExpression;
exports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;
exports.DoExpression = DoExpression;
exports.FunctionExpression = FunctionExpression;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.Identifier = Identifier;
exports.LogicalExpression = LogicalExpression;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.ObjectExpression = ObjectExpression;
exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
exports.SequenceExpression = SequenceExpression;
exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
exports.TSConditionalType = TSConditionalType;
exports.TSConstructorType = exports.TSFunctionType = TSFunctionType;
exports.TSInferType = TSInferType;
exports.TSInstantiationExpression = TSInstantiationExpression;
exports.TSIntersectionType = TSIntersectionType;
exports.UnaryLike = exports.TSTypeAssertion = UnaryLike;
exports.TSTypeOperator = TSTypeOperator;
exports.TSUnionType = TSUnionType;
exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.UpdateExpression = UpdateExpression;
exports.AwaitExpression = exports.YieldExpression = YieldExpression;
var _t = require(&quot;@babel/types&quot;);
var _index = require(&quot;./index.js&quot;);
const {
  isArrayTypeAnnotation,
  isBinaryExpression,
  isCallExpression,
  isForOfStatement,
  isIndexedAccessType,
  isMemberExpression,
  isObjectPattern,
  isOptionalMemberExpression,
  isYieldExpression,
  isStatement
} = _t;
const PRECEDENCE = new Map([[&quot;||&quot;, 0], [&quot;??&quot;, 0], [&quot;|&gt;&quot;, 0], [&quot;&amp;&amp;&quot;, 1], [&quot;|&quot;, 2], [&quot;^&quot;, 3], [&quot;&amp;&quot;, 4], [&quot;==&quot;, 5], [&quot;===&quot;, 5], [&quot;!=&quot;, 5], [&quot;!==&quot;, 5], [&quot;&lt;&quot;, 6], [&quot;&gt;&quot;, 6], [&quot;&lt;=&quot;, 6], [&quot;&gt;=&quot;, 6], [&quot;in&quot;, 6], [&quot;instanceof&quot;, 6], [&quot;&gt;&gt;&quot;, 7], [&quot;&lt;&lt;&quot;, 7], [&quot;&gt;&gt;&gt;&quot;, 7], [&quot;+&quot;, 8], [&quot;-&quot;, 8], [&quot;*&quot;, 9], [&quot;/&quot;, 9], [&quot;%&quot;, 9], [&quot;**&quot;, 10]]);
function getBinaryPrecedence(node, nodeType) {
  if (nodeType === &quot;BinaryExpression&quot; || nodeType === &quot;LogicalExpression&quot;) {
    return PRECEDENCE.get(node.operator);
  }
  if (nodeType === &quot;TSAsExpression&quot; || nodeType === &quot;TSSatisfiesExpression&quot;) {
    return PRECEDENCE.get(&quot;in&quot;);
  }
}
function isTSTypeExpression(nodeType) {
  return nodeType === &quot;TSAsExpression&quot; || nodeType === &quot;TSSatisfiesExpression&quot; || nodeType === &quot;TSTypeAssertion&quot;;
}
const isClassExtendsClause = (node, parent) =&gt; {
  const parentType = parent.type;
  return (parentType === &quot;ClassDeclaration&quot; || parentType === &quot;ClassExpression&quot;) &amp;&amp; parent.superClass === node;
};
const hasPostfixPart = (node, parent) =&gt; {
  const parentType = parent.type;
  return (parentType === &quot;MemberExpression&quot; || parentType === &quot;OptionalMemberExpression&quot;) &amp;&amp; parent.object === node || (parentType === &quot;CallExpression&quot; || parentType === &quot;OptionalCallExpression&quot; || parentType === &quot;NewExpression&quot;) &amp;&amp; parent.callee === node || parentType === &quot;TaggedTemplateExpression&quot; &amp;&amp; parent.tag === node || parentType === &quot;TSNonNullExpression&quot;;
};
function NullableTypeAnnotation(node, parent) {
  return isArrayTypeAnnotation(parent);
}
function FunctionTypeAnnotation(node, parent, tokenContext) {
  const parentType = parent.type;
  return (parentType === &quot;UnionTypeAnnotation&quot; || parentType === &quot;IntersectionTypeAnnotation&quot; || parentType === &quot;ArrayTypeAnnotation&quot; || Boolean(tokenContext &amp; _index.TokenContext.arrowFlowReturnType)
  );
}
function UpdateExpression(node, parent) {
  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
}
function needsParenBeforeExpressionBrace(tokenContext) {
  return Boolean(tokenContext &amp; (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
}
function ObjectExpression(node, parent, tokenContext) {
  return needsParenBeforeExpressionBrace(tokenContext);
}
function DoExpression(node, parent, tokenContext) {
  return !node.async &amp;&amp; Boolean(tokenContext &amp; _index.TokenContext.expressionStatement);
}
function Binary(node, parent) {
  const parentType = parent.type;
  if (node.type === &quot;BinaryExpression&quot; &amp;&amp; node.operator === &quot;**&quot; &amp;&amp; parentType === &quot;BinaryExpression&quot; &amp;&amp; parent.operator === &quot;**&quot;) {
    return parent.left === node;
  }
  if (isClassExtendsClause(node, parent)) {
    return true;
  }
  if (hasPostfixPart(node, parent) || parentType === &quot;UnaryExpression&quot; || parentType === &quot;SpreadElement&quot; || parentType === &quot;AwaitExpression&quot;) {
    return true;
  }
  const parentPos = getBinaryPrecedence(parent, parentType);
  if (parentPos != null) {
    const nodePos = getBinaryPrecedence(node, node.type);
    if (parentPos === nodePos &amp;&amp; parentType === &quot;BinaryExpression&quot; &amp;&amp; parent.right === node || parentPos &gt; nodePos) {
      return true;
    }
  }
  return undefined;
}
function UnionTypeAnnotation(node, parent) {
  const parentType = parent.type;
  return parentType === &quot;ArrayTypeAnnotation&quot; || parentType === &quot;NullableTypeAnnotation&quot; || parentType === &quot;IntersectionTypeAnnotation&quot; || parentType === &quot;UnionTypeAnnotation&quot;;
}
function OptionalIndexedAccessType(node, parent) {
  return isIndexedAccessType(parent) &amp;&amp; parent.objectType === node;
}
function TSAsExpression(node, parent) {
  if ((parent.type === &quot;AssignmentExpression&quot; || parent.type === &quot;AssignmentPattern&quot;) &amp;&amp; parent.left === node) {
    return true;
  }
  if (parent.type === &quot;BinaryExpression&quot; &amp;&amp; (parent.operator === &quot;|&quot; || parent.operator === &quot;&amp;&quot;) &amp;&amp; node === parent.left) {
    return true;
  }
  return Binary(node, parent);
}
function TSConditionalType(node, parent) {
  const parentType = parent.type;
  if (parentType === &quot;TSArrayType&quot; || parentType === &quot;TSIndexedAccessType&quot; &amp;&amp; parent.objectType === node || parentType === &quot;TSOptionalType&quot; || parentType === &quot;TSTypeOperator&quot; || parentType === &quot;TSTypeParameter&quot;) {
    return true;
  }
  if ((parentType === &quot;TSIntersectionType&quot; || parentType === &quot;TSUnionType&quot;) &amp;&amp; parent.types[0] === node) {
    return true;
  }
  if (parentType === &quot;TSConditionalType&quot; &amp;&amp; (parent.checkType === node || parent.extendsType === node)) {
    return true;
  }
  return false;
}
function TSUnionType(node, parent) {
  const parentType = parent.type;
  return parentType === &quot;TSIntersectionType&quot; || parentType === &quot;TSTypeOperator&quot; || parentType === &quot;TSArrayType&quot; || parentType === &quot;TSIndexedAccessType&quot; &amp;&amp; parent.objectType === node || parentType === &quot;TSOptionalType&quot;;
}
function TSIntersectionType(node, parent) {
  const parentType = parent.type;
  return parentType === &quot;TSTypeOperator&quot; || parentType === &quot;TSArrayType&quot; || parentType === &quot;TSIndexedAccessType&quot; &amp;&amp; parent.objectType === node || parentType === &quot;TSOptionalType&quot;;
}
function TSInferType(node, parent) {
  const parentType = parent.type;
  if (parentType === &quot;TSArrayType&quot; || parentType === &quot;TSIndexedAccessType&quot; &amp;&amp; parent.objectType === node || parentType === &quot;TSOptionalType&quot;) {
    return true;
  }
  if (node.typeParameter.constraint) {
    if ((parentType === &quot;TSIntersectionType&quot; || parentType === &quot;TSUnionType&quot;) &amp;&amp; parent.types[0] === node) {
      return true;
    }
  }
  return false;
}
function TSTypeOperator(node, parent) {
  const parentType = parent.type;
  return parentType === &quot;TSArrayType&quot; || parentType === &quot;TSIndexedAccessType&quot; &amp;&amp; parent.objectType === node || parentType === &quot;TSOptionalType&quot;;
}
function TSInstantiationExpression(node, parent) {
  const parentType = parent.type;
  return (parentType === &quot;CallExpression&quot; || parentType === &quot;OptionalCallExpression&quot; || parentType === &quot;NewExpression&quot; || parentType === &quot;TSInstantiationExpression&quot;) &amp;&amp; !!parent.typeParameters;
}
function TSFunctionType(node, parent) {
  const parentType = parent.type;
  return parentType === &quot;TSIntersectionType&quot; || parentType === &quot;TSUnionType&quot; || parentType === &quot;TSTypeOperator&quot; || parentType === &quot;TSOptionalType&quot; || parentType === &quot;TSArrayType&quot; || parentType === &quot;TSIndexedAccessType&quot; &amp;&amp; parent.objectType === node || parentType === &quot;TSConditionalType&quot; &amp;&amp; (parent.checkType === node || parent.extendsType === node);
}
function BinaryExpression(node, parent, tokenContext) {
  return node.operator === &quot;in&quot; &amp;&amp; Boolean(tokenContext &amp; _index.TokenContext.forInOrInitHeadAccumulate);
}
function SequenceExpression(node, parent) {
  const parentType = parent.type;
  if (parentType === &quot;SequenceExpression&quot; || parentType === &quot;ParenthesizedExpression&quot; || parentType === &quot;MemberExpression&quot; &amp;&amp; parent.property === node || parentType === &quot;OptionalMemberExpression&quot; &amp;&amp; parent.property === node || parentType === &quot;TemplateLiteral&quot;) {
    return false;
  }
  if (parentType === &quot;ClassDeclaration&quot;) {
    return true;
  }
  if (parentType === &quot;ForOfStatement&quot;) {
    return parent.right === node;
  }
  if (parentType === &quot;ExportDefaultDeclaration&quot;) {
    return true;
  }
  return !isStatement(parent);
}
function YieldExpression(node, parent) {
  const parentType = parent.type;
  return parentType === &quot;BinaryExpression&quot; || parentType === &quot;LogicalExpression&quot; || parentType === &quot;UnaryExpression&quot; || parentType === &quot;SpreadElement&quot; || hasPostfixPart(node, parent) || parentType === &quot;AwaitExpression&quot; &amp;&amp; isYieldExpression(node) || parentType === &quot;ConditionalExpression&quot; &amp;&amp; node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
}
function ClassExpression(node, parent, tokenContext) {
  return Boolean(tokenContext &amp; (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
}
function UnaryLike(node, parent) {
  return hasPostfixPart(node, parent) || isBinaryExpression(parent) &amp;&amp; parent.operator === &quot;**&quot; &amp;&amp; parent.left === node || isClassExtendsClause(node, parent);
}
function FunctionExpression(node, parent, tokenContext) {
  return Boolean(tokenContext &amp; (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
}
function ConditionalExpression(node, parent) {
  const parentType = parent.type;
  if (parentType === &quot;UnaryExpression&quot; || parentType === &quot;SpreadElement&quot; || parentType === &quot;BinaryExpression&quot; || parentType === &quot;LogicalExpression&quot; || parentType === &quot;ConditionalExpression&quot; &amp;&amp; parent.test === node || parentType === &quot;AwaitExpression&quot; || isTSTypeExpression(parentType)) {
    return true;
  }
  return UnaryLike(node, parent);
}
function OptionalMemberExpression(node, parent) {
  return isCallExpression(parent) &amp;&amp; parent.callee === node || isMemberExpression(parent) &amp;&amp; parent.object === node;
}
function AssignmentExpression(node, parent, tokenContext) {
  if (needsParenBeforeExpressionBrace(tokenContext) &amp;&amp; isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression(node, parent);
  }
}
function LogicalExpression(node, parent) {
  const parentType = parent.type;
  if (isTSTypeExpression(parentType)) return true;
  if (parentType !== &quot;LogicalExpression&quot;) return false;
  switch (node.operator) {
    case &quot;||&quot;:
      return parent.operator === &quot;??&quot; || parent.operator === &quot;&amp;&amp;&quot;;
    case &quot;&amp;&amp;&quot;:
      return parent.operator === &quot;??&quot;;
    case &quot;??&quot;:
      return parent.operator !== &quot;??&quot;;
  }
}
function Identifier(node, parent, tokenContext, getRawIdentifier) {
  var _node$extra;
  const parentType = parent.type;
  if ((_node$extra = node.extra) != null &amp;&amp; _node$extra.parenthesized &amp;&amp; parentType === &quot;AssignmentExpression&quot; &amp;&amp; parent.left === node) {
    const rightType = parent.right.type;
    if ((rightType === &quot;FunctionExpression&quot; || rightType === &quot;ClassExpression&quot;) &amp;&amp; parent.right.id == null) {
      return true;
    }
  }
  if (getRawIdentifier &amp;&amp; getRawIdentifier(node) !== node.name) {
    return false;
  }
  if (node.name === &quot;let&quot;) {
    const isFollowedByBracket = isMemberExpression(parent, {
      object: node,
      computed: true
    }) || isOptionalMemberExpression(parent, {
      object: node,
      computed: true,
      optional: false
    });
    if (isFollowedByBracket &amp;&amp; tokenContext &amp; (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead)) {
      return true;
    }
    return Boolean(tokenContext &amp; _index.TokenContext.forOfHead);
  }
  return node.name === &quot;async&quot; &amp;&amp; isForOfStatement(parent, {
    left: node,
    await: false
  });
}

//# sourceMappingURL=parentheses.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
