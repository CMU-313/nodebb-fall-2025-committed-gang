<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/logrotate-stream/node_modules/yargs/build/lib/validation.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/logrotate-stream/node_modules/yargs/build/lib/validation.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">306</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">93.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { argsert } from &#039;./argsert.js&#039;;
import { assertNotStrictEqual, } from &#039;./typings/common-types.js&#039;;
import { levenshtein as distance } from &#039;./utils/levenshtein.js&#039;;
import { objFilter } from &#039;./utils/obj-filter.js&#039;;
const specialKeys = [&#039;$0&#039;, &#039;--&#039;, &#039;_&#039;];
export function validation(yargs, usage, shim) {
    const __ = shim.y18n.__;
    const __n = shim.y18n.__n;
    const self = {};
    self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv[&#039;--&#039;] ? argv[&#039;--&#039;].length : 0);
        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
        if (demandedCommands._ &amp;&amp;
            (_s &lt; demandedCommands._.min || _s &gt; demandedCommands._.max)) {
            if (_s &lt; demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(demandedCommands._.minMsg
                        ? demandedCommands._.minMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.min.toString())
                        : null);
                }
                else {
                    usage.fail(__n(&#039;Not enough non-option arguments: got %s, need at least %s&#039;, &#039;Not enough non-option arguments: got %s, need at least %s&#039;, _s, _s.toString(), demandedCommands._.min.toString()));
                }
            }
            else if (_s &gt; demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(demandedCommands._.maxMsg
                        ? demandedCommands._.maxMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.max.toString())
                        : null);
                }
                else {
                    usage.fail(__n(&#039;Too many non-option arguments: got %s, maximum of %s&#039;, &#039;Too many non-option arguments: got %s, maximum of %s&#039;, _s, _s.toString(), demandedCommands._.max.toString()));
                }
            }
        }
    };
    self.positionalCount = function positionalCount(required, observed) {
        if (observed &lt; required) {
            usage.fail(__n(&#039;Not enough non-option arguments: got %s, need at least %s&#039;, &#039;Not enough non-option arguments: got %s, need at least %s&#039;, observed, observed + &#039;&#039;, required + &#039;&#039;));
        }
    };
    self.requiredArguments = function requiredArguments(argv, demandedOptions) {
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
            if (!Object.prototype.hasOwnProperty.call(argv, key) ||
                typeof argv[key] === &#039;undefined&#039;) {
                missing = missing || {};
                missing[key] = demandedOptions[key];
            }
        }
        if (missing) {
            const customMsgs = [];
            for (const key of Object.keys(missing)) {
                const msg = missing[key];
                if (msg &amp;&amp; customMsgs.indexOf(msg) &lt; 0) {
                    customMsgs.push(msg);
                }
            }
            const customMsg = customMsgs.length ? `\n${customMsgs.join(&#039;\n&#039;)}` : &#039;&#039;;
            usage.fail(__n(&#039;Missing required argument: %s&#039;, &#039;Missing required arguments: %s&#039;, Object.keys(missing).length, Object.keys(missing).join(&#039;, &#039;) + customMsg));
        }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        var _a;
        const commandKeys = yargs
            .getInternalMethods()
            .getCommandInstance()
            .getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        Object.keys(argv).forEach(key =&gt; {
            if (!specialKeys.includes(key) &amp;&amp;
                !Object.prototype.hasOwnProperty.call(positionalMap, key) &amp;&amp;
                !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) &amp;&amp;
                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if (checkPositionals &amp;&amp;
            (currentContext.commands.length &gt; 0 ||
                commandKeys.length &gt; 0 ||
                isDefaultCommand)) {
            argv._.slice(currentContext.commands.length).forEach(key =&gt; {
                if (!commandKeys.includes(&#039;&#039; + key)) {
                    unknown.push(&#039;&#039; + key);
                }
            });
        }
        if (checkPositionals) {
            const demandedCommands = yargs.getDemandedCommands();
            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;
            const expected = currentContext.commands.length + maxNonOptDemanded;
            if (expected &lt; argv._.length) {
                argv._.slice(expected).forEach(key =&gt; {
                    key = String(key);
                    if (!currentContext.commands.includes(key) &amp;&amp;
                        !unknown.includes(key)) {
                        unknown.push(key);
                    }
                });
            }
        }
        if (unknown.length) {
            usage.fail(__n(&#039;Unknown argument: %s&#039;, &#039;Unknown arguments: %s&#039;, unknown.length, unknown.map(s =&gt; (s.trim() ? s : `&quot;${s}&quot;`)).join(&#039;, &#039;)));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs
            .getInternalMethods()
            .getCommandInstance()
            .getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        if (currentContext.commands.length &gt; 0 || commandKeys.length &gt; 0) {
            argv._.slice(currentContext.commands.length).forEach(key =&gt; {
                if (!commandKeys.includes(&#039;&#039; + key)) {
                    unknown.push(&#039;&#039; + key);
                }
            });
        }
        if (unknown.length &gt; 0) {
            usage.fail(__n(&#039;Unknown command: %s&#039;, &#039;Unknown commands: %s&#039;, unknown.length, unknown.join(&#039;, &#039;)));
            return true;
        }
        else {
            return false;
        }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        const newAliases = yargs.parsed.newAliases;
        return [key, ...aliases[key]].some(a =&gt; !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
    };
    self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
            return;
        Object.keys(argv).forEach(key =&gt; {
            if (specialKeys.indexOf(key) === -1 &amp;&amp;
                Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach(value =&gt; {
                    if (options.choices[key].indexOf(value) === -1 &amp;&amp;
                        value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
            return;
        let msg = __(&#039;Invalid values:&#039;);
        invalidKeys.forEach(key =&gt; {
            msg += `\n  ${__(&#039;Argument: %s, Given: %s, Choices: %s&#039;, key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
    };
    let implied = {};
    self.implies = function implies(key, value) {
        argsert(&#039;&lt;string|object&gt; [array|number|string]&#039;, [key, value], arguments.length);
        if (typeof key === &#039;object&#039;) {
            Object.keys(key).forEach(k =&gt; {
                self.implies(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(i =&gt; self.implies(key, i));
            }
            else {
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === &#039;number&#039;) {
            val = argv._.length &gt;= val;
        }
        else if (val.match(/^--no-.+/)) {
            val = val.match(/^--no-(.+)/)[1];
            val = !Object.prototype.hasOwnProperty.call(argv, val);
        }
        else {
            val = Object.prototype.hasOwnProperty.call(argv, val);
        }
        return val;
    }
    self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach(key =&gt; {
            const origKey = key;
            (implied[key] || []).forEach(value =&gt; {
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key &amp;&amp; !value) {
                    implyFail.push(` ${origKey} -&gt; ${origValue}`);
                }
            });
        });
        if (implyFail.length) {
            let msg = `${__(&#039;Implications failed:&#039;)}\n`;
            implyFail.forEach(value =&gt; {
                msg += value;
            });
            usage.fail(msg);
        }
    };
    let conflicting = {};
    self.conflicts = function conflicts(key, value) {
        argsert(&#039;&lt;string|object&gt; [array|string]&#039;, [key, value], arguments.length);
        if (typeof key === &#039;object&#039;) {
            Object.keys(key).forEach(k =&gt; {
                self.conflicts(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(i =&gt; self.conflicts(key, i));
            }
            else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = () =&gt; conflicting;
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach(key =&gt; {
            if (conflicting[key]) {
                conflicting[key].forEach(value =&gt; {
                    if (value &amp;&amp; argv[key] !== undefined &amp;&amp; argv[value] !== undefined) {
                        usage.fail(__(&#039;Arguments %s and %s are mutually exclusive&#039;, key, value));
                    }
                });
            }
        });
        if (yargs.getInternalMethods().getParserConfiguration()[&#039;strip-dashed&#039;]) {
            Object.keys(conflicting).forEach(key =&gt; {
                conflicting[key].forEach(value =&gt; {
                    if (value &amp;&amp;
                        argv[shim.Parser.camelCase(key)] !== undefined &amp;&amp;
                        argv[shim.Parser.camelCase(value)] !== undefined) {
                        usage.fail(__(&#039;Arguments %s and %s are mutually exclusive&#039;, key, value));
                    }
                });
            });
        }
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) =&gt; b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
            const d = distance(cmd, candidate);
            if (d &lt;= threshold &amp;&amp; d &lt; bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended)
            usage.fail(__(&#039;Did you mean %s?&#039;, recommended));
    };
    self.reset = function reset(localLookup) {
        implied = objFilter(implied, k =&gt; !localLookup[k]);
        conflicting = objFilter(conflicting, k =&gt; !localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied,
            conflicting,
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({ implied, conflicting } = frozen);
    };
    return self;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
