<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/tldts-core/dist/cjs/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/tldts-core/dist/cjs/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">54.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">562</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">103.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

/**
 * Check if `vhost` is a valid suffix of `hostname` (top-domain)
 *
 * It means that `vhost` needs to be a suffix of `hostname` and we then need to
 * make sure that: either they are equal, or the character preceding `vhost` in
 * `hostname` is a &#039;.&#039; (it should not be a partial label).
 *
 * * hostname = &#039;not.evil.com&#039; and vhost = &#039;vil.com&#039;      =&gt; not ok
 * * hostname = &#039;not.evil.com&#039; and vhost = &#039;evil.com&#039;     =&gt; ok
 * * hostname = &#039;not.evil.com&#039; and vhost = &#039;not.evil.com&#039; =&gt; ok
 */
function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
        return (hostname.length === vhost.length ||
            hostname[hostname.length - vhost.length - 1] === &#039;.&#039;);
    }
    return false;
}
/**
 * Given a hostname and its public suffix, extract the general domain.
 */
function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last &#039;.&#039; in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  =&gt; evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   =&gt; example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf(&#039;.&#039;, publicSuffixIndex);
    // No &#039;.&#039; found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
        return hostname;
    }
    // Extract the part between the last &#039;.&#039;
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
/**
 * Detects the domain based on rules and upon and a host string
 */
function getDomain(suffix, hostname, options) {
    // Check if `hostname` ends with a member of `validHosts`.
    if (options.validHosts !== null) {
        const validHosts = options.validHosts;
        for (const vhost of validHosts) {
            if ( /*@__INLINE__*/shareSameDomainSuffix(hostname, vhost)) {
                return vhost;
            }
        }
    }
    let numberOfLeadingDots = 0;
    if (hostname.startsWith(&#039;.&#039;)) {
        while (numberOfLeadingDots &lt; hostname.length &amp;&amp;
            hostname[numberOfLeadingDots] === &#039;.&#039;) {
            numberOfLeadingDots += 1;
        }
    }
    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length - numberOfLeadingDots) {
        return null;
    }
    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
}

/**
 * Return the part of domain without suffix.
 *
 * Example: for domain &#039;foo.com&#039;, the result would be &#039;foo&#039;.
 */
function getDomainWithoutSuffix(domain, suffix) {
    // Note: here `domain` and `suffix` cannot have the same length because in
    // this case we set `domain` to `null` instead. It is thus safe to assume
    // that `suffix` is shorter than `domain`.
    return domain.slice(0, -suffix.length - 1);
}

/**
 * @param url - URL we want to extract a hostname from.
 * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.
 */
function extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    // If url is not already a valid hostname, then try to extract hostname.
    if (!urlIsValidHostname) {
        // Special handling of data URLs
        if (url.startsWith(&#039;data:&#039;)) {
            return null;
        }
        // Trim leading spaces
        while (start &lt; url.length &amp;&amp; url.charCodeAt(start) &lt;= 32) {
            start += 1;
        }
        // Trim trailing spaces
        while (end &gt; start + 1 &amp;&amp; url.charCodeAt(end - 1) &lt;= 32) {
            end -= 1;
        }
        // Skip scheme.
        if (url.charCodeAt(start) === 47 /* &#039;/&#039; */ &amp;&amp;
            url.charCodeAt(start + 1) === 47 /* &#039;/&#039; */) {
            start += 2;
        }
        else {
            const indexOfProtocol = url.indexOf(&#039;:/&#039;, start);
            if (indexOfProtocol !== -1) {
                // Implement fast-path for common protocols. We expect most protocols
                // should be one of these 4 and thus we will not need to perform the
                // more expansive validity check most of the time.
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (protocolSize === 5 &amp;&amp;
                    c0 === 104 /* &#039;h&#039; */ &amp;&amp;
                    c1 === 116 /* &#039;t&#039; */ &amp;&amp;
                    c2 === 116 /* &#039;t&#039; */ &amp;&amp;
                    c3 === 112 /* &#039;p&#039; */ &amp;&amp;
                    c4 === 115 /* &#039;s&#039; */) ;
                else if (protocolSize === 4 &amp;&amp;
                    c0 === 104 /* &#039;h&#039; */ &amp;&amp;
                    c1 === 116 /* &#039;t&#039; */ &amp;&amp;
                    c2 === 116 /* &#039;t&#039; */ &amp;&amp;
                    c3 === 112 /* &#039;p&#039; */) ;
                else if (protocolSize === 3 &amp;&amp;
                    c0 === 119 /* &#039;w&#039; */ &amp;&amp;
                    c1 === 115 /* &#039;s&#039; */ &amp;&amp;
                    c2 === 115 /* &#039;s&#039; */) ;
                else if (protocolSize === 2 &amp;&amp;
                    c0 === 119 /* &#039;w&#039; */ &amp;&amp;
                    c1 === 115 /* &#039;s&#039; */) ;
                else {
                    // Check that scheme is valid
                    for (let i = start; i &lt; indexOfProtocol; i += 1) {
                        const lowerCaseCode = url.charCodeAt(i) | 32;
                        if (!(((lowerCaseCode &gt;= 97 &amp;&amp; lowerCaseCode &lt;= 122) || // [a, z]
                            (lowerCaseCode &gt;= 48 &amp;&amp; lowerCaseCode &lt;= 57) || // [0, 9]
                            lowerCaseCode === 46 || // &#039;.&#039;
                            lowerCaseCode === 45 || // &#039;-&#039;
                            lowerCaseCode === 43) // &#039;+&#039;
                        )) {
                            return null;
                        }
                    }
                }
                // Skip 0, 1 or more &#039;/&#039; after &#039;:/&#039;
                start = indexOfProtocol + 2;
                while (url.charCodeAt(start) === 47 /* &#039;/&#039; */) {
                    start += 1;
                }
            }
        }
        // Detect first occurrence of &#039;/&#039;, &#039;?&#039; or &#039;#&#039;. We also keep track of the
        // last occurrence of &#039;@&#039;, &#039;]&#039; or &#039;:&#039; to speed-up subsequent parsing of
        // (respectively), identifier, ipv6 or port.
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for (let i = start; i &lt; end; i += 1) {
            const code = url.charCodeAt(i);
            if (code === 35 || // &#039;#&#039;
                code === 47 || // &#039;/&#039;
                code === 63 // &#039;?&#039;
            ) {
                end = i;
                break;
            }
            else if (code === 64) {
                // &#039;@&#039;
                indexOfIdentifier = i;
            }
            else if (code === 93) {
                // &#039;]&#039;
                indexOfClosingBracket = i;
            }
            else if (code === 58) {
                // &#039;:&#039;
                indexOfPort = i;
            }
            else if (code &gt;= 65 &amp;&amp; code &lt;= 90) {
                hasUpper = true;
            }
        }
        // Detect identifier: &#039;@&#039;
        if (indexOfIdentifier !== -1 &amp;&amp;
            indexOfIdentifier &gt; start &amp;&amp;
            indexOfIdentifier &lt; end) {
            start = indexOfIdentifier + 1;
        }
        // Handle ipv6 addresses
        if (url.charCodeAt(start) === 91 /* &#039;[&#039; */) {
            if (indexOfClosingBracket !== -1) {
                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            }
            return null;
        }
        else if (indexOfPort !== -1 &amp;&amp; indexOfPort &gt; start &amp;&amp; indexOfPort &lt; end) {
            // Detect port: &#039;:&#039;
            end = indexOfPort;
        }
    }
    // Trim trailing dots
    while (end &gt; start + 1 &amp;&amp; url.charCodeAt(end - 1) === 46 /* &#039;.&#039; */) {
        end -= 1;
    }
    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) {
        return hostname.toLowerCase();
    }
    return hostname;
}

/**
 * Check if a hostname is an IP. You should be aware that this only works
 * because `hostname` is already garanteed to be a valid hostname!
 */
function isProbablyIpv4(hostname) {
    // Cannot be shorted than 1.1.1.1
    if (hostname.length &lt; 7) {
        return false;
    }
    // Cannot be longer than: 255.255.255.255
    if (hostname.length &gt; 15) {
        return false;
    }
    let numberOfDots = 0;
    for (let i = 0; i &lt; hostname.length; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* &#039;.&#039; */) {
            numberOfDots += 1;
        }
        else if (code &lt; 48 /* &#039;0&#039; */ || code &gt; 57 /* &#039;9&#039; */) {
            return false;
        }
    }
    return (numberOfDots === 3 &amp;&amp;
        hostname.charCodeAt(0) !== 46 /* &#039;.&#039; */ &amp;&amp;
        hostname.charCodeAt(hostname.length - 1) !== 46 /* &#039;.&#039; */);
}
/**
 * Similar to isProbablyIpv4.
 */
function isProbablyIpv6(hostname) {
    if (hostname.length &lt; 3) {
        return false;
    }
    let start = hostname.startsWith(&#039;[&#039;) ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === &#039;]&#039;) {
        end -= 1;
    }
    // We only consider the maximum size of a normal IPV6. Note that this will
    // fail on so-called &quot;IPv4 mapped IPv6 addresses&quot; but this is a corner-case
    // and a proper validation library should be used for these.
    if (end - start &gt; 39) {
        return false;
    }
    let hasColon = false;
    for (; start &lt; end; start += 1) {
        const code = hostname.charCodeAt(start);
        if (code === 58 /* &#039;:&#039; */) {
            hasColon = true;
        }
        else if (!(((code &gt;= 48 &amp;&amp; code &lt;= 57) || // 0-9
            (code &gt;= 97 &amp;&amp; code &lt;= 102) || // a-f
            (code &gt;= 65 &amp;&amp; code &lt;= 90)) // A-F
        )) {
            return false;
        }
    }
    return hasColon;
}
/**
 * Check if `hostname` is *probably* a valid ip addr (either ipv6 or ipv4).
 * This *will not* work on any string. We need `hostname` to be a valid
 * hostname.
 */
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}

/**
 * Implements fast shallow verification of hostnames. This does not perform a
 * struct check on the content of labels (classes of Unicode characters, etc.)
 * but instead check that the structure is valid (number of labels, length of
 * labels, etc.).
 *
 * If you need stricter validation, consider using an external library.
 */
function isValidAscii(code) {
    return ((code &gt;= 97 &amp;&amp; code &lt;= 122) || (code &gt;= 48 &amp;&amp; code &lt;= 57) || code &gt; 127);
}
/**
 * Check if a hostname string is valid. It&#039;s usually a preliminary check before
 * trying to use getDomain or anything else.
 *
 * Beware: it does not check if the TLD exists.
 */
function isValidHostname (hostname) {
    if (hostname.length &gt; 255) {
        return false;
    }
    if (hostname.length === 0) {
        return false;
    }
    if (
    /*@__INLINE__*/ !isValidAscii(hostname.charCodeAt(0)) &amp;&amp;
        hostname.charCodeAt(0) !== 46 &amp;&amp; // &#039;.&#039; (dot)
        hostname.charCodeAt(0) !== 95 // &#039;_&#039; (underscore)
    ) {
        return false;
    }
    // Validate hostname according to RFC
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for (let i = 0; i &lt; len; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* &#039;.&#039; */) {
            if (
            // Check that previous label is &lt; 63 bytes long (64 = 63 + &#039;.&#039;)
            i - lastDotIndex &gt; 64 ||
                // Check that previous character was not already a &#039;.&#039;
                lastCharCode === 46 ||
                // Check that the previous label does not end with a &#039;-&#039; (dash)
                lastCharCode === 45 ||
                // Check that the previous label does not end with a &#039;_&#039; (underscore)
                lastCharCode === 95) {
                return false;
            }
            lastDotIndex = i;
        }
        else if (!( /*@__INLINE__*/(isValidAscii(code) || code === 45 || code === 95))) {
            // Check if there is a forbidden character in the label
            return false;
        }
        lastCharCode = code;
    }
    return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 &lt;= 63 &amp;&amp;
        // Check that the last character is an allowed trailing label character.
        // Since we already checked that the char is a valid hostname character,
        // we only need to check that it&#039;s different from &#039;-&#039;.
        lastCharCode !== 45);
}

function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname,
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
}

/**
 * Returns the subdomain of a hostname string
 */
function getSubdomain(hostname, domain) {
    // If `hostname` and `domain` are the same, then there is no sub-domain
    if (domain.length === hostname.length) {
        return &#039;&#039;;
    }
    return hostname.slice(0, -domain.length - 1);
}

/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */
function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null,
    };
}
function resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ setDefaults(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== &#039;string&#039;) {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (!options.extractHostname) {
        result.hostname = url;
    }
    else if (options.mixedInputs) {
        result.hostname = extractHostname(url, isValidHostname(url));
    }
    else {
        result.hostname = extractHostname(url, false);
    }
    if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {
        return result;
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp) {
        result.isIp = isIp(result.hostname);
        if (result.isIp) {
            return result;
        }
    }
    // Perform optional hostname validation. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain.
    if (options.validateHostname &amp;&amp;
        options.extractHostname &amp;&amp;
        !isValidHostname(result.hostname)) {
        result.hostname = null;
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = getDomain(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = getSubdomain(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
    return result;
}

function fastPath (hostname, options, out) {
    // Fast path for very popular suffixes; this allows to by-pass lookup
    // completely as well as any extra allocation or string manipulation.
    if (!options.allowPrivateDomains &amp;&amp; hostname.length &gt; 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (c3 === 109 /* &#039;m&#039; */ &amp;&amp;
            c2 === 111 /* &#039;o&#039; */ &amp;&amp;
            c1 === 99 /* &#039;c&#039; */ &amp;&amp;
            c0 === 46 /* &#039;.&#039; */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = &#039;com&#039;;
            return true;
        }
        else if (c3 === 103 /* &#039;g&#039; */ &amp;&amp;
            c2 === 114 /* &#039;r&#039; */ &amp;&amp;
            c1 === 111 /* &#039;o&#039; */ &amp;&amp;
            c0 === 46 /* &#039;.&#039; */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = &#039;org&#039;;
            return true;
        }
        else if (c3 === 117 /* &#039;u&#039; */ &amp;&amp;
            c2 === 100 /* &#039;d&#039; */ &amp;&amp;
            c1 === 101 /* &#039;e&#039; */ &amp;&amp;
            c0 === 46 /* &#039;.&#039; */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = &#039;edu&#039;;
            return true;
        }
        else if (c3 === 118 /* &#039;v&#039; */ &amp;&amp;
            c2 === 111 /* &#039;o&#039; */ &amp;&amp;
            c1 === 103 /* &#039;g&#039; */ &amp;&amp;
            c0 === 46 /* &#039;.&#039; */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = &#039;gov&#039;;
            return true;
        }
        else if (c3 === 116 /* &#039;t&#039; */ &amp;&amp;
            c2 === 101 /* &#039;e&#039; */ &amp;&amp;
            c1 === 110 /* &#039;n&#039; */ &amp;&amp;
            c0 === 46 /* &#039;.&#039; */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = &#039;net&#039;;
            return true;
        }
        else if (c3 === 101 /* &#039;e&#039; */ &amp;&amp;
            c2 === 100 /* &#039;d&#039; */ &amp;&amp;
            c1 === 46 /* &#039;.&#039; */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = &#039;de&#039;;
            return true;
        }
    }
    return false;
}

exports.fastPathLookup = fastPath;
exports.getEmptyResult = getEmptyResult;
exports.parseImpl = parseImpl;
exports.resetResult = resetResult;
exports.setDefaults = setDefaults;
//# sourceMappingURL=index.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
