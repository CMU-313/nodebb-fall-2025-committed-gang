<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/object-inspect/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/object-inspect/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">545</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">80.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.86</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var hasMap = typeof Map === &#039;function&#039; &amp;&amp; Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor &amp;&amp; hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, &#039;size&#039;) : null;
var mapSize = hasMap &amp;&amp; mapSizeDescriptor &amp;&amp; typeof mapSizeDescriptor.get === &#039;function&#039; ? mapSizeDescriptor.get : null;
var mapForEach = hasMap &amp;&amp; Map.prototype.forEach;
var hasSet = typeof Set === &#039;function&#039; &amp;&amp; Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor &amp;&amp; hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, &#039;size&#039;) : null;
var setSize = hasSet &amp;&amp; setSizeDescriptor &amp;&amp; typeof setSizeDescriptor.get === &#039;function&#039; ? setSizeDescriptor.get : null;
var setForEach = hasSet &amp;&amp; Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === &#039;function&#039; &amp;&amp; WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === &#039;function&#039; &amp;&amp; WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === &#039;function&#039; &amp;&amp; WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === &#039;function&#039; ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === &#039;function&#039; &amp;&amp; typeof Symbol.iterator === &#039;symbol&#039; ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === &#039;function&#039; &amp;&amp; typeof Symbol.iterator === &#039;object&#039;;
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === &#039;function&#039; &amp;&amp; Symbol.toStringTag &amp;&amp; (typeof Symbol.toStringTag === hasShammedSymbols ? &#039;object&#039; : &#039;symbol&#039;)
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === &#039;function&#039; ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num &amp;&amp; num &gt; -1000 &amp;&amp; num &lt; 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === &#039;number&#039;) {
        var int = num &lt; 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, &#039;$&amp;_&#039;) + &#039;.&#039; + $replace.call($replace.call(dec, /([0-9]{3})/g, &#039;$&amp;_&#039;), /_$/, &#039;&#039;);
        }
    }
    return $replace.call(str, sepRegex, &#039;$&amp;_&#039;);
}

var utilInspect = require(&#039;./util.inspect&#039;);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    &#039;double&#039;: &#039;&quot;&#039;,
    single: &quot;&#039;&quot;
};
var quoteREs = {
    __proto__: null,
    &#039;double&#039;: /([&quot;\\])/g,
    single: /([&#039;\\])/g
};

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, &#039;quoteStyle&#039;) &amp;&amp; !has(quotes, opts.quoteStyle)) {
        throw new TypeError(&#039;option &quot;quoteStyle&quot; must be &quot;single&quot; or &quot;double&quot;&#039;);
    }
    if (
        has(opts, &#039;maxStringLength&#039;) &amp;&amp; (typeof opts.maxStringLength === &#039;number&#039;
            ? opts.maxStringLength &lt; 0 &amp;&amp; opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError(&#039;option &quot;maxStringLength&quot;, if provided, must be a positive integer, Infinity, or `null`&#039;);
    }
    var customInspect = has(opts, &#039;customInspect&#039;) ? opts.customInspect : true;
    if (typeof customInspect !== &#039;boolean&#039; &amp;&amp; customInspect !== &#039;symbol&#039;) {
        throw new TypeError(&#039;option &quot;customInspect&quot;, if provided, must be `true`, `false`, or `\&#039;symbol\&#039;`&#039;);
    }

    if (
        has(opts, &#039;indent&#039;)
        &amp;&amp; opts.indent !== null
        &amp;&amp; opts.indent !== &#039;\t&#039;
        &amp;&amp; !(parseInt(opts.indent, 10) === opts.indent &amp;&amp; opts.indent &gt; 0)
    ) {
        throw new TypeError(&#039;option &quot;indent&quot; must be &quot;\\t&quot;, an integer &gt; 0, or `null`&#039;);
    }
    if (has(opts, &#039;numericSeparator&#039;) &amp;&amp; typeof opts.numericSeparator !== &#039;boolean&#039;) {
        throw new TypeError(&#039;option &quot;numericSeparator&quot;, if provided, must be `true` or `false`&#039;);
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === &#039;undefined&#039;) {
        return &#039;undefined&#039;;
    }
    if (obj === null) {
        return &#039;null&#039;;
    }
    if (typeof obj === &#039;boolean&#039;) {
        return obj ? &#039;true&#039; : &#039;false&#039;;
    }

    if (typeof obj === &#039;string&#039;) {
        return inspectString(obj, opts);
    }
    if (typeof obj === &#039;number&#039;) {
        if (obj === 0) {
            return Infinity / obj &gt; 0 ? &#039;0&#039; : &#039;-0&#039;;
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === &#039;bigint&#039;) {
        var bigIntStr = String(obj) + &#039;n&#039;;
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === &#039;undefined&#039; ? 5 : opts.depth;
    if (typeof depth === &#039;undefined&#039;) { depth = 0; }
    if (depth &gt;= maxDepth &amp;&amp; maxDepth &gt; 0 &amp;&amp; typeof obj === &#039;object&#039;) {
        return isArray(obj) ? &#039;[Array]&#039; : &#039;[Object]&#039;;
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === &#039;undefined&#039;) {
        seen = [];
    } else if (indexOf(seen, obj) &gt;= 0) {
        return &#039;[Circular]&#039;;
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, &#039;quoteStyle&#039;)) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === &#039;function&#039; &amp;&amp; !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return &#039;[Function&#039; + (name ? &#039;: &#039; + name : &#039; (anonymous)&#039;) + &#039;]&#039; + (keys.length &gt; 0 ? &#039; { &#039; + $join.call(keys, &#039;, &#039;) + &#039; }&#039; : &#039;&#039;);
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, &#039;$1&#039;) : symToString.call(obj);
        return typeof obj === &#039;object&#039; &amp;&amp; !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = &#039;&lt;&#039; + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i &lt; attrs.length; i++) {
            s += &#039; &#039; + attrs[i].name + &#039;=&#039; + wrapQuotes(quote(attrs[i].value), &#039;double&#039;, opts);
        }
        s += &#039;&gt;&#039;;
        if (obj.childNodes &amp;&amp; obj.childNodes.length) { s += &#039;...&#039;; }
        s += &#039;&lt;/&#039; + $toLowerCase.call(String(obj.nodeName)) + &#039;&gt;&#039;;
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return &#039;[]&#039;; }
        var xs = arrObjKeys(obj, inspect);
        if (indent &amp;&amp; !singleLineValues(xs)) {
            return &#039;[&#039; + indentedJoin(xs, indent) + &#039;]&#039;;
        }
        return &#039;[ &#039; + $join.call(xs, &#039;, &#039;) + &#039; ]&#039;;
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!(&#039;cause&#039; in Error.prototype) &amp;&amp; &#039;cause&#039; in obj &amp;&amp; !isEnumerable.call(obj, &#039;cause&#039;)) {
            return &#039;{ [&#039; + String(obj) + &#039;] &#039; + $join.call($concat.call(&#039;[cause]: &#039; + inspect(obj.cause), parts), &#039;, &#039;) + &#039; }&#039;;
        }
        if (parts.length === 0) { return &#039;[&#039; + String(obj) + &#039;]&#039;; }
        return &#039;{ [&#039; + String(obj) + &#039;] &#039; + $join.call(parts, &#039;, &#039;) + &#039; }&#039;;
    }
    if (typeof obj === &#039;object&#039; &amp;&amp; customInspect) {
        if (inspectSymbol &amp;&amp; typeof obj[inspectSymbol] === &#039;function&#039; &amp;&amp; utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== &#039;symbol&#039; &amp;&amp; typeof obj.inspect === &#039;function&#039;) {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + &#039; =&gt; &#039; + inspect(value, obj));
            });
        }
        return collectionOf(&#039;Map&#039;, mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf(&#039;Set&#039;, setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf(&#039;WeakMap&#039;);
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf(&#039;WeakSet&#039;);
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf(&#039;WeakRef&#039;);
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== &#039;undefined&#039; &amp;&amp; obj === window) {
        return &#039;{ [object Window] }&#039;;
    }
    if (
        (typeof globalThis !== &#039;undefined&#039; &amp;&amp; obj === globalThis)
        || (typeof global !== &#039;undefined&#039; &amp;&amp; obj === global)
    ) {
        return &#039;{ [object globalThis] }&#039;;
    }
    if (!isDate(obj) &amp;&amp; !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? &#039;&#039; : &#039;null prototype&#039;;
        var stringTag = !isPlainObject &amp;&amp; toStringTag &amp;&amp; Object(obj) === obj &amp;&amp; toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? &#039;Object&#039; : &#039;&#039;;
        var constructorTag = isPlainObject || typeof obj.constructor !== &#039;function&#039; ? &#039;&#039; : obj.constructor.name ? obj.constructor.name + &#039; &#039; : &#039;&#039;;
        var tag = constructorTag + (stringTag || protoTag ? &#039;[&#039; + $join.call($concat.call([], stringTag || [], protoTag || []), &#039;: &#039;) + &#039;] &#039; : &#039;&#039;);
        if (ys.length === 0) { return tag + &#039;{}&#039;; }
        if (indent) {
            return tag + &#039;{&#039; + indentedJoin(ys, indent) + &#039;}&#039;;
        }
        return tag + &#039;{ &#039; + $join.call(ys, &#039;, &#039;) + &#039; }&#039;;
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /&quot;/g, &#039;&amp;quot;&#039;);
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === &#039;object&#039; &amp;&amp; (toStringTag in obj || typeof obj[toStringTag] !== &#039;undefined&#039;));
}
function isArray(obj) { return toStr(obj) === &#039;[object Array]&#039; &amp;&amp; canTrustToString(obj); }
function isDate(obj) { return toStr(obj) === &#039;[object Date]&#039; &amp;&amp; canTrustToString(obj); }
function isRegExp(obj) { return toStr(obj) === &#039;[object RegExp]&#039; &amp;&amp; canTrustToString(obj); }
function isError(obj) { return toStr(obj) === &#039;[object Error]&#039; &amp;&amp; canTrustToString(obj); }
function isString(obj) { return toStr(obj) === &#039;[object String]&#039; &amp;&amp; canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === &#039;[object Number]&#039; &amp;&amp; canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === &#039;[object Boolean]&#039; &amp;&amp; canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can&#039;t be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj &amp;&amp; typeof obj === &#039;object&#039; &amp;&amp; obj instanceof Symbol;
    }
    if (typeof obj === &#039;symbol&#039;) {
        return true;
    }
    if (!obj || typeof obj !== &#039;object&#039; || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== &#039;object&#039; || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i &lt; l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== &#039;object&#039;) {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== &#039;object&#039;) {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== &#039;object&#039;) {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== &#039;object&#039;) {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== &#039;object&#039;) {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== &#039;object&#039;) { return false; }
    if (typeof HTMLElement !== &#039;undefined&#039; &amp;&amp; x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === &#039;string&#039; &amp;&amp; typeof x.getAttribute === &#039;function&#039;;
}

function inspectString(str, opts) {
    if (str.length &gt; opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = &#039;... &#039; + remaining + &#039; more character&#039; + (remaining &gt; 1 ? &#039;s&#039; : &#039;&#039;);
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || &#039;single&#039;];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, &#039;\\$1&#039;), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, &#039;single&#039;, opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: &#039;b&#039;,
        9: &#039;t&#039;,
        10: &#039;n&#039;,
        12: &#039;f&#039;,
        13: &#039;r&#039;
    }[n];
    if (x) { return &#039;\\&#039; + x; }
    return &#039;\\x&#039; + (n &lt; 0x10 ? &#039;0&#039; : &#039;&#039;) + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return &#039;Object(&#039; + str + &#039;)&#039;;
}

function weakCollectionOf(type) {
    return type + &#039; { ? }&#039;;
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, &#039;, &#039;);
    return type + &#039; (&#039; + size + &#039;) {&#039; + joinedEntries + &#039;}&#039;;
}

function singleLineValues(xs) {
    for (var i = 0; i &lt; xs.length; i++) {
        if (indexOf(xs[i], &#039;\n&#039;) &gt;= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === &#039;\t&#039;) {
        baseIndent = &#039;\t&#039;;
    } else if (typeof opts.indent === &#039;number&#039; &amp;&amp; opts.indent &gt; 0) {
        baseIndent = $join.call(Array(opts.indent + 1), &#039; &#039;);
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return &#039;&#039;; }
    var lineJoiner = &#039;\n&#039; + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, &#039;,&#039; + lineJoiner) + &#039;\n&#039; + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i &lt; obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : &#039;&#039;;
        }
    }
    var syms = typeof gOPS === &#039;function&#039; ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k &lt; syms.length; k++) {
            symMap[&#039;$&#039; + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr &amp;&amp; String(Number(key)) === key &amp;&amp; key &lt; obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols &amp;&amp; symMap[&#039;$&#039; + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + &#039;: &#039; + inspect(obj[key], obj));
        } else {
            xs.push(key + &#039;: &#039; + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === &#039;function&#039;) {
        for (var j = 0; j &lt; syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push(&#039;[&#039; + inspect(syms[j]) + &#039;]: &#039; + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
