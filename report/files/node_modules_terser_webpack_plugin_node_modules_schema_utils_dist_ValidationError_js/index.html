<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/terser-webpack-plugin/node_modules/schema-utils/dist/ValidationError.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/terser-webpack-plugin/node_modules/schema-utils/dist/ValidationError.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1063</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">110.94</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.89</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});
exports.default = void 0;
var _memorize = _interopRequireDefault(require(&quot;./util/memorize&quot;));
function _interopRequireDefault(e) { return e &amp;&amp; e.__esModule ? e : { default: e }; }
/** @typedef {import(&quot;json-schema&quot;).JSONSchema6} JSONSchema6 */
/** @typedef {import(&quot;json-schema&quot;).JSONSchema7} JSONSchema7 */

/** @typedef {import(&quot;./validate&quot;).Schema} Schema */
/** @typedef {import(&quot;./validate&quot;).ValidationErrorConfiguration} ValidationErrorConfiguration */
/** @typedef {import(&quot;./validate&quot;).PostFormatter} PostFormatter */
/** @typedef {import(&quot;./validate&quot;).SchemaUtilErrorObject} SchemaUtilErrorObject */

/** @enum {number} */
const SPECIFICITY = {
  type: 1,
  not: 1,
  oneOf: 1,
  anyOf: 1,
  if: 1,
  enum: 1,
  const: 1,
  instanceof: 1,
  required: 2,
  pattern: 2,
  patternRequired: 2,
  format: 2,
  formatMinimum: 2,
  formatMaximum: 2,
  minimum: 2,
  exclusiveMinimum: 2,
  maximum: 2,
  exclusiveMaximum: 2,
  multipleOf: 2,
  uniqueItems: 2,
  contains: 2,
  minLength: 2,
  maxLength: 2,
  minItems: 2,
  maxItems: 2,
  minProperties: 2,
  maxProperties: 2,
  dependencies: 2,
  propertyNames: 2,
  additionalItems: 2,
  additionalProperties: 2,
  absolutePath: 2
};

/**
 * @param {string} value
 * @returns {value is number}
 */
function isNumeric(value) {
  return /^-?\d+$/.test(value);
}

/**
 *
 * @param {Array&lt;SchemaUtilErrorObject&gt;} array
 * @param {(item: SchemaUtilErrorObject) =&gt; number} fn
 * @returns {Array&lt;SchemaUtilErrorObject&gt;}
 */
function filterMax(array, fn) {
  const evaluatedMax = array.reduce((max, item) =&gt; Math.max(max, fn(item)), 0);
  return array.filter(item =&gt; fn(item) === evaluatedMax);
}

/**
 *
 * @param {Array&lt;SchemaUtilErrorObject&gt;} children
 * @returns {Array&lt;SchemaUtilErrorObject&gt;}
 */
function filterChildren(children) {
  let newChildren = children;
  newChildren = filterMax(newChildren,
  /**
   *
   * @param {SchemaUtilErrorObject} error
   * @returns {number}
   */
  error =&gt; error.instancePath ? error.instancePath.length : 0);
  newChildren = filterMax(newChildren,
  /**
   * @param {SchemaUtilErrorObject} error
   * @returns {number}
   */
  error =&gt; SPECIFICITY[(/** @type {keyof typeof SPECIFICITY} */error.keyword)] || 2);
  return newChildren;
}

/**
 * Find all children errors
 * @param {Array&lt;SchemaUtilErrorObject&gt;} children
 * @param {Array&lt;string&gt;} schemaPaths
 * @return {number} returns index of first child
 */
function findAllChildren(children, schemaPaths) {
  let i = children.length - 1;
  const predicate =
  /**
   * @param {string} schemaPath
   * @returns {boolean}
   */
  schemaPath =&gt; children[i].schemaPath.indexOf(schemaPath) !== 0;
  while (i &gt; -1 &amp;&amp; !schemaPaths.every(predicate)) {
    if (children[i].keyword === &quot;anyOf&quot; || children[i].keyword === &quot;oneOf&quot;) {
      const refs = extractRefs(children[i]);
      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));
      i = childrenStart - 1;
    } else {
      i -= 1;
    }
  }
  return i + 1;
}

/**
 * Extracts all refs from schema
 * @param {SchemaUtilErrorObject} error
 * @return {Array&lt;string&gt;}
 */
function extractRefs(error) {
  const {
    schema
  } = error;
  if (!Array.isArray(schema)) {
    return [];
  }
  return schema.map(({
    $ref
  }) =&gt; $ref).filter(s =&gt; s);
}

/**
 * Groups children by their first level parent (assuming that error is root)
 * @param {Array&lt;SchemaUtilErrorObject&gt;} children
 * @return {Array&lt;SchemaUtilErrorObject&gt;}
 */
function groupChildrenByFirstChild(children) {
  const result = [];
  let i = children.length - 1;
  while (i &gt; 0) {
    const child = children[i];
    if (child.keyword === &quot;anyOf&quot; || child.keyword === &quot;oneOf&quot;) {
      const refs = extractRefs(child);
      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));
      if (childrenStart !== i) {
        result.push(Object.assign({}, child, {
          children: children.slice(childrenStart, i)
        }));
        i = childrenStart;
      } else {
        result.push(child);
      }
    } else {
      result.push(child);
    }
    i -= 1;
  }
  if (i === 0) {
    result.push(children[i]);
  }
  return result.reverse();
}

/**
 * @param {string} str
 * @param {string} prefix
 * @returns {string}
 */
function indent(str, prefix) {
  return str.replace(/\n(?!$)/g, `\n${prefix}`);
}

/**
 * @param {Schema} schema
 * @returns {schema is (Schema &amp; {not: Schema})}
 */
function hasNotInSchema(schema) {
  return !!schema.not;
}

/**
 * @param {Schema} schema
 * @return {Schema}
 */
function findFirstTypedSchema(schema) {
  if (hasNotInSchema(schema)) {
    return findFirstTypedSchema(schema.not);
  }
  return schema;
}

/**
 * @param {Schema} schema
 * @return {boolean}
 */
function canApplyNot(schema) {
  const typedSchema = findFirstTypedSchema(schema);
  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);
}

/**
 * @param {any} maybeObj
 * @returns {boolean}
 */
function isObject(maybeObj) {
  return typeof maybeObj === &quot;object&quot; &amp;&amp; !Array.isArray(maybeObj) &amp;&amp; maybeObj !== null;
}

/**
 * @param {Schema} schema
 * @returns {boolean}
 */
function likeNumber(schema) {
  return schema.type === &quot;number&quot; || typeof schema.minimum !== &quot;undefined&quot; || typeof schema.exclusiveMinimum !== &quot;undefined&quot; || typeof schema.maximum !== &quot;undefined&quot; || typeof schema.exclusiveMaximum !== &quot;undefined&quot; || typeof schema.multipleOf !== &quot;undefined&quot;;
}

/**
 * @param {Schema} schema
 * @returns {boolean}
 */
function likeInteger(schema) {
  return schema.type === &quot;integer&quot; || typeof schema.minimum !== &quot;undefined&quot; || typeof schema.exclusiveMinimum !== &quot;undefined&quot; || typeof schema.maximum !== &quot;undefined&quot; || typeof schema.exclusiveMaximum !== &quot;undefined&quot; || typeof schema.multipleOf !== &quot;undefined&quot;;
}

/**
 * @param {Schema} schema
 * @returns {boolean}
 */
function likeString(schema) {
  return schema.type === &quot;string&quot; || typeof schema.minLength !== &quot;undefined&quot; || typeof schema.maxLength !== &quot;undefined&quot; || typeof schema.pattern !== &quot;undefined&quot; || typeof schema.format !== &quot;undefined&quot; || typeof schema.formatMinimum !== &quot;undefined&quot; || typeof schema.formatMaximum !== &quot;undefined&quot;;
}

/**
 * @param {Schema} schema
 * @returns {boolean}
 */
function likeBoolean(schema) {
  return schema.type === &quot;boolean&quot;;
}

/**
 * @param {Schema} schema
 * @returns {boolean}
 */
function likeArray(schema) {
  return schema.type === &quot;array&quot; || typeof schema.minItems === &quot;number&quot; || typeof schema.maxItems === &quot;number&quot; || typeof schema.uniqueItems !== &quot;undefined&quot; || typeof schema.items !== &quot;undefined&quot; || typeof schema.additionalItems !== &quot;undefined&quot; || typeof schema.contains !== &quot;undefined&quot;;
}

/**
 * @param {Schema &amp; {patternRequired?: Array&lt;string&gt;}} schema
 * @returns {boolean}
 */
function likeObject(schema) {
  return schema.type === &quot;object&quot; || typeof schema.minProperties !== &quot;undefined&quot; || typeof schema.maxProperties !== &quot;undefined&quot; || typeof schema.required !== &quot;undefined&quot; || typeof schema.properties !== &quot;undefined&quot; || typeof schema.patternProperties !== &quot;undefined&quot; || typeof schema.additionalProperties !== &quot;undefined&quot; || typeof schema.dependencies !== &quot;undefined&quot; || typeof schema.propertyNames !== &quot;undefined&quot; || typeof schema.patternRequired !== &quot;undefined&quot;;
}

/**
 * @param {Schema} schema
 * @returns {boolean}
 */
function likeNull(schema) {
  return schema.type === &quot;null&quot;;
}

/**
 * @param {string} type
 * @returns {string}
 */
function getArticle(type) {
  if (/^[aeiou]/i.test(type)) {
    return &quot;an&quot;;
  }
  return &quot;a&quot;;
}

/**
 * @param {Schema=} schema
 * @returns {string}
 */
function getSchemaNonTypes(schema) {
  if (!schema) {
    return &quot;&quot;;
  }
  if (!schema.type) {
    if (likeNumber(schema) || likeInteger(schema)) {
      return &quot; | should be any non-number&quot;;
    }
    if (likeString(schema)) {
      return &quot; | should be any non-string&quot;;
    }
    if (likeArray(schema)) {
      return &quot; | should be any non-array&quot;;
    }
    if (likeObject(schema)) {
      return &quot; | should be any non-object&quot;;
    }
  }
  return &quot;&quot;;
}

/**
 * @param {Array&lt;string&gt;} hints
 * @returns {string}
 */
function formatHints(hints) {
  return hints.length &gt; 0 ? `(${hints.join(&quot;, &quot;)})` : &quot;&quot;;
}
const getUtilHints = (0, _memorize.default)(() =&gt;
// eslint-disable-next-line global-require
require(&quot;./util/hints&quot;));

/**
 * @param {Schema} schema
 * @param {boolean} logic
 * @returns {string[]}
 */
function getHints(schema, logic) {
  if (likeNumber(schema) || likeInteger(schema)) {
    const util = getUtilHints();
    return util.numberHints(schema, logic);
  } else if (likeString(schema)) {
    const util = getUtilHints();
    return util.stringHints(schema, logic);
  }
  return [];
}
class ValidationError extends Error {
  /**
   * @param {Array&lt;SchemaUtilErrorObject&gt;} errors
   * @param {Schema} schema
   * @param {ValidationErrorConfiguration} configuration
   */
  constructor(errors, schema, configuration = {}) {
    super();

    /** @type {string} */
    this.name = &quot;ValidationError&quot;;
    /** @type {Array&lt;SchemaUtilErrorObject&gt;} */
    this.errors = errors;
    /** @type {Schema} */
    this.schema = schema;
    let headerNameFromSchema;
    let baseDataPathFromSchema;
    if (schema.title &amp;&amp; (!configuration.name || !configuration.baseDataPath)) {
      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);
      if (splittedTitleFromSchema) {
        if (!configuration.name) {
          [, headerNameFromSchema] = splittedTitleFromSchema;
        }
        if (!configuration.baseDataPath) {
          [,, baseDataPathFromSchema] = splittedTitleFromSchema;
        }
      }
    }

    /** @type {string} */
    this.headerName = configuration.name || headerNameFromSchema || &quot;Object&quot;;
    /** @type {string} */
    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || &quot;configuration&quot;;

    /** @type {PostFormatter | null} */
    this.postFormatter = configuration.postFormatter || null;
    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\n`;

    /** @type {string} */
    this.message = `${header}${this.formatValidationErrors(errors)}`;
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * @param {string} path
   * @returns {Schema}
   */
  getSchemaPart(path) {
    const newPath = path.split(&quot;/&quot;);
    let schemaPart = this.schema;
    for (let i = 1; i &lt; newPath.length; i++) {
      const inner = schemaPart[(/** @type {keyof Schema} */newPath[i])];
      if (!inner) {
        break;
      }
      schemaPart = inner;
    }
    return schemaPart;
  }

  /**
   * @param {Schema} schema
   * @param {boolean} logic
   * @param {Array&lt;Object&gt;} prevSchemas
   * @returns {string}
   */
  formatSchema(schema, logic = true, prevSchemas = []) {
    let newLogic = logic;
    const formatInnerSchema =
    /**
     *
     * @param {Object} innerSchema
     * @param {boolean=} addSelf
     * @returns {string}
     */
    (innerSchema, addSelf) =&gt; {
      if (!addSelf) {
        return this.formatSchema(innerSchema, newLogic, prevSchemas);
      }
      if (prevSchemas.includes(innerSchema)) {
        return &quot;(recursive)&quot;;
      }
      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));
    };
    if (hasNotInSchema(schema) &amp;&amp; !likeObject(schema)) {
      if (canApplyNot(schema.not)) {
        newLogic = !logic;
        return formatInnerSchema(schema.not);
      }
      const needApplyLogicHere = !schema.not.not;
      const prefix = logic ? &quot;&quot; : &quot;non &quot;;
      newLogic = !logic;
      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);
    }
    if (/** @type {Schema &amp; {instanceof: string | Array&lt;string&gt;}} */schema.instanceof) {
      const {
        instanceof: value
      } = /** @type {Schema &amp; {instanceof: string | Array&lt;string&gt;}} */schema;
      const values = !Array.isArray(value) ? [value] : value;
      return values.map(
      /**
       * @param {string} item
       * @returns {string}
       */
      item =&gt; item === &quot;Function&quot; ? &quot;function&quot; : item).join(&quot; | &quot;);
    }
    if (schema.enum) {
      const enumValues = /** @type {Array&lt;any&gt;} */schema.enum.map(item =&gt; {
        if (item === null &amp;&amp; schema.undefinedAsNull) {
          return `${JSON.stringify(item)} | undefined`;
        }
        return JSON.stringify(item);
      }).join(&quot; | &quot;);
      return `${enumValues}`;
    }
    if (typeof schema.const !== &quot;undefined&quot;) {
      return JSON.stringify(schema.const);
    }
    if (schema.oneOf) {
      return /** @type {Array&lt;Schema&gt;} */schema.oneOf.map(item =&gt; formatInnerSchema(item, true)).join(&quot; | &quot;);
    }
    if (schema.anyOf) {
      return /** @type {Array&lt;Schema&gt;} */schema.anyOf.map(item =&gt; formatInnerSchema(item, true)).join(&quot; | &quot;);
    }
    if (schema.allOf) {
      return /** @type {Array&lt;Schema&gt;} */schema.allOf.map(item =&gt; formatInnerSchema(item, true)).join(&quot; &amp; &quot;);
    }
    if (/** @type {JSONSchema7} */schema.if) {
      const {
        if: ifValue,
        then: thenValue,
        else: elseValue
      } = /** @type {JSONSchema7} */schema;
      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : &quot;&quot;}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : &quot;&quot;}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : &quot;&quot;}`;
    }
    if (schema.$ref) {
      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);
    }
    if (likeNumber(schema) || likeInteger(schema)) {
      const [type, ...hints] = getHints(schema, logic);
      const str = `${type}${hints.length &gt; 0 ? ` ${formatHints(hints)}` : &quot;&quot;}`;
      return logic ? str : hints.length &gt; 0 ? `non-${type} | ${str}` : `non-${type}`;
    }
    if (likeString(schema)) {
      const [type, ...hints] = getHints(schema, logic);
      const str = `${type}${hints.length &gt; 0 ? ` ${formatHints(hints)}` : &quot;&quot;}`;
      return logic ? str : str === &quot;string&quot; ? &quot;non-string&quot; : `non-string | ${str}`;
    }
    if (likeBoolean(schema)) {
      return `${logic ? &quot;&quot; : &quot;non-&quot;}boolean`;
    }
    if (likeArray(schema)) {
      // not logic already applied in formatValidationError
      newLogic = true;
      const hints = [];
      if (typeof schema.minItems === &quot;number&quot;) {
        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems &gt; 1 ? &quot;s&quot; : &quot;&quot;}`);
      }
      if (typeof schema.maxItems === &quot;number&quot;) {
        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems &gt; 1 ? &quot;s&quot; : &quot;&quot;}`);
      }
      if (schema.uniqueItems) {
        hints.push(&quot;should not have duplicate items&quot;);
      }
      const hasAdditionalItems = typeof schema.additionalItems === &quot;undefined&quot; || Boolean(schema.additionalItems);
      let items = &quot;&quot;;
      if (schema.items) {
        if (Array.isArray(schema.items) &amp;&amp; schema.items.length &gt; 0) {
          items = `${/** @type {Array&lt;Schema&gt;} */schema.items.map(item =&gt; formatInnerSchema(item)).join(&quot;, &quot;)}`;
          if (hasAdditionalItems) {
            if (schema.additionalItems &amp;&amp; isObject(schema.additionalItems) &amp;&amp; Object.keys(schema.additionalItems).length &gt; 0) {
              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);
            }
          }
        } else if (schema.items &amp;&amp; Object.keys(schema.items).length &gt; 0) {
          // &quot;additionalItems&quot; is ignored
          items = `${formatInnerSchema(schema.items)}`;
        } else {
          // Fallback for empty `items` value
          items = &quot;any&quot;;
        }
      } else {
        // &quot;additionalItems&quot; is ignored
        items = &quot;any&quot;;
      }
      if (schema.contains &amp;&amp; Object.keys(schema.contains).length &gt; 0) {
        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);
      }
      return `[${items}${hasAdditionalItems ? &quot;, ...&quot; : &quot;&quot;}]${hints.length &gt; 0 ? ` (${hints.join(&quot;, &quot;)})` : &quot;&quot;}`;
    }
    if (likeObject(schema)) {
      // not logic already applied in formatValidationError
      newLogic = true;
      const hints = [];
      if (typeof schema.minProperties === &quot;number&quot;) {
        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties &gt; 1 ? &quot;properties&quot; : &quot;property&quot;}`);
      }
      if (typeof schema.maxProperties === &quot;number&quot;) {
        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties &amp;&amp; schema.minProperties &gt; 1 ? &quot;properties&quot; : &quot;property&quot;}`);
      }
      if (schema.patternProperties &amp;&amp; Object.keys(schema.patternProperties).length &gt; 0) {
        const patternProperties = Object.keys(schema.patternProperties);
        hints.push(`additional property names should match pattern${patternProperties.length &gt; 1 ? &quot;s&quot; : &quot;&quot;} ${patternProperties.map(pattern =&gt; JSON.stringify(pattern)).join(&quot; | &quot;)}`);
      }
      const properties = schema.properties ? Object.keys(schema.properties) : [];
      /** @type {Array&lt;string&gt;} */
      // @ts-ignore
      const required = schema.required ? schema.required : [];
      const allProperties = [...new Set(/** @type {Array&lt;string&gt;} */[].concat(required).concat(properties))];
      const objectStructure = allProperties.map(property =&gt; {
        const isRequired = required.includes(property);

        // Some properties need quotes, maybe we should add check
        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable
        return `${property}${isRequired ? &quot;&quot; : &quot;?&quot;}`;
      }).concat(typeof schema.additionalProperties === &quot;undefined&quot; || Boolean(schema.additionalProperties) ? schema.additionalProperties &amp;&amp; isObject(schema.additionalProperties) ? [`&lt;key&gt;: ${formatInnerSchema(schema.additionalProperties)}`] : [&quot;…&quot;] : []).join(&quot;, &quot;);
      const {
        dependencies,
        propertyNames,
        patternRequired
      } = /** @type {Schema &amp; {patternRequired?: Array&lt;string&gt;;}} */schema;
      if (dependencies) {
        Object.keys(dependencies).forEach(dependencyName =&gt; {
          const dependency = dependencies[dependencyName];
          if (Array.isArray(dependency)) {
            hints.push(`should have ${dependency.length &gt; 1 ? &quot;properties&quot; : &quot;property&quot;} ${dependency.map(dep =&gt; `&#039;${dep}&#039;`).join(&quot;, &quot;)} when property &#039;${dependencyName}&#039; is present`);
          } else {
            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property &#039;${dependencyName}&#039; is present`);
          }
        });
      }
      if (propertyNames &amp;&amp; Object.keys(propertyNames).length &gt; 0) {
        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);
      }
      if (patternRequired &amp;&amp; patternRequired.length &gt; 0) {
        hints.push(`should have property matching pattern ${patternRequired.map(
        /**
         * @param {string} item
         * @returns {string}
         */
        item =&gt; JSON.stringify(item))}`);
      }
      return `object {${objectStructure ? ` ${objectStructure} ` : &quot;&quot;}}${hints.length &gt; 0 ? ` (${hints.join(&quot;, &quot;)})` : &quot;&quot;}`;
    }
    if (likeNull(schema)) {
      return `${logic ? &quot;&quot; : &quot;non-&quot;}null`;
    }
    if (Array.isArray(schema.type)) {
      // not logic already applied in formatValidationError
      return `${schema.type.join(&quot; | &quot;)}`;
    }

    // Fallback for unknown keywords
    // not logic already applied in formatValidationError
    /* istanbul ignore next */
    return JSON.stringify(schema, null, 2);
  }

  /**
   * @param {Schema=} schemaPart
   * @param {(boolean | Array&lt;string&gt;)=} additionalPath
   * @param {boolean=} needDot
   * @param {boolean=} logic
   * @returns {string}
   */
  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {
    if (!schemaPart) {
      return &quot;&quot;;
    }
    if (Array.isArray(additionalPath)) {
      for (let i = 0; i &lt; additionalPath.length; i++) {
        /** @type {Schema | undefined} */
        const inner = schemaPart[(/** @type {keyof Schema} */additionalPath[i])];
        if (inner) {
          // eslint-disable-next-line no-param-reassign
          schemaPart = inner;
        } else {
          break;
        }
      }
    }
    while (schemaPart.$ref) {
      // eslint-disable-next-line no-param-reassign
      schemaPart = this.getSchemaPart(schemaPart.$ref);
    }
    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? &quot;.&quot; : &quot;&quot;}`;
    if (schemaPart.description) {
      schemaText += `\n-&gt; ${schemaPart.description}`;
    }
    if (schemaPart.link) {
      schemaText += `\n-&gt; Read more at ${schemaPart.link}`;
    }
    return schemaText;
  }

  /**
   * @param {Schema=} schemaPart
   * @returns {string}
   */
  getSchemaPartDescription(schemaPart) {
    if (!schemaPart) {
      return &quot;&quot;;
    }
    while (schemaPart.$ref) {
      // eslint-disable-next-line no-param-reassign
      schemaPart = this.getSchemaPart(schemaPart.$ref);
    }
    let schemaText = &quot;&quot;;
    if (schemaPart.description) {
      schemaText += `\n-&gt; ${schemaPart.description}`;
    }
    if (schemaPart.link) {
      schemaText += `\n-&gt; Read more at ${schemaPart.link}`;
    }
    return schemaText;
  }

  /**
   * @param {SchemaUtilErrorObject} error
   * @returns {string}
   */
  formatValidationError(error) {
    const {
      keyword,
      instancePath: errorInstancePath
    } = error;
    const splittedInstancePath = errorInstancePath.split(&quot;/&quot;);
    /**
     * @type {Array&lt;string&gt;}
     */
    const defaultValue = [];
    const prettyInstancePath = splittedInstancePath.reduce((acc, val) =&gt; {
      if (val.length &gt; 0) {
        if (isNumeric(val)) {
          acc.push(`[${val}]`);
        } else if (/^\[/.test(val)) {
          acc.push(val);
        } else {
          acc.push(`.${val}`);
        }
      }
      return acc;
    }, defaultValue).join(&quot;&quot;);
    const instancePath = `${this.baseDataPath}${prettyInstancePath}`;

    // const { keyword, instancePath: errorInstancePath } = error;
    // const instancePath = `${this.baseDataPath}${errorInstancePath.replace(/\//g, &#039;.&#039;)}`;

    switch (keyword) {
      case &quot;type&quot;:
        {
          const {
            parentSchema,
            params
          } = error;
          switch (params.type) {
            case &quot;number&quot;:
              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
            case &quot;integer&quot;:
              return `${instancePath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;
            case &quot;string&quot;:
              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
            case &quot;boolean&quot;:
              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
            case &quot;array&quot;:
              return `${instancePath} should be an array:\n${this.getSchemaPartText(parentSchema)}`;
            case &quot;object&quot;:
              return `${instancePath} should be an object:\n${this.getSchemaPartText(parentSchema)}`;
            case &quot;null&quot;:
              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;
            default:
              return `${instancePath} should be:\n${this.getSchemaPartText(parentSchema)}`;
          }
        }
      case &quot;instanceof&quot;:
        {
          const {
            parentSchema
          } = error;
          return `${instancePath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;
        }
      case &quot;pattern&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            pattern
          } = params;
          return `${instancePath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;format&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            format
          } = params;
          return `${instancePath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;formatMinimum&quot;:
      case &quot;formatExclusiveMinimum&quot;:
      case &quot;formatMaximum&quot;:
      case &quot;formatExclusiveMaximum&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            comparison,
            limit
          } = params;
          return `${instancePath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;minimum&quot;:
      case &quot;maximum&quot;:
      case &quot;exclusiveMinimum&quot;:
      case &quot;exclusiveMaximum&quot;:
        {
          const {
            parentSchema,
            params
          } = error;
          const {
            comparison,
            limit
          } = params;
          const [, ...hints] = getHints(/** @type {Schema} */parentSchema, true);
          if (hints.length === 0) {
            hints.push(`should be ${comparison} ${limit}`);
          }
          return `${instancePath} ${hints.join(&quot; &quot;)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;multipleOf&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            multipleOf
          } = params;
          return `${instancePath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;patternRequired&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            missingPattern
          } = params;
          return `${instancePath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;minLength&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          if (limit === 1) {
            return `${instancePath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
          }
          const length = limit - 1;
          return `${instancePath} should be longer than ${length} character${length &gt; 1 ? &quot;s&quot; : &quot;&quot;}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;minItems&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          if (limit === 1) {
            return `${instancePath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
          }
          return `${instancePath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;minProperties&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          if (limit === 1) {
            return `${instancePath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
          }
          return `${instancePath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;maxLength&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          const max = limit + 1;
          return `${instancePath} should be shorter than ${max} character${max &gt; 1 ? &quot;s&quot; : &quot;&quot;}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;maxItems&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;maxProperties&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          return `${instancePath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;uniqueItems&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            i
          } = params;
          return `${instancePath} should not contain the item &#039;${/** @type {{ data: Array&lt;any&gt; }} **/
          error.data[i]}&#039; twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;additionalItems&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            limit
          } = params;
          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\n${this.getSchemaPartText(parentSchema)}`;
        }
      case &quot;contains&quot;:
        {
          const {
            parentSchema
          } = error;
          return `${instancePath} should contains at least one ${this.getSchemaPartText(parentSchema, [&quot;contains&quot;])} item${getSchemaNonTypes(parentSchema)}.`;
        }
      case &quot;required&quot;:
        {
          const {
            parentSchema,
            params
          } = error;
          const missingProperty = params.missingProperty.replace(/^\./, &quot;&quot;);
          const hasProperty = parentSchema &amp;&amp; Boolean(/** @type {Schema} */
          parentSchema.properties &amp;&amp; /** @type {Schema} */
          parentSchema.properties[missingProperty]);
          return `${instancePath} misses the property &#039;${missingProperty}&#039;${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\n${this.getSchemaPartText(parentSchema, [&quot;properties&quot;, missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;additionalProperties&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            additionalProperty
          } = params;
          return `${instancePath} has an unknown property &#039;${additionalProperty}&#039;${getSchemaNonTypes(parentSchema)}. These properties are valid:\n${this.getSchemaPartText(parentSchema)}`;
        }
      case &quot;dependencies&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            property,
            deps
          } = params;
          const dependencies = deps.split(&quot;,&quot;).map(
          /**
           * @param {string} dep
           * @returns {string}
           */
          dep =&gt; `&#039;${dep.trim()}&#039;`).join(&quot;, &quot;);
          return `${instancePath} should have properties ${dependencies} when property &#039;${property}&#039; is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;propertyNames&quot;:
        {
          const {
            params,
            parentSchema,
            schema
          } = error;
          const {
            propertyName
          } = params;
          return `${instancePath} property name &#039;${propertyName}&#039; is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;
        }
      case &quot;enum&quot;:
        {
          const {
            parentSchema
          } = error;
          if (parentSchema &amp;&amp; /** @type {Schema} */
          parentSchema.enum &amp;&amp; /** @type {Schema} */
          parentSchema.enum.length === 1) {
            return `${instancePath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;
          }
          return `${instancePath} should be one of these:\n${this.getSchemaPartText(parentSchema)}`;
        }
      case &quot;const&quot;:
        {
          const {
            parentSchema
          } = error;
          return `${instancePath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;
        }
      case &quot;not&quot;:
        {
          const postfix = likeObject(/** @type {Schema} */error.parentSchema) ? `\n${this.getSchemaPartText(error.parentSchema)}` : &quot;&quot;;
          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);
          if (canApplyNot(error.schema)) {
            return `${instancePath} should be any ${schemaOutput}${postfix}.`;
          }
          const {
            schema,
            parentSchema
          } = error;
          return `${instancePath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema &amp;&amp; likeObject(parentSchema) ? `\n${this.getSchemaPartText(parentSchema)}` : &quot;&quot;}`;
        }
      case &quot;oneOf&quot;:
      case &quot;anyOf&quot;:
        {
          const {
            parentSchema,
            children
          } = error;
          if (children &amp;&amp; children.length &gt; 0) {
            if (error.schema.length === 1) {
              const lastChild = children[children.length - 1];
              const remainingChildren = children.slice(0, children.length - 1);
              return this.formatValidationError(Object.assign({}, lastChild, {
                children: remainingChildren,
                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)
              }));
            }
            let filteredChildren = filterChildren(children);
            if (filteredChildren.length === 1) {
              return this.formatValidationError(filteredChildren[0]);
            }
            filteredChildren = groupChildrenByFirstChild(filteredChildren);
            return `${instancePath} should be one of these:\n${this.getSchemaPartText(parentSchema)}\nDetails:\n${filteredChildren.map(
            /**
             * @param {SchemaUtilErrorObject} nestedError
             * @returns {string}
             */
            nestedError =&gt; ` * ${indent(this.formatValidationError(nestedError), &quot;   &quot;)}`).join(&quot;\n&quot;)}`;
          }
          return `${instancePath} should be one of these:\n${this.getSchemaPartText(parentSchema)}`;
        }
      case &quot;if&quot;:
        {
          const {
            params,
            parentSchema
          } = error;
          const {
            failingKeyword
          } = params;
          return `${instancePath} should match &quot;${failingKeyword}&quot; schema:\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;
        }
      case &quot;absolutePath&quot;:
        {
          const {
            message,
            parentSchema
          } = error;
          return `${instancePath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;
        }
      /* istanbul ignore next */
      default:
        {
          const {
            message,
            parentSchema
          } = error;
          const ErrorInJSON = JSON.stringify(error, null, 2);

          // For `custom`, `false schema`, `$ref` keywords
          // Fallback for unknown keywords
          return `${instancePath} ${message} (${ErrorInJSON}).\n${this.getSchemaPartText(parentSchema, false)}`;
        }
    }
  }

  /**
   * @param {Array&lt;SchemaUtilErrorObject&gt;} errors
   * @returns {string}
   */
  formatValidationErrors(errors) {
    return errors.map(error =&gt; {
      let formattedError = this.formatValidationError(error);
      if (this.postFormatter) {
        formattedError = this.postFormatter(formattedError, error);
      }
      return ` - ${indent(formattedError, &quot;   &quot;)}`;
    }).join(&quot;\n&quot;);
  }
}
var _default = exports.default = ValidationError;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
