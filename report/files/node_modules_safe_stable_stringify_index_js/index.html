<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/safe-stable-stringify/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/safe-stable-stringify/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">49.49</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">626</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">171.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

const { hasOwnProperty } = Object.prototype

const stringify = configure()

// @ts-expect-error
stringify.configure = configure
// @ts-expect-error
stringify.stringify = stringify

// @ts-expect-error
stringify.default = stringify

// @ts-expect-error used for named export
exports.stringify = stringify
// @ts-expect-error used for named export
exports.configure = configure

module.exports = stringify

// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/

// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape (str) {
  // Some magic numbers that worked out fine while benchmarking with v8 8.0
  if (str.length &lt; 5000 &amp;&amp; !strEscapeSequencesRegExp.test(str)) {
    return `&quot;${str}&quot;`
  }
  return JSON.stringify(str)
}

function sort (array, comparator) {
  // Insertion sort is very efficient for small input sizes, but it has a bad
  // worst case complexity. Thus, use native array sort for bigger values.
  if (array.length &gt; 2e2 || comparator) {
    return array.sort(comparator)
  }
  for (let i = 1; i &lt; array.length; i++) {
    const currentValue = array[i]
    let position = i
    while (position !== 0 &amp;&amp; array[position - 1] &gt; currentValue) {
      array[position] = array[position - 1]
      position--
    }
    array[position] = currentValue
  }
  return array
}

const typedArrayPrototypeGetSymbolToStringTag =
  Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get

function isTypedArrayWithEntries (value) {
  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined &amp;&amp; value.length !== 0
}

function stringifyTypedArray (array, separator, maximumBreadth) {
  if (array.length &lt; maximumBreadth) {
    maximumBreadth = array.length
  }
  const whitespace = separator === &#039;,&#039; ? &#039;&#039; : &#039; &#039;
  let res = `&quot;0&quot;:${whitespace}${array[0]}`
  for (let i = 1; i &lt; maximumBreadth; i++) {
    res += `${separator}&quot;${i}&quot;:${whitespace}${array[i]}`
  }
  return res
}

function getCircularValueOption (options) {
  if (hasOwnProperty.call(options, &#039;circularValue&#039;)) {
    const circularValue = options.circularValue
    if (typeof circularValue === &#039;string&#039;) {
      return `&quot;${circularValue}&quot;`
    }
    if (circularValue == null) {
      return circularValue
    }
    if (circularValue === Error || circularValue === TypeError) {
      return {
        toString () {
          throw new TypeError(&#039;Converting circular structure to JSON&#039;)
        }
      }
    }
    throw new TypeError(&#039;The &quot;circularValue&quot; argument must be of type string or the value null or undefined&#039;)
  }
  return &#039;&quot;[Circular]&quot;&#039;
}

function getDeterministicOption (options) {
  let value
  if (hasOwnProperty.call(options, &#039;deterministic&#039;)) {
    value = options.deterministic
    if (typeof value !== &#039;boolean&#039; &amp;&amp; typeof value !== &#039;function&#039;) {
      throw new TypeError(&#039;The &quot;deterministic&quot; argument must be of type boolean or comparator function&#039;)
    }
  }
  return value === undefined ? true : value
}

function getBooleanOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== &#039;boolean&#039;) {
      throw new TypeError(`The &quot;${key}&quot; argument must be of type boolean`)
    }
  }
  return value === undefined ? true : value
}

function getPositiveIntegerOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== &#039;number&#039;) {
      throw new TypeError(`The &quot;${key}&quot; argument must be of type number`)
    }
    if (!Number.isInteger(value)) {
      throw new TypeError(`The &quot;${key}&quot; argument must be an integer`)
    }
    if (value &lt; 1) {
      throw new RangeError(`The &quot;${key}&quot; argument must be &gt;= 1`)
    }
  }
  return value === undefined ? Infinity : value
}

function getItemCount (number) {
  if (number === 1) {
    return &#039;1 item&#039;
  }
  return `${number} items`
}

function getUniqueReplacerSet (replacerArray) {
  const replacerSet = new Set()
  for (const value of replacerArray) {
    if (typeof value === &#039;string&#039; || typeof value === &#039;number&#039;) {
      replacerSet.add(String(value))
    }
  }
  return replacerSet
}

function getStrictOption (options) {
  if (hasOwnProperty.call(options, &#039;strict&#039;)) {
    const value = options.strict
    if (typeof value !== &#039;boolean&#039;) {
      throw new TypeError(&#039;The &quot;strict&quot; argument must be of type boolean&#039;)
    }
    if (value) {
      return (value) =&gt; {
        let message = `Object can not safely be stringified. Received type ${typeof value}`
        if (typeof value !== &#039;function&#039;) message += ` (${value.toString()})`
        throw new Error(message)
      }
    }
  }
}

function configure (options) {
  options = { ...options }
  const fail = getStrictOption(options)
  if (fail) {
    if (options.bigint === undefined) {
      options.bigint = false
    }
    if (!(&#039;circularValue&#039; in options)) {
      options.circularValue = Error
    }
  }
  const circularValue = getCircularValueOption(options)
  const bigint = getBooleanOption(options, &#039;bigint&#039;)
  const deterministic = getDeterministicOption(options)
  const comparator = typeof deterministic === &#039;function&#039; ? deterministic : undefined
  const maximumDepth = getPositiveIntegerOption(options, &#039;maximumDepth&#039;)
  const maximumBreadth = getPositiveIntegerOption(options, &#039;maximumBreadth&#039;)

  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
    let value = parent[key]

    if (typeof value === &#039;object&#039; &amp;&amp; value !== null &amp;&amp; typeof value.toJSON === &#039;function&#039;) {
      value = value.toJSON(key)
    }
    value = replacer.call(parent, key, value)

    switch (typeof value) {
      case &#039;string&#039;:
        return strEscape(value)
      case &#039;object&#039;: {
        if (value === null) {
          return &#039;null&#039;
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = &#039;&#039;
        let join = &#039;,&#039;
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return &#039;[]&#039;
          }
          if (maximumDepth &lt; stack.length + 1) {
            return &#039;&quot;[Array]&quot;&#039;
          }
          stack.push(value)
          if (spacer !== &#039;&#039;) {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i &lt; maximumValuesToStringify - 1; i++) {
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : &#039;null&#039;
            res += join
          }
          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : &#039;null&#039;
          if (value.length - 1 &gt; maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}&quot;... ${getItemCount(removedKeys)} not stringified&quot;`
          }
          if (spacer !== &#039;&#039;) {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return &#039;{}&#039;
        }
        if (maximumDepth &lt; stack.length + 1) {
          return &#039;&quot;[Object]&quot;&#039;
        }
        let whitespace = &#039;&#039;
        let separator = &#039;&#039;
        if (spacer !== &#039;&#039;) {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = &#039; &#039;
        }
        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (deterministic &amp;&amp; !isTypedArrayWithEntries(value)) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i &lt; maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (keyLength &gt; maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}&quot;...&quot;:${whitespace}&quot;${getItemCount(removedKeys)} not stringified&quot;`
          separator = join
        }
        if (spacer !== &#039;&#039; &amp;&amp; separator.length &gt; 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case &#039;number&#039;:
        return isFinite(value) ? String(value) : fail ? fail(value) : &#039;null&#039;
      case &#039;boolean&#039;:
        return value === true ? &#039;true&#039; : &#039;false&#039;
      case &#039;undefined&#039;:
        return undefined
      case &#039;bigint&#039;:
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
    if (typeof value === &#039;object&#039; &amp;&amp; value !== null &amp;&amp; typeof value.toJSON === &#039;function&#039;) {
      value = value.toJSON(key)
    }

    switch (typeof value) {
      case &#039;string&#039;:
        return strEscape(value)
      case &#039;object&#039;: {
        if (value === null) {
          return &#039;null&#039;
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        const originalIndentation = indentation
        let res = &#039;&#039;
        let join = &#039;,&#039;

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return &#039;[]&#039;
          }
          if (maximumDepth &lt; stack.length + 1) {
            return &#039;&quot;[Array]&quot;&#039;
          }
          stack.push(value)
          if (spacer !== &#039;&#039;) {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i &lt; maximumValuesToStringify - 1; i++) {
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : &#039;null&#039;
            res += join
          }
          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : &#039;null&#039;
          if (value.length - 1 &gt; maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}&quot;... ${getItemCount(removedKeys)} not stringified&quot;`
          }
          if (spacer !== &#039;&#039;) {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }
        stack.push(value)
        let whitespace = &#039;&#039;
        if (spacer !== &#039;&#039;) {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = &#039; &#039;
        }
        let separator = &#039;&#039;
        for (const key of replacer) {
          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (spacer !== &#039;&#039; &amp;&amp; separator.length &gt; 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case &#039;number&#039;:
        return isFinite(value) ? String(value) : fail ? fail(value) : &#039;null&#039;
      case &#039;boolean&#039;:
        return value === true ? &#039;true&#039; : &#039;false&#039;
      case &#039;undefined&#039;:
        return undefined
      case &#039;bigint&#039;:
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyIndent (key, value, stack, spacer, indentation) {
    switch (typeof value) {
      case &#039;string&#039;:
        return strEscape(value)
      case &#039;object&#039;: {
        if (value === null) {
          return &#039;null&#039;
        }
        if (typeof value.toJSON === &#039;function&#039;) {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again.
          if (typeof value !== &#039;object&#039;) {
            return stringifyIndent(key, value, stack, spacer, indentation)
          }
          if (value === null) {
            return &#039;null&#039;
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return &#039;[]&#039;
          }
          if (maximumDepth &lt; stack.length + 1) {
            return &#039;&quot;[Array]&quot;&#039;
          }
          stack.push(value)
          indentation += spacer
          let res = `\n${indentation}`
          const join = `,\n${indentation}`
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i &lt; maximumValuesToStringify - 1; i++) {
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
            res += tmp !== undefined ? tmp : &#039;null&#039;
            res += join
          }
          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
          res += tmp !== undefined ? tmp : &#039;null&#039;
          if (value.length - 1 &gt; maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}&quot;... ${getItemCount(removedKeys)} not stringified&quot;`
          }
          res += `\n${originalIndentation}`
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return &#039;{}&#039;
        }
        if (maximumDepth &lt; stack.length + 1) {
          return &#039;&quot;[Object]&quot;&#039;
        }
        indentation += spacer
        const join = `,\n${indentation}`
        let res = &#039;&#039;
        let separator = &#039;&#039;
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, join, maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = join
        }
        if (deterministic) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i &lt; maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}: ${tmp}`
            separator = join
          }
        }
        if (keyLength &gt; maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}&quot;...&quot;: &quot;${getItemCount(removedKeys)} not stringified&quot;`
          separator = join
        }
        if (separator !== &#039;&#039;) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case &#039;number&#039;:
        return isFinite(value) ? String(value) : fail ? fail(value) : &#039;null&#039;
      case &#039;boolean&#039;:
        return value === true ? &#039;true&#039; : &#039;false&#039;
      case &#039;undefined&#039;:
        return undefined
      case &#039;bigint&#039;:
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifySimple (key, value, stack) {
    switch (typeof value) {
      case &#039;string&#039;:
        return strEscape(value)
      case &#039;object&#039;: {
        if (value === null) {
          return &#039;null&#039;
        }
        if (typeof value.toJSON === &#039;function&#039;) {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again
          if (typeof value !== &#039;object&#039;) {
            return stringifySimple(key, value, stack)
          }
          if (value === null) {
            return &#039;null&#039;
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = &#039;&#039;

        const hasLength = value.length !== undefined
        if (hasLength &amp;&amp; Array.isArray(value)) {
          if (value.length === 0) {
            return &#039;[]&#039;
          }
          if (maximumDepth &lt; stack.length + 1) {
            return &#039;&quot;[Array]&quot;&#039;
          }
          stack.push(value)
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i &lt; maximumValuesToStringify - 1; i++) {
            const tmp = stringifySimple(String(i), value[i], stack)
            res += tmp !== undefined ? tmp : &#039;null&#039;
            res += &#039;,&#039;
          }
          const tmp = stringifySimple(String(i), value[i], stack)
          res += tmp !== undefined ? tmp : &#039;null&#039;
          if (value.length - 1 &gt; maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `,&quot;... ${getItemCount(removedKeys)} not stringified&quot;`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return &#039;{}&#039;
        }
        if (maximumDepth &lt; stack.length + 1) {
          return &#039;&quot;[Object]&quot;&#039;
        }
        let separator = &#039;&#039;
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (hasLength &amp;&amp; isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, &#039;,&#039;, maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = &#039;,&#039;
        }
        if (deterministic) {
          keys = sort(keys, comparator)
        }
        stack.push(value)
        for (let i = 0; i &lt; maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifySimple(key, value[key], stack)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${tmp}`
            separator = &#039;,&#039;
          }
        }
        if (keyLength &gt; maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}&quot;...&quot;:&quot;${getItemCount(removedKeys)} not stringified&quot;`
        }
        stack.pop()
        return `{${res}}`
      }
      case &#039;number&#039;:
        return isFinite(value) ? String(value) : fail ? fail(value) : &#039;null&#039;
      case &#039;boolean&#039;:
        return value === true ? &#039;true&#039; : &#039;false&#039;
      case &#039;undefined&#039;:
        return undefined
      case &#039;bigint&#039;:
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringify (value, replacer, space) {
    if (arguments.length &gt; 1) {
      let spacer = &#039;&#039;
      if (typeof space === &#039;number&#039;) {
        spacer = &#039; &#039;.repeat(Math.min(space, 10))
      } else if (typeof space === &#039;string&#039;) {
        spacer = space.slice(0, 10)
      }
      if (replacer != null) {
        if (typeof replacer === &#039;function&#039;) {
          return stringifyFnReplacer(&#039;&#039;, { &#039;&#039;: value }, [], replacer, spacer, &#039;&#039;)
        }
        if (Array.isArray(replacer)) {
          return stringifyArrayReplacer(&#039;&#039;, value, [], getUniqueReplacerSet(replacer), spacer, &#039;&#039;)
        }
      }
      if (spacer.length !== 0) {
        return stringifyIndent(&#039;&#039;, value, [], spacer, &#039;&#039;)
      }
    }
    return stringifySimple(&#039;&#039;, value, [])
  }

  return stringify
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
