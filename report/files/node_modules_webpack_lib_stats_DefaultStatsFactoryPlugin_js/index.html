<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/stats/DefaultStatsFactoryPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/stats/DefaultStatsFactoryPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2688</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">154.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">25.53</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const util = require(&quot;util&quot;);
const { WEBPACK_MODULE_TYPE_RUNTIME } = require(&quot;../ModuleTypeConstants&quot;);
const ModuleDependency = require(&quot;../dependencies/ModuleDependency&quot;);
const formatLocation = require(&quot;../formatLocation&quot;);
const { LogType } = require(&quot;../logging/Logger&quot;);
const AggressiveSplittingPlugin = require(&quot;../optimize/AggressiveSplittingPlugin&quot;);
const SizeLimitsPlugin = require(&quot;../performance/SizeLimitsPlugin&quot;);
const { countIterable } = require(&quot;../util/IterableHelpers&quot;);
const {
	compareLocations,
	compareChunksById,
	compareNumbers,
	compareIds,
	concatComparators,
	compareSelect,
	compareModulesByIdentifier
} = require(&quot;../util/comparators&quot;);
const { makePathsRelative, parseResource } = require(&quot;../util/identifier&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../Chunk&quot;)} Chunk */
/** @typedef {import(&quot;../Chunk&quot;).ChunkId} ChunkId */
/** @typedef {import(&quot;../Chunk&quot;).ChunkName} ChunkName */
/** @typedef {import(&quot;../ChunkGraph&quot;).ModuleId} ModuleId */
/** @typedef {import(&quot;../ChunkGroup&quot;)} ChunkGroup */
/** @typedef {import(&quot;../ChunkGroup&quot;).OriginRecord} OriginRecord */
/** @typedef {import(&quot;../Compilation&quot;)} Compilation */
/** @typedef {import(&quot;../Compilation&quot;).Asset} Asset */
/** @typedef {import(&quot;../Compilation&quot;).AssetInfo} AssetInfo */
/** @typedef {import(&quot;../Compilation&quot;).ExcludeModulesType} ExcludeModulesType */
/** @typedef {import(&quot;../Compilation&quot;).KnownNormalizedStatsOptions} KnownNormalizedStatsOptions */
/** @typedef {import(&quot;../Compilation&quot;).NormalizedStatsOptions} NormalizedStatsOptions */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../Dependency&quot;)} Dependency */
/** @typedef {import(&quot;../Dependency&quot;).DependencyLocation} DependencyLocation */
/** @typedef {import(&quot;../Module&quot;)} Module */
/** @typedef {import(&quot;../Module&quot;).BuildInfo} BuildInfo */
/** @typedef {import(&quot;../ModuleGraphConnection&quot;)} ModuleGraphConnection */
/** @typedef {import(&quot;../ModuleProfile&quot;)} ModuleProfile */
/** @typedef {import(&quot;../RequestShortener&quot;)} RequestShortener */
/** @typedef {import(&quot;../TemplatedPathPlugin&quot;).TemplatePath} TemplatePath */
/** @typedef {import(&quot;../WebpackError&quot;)} WebpackError */
/** @typedef {import(&quot;../util/runtime&quot;).RuntimeSpec} RuntimeSpec */
/** @typedef {import(&quot;./StatsFactory&quot;)} StatsFactory */
/** @typedef {import(&quot;./StatsFactory&quot;).StatsFactoryContext} StatsFactoryContext */

/**
 * @template T
 * @typedef {import(&quot;../util/comparators&quot;).Comparator&lt;T&gt;} Comparator&lt;T&gt;
 */

/**
 * @template T, R
 * @typedef {import(&quot;../util/smartGrouping&quot;).GroupConfig&lt;T, R&gt;} GroupConfig
 */

/** @typedef {KnownStatsCompilation &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsCompilation */
/**
 * @typedef {object} KnownStatsCompilation
 * @property {Record&lt;string, EXPECTED_ANY&gt;=} env
 * @property {string=} name
 * @property {string=} hash
 * @property {string=} version
 * @property {number=} time
 * @property {number=} builtAt
 * @property {boolean=} needAdditionalPass
 * @property {string=} publicPath
 * @property {string=} outputPath
 * @property {Record&lt;string, string[]&gt;=} assetsByChunkName
 * @property {StatsAsset[]=} assets
 * @property {number=} filteredAssets
 * @property {StatsChunk[]=} chunks
 * @property {StatsModule[]=} modules
 * @property {number=} filteredModules
 * @property {Record&lt;string, StatsChunkGroup&gt;=} entrypoints
 * @property {Record&lt;string, StatsChunkGroup&gt;=} namedChunkGroups
 * @property {StatsError[]=} errors
 * @property {number=} errorsCount
 * @property {StatsError[]=} warnings
 * @property {number=} warningsCount
 * @property {StatsCompilation[]=} children
 * @property {Record&lt;string, StatsLogging&gt;=} logging
 * @property {number=} filteredWarningDetailsCount
 * @property {number=} filteredErrorDetailsCount
 */

/** @typedef {KnownStatsLogging &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsLogging */
/**
 * @typedef {object} KnownStatsLogging
 * @property {StatsLoggingEntry[]} entries
 * @property {number} filteredEntries
 * @property {boolean} debug
 */

/** @typedef {KnownStatsLoggingEntry &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsLoggingEntry */
/**
 * @typedef {object} KnownStatsLoggingEntry
 * @property {string} type
 * @property {string=} message
 * @property {string[]=} trace
 * @property {StatsLoggingEntry[]=} children
 * @property {EXPECTED_ANY[]=} args
 * @property {number=} time
 */

/** @typedef {KnownStatsAsset &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsAsset */
/** @typedef {ChunkId} KnownStatsAssetChunk */
/** @typedef {ChunkName} KnownStatsAssetChunkName */
/** @typedef {string} KnownStatsAssetChunkIdHint */
/**
 * @typedef {object} KnownStatsAsset
 * @property {string} type
 * @property {string} name
 * @property {AssetInfo} info
 * @property {number} size
 * @property {boolean} emitted
 * @property {boolean} comparedForEmit
 * @property {boolean} cached
 * @property {StatsAsset[]=} related
 * @property {KnownStatsAssetChunk[]=} chunks
 * @property {KnownStatsAssetChunkName[]=} chunkNames
 * @property {KnownStatsAssetChunkIdHint[]=} chunkIdHints
 * @property {KnownStatsAssetChunk[]=} auxiliaryChunks
 * @property {KnownStatsAssetChunkName[]=} auxiliaryChunkNames
 * @property {KnownStatsAssetChunkIdHint[]=} auxiliaryChunkIdHints
 * @property {number=} filteredRelated
 * @property {boolean=} isOverSizeLimit
 */

/** @typedef {KnownStatsChunkGroup &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsChunkGroup */
/**
 * @typedef {object} KnownStatsChunkGroup
 * @property {(string | null)=} name
 * @property {(string | number)[]=} chunks
 * @property {({ name: string, size?: number })[]=} assets
 * @property {number=} filteredAssets
 * @property {number=} assetsSize
 * @property {({ name: string, size?: number })[]=} auxiliaryAssets
 * @property {number=} filteredAuxiliaryAssets
 * @property {number=} auxiliaryAssetsSize
 * @property {{ [x: string]: StatsChunkGroup[] }=} children
 * @property {{ [x: string]: string[] }=} childAssets
 * @property {boolean=} isOverSizeLimit
 */

/** @typedef {Module[]} ModuleIssuerPath */
/** @typedef {KnownStatsModule &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsModule */
/**
 * @typedef {object} KnownStatsModule
 * @property {string=} type
 * @property {string=} moduleType
 * @property {(string | null)=} layer
 * @property {string=} identifier
 * @property {string=} name
 * @property {(string | null)=} nameForCondition
 * @property {number=} index
 * @property {number=} preOrderIndex
 * @property {number=} index2
 * @property {number=} postOrderIndex
 * @property {number=} size
 * @property {{ [x: string]: number }=} sizes
 * @property {boolean=} cacheable
 * @property {boolean=} built
 * @property {boolean=} codeGenerated
 * @property {boolean=} buildTimeExecuted
 * @property {boolean=} cached
 * @property {boolean=} optional
 * @property {boolean=} orphan
 * @property {string | number=} id
 * @property {string | number | null=} issuerId
 * @property {(string | number)[]=} chunks
 * @property {(string | number)[]=} assets
 * @property {boolean=} dependent
 * @property {(string | null)=} issuer
 * @property {(string | null)=} issuerName
 * @property {StatsModuleIssuer[] | null=} issuerPath
 * @property {boolean=} failed
 * @property {number=} errors
 * @property {number=} warnings
 * @property {StatsProfile=} profile
 * @property {StatsModuleReason[]=} reasons
 * @property {(boolean | null | string[])=} usedExports
 * @property {(string[] | null)=} providedExports
 * @property {string[]=} optimizationBailout
 * @property {(number | null)=} depth
 * @property {StatsModule[]=} modules
 * @property {number=} filteredModules
 * @property {ReturnType&lt;Source[&quot;source&quot;]&gt;=} source
 */

/** @typedef {KnownStatsProfile &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsProfile */
/**
 * @typedef {object} KnownStatsProfile
 * @property {number} total
 * @property {number} resolving
 * @property {number} restoring
 * @property {number} building
 * @property {number} integration
 * @property {number} storing
 * @property {number} additionalResolving
 * @property {number} additionalIntegration
 * @property {number} factory
 * @property {number} dependencies
 */

/** @typedef {KnownStatsModuleIssuer &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsModuleIssuer */
/**
 * @typedef {object} KnownStatsModuleIssuer
 * @property {string} identifier
 * @property {string} name
 * @property {(string|number)=} id
 * @property {StatsProfile} profile
 */

/** @typedef {KnownStatsModuleReason &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsModuleReason */
/**
 * @typedef {object} KnownStatsModuleReason
 * @property {string | null} moduleIdentifier
 * @property {string | null} module
 * @property {string | null} moduleName
 * @property {string | null} resolvedModuleIdentifier
 * @property {string | null} resolvedModule
 * @property {string | null} type
 * @property {boolean} active
 * @property {string | null} explanation
 * @property {string | null} userRequest
 * @property {(string | null)=} loc
 * @property {(string | number | null)=} moduleId
 * @property {(string | number | null)=} resolvedModuleId
 */

/** @typedef {KnownStatsChunk &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsChunk */
/**
 * @typedef {object} KnownStatsChunk
 * @property {boolean} rendered
 * @property {boolean} initial
 * @property {boolean} entry
 * @property {boolean} recorded
 * @property {string=} reason
 * @property {number} size
 * @property {Record&lt;string, number&gt;} sizes
 * @property {string[]} names
 * @property {string[]} idHints
 * @property {string[]=} runtime
 * @property {string[]} files
 * @property {string[]} auxiliaryFiles
 * @property {string} hash
 * @property {Record&lt;string, ChunkId[]&gt;} childrenByOrder
 * @property {(string|number)=} id
 * @property {(string|number)[]=} siblings
 * @property {(string|number)[]=} parents
 * @property {(string|number)[]=} children
 * @property {StatsModule[]=} modules
 * @property {number=} filteredModules
 * @property {StatsChunkOrigin[]=} origins
 */

/** @typedef {KnownStatsChunkOrigin &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsChunkOrigin */
/**
 * @typedef {object} KnownStatsChunkOrigin
 * @property {string} module
 * @property {string} moduleIdentifier
 * @property {string} moduleName
 * @property {string} loc
 * @property {string} request
 * @property {(string | number)=} moduleId
 */

/** @typedef {KnownStatsModuleTraceItem &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsModuleTraceItem */
/**
 * @typedef {object} KnownStatsModuleTraceItem
 * @property {string=} originIdentifier
 * @property {string=} originName
 * @property {string=} moduleIdentifier
 * @property {string=} moduleName
 * @property {StatsModuleTraceDependency[]=} dependencies
 * @property {(string|number)=} originId
 * @property {(string|number)=} moduleId
 */

/** @typedef {KnownStatsModuleTraceDependency &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsModuleTraceDependency */
/**
 * @typedef {object} KnownStatsModuleTraceDependency
 * @property {string=} loc
 */

/** @typedef {KnownStatsError &amp; Record&lt;string, EXPECTED_ANY&gt;} StatsError */
/**
 * @typedef {object} KnownStatsError
 * @property {string} message
 * @property {string=} chunkName
 * @property {boolean=} chunkEntry
 * @property {boolean=} chunkInitial
 * @property {string=} file
 * @property {string=} moduleIdentifier
 * @property {string=} moduleName
 * @property {string=} loc
 * @property {ChunkId=} chunkId
 * @property {string|number=} moduleId
 * @property {StatsModuleTraceItem[]=} moduleTrace
 * @property {string=} details
 * @property {string=} stack
 * @property {KnownStatsError=} cause
 * @property {KnownStatsError[]=} errors
 * @property {string=} compilerPath
 */

/** @typedef {Asset &amp; { type: string, related: PreprocessedAsset[] | undefined }} PreprocessedAsset */

/**
 * @template T
 * @template O
 * @typedef {Record&lt;string, (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) =&gt; void&gt;} ExtractorsByOption
 */

/** @typedef {{ name: string, chunkGroup: ChunkGroup }} ChunkGroupInfoWithName */
/** @typedef {{ origin: Module, module: Module }} ModuleTrace */

/**
 * @typedef {object} SimpleExtractors
 * @property {ExtractorsByOption&lt;Compilation, StatsCompilation&gt;} compilation
 * @property {ExtractorsByOption&lt;PreprocessedAsset, StatsAsset&gt;} asset
 * @property {ExtractorsByOption&lt;PreprocessedAsset, StatsAsset&gt;} asset$visible
 * @property {ExtractorsByOption&lt;ChunkGroupInfoWithName, StatsChunkGroup&gt;} chunkGroup
 * @property {ExtractorsByOption&lt;Module, StatsModule&gt;} module
 * @property {ExtractorsByOption&lt;Module, StatsModule&gt;} module$visible
 * @property {ExtractorsByOption&lt;Module, StatsModuleIssuer&gt;} moduleIssuer
 * @property {ExtractorsByOption&lt;ModuleProfile, StatsProfile&gt;} profile
 * @property {ExtractorsByOption&lt;ModuleGraphConnection, StatsModuleReason&gt;} moduleReason
 * @property {ExtractorsByOption&lt;Chunk, StatsChunk&gt;} chunk
 * @property {ExtractorsByOption&lt;OriginRecord, StatsChunkOrigin&gt;} chunkOrigin
 * @property {ExtractorsByOption&lt;WebpackError, StatsError&gt;} error
 * @property {ExtractorsByOption&lt;WebpackError, StatsError&gt;} warning
 * @property {ExtractorsByOption&lt;WebpackError, StatsError&gt;} cause
 * @property {ExtractorsByOption&lt;ModuleTrace, StatsModuleTraceItem&gt;} moduleTraceItem
 * @property {ExtractorsByOption&lt;Dependency, StatsModuleTraceDependency&gt;} moduleTraceDependency
 */

/**
 * @template T
 * @template I
 * @param {Iterable&lt;T&gt;} items items to select from
 * @param {(item: T) =&gt; Iterable&lt;I&gt;} selector selector function to select values from item
 * @returns {I[]} array of values
 */
const uniqueArray = (items, selector) =&gt; {
	/** @type {Set&lt;I&gt;} */
	const set = new Set();
	for (const item of items) {
		for (const i of selector(item)) {
			set.add(i);
		}
	}
	return Array.from(set);
};

/**
 * @template T
 * @template I
 * @param {Iterable&lt;T&gt;} items items to select from
 * @param {(item: T) =&gt; Iterable&lt;I&gt;} selector selector function to select values from item
 * @param {Comparator&lt;I&gt;} comparator comparator function
 * @returns {I[]} array of values
 */
const uniqueOrderedArray = (items, selector, comparator) =&gt;
	uniqueArray(items, selector).sort(comparator);

/** @template T @template R @typedef {{ [P in keyof T]: R }} MappedValues&lt;T, R&gt; */

/**
 * @template {object} T
 * @template {object} R
 * @param {T} obj object to be mapped
 * @param {function(T[keyof T], keyof T): R} fn mapping function
 * @returns {MappedValues&lt;T, R&gt;} mapped object
 */
const mapObject = (obj, fn) =&gt; {
	const newObj = Object.create(null);
	for (const key of Object.keys(obj)) {
		newObj[key] = fn(
			obj[/** @type {keyof T} */ (key)],
			/** @type {keyof T} */ (key)
		);
	}
	return newObj;
};

/**
 * @template T
 * @param {Compilation} compilation the compilation
 * @param {(compilation: Compilation, name: string) =&gt; T[]} getItems get items
 * @returns {number} total number
 */
const countWithChildren = (compilation, getItems) =&gt; {
	let count = getItems(compilation, &quot;&quot;).length;
	for (const child of compilation.children) {
		count += countWithChildren(child, (c, type) =&gt;
			getItems(c, `.children[].compilation${type}`)
		);
	}
	return count;
};

/** @typedef {Error &amp; { cause?: unknown }} ErrorWithCause */
/** @typedef {Error &amp; { errors: EXPECTED_ANY[] }} AggregateError */

/** @type {ExtractorsByOption&lt;string | ErrorWithCause | AggregateError | WebpackError, StatsError&gt;} */
const EXTRACT_ERROR = {
	_: (object, error, context, { requestShortener }) =&gt; {
		// TODO webpack 6 disallow strings in the errors/warnings list
		if (typeof error === &quot;string&quot;) {
			object.message = error;
		} else {
			if (/** @type {WebpackError} */ (error).chunk) {
				const chunk = /** @type {WebpackError} */ (error).chunk;
				object.chunkName =
					/** @type {string | undefined} */
					(chunk.name);
				object.chunkEntry = chunk.hasRuntime();
				object.chunkInitial = chunk.canBeInitial();
			}

			if (/** @type {WebpackError} */ (error).file) {
				object.file = /** @type {WebpackError} */ (error).file;
			}

			if (/** @type {WebpackError} */ (error).module) {
				object.moduleIdentifier =
					/** @type {WebpackError} */
					(error).module.identifier();
				object.moduleName =
					/** @type {WebpackError} */
					(error).module.readableIdentifier(requestShortener);
			}

			if (/** @type {WebpackError} */ (error).loc) {
				object.loc = formatLocation(/** @type {WebpackError} */ (error).loc);
			}

			object.message = error.message;
		}
	},
	ids: (object, error, { compilation: { chunkGraph } }) =&gt; {
		if (typeof error !== &quot;string&quot;) {
			if (/** @type {WebpackError} */ (error).chunk) {
				object.chunkId = /** @type {ChunkId} */ (
					/** @type {WebpackError} */
					(error).chunk.id
				);
			}

			if (/** @type {WebpackError} */ (error).module) {
				object.moduleId =
					/** @type {ModuleId} */
					(chunkGraph.getModuleId(/** @type {WebpackError} */ (error).module));
			}
		}
	},
	moduleTrace: (object, error, context, options, factory) =&gt; {
		if (
			typeof error !== &quot;string&quot; &amp;&amp;
			/** @type {WebpackError} */ (error).module
		) {
			const {
				type,
				compilation: { moduleGraph }
			} = context;
			/** @type {Set&lt;Module&gt;} */
			const visitedModules = new Set();
			/** @type {ModuleTrace[]} */
			const moduleTrace = [];
			let current = /** @type {WebpackError} */ (error).module;
			while (current) {
				if (visitedModules.has(current)) break; // circular (technically impossible, but how knows)
				visitedModules.add(current);
				const origin = moduleGraph.getIssuer(current);
				if (!origin) break;
				moduleTrace.push({ origin, module: current });
				current = origin;
			}
			object.moduleTrace = factory.create(
				`${type}.moduleTrace`,
				moduleTrace,
				context
			);
		}
	},
	errorDetails: (
		object,
		error,
		{ type, compilation, cachedGetErrors, cachedGetWarnings },
		{ errorDetails }
	) =&gt; {
		if (
			typeof error !== &quot;string&quot; &amp;&amp;
			(errorDetails === true ||
				(type.endsWith(&quot;.error&quot;) &amp;&amp; cachedGetErrors(compilation).length &lt; 3))
		) {
			object.details = /** @type {WebpackError} */ (error).details;
		}
	},
	errorStack: (object, error) =&gt; {
		if (typeof error !== &quot;string&quot;) {
			object.stack = error.stack;
		}
	},
	errorCause: (object, error, context, options, factory) =&gt; {
		if (
			typeof error !== &quot;string&quot; &amp;&amp;
			/** @type {ErrorWithCause} */ (error).cause
		) {
			const rawCause = /** @type {ErrorWithCause} */ (error).cause;
			/** @type {Error} */
			const cause =
				typeof rawCause === &quot;string&quot;
					? /** @type {Error} */ ({ message: rawCause })
					: /** @type {Error} */ (rawCause);
			const { type } = context;

			object.cause = factory.create(`${type}.cause`, cause, context);
		}
	},
	errorErrors: (object, error, context, options, factory) =&gt; {
		if (
			typeof error !== &quot;string&quot; &amp;&amp;
			/** @type {AggregateError} */
			(error).errors
		) {
			const { type } = context;
			object.errors = factory.create(
				`${type}.errors`,
				/** @type {Error[]} */
				(/** @type {AggregateError} */ (error).errors),
				context
			);
		}
	}
};

/** @type {SimpleExtractors} */
const SIMPLE_EXTRACTORS = {
	compilation: {
		_: (object, compilation, context, options) =&gt; {
			if (!context.makePathsRelative) {
				context.makePathsRelative = makePathsRelative.bindContextCache(
					compilation.compiler.context,
					compilation.compiler.root
				);
			}
			if (!context.cachedGetErrors) {
				const map = new WeakMap();
				context.cachedGetErrors = compilation =&gt;
					map.get(compilation) ||
					// eslint-disable-next-line no-sequences
					(errors =&gt; (map.set(compilation, errors), errors))(
						compilation.getErrors()
					);
			}
			if (!context.cachedGetWarnings) {
				const map = new WeakMap();
				context.cachedGetWarnings = compilation =&gt;
					map.get(compilation) ||
					// eslint-disable-next-line no-sequences
					(warnings =&gt; (map.set(compilation, warnings), warnings))(
						compilation.getWarnings()
					);
			}
			if (compilation.name) {
				object.name = compilation.name;
			}
			if (compilation.needAdditionalPass) {
				object.needAdditionalPass = true;
			}

			const { logging, loggingDebug, loggingTrace } = options;
			if (logging || (loggingDebug &amp;&amp; loggingDebug.length &gt; 0)) {
				const util = require(&quot;util&quot;);
				object.logging = {};
				let acceptedTypes;
				let collapsedGroups = false;
				switch (logging) {
					case &quot;error&quot;:
						acceptedTypes = new Set([LogType.error]);
						break;
					case &quot;warn&quot;:
						acceptedTypes = new Set([LogType.error, LogType.warn]);
						break;
					case &quot;info&quot;:
						acceptedTypes = new Set([
							LogType.error,
							LogType.warn,
							LogType.info
						]);
						break;
					case &quot;log&quot;:
						acceptedTypes = new Set([
							LogType.error,
							LogType.warn,
							LogType.info,
							LogType.log,
							LogType.group,
							LogType.groupEnd,
							LogType.groupCollapsed,
							LogType.clear
						]);
						break;
					case &quot;verbose&quot;:
						acceptedTypes = new Set([
							LogType.error,
							LogType.warn,
							LogType.info,
							LogType.log,
							LogType.group,
							LogType.groupEnd,
							LogType.groupCollapsed,
							LogType.profile,
							LogType.profileEnd,
							LogType.time,
							LogType.status,
							LogType.clear
						]);
						collapsedGroups = true;
						break;
					default:
						acceptedTypes = new Set();
						break;
				}
				const cachedMakePathsRelative = makePathsRelative.bindContextCache(
					options.context,
					compilation.compiler.root
				);
				let depthInCollapsedGroup = 0;
				for (const [origin, logEntries] of compilation.logging) {
					const debugMode = loggingDebug.some(fn =&gt; fn(origin));
					if (logging === false &amp;&amp; !debugMode) continue;
					/** @type {KnownStatsLoggingEntry[]} */
					const groupStack = [];
					/** @type {KnownStatsLoggingEntry[]} */
					const rootList = [];
					let currentList = rootList;
					let processedLogEntries = 0;
					for (const entry of logEntries) {
						let type = entry.type;
						if (!debugMode &amp;&amp; !acceptedTypes.has(type)) continue;

						// Expand groups in verbose and debug modes
						if (
							type === LogType.groupCollapsed &amp;&amp;
							(debugMode || collapsedGroups)
						)
							type = LogType.group;

						if (depthInCollapsedGroup === 0) {
							processedLogEntries++;
						}

						if (type === LogType.groupEnd) {
							groupStack.pop();
							currentList =
								groupStack.length &gt; 0
									? /** @type {KnownStatsLoggingEntry[]} */ (
											groupStack[groupStack.length - 1].children
										)
									: rootList;
							if (depthInCollapsedGroup &gt; 0) depthInCollapsedGroup--;
							continue;
						}
						let message;
						if (entry.type === LogType.time) {
							const [label, first, second] =
								/** @type {[string, number, number]} */
								(entry.args);
							message = `${label}: ${first * 1000 + second / 1000000} ms`;
						} else if (entry.args &amp;&amp; entry.args.length &gt; 0) {
							message = util.format(entry.args[0], ...entry.args.slice(1));
						}
						/** @type {KnownStatsLoggingEntry} */
						const newEntry = {
							...entry,
							type,
							message,
							trace: loggingTrace ? entry.trace : undefined,
							children:
								type === LogType.group || type === LogType.groupCollapsed
									? []
									: undefined
						};
						currentList.push(newEntry);
						if (newEntry.children) {
							groupStack.push(newEntry);
							currentList = newEntry.children;
							if (depthInCollapsedGroup &gt; 0) {
								depthInCollapsedGroup++;
							} else if (type === LogType.groupCollapsed) {
								depthInCollapsedGroup = 1;
							}
						}
					}
					let name = cachedMakePathsRelative(origin).replace(/\|/g, &quot; &quot;);
					if (name in object.logging) {
						let i = 1;
						while (`${name}#${i}` in object.logging) {
							i++;
						}
						name = `${name}#${i}`;
					}
					object.logging[name] = {
						entries: rootList,
						filteredEntries: logEntries.length - processedLogEntries,
						debug: debugMode
					};
				}
			}
		},
		hash: (object, compilation) =&gt; {
			object.hash = /** @type {string} */ (compilation.hash);
		},
		version: object =&gt; {
			object.version = require(&quot;../../package.json&quot;).version;
		},
		env: (object, compilation, context, { _env }) =&gt; {
			object.env = _env;
		},
		timings: (object, compilation) =&gt; {
			object.time =
				/** @type {number} */ (compilation.endTime) -
				/** @type {number} */ (compilation.startTime);
		},
		builtAt: (object, compilation) =&gt; {
			object.builtAt = /** @type {number} */ (compilation.endTime);
		},
		publicPath: (object, compilation) =&gt; {
			object.publicPath = compilation.getPath(
				/** @type {TemplatePath} */
				(compilation.outputOptions.publicPath)
			);
		},
		outputPath: (object, compilation) =&gt; {
			object.outputPath = /** @type {string} */ (
				compilation.outputOptions.path
			);
		},
		assets: (object, compilation, context, options, factory) =&gt; {
			const { type } = context;
			/** @type {Map&lt;string, Chunk[]&gt;} */
			const compilationFileToChunks = new Map();
			/** @type {Map&lt;string, Chunk[]&gt;} */
			const compilationAuxiliaryFileToChunks = new Map();
			for (const chunk of compilation.chunks) {
				for (const file of chunk.files) {
					let array = compilationFileToChunks.get(file);
					if (array === undefined) {
						array = [];
						compilationFileToChunks.set(file, array);
					}
					array.push(chunk);
				}
				for (const file of chunk.auxiliaryFiles) {
					let array = compilationAuxiliaryFileToChunks.get(file);
					if (array === undefined) {
						array = [];
						compilationAuxiliaryFileToChunks.set(file, array);
					}
					array.push(chunk);
				}
			}
			/** @type {Map&lt;string, PreprocessedAsset&gt;} */
			const assetMap = new Map();
			/** @type {Set&lt;PreprocessedAsset&gt;} */
			const assets = new Set();
			for (const asset of compilation.getAssets()) {
				/** @type {PreprocessedAsset} */
				const item = {
					...asset,
					type: &quot;asset&quot;,
					related: undefined
				};
				assets.add(item);
				assetMap.set(asset.name, item);
			}
			for (const item of assetMap.values()) {
				const related = item.info.related;
				if (!related) continue;
				for (const type of Object.keys(related)) {
					const relatedEntry = related[type];
					const deps = Array.isArray(relatedEntry)
						? relatedEntry
						: [relatedEntry];
					for (const dep of deps) {
						const depItem = assetMap.get(dep);
						if (!depItem) continue;
						assets.delete(depItem);
						depItem.type = type;
						item.related = item.related || [];
						item.related.push(depItem);
					}
				}
			}

			object.assetsByChunkName = {};
			for (const [file, chunks] of compilationFileToChunks) {
				for (const chunk of chunks) {
					const name = chunk.name;
					if (!name) continue;
					if (
						!Object.prototype.hasOwnProperty.call(
							object.assetsByChunkName,
							name
						)
					) {
						object.assetsByChunkName[name] = [];
					}
					object.assetsByChunkName[name].push(file);
				}
			}

			const groupedAssets = factory.create(
				`${type}.assets`,
				Array.from(assets),
				{
					...context,
					compilationFileToChunks,
					compilationAuxiliaryFileToChunks
				}
			);
			const limited = spaceLimited(
				groupedAssets,
				/** @type {number} */ (options.assetsSpace)
			);
			object.assets = limited.children;
			object.filteredAssets = limited.filteredChildren;
		},
		chunks: (object, compilation, context, options, factory) =&gt; {
			const { type } = context;
			object.chunks = factory.create(
				`${type}.chunks`,
				Array.from(compilation.chunks),
				context
			);
		},
		modules: (object, compilation, context, options, factory) =&gt; {
			const { type } = context;
			const array = Array.from(compilation.modules);
			const groupedModules = factory.create(`${type}.modules`, array, context);
			const limited = spaceLimited(groupedModules, options.modulesSpace);
			object.modules = limited.children;
			object.filteredModules = limited.filteredChildren;
		},
		entrypoints: (
			object,
			compilation,
			context,
			{ entrypoints, chunkGroups, chunkGroupAuxiliary, chunkGroupChildren },
			factory
		) =&gt; {
			const { type } = context;
			/** @type {ChunkGroupInfoWithName[]} */
			const array = Array.from(compilation.entrypoints, ([key, value]) =&gt; ({
				name: key,
				chunkGroup: value
			}));
			if (entrypoints === &quot;auto&quot; &amp;&amp; !chunkGroups) {
				if (array.length &gt; 5) return;
				if (
					!chunkGroupChildren &amp;&amp;
					array.every(({ chunkGroup }) =&gt; {
						if (chunkGroup.chunks.length !== 1) return false;
						const chunk = chunkGroup.chunks[0];
						return (
							chunk.files.size === 1 &amp;&amp;
							(!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0)
						);
					})
				) {
					return;
				}
			}
			object.entrypoints = factory.create(
				`${type}.entrypoints`,
				array,
				context
			);
		},
		chunkGroups: (object, compilation, context, options, factory) =&gt; {
			const { type } = context;
			const array = Array.from(
				compilation.namedChunkGroups,
				([key, value]) =&gt; ({
					name: key,
					chunkGroup: value
				})
			);
			object.namedChunkGroups = factory.create(
				`${type}.namedChunkGroups`,
				array,
				context
			);
		},
		errors: (object, compilation, context, options, factory) =&gt; {
			const { type, cachedGetErrors } = context;
			const rawErrors = cachedGetErrors(compilation);
			const factorizedErrors = factory.create(
				`${type}.errors`,
				cachedGetErrors(compilation),
				context
			);
			let filtered = 0;
			if (options.errorDetails === &quot;auto&quot; &amp;&amp; rawErrors.length &gt;= 3) {
				filtered = rawErrors
					.map(e =&gt; typeof e !== &quot;string&quot; &amp;&amp; e.details)
					.filter(Boolean).length;
			}
			if (
				options.errorDetails === true ||
				!Number.isFinite(options.errorsSpace)
			) {
				object.errors = factorizedErrors;
				if (filtered) object.filteredErrorDetailsCount = filtered;
				return;
			}
			const [errors, filteredBySpace] = errorsSpaceLimit(
				factorizedErrors,
				/** @type {number} */
				(options.errorsSpace)
			);
			object.filteredErrorDetailsCount = filtered + filteredBySpace;
			object.errors = errors;
		},
		errorsCount: (object, compilation, { cachedGetErrors }) =&gt; {
			object.errorsCount = countWithChildren(compilation, c =&gt;
				cachedGetErrors(c)
			);
		},
		warnings: (object, compilation, context, options, factory) =&gt; {
			const { type, cachedGetWarnings } = context;
			const rawWarnings = factory.create(
				`${type}.warnings`,
				cachedGetWarnings(compilation),
				context
			);
			let filtered = 0;
			if (options.errorDetails === &quot;auto&quot;) {
				filtered = cachedGetWarnings(compilation)
					.map(e =&gt; typeof e !== &quot;string&quot; &amp;&amp; e.details)
					.filter(Boolean).length;
			}
			if (
				options.errorDetails === true ||
				!Number.isFinite(options.warningsSpace)
			) {
				object.warnings = rawWarnings;
				if (filtered) object.filteredWarningDetailsCount = filtered;
				return;
			}
			const [warnings, filteredBySpace] = errorsSpaceLimit(
				rawWarnings,
				/** @type {number} */
				(options.warningsSpace)
			);
			object.filteredWarningDetailsCount = filtered + filteredBySpace;
			object.warnings = warnings;
		},
		warningsCount: (
			object,
			compilation,
			context,
			{ warningsFilter },
			factory
		) =&gt; {
			const { type, cachedGetWarnings } = context;
			object.warningsCount = countWithChildren(compilation, (c, childType) =&gt; {
				if (
					!warningsFilter &amp;&amp;
					/** @type {KnownNormalizedStatsOptions[&quot;warningsFilter&quot;]} */
					(warningsFilter).length === 0
				)
					// Type is wrong, because we don&#039;t need the real value for counting
					return /** @type {EXPECTED_ANY[]} */ (cachedGetWarnings(c));
				return factory
					.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context)
					.filter(
						/**
						 * @param {StatsError} warning warning
						 * @returns {boolean} result
						 */
						warning =&gt; {
							const warningString = Object.keys(warning)
								.map(
									key =&gt;
										`${warning[/** @type {keyof KnownStatsError} */ (key)]}`
								)
								.join(&quot;\n&quot;);
							return !warningsFilter.some(filter =&gt;
								filter(warning, warningString)
							);
						}
					);
			});
		},
		children: (object, compilation, context, options, factory) =&gt; {
			const { type } = context;
			object.children = factory.create(
				`${type}.children`,
				compilation.children,
				context
			);
		}
	},
	asset: {
		_: (object, asset, context, options, factory) =&gt; {
			const { compilation } = context;
			object.type = asset.type;
			object.name = asset.name;
			object.size = asset.source.size();
			object.emitted = compilation.emittedAssets.has(asset.name);
			object.comparedForEmit = compilation.comparedForEmitAssets.has(
				asset.name
			);
			const cached = !object.emitted &amp;&amp; !object.comparedForEmit;
			object.cached = cached;
			object.info = asset.info;
			if (!cached || options.cachedAssets) {
				Object.assign(
					object,
					factory.create(`${context.type}$visible`, asset, context)
				);
			}
		}
	},
	asset$visible: {
		_: (
			object,
			asset,
			{ compilation, compilationFileToChunks, compilationAuxiliaryFileToChunks }
		) =&gt; {
			const chunks = compilationFileToChunks.get(asset.name) || [];
			const auxiliaryChunks =
				compilationAuxiliaryFileToChunks.get(asset.name) || [];
			object.chunkNames = uniqueOrderedArray(
				chunks,
				c =&gt; (c.name ? [c.name] : []),
				compareIds
			);
			object.chunkIdHints = uniqueOrderedArray(
				chunks,
				c =&gt; Array.from(c.idNameHints),
				compareIds
			);
			object.auxiliaryChunkNames = uniqueOrderedArray(
				auxiliaryChunks,
				c =&gt; (c.name ? [c.name] : []),
				compareIds
			);
			object.auxiliaryChunkIdHints = uniqueOrderedArray(
				auxiliaryChunks,
				c =&gt; Array.from(c.idNameHints),
				compareIds
			);
			object.filteredRelated = asset.related ? asset.related.length : undefined;
		},
		relatedAssets: (object, asset, context, options, factory) =&gt; {
			const { type } = context;
			object.related = factory.create(
				`${type.slice(0, -8)}.related`,
				asset.related || [],
				context
			);
			object.filteredRelated = asset.related
				? asset.related.length -
					/** @type {StatsAsset[]} */ (object.related).length
				: undefined;
		},
		ids: (
			object,
			asset,
			{ compilationFileToChunks, compilationAuxiliaryFileToChunks }
		) =&gt; {
			const chunks = compilationFileToChunks.get(asset.name) || [];
			const auxiliaryChunks =
				compilationAuxiliaryFileToChunks.get(asset.name) || [];
			object.chunks = uniqueOrderedArray(
				chunks,
				c =&gt; /** @type {ChunkId[]} */ (c.ids),
				compareIds
			);
			object.auxiliaryChunks = uniqueOrderedArray(
				auxiliaryChunks,
				c =&gt; /** @type {ChunkId[]} */ (c.ids),
				compareIds
			);
		},
		performance: (object, asset) =&gt; {
			object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);
		}
	},
	chunkGroup: {
		_: (
			object,
			{ name, chunkGroup },
			{ compilation, compilation: { moduleGraph, chunkGraph } },
			{ ids, chunkGroupAuxiliary, chunkGroupChildren, chunkGroupMaxAssets }
		) =&gt; {
			const children =
				chunkGroupChildren &amp;&amp;
				chunkGroup.getChildrenByOrders(moduleGraph, chunkGraph);
			/**
			 * @param {string} name Name
			 * @returns {{ name: string, size: number }} Asset object
			 */
			const toAsset = name =&gt; {
				const asset = compilation.getAsset(name);
				return {
					name,
					size: /** @type {number} */ (asset ? asset.info.size : -1)
				};
			};
			/** @type {(total: number, asset: { size: number }) =&gt; number} */
			const sizeReducer = (total, { size }) =&gt; total + size;
			const assets = uniqueArray(chunkGroup.chunks, c =&gt; c.files).map(toAsset);
			const auxiliaryAssets = uniqueOrderedArray(
				chunkGroup.chunks,
				c =&gt; c.auxiliaryFiles,
				compareIds
			).map(toAsset);
			const assetsSize = assets.reduce(sizeReducer, 0);
			const auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0);
			/** @type {KnownStatsChunkGroup} */
			const statsChunkGroup = {
				name,
				chunks: ids
					? /** @type {ChunkId[]} */ (chunkGroup.chunks.map(c =&gt; c.id))
					: undefined,
				assets: assets.length &lt;= chunkGroupMaxAssets ? assets : undefined,
				filteredAssets:
					assets.length &lt;= chunkGroupMaxAssets ? 0 : assets.length,
				assetsSize,
				auxiliaryAssets:
					chunkGroupAuxiliary &amp;&amp; auxiliaryAssets.length &lt;= chunkGroupMaxAssets
						? auxiliaryAssets
						: undefined,
				filteredAuxiliaryAssets:
					chunkGroupAuxiliary &amp;&amp; auxiliaryAssets.length &lt;= chunkGroupMaxAssets
						? 0
						: auxiliaryAssets.length,
				auxiliaryAssetsSize,
				children: children
					? mapObject(children, groups =&gt;
							groups.map(group =&gt; {
								const assets = uniqueArray(group.chunks, c =&gt; c.files).map(
									toAsset
								);
								const auxiliaryAssets = uniqueOrderedArray(
									group.chunks,
									c =&gt; c.auxiliaryFiles,
									compareIds
								).map(toAsset);

								/** @type {KnownStatsChunkGroup} */
								const childStatsChunkGroup = {
									name: group.name,
									chunks: ids
										? /** @type {ChunkId[]} */
											(group.chunks.map(c =&gt; c.id))
										: undefined,
									assets:
										assets.length &lt;= chunkGroupMaxAssets ? assets : undefined,
									filteredAssets:
										assets.length &lt;= chunkGroupMaxAssets ? 0 : assets.length,
									auxiliaryAssets:
										chunkGroupAuxiliary &amp;&amp;
										auxiliaryAssets.length &lt;= chunkGroupMaxAssets
											? auxiliaryAssets
											: undefined,
									filteredAuxiliaryAssets:
										chunkGroupAuxiliary &amp;&amp;
										auxiliaryAssets.length &lt;= chunkGroupMaxAssets
											? 0
											: auxiliaryAssets.length
								};

								return childStatsChunkGroup;
							})
						)
					: undefined,
				childAssets: children
					? mapObject(children, groups =&gt; {
							/** @type {Set&lt;string&gt;} */
							const set = new Set();
							for (const group of groups) {
								for (const chunk of group.chunks) {
									for (const asset of chunk.files) {
										set.add(asset);
									}
								}
							}
							return Array.from(set);
						})
					: undefined
			};
			Object.assign(object, statsChunkGroup);
		},
		performance: (object, { chunkGroup }) =&gt; {
			object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);
		}
	},
	module: {
		_: (object, module, context, options, factory) =&gt; {
			const { type } = context;
			const compilation = /** @type {Compilation} */ (context.compilation);
			const built = compilation.builtModules.has(module);
			const codeGenerated = compilation.codeGeneratedModules.has(module);
			const buildTimeExecuted =
				compilation.buildTimeExecutedModules.has(module);
			/** @type {{[x: string]: number}} */
			const sizes = {};
			for (const sourceType of module.getSourceTypes()) {
				sizes[sourceType] = module.size(sourceType);
			}
			/** @type {KnownStatsModule} */
			const statsModule = {
				type: &quot;module&quot;,
				moduleType: module.type,
				layer: module.layer,
				size: module.size(),
				sizes,
				built,
				codeGenerated,
				buildTimeExecuted,
				cached: !built &amp;&amp; !codeGenerated
			};
			Object.assign(object, statsModule);
			if (built || codeGenerated || options.cachedModules) {
				Object.assign(
					object,
					factory.create(`${type}$visible`, module, context)
				);
			}
		}
	},
	module$visible: {
		_: (object, module, context, { requestShortener }, factory) =&gt; {
			const { type, rootModules } = context;
			const compilation = /** @type {Compilation} */ (context.compilation);
			const { moduleGraph } = compilation;
			/** @type {ModuleIssuerPath} */
			const path = [];
			const issuer = moduleGraph.getIssuer(module);
			let current = issuer;
			while (current) {
				path.push(current);
				current = moduleGraph.getIssuer(current);
			}
			path.reverse();
			const profile = moduleGraph.getProfile(module);
			const errors = module.getErrors();
			const errorsCount = errors !== undefined ? countIterable(errors) : 0;
			const warnings = module.getWarnings();
			const warningsCount =
				warnings !== undefined ? countIterable(warnings) : 0;
			/** @type {KnownStatsModule} */
			const statsModule = {
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				nameForCondition: module.nameForCondition(),
				index: /** @type {number} */ (moduleGraph.getPreOrderIndex(module)),
				preOrderIndex: /** @type {number} */ (
					moduleGraph.getPreOrderIndex(module)
				),
				index2: /** @type {number} */ (moduleGraph.getPostOrderIndex(module)),
				postOrderIndex: /** @type {number} */ (
					moduleGraph.getPostOrderIndex(module)
				),
				cacheable: /** @type {BuildInfo} */ (module.buildInfo).cacheable,
				optional: module.isOptional(moduleGraph),
				orphan:
					!type.endsWith(&quot;module.modules[].module$visible&quot;) &amp;&amp;
					compilation.chunkGraph.getNumberOfModuleChunks(module) === 0,
				dependent: rootModules ? !rootModules.has(module) : undefined,
				issuer: issuer &amp;&amp; issuer.identifier(),
				issuerName: issuer &amp;&amp; issuer.readableIdentifier(requestShortener),
				issuerPath:
					issuer &amp;&amp;
					/** @type {StatsModuleIssuer[] | undefined} */
					(factory.create(`${type.slice(0, -8)}.issuerPath`, path, context)),
				failed: errorsCount &gt; 0,
				errors: errorsCount,
				warnings: warningsCount
			};
			Object.assign(object, statsModule);
			if (profile) {
				object.profile = factory.create(
					`${type.slice(0, -8)}.profile`,
					profile,
					context
				);
			}
		},
		ids: (object, module, { compilation: { chunkGraph, moduleGraph } }) =&gt; {
			object.id = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));
			const issuer = moduleGraph.getIssuer(module);
			object.issuerId = issuer &amp;&amp; chunkGraph.getModuleId(issuer);
			object.chunks =
				/** @type {ChunkId[]} */
				(
					Array.from(
						chunkGraph.getOrderedModuleChunksIterable(
							module,
							compareChunksById
						),
						chunk =&gt; chunk.id
					)
				);
		},
		moduleAssets: (object, module) =&gt; {
			object.assets = /** @type {BuildInfo} */ (module.buildInfo).assets
				? Object.keys(/** @type {BuildInfo} */ (module.buildInfo).assets)
				: [];
		},
		reasons: (object, module, context, options, factory) =&gt; {
			const {
				type,
				compilation: { moduleGraph }
			} = context;
			const groupsReasons = factory.create(
				`${type.slice(0, -8)}.reasons`,
				Array.from(moduleGraph.getIncomingConnections(module)),
				context
			);
			const limited = spaceLimited(
				groupsReasons,
				/** @type {number} */
				(options.reasonsSpace)
			);
			object.reasons = limited.children;
			object.filteredReasons = limited.filteredChildren;
		},
		usedExports: (
			object,
			module,
			{ runtime, compilation: { moduleGraph } }
		) =&gt; {
			const usedExports = moduleGraph.getUsedExports(module, runtime);
			if (usedExports === null) {
				object.usedExports = null;
			} else if (typeof usedExports === &quot;boolean&quot;) {
				object.usedExports = usedExports;
			} else {
				object.usedExports = Array.from(usedExports);
			}
		},
		providedExports: (object, module, { compilation: { moduleGraph } }) =&gt; {
			const providedExports = moduleGraph.getProvidedExports(module);
			object.providedExports = Array.isArray(providedExports)
				? providedExports
				: null;
		},
		optimizationBailout: (
			object,
			module,
			{ compilation: { moduleGraph } },
			{ requestShortener }
		) =&gt; {
			object.optimizationBailout = moduleGraph
				.getOptimizationBailout(module)
				.map(item =&gt; {
					if (typeof item === &quot;function&quot;) return item(requestShortener);
					return item;
				});
		},
		depth: (object, module, { compilation: { moduleGraph } }) =&gt; {
			object.depth = moduleGraph.getDepth(module);
		},
		nestedModules: (object, module, context, options, factory) =&gt; {
			const { type } = context;
			const innerModules = /** @type {Module &amp; { modules?: Module[] }} */ (
				module
			).modules;
			if (Array.isArray(innerModules)) {
				const groupedModules = factory.create(
					`${type.slice(0, -8)}.modules`,
					innerModules,
					context
				);
				const limited = spaceLimited(
					groupedModules,
					options.nestedModulesSpace
				);
				object.modules = limited.children;
				object.filteredModules = limited.filteredChildren;
			}
		},
		source: (object, module) =&gt; {
			const originalSource = module.originalSource();
			if (originalSource) {
				object.source = originalSource.source();
			}
		}
	},
	profile: {
		_: (object, profile) =&gt; {
			/** @type {KnownStatsProfile} */
			const statsProfile = {
				total:
					profile.factory +
					profile.restoring +
					profile.integration +
					profile.building +
					profile.storing,
				resolving: profile.factory,
				restoring: profile.restoring,
				building: profile.building,
				integration: profile.integration,
				storing: profile.storing,
				additionalResolving: profile.additionalFactories,
				additionalIntegration: profile.additionalIntegration,
				// TODO remove this in webpack 6
				factory: profile.factory,
				// TODO remove this in webpack 6
				dependencies: profile.additionalFactories
			};
			Object.assign(object, statsProfile);
		}
	},
	moduleIssuer: {
		_: (object, module, context, { requestShortener }, factory) =&gt; {
			const { type } = context;
			const compilation = /** @type {Compilation} */ (context.compilation);
			const { moduleGraph } = compilation;
			const profile = moduleGraph.getProfile(module);
			/** @type {Partial&lt;KnownStatsModuleIssuer&gt;} */
			const statsModuleIssuer = {
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener)
			};
			Object.assign(object, statsModuleIssuer);
			if (profile) {
				object.profile = factory.create(`${type}.profile`, profile, context);
			}
		},
		ids: (object, module, { compilation: { chunkGraph } }) =&gt; {
			object.id = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));
		}
	},
	moduleReason: {
		_: (object, reason, { runtime }, { requestShortener }) =&gt; {
			const dep = reason.dependency;
			const moduleDep =
				dep &amp;&amp; dep instanceof ModuleDependency ? dep : undefined;
			/** @type {KnownStatsModuleReason} */
			const statsModuleReason = {
				moduleIdentifier: reason.originModule
					? reason.originModule.identifier()
					: null,
				module: reason.originModule
					? reason.originModule.readableIdentifier(requestShortener)
					: null,
				moduleName: reason.originModule
					? reason.originModule.readableIdentifier(requestShortener)
					: null,
				resolvedModuleIdentifier: reason.resolvedOriginModule
					? reason.resolvedOriginModule.identifier()
					: null,
				resolvedModule: reason.resolvedOriginModule
					? reason.resolvedOriginModule.readableIdentifier(requestShortener)
					: null,
				type: reason.dependency ? reason.dependency.type : null,
				active: reason.isActive(runtime),
				explanation: reason.explanation,
				userRequest: (moduleDep &amp;&amp; moduleDep.userRequest) || null
			};
			Object.assign(object, statsModuleReason);
			if (reason.dependency) {
				const locInfo = formatLocation(reason.dependency.loc);
				if (locInfo) {
					object.loc = locInfo;
				}
			}
		},
		ids: (object, reason, { compilation: { chunkGraph } }) =&gt; {
			object.moduleId = reason.originModule
				? chunkGraph.getModuleId(reason.originModule)
				: null;
			object.resolvedModuleId = reason.resolvedOriginModule
				? chunkGraph.getModuleId(reason.resolvedOriginModule)
				: null;
		}
	},
	chunk: {
		_: (object, chunk, { makePathsRelative, compilation: { chunkGraph } }) =&gt; {
			const childIdByOrder = chunk.getChildIdsByOrders(chunkGraph);

			/** @type {KnownStatsChunk} */
			const statsChunk = {
				rendered: chunk.rendered,
				initial: chunk.canBeInitial(),
				entry: chunk.hasRuntime(),
				recorded: AggressiveSplittingPlugin.wasChunkRecorded(chunk),
				reason: chunk.chunkReason,
				size: chunkGraph.getChunkModulesSize(chunk),
				sizes: chunkGraph.getChunkModulesSizes(chunk),
				names: chunk.name ? [chunk.name] : [],
				idHints: Array.from(chunk.idNameHints),
				runtime:
					chunk.runtime === undefined
						? undefined
						: typeof chunk.runtime === &quot;string&quot;
							? [makePathsRelative(chunk.runtime)]
							: Array.from(chunk.runtime.sort(), makePathsRelative),
				files: Array.from(chunk.files),
				auxiliaryFiles: Array.from(chunk.auxiliaryFiles).sort(compareIds),
				hash: /** @type {string} */ (chunk.renderedHash),
				childrenByOrder: childIdByOrder
			};
			Object.assign(object, statsChunk);
		},
		ids: (object, chunk) =&gt; {
			object.id = /** @type {ChunkId} */ (chunk.id);
		},
		chunkRelations: (object, chunk, { compilation: { chunkGraph } }) =&gt; {
			/** @type {Set&lt;string|number&gt;} */
			const parents = new Set();
			/** @type {Set&lt;string|number&gt;} */
			const children = new Set();
			/** @type {Set&lt;string|number&gt;} */
			const siblings = new Set();

			for (const chunkGroup of chunk.groupsIterable) {
				for (const parentGroup of chunkGroup.parentsIterable) {
					for (const chunk of parentGroup.chunks) {
						parents.add(/** @type {ChunkId} */ (chunk.id));
					}
				}
				for (const childGroup of chunkGroup.childrenIterable) {
					for (const chunk of childGroup.chunks) {
						children.add(/** @type {ChunkId} */ (chunk.id));
					}
				}
				for (const sibling of chunkGroup.chunks) {
					if (sibling !== chunk)
						siblings.add(/** @type {ChunkId} */ (sibling.id));
				}
			}
			object.siblings = Array.from(siblings).sort(compareIds);
			object.parents = Array.from(parents).sort(compareIds);
			object.children = Array.from(children).sort(compareIds);
		},
		chunkModules: (object, chunk, context, options, factory) =&gt; {
			const {
				type,
				compilation: { chunkGraph }
			} = context;
			const array = chunkGraph.getChunkModules(chunk);
			const groupedModules = factory.create(`${type}.modules`, array, {
				...context,
				runtime: chunk.runtime,
				rootModules: new Set(chunkGraph.getChunkRootModules(chunk))
			});
			const limited = spaceLimited(groupedModules, options.chunkModulesSpace);
			object.modules = limited.children;
			object.filteredModules = limited.filteredChildren;
		},
		chunkOrigins: (object, chunk, context, options, factory) =&gt; {
			const {
				type,
				compilation: { chunkGraph }
			} = context;
			/** @type {Set&lt;string&gt;} */
			const originsKeySet = new Set();
			/** @type {OriginRecord[]} */
			const origins = [];
			for (const g of chunk.groupsIterable) {
				origins.push(...g.origins);
			}
			const array = origins.filter(origin =&gt; {
				const key = [
					origin.module ? chunkGraph.getModuleId(origin.module) : undefined,
					formatLocation(origin.loc),
					origin.request
				].join();
				if (originsKeySet.has(key)) return false;
				originsKeySet.add(key);
				return true;
			});
			object.origins = factory.create(`${type}.origins`, array, context);
		}
	},
	chunkOrigin: {
		_: (object, origin, context, { requestShortener }) =&gt; {
			/** @type {KnownStatsChunkOrigin} */
			const statsChunkOrigin = {
				module: origin.module ? origin.module.identifier() : &quot;&quot;,
				moduleIdentifier: origin.module ? origin.module.identifier() : &quot;&quot;,
				moduleName: origin.module
					? origin.module.readableIdentifier(requestShortener)
					: &quot;&quot;,
				loc: formatLocation(origin.loc),
				request: origin.request
			};
			Object.assign(object, statsChunkOrigin);
		},
		ids: (object, origin, { compilation: { chunkGraph } }) =&gt; {
			object.moduleId = origin.module
				? /** @type {ModuleId} */ (chunkGraph.getModuleId(origin.module))
				: undefined;
		}
	},
	error: EXTRACT_ERROR,
	warning: EXTRACT_ERROR,
	cause: EXTRACT_ERROR,
	moduleTraceItem: {
		_: (object, { origin, module }, context, { requestShortener }, factory) =&gt; {
			const {
				type,
				compilation: { moduleGraph }
			} = context;
			object.originIdentifier = origin.identifier();
			object.originName = origin.readableIdentifier(requestShortener);
			object.moduleIdentifier = module.identifier();
			object.moduleName = module.readableIdentifier(requestShortener);
			const dependencies = Array.from(
				moduleGraph.getIncomingConnections(module)
			)
				.filter(c =&gt; c.resolvedOriginModule === origin &amp;&amp; c.dependency)
				.map(c =&gt; c.dependency);
			object.dependencies = factory.create(
				`${type}.dependencies`,
				/** @type {Dependency[]} */
				(Array.from(new Set(dependencies))),
				context
			);
		},
		ids: (object, { origin, module }, { compilation: { chunkGraph } }) =&gt; {
			object.originId =
				/** @type {ModuleId} */
				(chunkGraph.getModuleId(origin));
			object.moduleId =
				/** @type {ModuleId} */
				(chunkGraph.getModuleId(module));
		}
	},
	moduleTraceDependency: {
		_: (object, dependency) =&gt; {
			object.loc = formatLocation(dependency.loc);
		}
	}
};

/** @type {Record&lt;string, Record&lt;string, (thing: ModuleGraphConnection, context: StatsFactoryContext, options: NormalizedStatsOptions, idx: number, i: number) =&gt; boolean | undefined&gt;&gt;} */
const FILTER = {
	&quot;module.reasons&quot;: {
		&quot;!orphanModules&quot;: (reason, { compilation: { chunkGraph } }) =&gt; {
			if (
				reason.originModule &amp;&amp;
				chunkGraph.getNumberOfModuleChunks(reason.originModule) === 0
			) {
				return false;
			}
		}
	}
};

/** @type {Record&lt;string, Record&lt;string, (thing: KnownStatsError, context: StatsFactoryContext, options: NormalizedStatsOptions, idx: number, i: number) =&gt; boolean | undefined&gt;&gt;} */
const FILTER_RESULTS = {
	&quot;compilation.warnings&quot;: {
		warningsFilter: util.deprecate(
			(warning, context, { warningsFilter }) =&gt; {
				const warningString = Object.keys(warning)
					.map(key =&gt; `${warning[/** @type {keyof KnownStatsError} */ (key)]}`)
					.join(&quot;\n&quot;);
				return !warningsFilter.some(filter =&gt; filter(warning, warningString));
			},
			&quot;config.stats.warningsFilter is deprecated in favor of config.ignoreWarnings&quot;,
			&quot;DEP_WEBPACK_STATS_WARNINGS_FILTER&quot;
		)
	}
};

/** @type {Record&lt;string, (comparators: Comparator&lt;Module&gt;[], context: StatsFactoryContext) =&gt; void&gt;} */
const MODULES_SORTER = {
	_: (comparators, { compilation: { moduleGraph } }) =&gt; {
		comparators.push(
			compareSelect(m =&gt; moduleGraph.getDepth(m), compareNumbers),
			compareSelect(m =&gt; moduleGraph.getPreOrderIndex(m), compareNumbers),
			compareSelect(m =&gt; m.identifier(), compareIds)
		);
	}
};

/** @type {Record&lt;string, Record&lt;string, (comparators: Comparator&lt;TODO&gt;[], context: StatsFactoryContext, options: NormalizedStatsOptions) =&gt; void&gt;&gt;} */
const SORTERS = {
	&quot;compilation.chunks&quot;: {
		_: comparators =&gt; {
			comparators.push(compareSelect(c =&gt; c.id, compareIds));
		}
	},
	&quot;compilation.modules&quot;: MODULES_SORTER,
	&quot;chunk.rootModules&quot;: MODULES_SORTER,
	&quot;chunk.modules&quot;: MODULES_SORTER,
	&quot;module.modules&quot;: MODULES_SORTER,
	&quot;module.reasons&quot;: {
		_: (comparators, { compilation: { chunkGraph } }) =&gt; {
			comparators.push(
				compareSelect(x =&gt; x.originModule, compareModulesByIdentifier)
			);
			comparators.push(
				compareSelect(x =&gt; x.resolvedOriginModule, compareModulesByIdentifier)
			);
			comparators.push(
				compareSelect(
					x =&gt; x.dependency,
					concatComparators(
						compareSelect(
							/**
							 * @param {Dependency} x dependency
							 * @returns {DependencyLocation} location
							 */
							x =&gt; x.loc,
							compareLocations
						),
						compareSelect(x =&gt; x.type, compareIds)
					)
				)
			);
		}
	},
	&quot;chunk.origins&quot;: {
		_: (comparators, { compilation: { chunkGraph } }) =&gt; {
			comparators.push(
				compareSelect(
					origin =&gt;
						origin.module ? chunkGraph.getModuleId(origin.module) : undefined,
					compareIds
				),
				compareSelect(origin =&gt; formatLocation(origin.loc), compareIds),
				compareSelect(origin =&gt; origin.request, compareIds)
			);
		}
	}
};

/**
 * @template T
 * @typedef {T &amp; { children?: Children&lt;T&gt;[] | undefined, filteredChildren?: number }} Children
 */

/**
 * @template T
 * @param {Children&lt;T&gt;} item item
 * @returns {number} item size
 */
const getItemSize = item =&gt;
	// Each item takes 1 line
	// + the size of the children
	// + 1 extra line when it has children and filteredChildren
	!item.children
		? 1
		: item.filteredChildren
			? 2 + getTotalSize(item.children)
			: 1 + getTotalSize(item.children);

/**
 * @template T
 * @param {Children&lt;T&gt;[]} children children
 * @returns {number} total size
 */
const getTotalSize = children =&gt; {
	let size = 0;
	for (const child of children) {
		size += getItemSize(child);
	}
	return size;
};

/**
 * @template T
 * @param {Children&lt;T&gt;[]} children children
 * @returns {number} total items
 */
const getTotalItems = children =&gt; {
	let count = 0;
	for (const child of children) {
		if (!child.children &amp;&amp; !child.filteredChildren) {
			count++;
		} else {
			if (child.children) count += getTotalItems(child.children);
			if (child.filteredChildren) count += child.filteredChildren;
		}
	}
	return count;
};

/**
 * @template T
 * @param {Children&lt;T&gt;[]} children children
 * @returns {Children&lt;T&gt;[]} collapsed children
 */
const collapse = children =&gt; {
	// After collapse each child must take exactly one line
	const newChildren = [];
	for (const child of children) {
		if (child.children) {
			let filteredChildren = child.filteredChildren || 0;
			filteredChildren += getTotalItems(child.children);
			newChildren.push({
				...child,
				children: undefined,
				filteredChildren
			});
		} else {
			newChildren.push(child);
		}
	}
	return newChildren;
};

/**
 * @template T
 * @param {Children&lt;T&gt;[]} itemsAndGroups item and groups
 * @param {number} max max
 * @param {boolean=} filteredChildrenLineReserved filtered children line reserved
 * @returns {Children&lt;T&gt;} result
 */
const spaceLimited = (
	itemsAndGroups,
	max,
	filteredChildrenLineReserved = false
) =&gt; {
	if (max &lt; 1) {
		return /** @type {Children&lt;T&gt;} */ ({
			children: undefined,
			filteredChildren: getTotalItems(itemsAndGroups)
		});
	}
	/** @type {Children&lt;T&gt;[] | undefined} */
	let children;
	/** @type {number | undefined} */
	let filteredChildren;
	// This are the groups, which take 1+ lines each
	/** @type {Children&lt;T&gt;[] | undefined} */
	const groups = [];
	// The sizes of the groups are stored in groupSizes
	/** @type {number[]} */
	const groupSizes = [];
	// This are the items, which take 1 line each
	const items = [];
	// The total of group sizes
	let groupsSize = 0;

	for (const itemOrGroup of itemsAndGroups) {
		// is item
		if (!itemOrGroup.children &amp;&amp; !itemOrGroup.filteredChildren) {
			items.push(itemOrGroup);
		} else {
			groups.push(itemOrGroup);
			const size = getItemSize(itemOrGroup);
			groupSizes.push(size);
			groupsSize += size;
		}
	}

	if (groupsSize + items.length &lt;= max) {
		// The total size in the current state fits into the max
		// keep all
		children = groups.length &gt; 0 ? groups.concat(items) : items;
	} else if (groups.length === 0) {
		// slice items to max
		// inner space marks that lines for filteredChildren already reserved
		const limit = max - (filteredChildrenLineReserved ? 0 : 1);
		filteredChildren = items.length - limit;
		items.length = limit;
		children = items;
	} else {
		// limit is the size when all groups are collapsed
		const limit =
			groups.length +
			(filteredChildrenLineReserved || items.length === 0 ? 0 : 1);
		if (limit &lt; max) {
			// calculate how much we are over the size limit
			// this allows to approach the limit faster
			let oversize;
			// If each group would take 1 line the total would be below the maximum
			// collapse some groups, keep items
			while (
				(oversize =
					groupsSize +
					items.length +
					(filteredChildren &amp;&amp; !filteredChildrenLineReserved ? 1 : 0) -
					max) &gt; 0
			) {
				// Find the maximum group and process only this one
				const maxGroupSize = Math.max(...groupSizes);
				if (maxGroupSize &lt; items.length) {
					filteredChildren = items.length;
					items.length = 0;
					continue;
				}
				for (let i = 0; i &lt; groups.length; i++) {
					if (groupSizes[i] === maxGroupSize) {
						const group = groups[i];
						// run this algorithm recursively and limit the size of the children to
						// current size - oversize / number of groups
						// So it should always end up being smaller
						const headerSize = group.filteredChildren ? 2 : 1;
						const limited = spaceLimited(
							/** @type {Children&lt;T&gt;[]} */ (group.children),
							maxGroupSize -
								// we should use ceil to always feet in max
								Math.ceil(oversize / groups.length) -
								// we substitute size of group head
								headerSize,
							headerSize === 2
						);
						groups[i] = {
							...group,
							children: limited.children,
							filteredChildren: limited.filteredChildren
								? (group.filteredChildren || 0) + limited.filteredChildren
								: group.filteredChildren
						};
						const newSize = getItemSize(groups[i]);
						groupsSize -= maxGroupSize - newSize;
						groupSizes[i] = newSize;
						break;
					}
				}
			}
			children = groups.concat(items);
		} else if (limit === max) {
			// If we have only enough space to show one line per group and one line for the filtered items
			// collapse all groups and items
			children = collapse(groups);
			filteredChildren = items.length;
		} else {
			// If we have no space
			// collapse complete group
			filteredChildren = getTotalItems(itemsAndGroups);
		}
	}

	return /** @type {Children&lt;T&gt;} */ ({ children, filteredChildren });
};

/**
 * @param {StatsError[]} errors errors
 * @param {number} max max
 * @returns {[StatsError[], number]} error space limit
 */
const errorsSpaceLimit = (errors, max) =&gt; {
	let filtered = 0;
	// Can not fit into limit
	// print only messages
	if (errors.length + 1 &gt;= max)
		return [
			errors.map(error =&gt; {
				if (typeof error === &quot;string&quot; || !error.details) return error;
				filtered++;
				return { ...error, details: &quot;&quot; };
			}),
			filtered
		];
	let fullLength = errors.length;
	let result = errors;

	let i = 0;
	for (; i &lt; errors.length; i++) {
		const error = errors[i];
		if (typeof error !== &quot;string&quot; &amp;&amp; error.details) {
			const splitted = error.details.split(&quot;\n&quot;);
			const len = splitted.length;
			fullLength += len;
			if (fullLength &gt; max) {
				result = i &gt; 0 ? errors.slice(0, i) : [];
				const overLimit = fullLength - max + 1;
				const error = errors[i++];
				result.push({
					...error,
					details:
						/** @type {string} */
						(error.details).split(&quot;\n&quot;).slice(0, -overLimit).join(&quot;\n&quot;),
					filteredDetails: overLimit
				});
				filtered = errors.length - i;
				for (; i &lt; errors.length; i++) {
					const error = errors[i];
					if (typeof error === &quot;string&quot; || !error.details) result.push(error);
					result.push({ ...error, details: &quot;&quot; });
				}
				break;
			} else if (fullLength === max) {
				result = errors.slice(0, ++i);
				filtered = errors.length - i;
				for (; i &lt; errors.length; i++) {
					const error = errors[i];
					if (typeof error === &quot;string&quot; || !error.details) result.push(error);
					result.push({ ...error, details: &quot;&quot; });
				}
				break;
			}
		}
	}

	return [result, filtered];
};

/**
 * @template {{ size: number }} T
 * @template {{ size: number }} R
 * @param {(R | T)[]} children children
 * @param {T[]} assets assets
 * @returns {{ size: number }} asset size
 */
const assetGroup = (children, assets) =&gt; {
	let size = 0;
	for (const asset of children) {
		size += asset.size;
	}
	return { size };
};

/**
 * @template {{ size: number, sizes: Record&lt;string, number&gt; }} T
 * @param {Children&lt;T&gt;[]} children children
 * @param {KnownStatsModule[]} modules modules
 * @returns {{ size: number, sizes: Record&lt;string, number&gt;}} size and sizes
 */
const moduleGroup = (children, modules) =&gt; {
	let size = 0;
	/** @type {Record&lt;string, number&gt;} */
	const sizes = {};
	for (const module of children) {
		size += module.size;
		for (const key of Object.keys(module.sizes)) {
			sizes[key] = (sizes[key] || 0) + module.sizes[key];
		}
	}
	return {
		size,
		sizes
	};
};

/**
 * @template {{ active: boolean }} T
 * @param {Children&lt;T&gt;[]} children children
 * @param {KnownStatsModuleReason[]} reasons reasons
 * @returns {{ active: boolean }} reason group
 */
const reasonGroup = (children, reasons) =&gt; {
	let active = false;
	for (const reason of children) {
		active = active || reason.active;
	}
	return {
		active
	};
};

const GROUP_EXTENSION_REGEXP = /(\.[^.]+?)(?:\?|(?: \+ \d+ modules?)?$)/;
const GROUP_PATH_REGEXP = /(.+)[/\\][^/\\]+?(?:\?|(?: \+ \d+ modules?)?$)/;

/** @typedef {Record&lt;string, (groupConfigs: GroupConfig&lt;KnownStatsAsset, TODO&gt;[], context: StatsFactoryContext, options: NormalizedStatsOptions) =&gt; void&gt;} AssetsGroupers */

/** @type {AssetsGroupers} */
const ASSETS_GROUPERS = {
	_: (groupConfigs, context, options) =&gt; {
		/**
		 * @param {keyof KnownStatsAsset} name name
		 * @param {boolean=} exclude need exclude?
		 */
		const groupByFlag = (name, exclude) =&gt; {
			groupConfigs.push({
				getKeys: asset =&gt; (asset[name] ? [&quot;1&quot;] : undefined),
				getOptions: () =&gt; ({
					groupChildren: !exclude,
					force: exclude
				}),
				createGroup: (key, children, assets) =&gt;
					exclude
						? {
								type: &quot;assets by status&quot;,
								[name]: Boolean(key),
								filteredChildren: assets.length,
								...assetGroup(children, assets)
							}
						: {
								type: &quot;assets by status&quot;,
								[name]: Boolean(key),
								children,
								...assetGroup(children, assets)
							}
			});
		};
		const {
			groupAssetsByEmitStatus,
			groupAssetsByPath,
			groupAssetsByExtension
		} = options;
		if (groupAssetsByEmitStatus) {
			groupByFlag(&quot;emitted&quot;);
			groupByFlag(&quot;comparedForEmit&quot;);
			groupByFlag(&quot;isOverSizeLimit&quot;);
		}
		if (groupAssetsByEmitStatus || !options.cachedAssets) {
			groupByFlag(&quot;cached&quot;, !options.cachedAssets);
		}
		if (groupAssetsByPath || groupAssetsByExtension) {
			groupConfigs.push({
				getKeys: asset =&gt; {
					const extensionMatch =
						groupAssetsByExtension &amp;&amp; GROUP_EXTENSION_REGEXP.exec(asset.name);
					const extension = extensionMatch ? extensionMatch[1] : &quot;&quot;;
					const pathMatch =
						groupAssetsByPath &amp;&amp; GROUP_PATH_REGEXP.exec(asset.name);
					const path = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
					/** @type {string[]} */
					const keys = [];
					if (groupAssetsByPath) {
						keys.push(&quot;.&quot;);
						if (extension)
							keys.push(
								path.length
									? `${path.join(&quot;/&quot;)}/*${extension}`
									: `*${extension}`
							);
						while (path.length &gt; 0) {
							keys.push(`${path.join(&quot;/&quot;)}/`);
							path.pop();
						}
					} else if (extension) {
						keys.push(`*${extension}`);
					}
					return keys;
				},
				createGroup: (key, children, assets) =&gt; ({
					type: groupAssetsByPath ? &quot;assets by path&quot; : &quot;assets by extension&quot;,
					name: key,
					children,
					...assetGroup(children, assets)
				})
			});
		}
	},
	groupAssetsByInfo: (groupConfigs, context, options) =&gt; {
		/**
		 * @param {string} name name
		 */
		const groupByAssetInfoFlag = name =&gt; {
			groupConfigs.push({
				getKeys: asset =&gt; (asset.info &amp;&amp; asset.info[name] ? [&quot;1&quot;] : undefined),
				createGroup: (key, children, assets) =&gt; ({
					type: &quot;assets by info&quot;,
					info: {
						[name]: Boolean(key)
					},
					children,
					...assetGroup(children, assets)
				})
			});
		};
		groupByAssetInfoFlag(&quot;immutable&quot;);
		groupByAssetInfoFlag(&quot;development&quot;);
		groupByAssetInfoFlag(&quot;hotModuleReplacement&quot;);
	},
	groupAssetsByChunk: (groupConfigs, context, options) =&gt; {
		/**
		 * @param {keyof KnownStatsAsset} name name
		 */
		const groupByNames = name =&gt; {
			groupConfigs.push({
				getKeys: asset =&gt; /** @type {string[]} */ (asset[name]),
				createGroup: (key, children, assets) =&gt; ({
					type: &quot;assets by chunk&quot;,
					[name]: [key],
					children,
					...assetGroup(children, assets)
				})
			});
		};
		groupByNames(&quot;chunkNames&quot;);
		groupByNames(&quot;auxiliaryChunkNames&quot;);
		groupByNames(&quot;chunkIdHints&quot;);
		groupByNames(&quot;auxiliaryChunkIdHints&quot;);
	},
	excludeAssets: (groupConfigs, context, { excludeAssets }) =&gt; {
		groupConfigs.push({
			getKeys: asset =&gt; {
				const ident = asset.name;
				const excluded = excludeAssets.some(fn =&gt; fn(ident, asset));
				if (excluded) return [&quot;excluded&quot;];
			},
			getOptions: () =&gt; ({
				groupChildren: false,
				force: true
			}),
			createGroup: (key, children, assets) =&gt; ({
				type: &quot;hidden assets&quot;,
				filteredChildren: assets.length,
				...assetGroup(children, assets)
			})
		});
	}
};

/** @typedef {Record&lt;string, (groupConfigs: GroupConfig&lt;KnownStatsModule, TODO&gt;[], context: StatsFactoryContext, options: NormalizedStatsOptions) =&gt; void&gt;} ModulesGroupers */

/** @type {(type: ExcludeModulesType) =&gt; ModulesGroupers} */
const MODULES_GROUPERS = type =&gt; ({
	_: (groupConfigs, context, options) =&gt; {
		/**
		 * @param {keyof KnownStatsModule} name name
		 * @param {string} type type
		 * @param {boolean=} exclude need exclude?
		 */
		const groupByFlag = (name, type, exclude) =&gt; {
			groupConfigs.push({
				getKeys: module =&gt; (module[name] ? [&quot;1&quot;] : undefined),
				getOptions: () =&gt; ({
					groupChildren: !exclude,
					force: exclude
				}),
				createGroup: (key, children, modules) =&gt; ({
					type,
					[name]: Boolean(key),
					...(exclude ? { filteredChildren: modules.length } : { children }),
					...moduleGroup(children, modules)
				})
			});
		};
		const {
			groupModulesByCacheStatus,
			groupModulesByLayer,
			groupModulesByAttributes,
			groupModulesByType,
			groupModulesByPath,
			groupModulesByExtension
		} = options;
		if (groupModulesByAttributes) {
			groupByFlag(&quot;errors&quot;, &quot;modules with errors&quot;);
			groupByFlag(&quot;warnings&quot;, &quot;modules with warnings&quot;);
			groupByFlag(&quot;assets&quot;, &quot;modules with assets&quot;);
			groupByFlag(&quot;optional&quot;, &quot;optional modules&quot;);
		}
		if (groupModulesByCacheStatus) {
			groupByFlag(&quot;cacheable&quot;, &quot;cacheable modules&quot;);
			groupByFlag(&quot;built&quot;, &quot;built modules&quot;);
			groupByFlag(&quot;codeGenerated&quot;, &quot;code generated modules&quot;);
		}
		if (groupModulesByCacheStatus || !options.cachedModules) {
			groupByFlag(&quot;cached&quot;, &quot;cached modules&quot;, !options.cachedModules);
		}
		if (groupModulesByAttributes || !options.orphanModules) {
			groupByFlag(&quot;orphan&quot;, &quot;orphan modules&quot;, !options.orphanModules);
		}
		if (groupModulesByAttributes || !options.dependentModules) {
			groupByFlag(&quot;dependent&quot;, &quot;dependent modules&quot;, !options.dependentModules);
		}
		if (groupModulesByType || !options.runtimeModules) {
			groupConfigs.push({
				getKeys: module =&gt; {
					if (!module.moduleType) return;
					if (groupModulesByType) {
						return [module.moduleType.split(&quot;/&quot;, 1)[0]];
					} else if (module.moduleType === WEBPACK_MODULE_TYPE_RUNTIME) {
						return [WEBPACK_MODULE_TYPE_RUNTIME];
					}
				},
				getOptions: key =&gt; {
					const exclude =
						key === WEBPACK_MODULE_TYPE_RUNTIME &amp;&amp; !options.runtimeModules;
					return {
						groupChildren: !exclude,
						force: exclude
					};
				},
				createGroup: (key, children, modules) =&gt; {
					const exclude =
						key === WEBPACK_MODULE_TYPE_RUNTIME &amp;&amp; !options.runtimeModules;
					return {
						type: `${key} modules`,
						moduleType: key,
						...(exclude ? { filteredChildren: modules.length } : { children }),
						...moduleGroup(children, modules)
					};
				}
			});
		}
		if (groupModulesByLayer) {
			groupConfigs.push({
				getKeys: module =&gt; /** @type {string[]} */ ([module.layer]),
				createGroup: (key, children, modules) =&gt; ({
					type: &quot;modules by layer&quot;,
					layer: key,
					children,
					...moduleGroup(children, modules)
				})
			});
		}
		if (groupModulesByPath || groupModulesByExtension) {
			groupConfigs.push({
				getKeys: module =&gt; {
					if (!module.name) return;
					const resource = parseResource(
						/** @type {string} */ (module.name.split(&quot;!&quot;).pop())
					).path;
					const dataUrl = /^data:[^,;]+/.exec(resource);
					if (dataUrl) return [dataUrl[0]];
					const extensionMatch =
						groupModulesByExtension &amp;&amp; GROUP_EXTENSION_REGEXP.exec(resource);
					const extension = extensionMatch ? extensionMatch[1] : &quot;&quot;;
					const pathMatch =
						groupModulesByPath &amp;&amp; GROUP_PATH_REGEXP.exec(resource);
					const path = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
					const keys = [];
					if (groupModulesByPath) {
						if (extension)
							keys.push(
								path.length
									? `${path.join(&quot;/&quot;)}/*${extension}`
									: `*${extension}`
							);
						while (path.length &gt; 0) {
							keys.push(`${path.join(&quot;/&quot;)}/`);
							path.pop();
						}
					} else if (extension) {
						keys.push(`*${extension}`);
					}
					return keys;
				},
				createGroup: (key, children, modules) =&gt; {
					const isDataUrl = key.startsWith(&quot;data:&quot;);
					return {
						type: isDataUrl
							? &quot;modules by mime type&quot;
							: groupModulesByPath
								? &quot;modules by path&quot;
								: &quot;modules by extension&quot;,
						name: isDataUrl ? key.slice(/* &#039;data:&#039;.length */ 5) : key,
						children,
						...moduleGroup(children, modules)
					};
				}
			});
		}
	},
	excludeModules: (groupConfigs, context, { excludeModules }) =&gt; {
		groupConfigs.push({
			getKeys: module =&gt; {
				const name = module.name;
				if (name) {
					const excluded = excludeModules.some(fn =&gt; fn(name, module, type));
					if (excluded) return [&quot;1&quot;];
				}
			},
			getOptions: () =&gt; ({
				groupChildren: false,
				force: true
			}),
			createGroup: (key, children, modules) =&gt; ({
				type: &quot;hidden modules&quot;,
				filteredChildren: children.length,
				...moduleGroup(children, modules)
			})
		});
	}
});

/** @typedef {Record&lt;string, (groupConfigs: GroupConfig&lt;KnownStatsModuleReason, TODO&gt;[], context: StatsFactoryContext, options: NormalizedStatsOptions) =&gt; void&gt;} ModuleReasonsGroupers */

/** @type {ModuleReasonsGroupers} */
const MODULE_REASONS_GROUPERS = {
	groupReasonsByOrigin: groupConfigs =&gt; {
		groupConfigs.push({
			getKeys: reason =&gt; /** @type {string[]} */ ([reason.module]),
			createGroup: (key, children, reasons) =&gt; ({
				type: &quot;from origin&quot;,
				module: key,
				children,
				...reasonGroup(children, reasons)
			})
		});
	}
};

/** @type {Record&lt;string, AssetsGroupers | ModulesGroupers | ModuleReasonsGroupers&gt;} */
const RESULT_GROUPERS = {
	&quot;compilation.assets&quot;: ASSETS_GROUPERS,
	&quot;asset.related&quot;: ASSETS_GROUPERS,
	&quot;compilation.modules&quot;: MODULES_GROUPERS(&quot;module&quot;),
	&quot;chunk.modules&quot;: MODULES_GROUPERS(&quot;chunk&quot;),
	&quot;chunk.rootModules&quot;: MODULES_GROUPERS(&quot;root-of-chunk&quot;),
	&quot;module.modules&quot;: MODULES_GROUPERS(&quot;nested&quot;),
	&quot;module.reasons&quot;: MODULE_REASONS_GROUPERS
};

// remove a prefixed &quot;!&quot; that can be specified to reverse sort order
/**
 * @param {string} field a field name
 * @returns {field} normalized field
 */
const normalizeFieldKey = field =&gt; {
	if (field[0] === &quot;!&quot;) {
		return field.slice(1);
	}
	return field;
};

// if a field is prefixed by a &quot;!&quot; reverse sort order
/**
 * @param {string} field a field name
 * @returns {boolean} result
 */
const sortOrderRegular = field =&gt; {
	if (field[0] === &quot;!&quot;) {
		return false;
	}
	return true;
};

/**
 * @template T
 * @param {string | false} field field name
 * @returns {(a: T, b: T) =&gt; 0 | 1 | -1} comparators
 */
const sortByField = field =&gt; {
	if (!field) {
		/**
		 * @param {T} a first
		 * @param {T} b second
		 * @returns {-1 | 0 | 1} zero
		 */
		const noSort = (a, b) =&gt; 0;
		return noSort;
	}

	const fieldKey = normalizeFieldKey(field);

	let sortFn = compareSelect(m =&gt; m[fieldKey], compareIds);

	// if a field is prefixed with a &quot;!&quot; the sort is reversed!
	const sortIsRegular = sortOrderRegular(field);

	if (!sortIsRegular) {
		const oldSortFn = sortFn;
		sortFn = (a, b) =&gt; oldSortFn(b, a);
	}

	return sortFn;
};

/** @type {Record&lt;string, (comparators: Comparator&lt;Asset&gt;[], context: StatsFactoryContext, options: NormalizedStatsOptions) =&gt; void&gt;} */
const ASSET_SORTERS = {
	assetsSort: (comparators, context, { assetsSort }) =&gt; {
		comparators.push(sortByField(assetsSort));
	},
	_: comparators =&gt; {
		comparators.push(compareSelect(a =&gt; a.name, compareIds));
	}
};

/** @type {Record&lt;string, Record&lt;string, (comparators: Comparator&lt;TODO&gt;[], context: StatsFactoryContext, options: NormalizedStatsOptions) =&gt; void&gt;&gt;} */
const RESULT_SORTERS = {
	&quot;compilation.chunks&quot;: {
		chunksSort: (comparators, context, { chunksSort }) =&gt; {
			comparators.push(sortByField(chunksSort));
		}
	},
	&quot;compilation.modules&quot;: {
		modulesSort: (comparators, context, { modulesSort }) =&gt; {
			comparators.push(sortByField(modulesSort));
		}
	},
	&quot;chunk.modules&quot;: {
		chunkModulesSort: (comparators, context, { chunkModulesSort }) =&gt; {
			comparators.push(sortByField(chunkModulesSort));
		}
	},
	&quot;module.modules&quot;: {
		nestedModulesSort: (comparators, context, { nestedModulesSort }) =&gt; {
			comparators.push(sortByField(nestedModulesSort));
		}
	},
	&quot;compilation.assets&quot;: ASSET_SORTERS,
	&quot;asset.related&quot;: ASSET_SORTERS
};

/**
 * @template T
 * @param {Record&lt;string, Record&lt;string, T&gt;&gt;} config the config see above
 * @param {NormalizedStatsOptions} options stats options
 * @param {(hookFor: string, fn: T) =&gt; void} fn handler function called for every active line in config
 * @returns {void}
 */
const iterateConfig = (config, options, fn) =&gt; {
	for (const hookFor of Object.keys(config)) {
		const subConfig = config[hookFor];
		for (const option of Object.keys(subConfig)) {
			if (option !== &quot;_&quot;) {
				if (option.startsWith(&quot;!&quot;)) {
					if (options[option.slice(1)]) continue;
				} else {
					const value = options[option];
					if (
						value === false ||
						value === undefined ||
						(Array.isArray(value) &amp;&amp; value.length === 0)
					)
						continue;
				}
			}
			fn(hookFor, subConfig[option]);
		}
	}
};

/** @type {Record&lt;string, string&gt;} */
const ITEM_NAMES = {
	&quot;compilation.children[]&quot;: &quot;compilation&quot;,
	&quot;compilation.modules[]&quot;: &quot;module&quot;,
	&quot;compilation.entrypoints[]&quot;: &quot;chunkGroup&quot;,
	&quot;compilation.namedChunkGroups[]&quot;: &quot;chunkGroup&quot;,
	&quot;compilation.errors[]&quot;: &quot;error&quot;,
	&quot;compilation.warnings[]&quot;: &quot;warning&quot;,
	&quot;error.errors[]&quot;: &quot;error&quot;,
	&quot;warning.errors[]&quot;: &quot;error&quot;,
	&quot;chunk.modules[]&quot;: &quot;module&quot;,
	&quot;chunk.rootModules[]&quot;: &quot;module&quot;,
	&quot;chunk.origins[]&quot;: &quot;chunkOrigin&quot;,
	&quot;compilation.chunks[]&quot;: &quot;chunk&quot;,
	&quot;compilation.assets[]&quot;: &quot;asset&quot;,
	&quot;asset.related[]&quot;: &quot;asset&quot;,
	&quot;module.issuerPath[]&quot;: &quot;moduleIssuer&quot;,
	&quot;module.reasons[]&quot;: &quot;moduleReason&quot;,
	&quot;module.modules[]&quot;: &quot;module&quot;,
	&quot;module.children[]&quot;: &quot;module&quot;,
	&quot;moduleTrace[]&quot;: &quot;moduleTraceItem&quot;,
	&quot;moduleTraceItem.dependencies[]&quot;: &quot;moduleTraceDependency&quot;
};

/**
 * @template T
 * @typedef {{ name: T }} NamedObject
 */

/**
 * @template {{ name: string }} T
 * @param {T[]} items items to be merged
 * @returns {NamedObject&lt;T&gt;} an object
 */
const mergeToObject = items =&gt; {
	const obj = Object.create(null);
	for (const item of items) {
		obj[item.name] = item;
	}
	return obj;
};

/**
 * @template {{ name: string }} T
 * @type {Record&lt;string, (items: T[]) =&gt; NamedObject&lt;T&gt;&gt;}
 */
const MERGER = {
	&quot;compilation.entrypoints&quot;: mergeToObject,
	&quot;compilation.namedChunkGroups&quot;: mergeToObject
};

const PLUGIN_NAME = &quot;DefaultStatsFactoryPlugin&quot;;

class DefaultStatsFactoryPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation =&gt; {
			compilation.hooks.statsFactory.tap(
				PLUGIN_NAME,
				/**
				 * @param {StatsFactory} stats stats factory
				 * @param {NormalizedStatsOptions} options stats options
				 */
				(stats, options) =&gt; {
					iterateConfig(
						/** @type {TODO} */
						(SIMPLE_EXTRACTORS),
						options,
						(hookFor, fn) =&gt; {
							stats.hooks.extract
								.for(hookFor)
								.tap(PLUGIN_NAME, (obj, data, ctx) =&gt;
									fn(obj, data, ctx, options, stats)
								);
						}
					);
					iterateConfig(FILTER, options, (hookFor, fn) =&gt; {
						stats.hooks.filter
							.for(hookFor)
							.tap(PLUGIN_NAME, (item, ctx, idx, i) =&gt;
								fn(item, ctx, options, idx, i)
							);
					});
					iterateConfig(FILTER_RESULTS, options, (hookFor, fn) =&gt; {
						stats.hooks.filterResults
							.for(hookFor)
							.tap(PLUGIN_NAME, (item, ctx, idx, i) =&gt;
								fn(item, ctx, options, idx, i)
							);
					});
					iterateConfig(SORTERS, options, (hookFor, fn) =&gt; {
						stats.hooks.sort
							.for(hookFor)
							.tap(PLUGIN_NAME, (comparators, ctx) =&gt;
								fn(comparators, ctx, options)
							);
					});
					iterateConfig(RESULT_SORTERS, options, (hookFor, fn) =&gt; {
						stats.hooks.sortResults
							.for(hookFor)
							.tap(PLUGIN_NAME, (comparators, ctx) =&gt;
								fn(comparators, ctx, options)
							);
					});
					iterateConfig(
						/** @type {TODO} */
						(RESULT_GROUPERS),
						options,
						(hookFor, fn) =&gt; {
							stats.hooks.groupResults
								.for(hookFor)
								.tap(PLUGIN_NAME, (groupConfigs, ctx) =&gt;
									fn(groupConfigs, ctx, options)
								);
						}
					);
					for (const key of Object.keys(ITEM_NAMES)) {
						const itemName = ITEM_NAMES[key];
						stats.hooks.getItemName.for(key).tap(PLUGIN_NAME, () =&gt; itemName);
					}
					for (const key of Object.keys(MERGER)) {
						const merger = MERGER[key];
						stats.hooks.merge.for(key).tap(PLUGIN_NAME, merger);
					}
					if (options.children) {
						if (Array.isArray(options.children)) {
							stats.hooks.getItemFactory
								.for(&quot;compilation.children[].compilation&quot;)
								.tap(
									PLUGIN_NAME,
									/**
									 * @param {Compilation} comp compilation
									 * @param {StatsFactoryContext} options options
									 * @returns {StatsFactory | undefined} stats factory
									 */
									(comp, { _index: idx }) =&gt; {
										const children =
											/** @type {TODO} */
											(options.children);
										if (idx &lt; children.length) {
											return compilation.createStatsFactory(
												compilation.createStatsOptions(children[idx])
											);
										}
									}
								);
						} else if (options.children !== true) {
							const childFactory = compilation.createStatsFactory(
								compilation.createStatsOptions(options.children)
							);
							stats.hooks.getItemFactory
								.for(&quot;compilation.children[].compilation&quot;)
								.tap(PLUGIN_NAME, () =&gt; childFactory);
						}
					}
				}
			);
		});
	}
}
module.exports = DefaultStatsFactoryPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
