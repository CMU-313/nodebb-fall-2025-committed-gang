<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/optimize/InnerGraphPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/optimize/InnerGraphPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">457</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">68.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_ESM
} = require(&quot;../ModuleTypeConstants&quot;);
const PureExpressionDependency = require(&quot;../dependencies/PureExpressionDependency&quot;);
const InnerGraph = require(&quot;./InnerGraph&quot;);

/** @typedef {import(&quot;estree&quot;).ClassDeclaration} ClassDeclaration */
/** @typedef {import(&quot;estree&quot;).ClassExpression} ClassExpression */
/** @typedef {import(&quot;estree&quot;).Expression} Expression */
/** @typedef {import(&quot;estree&quot;).MaybeNamedClassDeclaration} MaybeNamedClassDeclaration */
/** @typedef {import(&quot;estree&quot;).MaybeNamedFunctionDeclaration} MaybeNamedFunctionDeclaration */
/** @typedef {import(&quot;estree&quot;).Node} Node */
/** @typedef {import(&quot;estree&quot;).VariableDeclarator} VariableDeclarator */
/** @typedef {import(&quot;../../declarations/WebpackOptions&quot;).JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../Dependency&quot;)} Dependency */
/** @typedef {import(&quot;../Dependency&quot;).DependencyLocation} DependencyLocation */
/** @typedef {import(&quot;../dependencies/HarmonyImportSpecifierDependency&quot;)} HarmonyImportSpecifierDependency */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;)} JavascriptParser */
/** @typedef {import(&quot;../javascript/JavascriptParser&quot;).Range} Range */
/** @typedef {import(&quot;./InnerGraph&quot;).InnerGraph} InnerGraph */
/** @typedef {import(&quot;./InnerGraph&quot;).TopLevelSymbol} TopLevelSymbol */

const { topLevelSymbolTag } = InnerGraph;

const PLUGIN_NAME = &quot;InnerGraphPlugin&quot;;

class InnerGraphPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory }) =&gt; {
				const logger = compilation.getLogger(&quot;webpack.InnerGraphPlugin&quot;);

				compilation.dependencyTemplates.set(
					PureExpressionDependency,
					new PureExpressionDependency.Template()
				);

				/**
				 * @param {JavascriptParser} parser the parser
				 * @param {JavascriptParserOptions} parserOptions options
				 * @returns {void}
				 */
				const handler = (parser, parserOptions) =&gt; {
					/**
					 * @param {Expression} sup sup
					 */
					const onUsageSuper = sup =&gt; {
						InnerGraph.onUsage(parser.state, usedByExports =&gt; {
							switch (usedByExports) {
								case undefined:
								case true:
									return;
								default: {
									const dep = new PureExpressionDependency(
										/** @type {Range} */
										(sup.range)
									);
									dep.loc = /** @type {DependencyLocation} */ (sup.loc);
									dep.usedByExports = usedByExports;
									parser.state.module.addDependency(dep);
									break;
								}
							}
						});
					};

					parser.hooks.program.tap(PLUGIN_NAME, () =&gt; {
						InnerGraph.enable(parser.state);
					});

					parser.hooks.finish.tap(PLUGIN_NAME, () =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;

						logger.time(&quot;infer dependency usage&quot;);
						InnerGraph.inferDependencyUsage(parser.state);
						logger.timeAggregate(&quot;infer dependency usage&quot;);
					});

					// During prewalking the following datastructures are filled with
					// nodes that have a TopLevelSymbol assigned and
					// variables are tagged with the assigned TopLevelSymbol

					// We differ 3 types of nodes:
					// 1. full statements (export default, function declaration)
					// 2. classes (class declaration, class expression)
					// 3. variable declarators (const x = ...)

					/** @type {WeakMap&lt;Node | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration, TopLevelSymbol&gt;} */
					const statementWithTopLevelSymbol = new WeakMap();
					/** @type {WeakMap&lt;Node | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration, Node&gt;} */
					const statementPurePart = new WeakMap();

					/** @type {WeakMap&lt;ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration, TopLevelSymbol&gt;} */
					const classWithTopLevelSymbol = new WeakMap();

					/** @type {WeakMap&lt;VariableDeclarator, TopLevelSymbol&gt;} */
					const declWithTopLevelSymbol = new WeakMap();
					/** @type {WeakSet&lt;VariableDeclarator&gt;} */
					const pureDeclarators = new WeakSet();

					// The following hooks are used during prewalking:

					parser.hooks.preStatement.tap(PLUGIN_NAME, statement =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;

						if (
							parser.scope.topLevelScope === true &amp;&amp;
							statement.type === &quot;FunctionDeclaration&quot;
						) {
							const name = statement.id ? statement.id.name : &quot;*default*&quot;;
							const fn =
								/** @type {TopLevelSymbol} */
								(InnerGraph.tagTopLevelSymbol(parser, name));
							statementWithTopLevelSymbol.set(statement, fn);
							return true;
						}
					});

					parser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;

						if (parser.scope.topLevelScope === true) {
							if (
								statement.type === &quot;ClassDeclaration&quot; &amp;&amp;
								parser.isPure(
									statement,
									/** @type {Range} */ (statement.range)[0]
								)
							) {
								const name = statement.id ? statement.id.name : &quot;*default*&quot;;
								const fn = /** @type {TopLevelSymbol} */ (
									InnerGraph.tagTopLevelSymbol(parser, name)
								);
								classWithTopLevelSymbol.set(statement, fn);
								return true;
							}
							if (statement.type === &quot;ExportDefaultDeclaration&quot;) {
								const name = &quot;*default*&quot;;
								const fn =
									/** @type {TopLevelSymbol} */
									(InnerGraph.tagTopLevelSymbol(parser, name));
								const decl = statement.declaration;
								if (
									(decl.type === &quot;ClassExpression&quot; ||
										decl.type === &quot;ClassDeclaration&quot;) &amp;&amp;
									parser.isPure(
										/** @type {ClassExpression | ClassDeclaration} */
										(decl),
										/** @type {Range} */
										(decl.range)[0]
									)
								) {
									classWithTopLevelSymbol.set(
										/** @type {ClassExpression | ClassDeclaration} */
										(decl),
										fn
									);
								} else if (
									parser.isPure(
										/** @type {Expression} */
										(decl),
										/** @type {Range} */
										(statement.range)[0]
									)
								) {
									statementWithTopLevelSymbol.set(statement, fn);
									if (
										!decl.type.endsWith(&quot;FunctionExpression&quot;) &amp;&amp;
										!decl.type.endsWith(&quot;Declaration&quot;) &amp;&amp;
										decl.type !== &quot;Literal&quot;
									) {
										statementPurePart.set(
											statement,
											/** @type {Expression} */
											(decl)
										);
									}
								}
							}
						}
					});

					parser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;
						if (
							parser.scope.topLevelScope === true &amp;&amp;
							decl.init &amp;&amp;
							decl.id.type === &quot;Identifier&quot;
						) {
							const name = decl.id.name;
							if (
								decl.init.type === &quot;ClassExpression&quot; &amp;&amp;
								parser.isPure(
									decl.init,
									/** @type {Range} */ (decl.id.range)[1]
								)
							) {
								const fn =
									/** @type {TopLevelSymbol} */
									(InnerGraph.tagTopLevelSymbol(parser, name));
								classWithTopLevelSymbol.set(decl.init, fn);
							} else if (
								parser.isPure(
									decl.init,
									/** @type {Range} */ (decl.id.range)[1]
								)
							) {
								const fn =
									/** @type {TopLevelSymbol} */
									(InnerGraph.tagTopLevelSymbol(parser, name));
								declWithTopLevelSymbol.set(decl, fn);
								if (
									!decl.init.type.endsWith(&quot;FunctionExpression&quot;) &amp;&amp;
									decl.init.type !== &quot;Literal&quot;
								) {
									pureDeclarators.add(decl);
								}
							}
						}
					});

					// During real walking we set the TopLevelSymbol state to the assigned
					// TopLevelSymbol by using the fill datastructures.

					// In addition to tracking TopLevelSymbols, we sometimes need to
					// add a PureExpressionDependency. This is needed to skip execution
					// of pure expressions, even when they are not dropped due to
					// minimizing. Otherwise symbols used there might not exist anymore
					// as they are removed as unused by this optimization

					// When we find a reference to a TopLevelSymbol, we register a
					// TopLevelSymbol dependency from TopLevelSymbol in state to the
					// referenced TopLevelSymbol. This way we get a graph of all
					// TopLevelSymbols.

					// The following hooks are called during walking:

					parser.hooks.statement.tap(PLUGIN_NAME, statement =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;
						if (parser.scope.topLevelScope === true) {
							InnerGraph.setTopLevelSymbol(parser.state, undefined);

							const fn = statementWithTopLevelSymbol.get(statement);
							if (fn) {
								InnerGraph.setTopLevelSymbol(parser.state, fn);
								const purePart = statementPurePart.get(statement);
								if (purePart) {
									InnerGraph.onUsage(parser.state, usedByExports =&gt; {
										switch (usedByExports) {
											case undefined:
											case true:
												return;
											default: {
												const dep = new PureExpressionDependency(
													/** @type {Range} */ (purePart.range)
												);
												dep.loc =
													/** @type {DependencyLocation} */
													(statement.loc);
												dep.usedByExports = usedByExports;
												parser.state.module.addDependency(dep);
												break;
											}
										}
									});
								}
							}
						}
					});

					parser.hooks.classExtendsExpression.tap(
						PLUGIN_NAME,
						(expr, statement) =&gt; {
							if (!InnerGraph.isEnabled(parser.state)) return;
							if (parser.scope.topLevelScope === true) {
								const fn = classWithTopLevelSymbol.get(statement);
								if (
									fn &amp;&amp;
									parser.isPure(
										expr,
										statement.id
											? /** @type {Range} */ (statement.id.range)[1]
											: /** @type {Range} */ (statement.range)[0]
									)
								) {
									InnerGraph.setTopLevelSymbol(parser.state, fn);
									onUsageSuper(expr);
								}
							}
						}
					);

					parser.hooks.classBodyElement.tap(
						PLUGIN_NAME,
						(element, classDefinition) =&gt; {
							if (!InnerGraph.isEnabled(parser.state)) return;
							if (parser.scope.topLevelScope === true) {
								const fn = classWithTopLevelSymbol.get(classDefinition);
								if (fn) {
									InnerGraph.setTopLevelSymbol(parser.state, undefined);
								}
							}
						}
					);

					parser.hooks.classBodyValue.tap(
						PLUGIN_NAME,
						(expression, element, classDefinition) =&gt; {
							if (!InnerGraph.isEnabled(parser.state)) return;
							if (parser.scope.topLevelScope === true) {
								const fn = classWithTopLevelSymbol.get(classDefinition);
								if (fn) {
									if (
										!element.static ||
										parser.isPure(
											expression,
											element.key
												? /** @type {Range} */ (element.key.range)[1]
												: /** @type {Range} */ (element.range)[0]
										)
									) {
										InnerGraph.setTopLevelSymbol(parser.state, fn);
										if (element.type !== &quot;MethodDefinition&quot; &amp;&amp; element.static) {
											InnerGraph.onUsage(parser.state, usedByExports =&gt; {
												switch (usedByExports) {
													case undefined:
													case true:
														return;
													default: {
														const dep = new PureExpressionDependency(
															/** @type {Range} */ (expression.range)
														);
														dep.loc =
															/** @type {DependencyLocation} */
															(expression.loc);
														dep.usedByExports = usedByExports;
														parser.state.module.addDependency(dep);
														break;
													}
												}
											});
										}
									} else {
										InnerGraph.setTopLevelSymbol(parser.state, undefined);
									}
								}
							}
						}
					);

					parser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;
						const fn = declWithTopLevelSymbol.get(decl);

						if (fn) {
							InnerGraph.setTopLevelSymbol(parser.state, fn);
							if (pureDeclarators.has(decl)) {
								if (
									/** @type {ClassExpression} */
									(decl.init).type === &quot;ClassExpression&quot;
								) {
									if (decl.init.superClass) {
										onUsageSuper(decl.init.superClass);
									}
								} else {
									InnerGraph.onUsage(parser.state, usedByExports =&gt; {
										switch (usedByExports) {
											case undefined:
											case true:
												return;
											default: {
												const dep = new PureExpressionDependency(
													/** @type {Range} */ (
														/** @type {ClassExpression} */
														(decl.init).range
													)
												);
												dep.loc = /** @type {DependencyLocation} */ (decl.loc);
												dep.usedByExports = usedByExports;
												parser.state.module.addDependency(dep);
												break;
											}
										}
									});
								}
							}
							parser.walkExpression(
								/** @type {NonNullable&lt;VariableDeclarator[&quot;init&quot;]&gt;} */ (
									decl.init
								)
							);
							InnerGraph.setTopLevelSymbol(parser.state, undefined);
							return true;
						} else if (
							decl.id.type === &quot;Identifier&quot; &amp;&amp;
							decl.init &amp;&amp;
							decl.init.type === &quot;ClassExpression&quot; &amp;&amp;
							classWithTopLevelSymbol.has(decl.init)
						) {
							parser.walkExpression(decl.init);
							InnerGraph.setTopLevelSymbol(parser.state, undefined);
							return true;
						}
					});

					parser.hooks.expression
						.for(topLevelSymbolTag)
						.tap(PLUGIN_NAME, () =&gt; {
							const topLevelSymbol = /** @type {TopLevelSymbol} */ (
								parser.currentTagData
							);
							const currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(
								parser.state
							);
							InnerGraph.addUsage(
								parser.state,
								topLevelSymbol,
								currentTopLevelSymbol || true
							);
						});
					parser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr =&gt; {
						if (!InnerGraph.isEnabled(parser.state)) return;
						if (expr.operator === &quot;=&quot;) return true;
					});
				};
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, handler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_ESM)
					.tap(PLUGIN_NAME, handler);

				compilation.hooks.finishModules.tap(PLUGIN_NAME, () =&gt; {
					logger.timeAggregateEnd(&quot;infer dependency usage&quot;);
				});
			}
		);
	}
}

module.exports = InnerGraphPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
