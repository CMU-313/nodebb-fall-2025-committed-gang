<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jquery-ui/ui/widgets/spinner.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jquery-ui/ui/widgets/spinner.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">560</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * jQuery UI Spinner 1.14.1
 * https://jqueryui.com
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license.
 * https://jquery.org/license
 */

//&gt;&gt;label: Spinner
//&gt;&gt;group: Widgets
//&gt;&gt;description: Displays buttons to easily input numbers via the keyboard or mouse.
//&gt;&gt;docs: https://api.jqueryui.com/spinner/
//&gt;&gt;demos: https://jqueryui.com/spinner/
//&gt;&gt;css.structure: ../../themes/base/core.css
//&gt;&gt;css.structure: ../../themes/base/spinner.css
//&gt;&gt;css.theme: ../../themes/base/theme.css

( function( factory ) {
	&quot;use strict&quot;;

	if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {

		// AMD. Register as an anonymous module.
		define( [
			&quot;jquery&quot;,
			&quot;./button&quot;,
			&quot;../version&quot;,
			&quot;../keycode&quot;,
			&quot;../widget&quot;
		], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
} )( function( $ ) {
&quot;use strict&quot;;

function spinnerModifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( &quot;change&quot; );
		}
	};
}

$.widget( &quot;ui.spinner&quot;, {
	version: &quot;1.14.1&quot;,
	defaultElement: &quot;&lt;input&gt;&quot;,
	widgetEventPrefix: &quot;spin&quot;,
	options: {
		classes: {
			&quot;ui-spinner&quot;: &quot;ui-corner-all&quot;,
			&quot;ui-spinner-down&quot;: &quot;ui-corner-br&quot;,
			&quot;ui-spinner-up&quot;: &quot;ui-corner-tr&quot;
		},
		culture: null,
		icons: {
			down: &quot;ui-icon-triangle-1-s&quot;,
			up: &quot;ui-icon-triangle-1-n&quot;
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {

		// handle string values that need to be parsed
		this._setOption( &quot;max&quot;, this.options.max );
		this._setOption( &quot;min&quot;, this.options.min );
		this._setOption( &quot;step&quot;, this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== &quot;&quot; ) {

			// Format the value, but don&#039;t constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( &quot;autocomplete&quot; );
			}
		} );
	},

	_getCreateOptions: function() {
		var options = this._super();
		var element = this.element;

		$.each( [ &quot;min&quot;, &quot;max&quot;, &quot;step&quot; ], function( i, option ) {
			var value = element.attr( option );
			if ( value != null &amp;&amp; value.length ) {
				options[ option ] = value;
			}
		} );

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) &amp;&amp; this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: &quot;_stop&quot;,
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( &quot;change&quot;, event );
			}
		},
		mousewheel: function( event, delta ) {
			var activeElement = this.document[ 0 ].activeElement;
			var isActive = this.element[ 0 ] === activeElement;

			if ( !isActive || !delta ) {
				return;
			}

			if ( !this.spinning &amp;&amp; !this._start( event ) ) {
				return false;
			}

			this._spin( ( delta &gt; 0 ? 1 : -1 ) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay( function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		&quot;mousedown .ui-spinner-button&quot;: function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[ 0 ] === this.document[ 0 ].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[ 0 ] === this.document[ 0 ].activeElement;
				if ( !isActive ) {
					this.element.trigger( &quot;focus&quot; );
					this.previous = previous;
				}
			}

			// Ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget )
				.hasClass( &quot;ui-spinner-up&quot; ) ? 1 : -1, event );
		},
		&quot;mouseup .ui-spinner-button&quot;: &quot;_stop&quot;,
		&quot;mouseenter .ui-spinner-button&quot;: function( event ) {

			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( &quot;ui-state-active&quot; ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget )
				.hasClass( &quot;ui-spinner-up&quot; ) ? 1 : -1, event );
		},

		// TODO: do we really want to consider this a stop?
		// shouldn&#039;t we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		&quot;mouseleave .ui-spinner-button&quot;: &quot;_stop&quot;
	},

	// Support mobile enhanced option and make backcompat more sane
	_enhance: function() {
		this.uiSpinner = this.element
			.attr( &quot;autocomplete&quot;, &quot;off&quot; )
			.wrap( &quot;&lt;span&gt;&quot; )
			.parent()

				// Add buttons
				.append(
					&quot;&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;&quot;
				);
	},

	_draw: function() {
		this._enhance();

		this._addClass( this.uiSpinner, &quot;ui-spinner&quot;, &quot;ui-widget ui-widget-content&quot; );
		this._addClass( &quot;ui-spinner-input&quot; );

		this.element.attr( &quot;role&quot;, &quot;spinbutton&quot; );

		// Button bindings
		this.buttons = this.uiSpinner.children( &quot;a&quot; )
			.attr( &quot;tabIndex&quot;, -1 )
			.attr( &quot;aria-hidden&quot;, true )
			.button( {
				classes: {
					&quot;ui-button&quot;: &quot;&quot;
				}
			} );

		// TODO: Right now button does not support classes this is already updated in button PR
		this._removeClass( this.buttons, &quot;ui-corner-all&quot; );

		this._addClass( this.buttons.first(), &quot;ui-spinner-button ui-spinner-up&quot; );
		this._addClass( this.buttons.last(), &quot;ui-spinner-button ui-spinner-down&quot; );
		this.buttons.first().button( {
			&quot;icon&quot;: this.options.icons.up,
			&quot;showLabel&quot;: false
		} );
		this.buttons.last().button( {
			&quot;icon&quot;: this.options.icons.down,
			&quot;showLabel&quot;: false
		} );

		// IE 6 doesn&#039;t understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() &gt; Math.ceil( this.uiSpinner.height() * 0.5 ) &amp;&amp;
				this.uiSpinner.height() &gt; 0 ) {
			this.uiSpinner.height( this.uiSpinner.height() );
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_start: function( event ) {
		if ( !this.spinning &amp;&amp; this._trigger( &quot;start&quot;, event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay( function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( &quot;spin&quot;, event, { value: value } ) !== false ) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return typeof incremental === &quot;function&quot; ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( &quot;.&quot; );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// Make sure we&#039;re at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;

		// - round to the nearest step
		aboveMin = Math.round( aboveMin / options.step ) * options.step;

		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// Fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// Clamp the value
		if ( options.max !== null &amp;&amp; value &gt; options.max ) {
			return options.max;
		}
		if ( options.min !== null &amp;&amp; value &lt; options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( &quot;stop&quot;, event );
	},

	_setOption: function( key, value ) {
		var prevValue, first, last;

		if ( key === &quot;culture&quot; || key === &quot;numberFormat&quot; ) {
			prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === &quot;max&quot; || key === &quot;min&quot; || key === &quot;step&quot; ) {
			if ( typeof value === &quot;string&quot; ) {
				value = this._parse( value );
			}
		}
		if ( key === &quot;icons&quot; ) {
			first = this.buttons.first().find( &quot;.ui-icon&quot; );
			this._removeClass( first, null, this.options.icons.up );
			this._addClass( first, null, value.up );
			last = this.buttons.last().find( &quot;.ui-icon&quot; );
			this._removeClass( last, null, this.options.icons.down );
			this._addClass( last, null, value.down );
		}

		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( this.uiSpinner, null, &quot;ui-state-disabled&quot;, !!value );
		this.element.prop( &quot;disabled&quot;, !!value );
		this.buttons.button( value ? &quot;disable&quot; : &quot;enable&quot; );
	},

	_setOptions: spinnerModifier( function( options ) {
		this._super( options );
	} ),

	_parse: function( val ) {
		if ( typeof val === &quot;string&quot; &amp;&amp; val !== &quot;&quot; ) {
			val = window.Globalize &amp;&amp; this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === &quot;&quot; || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === &quot;&quot; ) {
			return &quot;&quot;;
		}
		return window.Globalize &amp;&amp; this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr( {
			&quot;aria-valuemin&quot;: this.options.min,
			&quot;aria-valuemax&quot;: this.options.max,

			// TODO: what should we do with values that can&#039;t be parsed?
			&quot;aria-valuenow&quot;: this._parse( this.element.val() )
		} );
	},

	isValid: function() {
		var value = this.value();

		// Null is invalid
		if ( value === null ) {
			return false;
		}

		// If value gets adjusted, it&#039;s invalid
		return value === this._adjustValue( value );
	},

	// Update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== &quot;&quot; ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.prop( &quot;disabled&quot;, false )
			.removeAttr( &quot;autocomplete role aria-valuemin aria-valuemax aria-valuenow&quot; );

		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinnerModifier( function( steps ) {
		this._stepUp( steps );
	} ),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinnerModifier( function( steps ) {
		this._stepDown( steps );
	} ),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinnerModifier( function( pages ) {
		this._stepUp( ( pages || 1 ) * this.options.page );
	} ),

	pageDown: spinnerModifier( function( pages ) {
		this._stepDown( ( pages || 1 ) * this.options.page );
	} ),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinnerModifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat === true ) {

	// Backcompat for spinner html extension points
	$.widget( &quot;ui.spinner&quot;, $.ui.spinner, {
		_enhance: function() {
			this.uiSpinner = this.element
				.attr( &quot;autocomplete&quot;, &quot;off&quot; )
				.wrap( this._uiSpinnerHtml() )
				.parent()

					// Add buttons
					.append( this._buttonHtml() );
		},
		_uiSpinnerHtml: function() {
			return &quot;&lt;span&gt;&quot;;
		},

		_buttonHtml: function() {
			return &quot;&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;&quot;;
		}
	} );
}

return $.ui.spinner;

} );
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
