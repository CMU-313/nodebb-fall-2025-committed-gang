<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/whatwg-url/lib/url-state-machine.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/whatwg-url/lib/url-state-machine.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.24</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1275</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">171.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
const tr46 = require(&quot;tr46&quot;);

const infra = require(&quot;./infra&quot;);
const { utf8DecodeWithoutBOM } = require(&quot;./encoding&quot;);
const { percentDecodeString, utf8PercentEncodeCodePoint, utf8PercentEncodeString, isC0ControlPercentEncode,
  isFragmentPercentEncode, isQueryPercentEncode, isSpecialQueryPercentEncode, isPathPercentEncode,
  isUserinfoPercentEncode } = require(&quot;./percent-encoding&quot;);

function p(char) {
  return char.codePointAt(0);
}

const specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

const failure = Symbol(&quot;failure&quot;);

function countSymbols(str) {
  return [...str].length;
}

function at(input, idx) {
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
}

function isSingleDot(buffer) {
  return buffer === &quot;.&quot; || buffer.toLowerCase() === &quot;%2e&quot;;
}

function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === &quot;..&quot; || buffer === &quot;%2e.&quot; || buffer === &quot;.%2e&quot; || buffer === &quot;%2e%2e&quot;;
}

function isWindowsDriveLetterCodePoints(cp1, cp2) {
  return infra.isASCIIAlpha(cp1) &amp;&amp; (cp2 === p(&quot;:&quot;) || cp2 === p(&quot;|&quot;));
}

function isWindowsDriveLetterString(string) {
  return string.length === 2 &amp;&amp; infra.isASCIIAlpha(string.codePointAt(0)) &amp;&amp; (string[1] === &quot;:&quot; || string[1] === &quot;|&quot;);
}

function isNormalizedWindowsDriveLetterString(string) {
  return string.length === 2 &amp;&amp; infra.isASCIIAlpha(string.codePointAt(0)) &amp;&amp; string[1] === &quot;:&quot;;
}

function containsForbiddenHostCodePoint(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|&lt;|&gt;|\?|@|\[|\\|\]|\^|\|/u) !== -1;
}

function containsForbiddenDomainCodePoint(string) {
  return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
}

function isSpecialScheme(scheme) {
  return specialSchemes[scheme] !== undefined;
}

function isSpecial(url) {
  return isSpecialScheme(url.scheme);
}

function isNotSpecial(url) {
  return !isSpecialScheme(url.scheme);
}

function defaultPort(scheme) {
  return specialSchemes[scheme];
}

function parseIPv4Number(input) {
  if (input === &quot;&quot;) {
    return failure;
  }

  let R = 10;

  if (input.length &gt;= 2 &amp;&amp; input.charAt(0) === &quot;0&quot; &amp;&amp; input.charAt(1).toLowerCase() === &quot;x&quot;) {
    input = input.substring(2);
    R = 16;
  } else if (input.length &gt;= 2 &amp;&amp; input.charAt(0) === &quot;0&quot;) {
    input = input.substring(1);
    R = 8;
  }

  if (input === &quot;&quot;) {
    return 0;
  }

  let regex = /[^0-7]/u;
  if (R === 10) {
    regex = /[^0-9]/u;
  }
  if (R === 16) {
    regex = /[^0-9A-Fa-f]/u;
  }

  if (regex.test(input)) {
    return failure;
  }

  return parseInt(input, R);
}

function parseIPv4(input) {
  const parts = input.split(&quot;.&quot;);
  if (parts[parts.length - 1] === &quot;&quot;) {
    if (parts.length &gt; 1) {
      parts.pop();
    }
  }

  if (parts.length &gt; 4) {
    return failure;
  }

  const numbers = [];
  for (const part of parts) {
    const n = parseIPv4Number(part);
    if (n === failure) {
      return failure;
    }

    numbers.push(n);
  }

  for (let i = 0; i &lt; numbers.length - 1; ++i) {
    if (numbers[i] &gt; 255) {
      return failure;
    }
  }
  if (numbers[numbers.length - 1] &gt;= 256 ** (5 - numbers.length)) {
    return failure;
  }

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) {
    ipv4 += n * 256 ** (3 - counter);
    ++counter;
  }

  return ipv4;
}

function serializeIPv4(address) {
  let output = &quot;&quot;;
  let n = address;

  for (let i = 1; i &lt;= 4; ++i) {
    output = String(n % 256) + output;
    if (i !== 4) {
      output = `.${output}`;
    }
    n = Math.floor(n / 256);
  }

  return output;
}

function parseIPv6(input) {
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer = 0;

  input = Array.from(input, c =&gt; c.codePointAt(0));

  if (input[pointer] === p(&quot;:&quot;)) {
    if (input[pointer + 1] !== p(&quot;:&quot;)) {
      return failure;
    }

    pointer += 2;
    ++pieceIndex;
    compress = pieceIndex;
  }

  while (pointer &lt; input.length) {
    if (pieceIndex === 8) {
      return failure;
    }

    if (input[pointer] === p(&quot;:&quot;)) {
      if (compress !== null) {
        return failure;
      }
      ++pointer;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    }

    let value = 0;
    let length = 0;

    while (length &lt; 4 &amp;&amp; infra.isASCIIHex(input[pointer])) {
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    }

    if (input[pointer] === p(&quot;.&quot;)) {
      if (length === 0) {
        return failure;
      }

      pointer -= length;

      if (pieceIndex &gt; 6) {
        return failure;
      }

      let numbersSeen = 0;

      while (input[pointer] !== undefined) {
        let ipv4Piece = null;

        if (numbersSeen &gt; 0) {
          if (input[pointer] === p(&quot;.&quot;) &amp;&amp; numbersSeen &lt; 4) {
            ++pointer;
          } else {
            return failure;
          }
        }

        if (!infra.isASCIIDigit(input[pointer])) {
          return failure;
        }

        while (infra.isASCIIDigit(input[pointer])) {
          const number = parseInt(at(input, pointer));
          if (ipv4Piece === null) {
            ipv4Piece = number;
          } else if (ipv4Piece === 0) {
            return failure;
          } else {
            ipv4Piece = ipv4Piece * 10 + number;
          }
          if (ipv4Piece &gt; 255) {
            return failure;
          }
          ++pointer;
        }

        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

        ++numbersSeen;

        if (numbersSeen === 2 || numbersSeen === 4) {
          ++pieceIndex;
        }
      }

      if (numbersSeen !== 4) {
        return failure;
      }

      break;
    } else if (input[pointer] === p(&quot;:&quot;)) {
      ++pointer;
      if (input[pointer] === undefined) {
        return failure;
      }
    } else if (input[pointer] !== undefined) {
      return failure;
    }

    address[pieceIndex] = value;
    ++pieceIndex;
  }

  if (compress !== null) {
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 &amp;&amp; swaps &gt; 0) {
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    }
  } else if (compress === null &amp;&amp; pieceIndex !== 8) {
    return failure;
  }

  return address;
}

function serializeIPv6(address) {
  let output = &quot;&quot;;
  const compress = findTheIPv6AddressCompressedPieceIndex(address);
  let ignore0 = false;

  for (let pieceIndex = 0; pieceIndex &lt;= 7; ++pieceIndex) {
    if (ignore0 &amp;&amp; address[pieceIndex] === 0) {
      continue;
    } else if (ignore0) {
      ignore0 = false;
    }

    if (compress === pieceIndex) {
      const separator = pieceIndex === 0 ? &quot;::&quot; : &quot;:&quot;;
      output += separator;
      ignore0 = true;
      continue;
    }

    output += address[pieceIndex].toString(16);

    if (pieceIndex !== 7) {
      output += &quot;:&quot;;
    }
  }

  return output;
}

function parseHost(input, isOpaque = false) {
  if (input[0] === &quot;[&quot;) {
    if (input[input.length - 1] !== &quot;]&quot;) {
      return failure;
    }

    return parseIPv6(input.substring(1, input.length - 1));
  }

  if (isOpaque) {
    return parseOpaqueHost(input);
  }

  const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
  const asciiDomain = domainToASCII(domain);
  if (asciiDomain === failure) {
    return failure;
  }

  if (endsInANumber(asciiDomain)) {
    return parseIPv4(asciiDomain);
  }

  return asciiDomain;
}

function endsInANumber(input) {
  const parts = input.split(&quot;.&quot;);
  if (parts[parts.length - 1] === &quot;&quot;) {
    if (parts.length === 1) {
      return false;
    }
    parts.pop();
  }

  const last = parts[parts.length - 1];
  if (parseIPv4Number(last) !== failure) {
    return true;
  }

  if (/^[0-9]+$/u.test(last)) {
    return true;
  }

  return false;
}

function parseOpaqueHost(input) {
  if (containsForbiddenHostCodePoint(input)) {
    return failure;
  }

  return utf8PercentEncodeString(input, isC0ControlPercentEncode);
}

function findTheIPv6AddressCompressedPieceIndex(address) {
  let longestIndex = null;
  let longestSize = 1; // only find elements &gt; 1
  let foundIndex = null;
  let foundSize = 0;

  for (let pieceIndex = 0; pieceIndex &lt; address.length; ++pieceIndex) {
    if (address[pieceIndex] !== 0) {
      if (foundSize &gt; longestSize) {
        longestIndex = foundIndex;
        longestSize = foundSize;
      }

      foundIndex = null;
      foundSize = 0;
    } else {
      if (foundIndex === null) {
        foundIndex = pieceIndex;
      }
      ++foundSize;
    }
  }

  if (foundSize &gt; longestSize) {
    return foundIndex;
  }

  return longestIndex;
}

function serializeHost(host) {
  if (typeof host === &quot;number&quot;) {
    return serializeIPv4(host);
  }

  // IPv6 serializer
  if (host instanceof Array) {
    return `[${serializeIPv6(host)}]`;
  }

  return host;
}

function domainToASCII(domain, beStrict = false) {
  const result = tr46.toASCII(domain, {
    checkHyphens: beStrict,
    checkBidi: true,
    checkJoiners: true,
    useSTD3ASCIIRules: beStrict,
    transitionalProcessing: false,
    verifyDNSLength: beStrict,
    ignoreInvalidPunycode: false
  });
  if (result === null) {
    return failure;
  }

  if (!beStrict) {
    if (result === &quot;&quot;) {
      return failure;
    }
    if (containsForbiddenDomainCodePoint(result)) {
      return failure;
    }
  }
  return result;
}

function trimControlChars(string) {
  // Avoid using regexp because of this V8 bug: https://issues.chromium.org/issues/42204424

  let start = 0;
  let end = string.length;
  for (; start &lt; end; ++start) {
    if (string.charCodeAt(start) &gt; 0x20) {
      break;
    }
  }
  for (; end &gt; start; --end) {
    if (string.charCodeAt(end - 1) &gt; 0x20) {
      break;
    }
  }
  return string.substring(start, end);
}

function trimTabAndNewline(url) {
  return url.replace(/\u0009|\u000A|\u000D/ug, &quot;&quot;);
}

function shortenPath(url) {
  const { path } = url;
  if (path.length === 0) {
    return;
  }
  if (url.scheme === &quot;file&quot; &amp;&amp; path.length === 1 &amp;&amp; isNormalizedWindowsDriveLetter(path[0])) {
    return;
  }

  path.pop();
}

function includesCredentials(url) {
  return url.username !== &quot;&quot; || url.password !== &quot;&quot;;
}

function cannotHaveAUsernamePasswordPort(url) {
  return url.host === null || url.host === &quot;&quot; || url.scheme === &quot;file&quot;;
}

function hasAnOpaquePath(url) {
  return typeof url.path === &quot;string&quot;;
}

function isNormalizedWindowsDriveLetter(string) {
  return /^[A-Za-z]:$/u.test(string);
}

function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encodingOverride = encodingOverride || &quot;utf-8&quot;;
  this.stateOverride = stateOverride;
  this.url = url;
  this.failure = false;
  this.parseError = false;

  if (!this.url) {
    this.url = {
      scheme: &quot;&quot;,
      username: &quot;&quot;,
      password: &quot;&quot;,
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null
    };

    const res = trimControlChars(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
  }

  const res = trimTabAndNewline(this.input);
  if (res !== this.input) {
    this.parseError = true;
  }
  this.input = res;

  this.state = stateOverride || &quot;scheme start&quot;;

  this.buffer = &quot;&quot;;
  this.atFlag = false;
  this.arrFlag = false;
  this.passwordTokenSeenFlag = false;

  this.input = Array.from(this.input, c =&gt; c.codePointAt(0));

  for (; this.pointer &lt;= this.input.length; ++this.pointer) {
    const c = this.input[this.pointer];
    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

    // exec state machine
    const ret = this[`parse ${this.state}`](c, cStr);
    if (!ret) {
      break; // terminate algorithm
    } else if (ret === failure) {
      this.failure = true;
      break;
    }
  }
}

URLStateMachine.prototype[&quot;parse scheme start&quot;] = function parseSchemeStart(c, cStr) {
  if (infra.isASCIIAlpha(c)) {
    this.buffer += cStr.toLowerCase();
    this.state = &quot;scheme&quot;;
  } else if (!this.stateOverride) {
    this.state = &quot;no scheme&quot;;
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse scheme&quot;] = function parseScheme(c, cStr) {
  if (infra.isASCIIAlphanumeric(c) || c === p(&quot;+&quot;) || c === p(&quot;-&quot;) || c === p(&quot;.&quot;)) {
    this.buffer += cStr.toLowerCase();
  } else if (c === p(&quot;:&quot;)) {
    if (this.stateOverride) {
      if (isSpecial(this.url) &amp;&amp; !isSpecialScheme(this.buffer)) {
        return false;
      }

      if (!isSpecial(this.url) &amp;&amp; isSpecialScheme(this.buffer)) {
        return false;
      }

      if ((includesCredentials(this.url) || this.url.port !== null) &amp;&amp; this.buffer === &quot;file&quot;) {
        return false;
      }

      if (this.url.scheme === &quot;file&quot; &amp;&amp; this.url.host === &quot;&quot;) {
        return false;
      }
    }
    this.url.scheme = this.buffer;
    if (this.stateOverride) {
      if (this.url.port === defaultPort(this.url.scheme)) {
        this.url.port = null;
      }
      return false;
    }
    this.buffer = &quot;&quot;;
    if (this.url.scheme === &quot;file&quot;) {
      if (this.input[this.pointer + 1] !== p(&quot;/&quot;) || this.input[this.pointer + 2] !== p(&quot;/&quot;)) {
        this.parseError = true;
      }
      this.state = &quot;file&quot;;
    } else if (isSpecial(this.url) &amp;&amp; this.base !== null &amp;&amp; this.base.scheme === this.url.scheme) {
      this.state = &quot;special relative or authority&quot;;
    } else if (isSpecial(this.url)) {
      this.state = &quot;special authority slashes&quot;;
    } else if (this.input[this.pointer + 1] === p(&quot;/&quot;)) {
      this.state = &quot;path or authority&quot;;
      ++this.pointer;
    } else {
      this.url.path = &quot;&quot;;
      this.state = &quot;opaque path&quot;;
    }
  } else if (!this.stateOverride) {
    this.buffer = &quot;&quot;;
    this.state = &quot;no scheme&quot;;
    this.pointer = -1;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse no scheme&quot;] = function parseNoScheme(c) {
  if (this.base === null || (hasAnOpaquePath(this.base) &amp;&amp; c !== p(&quot;#&quot;))) {
    return failure;
  } else if (hasAnOpaquePath(this.base) &amp;&amp; c === p(&quot;#&quot;)) {
    this.url.scheme = this.base.scheme;
    this.url.path = this.base.path;
    this.url.query = this.base.query;
    this.url.fragment = &quot;&quot;;
    this.state = &quot;fragment&quot;;
  } else if (this.base.scheme === &quot;file&quot;) {
    this.state = &quot;file&quot;;
    --this.pointer;
  } else {
    this.state = &quot;relative&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse special relative or authority&quot;] = function parseSpecialRelativeOrAuthority(c) {
  if (c === p(&quot;/&quot;) &amp;&amp; this.input[this.pointer + 1] === p(&quot;/&quot;)) {
    this.state = &quot;special authority ignore slashes&quot;;
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = &quot;relative&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse path or authority&quot;] = function parsePathOrAuthority(c) {
  if (c === p(&quot;/&quot;)) {
    this.state = &quot;authority&quot;;
  } else {
    this.state = &quot;path&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse relative&quot;] = function parseRelative(c) {
  this.url.scheme = this.base.scheme;
  if (c === p(&quot;/&quot;)) {
    this.state = &quot;relative slash&quot;;
  } else if (isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;)) {
    this.parseError = true;
    this.state = &quot;relative slash&quot;;
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    if (c === p(&quot;?&quot;)) {
      this.url.query = &quot;&quot;;
      this.state = &quot;query&quot;;
    } else if (c === p(&quot;#&quot;)) {
      this.url.fragment = &quot;&quot;;
      this.state = &quot;fragment&quot;;
    } else if (!isNaN(c)) {
      this.url.query = null;
      this.url.path.pop();
      this.state = &quot;path&quot;;
      --this.pointer;
    }
  }

  return true;
};

URLStateMachine.prototype[&quot;parse relative slash&quot;] = function parseRelativeSlash(c) {
  if (isSpecial(this.url) &amp;&amp; (c === p(&quot;/&quot;) || c === p(&quot;\\&quot;))) {
    if (c === p(&quot;\\&quot;)) {
      this.parseError = true;
    }
    this.state = &quot;special authority ignore slashes&quot;;
  } else if (c === p(&quot;/&quot;)) {
    this.state = &quot;authority&quot;;
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.state = &quot;path&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse special authority slashes&quot;] = function parseSpecialAuthoritySlashes(c) {
  if (c === p(&quot;/&quot;) &amp;&amp; this.input[this.pointer + 1] === p(&quot;/&quot;)) {
    this.state = &quot;special authority ignore slashes&quot;;
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = &quot;special authority ignore slashes&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse special authority ignore slashes&quot;] = function parseSpecialAuthorityIgnoreSlashes(c) {
  if (c !== p(&quot;/&quot;) &amp;&amp; c !== p(&quot;\\&quot;)) {
    this.state = &quot;authority&quot;;
    --this.pointer;
  } else {
    this.parseError = true;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse authority&quot;] = function parseAuthority(c, cStr) {
  if (c === p(&quot;@&quot;)) {
    this.parseError = true;
    if (this.atFlag) {
      this.buffer = `%40${this.buffer}`;
    }
    this.atFlag = true;

    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
    const len = countSymbols(this.buffer);
    for (let pointer = 0; pointer &lt; len; ++pointer) {
      const codePoint = this.buffer.codePointAt(pointer);

      if (codePoint === p(&quot;:&quot;) &amp;&amp; !this.passwordTokenSeenFlag) {
        this.passwordTokenSeenFlag = true;
        continue;
      }
      const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
      if (this.passwordTokenSeenFlag) {
        this.url.password += encodedCodePoints;
      } else {
        this.url.username += encodedCodePoints;
      }
    }
    this.buffer = &quot;&quot;;
  } else if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;) ||
             (isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;))) {
    if (this.atFlag &amp;&amp; this.buffer === &quot;&quot;) {
      this.parseError = true;
      return failure;
    }
    this.pointer -= countSymbols(this.buffer) + 1;
    this.buffer = &quot;&quot;;
    this.state = &quot;host&quot;;
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse hostname&quot;] =
URLStateMachine.prototype[&quot;parse host&quot;] = function parseHostName(c, cStr) {
  if (this.stateOverride &amp;&amp; this.url.scheme === &quot;file&quot;) {
    --this.pointer;
    this.state = &quot;file host&quot;;
  } else if (c === p(&quot;:&quot;) &amp;&amp; !this.arrFlag) {
    if (this.buffer === &quot;&quot;) {
      this.parseError = true;
      return failure;
    }

    if (this.stateOverride === &quot;hostname&quot;) {
      return false;
    }

    const host = parseHost(this.buffer, isNotSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = &quot;&quot;;
    this.state = &quot;port&quot;;
  } else if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;) ||
             (isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;))) {
    --this.pointer;
    if (isSpecial(this.url) &amp;&amp; this.buffer === &quot;&quot;) {
      this.parseError = true;
      return failure;
    } else if (this.stateOverride &amp;&amp; this.buffer === &quot;&quot; &amp;&amp;
               (includesCredentials(this.url) || this.url.port !== null)) {
      this.parseError = true;
      return false;
    }

    const host = parseHost(this.buffer, isNotSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = &quot;&quot;;
    this.state = &quot;path start&quot;;
    if (this.stateOverride) {
      return false;
    }
  } else {
    if (c === p(&quot;[&quot;)) {
      this.arrFlag = true;
    } else if (c === p(&quot;]&quot;)) {
      this.arrFlag = false;
    }
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse port&quot;] = function parsePort(c, cStr) {
  if (infra.isASCIIDigit(c)) {
    this.buffer += cStr;
  } else if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;) ||
             (isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;)) ||
             this.stateOverride) {
    if (this.buffer !== &quot;&quot;) {
      const port = parseInt(this.buffer);
      if (port &gt; 2 ** 16 - 1) {
        this.parseError = true;
        return failure;
      }
      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
      this.buffer = &quot;&quot;;
    }
    if (this.stateOverride) {
      return false;
    }
    this.state = &quot;path start&quot;;
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

const fileOtherwiseCodePoints = new Set([p(&quot;/&quot;), p(&quot;\\&quot;), p(&quot;?&quot;), p(&quot;#&quot;)]);

function startsWithWindowsDriveLetter(input, pointer) {
  const length = input.length - pointer;
  return length &gt;= 2 &amp;&amp;
    isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) &amp;&amp;
    (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
}

URLStateMachine.prototype[&quot;parse file&quot;] = function parseFile(c) {
  this.url.scheme = &quot;file&quot;;
  this.url.host = &quot;&quot;;

  if (c === p(&quot;/&quot;) || c === p(&quot;\\&quot;)) {
    if (c === p(&quot;\\&quot;)) {
      this.parseError = true;
    }
    this.state = &quot;file slash&quot;;
  } else if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
    this.url.host = this.base.host;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    if (c === p(&quot;?&quot;)) {
      this.url.query = &quot;&quot;;
      this.state = &quot;query&quot;;
    } else if (c === p(&quot;#&quot;)) {
      this.url.fragment = &quot;&quot;;
      this.state = &quot;fragment&quot;;
    } else if (!isNaN(c)) {
      this.url.query = null;
      if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
        shortenPath(this.url);
      } else {
        this.parseError = true;
        this.url.path = [];
      }

      this.state = &quot;path&quot;;
      --this.pointer;
    }
  } else {
    this.state = &quot;path&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse file slash&quot;] = function parseFileSlash(c) {
  if (c === p(&quot;/&quot;) || c === p(&quot;\\&quot;)) {
    if (c === p(&quot;\\&quot;)) {
      this.parseError = true;
    }
    this.state = &quot;file host&quot;;
  } else {
    if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
      if (!startsWithWindowsDriveLetter(this.input, this.pointer) &amp;&amp;
          isNormalizedWindowsDriveLetterString(this.base.path[0])) {
        this.url.path.push(this.base.path[0]);
      }
      this.url.host = this.base.host;
    }
    this.state = &quot;path&quot;;
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse file host&quot;] = function parseFileHost(c, cStr) {
  if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;\\&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;)) {
    --this.pointer;
    if (!this.stateOverride &amp;&amp; isWindowsDriveLetterString(this.buffer)) {
      this.parseError = true;
      this.state = &quot;path&quot;;
    } else if (this.buffer === &quot;&quot;) {
      this.url.host = &quot;&quot;;
      if (this.stateOverride) {
        return false;
      }
      this.state = &quot;path start&quot;;
    } else {
      let host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      if (host === &quot;localhost&quot;) {
        host = &quot;&quot;;
      }
      this.url.host = host;

      if (this.stateOverride) {
        return false;
      }

      this.buffer = &quot;&quot;;
      this.state = &quot;path start&quot;;
    }
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse path start&quot;] = function parsePathStart(c) {
  if (isSpecial(this.url)) {
    if (c === p(&quot;\\&quot;)) {
      this.parseError = true;
    }
    this.state = &quot;path&quot;;

    if (c !== p(&quot;/&quot;) &amp;&amp; c !== p(&quot;\\&quot;)) {
      --this.pointer;
    }
  } else if (!this.stateOverride &amp;&amp; c === p(&quot;?&quot;)) {
    this.url.query = &quot;&quot;;
    this.state = &quot;query&quot;;
  } else if (!this.stateOverride &amp;&amp; c === p(&quot;#&quot;)) {
    this.url.fragment = &quot;&quot;;
    this.state = &quot;fragment&quot;;
  } else if (c !== undefined) {
    this.state = &quot;path&quot;;
    if (c !== p(&quot;/&quot;)) {
      --this.pointer;
    }
  } else if (this.stateOverride &amp;&amp; this.url.host === null) {
    this.url.path.push(&quot;&quot;);
  }

  return true;
};

URLStateMachine.prototype[&quot;parse path&quot;] = function parsePath(c) {
  if (isNaN(c) || c === p(&quot;/&quot;) || (isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;)) ||
      (!this.stateOverride &amp;&amp; (c === p(&quot;?&quot;) || c === p(&quot;#&quot;)))) {
    if (isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;)) {
      this.parseError = true;
    }

    if (isDoubleDot(this.buffer)) {
      shortenPath(this.url);
      if (c !== p(&quot;/&quot;) &amp;&amp; !(isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;))) {
        this.url.path.push(&quot;&quot;);
      }
    } else if (isSingleDot(this.buffer) &amp;&amp; c !== p(&quot;/&quot;) &amp;&amp;
               !(isSpecial(this.url) &amp;&amp; c === p(&quot;\\&quot;))) {
      this.url.path.push(&quot;&quot;);
    } else if (!isSingleDot(this.buffer)) {
      if (this.url.scheme === &quot;file&quot; &amp;&amp; this.url.path.length === 0 &amp;&amp; isWindowsDriveLetterString(this.buffer)) {
        this.buffer = `${this.buffer[0]}:`;
      }
      this.url.path.push(this.buffer);
    }
    this.buffer = &quot;&quot;;
    if (c === p(&quot;?&quot;)) {
      this.url.query = &quot;&quot;;
      this.state = &quot;query&quot;;
    }
    if (c === p(&quot;#&quot;)) {
      this.url.fragment = &quot;&quot;;
      this.state = &quot;fragment&quot;;
    }
  } else {
    // TODO: If c is not a URL code point and not &quot;%&quot;, parse error.

    if (c === p(&quot;%&quot;) &amp;&amp;
      (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
        !infra.isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
  }

  return true;
};

URLStateMachine.prototype[&quot;parse opaque path&quot;] = function parseOpaquePath(c) {
  if (c === p(&quot;?&quot;)) {
    this.url.query = &quot;&quot;;
    this.state = &quot;query&quot;;
  } else if (c === p(&quot;#&quot;)) {
    this.url.fragment = &quot;&quot;;
    this.state = &quot;fragment&quot;;
  } else if (c === p(&quot; &quot;)) {
    const remaining = this.input[this.pointer + 1];
    if (remaining === p(&quot;?&quot;) || remaining === p(&quot;#&quot;)) {
      this.url.path += &quot;%20&quot;;
    } else {
      this.url.path += &quot; &quot;;
    }
  } else {
    // TODO: Add: not a URL code point
    if (!isNaN(c) &amp;&amp; c !== p(&quot;%&quot;)) {
      this.parseError = true;
    }

    if (c === p(&quot;%&quot;) &amp;&amp;
        (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
         !infra.isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    if (!isNaN(c)) {
      this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
    }
  }

  return true;
};

URLStateMachine.prototype[&quot;parse query&quot;] = function parseQuery(c, cStr) {
  if (!isSpecial(this.url) || this.url.scheme === &quot;ws&quot; || this.url.scheme === &quot;wss&quot;) {
    this.encodingOverride = &quot;utf-8&quot;;
  }

  if ((!this.stateOverride &amp;&amp; c === p(&quot;#&quot;)) || isNaN(c)) {
    const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
    this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);

    this.buffer = &quot;&quot;;

    if (c === p(&quot;#&quot;)) {
      this.url.fragment = &quot;&quot;;
      this.state = &quot;fragment&quot;;
    }
  } else if (!isNaN(c)) {
    // TODO: If c is not a URL code point and not &quot;%&quot;, parse error.

    if (c === p(&quot;%&quot;) &amp;&amp;
      (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
        !infra.isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype[&quot;parse fragment&quot;] = function parseFragment(c) {
  if (!isNaN(c)) {
    // TODO: If c is not a URL code point and not &quot;%&quot;, parse error.
    if (c === p(&quot;%&quot;) &amp;&amp;
      (!infra.isASCIIHex(this.input[this.pointer + 1]) ||
        !infra.isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
  }

  return true;
};

function serializeURL(url, excludeFragment) {
  let output = `${url.scheme}:`;
  if (url.host !== null) {
    output += &quot;//&quot;;

    if (url.username !== &quot;&quot; || url.password !== &quot;&quot;) {
      output += url.username;
      if (url.password !== &quot;&quot;) {
        output += `:${url.password}`;
      }
      output += &quot;@&quot;;
    }

    output += serializeHost(url.host);

    if (url.port !== null) {
      output += `:${url.port}`;
    }
  }

  if (url.host === null &amp;&amp; !hasAnOpaquePath(url) &amp;&amp; url.path.length &gt; 1 &amp;&amp; url.path[0] === &quot;&quot;) {
    output += &quot;/.&quot;;
  }
  output += serializePath(url);

  if (url.query !== null) {
    output += `?${url.query}`;
  }

  if (!excludeFragment &amp;&amp; url.fragment !== null) {
    output += `#${url.fragment}`;
  }

  return output;
}

function serializeOrigin(tuple) {
  let result = `${tuple.scheme}://`;
  result += serializeHost(tuple.host);

  if (tuple.port !== null) {
    result += `:${tuple.port}`;
  }

  return result;
}

function serializePath(url) {
  if (hasAnOpaquePath(url)) {
    return url.path;
  }

  let output = &quot;&quot;;
  for (const segment of url.path) {
    output += `/${segment}`;
  }
  return output;
}

module.exports.serializeURL = serializeURL;

module.exports.serializePath = serializePath;

module.exports.serializeURLOrigin = function (url) {
  // https://url.spec.whatwg.org/#concept-url-origin
  switch (url.scheme) {
    case &quot;blob&quot;: {
      const pathURL = module.exports.parseURL(serializePath(url));
      if (pathURL === null) {
        return &quot;null&quot;;
      }
      if (pathURL.scheme !== &quot;http&quot; &amp;&amp; pathURL.scheme !== &quot;https&quot;) {
        return &quot;null&quot;;
      }
      return module.exports.serializeURLOrigin(pathURL);
    }
    case &quot;ftp&quot;:
    case &quot;http&quot;:
    case &quot;https&quot;:
    case &quot;ws&quot;:
    case &quot;wss&quot;:
      return serializeOrigin({
        scheme: url.scheme,
        host: url.host,
        port: url.port
      });
    case &quot;file&quot;:
      // The spec says:
      // &gt; Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.
      // Browsers tested so far:
      // - Chrome says &quot;file://&quot;, but treats file: URLs as cross-origin for most (all?) purposes; see e.g.
      //   https://bugs.chromium.org/p/chromium/issues/detail?id=37586
      // - Firefox says &quot;null&quot;, but treats file: URLs as same-origin sometimes based on directory stuff; see
      //   https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs
      return &quot;null&quot;;
    default:
      // serializing an opaque origin returns &quot;null&quot;
      return &quot;null&quot;;
  }
};

module.exports.basicURLParse = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) {
    return null;
  }

  return usm.url;
};

module.exports.setTheUsername = function (url, username) {
  url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
};

module.exports.setThePassword = function (url, password) {
  url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
};

module.exports.serializeHost = serializeHost;

module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

module.exports.hasAnOpaquePath = hasAnOpaquePath;

module.exports.serializeInteger = function (integer) {
  return String(integer);
};

module.exports.parseURL = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  // We don&#039;t handle blobs, so this just delegates:
  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
