<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">341</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">73.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const { STAGE_ADVANCED } = require(&quot;../OptimizationStages&quot;);
const { intersect } = require(&quot;../util/SetHelpers&quot;);
const {
	compareModulesByIdentifier,
	compareChunks
} = require(&quot;../util/comparators&quot;);
const createSchemaValidation = require(&quot;../util/create-schema-validation&quot;);
const identifierUtils = require(&quot;../util/identifier&quot;);

/** @typedef {import(&quot;../../declarations/plugins/optimize/AggressiveSplittingPlugin&quot;).AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */
/** @typedef {import(&quot;../Chunk&quot;)} Chunk */
/** @typedef {import(&quot;../ChunkGraph&quot;)} ChunkGraph */
/** @typedef {import(&quot;../Compiler&quot;)} Compiler */
/** @typedef {import(&quot;../Module&quot;)} Module */

const validate = createSchemaValidation(
	require(&quot;../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js&quot;),
	() =&gt;
		require(&quot;../../schemas/plugins/optimize/AggressiveSplittingPlugin.json&quot;),
	{
		name: &quot;Aggressive Splitting Plugin&quot;,
		baseDataPath: &quot;options&quot;
	}
);

/**
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {Chunk} oldChunk the old chunk
 * @param {Chunk} newChunk the new chunk
 * @returns {(module: Module) =&gt; void} function to move module between chunks
 */
const moveModuleBetween = (chunkGraph, oldChunk, newChunk) =&gt; module =&gt; {
	chunkGraph.disconnectChunkAndModule(oldChunk, module);
	chunkGraph.connectChunkAndModule(newChunk, module);
};

/**
 * @param {ChunkGraph} chunkGraph the chunk graph
 * @param {Chunk} chunk the chunk
 * @returns {(module: Module) =&gt; boolean} filter for entry module
 */
const isNotAEntryModule = (chunkGraph, chunk) =&gt; module =&gt;
	!chunkGraph.isEntryModuleInChunk(module, chunk);

/** @type {WeakSet&lt;Chunk&gt;} */
const recordedChunks = new WeakSet();

const PLUGIN_NAME = &quot;AggressiveSplittingPlugin&quot;;

class AggressiveSplittingPlugin {
	/**
	 * @param {AggressiveSplittingPluginOptions=} options options object
	 */
	constructor(options = {}) {
		validate(options);

		this.options = options;
		if (typeof this.options.minSize !== &quot;number&quot;) {
			this.options.minSize = 30 * 1024;
		}
		if (typeof this.options.maxSize !== &quot;number&quot;) {
			this.options.maxSize = 50 * 1024;
		}
		if (typeof this.options.chunkOverhead !== &quot;number&quot;) {
			this.options.chunkOverhead = 0;
		}
		if (typeof this.options.entryChunkMultiplicator !== &quot;number&quot;) {
			this.options.entryChunkMultiplicator = 1;
		}
	}

	/**
	 * @param {Chunk} chunk the chunk to test
	 * @returns {boolean} true if the chunk was recorded
	 */
	static wasChunkRecorded(chunk) {
		return recordedChunks.has(chunk);
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation =&gt; {
			let needAdditionalSeal = false;
			/** @typedef {{ id?: NonNullable&lt;Chunk[&quot;id&quot;]&gt;, hash?: NonNullable&lt;Chunk[&quot;hash&quot;]&gt;, modules: Module[], size: number }} SplitData */
			/** @type {SplitData[]} */
			let newSplits;
			/** @type {Set&lt;Chunk&gt;} */
			let fromAggressiveSplittingSet;
			/** @type {Map&lt;Chunk, SplitData&gt;} */
			let chunkSplitDataMap;
			compilation.hooks.optimize.tap(PLUGIN_NAME, () =&gt; {
				newSplits = [];
				fromAggressiveSplittingSet = new Set();
				chunkSplitDataMap = new Map();
			});
			compilation.hooks.optimizeChunks.tap(
				{
					name: PLUGIN_NAME,
					stage: STAGE_ADVANCED
				},
				chunks =&gt; {
					const chunkGraph = compilation.chunkGraph;
					// Precompute stuff
					const nameToModuleMap = new Map();
					const moduleToNameMap = new Map();
					const makePathsRelative =
						identifierUtils.makePathsRelative.bindContextCache(
							compiler.context,
							compiler.root
						);
					for (const m of compilation.modules) {
						const name = makePathsRelative(m.identifier());
						nameToModuleMap.set(name, m);
						moduleToNameMap.set(m, name);
					}

					// Check used chunk ids
					const usedIds = new Set();
					for (const chunk of chunks) {
						usedIds.add(chunk.id);
					}

					const recordedSplits =
						(compilation.records &amp;&amp; compilation.records.aggressiveSplits) || [];
					const usedSplits = newSplits
						? recordedSplits.concat(newSplits)
						: recordedSplits;

					const minSize = /** @type {number} */ (this.options.minSize);
					const maxSize = /** @type {number} */ (this.options.maxSize);

					/**
					 * @param {SplitData} splitData split data
					 * @returns {boolean} true when applied, otherwise false
					 */
					const applySplit = splitData =&gt; {
						// Cannot split if id is already taken
						if (splitData.id !== undefined &amp;&amp; usedIds.has(splitData.id)) {
							return false;
						}

						// Get module objects from names
						const selectedModules = splitData.modules.map(name =&gt;
							nameToModuleMap.get(name)
						);

						// Does the modules exist at all?
						if (!selectedModules.every(Boolean)) return false;

						// Check if size matches (faster than waiting for hash)
						let size = 0;
						for (const m of selectedModules) size += m.size();
						if (size !== splitData.size) return false;

						// get chunks with all modules
						const selectedChunks = intersect(
							selectedModules.map(
								m =&gt; new Set(chunkGraph.getModuleChunksIterable(m))
							)
						);

						// No relevant chunks found
						if (selectedChunks.size === 0) return false;

						// The found chunk is already the split or similar
						if (
							selectedChunks.size === 1 &amp;&amp;
							chunkGraph.getNumberOfChunkModules(
								Array.from(selectedChunks)[0]
							) === selectedModules.length
						) {
							const chunk = Array.from(selectedChunks)[0];
							if (fromAggressiveSplittingSet.has(chunk)) return false;
							fromAggressiveSplittingSet.add(chunk);
							chunkSplitDataMap.set(chunk, splitData);
							return true;
						}

						// split the chunk into two parts
						const newChunk = compilation.addChunk();
						newChunk.chunkReason = &quot;aggressive splitted&quot;;
						for (const chunk of selectedChunks) {
							for (const module of selectedModules) {
								moveModuleBetween(chunkGraph, chunk, newChunk)(module);
							}
							chunk.split(newChunk);
							chunk.name = null;
						}
						fromAggressiveSplittingSet.add(newChunk);
						chunkSplitDataMap.set(newChunk, splitData);

						if (splitData.id !== null &amp;&amp; splitData.id !== undefined) {
							newChunk.id = splitData.id;
							newChunk.ids = [splitData.id];
						}
						return true;
					};

					// try to restore to recorded splitting
					let changed = false;
					for (let j = 0; j &lt; usedSplits.length; j++) {
						const splitData = usedSplits[j];
						if (applySplit(splitData)) changed = true;
					}

					// for any chunk which isn&#039;t splitted yet, split it and create a new entry
					// start with the biggest chunk
					const cmpFn = compareChunks(chunkGraph);
					const sortedChunks = Array.from(chunks).sort((a, b) =&gt; {
						const diff1 =
							chunkGraph.getChunkModulesSize(b) -
							chunkGraph.getChunkModulesSize(a);
						if (diff1) return diff1;
						const diff2 =
							chunkGraph.getNumberOfChunkModules(a) -
							chunkGraph.getNumberOfChunkModules(b);
						if (diff2) return diff2;
						return cmpFn(a, b);
					});
					for (const chunk of sortedChunks) {
						if (fromAggressiveSplittingSet.has(chunk)) continue;
						const size = chunkGraph.getChunkModulesSize(chunk);
						if (
							size &gt; maxSize &amp;&amp;
							chunkGraph.getNumberOfChunkModules(chunk) &gt; 1
						) {
							const modules = chunkGraph
								.getOrderedChunkModules(chunk, compareModulesByIdentifier)
								.filter(isNotAEntryModule(chunkGraph, chunk));
							const selectedModules = [];
							let selectedModulesSize = 0;
							for (let k = 0; k &lt; modules.length; k++) {
								const module = modules[k];
								const newSize = selectedModulesSize + module.size();
								if (newSize &gt; maxSize &amp;&amp; selectedModulesSize &gt;= minSize) {
									break;
								}
								selectedModulesSize = newSize;
								selectedModules.push(module);
							}
							if (selectedModules.length === 0) continue;
							/** @type {SplitData} */
							const splitData = {
								modules: selectedModules
									.map(m =&gt; moduleToNameMap.get(m))
									.sort(),
								size: selectedModulesSize
							};

							if (applySplit(splitData)) {
								newSplits = (newSplits || []).concat(splitData);
								changed = true;
							}
						}
					}
					if (changed) return true;
				}
			);
			compilation.hooks.recordHash.tap(PLUGIN_NAME, records =&gt; {
				// 4. save made splittings to records
				const allSplits = new Set();
				/** @type {Set&lt;SplitData&gt;} */
				const invalidSplits = new Set();

				// Check if some splittings are invalid
				// We remove invalid splittings and try again
				for (const chunk of compilation.chunks) {
					const splitData = chunkSplitDataMap.get(chunk);
					if (
						splitData !== undefined &amp;&amp;
						splitData.hash &amp;&amp;
						chunk.hash !== splitData.hash
					) {
						// Split was successful, but hash doesn&#039;t equal
						// We can throw away the split since it&#039;s useless now
						invalidSplits.add(splitData);
					}
				}

				if (invalidSplits.size &gt; 0) {
					records.aggressiveSplits =
						/** @type {SplitData[]} */
						(records.aggressiveSplits).filter(
							splitData =&gt; !invalidSplits.has(splitData)
						);
					needAdditionalSeal = true;
				} else {
					// set hash and id values on all (new) splittings
					for (const chunk of compilation.chunks) {
						const splitData = chunkSplitDataMap.get(chunk);
						if (splitData !== undefined) {
							splitData.hash =
								/** @type {NonNullable&lt;Chunk[&quot;hash&quot;]&gt;} */
								(chunk.hash);
							splitData.id =
								/** @type {NonNullable&lt;Chunk[&quot;id&quot;]&gt;} */
								(chunk.id);
							allSplits.add(splitData);
							// set flag for stats
							recordedChunks.add(chunk);
						}
					}

					// Also add all unused historical splits (after the used ones)
					// They can still be used in some future compilation
					const recordedSplits =
						compilation.records &amp;&amp; compilation.records.aggressiveSplits;
					if (recordedSplits) {
						for (const splitData of recordedSplits) {
							if (!invalidSplits.has(splitData)) allSplits.add(splitData);
						}
					}

					// record all splits
					records.aggressiveSplits = Array.from(allSplits);

					needAdditionalSeal = false;
				}
			});
			compilation.hooks.needAdditionalSeal.tap(PLUGIN_NAME, () =&gt; {
				if (needAdditionalSeal) {
					needAdditionalSeal = false;
					return true;
				}
			});
		});
	}
}
module.exports = AggressiveSplittingPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
