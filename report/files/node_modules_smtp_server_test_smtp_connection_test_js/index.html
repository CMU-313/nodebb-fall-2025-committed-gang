<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/smtp-server/test/smtp-connection-test.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/smtp-server/test/smtp-connection-test.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1666</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">127.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.72</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint no-unused-expressions:0, prefer-arrow-callback: 0 */

&#039;use strict&#039;;

const chai = require(&#039;chai&#039;);
const Client = require(&#039;nodemailer/lib/smtp-connection&#039;);
const XOAuth2 = require(&#039;nodemailer/lib/xoauth2&#039;);
const SMTPServer = require(&#039;../lib/smtp-server&#039;).SMTPServer;
const SMTPConnection = require(&#039;../lib/smtp-connection&#039;).SMTPConnection;
const net = require(&#039;net&#039;);
const pem = require(&#039;pem&#039;);

const expect = chai.expect;
const fs = require(&#039;fs&#039;);

chai.config.includeStack = true;

describe(&#039;SMTPServer&#039;, function () {
    this.timeout(10 * 1000); // eslint-disable-line no-invalid-this

    describe(&#039;Unit tests&#039;, function () {
        describe(&#039;#_parseAddressCommand&#039;, function () {
            it(&#039;should parse MAIL FROM/RCPT TO&#039;, function () {
                let conn = new SMTPConnection(
                    {
                        options: {}
                    },
                    {}
                );

                expect(conn._parseAddressCommand(&#039;MAIL FROM&#039;, &#039;MAIL FROM:&lt;test@example.com&gt;&#039;)).to.deep.equal({
                    address: &#039;test@example.com&#039;,
                    args: false
                });

                expect(conn._parseAddressCommand(&#039;MAIL FROM&#039;, &#039;MAIL FROM:&lt;sender@example.com&gt; SIZE=12345    RET=HDRS  &#039;)).to.deep.equal({
                    address: &#039;sender@example.com&#039;,
                    args: {
                        SIZE: &#039;12345&#039;,
                        RET: &#039;HDRS&#039;
                    }
                });

                expect(conn._parseAddressCommand(&#039;MAIL FROM&#039;, &#039;MAIL FROM : &lt;test@example.com&gt;&#039;)).to.deep.equal({
                    address: &#039;test@example.com&#039;,
                    args: false
                });

                expect(conn._parseAddressCommand(&#039;MAIL TO&#039;, &#039;MAIL FROM:&lt;test@example.com&gt;&#039;)).to.be.false;

                expect(conn._parseAddressCommand(&#039;MAIL FROM&#039;, &#039;MAIL FROM:&lt;sender@example.com&gt; CUSTOM=a+ABc+20foo&#039;)).to.deep.equal({
                    address: &#039;sender@example.com&#039;,
                    args: {
                        CUSTOM: &#039;a\xabc foo&#039;
                    }
                });
            });
        });
    });

    describe(&#039;Plaintext server&#039;, function () {
        let PORT;
        let server;

        beforeEach(function (done) {
            server = new SMTPServer({
                maxClients: 5,
                logger: false,
                socketTimeout: 2 * 1000
            });
            server.listen(0, &#039;127.0.0.1&#039;, (err) =&gt; {
              if (err) return done(err);
              PORT = server.server.address().port;
              done();
            });
        });

        afterEach(function (done) {
            server.close(done);
        });

        it(&#039;should connect without TLS&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                ignoreTLS: true
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                connection.quit();
            });
        });

        it(&#039;should connect with TLS&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                tls: {
                    rejectUnauthorized: false
                }
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                connection.quit();
            });
        });

        it(&#039;open multiple connections&#039;, function (done) {
            let limit = 5;
            let disconnected = 0;
            let connected = 0;
            let connections = [];

            let createConnection = function (callback) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;error&#039;, function (err) {
                    connected++;
                    expect(err).to.not.exist;
                    connection.close();
                });

                connection.on(&#039;end&#039;, function () {
                    disconnected++;
                    if (disconnected &gt;= limit) {
                        return done();
                    }
                });

                connection.connect(function () {
                    connected++;
                    callback(null, connection);
                });
            };

            let connCb = function (err, conn) {
                expect(err).to.not.exist;
                connections.push(conn);

                if (connected &gt;= limit) {
                    connections.forEach(function (connection) {
                        connection.close();
                    });
                }
            };

            for (let i = 0; i &lt; limit; i++) {
                createConnection(connCb);
            }
        });

        it(&#039;should reject too many connections&#039;, function (done) {
            let limit = 7;
            let expectedErrors = 2;
            let disconnected = 0;
            let connected = 0;
            let connections = [];

            let createConnection = function (callback) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;error&#039;, function (err) {
                    connected++;
                    if (!expectedErrors) {
                        expect(err).to.not.exist;
                    } else {
                        expectedErrors--;
                    }
                    connection.close();
                });

                connection.on(&#039;end&#039;, function () {
                    disconnected++;
                    if (disconnected &gt;= limit) {
                        return done();
                    }
                });

                connection.connect(function () {
                    connected++;
                    callback(null, connection);
                });
            };

            let connCb = function (err, conn) {
                expect(err).to.not.exist;
                connections.push(conn);

                if (connected &gt;= limit) {
                    connections.forEach(function (connection) {
                        connection.close();
                    });
                }
            };

            for (let i = 0; i &lt; limit; i++) {
                createConnection(connCb);
            }
        });

        it(&#039;should close on timeout&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                ignoreTLS: true
            });

            connection.on(&#039;error&#039;, function (err) {
                expect(err).to.exist;
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                // do nothing, wait until timeout occurs
            });
        });

        it(&#039;should close on timeout using secure socket&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                tls: {
                    rejectUnauthorized: false
                }
            });

            connection.on(&#039;error&#039;, function (err) {
                expect(err).to.exist;
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                // do nothing, wait until timeout occurs
            });
        });
    });

    describe(&#039;Plaintext server with no connection limit&#039;, function () {
        this.timeout(60 * 1000); // eslint-disable-line no-invalid-this

        let PORT = 1336;

        let server = new SMTPServer({
            logger: false,
            socketTimeout: 100 * 1000,
            closeTimeout: 6 * 1000
        });

        beforeEach(function (done) {
            server.listen(PORT, &#039;127.0.0.1&#039;, done);
        });

        it(&#039;open multiple connections and close all at once&#039;, function (done) {
            let limit = 100;
            let cleanClose = 4;

            let disconnected = 0;
            let connected = 0;
            let connections = [];

            let createConnection = function (callback) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;error&#039;, function (err) {
                    expect(err.responseCode).to.equal(421); // Server shutting down
                });

                connection.on(&#039;end&#039;, function () {
                    disconnected++;

                    if (disconnected &gt;= limit) {
                        return done();
                    }
                });

                connection.connect(function () {
                    connected++;
                    callback(null, connection);
                });
            };

            let connCb = function (err, conn) {
                expect(err).to.not.exist;
                connections.push(conn);

                if (connected &gt;= limit) {
                    server.close();
                    setTimeout(function () {
                        for (let i = 0; i &lt; cleanClose; i++) {
                            connections[i].quit();
                        }
                    }, 1000);
                } else {
                    createConnection(connCb);
                }
            };

            createConnection(connCb);
        });
    });

    describe(&#039;Plaintext server with hidden STARTTLS&#039;, function () {
        let PORT;
        let server;

        beforeEach(function (done) {
            server = new SMTPServer({
                maxClients: 5,
                hideSTARTTLS: true,
                logger: false,
                socketTimeout: 2 * 1000
            });
            server.listen(0, &#039;127.0.0.1&#039;, (err) =&gt; {
              if (err) return done(err);
              PORT = server.server.address().port;
              done();
            });
        });

        afterEach(function (done) {
            server.close(done);
        });

        it(&#039;should connect without TLS&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                expect(connection.secure).to.be.false;
                connection.quit();
            });
        });

        it(&#039;should connect with TLS&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                requireTLS: true,
                tls: {
                    rejectUnauthorized: false
                }
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                expect(connection.secure).to.be.true;
                connection.quit();
            });
        });
    });

    describe(&#039;Plaintext server with no STARTTLS&#039;, function () {
        let PORT;
        let server;

        beforeEach(function (done) {
            server = new SMTPServer({
                maxClients: 5,
                disabledCommands: [&#039;STARTTLS&#039;],
                logger: false,
                socketTimeout: 2 * 1000,
                onAuth(auth, session, callback) {
                    expect(session.tlsOptions).to.be.false;
                    if (auth.username === &#039;testuser&#039; &amp;&amp; auth.password === &#039;testpass&#039;) {
                        return callback(null, {
                            user: &#039;userdata&#039;
                        });
                    } else {
                        return callback(null, {
                            message: &#039;Authentication failed&#039;
                        });
                    }
                }
            });
            server.listen(0, &#039;127.0.0.1&#039;, (err) =&gt; {
              if (err) return done(err);
              PORT = server.server.address().port;
              done();
            });
        });

        afterEach(function (done) {
            server.close(done);
        });

        it(&#039;should connect without TLS&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                expect(connection.secure).to.be.false;
                connection.quit();
            });
        });

        it(&#039;should not connect with TLS&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                requireTLS: true,
                tls: {
                    rejectUnauthorized: false
                }
            });

            let error;

            connection.on(&#039;error&#039;, function (err) {
                error = err;
            });

            connection.on(&#039;end&#039;, function () {
                expect(error).to.exist;
                done();
            });

            connection.connect(function () {
                // should not be called
                expect(false).to.be.true;
                connection.quit();
            });
        });

        it(&#039;should close after too many unauthenticated commands&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                ignoreTLS: true
            });

            connection.on(&#039;error&#039;, function (err) {
                expect(err).to.exist;
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                let looper = function () {
                    connection._currentAction = function () {
                        looper();
                    };
                    connection._sendCommand(&#039;NOOP&#039;);
                };
                looper();
            });
        });

        it(&#039;should close after too many unrecognized commands&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                ignoreTLS: true
            });

            connection.on(&#039;error&#039;, function (err) {
                expect(err).to.exist;
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                connection.login(
                    {
                        user: &#039;testuser&#039;,
                        pass: &#039;testpass&#039;
                    },
                    function (err) {
                        expect(err).to.not.exist;

                        let looper = function () {
                            connection._currentAction = function () {
                                looper();
                            };
                            connection._sendCommand(&#039;ZOOP&#039;);
                        };
                        looper();
                    }
                );
            });
        });

        it(&#039;should reject early talker&#039;, function (done) {
            let socket = net.connect(PORT, &#039;127.0.0.1&#039;, function () {
                let buffers = [];
                socket.on(&#039;data&#039;, function (chunk) {
                    buffers.push(chunk);
                });
                socket.on(&#039;end&#039;, function () {
                    let data = Buffer.concat(buffers).toString();
                    expect(/^421 /.test(data)).to.be.true;
                    done();
                });
                socket.write(&#039;EHLO FOO\r\n&#039;);
            });
        });

        it(&#039;should reject HTTP requests&#039;, function (done) {
            let socket = net.connect(PORT, &#039;127.0.0.1&#039;, function () {
                let buffers = [];
                let started = false;
                socket.on(&#039;data&#039;, function (chunk) {
                    buffers.push(chunk);

                    if (!started) {
                        started = true;
                        socket.write(&#039;GET /path/file.html HTTP/1.0\r\nHost: www.example.com\r\n\r\n&#039;);
                    }
                });
                socket.on(&#039;end&#039;, function () {
                    let data = Buffer.concat(buffers).toString();
                    expect(/^421 /m.test(data)).to.be.true;
                    done();
                });
            });
        });
    });

    describe(&#039;Secure server&#039;, function () {
        let PORT = 1336;

        let server = new SMTPServer({
            secure: true,
            logger: false
        });

        beforeEach(function (done) {
            server.listen(PORT, &#039;127.0.0.1&#039;, done);
        });

        afterEach(function (done) {
            server.close(function () {
                done();
            });
        });

        it(&#039;should connect to secure server&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                secure: true,
                tls: {
                    rejectUnauthorized: false
                }
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                connection.quit();
            });
        });
    });

    describe(&#039;Secure server with upgrade&#039;, function () {
        let PORT = 1336;

        let server = new SMTPServer({
            secure: true,
            needsUpgrade: true,
            logger: false
        });

        beforeEach(function (done) {
            server.listen(PORT, &#039;127.0.0.1&#039;, done);
        });

        afterEach(function (done) {
            server.close(function () {
                done();
            });
        });

        it(&#039;should connect to secure server&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                secure: true,
                tls: {
                    rejectUnauthorized: false
                }
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                connection.quit();
            });
        });
    });

    describe(&#039;Secure server with cert update&#039;, function () {
        let PORT = 1336;
        let server;

        beforeEach(function (done) {
            pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) =&gt; {
                if (err) {
                    return done(err);
                }

                server = new SMTPServer({
                    secure: true,
                    logger: false,
                    key: keys.serviceKey,
                    cert: keys.certificate
                });

                server.listen(PORT, &#039;127.0.0.1&#039;, done);
            });
        });

        afterEach(function (done) {
            server.close(function () {
                done();
            });
        });

        it(&#039;should connect to secure server&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                secure: true,
                tls: {
                    rejectUnauthorized: false
                }
            });

            let firstFingerprint;

            connection.connect(() =&gt; {
                firstFingerprint = connection._socket.getPeerCertificate().fingerprint;
                connection.quit();
            });

            connection.on(&#039;end&#039;, () =&gt; {
                pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) =&gt; {
                    if (err) {
                        return done(err);
                    }

                    server.updateSecureContext({
                        key: keys.serviceKey,
                        cert: keys.certificate
                    });

                    setTimeout(() =&gt; {
                        let connection = new Client({
                            port: PORT,
                            host: &#039;127.0.0.1&#039;,
                            secure: true,
                            tls: {
                                rejectUnauthorized: false
                            }
                        });

                        connection.connect(() =&gt; {
                            let secondFingerprint = connection._socket.getPeerCertificate().fingerprint;
                            expect(firstFingerprint).to.not.equal(secondFingerprint);
                            connection.quit();
                        });

                        connection.on(&#039;end&#039;, done);
                    }, 1000);
                });
            });
        });
    });

    describe(&#039;Authentication tests&#039;, function () {
        let PORT;
        let server;

        beforeEach(function (done) {
            server = new SMTPServer({
                maxClients: 5,
                logger: false,
                authMethods: [&#039;PLAIN&#039;, &#039;LOGIN&#039;, &#039;XOAUTH2&#039;, &#039;CRAM-MD5&#039;],
                allowInsecureAuth: true,
                onAuth(auth, session, callback) {
                    expect(session.tlsOptions).to.exist;
                    if (auth.method === &#039;XOAUTH2&#039;) {
                        if (auth.username === &#039;testuser&#039; &amp;&amp; auth.accessToken === &#039;testtoken&#039;) {
                            return callback(null, {
                                user: &#039;userdata&#039;
                            });
                        } else {
                            return callback(null, {
                                data: {
                                    status: &#039;401&#039;,
                                    schemes: &#039;bearer mac&#039;,
                                    scope: &#039;https://mail.google.com/&#039;
                                }
                            });
                        }
                    } else if (auth.username === &#039;testuser&#039; &amp;&amp; (auth.method === &#039;CRAM-MD5&#039; ? auth.validatePassword(&#039;testpass&#039;) : auth.password === &#039;testpass&#039;)) {
                        return callback(null, {
                            user: &#039;userdata&#039;
                        });
                    } else {
                        return callback(null, {
                            message: &#039;Authentication failed&#039;
                        });
                    }
                }
            });
            server.listen(0, &#039;127.0.0.1&#039;, (err) =&gt; {
              if (err) return done(err);
              PORT = server.server.address().port;
              done();
            });
        });

        afterEach(function (done) {
            server.close(done);
        });

        describe(&#039;PLAIN&#039;, function () {
            it(&#039;should authenticate&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;testuser&#039;,
                            pass: &#039;testpass&#039;,
                            method: &#039;PLAIN&#039;
                        },
                        function (err) {
                            expect(err).to.not.exist;
                            connection.quit();
                        }
                    );
                });
            });

            it(&#039;should fail&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;zzzz&#039;,
                            pass: &#039;yyyy&#039;,
                            method: &#039;PLAIN&#039;
                        },
                        function (err) {
                            expect(err).to.exist;
                            connection.quit();
                        }
                    );
                });
            });
        });

        describe(&#039;LOGIN&#039;, function () {
            it(&#039;should authenticate&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    },
                    logger: false
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;testuser&#039;,
                            pass: &#039;testpass&#039;,
                            method: &#039;LOGIN&#039;
                        },
                        function (err) {
                            expect(err).to.not.exist;
                            connection.quit();
                        }
                    );
                });
            });

            it(&#039;should authenticate without STARTTLS&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    ignoreTLS: true,
                    logger: false
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;testuser&#039;,
                            pass: &#039;testpass&#039;,
                            method: &#039;LOGIN&#039;
                        },
                        function (err) {
                            expect(err).to.not.exist;
                            connection.quit();
                        }
                    );
                });
            });

            it(&#039;should fail&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;zzzz&#039;,
                            pass: &#039;yyyy&#039;,
                            method: &#039;LOGIN&#039;
                        },
                        function (err) {
                            expect(err).to.exist;
                            connection.quit();
                        }
                    );
                });
            });
        });

        describe(&#039;XOAUTH2&#039;, function () {
            it(&#039;should authenticate&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            type: &#039;oauth2&#039;,
                            user: &#039;testuser&#039;,
                            method: &#039;XOAUTH2&#039;,
                            oauth2: new XOAuth2(
                                {
                                    user: &#039;testuser&#039;,
                                    accessToken: &#039;testtoken&#039;
                                },
                                false
                            )
                        },
                        function (err) {
                            expect(err).to.not.exist;
                            connection.quit();
                        }
                    );
                });
            });

            it(&#039;should fail&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            type: &#039;oauth2&#039;,
                            user: &#039;zzzz&#039;,
                            method: &#039;XOAUTH2&#039;,
                            oauth2: new XOAuth2(
                                {
                                    user: &#039;zzzz&#039;,
                                    accessToken: &#039;testtoken&#039;
                                },
                                false
                            )
                        },
                        function (err) {
                            expect(err).to.exist;
                            connection.quit();
                        }
                    );
                });
            });
        });

        describe(&#039;CRAM-MD5&#039;, function () {
            it(&#039;should authenticate&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;testuser&#039;,
                            pass: &#039;testpass&#039;,
                            method: &#039;CRAM-MD5&#039;
                        },
                        function (err) {
                            expect(err).to.not.exist;
                            connection.quit();
                        }
                    );
                });
            });

            it(&#039;should fail&#039;, function (done) {
                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    tls: {
                        rejectUnauthorized: false
                    }
                });

                connection.on(&#039;end&#039;, done);

                connection.connect(function () {
                    connection.login(
                        {
                            user: &#039;zzzz&#039;,
                            pass: &#039;yyyy&#039;,
                            method: &#039;CRAM-MD5&#039;
                        },
                        function (err) {
                            expect(err).to.exist;
                            connection.quit();
                        }
                    );
                });
            });
        });
    });

    describe(&#039;Mail tests&#039;, function () {
        let PORT;

        let connection;

        let server;

        beforeEach(function (done) {
            server = new SMTPServer({
                maxClients: 5,
                logger: false,
                authMethods: [&#039;PLAIN&#039;, &#039;LOGIN&#039;, &#039;XOAUTH2&#039;],
                size: 1024
            });

            server.onAuth = function (auth, session, callback) {
                if (auth.username === &#039;testuser&#039; &amp;&amp; auth.password === &#039;testpass&#039;) {
                    return callback(null, {
                        user: &#039;userdata&#039;
                    });
                } else {
                    return callback(null, {
                        message: &#039;Authentication failed&#039;
                    });
                }
            };

            server.onMailFrom = function (address, session, callback) {
                if (/^deny/i.test(address.address)) {
                    return callback(new Error(&#039;Not accepted&#039;));
                }
                callback();
            };

            server.onRcptTo = function (address, session, callback) {
                if (/^deny/i.test(address.address)) {
                    return callback(new Error(&#039;Not accepted&#039;));
                }
                callback();
            };

            server.onData = function (stream, session, callback) {
                let chunks = [];
                let chunklen = 0;

                stream.on(&#039;data&#039;, chunk =&gt; {
                    chunks.push(chunk);
                    chunklen += chunk.length;
                });

                stream.on(&#039;end&#039;, () =&gt; {
                    let message = Buffer.concat(chunks, chunklen).toString();
                    let err;

                    if (/^deny/i.test(message)) {
                        return callback(new Error(&#039;Not queued&#039;));
                    } else if (stream.sizeExceeded) {
                        err = new Error(&#039;Maximum allowed message size 1kB exceeded&#039;);
                        err.statusCode = 552;
                        return callback(err);
                    }

                    callback(null, &#039;Message queued as abcdef&#039;); // accept the message once the stream is ended
                });
            };

            server.listen(0, &#039;127.0.0.1&#039;, (err) =&gt; {
              if (err) return done(err);
              PORT = server.server.address().port;
              connection = new Client({
                  port: PORT,
                  host: &#039;127.0.0.1&#039;,
                  tls: {
                      rejectUnauthorized: false
                  }
              });

              connection.connect(function () {
                  connection.login(
                      {
                          user: &#039;testuser&#039;,
                          pass: &#039;testpass&#039;
                      },
                      function (err) {
                          expect(err).to.not.exist;
                          done();
                      }
                  );
              });
            });
        });

        afterEach(function (done) {
            connection.on(&#039;end&#039;, function () {
                server.close(done);
            });
            connection.close();
        });

        it(&#039;should send&#039;, function (done) {
            connection.send(
                {
                    from: &#039;sender@example.com&#039;,
                    to: [&#039;recipient@exmaple.com&#039;]
                },
                &#039;testmessage&#039;,
                function (err, status) {
                    expect(err).to.not.exist;
                    expect(status.accepted.length).to.equal(1);
                    expect(status.rejected.length).to.equal(0);
                    done();
                }
            );
        });

        it(&#039;should reject single recipient&#039;, function (done) {
            connection.send(
                {
                    from: &#039;sender@example.com&#039;,
                    to: [&#039;recipient@exmaple.com&#039;, &#039;deny-recipient@example.com&#039;]
                },
                &#039;testmessage&#039;,
                function (err, status) {
                    expect(err).to.not.exist;
                    expect(status.accepted.length).to.equal(1);
                    expect(status.rejected.length).to.equal(1);
                    done();
                }
            );
        });

        it(&#039;should reject sender&#039;, function (done) {
            connection.send(
                {
                    from: &#039;deny-sender@example.com&#039;,
                    to: [&#039;recipient@exmaple.com&#039;]
                },
                &#039;testmessage&#039;,
                function (err) {
                    expect(err).to.exist;
                    done();
                }
            );
        });

        it(&#039;should reject recipients&#039;, function (done) {
            connection.send(
                {
                    from: &#039;sender@example.com&#039;,
                    to: [&#039;deny-recipient@exmaple.com&#039;]
                },
                &#039;testmessage&#039;,
                function (err) {
                    expect(err).to.exist;
                    done();
                }
            );
        });

        it(&#039;should reject message&#039;, function (done) {
            connection.send(
                {
                    from: &#039;sender@example.com&#039;,
                    to: [&#039;recipient@exmaple.com&#039;]
                },
                &#039;deny-testmessage&#039;,
                function (err) {
                    expect(err).to.exist;
                    done();
                }
            );
        });

        it(&#039;should reject too big message&#039;, function (done) {
            connection.send(
                {
                    from: &#039;sender@example.com&#039;,
                    to: [&#039;recipient@exmaple.com&#039;]
                },
                new Array(1000).join(&#039;testmessage&#039;),
                function (err) {
                    expect(err).to.exist;
                    done();
                }
            );
        });

        it(&#039;should send multiple messages&#039;, function (done) {
            connection.send(
                {
                    from: &#039;sender@example.com&#039;,
                    to: [&#039;recipient@exmaple.com&#039;]
                },
                &#039;testmessage 1&#039;,
                function (err, status) {
                    expect(err).to.not.exist;
                    expect(status.accepted.length).to.equal(1);
                    expect(status.rejected.length).to.equal(0);

                    connection.send(
                        {
                            from: &#039;sender@example.com&#039;,
                            to: [&#039;recipient@exmaple.com&#039;]
                        },
                        &#039;testmessage 2&#039;,
                        function (err, status) {
                            expect(err).to.not.exist;
                            expect(status.accepted.length).to.equal(1);
                            expect(status.rejected.length).to.equal(0);

                            connection.send(
                                {
                                    from: &#039;sender@example.com&#039;,
                                    to: [&#039;recipient@exmaple.com&#039;]
                                },
                                &#039;deny-testmessage&#039;,
                                function (err) {
                                    expect(err).to.exist;

                                    connection.send(
                                        {
                                            from: &#039;sender@example.com&#039;,
                                            to: [&#039;recipient@exmaple.com&#039;]
                                        },
                                        &#039;testmessage 3&#039;,
                                        function (err, status) {
                                            expect(err).to.not.exist;
                                            expect(status.accepted.length).to.equal(1);
                                            expect(status.rejected.length).to.equal(0);
                                            done();
                                        }
                                    );
                                }
                            );
                        }
                    );
                }
            );
        });
    });

    describe(&#039;SMTPUTF8&#039;, function () {
        it(&#039;should allow addresses with UTF-8 characters&#039;, function (done) {
            let utf8Address = &#039;δοκιμή@παράδειγμα.δοκιμή&#039;;
            let PORT = 1336;

            let connection;

            let server = new SMTPServer({
                logger: false,
                disabledCommands: [&#039;AUTH&#039;, &#039;STARTTLS&#039;]
            });

            server.onRcptTo = function (address, session, callback) {
                expect(utf8Address).to.equal(address.address);
                callback();
            };

            server.listen(PORT, &#039;127.0.0.1&#039;, function () {
                connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;
                });

                connection.on(&#039;end&#039;, function () {
                    server.close(done);
                });

                connection.connect(function () {
                    connection.send(
                        {
                            from: &#039;sender@example.com&#039;,
                            to: [utf8Address]
                        },
                        &#039;testmessage&#039;,
                        function (err, status) {
                            expect(err).to.not.exist;
                            expect(status.accepted.length).to.equal(1);
                            expect(status.rejected.length).to.equal(0);
                            connection.quit();
                        }
                    );
                });
            });
        });
    });

    describe(&#039;#onData&#039;, function () {
        it(&#039;should accept a prematurely called continue callback&#039;, function (done) {
            let PORT = 1336;

            let connection;

            let server = new SMTPServer({
                logger: false,
                disabledCommands: [&#039;AUTH&#039;, &#039;STARTTLS&#039;]
            });

            server.onData = function (stream, session, callback) {
                const nullDevice = process.platform === &#039;win32&#039; ? &#039;\\\\.\\NUL&#039; : &#039;/dev/null&#039;;
                stream.pipe(fs.createWriteStream(nullDevice));
                callback();
            };

            server.listen(PORT, &#039;127.0.0.1&#039;, function () {
                connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;
                });

                connection.on(&#039;end&#039;, function () {
                    server.close(done);
                });

                connection.connect(function () {
                    connection.send(
                        {
                            from: &#039;sender@example.com&#039;,
                            to: [&#039;receiver@example.com&#039;]
                        },
                        new Array(1024 * 1024).join(&#039;#&#039;),
                        function (err) {
                            expect(err).to.not.exist;
                            connection.quit();
                        }
                    );
                });
            });
        });
    });

    describe(&#039;PROXY server&#039;, function () {
        let PORT = 1336;

        let server = new SMTPServer({
            maxClients: 5,
            logger: false,
            useProxy: true,
            onConnect(session, callback) {
                if (session.remoteAddress === &#039;1.2.3.4&#039;) {
                    let err = new Error(&#039;Blacklisted IP&#039;);
                    err.responseCode = 421;
                    return callback(err);
                }
                callback();
            }
        });

        beforeEach(function (done) {
            server.listen(PORT, &#039;127.0.0.1&#039;, done);
        });

        afterEach(function (done) {
            server.close(done);
        });

        it(&#039;should rewrite remote address value&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                ignoreTLS: true
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                let conn;
                // get first connection
                server.connections.forEach(function (val) {
                    if (!conn) {
                        conn = val;
                    }
                });
                // default remote address should be overriden by the value from the PROXY header
                expect(conn.remoteAddress).to.equal(&#039;198.51.100.22&#039;);
                expect(conn.remotePort).to.equal(35646);
                connection.quit();
            });

            connection._socket.write(&#039;PROXY TCP4 198.51.100.22 203.0.113.7 35646 80\r\n&#039;);
        });

        it(&#039;should block blacklisted connection&#039;, function (done) {
            let socket = net.connect(PORT, &#039;127.0.0.1&#039;, function () {
                let buffers = [];
                socket.on(&#039;data&#039;, function (chunk) {
                    buffers.push(chunk);
                });
                socket.on(&#039;end&#039;, function () {
                    let data = Buffer.concat(buffers).toString();
                    expect(data.indexOf(&#039;421 &#039;)).to.equal(0);
                    expect(data.indexOf(&#039;Blacklisted&#039;)).to.gte(4);
                    done();
                });
                socket.write(&#039;PROXY TCP4 1.2.3.4 203.0.113.7 35646 80\r\n&#039;);
            });
        });
    });

    describe(&#039;Secure PROXY server&#039;, function () {
        let PORT = 1336;

        let server = new SMTPServer({
            maxClients: 5,
            logger: false,
            useProxy: true,
            secure: true,
            onConnect(session, callback) {
                if (session.remoteAddress === &#039;1.2.3.4&#039;) {
                    let err = new Error(&#039;Blacklisted IP&#039;);
                    err.responseCode = 421;
                    return callback(err);
                }
                callback();
            }
        });

        beforeEach(function (done) {
            server.listen(PORT, &#039;127.0.0.1&#039;, done);
        });

        afterEach(function (done) {
            server.close(done);
        });

        it(&#039;should rewrite remote address value&#039;, function (done) {
            let connection = new Client({
                port: PORT,
                host: &#039;127.0.0.1&#039;,
                tls: {
                    rejectUnauthorized: false
                }
            });

            connection.on(&#039;end&#039;, done);

            connection.connect(function () {
                let conn;
                // get first connection
                server.connections.forEach(function (val) {
                    if (!conn) {
                        conn = val;
                    }
                });
                // default remote address should be overriden by the value from the PROXY header
                expect(conn.remoteAddress).to.equal(&#039;198.51.100.22&#039;);
                expect(conn.remotePort).to.equal(35646);
                connection.quit();
            });

            connection._socket.write(&#039;PROXY TCP4 198.51.100.22 203.0.113.7 35646 80\r\n&#039;);
            connection._upgradeConnection(err =&gt; {
                expect(err).to.not.exist;
                // server should respond with greeting after this point
            });
        });
    });

    describe(&#039;onClose handler&#039;, function () {
        let PORT = 1336;

        it(&#039;should detect once a connection is closed&#039;, function (done) {
            let closed = 0;
            let total = 50;
            let server = new SMTPServer({
                logger: false,
                onClose(session) {
                    expect(session).to.exist;
                    expect(closed).to.be.lt(total);
                    if (++closed &gt;= total) {
                        server.close(done);
                    }
                }
            });

            server.listen(PORT, &#039;127.0.0.1&#039;, function () {
                let createConnection = function () {
                    let connection = new Client({
                        port: PORT,
                        host: &#039;127.0.0.1&#039;,
                        ignoreTLS: true
                    });

                    connection.connect(function () {
                        setTimeout(() =&gt; connection.quit(), 100);
                    });
                };
                for (let i = 0; i &lt; total; i++) {
                    createConnection();
                }
            });
        });
    });

    describe(&#039;onSecure handler&#039;, function () {
        let PORT = 1336;

        it(&#039;should detect once a connection is established with TLS&#039;, function (done) {
            let server;
            pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) =&gt; {
                if (err) {
                    return done(err);
                }

                let secureCount = 0;

                server = new SMTPServer({
                    secure: true,
                    logger: false,
                    key: keys.serviceKey,
                    cert: keys.certificate,

                    onSecure(socket, session, done) {
                        expect(session).to.exist;
                        expect(session.servername).to.equal(&#039;teretere1&#039;);
                        secureCount++;
                        done();
                    }
                });

                server.listen(PORT, &#039;127.0.0.1&#039;);

                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    secure: true,
                    tls: {
                        rejectUnauthorized: false,
                        servername: &#039;teretere1&#039;
                    }
                });

                connection.connect(function () {
                    setTimeout(() =&gt; {
                        connection.quit();
                        server.close(() =&gt; {
                            expect(secureCount).to.equal(1);
                            done();
                        });
                    }, 100);
                });

                connection.on(&#039;error&#039;, err =&gt; {
                    server.close(() =&gt; done(err));
                });
            });
        });

        it(&#039;should detect once a connection is upgraded to TLS&#039;, function (done) {
            let server;
            pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) =&gt; {
                if (err) {
                    return done(err);
                }

                let secureCount = 0;

                server = new SMTPServer({
                    secure: false,
                    logger: false,
                    key: keys.serviceKey,
                    cert: keys.certificate,

                    onSecure(socket, session, done) {
                        expect(session).to.exist;
                        expect(session.servername).to.equal(&#039;teretere2&#039;);
                        secureCount++;
                        done();
                    },
                    onConnect(session, done) {
                        done();
                    }
                });

                server.listen(PORT, &#039;127.0.0.1&#039;);

                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    secure: false,
                    tls: {
                        rejectUnauthorized: false,
                        servername: &#039;teretere2&#039;
                    }
                });

                connection.connect(function () {
                    setTimeout(() =&gt; {
                        connection.quit();
                        server.close(() =&gt; {
                            expect(secureCount).to.equal(1);
                            done();
                        });
                    }, 100);
                });

                connection.on(&#039;error&#039;, err =&gt; {
                    server.close(() =&gt; done(err));
                });
            });
        });

        it(&#039;onSecure is not triggered for cleartext connections&#039;, function (done) {
            let server;
            pem.createCertificate({ days: 1, selfSigned: true }, (err, keys) =&gt; {
                if (err) {
                    return done(err);
                }

                let secureCount = 0;

                server = new SMTPServer({
                    secure: false,
                    logger: false,
                    key: keys.serviceKey,
                    cert: keys.certificate,

                    onSecure(socket, session, done) {
                        expect(session).to.exist;
                        expect(session.servername).to.equal(&#039;teretere2&#039;);
                        secureCount++;
                        done();
                    },

                    onConnect(session, done) {
                        done();
                    }
                });

                server.listen(PORT, &#039;127.0.0.1&#039;);

                let connection = new Client({
                    port: PORT,
                    host: &#039;127.0.0.1&#039;,
                    secure: false,
                    ignoreTLS: true,
                    tls: {
                        rejectUnauthorized: false,
                        servername: &#039;teretere2&#039;
                    }
                });

                connection.connect(function () {
                    setTimeout(() =&gt; {
                        connection.quit();
                        server.close(() =&gt; {
                            expect(secureCount).to.equal(0);
                            done();
                        });
                    }, 100);
                });

                connection.on(&#039;error&#039;, err =&gt; {
                    server.close(() =&gt; done(err));
                });
            });
        });
    });
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
