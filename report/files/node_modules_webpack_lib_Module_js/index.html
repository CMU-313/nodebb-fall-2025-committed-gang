<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/Module.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/Module.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1237</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">46.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.45</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const util = require(&quot;util&quot;);
const ChunkGraph = require(&quot;./ChunkGraph&quot;);
const DependenciesBlock = require(&quot;./DependenciesBlock&quot;);
const ModuleGraph = require(&quot;./ModuleGraph&quot;);
const { JS_TYPES } = require(&quot;./ModuleSourceTypesConstants&quot;);
const RuntimeGlobals = require(&quot;./RuntimeGlobals&quot;);
const { first } = require(&quot;./util/SetHelpers&quot;);
const { compareChunksById } = require(&quot;./util/comparators&quot;);
const makeSerializable = require(&quot;./util/makeSerializable&quot;);

/** @typedef {import(&quot;webpack-sources&quot;).Source} Source */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).ResolveOptions} ResolveOptions */
/** @typedef {import(&quot;../declarations/WebpackOptions&quot;).WebpackOptionsNormalized} WebpackOptions */
/** @typedef {import(&quot;./Chunk&quot;)} Chunk */
/** @typedef {import(&quot;./ChunkGraph&quot;).ModuleId} ModuleId */
/** @typedef {import(&quot;./ChunkGroup&quot;)} ChunkGroup */
/** @typedef {import(&quot;./CodeGenerationResults&quot;)} CodeGenerationResults */
/** @typedef {import(&quot;./Compilation&quot;)} Compilation */
/** @typedef {import(&quot;./Compilation&quot;).AssetInfo} AssetInfo */
/** @typedef {import(&quot;./Compilation&quot;).UnsafeCacheData} UnsafeCacheData */
/** @typedef {import(&quot;./ConcatenationScope&quot;)} ConcatenationScope */
/** @typedef {import(&quot;./Dependency&quot;)} Dependency */
/** @typedef {import(&quot;./Dependency&quot;).UpdateHashContext} UpdateHashContext */
/** @typedef {import(&quot;./DependencyTemplate&quot;).CssData} CssData */
/** @typedef {import(&quot;./DependencyTemplates&quot;)} DependencyTemplates */
/** @typedef {import(&quot;./ExportsInfo&quot;).UsageStateType} UsageStateType */
/** @typedef {import(&quot;./FileSystemInfo&quot;)} FileSystemInfo */
/** @typedef {import(&quot;./FileSystemInfo&quot;).Snapshot} Snapshot */
/** @typedef {import(&quot;./ModuleGraphConnection&quot;).ConnectionState} ConnectionState */
/** @typedef {import(&quot;./ModuleTypeConstants&quot;).ModuleTypes} ModuleTypes */
/** @typedef {import(&quot;./NormalModuleFactory&quot;)} NormalModuleFactory */
/** @typedef {import(&quot;./RequestShortener&quot;)} RequestShortener */
/** @typedef {import(&quot;./ResolverFactory&quot;).ResolverWithOptions} ResolverWithOptions */
/** @typedef {import(&quot;./RuntimeTemplate&quot;)} RuntimeTemplate */
/** @typedef {import(&quot;./WebpackError&quot;)} WebpackError */
/** @typedef {import(&quot;./serialization/ObjectMiddleware&quot;).ObjectDeserializerContext} ObjectDeserializerContext */
/** @typedef {import(&quot;./serialization/ObjectMiddleware&quot;).ObjectSerializerContext} ObjectSerializerContext */
/** @typedef {import(&quot;./util/Hash&quot;)} Hash */
/** @typedef {import(&quot;./util/fs&quot;).InputFileSystem} InputFileSystem */
/** @typedef {import(&quot;./util/identifier&quot;).AssociatedObjectForCache} AssociatedObjectForCache */
/** @typedef {import(&quot;./util/runtime&quot;).RuntimeSpec} RuntimeSpec */

/**
 * @template T
 * @typedef {import(&quot;./util/LazySet&quot;)&lt;T&gt;} LazySet&lt;T&gt;
 */

/**
 * @template T
 * @typedef {import(&quot;./util/SortableSet&quot;)&lt;T&gt;} SortableSet&lt;T&gt;
 */

/**
 * @typedef {object} SourceContext
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {RuntimeSpec} runtime the runtimes code should be generated for
 * @property {string=} type the type of source that should be generated
 */

/** @typedef {ReadonlySet&lt;string&gt;} SourceTypes */

// TODO webpack 6: compilation will be required in CodeGenerationContext
/**
 * @typedef {object} CodeGenerationContext
 * @property {DependencyTemplates} dependencyTemplates the dependency templates
 * @property {RuntimeTemplate} runtimeTemplate the runtime template
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 * @property {RuntimeSpec} runtime the runtimes code should be generated for
 * @property {ConcatenationScope=} concatenationScope when in concatenated module, information about other concatenated modules
 * @property {CodeGenerationResults | undefined} codeGenerationResults code generation results of other modules (need to have a codeGenerationDependency to use that)
 * @property {Compilation=} compilation the compilation
 * @property {SourceTypes=} sourceTypes source types
 */

/**
 * @typedef {object} ConcatenationBailoutReasonContext
 * @property {ModuleGraph} moduleGraph the module graph
 * @property {ChunkGraph} chunkGraph the chunk graph
 */

/** @typedef {Set&lt;string&gt;} RuntimeRequirements */
/** @typedef {ReadonlySet&lt;string&gt;} ReadOnlyRuntimeRequirements */

/**
 * @typedef {object} CodeGenerationResult
 * @property {Map&lt;string, Source&gt;} sources the resulting sources for all source types
 * @property {Map&lt;string, TODO&gt;=} data the resulting data for all source types
 * @property {ReadOnlyRuntimeRequirements | null} runtimeRequirements the runtime requirements
 * @property {string=} hash a hash of the code generation result (will be automatically calculated from sources and runtimeRequirements if not provided)
 */

/**
 * @typedef {object} LibIdentOptions
 * @property {string} context absolute context path to which lib ident is relative to
 * @property {AssociatedObjectForCache=} associatedObjectForCache object for caching
 */

/**
 * @typedef {object} KnownBuildMeta
 * @property {(&quot;default&quot; | &quot;namespace&quot; | &quot;flagged&quot; | &quot;dynamic&quot;)=} exportsType
 * @property {(false | &quot;redirect&quot; | &quot;redirect-warn&quot;)=} defaultObject
 * @property {boolean=} strictHarmonyModule
 * @property {boolean=} async
 * @property {boolean=} sideEffectFree
 * @property {Record&lt;string, string&gt;=} exportsFinalName
 * @property {boolean=} isCSSModule
 */

/**
 * @typedef {object} KnownBuildInfo
 * @property {boolean=} cacheable
 * @property {boolean=} parsed
 * @property {boolean=} strict
 * @property {string=} moduleArgument using in AMD
 * @property {string=} exportsArgument using in AMD
 * @property {string=} moduleConcatenationBailout using in CommonJs
 * @property {boolean=} needCreateRequire using in APIPlugin
 * @property {string=} resourceIntegrity using in HttpUriPlugin
 * @property {LazySet&lt;string&gt;=} fileDependencies using in NormalModule
 * @property {LazySet&lt;string&gt;=} contextDependencies using in NormalModule
 * @property {LazySet&lt;string&gt;=} missingDependencies using in NormalModule
 * @property {LazySet&lt;string&gt;=} buildDependencies using in NormalModule
 * @property {ValueCacheVersions=} valueDependencies using in NormalModule
 * @property {Record&lt;string, Source&gt;=} assets using in NormalModule
 * @property {string=} hash using in NormalModule
 * @property {(Snapshot | null)=} snapshot using in ContextModule
 * @property {string=} fullContentHash for assets modules
 * @property {string=} filename for assets modules
 * @property {Map&lt;string, AssetInfo | undefined&gt;=} assetsInfo for assets modules
 * @property {boolean=} dataUrl for assets modules
 * @property {CssData=} cssData for css modules
 */

/** @typedef {Map&lt;string, string | Set&lt;string&gt;&gt;} ValueCacheVersions */

/**
 * @typedef {object} NeedBuildContext
 * @property {Compilation} compilation
 * @property {FileSystemInfo} fileSystemInfo
 * @property {ValueCacheVersions} valueCacheVersions
 */

/** @typedef {(err?: WebpackError | null, needBuild?: boolean) =&gt; void} NeedBuildCallback */

/** @typedef {(err?: WebpackError) =&gt; void} BuildCallback */

/** @typedef {KnownBuildMeta &amp; Record&lt;string, EXPECTED_ANY&gt;} BuildMeta */
/** @typedef {KnownBuildInfo &amp; Record&lt;string, EXPECTED_ANY&gt;} BuildInfo */

/**
 * @typedef {object} FactoryMeta
 * @property {boolean=} sideEffectFree
 */

const EMPTY_RESOLVE_OPTIONS = {};

let debugId = 1000;

const DEFAULT_TYPES_UNKNOWN = new Set([&quot;unknown&quot;]);

const deprecatedNeedRebuild = util.deprecate(
	/**
	 * @param {Module} module the module
	 * @param {NeedBuildContext} context context info
	 * @returns {boolean} true, when rebuild is needed
	 */
	(module, context) =&gt;
		module.needRebuild(
			context.fileSystemInfo.getDeprecatedFileTimestamps(),
			context.fileSystemInfo.getDeprecatedContextTimestamps()
		),
	&quot;Module.needRebuild is deprecated in favor of Module.needBuild&quot;,
	&quot;DEP_WEBPACK_MODULE_NEED_REBUILD&quot;
);

/** @typedef {(requestShortener: RequestShortener) =&gt; string} OptimizationBailoutFunction */

class Module extends DependenciesBlock {
	/**
	 * @param {ModuleTypes | &quot;&quot;} type the module type, when deserializing the type is not known and is an empty string
	 * @param {(string | null)=} context an optional context
	 * @param {(string | null)=} layer an optional layer in which the module is
	 */
	constructor(type, context = null, layer = null) {
		super();

		/** @type {ModuleTypes} */
		this.type = type;
		/** @type {string | null} */
		this.context = context;
		/** @type {string | null} */
		this.layer = layer;
		/** @type {boolean} */
		this.needId = true;

		// Unique Id
		/** @type {number} */
		this.debugId = debugId++;

		// Info from Factory
		/** @type {ResolveOptions | undefined} */
		this.resolveOptions = EMPTY_RESOLVE_OPTIONS;
		/** @type {FactoryMeta | undefined} */
		this.factoryMeta = undefined;
		// TODO refactor this -&gt; options object filled from Factory
		// TODO webpack 6: use an enum
		/** @type {boolean} */
		this.useSourceMap = false;
		/** @type {boolean} */
		this.useSimpleSourceMap = false;

		// Is in hot context, i.e. HotModuleReplacementPlugin.js enabled
		// TODO do we need hot here?
		/** @type {boolean} */
		this.hot = false;
		// Info from Build
		/** @type {WebpackError[] | undefined} */
		this._warnings = undefined;
		/** @type {WebpackError[] | undefined} */
		this._errors = undefined;
		/** @type {BuildMeta | undefined} */
		this.buildMeta = undefined;
		/** @type {BuildInfo | undefined} */
		this.buildInfo = undefined;
		/** @type {Dependency[] | undefined} */
		this.presentationalDependencies = undefined;
		/** @type {Dependency[] | undefined} */
		this.codeGenerationDependencies = undefined;
	}

	// TODO remove in webpack 6
	// BACKWARD-COMPAT START
	/**
	 * @returns {ModuleId | null} module id
	 */
	get id() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.id&quot;,
			&quot;DEP_WEBPACK_MODULE_ID&quot;
		).getModuleId(this);
	}

	/**
	 * @param {ModuleId} value value
	 */
	set id(value) {
		if (value === &quot;&quot;) {
			this.needId = false;
			return;
		}
		ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.id&quot;,
			&quot;DEP_WEBPACK_MODULE_ID&quot;
		).setModuleId(this, value);
	}

	/**
	 * @returns {string} the hash of the module
	 */
	get hash() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.hash&quot;,
			&quot;DEP_WEBPACK_MODULE_HASH&quot;
		).getModuleHash(this, undefined);
	}

	/**
	 * @returns {string} the shortened hash of the module
	 */
	get renderedHash() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.renderedHash&quot;,
			&quot;DEP_WEBPACK_MODULE_RENDERED_HASH&quot;
		).getRenderedModuleHash(this, undefined);
	}

	get profile() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.profile&quot;,
			&quot;DEP_WEBPACK_MODULE_PROFILE&quot;
		).getProfile(this);
	}

	set profile(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.profile&quot;,
			&quot;DEP_WEBPACK_MODULE_PROFILE&quot;
		).setProfile(this, value);
	}

	/**
	 * @returns {number | null} the pre order index
	 */
	get index() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.index&quot;,
			&quot;DEP_WEBPACK_MODULE_INDEX&quot;
		).getPreOrderIndex(this);
	}

	/**
	 * @param {number} value the pre order index
	 */
	set index(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.index&quot;,
			&quot;DEP_WEBPACK_MODULE_INDEX&quot;
		).setPreOrderIndex(this, value);
	}

	/**
	 * @returns {number | null} the post order index
	 */
	get index2() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.index2&quot;,
			&quot;DEP_WEBPACK_MODULE_INDEX2&quot;
		).getPostOrderIndex(this);
	}

	/**
	 * @param {number} value the post order index
	 */
	set index2(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.index2&quot;,
			&quot;DEP_WEBPACK_MODULE_INDEX2&quot;
		).setPostOrderIndex(this, value);
	}

	/**
	 * @returns {number | null} the depth
	 */
	get depth() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.depth&quot;,
			&quot;DEP_WEBPACK_MODULE_DEPTH&quot;
		).getDepth(this);
	}

	/**
	 * @param {number} value the depth
	 */
	set depth(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.depth&quot;,
			&quot;DEP_WEBPACK_MODULE_DEPTH&quot;
		).setDepth(this, value);
	}

	/**
	 * @returns {Module | null | undefined} issuer
	 */
	get issuer() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.issuer&quot;,
			&quot;DEP_WEBPACK_MODULE_ISSUER&quot;
		).getIssuer(this);
	}

	/**
	 * @param {Module | null} value issuer
	 */
	set issuer(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.issuer&quot;,
			&quot;DEP_WEBPACK_MODULE_ISSUER&quot;
		).setIssuer(this, value);
	}

	get usedExports() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.usedExports&quot;,
			&quot;DEP_WEBPACK_MODULE_USED_EXPORTS&quot;
		).getUsedExports(this, undefined);
	}

	/**
	 * @deprecated
	 * @returns {(string | OptimizationBailoutFunction)[]} list
	 */
	get optimizationBailout() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.optimizationBailout&quot;,
			&quot;DEP_WEBPACK_MODULE_OPTIMIZATION_BAILOUT&quot;
		).getOptimizationBailout(this);
	}

	get optional() {
		return this.isOptional(
			ModuleGraph.getModuleGraphForModule(
				this,
				&quot;Module.optional&quot;,
				&quot;DEP_WEBPACK_MODULE_OPTIONAL&quot;
			)
		);
	}

	/**
	 * @param {Chunk} chunk the chunk
	 * @returns {boolean} true, when the module was added
	 */
	addChunk(chunk) {
		const chunkGraph = ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.addChunk&quot;,
			&quot;DEP_WEBPACK_MODULE_ADD_CHUNK&quot;
		);
		if (chunkGraph.isModuleInChunk(this, chunk)) return false;
		chunkGraph.connectChunkAndModule(chunk, this);
		return true;
	}

	/**
	 * @param {Chunk} chunk the chunk
	 * @returns {void}
	 */
	removeChunk(chunk) {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.removeChunk&quot;,
			&quot;DEP_WEBPACK_MODULE_REMOVE_CHUNK&quot;
		).disconnectChunkAndModule(chunk, this);
	}

	/**
	 * @param {Chunk} chunk the chunk
	 * @returns {boolean} true, when the module is in the chunk
	 */
	isInChunk(chunk) {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.isInChunk&quot;,
			&quot;DEP_WEBPACK_MODULE_IS_IN_CHUNK&quot;
		).isModuleInChunk(this, chunk);
	}

	isEntryModule() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.isEntryModule&quot;,
			&quot;DEP_WEBPACK_MODULE_IS_ENTRY_MODULE&quot;
		).isEntryModule(this);
	}

	getChunks() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.getChunks&quot;,
			&quot;DEP_WEBPACK_MODULE_GET_CHUNKS&quot;
		).getModuleChunks(this);
	}

	getNumberOfChunks() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.getNumberOfChunks&quot;,
			&quot;DEP_WEBPACK_MODULE_GET_NUMBER_OF_CHUNKS&quot;
		).getNumberOfModuleChunks(this);
	}

	get chunksIterable() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.chunksIterable&quot;,
			&quot;DEP_WEBPACK_MODULE_CHUNKS_ITERABLE&quot;
		).getOrderedModuleChunksIterable(this, compareChunksById);
	}

	/**
	 * @param {string} exportName a name of an export
	 * @returns {boolean | null} true, if the export is provided why the module.
	 * null, if it&#039;s unknown.
	 * false, if it&#039;s not provided.
	 */
	isProvided(exportName) {
		return ModuleGraph.getModuleGraphForModule(
			this,
			&quot;Module.usedExports&quot;,
			&quot;DEP_WEBPACK_MODULE_USED_EXPORTS&quot;
		).isExportProvided(this, exportName);
	}
	// BACKWARD-COMPAT END

	/**
	 * @returns {string} name of the exports argument
	 */
	get exportsArgument() {
		return (this.buildInfo &amp;&amp; this.buildInfo.exportsArgument) || &quot;exports&quot;;
	}

	/**
	 * @returns {string} name of the module argument
	 */
	get moduleArgument() {
		return (this.buildInfo &amp;&amp; this.buildInfo.moduleArgument) || &quot;module&quot;;
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {boolean | undefined} strict the importing module is strict
	 * @returns {&quot;namespace&quot; | &quot;default-only&quot; | &quot;default-with-named&quot; | &quot;dynamic&quot;} export type
	 * &quot;namespace&quot;: Exports is already a namespace object. namespace = exports.
	 * &quot;dynamic&quot;: Check at runtime if __esModule is set. When set: namespace = { ...exports, default: exports }. When not set: namespace = { default: exports }.
	 * &quot;default-only&quot;: Provide a namespace object with only default export. namespace = { default: exports }
	 * &quot;default-with-named&quot;: Provide a namespace object with named and default export. namespace = { ...exports, default: exports }
	 */
	getExportsType(moduleGraph, strict) {
		switch (this.buildMeta &amp;&amp; this.buildMeta.exportsType) {
			case &quot;flagged&quot;:
				return strict ? &quot;default-with-named&quot; : &quot;namespace&quot;;
			case &quot;namespace&quot;:
				return &quot;namespace&quot;;
			case &quot;default&quot;:
				switch (/** @type {BuildMeta} */ (this.buildMeta).defaultObject) {
					case &quot;redirect&quot;:
						return &quot;default-with-named&quot;;
					case &quot;redirect-warn&quot;:
						return strict ? &quot;default-only&quot; : &quot;default-with-named&quot;;
					default:
						return &quot;default-only&quot;;
				}
			case &quot;dynamic&quot;: {
				if (strict) return &quot;default-with-named&quot;;
				// Try to figure out value of __esModule by following reexports
				const handleDefault = () =&gt; {
					switch (/** @type {BuildMeta} */ (this.buildMeta).defaultObject) {
						case &quot;redirect&quot;:
						case &quot;redirect-warn&quot;:
							return &quot;default-with-named&quot;;
						default:
							return &quot;default-only&quot;;
					}
				};
				const exportInfo = moduleGraph.getReadOnlyExportInfo(
					this,
					&quot;__esModule&quot;
				);
				if (exportInfo.provided === false) {
					return handleDefault();
				}
				const target = exportInfo.getTarget(moduleGraph);
				if (
					!target ||
					!target.export ||
					target.export.length !== 1 ||
					target.export[0] !== &quot;__esModule&quot;
				) {
					return &quot;dynamic&quot;;
				}
				switch (
					target.module.buildMeta &amp;&amp;
					target.module.buildMeta.exportsType
				) {
					case &quot;flagged&quot;:
					case &quot;namespace&quot;:
						return &quot;namespace&quot;;
					case &quot;default&quot;:
						return handleDefault();
					default:
						return &quot;dynamic&quot;;
				}
			}
			default:
				return strict ? &quot;default-with-named&quot; : &quot;dynamic&quot;;
		}
	}

	/**
	 * @param {Dependency} presentationalDependency dependency being tied to module.
	 * This is a Dependency without edge in the module graph. It&#039;s only for presentation.
	 * @returns {void}
	 */
	addPresentationalDependency(presentationalDependency) {
		if (this.presentationalDependencies === undefined) {
			this.presentationalDependencies = [];
		}
		this.presentationalDependencies.push(presentationalDependency);
	}

	/**
	 * @param {Dependency} codeGenerationDependency dependency being tied to module.
	 * This is a Dependency where the code generation result of the referenced module is needed during code generation.
	 * The Dependency should also be added to normal dependencies via addDependency.
	 * @returns {void}
	 */
	addCodeGenerationDependency(codeGenerationDependency) {
		if (this.codeGenerationDependencies === undefined) {
			this.codeGenerationDependencies = [];
		}
		this.codeGenerationDependencies.push(codeGenerationDependency);
	}

	/**
	 * Removes all dependencies and blocks
	 * @returns {void}
	 */
	clearDependenciesAndBlocks() {
		if (this.presentationalDependencies !== undefined) {
			this.presentationalDependencies.length = 0;
		}
		if (this.codeGenerationDependencies !== undefined) {
			this.codeGenerationDependencies.length = 0;
		}
		super.clearDependenciesAndBlocks();
	}

	/**
	 * @param {WebpackError} warning the warning
	 * @returns {void}
	 */
	addWarning(warning) {
		if (this._warnings === undefined) {
			this._warnings = [];
		}
		this._warnings.push(warning);
	}

	/**
	 * @returns {Iterable&lt;WebpackError&gt; | undefined} list of warnings if any
	 */
	getWarnings() {
		return this._warnings;
	}

	/**
	 * @returns {number} number of warnings
	 */
	getNumberOfWarnings() {
		return this._warnings !== undefined ? this._warnings.length : 0;
	}

	/**
	 * @param {WebpackError} error the error
	 * @returns {void}
	 */
	addError(error) {
		if (this._errors === undefined) {
			this._errors = [];
		}
		this._errors.push(error);
	}

	/**
	 * @returns {Iterable&lt;WebpackError&gt; | undefined} list of errors if any
	 */
	getErrors() {
		return this._errors;
	}

	/**
	 * @returns {number} number of errors
	 */
	getNumberOfErrors() {
		return this._errors !== undefined ? this._errors.length : 0;
	}

	/**
	 * removes all warnings and errors
	 * @returns {void}
	 */
	clearWarningsAndErrors() {
		if (this._warnings !== undefined) {
			this._warnings.length = 0;
		}
		if (this._errors !== undefined) {
			this._errors.length = 0;
		}
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @returns {boolean} true, if the module is optional
	 */
	isOptional(moduleGraph) {
		let hasConnections = false;
		for (const r of moduleGraph.getIncomingConnections(this)) {
			if (
				!r.dependency ||
				!r.dependency.optional ||
				!r.isTargetActive(undefined)
			) {
				return false;
			}
			hasConnections = true;
		}
		return hasConnections;
	}

	/**
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @param {Chunk} chunk a chunk
	 * @param {Chunk=} ignoreChunk chunk to be ignored
	 * @returns {boolean} true, if the module is accessible from &quot;chunk&quot; when ignoring &quot;ignoreChunk&quot;
	 */
	isAccessibleInChunk(chunkGraph, chunk, ignoreChunk) {
		// Check if module is accessible in ALL chunk groups
		for (const chunkGroup of chunk.groupsIterable) {
			if (!this.isAccessibleInChunkGroup(chunkGraph, chunkGroup)) return false;
		}
		return true;
	}

	/**
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @param {ChunkGroup} chunkGroup a chunk group
	 * @param {Chunk=} ignoreChunk chunk to be ignored
	 * @returns {boolean} true, if the module is accessible from &quot;chunkGroup&quot; when ignoring &quot;ignoreChunk&quot;
	 */
	isAccessibleInChunkGroup(chunkGraph, chunkGroup, ignoreChunk) {
		const queue = new Set([chunkGroup]);

		// Check if module is accessible from all items of the queue
		queueFor: for (const cg of queue) {
			// 1. If module is in one of the chunks of the group we can continue checking the next items
			//    because it&#039;s accessible.
			for (const chunk of cg.chunks) {
				if (chunk !== ignoreChunk &amp;&amp; chunkGraph.isModuleInChunk(this, chunk))
					continue queueFor;
			}
			// 2. If the chunk group is initial, we can break here because it&#039;s not accessible.
			if (chunkGroup.isInitial()) return false;
			// 3. Enqueue all parents because it must be accessible from ALL parents
			for (const parent of chunkGroup.parentsIterable) queue.add(parent);
		}
		// When we processed through the whole list and we didn&#039;t bailout, the module is accessible
		return true;
	}

	/**
	 * @param {Chunk} chunk a chunk
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {ChunkGraph} chunkGraph the chunk graph
	 * @returns {boolean} true, if the module has any reason why &quot;chunk&quot; should be included
	 */
	hasReasonForChunk(chunk, moduleGraph, chunkGraph) {
		// check for each reason if we need the chunk
		for (const [
			fromModule,
			connections
		] of moduleGraph.getIncomingConnectionsByOriginModule(this)) {
			if (!connections.some(c =&gt; c.isTargetActive(chunk.runtime))) continue;
			for (const originChunk of chunkGraph.getModuleChunksIterable(
				/** @type {Module} */ (fromModule)
			)) {
				// return true if module this is not reachable from originChunk when ignoring chunk
				if (!this.isAccessibleInChunk(chunkGraph, originChunk, chunk))
					return true;
			}
		}
		return false;
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @param {RuntimeSpec} runtime the runtime
	 * @returns {boolean} true if at least one other module depends on this module
	 */
	hasReasons(moduleGraph, runtime) {
		for (const c of moduleGraph.getIncomingConnections(this)) {
			if (c.isTargetActive(runtime)) return true;
		}
		return false;
	}

	/**
	 * @returns {string} for debugging
	 */
	toString() {
		return `Module[${this.debugId}: ${this.identifier()}]`;
	}

	/**
	 * @param {NeedBuildContext} context context info
	 * @param {NeedBuildCallback} callback callback function, returns true, if the module needs a rebuild
	 * @returns {void}
	 */
	needBuild(context, callback) {
		callback(
			null,
			!this.buildMeta ||
				this.needRebuild === Module.prototype.needRebuild ||
				deprecatedNeedRebuild(this, context)
		);
	}

	/**
	 * @deprecated Use needBuild instead
	 * @param {Map&lt;string, number|null&gt;} fileTimestamps timestamps of files
	 * @param {Map&lt;string, number|null&gt;} contextTimestamps timestamps of directories
	 * @returns {boolean} true, if the module needs a rebuild
	 */
	needRebuild(fileTimestamps, contextTimestamps) {
		return true;
	}

	/**
	 * @param {Hash} hash the hash used to track dependencies
	 * @param {UpdateHashContext} context context
	 * @returns {void}
	 */
	updateHash(
		hash,
		context = {
			chunkGraph: ChunkGraph.getChunkGraphForModule(
				this,
				&quot;Module.updateHash&quot;,
				&quot;DEP_WEBPACK_MODULE_UPDATE_HASH&quot;
			),
			runtime: undefined
		}
	) {
		const { chunkGraph, runtime } = context;
		hash.update(chunkGraph.getModuleGraphHash(this, runtime));
		if (this.presentationalDependencies !== undefined) {
			for (const dep of this.presentationalDependencies) {
				dep.updateHash(hash, context);
			}
		}
		super.updateHash(hash, context);
	}

	/**
	 * @returns {void}
	 */
	invalidateBuild() {
		// should be overridden to support this feature
	}

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @returns {string} a unique identifier of the module
	 */
	identifier() {
		const AbstractMethodError = require(&quot;./AbstractMethodError&quot;);
		throw new AbstractMethodError();
	}

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {RequestShortener} requestShortener the request shortener
	 * @returns {string} a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		const AbstractMethodError = require(&quot;./AbstractMethodError&quot;);
		throw new AbstractMethodError();
	}

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {WebpackOptions} options webpack options
	 * @param {Compilation} compilation the compilation
	 * @param {ResolverWithOptions} resolver the resolver
	 * @param {InputFileSystem} fs the file system
	 * @param {BuildCallback} callback callback function
	 * @returns {void}
	 */
	build(options, compilation, resolver, fs, callback) {
		const AbstractMethodError = require(&quot;./AbstractMethodError&quot;);
		throw new AbstractMethodError();
	}

	/**
	 * @abstract
	 * @returns {SourceTypes} types available (do not mutate)
	 */
	getSourceTypes() {
		// Better override this method to return the correct types
		if (this.source === Module.prototype.source) {
			return DEFAULT_TYPES_UNKNOWN;
		}
		return JS_TYPES;
	}

	/**
	 * @abstract
	 * @deprecated Use codeGeneration() instead
	 * @param {DependencyTemplates} dependencyTemplates the dependency templates
	 * @param {RuntimeTemplate} runtimeTemplate the runtime template
	 * @param {string=} type the type of source that should be generated
	 * @returns {Source} generated source
	 */
	source(dependencyTemplates, runtimeTemplate, type = &quot;javascript&quot;) {
		if (this.codeGeneration === Module.prototype.codeGeneration) {
			const AbstractMethodError = require(&quot;./AbstractMethodError&quot;);
			throw new AbstractMethodError();
		}
		const chunkGraph = ChunkGraph.getChunkGraphForModule(
			this,
			&quot;Module.source() is deprecated. Use Compilation.codeGenerationResults.getSource(module, runtime, type) instead&quot;,
			&quot;DEP_WEBPACK_MODULE_SOURCE&quot;
		);
		/** @type {CodeGenerationContext} */
		const codeGenContext = {
			dependencyTemplates,
			runtimeTemplate,
			moduleGraph: chunkGraph.moduleGraph,
			chunkGraph,
			runtime: undefined,
			codeGenerationResults: undefined
		};
		const sources = this.codeGeneration(codeGenContext).sources;

		return /** @type {Source} */ (
			type
				? sources.get(type)
				: sources.get(/** @type {string} */ (first(this.getSourceTypes())))
		);
	}

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {string=} type the source type for which the size should be estimated
	 * @returns {number} the estimated size of the module (must be non-zero)
	 */
	size(type) {
		const AbstractMethodError = require(&quot;./AbstractMethodError&quot;);
		throw new AbstractMethodError();
	}

	/**
	 * @param {LibIdentOptions} options options
	 * @returns {string | null} an identifier for library inclusion
	 */
	libIdent(options) {
		return null;
	}

	/**
	 * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)
	 */
	nameForCondition() {
		return null;
	}

	/**
	 * @param {ConcatenationBailoutReasonContext} context context
	 * @returns {string | undefined} reason why this module can&#039;t be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(context) {
		return `Module Concatenation is not implemented for ${this.constructor.name}`;
	}

	/**
	 * @param {ModuleGraph} moduleGraph the module graph
	 * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only
	 */
	getSideEffectsConnectionState(moduleGraph) {
		return true;
	}

	/**
	 * @param {CodeGenerationContext} context context for code generation
	 * @returns {CodeGenerationResult} result
	 */
	codeGeneration(context) {
		// Best override this method
		const sources = new Map();
		for (const type of this.getSourceTypes()) {
			if (type !== &quot;unknown&quot;) {
				sources.set(
					type,
					this.source(
						context.dependencyTemplates,
						context.runtimeTemplate,
						type
					)
				);
			}
		}
		return {
			sources,
			runtimeRequirements: new Set([
				RuntimeGlobals.module,
				RuntimeGlobals.exports,
				RuntimeGlobals.require
			])
		};
	}

	/**
	 * @param {Chunk} chunk the chunk which condition should be checked
	 * @param {Compilation} compilation the compilation
	 * @returns {boolean} true, if the chunk is ok for the module
	 */
	chunkCondition(chunk, compilation) {
		return true;
	}

	hasChunkCondition() {
		return this.chunkCondition !== Module.prototype.chunkCondition;
	}

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 * @param {Module} module fresh module
	 * @returns {void}
	 */
	updateCacheModule(module) {
		this.type = module.type;
		this.layer = module.layer;
		this.context = module.context;
		this.factoryMeta = module.factoryMeta;
		this.resolveOptions = module.resolveOptions;
	}

	/**
	 * Module should be unsafe cached. Get data that&#039;s needed for that.
	 * This data will be passed to restoreFromUnsafeCache later.
	 * @returns {UnsafeCacheData} cached data
	 */
	getUnsafeCacheData() {
		return {
			factoryMeta: this.factoryMeta,
			resolveOptions: this.resolveOptions
		};
	}

	/**
	 * restore unsafe cache data
	 * @param {UnsafeCacheData} unsafeCacheData data from getUnsafeCacheData
	 * @param {NormalModuleFactory} normalModuleFactory the normal module factory handling the unsafe caching
	 */
	_restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
		this.factoryMeta = unsafeCacheData.factoryMeta;
		this.resolveOptions = unsafeCacheData.resolveOptions;
	}

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache() {
		this.factoryMeta = undefined;
		this.resolveOptions = undefined;
	}

	/**
	 * @returns {Source | null} the original source for the module before webpack transformation
	 */
	originalSource() {
		return null;
	}

	/**
	 * @param {LazySet&lt;string&gt;} fileDependencies set where file dependencies are added to
	 * @param {LazySet&lt;string&gt;} contextDependencies set where context dependencies are added to
	 * @param {LazySet&lt;string&gt;} missingDependencies set where missing dependencies are added to
	 * @param {LazySet&lt;string&gt;} buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {}

	/**
	 * @param {ObjectSerializerContext} context context
	 */
	serialize(context) {
		const { write } = context;
		write(this.type);
		write(this.layer);
		write(this.context);
		write(this.resolveOptions);
		write(this.factoryMeta);
		write(this.useSourceMap);
		write(this.useSimpleSourceMap);
		write(this.hot);
		write(
			this._warnings !== undefined &amp;&amp; this._warnings.length === 0
				? undefined
				: this._warnings
		);
		write(
			this._errors !== undefined &amp;&amp; this._errors.length === 0
				? undefined
				: this._errors
		);
		write(this.buildMeta);
		write(this.buildInfo);
		write(this.presentationalDependencies);
		write(this.codeGenerationDependencies);
		super.serialize(context);
	}

	/**
	 * @param {ObjectDeserializerContext} context context
	 */
	deserialize(context) {
		const { read } = context;
		this.type = read();
		this.layer = read();
		this.context = read();
		this.resolveOptions = read();
		this.factoryMeta = read();
		this.useSourceMap = read();
		this.useSimpleSourceMap = read();
		this.hot = read();
		this._warnings = read();
		this._errors = read();
		this.buildMeta = read();
		this.buildInfo = read();
		this.presentationalDependencies = read();
		this.codeGenerationDependencies = read();
		super.deserialize(context);
	}
}

makeSerializable(Module, &quot;webpack/lib/Module&quot;);

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, &quot;hasEqualsChunks&quot;, {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY} throw an error
	 */
	get() {
		throw new Error(
			&quot;Module.hasEqualsChunks was renamed (use hasEqualChunks instead)&quot;
		);
	}
});

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, &quot;isUsed&quot;, {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY} throw an error
	 */
	get() {
		throw new Error(
			&quot;Module.isUsed was renamed (use getUsedName, isExportUsed or isModuleUsed instead)&quot;
		);
	}
});

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, &quot;errors&quot;, {
	/**
	 * @deprecated
	 * @returns {WebpackError[]} errors
	 */
	get: util.deprecate(
		/**
		 * @this {Module}
		 * @returns {WebpackError[]} errors
		 */
		function () {
			if (this._errors === undefined) {
				this._errors = [];
			}
			return this._errors;
		},
		&quot;Module.errors was removed (use getErrors instead)&quot;,
		&quot;DEP_WEBPACK_MODULE_ERRORS&quot;
	)
});

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, &quot;warnings&quot;, {
	/**
	 * @deprecated
	 * @returns {WebpackError[]} warnings
	 */
	get: util.deprecate(
		/**
		 * @this {Module}
		 * @returns {WebpackError[]} warnings
		 */
		function () {
			if (this._warnings === undefined) {
				this._warnings = [];
			}
			return this._warnings;
		},
		&quot;Module.warnings was removed (use getWarnings instead)&quot;,
		&quot;DEP_WEBPACK_MODULE_WARNINGS&quot;
	)
});

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, &quot;used&quot;, {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY} throw an error
	 */
	get() {
		throw new Error(
			&quot;Module.used was refactored (use ModuleGraph.getUsedExports instead)&quot;
		);
	},
	/**
	 * @param {EXPECTED_ANY} value value
	 */
	set(value) {
		throw new Error(
			&quot;Module.used was refactored (use ModuleGraph.setUsedExports instead)&quot;
		);
	}
});

module.exports = Module;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
