<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/semver/classes/range.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/semver/classes/range.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.10</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">557</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">105.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.27</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

const SPACE_CHARACTERS = /\s+/g

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &amp;&amp;
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.formatted = undefined
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range.trim().replace(SPACE_CHARACTERS, &#039; &#039;)

    // First, split on ||
    this.set = this.raw
      .split(&#039;||&#039;)
      // map the range to a 2d array of comparators
      .map(r =&gt; this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c =&gt; c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length &gt; 1) {
      // keep the first one, in case they&#039;re all null sets
      const first = this.set[0]
      this.set = this.set.filter(c =&gt; !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length &gt; 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 &amp;&amp; isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.formatted = undefined
  }

  get range () {
    if (this.formatted === undefined) {
      this.formatted = &#039;&#039;
      for (let i = 0; i &lt; this.set.length; i++) {
        if (i &gt; 0) {
          this.formatted += &#039;||&#039;
        }
        const comps = this.set[i]
        for (let k = 0; k &lt; comps.length; k++) {
          if (k &gt; 0) {
            this.formatted += &#039; &#039;
          }
          this.formatted += comps[k].toString().trim()
        }
      }
    }
    return this.formatted
  }

  format () {
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease &amp;&amp; FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose &amp;&amp; FLAG_LOOSE)
    const memoKey = memoOpts + &#039;:&#039; + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` =&gt; `&gt;=1.2.3 &lt;=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug(&#039;hyphen replace&#039;, range)

    // `&gt; 1.2.3 &lt; 1.2.5` =&gt; `&gt;1.2.3 &lt;1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug(&#039;comparator trim&#039;, range)

    // `~ 1.2.3` =&gt; `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug(&#039;tilde trim&#039;, range)

    // `^ 1.2.3` =&gt; `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug(&#039;caret trim&#039;, range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(&#039; &#039;)
      .map(comp =&gt; parseComparator(comp, this.options))
      .join(&#039; &#039;)
      .split(/\s+/)
      // &gt;=0.0.0 is equivalent to *
      .map(comp =&gt; replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp =&gt; {
        debug(&#039;loose invalid filter&#039;, comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug(&#039;range list&#039;, rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don&#039;t include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp =&gt; new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size &gt; 1 &amp;&amp; rangeMap.has(&#039;&#039;)) {
      rangeMap.delete(&#039;&#039;)
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError(&#039;a Range is required&#039;)
    }

    return this.set.some((thisComparators) =&gt; {
      return (
        isSatisfiable(thisComparators, options) &amp;&amp;
        range.set.some((rangeComparators) =&gt; {
          return (
            isSatisfiable(rangeComparators, options) &amp;&amp;
            thisComparators.every((thisComparator) =&gt; {
              return rangeComparators.every((rangeComparator) =&gt; {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === &#039;string&#039;) {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i &lt; this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = require(&#039;../internal/lrucache&#039;)
const cache = new LRU()

const parseOptions = require(&#039;../internal/parse-options&#039;)
const Comparator = require(&#039;./comparator&#039;)
const debug = require(&#039;../internal/debug&#039;)
const SemVer = require(&#039;./semver&#039;)
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = require(&#039;../internal/re&#039;)
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require(&#039;../internal/constants&#039;)

const isNullSet = c =&gt; c.value === &#039;&lt;0.0.0-0&#039;
const isAny = c =&gt; c.value === &#039;&#039;

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) =&gt; {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result &amp;&amp; remainingComparators.length) {
    result = remainingComparators.every((otherComparator) =&gt; {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt&#039;s at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) =&gt; {
  debug(&#039;comp&#039;, comp, options)
  comp = replaceCarets(comp, options)
  debug(&#039;caret&#039;, comp)
  comp = replaceTildes(comp, options)
  debug(&#039;tildes&#039;, comp)
  comp = replaceXRanges(comp, options)
  debug(&#039;xrange&#039;, comp)
  comp = replaceStars(comp, options)
  debug(&#039;stars&#039;, comp)
  return comp
}

const isX = id =&gt; !id || id.toLowerCase() === &#039;x&#039; || id === &#039;*&#039;

// ~, ~&gt; --&gt; * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~&gt;2, ~&gt;2.x ~&gt;2.x.x --&gt; &gt;=2.0.0 &lt;3.0.0-0
// ~2.0, ~2.0.x, ~&gt;2.0, ~&gt;2.0.x --&gt; &gt;=2.0.0 &lt;2.1.0-0
// ~1.2, ~1.2.x, ~&gt;1.2, ~&gt;1.2.x --&gt; &gt;=1.2.0 &lt;1.3.0-0
// ~1.2.3, ~&gt;1.2.3 --&gt; &gt;=1.2.3 &lt;1.3.0-0
// ~1.2.0, ~&gt;1.2.0 --&gt; &gt;=1.2.0 &lt;1.3.0-0
// ~0.0.1 --&gt; &gt;=0.0.1 &lt;0.1.0-0
const replaceTildes = (comp, options) =&gt; {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) =&gt; replaceTilde(c, options))
    .join(&#039; &#039;)
}

const replaceTilde = (comp, options) =&gt; {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) =&gt; {
    debug(&#039;tilde&#039;, comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = &#039;&#039;
    } else if (isX(m)) {
      ret = `&gt;=${M}.0.0 &lt;${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == &gt;=1.2.0 &lt;1.3.0-0
      ret = `&gt;=${M}.${m}.0 &lt;${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug(&#039;replaceTilde pr&#039;, pr)
      ret = `&gt;=${M}.${m}.${p}-${pr
      } &lt;${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == &gt;=1.2.3 &lt;1.3.0-0
      ret = `&gt;=${M}.${m}.${p
      } &lt;${M}.${+m + 1}.0-0`
    }

    debug(&#039;tilde return&#039;, ret)
    return ret
  })
}

// ^ --&gt; * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --&gt; &gt;=2.0.0 &lt;3.0.0-0
// ^2.0, ^2.0.x --&gt; &gt;=2.0.0 &lt;3.0.0-0
// ^1.2, ^1.2.x --&gt; &gt;=1.2.0 &lt;2.0.0-0
// ^1.2.3 --&gt; &gt;=1.2.3 &lt;2.0.0-0
// ^1.2.0 --&gt; &gt;=1.2.0 &lt;2.0.0-0
// ^0.0.1 --&gt; &gt;=0.0.1 &lt;0.0.2-0
// ^0.1.0 --&gt; &gt;=0.1.0 &lt;0.2.0-0
const replaceCarets = (comp, options) =&gt; {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) =&gt; replaceCaret(c, options))
    .join(&#039; &#039;)
}

const replaceCaret = (comp, options) =&gt; {
  debug(&#039;caret&#039;, comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? &#039;-0&#039; : &#039;&#039;
  return comp.replace(r, (_, M, m, p, pr) =&gt; {
    debug(&#039;caret&#039;, comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = &#039;&#039;
    } else if (isX(m)) {
      ret = `&gt;=${M}.0.0${z} &lt;${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === &#039;0&#039;) {
        ret = `&gt;=${M}.${m}.0${z} &lt;${M}.${+m + 1}.0-0`
      } else {
        ret = `&gt;=${M}.${m}.0${z} &lt;${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug(&#039;replaceCaret pr&#039;, pr)
      if (M === &#039;0&#039;) {
        if (m === &#039;0&#039;) {
          ret = `&gt;=${M}.${m}.${p}-${pr
          } &lt;${M}.${m}.${+p + 1}-0`
        } else {
          ret = `&gt;=${M}.${m}.${p}-${pr
          } &lt;${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `&gt;=${M}.${m}.${p}-${pr
        } &lt;${+M + 1}.0.0-0`
      }
    } else {
      debug(&#039;no pr&#039;)
      if (M === &#039;0&#039;) {
        if (m === &#039;0&#039;) {
          ret = `&gt;=${M}.${m}.${p
          }${z} &lt;${M}.${m}.${+p + 1}-0`
        } else {
          ret = `&gt;=${M}.${m}.${p
          }${z} &lt;${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `&gt;=${M}.${m}.${p
        } &lt;${+M + 1}.0.0-0`
      }
    }

    debug(&#039;caret return&#039;, ret)
    return ret
  })
}

const replaceXRanges = (comp, options) =&gt; {
  debug(&#039;replaceXRanges&#039;, comp, options)
  return comp
    .split(/\s+/)
    .map((c) =&gt; replaceXRange(c, options))
    .join(&#039; &#039;)
}

const replaceXRange = (comp, options) =&gt; {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) =&gt; {
    debug(&#039;xRange&#039;, comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === &#039;=&#039; &amp;&amp; anyX) {
      gtlt = &#039;&#039;
    }

    // if we&#039;re including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? &#039;-0&#039; : &#039;&#039;

    if (xM) {
      if (gtlt === &#039;&gt;&#039; || gtlt === &#039;&lt;&#039;) {
        // nothing is allowed
        ret = &#039;&lt;0.0.0-0&#039;
      } else {
        // nothing is forbidden
        ret = &#039;*&#039;
      }
    } else if (gtlt &amp;&amp; anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === &#039;&gt;&#039;) {
        // &gt;1 =&gt; &gt;=2.0.0
        // &gt;1.2 =&gt; &gt;=1.3.0
        gtlt = &#039;&gt;=&#039;
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === &#039;&lt;=&#039;) {
        // &lt;=0.7.x is actually &lt;0.8.0, since any 0.7.x should
        // pass.  Similarly, &lt;=7.x is actually &lt;8.0.0, etc.
        gtlt = &#039;&lt;&#039;
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === &#039;&lt;&#039;) {
        pr = &#039;-0&#039;
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `&gt;=${M}.0.0${pr} &lt;${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `&gt;=${M}.${m}.0${pr
      } &lt;${M}.${+m + 1}.0-0`
    }

    debug(&#039;xRange return&#039;, ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and &#039;&#039; means &quot;any version&quot;, just remove the *s entirely.
const replaceStars = (comp, options) =&gt; {
  debug(&#039;replaceStars&#039;, comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], &#039;&#039;)
}

const replaceGTE0 = (comp, options) =&gt; {
  debug(&#039;replaceGTE0&#039;, comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], &#039;&#039;)
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 =&gt; &gt;=1.2.0 &lt;=3.4.5
// 1.2.3 - 3.4 =&gt; &gt;=1.2.0 &lt;3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 =&gt; &gt;=1.2.0 &lt;3.5.0-0
// TODO build?
const hyphenReplace = incPr =&gt; ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr) =&gt; {
  if (isX(fM)) {
    from = &#039;&#039;
  } else if (isX(fm)) {
    from = `&gt;=${fM}.0.0${incPr ? &#039;-0&#039; : &#039;&#039;}`
  } else if (isX(fp)) {
    from = `&gt;=${fM}.${fm}.0${incPr ? &#039;-0&#039; : &#039;&#039;}`
  } else if (fpr) {
    from = `&gt;=${from}`
  } else {
    from = `&gt;=${from}${incPr ? &#039;-0&#039; : &#039;&#039;}`
  }

  if (isX(tM)) {
    to = &#039;&#039;
  } else if (isX(tm)) {
    to = `&lt;${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `&lt;${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `&lt;=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `&lt;${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `&lt;=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) =&gt; {
  for (let i = 0; i &lt; set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length &amp;&amp; !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to &gt;=1.2.3-pr.1 &lt;2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it&#039;s within the range set by the comparators.
    for (let i = 0; i &lt; set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length &gt; 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &amp;&amp;
            allowed.minor === version.minor &amp;&amp;
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it&#039;s not one of the ones we like.
    return false
  }

  return true
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
