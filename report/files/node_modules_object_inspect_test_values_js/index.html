<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/object-inspect/test/values.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/object-inspect/test/values.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.23</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">262</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">36.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.24</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var inspect = require(&#039;../&#039;);
var test = require(&#039;tape&#039;);
var mockProperty = require(&#039;mock-property&#039;);
var hasSymbols = require(&#039;has-symbols/shams&#039;)();
var hasToStringTag = require(&#039;has-tostringtag/shams&#039;)();
var forEach = require(&#039;for-each&#039;);
var semver = require(&#039;semver&#039;);

test(&#039;values&#039;, function (t) {
    t.plan(1);
    var obj = [{}, [], { &#039;a-b&#039;: 5 }];
    t.equal(inspect(obj), &#039;[ {}, [], { \&#039;a-b\&#039;: 5 } ]&#039;);
});

test(&#039;arrays with properties&#039;, function (t) {
    t.plan(1);
    var arr = [3];
    arr.foo = &#039;bar&#039;;
    var obj = [1, 2, arr];
    obj.baz = &#039;quux&#039;;
    obj.index = -1;
    t.equal(inspect(obj), &#039;[ 1, 2, [ 3, foo: \&#039;bar\&#039; ], baz: \&#039;quux\&#039;, index: -1 ]&#039;);
});

test(&#039;has&#039;, function (t) {
    t.plan(1);
    t.teardown(mockProperty(Object.prototype, &#039;hasOwnProperty&#039;, { &#039;delete&#039;: true }));

    t.equal(inspect({ a: 1, b: 2 }), &#039;{ a: 1, b: 2 }&#039;);
});

test(&#039;indexOf seen&#039;, function (t) {
    t.plan(1);
    var xs = [1, 2, 3, {}];
    xs.push(xs);

    var seen = [];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, {}, 0, seen),
        &#039;[ 1, 2, 3, {}, [Circular] ]&#039;
    );
});

test(&#039;seen seen&#039;, function (t) {
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, {}, 0, seen),
        &#039;[Circular]&#039;
    );
});

test(&#039;seen seen seen&#039;, function (t) {
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [5, xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, {}, 0, seen),
        &#039;[Circular]&#039;
    );
});

test(&#039;symbols&#039;, { skip: !hasSymbols }, function (t) {
    var sym = Symbol(&#039;foo&#039;);
    t.equal(inspect(sym), &#039;Symbol(foo)&#039;, &#039;Symbol(&quot;foo&quot;) should be &quot;Symbol(foo)&quot;&#039;);
    if (typeof sym === &#039;symbol&#039;) {
        // Symbol shams are incapable of differentiating boxed from unboxed symbols
        t.equal(inspect(Object(sym)), &#039;Object(Symbol(foo))&#039;, &#039;Object(Symbol(&quot;foo&quot;)) should be &quot;Object(Symbol(foo))&quot;&#039;);
    }

    t.test(&#039;toStringTag&#039;, { skip: !hasToStringTag }, function (st) {
        st.plan(1);

        var faker = {};
        faker[Symbol.toStringTag] = &#039;Symbol&#039;;
        st.equal(
            inspect(faker),
            &#039;{ [Symbol(Symbol.toStringTag)]: \&#039;Symbol\&#039; }&#039;,
            &#039;object lying about being a Symbol inspects as an object&#039;
        );
    });

    t.end();
});

test(&#039;Map&#039;, { skip: typeof Map !== &#039;function&#039; }, function (t) {
    var map = new Map();
    map.set({ a: 1 }, [&#039;b&#039;]);
    map.set(3, NaN);
    var expectedString = &#039;Map (2) {&#039; + inspect({ a: 1 }) + &#039; =&gt; &#039; + inspect([&#039;b&#039;]) + &#039;, 3 =&gt; NaN}&#039;;
    t.equal(inspect(map), expectedString, &#039;new Map([[{ a: 1 }, [&quot;b&quot;]], [3, NaN]]) should show size and contents&#039;);
    t.equal(inspect(new Map()), &#039;Map (0) {}&#039;, &#039;empty Map should show as empty&#039;);

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    t.equal(inspect(nestedMap), &#039;Map (1) {[Circular] =&gt; &#039; + expectedString + &#039;}&#039;, &#039;Map containing a Map should work&#039;);

    t.end();
});

test(&#039;WeakMap&#039;, { skip: typeof WeakMap !== &#039;function&#039; }, function (t) {
    var map = new WeakMap();
    map.set({ a: 1 }, [&#039;b&#039;]);
    var expectedString = &#039;WeakMap { ? }&#039;;
    t.equal(inspect(map), expectedString, &#039;new WeakMap([[{ a: 1 }, [&quot;b&quot;]]]) should not show size or contents&#039;);
    t.equal(inspect(new WeakMap()), &#039;WeakMap { ? }&#039;, &#039;empty WeakMap should not show as empty&#039;);

    t.end();
});

test(&#039;Set&#039;, { skip: typeof Set !== &#039;function&#039; }, function (t) {
    var set = new Set();
    set.add({ a: 1 });
    set.add([&#039;b&#039;]);
    var expectedString = &#039;Set (2) {&#039; + inspect({ a: 1 }) + &#039;, &#039; + inspect([&#039;b&#039;]) + &#039;}&#039;;
    t.equal(inspect(set), expectedString, &#039;new Set([{ a: 1 }, [&quot;b&quot;]]) should show size and contents&#039;);
    t.equal(inspect(new Set()), &#039;Set (0) {}&#039;, &#039;empty Set should show as empty&#039;);

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    t.equal(inspect(nestedSet), &#039;Set (2) {&#039; + expectedString + &#039;, [Circular]}&#039;, &#039;Set containing a Set should work&#039;);

    t.end();
});

test(&#039;WeakSet&#039;, { skip: typeof WeakSet !== &#039;function&#039; }, function (t) {
    var map = new WeakSet();
    map.add({ a: 1 });
    var expectedString = &#039;WeakSet { ? }&#039;;
    t.equal(inspect(map), expectedString, &#039;new WeakSet([{ a: 1 }]) should not show size or contents&#039;);
    t.equal(inspect(new WeakSet()), &#039;WeakSet { ? }&#039;, &#039;empty WeakSet should not show as empty&#039;);

    t.end();
});

test(&#039;WeakRef&#039;, { skip: typeof WeakRef !== &#039;function&#039; }, function (t) {
    var ref = new WeakRef({ a: 1 });
    var expectedString = &#039;WeakRef { ? }&#039;;
    t.equal(inspect(ref), expectedString, &#039;new WeakRef({ a: 1 }) should not show contents&#039;);

    t.end();
});

test(&#039;FinalizationRegistry&#039;, { skip: typeof FinalizationRegistry !== &#039;function&#039; }, function (t) {
    var registry = new FinalizationRegistry(function () {});
    var expectedString = &#039;FinalizationRegistry [FinalizationRegistry] {}&#039;;
    t.equal(inspect(registry), expectedString, &#039;new FinalizationRegistry(function () {}) should work normallys&#039;);

    t.end();
});

test(&#039;Strings&#039;, function (t) {
    var str = &#039;abc&#039;;

    t.equal(inspect(str), &quot;&#039;&quot; + str + &quot;&#039;&quot;, &#039;primitive string shows as such&#039;);
    t.equal(inspect(str, { quoteStyle: &#039;single&#039; }), &quot;&#039;&quot; + str + &quot;&#039;&quot;, &#039;primitive string shows as such, single quoted&#039;);
    t.equal(inspect(str, { quoteStyle: &#039;double&#039; }), &#039;&quot;&#039; + str + &#039;&quot;&#039;, &#039;primitive string shows as such, double quoted&#039;);
    t.equal(inspect(Object(str)), &#039;Object(&#039; + inspect(str) + &#039;)&#039;, &#039;String object shows as such&#039;);
    t.equal(inspect(Object(str), { quoteStyle: &#039;single&#039; }), &#039;Object(&#039; + inspect(str, { quoteStyle: &#039;single&#039; }) + &#039;)&#039;, &#039;String object shows as such, single quoted&#039;);
    t.equal(inspect(Object(str), { quoteStyle: &#039;double&#039; }), &#039;Object(&#039; + inspect(str, { quoteStyle: &#039;double&#039; }) + &#039;)&#039;, &#039;String object shows as such, double quoted&#039;);

    t.end();
});

test(&#039;Numbers&#039;, function (t) {
    var num = 42;

    t.equal(inspect(num), String(num), &#039;primitive number shows as such&#039;);
    t.equal(inspect(Object(num)), &#039;Object(&#039; + inspect(num) + &#039;)&#039;, &#039;Number object shows as such&#039;);

    t.end();
});

test(&#039;Booleans&#039;, function (t) {
    t.equal(inspect(true), String(true), &#039;primitive true shows as such&#039;);
    t.equal(inspect(Object(true)), &#039;Object(&#039; + inspect(true) + &#039;)&#039;, &#039;Boolean object true shows as such&#039;);

    t.equal(inspect(false), String(false), &#039;primitive false shows as such&#039;);
    t.equal(inspect(Object(false)), &#039;Object(&#039; + inspect(false) + &#039;)&#039;, &#039;Boolean false object shows as such&#039;);

    t.end();
});

test(&#039;Date&#039;, function (t) {
    var now = new Date();
    t.equal(inspect(now), String(now), &#039;Date shows properly&#039;);
    t.equal(inspect(new Date(NaN)), &#039;Invalid Date&#039;, &#039;Invalid Date shows properly&#039;);

    t.end();
});

test(&#039;RegExps&#039;, function (t) {
    t.equal(inspect(/a/g), &#039;/a/g&#039;, &#039;regex shows properly&#039;);
    t.equal(inspect(new RegExp(&#039;abc&#039;, &#039;i&#039;)), &#039;/abc/i&#039;, &#039;new RegExp shows properly&#039;);

    var match = &#039;abc abc&#039;.match(/[ab]+/);
    delete match.groups; // for node &lt; 10
    t.equal(inspect(match), &#039;[ \&#039;ab\&#039;, index: 0, input: \&#039;abc abc\&#039; ]&#039;, &#039;RegExp match object shows properly&#039;);

    t.end();
});

test(&#039;Proxies&#039;, { skip: typeof Proxy !== &#039;function&#039; || !hasToStringTag }, function (t) {
    var target = { proxy: true };
    var fake = new Proxy(target, { has: function () { return false; } });

    // needed to work around a weird difference in node v6.0 - v6.4 where non-present properties are not logged
    var isNode60 = semver.satisfies(process.version, &#039;6.0 - 6.4&#039;);

    forEach([
        &#039;Boolean&#039;,
        &#039;Number&#039;,
        &#039;String&#039;,
        &#039;Symbol&#039;,
        &#039;Date&#039;
    ], function (tag) {
        target[Symbol.toStringTag] = tag;

        t.equal(
            inspect(fake),
            &#039;{ &#039; + (isNode60 ? &#039;&#039; : &#039;proxy: true, &#039;) + &#039;[Symbol(Symbol.toStringTag)]: \&#039;&#039; + tag + &#039;\&#039; }&#039;,
            &#039;Proxy for + &#039; + tag + &#039; shows as the target, which has no slots&#039;
        );
    });

    t.end();
});

test(&#039;fakers&#039;, { skip: !hasToStringTag }, function (t) {
    var target = { proxy: false };

    forEach([
        &#039;Boolean&#039;,
        &#039;Number&#039;,
        &#039;String&#039;,
        &#039;Symbol&#039;,
        &#039;Date&#039;
    ], function (tag) {
        target[Symbol.toStringTag] = tag;

        t.equal(
            inspect(target),
            &#039;{ proxy: false, [Symbol(Symbol.toStringTag)]: \&#039;&#039; + tag + &#039;\&#039; }&#039;,
            &#039;Object pretending to be &#039; + tag + &#039; does not trick us&#039;
        );
    });

    t.end();
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
