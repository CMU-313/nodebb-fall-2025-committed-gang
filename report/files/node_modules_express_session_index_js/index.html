<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/express-session/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/express-session/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">694</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.53</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * express-session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

&#039;use strict&#039;;

/**
 * Module dependencies.
 * @private
 */

var Buffer = require(&#039;safe-buffer&#039;).Buffer
var cookie = require(&#039;cookie&#039;);
var crypto = require(&#039;crypto&#039;)
var debug = require(&#039;debug&#039;)(&#039;express-session&#039;);
var deprecate = require(&#039;depd&#039;)(&#039;express-session&#039;);
var onHeaders = require(&#039;on-headers&#039;)
var parseUrl = require(&#039;parseurl&#039;);
var signature = require(&#039;cookie-signature&#039;)
var uid = require(&#039;uid-safe&#039;).sync

var Cookie = require(&#039;./session/cookie&#039;)
var MemoryStore = require(&#039;./session/memory&#039;)
var Session = require(&#039;./session/session&#039;)
var Store = require(&#039;./session/store&#039;)

// environment

var env = process.env.NODE_ENV;

/**
 * Expose the middleware.
 */

exports = module.exports = session;

/**
 * Expose constructors.
 */

exports.Store = Store;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;

/**
 * Warning message for `MemoryStore` usage in production.
 * @private
 */

var warning = &#039;Warning: connect.session() MemoryStore is not\n&#039;
  + &#039;designed for a production environment, as it will leak\n&#039;
  + &#039;memory, and will not scale past a single process.&#039;;

/**
 * Node.js 0.8+ async implementation.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === &#039;function&#039;
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Setup session store with the given `options`.
 *
 * @param {Object} [options]
 * @param {Object} [options.cookie] Options for cookie
 * @param {Function} [options.genid]
 * @param {String} [options.name=connect.sid] Session ID cookie name
 * @param {Boolean} [options.proxy]
 * @param {Boolean} [options.resave] Resave unmodified sessions back to the store
 * @param {Boolean} [options.rolling] Enable/disable rolling session expiration
 * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store
 * @param {String|Array} [options.secret] Secret for signing session ID
 * @param {Object} [options.store=MemoryStore] Session store
 * @param {String} [options.unset]
 * @return {Function} middleware
 * @public
 */

function session(options) {
  var opts = options || {}

  // get the cookie options
  var cookieOptions = opts.cookie || {}

  // get the session id generate function
  var generateId = opts.genid || generateSessionId

  // get the session cookie name
  var name = opts.name || opts.key || &#039;connect.sid&#039;

  // get the session store
  var store = opts.store || new MemoryStore()

  // get the trust proxy setting
  var trustProxy = opts.proxy

  // get the resave session option
  var resaveSession = opts.resave;

  // get the rolling session option
  var rollingSessions = Boolean(opts.rolling)

  // get the save uninitialized session option
  var saveUninitializedSession = opts.saveUninitialized

  // get the cookie signing secret
  var secret = opts.secret

  if (typeof generateId !== &#039;function&#039;) {
    throw new TypeError(&#039;genid option must be a function&#039;);
  }

  if (resaveSession === undefined) {
    deprecate(&#039;undefined resave option; provide resave option&#039;);
    resaveSession = true;
  }

  if (saveUninitializedSession === undefined) {
    deprecate(&#039;undefined saveUninitialized option; provide saveUninitialized option&#039;);
    saveUninitializedSession = true;
  }

  if (opts.unset &amp;&amp; opts.unset !== &#039;destroy&#039; &amp;&amp; opts.unset !== &#039;keep&#039;) {
    throw new TypeError(&#039;unset option must be &quot;destroy&quot; or &quot;keep&quot;&#039;);
  }

  // TODO: switch to &quot;destroy&quot; on next major
  var unsetDestroy = opts.unset === &#039;destroy&#039;

  if (Array.isArray(secret) &amp;&amp; secret.length === 0) {
    throw new TypeError(&#039;secret option array must contain one or more strings&#039;);
  }

  if (secret &amp;&amp; !Array.isArray(secret)) {
    secret = [secret];
  }

  if (!secret) {
    deprecate(&#039;req.secret; provide secret option&#039;);
  }

  // notify user that this store is not
  // meant for a production environment
  /* istanbul ignore next: not tested */
  if (env === &#039;production&#039; &amp;&amp; store instanceof MemoryStore) {
    console.warn(warning);
  }

  // generates the new session
  store.generate = function(req){
    req.sessionID = generateId(req);
    req.session = new Session(req);
    req.session.cookie = new Cookie(cookieOptions);

    if (cookieOptions.secure === &#039;auto&#039;) {
      req.session.cookie.secure = issecure(req, trustProxy);
    }
  };

  var storeImplementsTouch = typeof store.touch === &#039;function&#039;;

  // register event listeners for the store to track readiness
  var storeReady = true
  store.on(&#039;disconnect&#039;, function ondisconnect() {
    storeReady = false
  })
  store.on(&#039;connect&#039;, function onconnect() {
    storeReady = true
  })

  return function session(req, res, next) {
    // self-awareness
    if (req.session) {
      next()
      return
    }

    // Handle connection as if there is no session if
    // the store has temporarily disconnected etc
    if (!storeReady) {
      debug(&#039;store is disconnected&#039;)
      next()
      return
    }

    // pathname mismatch
    var originalPath = parseUrl.original(req).pathname || &#039;/&#039;
    if (originalPath.indexOf(cookieOptions.path || &#039;/&#039;) !== 0) {
      debug(&#039;pathname mismatch&#039;)
      next()
      return
    }

    // ensure a secret is available or bail
    if (!secret &amp;&amp; !req.secret) {
      next(new Error(&#039;secret option required for sessions&#039;));
      return;
    }

    // backwards compatibility for signed cookies
    // req.secret is passed from the cookie parser middleware
    var secrets = secret || [req.secret];

    var originalHash;
    var originalId;
    var savedHash;
    var touched = false

    // expose store
    req.sessionStore = store;

    // get the session ID from the cookie
    var cookieId = req.sessionID = getcookie(req, name, secrets);

    // set-cookie
    onHeaders(res, function(){
      if (!req.session) {
        debug(&#039;no session&#039;);
        return;
      }

      if (!shouldSetCookie(req)) {
        return;
      }

      // only send secure cookies via https
      if (req.session.cookie.secure &amp;&amp; !issecure(req, trustProxy)) {
        debug(&#039;not secured&#039;);
        return;
      }

      if (!touched) {
        // touch session
        req.session.touch()
        touched = true
      }

      // set cookie
      try {
        setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data)
      } catch (err) {
        defer(next, err)
      }
    });

    // proxy end() to commit the session
    var _end = res.end;
    var _write = res.write;
    var ended = false;
    res.end = function end(chunk, encoding) {
      if (ended) {
        return false;
      }

      ended = true;

      var ret;
      var sync = true;

      function writeend() {
        if (sync) {
          ret = _end.call(res, chunk, encoding);
          sync = false;
          return;
        }

        _end.call(res);
      }

      function writetop() {
        if (!sync) {
          return ret;
        }

        if (!res._header) {
          res._implicitHeader()
        }

        if (chunk == null) {
          ret = true;
          return ret;
        }

        var contentLength = Number(res.getHeader(&#039;Content-Length&#039;));

        if (!isNaN(contentLength) &amp;&amp; contentLength &gt; 0) {
          // measure chunk
          chunk = !Buffer.isBuffer(chunk)
            ? Buffer.from(chunk, encoding)
            : chunk;
          encoding = undefined;

          if (chunk.length !== 0) {
            debug(&#039;split response&#039;);
            ret = _write.call(res, chunk.slice(0, chunk.length - 1));
            chunk = chunk.slice(chunk.length - 1, chunk.length);
            return ret;
          }
        }

        ret = _write.call(res, chunk, encoding);
        sync = false;

        return ret;
      }

      if (shouldDestroy(req)) {
        // destroy session
        debug(&#039;destroying&#039;);
        store.destroy(req.sessionID, function ondestroy(err) {
          if (err) {
            defer(next, err);
          }

          debug(&#039;destroyed&#039;);
          writeend();
        });

        return writetop();
      }

      // no session to save
      if (!req.session) {
        debug(&#039;no session&#039;);
        return _end.call(res, chunk, encoding);
      }

      if (!touched) {
        // touch session
        req.session.touch()
        touched = true
      }

      if (shouldSave(req)) {
        req.session.save(function onsave(err) {
          if (err) {
            defer(next, err);
          }

          writeend();
        });

        return writetop();
      } else if (storeImplementsTouch &amp;&amp; shouldTouch(req)) {
        // store implements touch method
        debug(&#039;touching&#039;);
        store.touch(req.sessionID, req.session, function ontouch(err) {
          if (err) {
            defer(next, err);
          }

          debug(&#039;touched&#039;);
          writeend();
        });

        return writetop();
      }

      return _end.call(res, chunk, encoding);
    };

    // generate the session
    function generate() {
      store.generate(req);
      originalId = req.sessionID;
      originalHash = hash(req.session);
      wrapmethods(req.session);
    }

    // inflate the session
    function inflate (req, sess) {
      store.createSession(req, sess)
      originalId = req.sessionID
      originalHash = hash(sess)

      if (!resaveSession) {
        savedHash = originalHash
      }

      wrapmethods(req.session)
    }

    function rewrapmethods (sess, callback) {
      return function () {
        if (req.session !== sess) {
          wrapmethods(req.session)
        }

        callback.apply(this, arguments)
      }
    }

    // wrap session methods
    function wrapmethods(sess) {
      var _reload = sess.reload
      var _save = sess.save;

      function reload(callback) {
        debug(&#039;reloading %s&#039;, this.id)
        _reload.call(this, rewrapmethods(this, callback))
      }

      function save() {
        debug(&#039;saving %s&#039;, this.id);
        savedHash = hash(this);
        _save.apply(this, arguments);
      }

      Object.defineProperty(sess, &#039;reload&#039;, {
        configurable: true,
        enumerable: false,
        value: reload,
        writable: true
      })

      Object.defineProperty(sess, &#039;save&#039;, {
        configurable: true,
        enumerable: false,
        value: save,
        writable: true
      });
    }

    // check if session has been modified
    function isModified(sess) {
      return originalId !== sess.id || originalHash !== hash(sess);
    }

    // check if session has been saved
    function isSaved(sess) {
      return originalId === sess.id &amp;&amp; savedHash === hash(sess);
    }

    // determine if session should be destroyed
    function shouldDestroy(req) {
      return req.sessionID &amp;&amp; unsetDestroy &amp;&amp; req.session == null;
    }

    // determine if session should be saved to store
    function shouldSave(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== &#039;string&#039;) {
        debug(&#039;session ignored because of bogus req.sessionID %o&#039;, req.sessionID);
        return false;
      }

      return !saveUninitializedSession &amp;&amp; !savedHash &amp;&amp; cookieId !== req.sessionID
        ? isModified(req.session)
        : !isSaved(req.session)
    }

    // determine if session should be touched
    function shouldTouch(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== &#039;string&#039;) {
        debug(&#039;session ignored because of bogus req.sessionID %o&#039;, req.sessionID);
        return false;
      }

      return cookieId === req.sessionID &amp;&amp; !shouldSave(req);
    }

    // determine if cookie should be set on response
    function shouldSetCookie(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== &#039;string&#039;) {
        return false;
      }

      return cookieId !== req.sessionID
        ? saveUninitializedSession || isModified(req.session)
        : rollingSessions || req.session.cookie.expires != null &amp;&amp; isModified(req.session);
    }

    // generate a session if the browser doesn&#039;t send a sessionID
    if (!req.sessionID) {
      debug(&#039;no SID sent, generating session&#039;);
      generate();
      next();
      return;
    }

    // generate the session object
    debug(&#039;fetching %s&#039;, req.sessionID);
    store.get(req.sessionID, function(err, sess){
      // error handling
      if (err &amp;&amp; err.code !== &#039;ENOENT&#039;) {
        debug(&#039;error %j&#039;, err);
        next(err)
        return
      }

      try {
        if (err || !sess) {
          debug(&#039;no session found&#039;)
          generate()
        } else {
          debug(&#039;session found&#039;)
          inflate(req, sess)
        }
      } catch (e) {
        next(e)
        return
      }

      next()
    });
  };
};

/**
 * Generate a session ID for a new session.
 *
 * @return {String}
 * @private
 */

function generateSessionId(sess) {
  return uid(24);
}

/**
 * Get the session ID cookie from request.
 *
 * @return {string}
 * @private
 */

function getcookie(req, name, secrets) {
  var header = req.headers.cookie;
  var raw;
  var val;

  // read from cookie header
  if (header) {
    var cookies = cookie.parse(header);

    raw = cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === &#039;s:&#039;) {
        val = unsigncookie(raw.slice(2), secrets);

        if (val === false) {
          debug(&#039;cookie signature invalid&#039;);
          val = undefined;
        }
      } else {
        debug(&#039;cookie unsigned&#039;)
      }
    }
  }

  // back-compat read from cookieParser() signedCookies data
  if (!val &amp;&amp; req.signedCookies) {
    val = req.signedCookies[name];

    if (val) {
      deprecate(&#039;cookie should be available in req.headers.cookie&#039;);
    }
  }

  // back-compat read from cookieParser() cookies data
  if (!val &amp;&amp; req.cookies) {
    raw = req.cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === &#039;s:&#039;) {
        val = unsigncookie(raw.slice(2), secrets);

        if (val) {
          deprecate(&#039;cookie should be available in req.headers.cookie&#039;);
        }

        if (val === false) {
          debug(&#039;cookie signature invalid&#039;);
          val = undefined;
        }
      } else {
        debug(&#039;cookie unsigned&#039;)
      }
    }
  }

  return val;
}

/**
 * Hash the given `sess` object omitting changes to `.cookie`.
 *
 * @param {Object} sess
 * @return {String}
 * @private
 */

function hash(sess) {
  // serialize
  var str = JSON.stringify(sess, function (key, val) {
    // ignore sess.cookie property
    if (this === sess &amp;&amp; key === &#039;cookie&#039;) {
      return
    }

    return val
  })

  // hash
  return crypto
    .createHash(&#039;sha1&#039;)
    .update(str, &#039;utf8&#039;)
    .digest(&#039;hex&#039;)
}

/**
 * Determine if request is secure.
 *
 * @param {Object} req
 * @param {Boolean} [trustProxy]
 * @return {Boolean}
 * @private
 */

function issecure(req, trustProxy) {
  // socket is https server
  if (req.connection &amp;&amp; req.connection.encrypted) {
    return true;
  }

  // do not trust proxy
  if (trustProxy === false) {
    return false;
  }

  // no explicit trust; try req.secure from express
  if (trustProxy !== true) {
    return req.secure === true
  }

  // read the proto from x-forwarded-proto header
  var header = req.headers[&#039;x-forwarded-proto&#039;] || &#039;&#039;;
  var index = header.indexOf(&#039;,&#039;);
  var proto = index !== -1
    ? header.substr(0, index).toLowerCase().trim()
    : header.toLowerCase().trim()

  return proto === &#039;https&#039;;
}

/**
 * Set cookie on response.
 *
 * @private
 */

function setcookie(res, name, val, secret, options) {
  var signed = &#039;s:&#039; + signature.sign(val, secret);
  var data = cookie.serialize(name, signed, options);

  debug(&#039;set-cookie %s&#039;, data);

  var prev = res.getHeader(&#039;Set-Cookie&#039;) || []
  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];

  res.setHeader(&#039;Set-Cookie&#039;, header)
}

/**
 * Verify and decode the given `val` with `secrets`.
 *
 * @param {String} val
 * @param {Array} secrets
 * @returns {String|Boolean}
 * @private
 */
function unsigncookie(val, secrets) {
  for (var i = 0; i &lt; secrets.length; i++) {
    var result = signature.unsign(val, secrets[i]);

    if (result !== false) {
      return result;
    }
  }

  return false;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
