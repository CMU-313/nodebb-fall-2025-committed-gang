<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodemailer/lib/shared/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodemailer/lib/shared/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">689</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">93.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.18</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint no-console: 0 */

&#039;use strict&#039;;

const urllib = require(&#039;url&#039;);
const util = require(&#039;util&#039;);
const fs = require(&#039;fs&#039;);
const nmfetch = require(&#039;../fetch&#039;);
const dns = require(&#039;dns&#039;);
const net = require(&#039;net&#039;);
const os = require(&#039;os&#039;);

const DNS_TTL = 5 * 60 * 1000;

let networkInterfaces;
try {
    networkInterfaces = os.networkInterfaces();
} catch (err) {
    // fails on some systems
}

module.exports.networkInterfaces = networkInterfaces;

const isFamilySupported = (family, allowInternal) =&gt; {
    let networkInterfaces = module.exports.networkInterfaces;
    if (!networkInterfaces) {
        // hope for the best
        return true;
    }

    const familySupported =
        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
        Object.keys(networkInterfaces)
            .map(key =&gt; networkInterfaces[key])
            // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)
            .reduce((acc, val) =&gt; acc.concat(val), [])
            .filter(i =&gt; !i.internal || allowInternal)
            .filter(i =&gt; i.family === &#039;IPv&#039; + family || i.family === family).length &gt; 0;

    return familySupported;
};

const resolver = (family, hostname, options, callback) =&gt; {
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);

    if (!familySupported) {
        return callback(null, []);
    }

    const resolver = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver[&#039;resolve&#039; + family](hostname, (err, addresses) =&gt; {
        if (err) {
            switch (err.code) {
                case dns.NODATA:
                case dns.NOTFOUND:
                case dns.NOTIMP:
                case dns.SERVFAIL:
                case dns.CONNREFUSED:
                case dns.REFUSED:
                case &#039;EAI_AGAIN&#039;:
                    return callback(null, []);
            }
            return callback(err);
        }
        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
};

const dnsCache = (module.exports.dnsCache = new Map());

const formatDNSValue = (value, extra) =&gt; {
    if (!value) {
        return Object.assign({}, extra || {});
    }

    return Object.assign(
        {
            servername: value.servername,
            host:
                !value.addresses || !value.addresses.length
                    ? null
                    : value.addresses.length === 1
                    ? value.addresses[0]
                    : value.addresses[Math.floor(Math.random() * value.addresses.length)]
        },
        extra || {}
    );
};

module.exports.resolveHostname = (options, callback) =&gt; {
    options = options || {};

    if (!options.host &amp;&amp; options.servername) {
        options.host = options.servername;
    }

    if (!options.host || net.isIP(options.host)) {
        // nothing to do here
        let value = {
            addresses: [options.host],
            servername: options.servername || false
        };
        return callback(
            null,
            formatDNSValue(value, {
                cached: false
            })
        );
    }

    let cached;
    if (dnsCache.has(options.host)) {
        cached = dnsCache.get(options.host);

        if (!cached.expires || cached.expires &gt;= Date.now()) {
            return callback(
                null,
                formatDNSValue(cached.value, {
                    cached: true
                })
            );
        }
    }

    resolver(4, options.host, options, (err, addresses) =&gt; {
        if (err) {
            if (cached) {
                // ignore error, use expired value
                return callback(
                    null,
                    formatDNSValue(cached.value, {
                        cached: true,
                        error: err
                    })
                );
            }
            return callback(err);
        }

        if (addresses &amp;&amp; addresses.length) {
            let value = {
                addresses,
                servername: options.servername || options.host
            };

            dnsCache.set(options.host, {
                value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });

            return callback(
                null,
                formatDNSValue(value, {
                    cached: false
                })
            );
        }

        resolver(6, options.host, options, (err, addresses) =&gt; {
            if (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(
                        null,
                        formatDNSValue(cached.value, {
                            cached: true,
                            error: err
                        })
                    );
                }
                return callback(err);
            }

            if (addresses &amp;&amp; addresses.length) {
                let value = {
                    addresses,
                    servername: options.servername || options.host
                };

                dnsCache.set(options.host, {
                    value,
                    expires: Date.now() + (options.dnsTtl || DNS_TTL)
                });

                return callback(
                    null,
                    formatDNSValue(value, {
                        cached: false
                    })
                );
            }

            try {
                dns.lookup(options.host, { all: true }, (err, addresses) =&gt; {
                    if (err) {
                        if (cached) {
                            // ignore error, use expired value
                            return callback(
                                null,
                                formatDNSValue(cached.value, {
                                    cached: true,
                                    error: err
                                })
                            );
                        }
                        return callback(err);
                    }

                    let address = addresses
                        ? addresses
                              .filter(addr =&gt; isFamilySupported(addr.family))
                              .map(addr =&gt; addr.address)
                              .shift()
                        : false;

                    if (addresses &amp;&amp; addresses.length &amp;&amp; !address) {
                        // there are addresses but none can be used
                        console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);
                    }

                    if (!address &amp;&amp; cached) {
                        // nothing was found, fallback to cached value
                        return callback(
                            null,
                            formatDNSValue(cached.value, {
                                cached: true
                            })
                        );
                    }

                    let value = {
                        addresses: address ? [address] : [options.host],
                        servername: options.servername || options.host
                    };

                    dnsCache.set(options.host, {
                        value,
                        expires: Date.now() + (options.dnsTtl || DNS_TTL)
                    });

                    return callback(
                        null,
                        formatDNSValue(value, {
                            cached: false
                        })
                    );
                });
            } catch (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(
                        null,
                        formatDNSValue(cached.value, {
                            cached: true,
                            error: err
                        })
                    );
                }
                return callback(err);
            }
        });
    });
};
/**
 * Parses connection url to a structured configuration object
 *
 * @param {String} str Connection url
 * @return {Object} Configuration object
 */
module.exports.parseConnectionUrl = str =&gt; {
    str = str || &#039;&#039;;
    let options = {};

    [urllib.parse(str, true)].forEach(url =&gt; {
        let auth;

        switch (url.protocol) {
            case &#039;smtp:&#039;:
                options.secure = false;
                break;
            case &#039;smtps:&#039;:
                options.secure = true;
                break;
            case &#039;direct:&#039;:
                options.direct = true;
                break;
        }

        if (!isNaN(url.port) &amp;&amp; Number(url.port)) {
            options.port = Number(url.port);
        }

        if (url.hostname) {
            options.host = url.hostname;
        }

        if (url.auth) {
            auth = url.auth.split(&#039;:&#039;);

            if (!options.auth) {
                options.auth = {};
            }

            options.auth.user = auth.shift();
            options.auth.pass = auth.join(&#039;:&#039;);
        }

        Object.keys(url.query || {}).forEach(key =&gt; {
            let obj = options;
            let lKey = key;
            let value = url.query[key];

            if (!isNaN(value)) {
                value = Number(value);
            }

            switch (value) {
                case &#039;true&#039;:
                    value = true;
                    break;
                case &#039;false&#039;:
                    value = false;
                    break;
            }

            // tls is nested object
            if (key.indexOf(&#039;tls.&#039;) === 0) {
                lKey = key.substr(4);
                if (!options.tls) {
                    options.tls = {};
                }
                obj = options.tls;
            } else if (key.indexOf(&#039;.&#039;) &gt;= 0) {
                // ignore nested properties besides tls
                return;
            }

            if (!(lKey in obj)) {
                obj[lKey] = value;
            }
        });
    });

    return options;
};

module.exports._logFunc = (logger, level, defaults, data, message, ...args) =&gt; {
    let entry = {};

    Object.keys(defaults || {}).forEach(key =&gt; {
        if (key !== &#039;level&#039;) {
            entry[key] = defaults[key];
        }
    });

    Object.keys(data || {}).forEach(key =&gt; {
        if (key !== &#039;level&#039;) {
            entry[key] = data[key];
        }
    });

    logger[level](entry, message, ...args);
};

/**
 * Returns a bunyan-compatible logger interface. Uses either provided logger or
 * creates a default console logger
 *
 * @param {Object} [options] Options object that might include &#039;logger&#039; value
 * @return {Object} bunyan compatible logger
 */
module.exports.getLogger = (options, defaults) =&gt; {
    options = options || {};

    let response = {};
    let levels = [&#039;trace&#039;, &#039;debug&#039;, &#039;info&#039;, &#039;warn&#039;, &#039;error&#039;, &#039;fatal&#039;];

    if (!options.logger) {
        // use vanity logger
        levels.forEach(level =&gt; {
            response[level] = () =&gt; false;
        });
        return response;
    }

    let logger = options.logger;

    if (options.logger === true) {
        // create console logger
        logger = createDefaultLogger(levels);
    }

    levels.forEach(level =&gt; {
        response[level] = (data, message, ...args) =&gt; {
            module.exports._logFunc(logger, level, defaults, data, message, ...args);
        };
    });

    return response;
};

/**
 * Wrapper for creating a callback that either resolves or rejects a promise
 * based on input
 *
 * @param {Function} resolve Function to run if callback is called
 * @param {Function} reject Function to run if callback ends with an error
 */
module.exports.callbackPromise = (resolve, reject) =&gt;
    function () {
        let args = Array.from(arguments);
        let err = args.shift();
        if (err) {
            reject(err);
        } else {
            resolve(...args);
        }
    };

module.exports.parseDataURI = uri =&gt; {
    let input = uri;
    let commaPos = input.indexOf(&#039;,&#039;);
    if (!commaPos) {
        return uri;
    }

    let data = input.substring(commaPos + 1);
    let metaStr = input.substring(&#039;data:&#039;.length, commaPos);

    let encoding;

    let metaEntries = metaStr.split(&#039;;&#039;);
    let lastMetaEntry = metaEntries.length &gt; 1 ? metaEntries[metaEntries.length - 1] : false;
    if (lastMetaEntry &amp;&amp; lastMetaEntry.indexOf(&#039;=&#039;) &lt; 0) {
        encoding = lastMetaEntry.toLowerCase();
        metaEntries.pop();
    }

    let contentType = metaEntries.shift() || &#039;application/octet-stream&#039;;
    let params = {};
    for (let entry of metaEntries) {
        let sep = entry.indexOf(&#039;=&#039;);
        if (sep &gt;= 0) {
            let key = entry.substring(0, sep);
            let value = entry.substring(sep + 1);
            params[key] = value;
        }
    }

    switch (encoding) {
        case &#039;base64&#039;:
            data = Buffer.from(data, &#039;base64&#039;);
            break;
        case &#039;utf8&#039;:
            data = Buffer.from(data);
            break;
        default:
            try {
                data = Buffer.from(decodeURIComponent(data));
            } catch (err) {
                data = Buffer.from(data);
            }
            data = Buffer.from(data);
    }

    return { data, encoding, contentType, params };
};

/**
 * Resolves a String or a Buffer value for content value. Useful if the value
 * is a Stream or a file or an URL. If the value is a Stream, overwrites
 * the stream object with the resolved value (you can&#039;t stream a value twice).
 *
 * This is useful when you want to create a plugin that needs a content value,
 * for example the `html` or `text` value as a String or a Buffer but not as
 * a file path or an URL.
 *
 * @param {Object} data An object or an Array you want to resolve an element for
 * @param {String|Number} key Property name or an Array index
 * @param {Function} callback Callback function with (err, value)
 */
module.exports.resolveContent = (data, key, callback) =&gt; {
    let promise;

    if (!callback) {
        promise = new Promise((resolve, reject) =&gt; {
            callback = module.exports.callbackPromise(resolve, reject);
        });
    }

    let content = (data &amp;&amp; data[key] &amp;&amp; data[key].content) || data[key];
    let contentStream;
    let encoding = ((typeof data[key] === &#039;object&#039; &amp;&amp; data[key].encoding) || &#039;utf8&#039;)
        .toString()
        .toLowerCase()
        .replace(/[-_\s]/g, &#039;&#039;);

    if (!content) {
        return callback(null, content);
    }

    if (typeof content === &#039;object&#039;) {
        if (typeof content.pipe === &#039;function&#039;) {
            return resolveStream(content, (err, value) =&gt; {
                if (err) {
                    return callback(err);
                }
                // we can&#039;t stream twice the same content, so we need
                // to replace the stream object with the streaming result
                if (data[key].content) {
                    data[key].content = value;
                } else {
                    data[key] = value;
                }
                callback(null, value);
            });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
            contentStream = nmfetch(content.path || content.href);
            return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content.path || content.href)) {
            let parsedDataUri = module.exports.parseDataURI(content.path || content.href);

            if (!parsedDataUri || !parsedDataUri.data) {
                return callback(null, Buffer.from(0));
            }
            return callback(null, parsedDataUri.data);
        } else if (content.path) {
            return resolveStream(fs.createReadStream(content.path), callback);
        }
    }

    if (typeof data[key].content === &#039;string&#039; &amp;&amp; ![&#039;utf8&#039;, &#039;usascii&#039;, &#039;ascii&#039;].includes(encoding)) {
        content = Buffer.from(data[key].content, encoding);
    }

    // default action, return as is
    setImmediate(() =&gt; callback(null, content));

    return promise;
};

/**
 * Copies properties from source objects to target objects
 */
module.exports.assign = function (/* target, ... sources */) {
    let args = Array.from(arguments);
    let target = args.shift() || {};

    args.forEach(source =&gt; {
        Object.keys(source || {}).forEach(key =&gt; {
            if ([&#039;tls&#039;, &#039;auth&#039;].includes(key) &amp;&amp; source[key] &amp;&amp; typeof source[key] === &#039;object&#039;) {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // ensure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach(subKey =&gt; {
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
};

module.exports.encodeXText = str =&gt; {
    // ! 0x21
    // + 0x2B
    // = 0x3D
    // ~ 0x7E
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
    }
    let buf = Buffer.from(str);
    let result = &#039;&#039;;
    for (let i = 0, len = buf.length; i &lt; len; i++) {
        let c = buf[i];
        if (c &lt; 0x21 || c &gt; 0x7e || c === 0x2b || c === 0x3d) {
            result += &#039;+&#039; + (c &lt; 0x10 ? &#039;0&#039; : &#039;&#039;) + c.toString(16).toUpperCase();
        } else {
            result += String.fromCharCode(c);
        }
    }
    return result;
};

/**
 * Streams a stream value into a Buffer
 *
 * @param {Object} stream Readable stream
 * @param {Function} callback Callback function with (err, value)
 */
function resolveStream(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;

    stream.on(&#039;error&#039;, err =&gt; {
        if (responded) {
            return;
        }

        responded = true;
        callback(err);
    });

    stream.on(&#039;readable&#039;, () =&gt; {
        let chunk;
        while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });

    stream.on(&#039;end&#039;, () =&gt; {
        if (responded) {
            return;
        }
        responded = true;

        let value;

        try {
            value = Buffer.concat(chunks, chunklen);
        } catch (E) {
            return callback(E);
        }
        callback(null, value);
    });
}

/**
 * Generates a bunyan-like logger that prints to console
 *
 * @returns {Object} Bunyan logger instance
 */
function createDefaultLogger(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map();
    levels.forEach(level =&gt; {
        if (level.length &gt; levelMaxLen) {
            levelMaxLen = level.length;
        }
    });

    levels.forEach(level =&gt; {
        let levelName = level.toUpperCase();
        if (levelName.length &lt; levelMaxLen) {
            levelName += &#039; &#039;.repeat(levelMaxLen - levelName.length);
        }
        levelNames.set(level, levelName);
    });

    let print = (level, entry, message, ...args) =&gt; {
        let prefix = &#039;&#039;;
        if (entry) {
            if (entry.tnx === &#039;server&#039;) {
                prefix = &#039;S: &#039;;
            } else if (entry.tnx === &#039;client&#039;) {
                prefix = &#039;C: &#039;;
            }

            if (entry.sid) {
                prefix = &#039;[&#039; + entry.sid + &#039;] &#039; + prefix;
            }

            if (entry.cid) {
                prefix = &#039;[#&#039; + entry.cid + &#039;] &#039; + prefix;
            }
        }

        message = util.format(message, ...args);
        message.split(/\r?\n/).forEach(line =&gt; {
            console.log(&#039;[%s] %s %s&#039;, new Date().toISOString().substr(0, 19).replace(/T/, &#039; &#039;), levelNames.get(level), prefix + line);
        });
    };

    let logger = {};
    levels.forEach(level =&gt; {
        logger[level] = print.bind(null, level);
    });

    return logger;
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
