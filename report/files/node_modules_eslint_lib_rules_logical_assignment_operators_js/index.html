<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/eslint/lib/rules/logical-assignment-operators.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/eslint/lib/rules/logical-assignment-operators.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">689</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.23</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.38</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview Rule to replace assignment expressions with logical operator assignment
 * @author Daniel Martens
 */
&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = require(&quot;./utils/ast-utils.js&quot;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const baseTypes = new Set([&quot;Identifier&quot;, &quot;Super&quot;, &quot;ThisExpression&quot;]);

/**
 * Returns true iff either &quot;undefined&quot; or a void expression (eg. &quot;void 0&quot;)
 * @param {ASTNode} expression Expression to check
 * @param {import(&#039;eslint-scope&#039;).Scope} scope Scope of the expression
 * @returns {boolean} True iff &quot;undefined&quot; or &quot;void ...&quot;
 */
function isUndefined(expression, scope) {
	if (expression.type === &quot;Identifier&quot; &amp;&amp; expression.name === &quot;undefined&quot;) {
		return astUtils.isReferenceToGlobalVariable(scope, expression);
	}

	return (
		expression.type === &quot;UnaryExpression&quot; &amp;&amp;
		expression.operator === &quot;void&quot; &amp;&amp;
		expression.argument.type === &quot;Literal&quot; &amp;&amp;
		expression.argument.value === 0
	);
}

/**
 * Returns true iff the reference is either an identifier or member expression
 * @param {ASTNode} expression Expression to check
 * @returns {boolean} True for identifiers and member expressions
 */
function isReference(expression) {
	return (
		(expression.type === &quot;Identifier&quot; &amp;&amp; expression.name !== &quot;undefined&quot;) ||
		expression.type === &quot;MemberExpression&quot;
	);
}

/**
 * Returns true iff the expression checks for nullish with loose equals.
 * Examples: value == null, value == void 0
 * @param {ASTNode} expression Test condition
 * @param {import(&#039;eslint-scope&#039;).Scope} scope Scope of the expression
 * @returns {boolean} True iff implicit nullish comparison
 */
function isImplicitNullishComparison(expression, scope) {
	if (
		expression.type !== &quot;BinaryExpression&quot; ||
		expression.operator !== &quot;==&quot;
	) {
		return false;
	}

	const reference = isReference(expression.left) ? &quot;left&quot; : &quot;right&quot;;
	const nullish = reference === &quot;left&quot; ? &quot;right&quot; : &quot;left&quot;;

	return (
		isReference(expression[reference]) &amp;&amp;
		(astUtils.isNullLiteral(expression[nullish]) ||
			isUndefined(expression[nullish], scope))
	);
}

/**
 * Condition with two equal comparisons.
 * @param {ASTNode} expression Condition
 * @returns {boolean} True iff matches ? === ? || ? === ?
 */
function isDoubleComparison(expression) {
	return (
		expression.type === &quot;LogicalExpression&quot; &amp;&amp;
		expression.operator === &quot;||&quot; &amp;&amp;
		expression.left.type === &quot;BinaryExpression&quot; &amp;&amp;
		expression.left.operator === &quot;===&quot; &amp;&amp;
		expression.right.type === &quot;BinaryExpression&quot; &amp;&amp;
		expression.right.operator === &quot;===&quot;
	);
}

/**
 * Returns true iff the expression checks for undefined and null.
 * Example: value === null || value === undefined
 * @param {ASTNode} expression Test condition
 * @param {import(&#039;eslint-scope&#039;).Scope} scope Scope of the expression
 * @returns {boolean} True iff explicit nullish comparison
 */
function isExplicitNullishComparison(expression, scope) {
	if (!isDoubleComparison(expression)) {
		return false;
	}
	const leftReference = isReference(expression.left.left) ? &quot;left&quot; : &quot;right&quot;;
	const leftNullish = leftReference === &quot;left&quot; ? &quot;right&quot; : &quot;left&quot;;
	const rightReference = isReference(expression.right.left)
		? &quot;left&quot;
		: &quot;right&quot;;
	const rightNullish = rightReference === &quot;left&quot; ? &quot;right&quot; : &quot;left&quot;;

	return (
		astUtils.isSameReference(
			expression.left[leftReference],
			expression.right[rightReference],
		) &amp;&amp;
		((astUtils.isNullLiteral(expression.left[leftNullish]) &amp;&amp;
			isUndefined(expression.right[rightNullish], scope)) ||
			(isUndefined(expression.left[leftNullish], scope) &amp;&amp;
				astUtils.isNullLiteral(expression.right[rightNullish])))
	);
}

/**
 * Returns true for Boolean(arg) calls
 * @param {ASTNode} expression Test condition
 * @param {import(&#039;eslint-scope&#039;).Scope} scope Scope of the expression
 * @returns {boolean} Whether the expression is a boolean cast
 */
function isBooleanCast(expression, scope) {
	return (
		expression.type === &quot;CallExpression&quot; &amp;&amp;
		expression.callee.name === &quot;Boolean&quot; &amp;&amp;
		expression.arguments.length === 1 &amp;&amp;
		astUtils.isReferenceToGlobalVariable(scope, expression.callee)
	);
}

/**
 * Returns true for:
 * truthiness checks:  value, Boolean(value), !!value
 * falsiness checks:   !value, !Boolean(value)
 * nullish checks:     value == null, value === undefined || value === null
 * @param {ASTNode} expression Test condition
 * @param {import(&#039;eslint-scope&#039;).Scope} scope Scope of the expression
 * @returns {?{ reference: ASTNode, operator: &#039;??&#039;|&#039;||&#039;|&#039;&amp;&amp;&#039;}} Null if not a known existence
 */
function getExistence(expression, scope) {
	const isNegated =
		expression.type === &quot;UnaryExpression&quot; &amp;&amp; expression.operator === &quot;!&quot;;
	const base = isNegated ? expression.argument : expression;

	switch (true) {
		case isReference(base):
			return { reference: base, operator: isNegated ? &quot;||&quot; : &quot;&amp;&amp;&quot; };
		case base.type === &quot;UnaryExpression&quot; &amp;&amp;
			base.operator === &quot;!&quot; &amp;&amp;
			isReference(base.argument):
			return { reference: base.argument, operator: &quot;&amp;&amp;&quot; };
		case isBooleanCast(base, scope) &amp;&amp; isReference(base.arguments[0]):
			return {
				reference: base.arguments[0],
				operator: isNegated ? &quot;||&quot; : &quot;&amp;&amp;&quot;,
			};
		case isImplicitNullishComparison(expression, scope):
			return {
				reference: isReference(expression.left)
					? expression.left
					: expression.right,
				operator: &quot;??&quot;,
			};
		case isExplicitNullishComparison(expression, scope):
			return {
				reference: isReference(expression.left.left)
					? expression.left.left
					: expression.left.right,
				operator: &quot;??&quot;,
			};
		default:
			return null;
	}
}

/**
 * Returns true iff the node is inside a with block
 * @param {ASTNode} node Node to check
 * @returns {boolean} True iff passed node is inside a with block
 */
function isInsideWithBlock(node) {
	if (node.type === &quot;Program&quot;) {
		return false;
	}

	return node.parent.type === &quot;WithStatement&quot; &amp;&amp; node.parent.body === node
		? true
		: isInsideWithBlock(node.parent);
}

/**
 * Gets the leftmost operand of a consecutive logical expression.
 * @param {SourceCode} sourceCode The ESLint source code object
 * @param {LogicalExpression} node LogicalExpression
 * @returns {Expression} Leftmost operand
 */
function getLeftmostOperand(sourceCode, node) {
	let left = node.left;

	while (
		left.type === &quot;LogicalExpression&quot; &amp;&amp;
		left.operator === node.operator
	) {
		if (astUtils.isParenthesised(sourceCode, left)) {
			/*
			 * It should have associativity,
			 * but ignore it if use parentheses to make the evaluation order clear.
			 */
			return left;
		}
		left = left.left;
	}
	return left;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;suggestion&quot;,

		docs: {
			description:
				&quot;Require or disallow logical assignment operator shorthand&quot;,
			recommended: false,
			frozen: true,
			url: &quot;https://eslint.org/docs/latest/rules/logical-assignment-operators&quot;,
		},

		schema: {
			type: &quot;array&quot;,
			oneOf: [
				{
					items: [
						{ const: &quot;always&quot; },
						{
							type: &quot;object&quot;,
							properties: {
								enforceForIfStatements: {
									type: &quot;boolean&quot;,
								},
							},
							additionalProperties: false,
						},
					],
					minItems: 0, // 0 for allowing passing no options
					maxItems: 2,
				},
				{
					items: [{ const: &quot;never&quot; }],
					minItems: 1,
					maxItems: 1,
				},
			],
		},
		fixable: &quot;code&quot;,
		hasSuggestions: true,
		messages: {
			assignment:
				&quot;Assignment (=) can be replaced with operator assignment ({{operator}}).&quot;,
			useLogicalOperator:
				&quot;Convert this assignment to use the operator {{ operator }}.&quot;,
			logical:
				&quot;Logical expression can be replaced with an assignment ({{ operator }}).&quot;,
			convertLogical:
				&quot;Replace this logical expression with an assignment with the operator {{ operator }}.&quot;,
			if: &quot;&#039;if&#039; statement can be replaced with a logical operator assignment with operator {{ operator }}.&quot;,
			convertIf:
				&quot;Replace this &#039;if&#039; statement with a logical assignment with operator {{ operator }}.&quot;,
			unexpected:
				&quot;Unexpected logical operator assignment ({{operator}}) shorthand.&quot;,
			separate:
				&quot;Separate the logical assignment into an assignment with a logical operator.&quot;,
		},
	},

	create(context) {
		const mode = context.options[0] === &quot;never&quot; ? &quot;never&quot; : &quot;always&quot;;
		const checkIf =
			mode === &quot;always&quot; &amp;&amp;
			context.options.length &gt; 1 &amp;&amp;
			context.options[1].enforceForIfStatements;
		const sourceCode = context.sourceCode;
		const isStrict = sourceCode.getScope(sourceCode.ast).isStrict;

		/**
		 * Returns false if the access could be a getter
		 * @param {ASTNode} node Assignment expression
		 * @returns {boolean} True iff the fix is safe
		 */
		function cannotBeGetter(node) {
			return (
				node.type === &quot;Identifier&quot; &amp;&amp;
				(isStrict || !isInsideWithBlock(node))
			);
		}

		/**
		 * Check whether only a single property is accessed
		 * @param {ASTNode} node reference
		 * @returns {boolean} True iff a single property is accessed
		 */
		function accessesSingleProperty(node) {
			if (!isStrict &amp;&amp; isInsideWithBlock(node)) {
				return node.type === &quot;Identifier&quot;;
			}

			return (
				node.type === &quot;MemberExpression&quot; &amp;&amp;
				baseTypes.has(node.object.type) &amp;&amp;
				(!node.computed ||
					(node.property.type !== &quot;MemberExpression&quot; &amp;&amp;
						node.property.type !== &quot;ChainExpression&quot;))
			);
		}

		/**
		 * Adds a fixer or suggestion whether on the fix is safe.
		 * @param {{ messageId: string, node: ASTNode }} descriptor Report descriptor without fix or suggest
		 * @param {{ messageId: string, fix: Function }} suggestion Adds the fix or the whole suggestion as only element in &quot;suggest&quot; to suggestion
		 * @param {boolean} shouldBeFixed Fix iff the condition is true
		 * @returns {Object} Descriptor with either an added fix or suggestion
		 */
		function createConditionalFixer(descriptor, suggestion, shouldBeFixed) {
			if (shouldBeFixed) {
				return {
					...descriptor,
					fix: suggestion.fix,
				};
			}

			return {
				...descriptor,
				suggest: [suggestion],
			};
		}

		/**
		 * Returns the operator token for assignments and binary expressions
		 * @param {ASTNode} node AssignmentExpression or BinaryExpression
		 * @returns {import(&#039;eslint&#039;).AST.Token} Operator token between the left and right expression
		 */
		function getOperatorToken(node) {
			return sourceCode.getFirstTokenBetween(
				node.left,
				node.right,
				token =&gt; token.value === node.operator,
			);
		}

		if (mode === &quot;never&quot;) {
			return {
				// foo ||= bar
				AssignmentExpression(assignment) {
					if (
						!astUtils.isLogicalAssignmentOperator(
							assignment.operator,
						)
					) {
						return;
					}

					const descriptor = {
						messageId: &quot;unexpected&quot;,
						node: assignment,
						data: { operator: assignment.operator },
					};
					const suggestion = {
						messageId: &quot;separate&quot;,
						*fix(ruleFixer) {
							if (
								sourceCode.getCommentsInside(assignment)
									.length &gt; 0
							) {
								return;
							}

							const operatorToken = getOperatorToken(assignment);

							// -&gt; foo = bar
							yield ruleFixer.replaceText(operatorToken, &quot;=&quot;);

							const assignmentText = sourceCode.getText(
								assignment.left,
							);
							const operator = assignment.operator.slice(0, -1);

							// -&gt; foo = foo || bar
							yield ruleFixer.insertTextAfter(
								operatorToken,
								` ${assignmentText} ${operator}`,
							);

							const precedence =
								astUtils.getPrecedence(assignment.right) &lt;=
								astUtils.getPrecedence({
									type: &quot;LogicalExpression&quot;,
									operator,
								});

							// ?? and || / &amp;&amp; cannot be mixed but have same precedence
							const mixed =
								assignment.operator === &quot;??=&quot; &amp;&amp;
								astUtils.isLogicalExpression(assignment.right);

							if (
								!astUtils.isParenthesised(
									sourceCode,
									assignment.right,
								) &amp;&amp;
								(precedence || mixed)
							) {
								// -&gt; foo = foo || (bar)
								yield ruleFixer.insertTextBefore(
									assignment.right,
									&quot;(&quot;,
								);
								yield ruleFixer.insertTextAfter(
									assignment.right,
									&quot;)&quot;,
								);
							}
						},
					};

					context.report(
						createConditionalFixer(
							descriptor,
							suggestion,
							cannotBeGetter(assignment.left),
						),
					);
				},
			};
		}

		return {
			// foo = foo || bar
			&quot;AssignmentExpression[operator=&#039;=&#039;][right.type=&#039;LogicalExpression&#039;]&quot;(
				assignment,
			) {
				const leftOperand = getLeftmostOperand(
					sourceCode,
					assignment.right,
				);

				if (!astUtils.isSameReference(assignment.left, leftOperand)) {
					return;
				}

				const descriptor = {
					messageId: &quot;assignment&quot;,
					node: assignment,
					data: { operator: `${assignment.right.operator}=` },
				};
				const suggestion = {
					messageId: &quot;useLogicalOperator&quot;,
					data: { operator: `${assignment.right.operator}=` },
					*fix(ruleFixer) {
						if (
							sourceCode.getCommentsInside(assignment).length &gt; 0
						) {
							return;
						}

						// No need for parenthesis around the assignment based on precedence as the precedence stays the same even with changed operator
						const assignmentOperatorToken =
							getOperatorToken(assignment);

						// -&gt; foo ||= foo || bar
						yield ruleFixer.insertTextBefore(
							assignmentOperatorToken,
							assignment.right.operator,
						);

						// -&gt; foo ||= bar
						const logicalOperatorToken = getOperatorToken(
							leftOperand.parent,
						);
						const firstRightOperandToken =
							sourceCode.getTokenAfter(logicalOperatorToken);

						yield ruleFixer.removeRange([
							leftOperand.parent.range[0],
							firstRightOperandToken.range[0],
						]);
					},
				};

				context.report(
					createConditionalFixer(
						descriptor,
						suggestion,
						cannotBeGetter(assignment.left),
					),
				);
			},

			// foo || (foo = bar)
			&#039;LogicalExpression[right.type=&quot;AssignmentExpression&quot;][right.operator=&quot;=&quot;]&#039;(
				logical,
			) {
				// Right side has to be parenthesized, otherwise would be parsed as (foo || foo) = bar which is illegal
				if (
					isReference(logical.left) &amp;&amp;
					astUtils.isSameReference(logical.left, logical.right.left)
				) {
					const descriptor = {
						messageId: &quot;logical&quot;,
						node: logical,
						data: { operator: `${logical.operator}=` },
					};
					const suggestion = {
						messageId: &quot;convertLogical&quot;,
						data: { operator: `${logical.operator}=` },
						*fix(ruleFixer) {
							if (
								sourceCode.getCommentsInside(logical).length &gt; 0
							) {
								return;
							}

							const parentPrecedence = astUtils.getPrecedence(
								logical.parent,
							);
							const requiresOuterParenthesis =
								logical.parent.type !== &quot;ExpressionStatement&quot; &amp;&amp;
								(parentPrecedence === -1 ||
									astUtils.getPrecedence({
										type: &quot;AssignmentExpression&quot;,
									}) &lt; parentPrecedence);

							if (
								!astUtils.isParenthesised(
									sourceCode,
									logical,
								) &amp;&amp;
								requiresOuterParenthesis
							) {
								yield ruleFixer.insertTextBefore(logical, &quot;(&quot;);
								yield ruleFixer.insertTextAfter(logical, &quot;)&quot;);
							}

							// Also removes all opening parenthesis
							yield ruleFixer.removeRange([
								logical.range[0],
								logical.right.range[0],
							]); // -&gt; foo = bar)

							// Also removes all ending parenthesis
							yield ruleFixer.removeRange([
								logical.right.range[1],
								logical.range[1],
							]); // -&gt; foo = bar

							const operatorToken = getOperatorToken(
								logical.right,
							);

							yield ruleFixer.insertTextBefore(
								operatorToken,
								logical.operator,
							); // -&gt; foo ||= bar
						},
					};
					const fix =
						cannotBeGetter(logical.left) ||
						accessesSingleProperty(logical.left);

					context.report(
						createConditionalFixer(descriptor, suggestion, fix),
					);
				}
			},

			// if (foo) foo = bar
			&quot;IfStatement[alternate=null]&quot;(ifNode) {
				if (!checkIf) {
					return;
				}

				const hasBody = ifNode.consequent.type === &quot;BlockStatement&quot;;

				if (hasBody &amp;&amp; ifNode.consequent.body.length !== 1) {
					return;
				}

				const body = hasBody
					? ifNode.consequent.body[0]
					: ifNode.consequent;
				const scope = sourceCode.getScope(ifNode);
				const existence = getExistence(ifNode.test, scope);

				if (
					body.type === &quot;ExpressionStatement&quot; &amp;&amp;
					body.expression.type === &quot;AssignmentExpression&quot; &amp;&amp;
					body.expression.operator === &quot;=&quot; &amp;&amp;
					existence !== null &amp;&amp;
					astUtils.isSameReference(
						existence.reference,
						body.expression.left,
					)
				) {
					const descriptor = {
						messageId: &quot;if&quot;,
						node: ifNode,
						data: { operator: `${existence.operator}=` },
					};
					const suggestion = {
						messageId: &quot;convertIf&quot;,
						data: { operator: `${existence.operator}=` },
						*fix(ruleFixer) {
							if (
								sourceCode.getCommentsInside(ifNode).length &gt; 0
							) {
								return;
							}

							const firstBodyToken =
								sourceCode.getFirstToken(body);
							const prevToken = sourceCode.getTokenBefore(ifNode);

							if (
								prevToken !== null &amp;&amp;
								prevToken.value !== &quot;;&quot; &amp;&amp;
								prevToken.value !== &quot;{&quot; &amp;&amp;
								firstBodyToken.type !== &quot;Identifier&quot; &amp;&amp;
								firstBodyToken.type !== &quot;Keyword&quot;
							) {
								// Do not fix if the fixed statement could be part of the previous statement (eg. fn() if (a == null) (a) = b --&gt; fn()(a) ??= b)
								return;
							}

							const operatorToken = getOperatorToken(
								body.expression,
							);

							yield ruleFixer.insertTextBefore(
								operatorToken,
								existence.operator,
							); // -&gt; if (foo) foo ||= bar

							yield ruleFixer.removeRange([
								ifNode.range[0],
								body.range[0],
							]); // -&gt; foo ||= bar

							yield ruleFixer.removeRange([
								body.range[1],
								ifNode.range[1],
							]); // -&gt; foo ||= bar, only present if &quot;if&quot; had a body

							const nextToken = sourceCode.getTokenAfter(
								body.expression,
							);

							if (
								hasBody &amp;&amp;
								nextToken !== null &amp;&amp;
								nextToken.value !== &quot;;&quot;
							) {
								yield ruleFixer.insertTextAfter(ifNode, &quot;;&quot;);
							}
						},
					};
					const shouldBeFixed =
						cannotBeGetter(existence.reference) ||
						(ifNode.test.type !== &quot;LogicalExpression&quot; &amp;&amp;
							accessesSingleProperty(existence.reference));

					context.report(
						createConditionalFixer(
							descriptor,
							suggestion,
							shouldBeFixed,
						),
					);
				}
			},
		};
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
