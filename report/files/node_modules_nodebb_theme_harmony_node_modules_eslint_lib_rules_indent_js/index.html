<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/indent.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-theme-harmony/node_modules/eslint/lib/rules/indent.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2335</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">117.59</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">16.46</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @fileoverview This rule sets a specific indentation style and width for your code
 *
 * @author Teddy Katz
 * @author Vitaly Puzrin
 * @author Gyandeep Singh
 * @deprecated in ESLint v8.53.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require(&quot;./utils/ast-utils&quot;);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const KNOWN_NODES = new Set([
	&quot;AssignmentExpression&quot;,
	&quot;AssignmentPattern&quot;,
	&quot;ArrayExpression&quot;,
	&quot;ArrayPattern&quot;,
	&quot;ArrowFunctionExpression&quot;,
	&quot;AwaitExpression&quot;,
	&quot;BlockStatement&quot;,
	&quot;BinaryExpression&quot;,
	&quot;BreakStatement&quot;,
	&quot;CallExpression&quot;,
	&quot;CatchClause&quot;,
	&quot;ChainExpression&quot;,
	&quot;ClassBody&quot;,
	&quot;ClassDeclaration&quot;,
	&quot;ClassExpression&quot;,
	&quot;ConditionalExpression&quot;,
	&quot;ContinueStatement&quot;,
	&quot;DoWhileStatement&quot;,
	&quot;DebuggerStatement&quot;,
	&quot;EmptyStatement&quot;,
	&quot;ExperimentalRestProperty&quot;,
	&quot;ExperimentalSpreadProperty&quot;,
	&quot;ExpressionStatement&quot;,
	&quot;ForStatement&quot;,
	&quot;ForInStatement&quot;,
	&quot;ForOfStatement&quot;,
	&quot;FunctionDeclaration&quot;,
	&quot;FunctionExpression&quot;,
	&quot;Identifier&quot;,
	&quot;IfStatement&quot;,
	&quot;Literal&quot;,
	&quot;LabeledStatement&quot;,
	&quot;LogicalExpression&quot;,
	&quot;MemberExpression&quot;,
	&quot;MetaProperty&quot;,
	&quot;MethodDefinition&quot;,
	&quot;NewExpression&quot;,
	&quot;ObjectExpression&quot;,
	&quot;ObjectPattern&quot;,
	&quot;PrivateIdentifier&quot;,
	&quot;Program&quot;,
	&quot;Property&quot;,
	&quot;PropertyDefinition&quot;,
	&quot;RestElement&quot;,
	&quot;ReturnStatement&quot;,
	&quot;SequenceExpression&quot;,
	&quot;SpreadElement&quot;,
	&quot;StaticBlock&quot;,
	&quot;Super&quot;,
	&quot;SwitchCase&quot;,
	&quot;SwitchStatement&quot;,
	&quot;TaggedTemplateExpression&quot;,
	&quot;TemplateElement&quot;,
	&quot;TemplateLiteral&quot;,
	&quot;ThisExpression&quot;,
	&quot;ThrowStatement&quot;,
	&quot;TryStatement&quot;,
	&quot;UnaryExpression&quot;,
	&quot;UpdateExpression&quot;,
	&quot;VariableDeclaration&quot;,
	&quot;VariableDeclarator&quot;,
	&quot;WhileStatement&quot;,
	&quot;WithStatement&quot;,
	&quot;YieldExpression&quot;,
	&quot;JSXFragment&quot;,
	&quot;JSXOpeningFragment&quot;,
	&quot;JSXClosingFragment&quot;,
	&quot;JSXIdentifier&quot;,
	&quot;JSXNamespacedName&quot;,
	&quot;JSXMemberExpression&quot;,
	&quot;JSXEmptyExpression&quot;,
	&quot;JSXExpressionContainer&quot;,
	&quot;JSXElement&quot;,
	&quot;JSXClosingElement&quot;,
	&quot;JSXOpeningElement&quot;,
	&quot;JSXAttribute&quot;,
	&quot;JSXSpreadAttribute&quot;,
	&quot;JSXText&quot;,
	&quot;ExportDefaultDeclaration&quot;,
	&quot;ExportNamedDeclaration&quot;,
	&quot;ExportAllDeclaration&quot;,
	&quot;ExportSpecifier&quot;,
	&quot;ImportDeclaration&quot;,
	&quot;ImportSpecifier&quot;,
	&quot;ImportDefaultSpecifier&quot;,
	&quot;ImportNamespaceSpecifier&quot;,
	&quot;ImportExpression&quot;,
]);

/*
 * General rule strategy:
 * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another
 *    specified token or to the first column.
 * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a
 *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly
 *    brace of the BlockStatement.
 * 3. After traversing the AST, calculate the expected indentation levels of every token according to the
 *    OffsetStorage container.
 * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,
 *    and report the token if the two values are not equal.
 */

/**
 * A mutable map that stores (key, value) pairs. The keys are numeric indices, and must be unique.
 * This is intended to be a generic wrapper around a map with non-negative integer keys, so that the underlying implementation
 * can easily be swapped out.
 */
class IndexMap {
	/**
	 * Creates an empty map
	 * @param {number} maxKey The maximum key
	 */
	constructor(maxKey) {
		// Initializing the array with the maximum expected size avoids dynamic reallocations that could degrade performance.
		this._values = Array(maxKey + 1);
	}

	/**
	 * Inserts an entry into the map.
	 * @param {number} key The entry&#039;s key
	 * @param {any} value The entry&#039;s value
	 * @returns {void}
	 */
	insert(key, value) {
		this._values[key] = value;
	}

	/**
	 * Finds the value of the entry with the largest key less than or equal to the provided key
	 * @param {number} key The provided key
	 * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.
	 */
	findLastNotAfter(key) {
		const values = this._values;

		for (let index = key; index &gt;= 0; index--) {
			const value = values[index];

			if (value) {
				return value;
			}
		}
		return void 0;
	}

	/**
	 * Deletes all of the keys in the interval [start, end)
	 * @param {number} start The start of the range
	 * @param {number} end The end of the range
	 * @returns {void}
	 */
	deleteRange(start, end) {
		this._values.fill(void 0, start, end);
	}
}

/**
 * A helper class to get token-based info related to indentation
 */
class TokenInfo {
	/**
	 * @param {SourceCode} sourceCode A SourceCode object
	 */
	constructor(sourceCode) {
		this.sourceCode = sourceCode;
		this.firstTokensByLineNumber = new Map();
		const tokens = sourceCode.tokensAndComments;

		for (let i = 0; i &lt; tokens.length; i++) {
			const token = tokens[i];

			if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {
				this.firstTokensByLineNumber.set(token.loc.start.line, token);
			}
			if (
				!this.firstTokensByLineNumber.has(token.loc.end.line) &amp;&amp;
				sourceCode.text
					.slice(
						token.range[1] - token.loc.end.column,
						token.range[1],
					)
					.trim()
			) {
				this.firstTokensByLineNumber.set(token.loc.end.line, token);
			}
		}
	}

	/**
	 * Gets the first token on a given token&#039;s line
	 * @param {Token|ASTNode} token a node or token
	 * @returns {Token} The first token on the given line
	 */
	getFirstTokenOfLine(token) {
		return this.firstTokensByLineNumber.get(token.loc.start.line);
	}

	/**
	 * Determines whether a token is the first token in its line
	 * @param {Token} token The token
	 * @returns {boolean} `true` if the token is the first on its line
	 */
	isFirstTokenOfLine(token) {
		return this.getFirstTokenOfLine(token) === token;
	}

	/**
	 * Get the actual indent of a token
	 * @param {Token} token Token to examine. This should be the first token on its line.
	 * @returns {string} The indentation characters that precede the token
	 */
	getTokenIndent(token) {
		return this.sourceCode.text.slice(
			token.range[0] - token.loc.start.column,
			token.range[0],
		);
	}
}

/**
 * A class to store information on desired offsets of tokens from each other
 */
class OffsetStorage {
	/**
	 * @param {TokenInfo} tokenInfo a TokenInfo instance
	 * @param {number} indentSize The desired size of each indentation level
	 * @param {string} indentType The indentation character
	 * @param {number} maxIndex The maximum end index of any token
	 */
	constructor(tokenInfo, indentSize, indentType, maxIndex) {
		this._tokenInfo = tokenInfo;
		this._indentSize = indentSize;
		this._indentType = indentType;

		this._indexMap = new IndexMap(maxIndex);
		this._indexMap.insert(0, { offset: 0, from: null, force: false });

		this._lockedFirstTokens = new WeakMap();
		this._desiredIndentCache = new WeakMap();
		this._ignoredTokens = new WeakSet();
	}

	_getOffsetDescriptor(token) {
		return this._indexMap.findLastNotAfter(token.range[0]);
	}

	/**
	 * Sets the offset column of token B to match the offset column of token A.
	 * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
	 * most cases, `setDesiredOffset` should be used instead.
	 * @param {Token} baseToken The first token
	 * @param {Token} offsetToken The second token, whose offset should be matched to the first token
	 * @returns {void}
	 */
	matchOffsetOf(baseToken, offsetToken) {
		/*
		 * lockedFirstTokens is a map from a token whose indentation is controlled by the &quot;first&quot; option to
		 * the token that it depends on. For example, with the `ArrayExpression: first` option, the first
		 * token of each element in the array after the first will be mapped to the first token of the first
		 * element. The desired indentation of each of these tokens is computed based on the desired indentation
		 * of the &quot;first&quot; element, rather than through the normal offset mechanism.
		 */
		this._lockedFirstTokens.set(offsetToken, baseToken);
	}

	/**
	 * Sets the desired offset of a token.
	 *
	 * This uses a line-based offset collapsing behavior to handle tokens on the same line.
	 * For example, consider the following two cases:
	 *
	 * (
	 *     [
	 *         bar
	 *     ]
	 * )
	 *
	 * ([
	 *     bar
	 * ])
	 *
	 * Based on the first case, it&#039;s clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
	 * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
	 * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
	 * from the start of its line.
	 *
	 * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
	 * between the `(` and the `[` tokens gets &quot;collapsed&quot; because the two tokens are on the same line. As a result, the
	 * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
	 * by 1 indent level from the start of the line.
	 *
	 * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
	 * without needing to check which lines those tokens are on.
	 *
	 * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
	 * behavior can occur. For example, consider the following cases:
	 *
	 * foo(
	 * ).
	 *     bar(
	 *         baz
	 *     )
	 *
	 * foo(
	 * ).bar(
	 *     baz
	 * )
	 *
	 * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
	 * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
	 * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
	 * collapsing would occur).
	 *
	 * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
	 * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
	 * in the second case.
	 * @param {Token} token The token
	 * @param {Token} fromToken The token that `token` should be offset from
	 * @param {number} offset The desired indent level
	 * @returns {void}
	 */
	setDesiredOffset(token, fromToken, offset) {
		return this.setDesiredOffsets(token.range, fromToken, offset);
	}

	/**
	 * Sets the desired offset of all tokens in a range
	 * It&#039;s common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
	 * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
	 * it). This means that the offset of each token is updated O(AST depth) times.
	 * It would not be performant to store and update the offsets for each token independently, because the rule would end
	 * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
	 *
	 * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
	 * list could represent the state of the offset tree at a given point:
	 *
	 * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file
	 * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
	 * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
	 * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
	 * - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token
	 *
	 * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
	 * `setDesiredOffsets([30, 43], fooToken, 1);`
	 * @param {[number, number]} range A [start, end] pair. All tokens with range[0] &lt;= token.start &lt; range[1] will have the offset applied.
	 * @param {Token} fromToken The token that this is offset from
	 * @param {number} offset The desired indent level
	 * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
	 * @returns {void}
	 */
	setDesiredOffsets(range, fromToken, offset, force) {
		/*
		 * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset
		 * descriptor. The tree for the example above would have the following nodes:
		 *
		 * * key: 0, value: { offset: 0, from: null }
		 * * key: 15, value: { offset: 1, from: barToken }
		 * * key: 30, value: { offset: 1, from: fooToken }
		 * * key: 43, value: { offset: 2, from: barToken }
		 * * key: 820, value: { offset: 1, from: bazToken }
		 *
		 * To find the offset descriptor for any given token, one needs to find the node with the largest key
		 * which is &lt;= token.start. To make this operation fast, the nodes are stored in a map indexed by key.
		 */

		const descriptorToInsert = { offset, from: fromToken, force };

		const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);

		const fromTokenIsInRange =
			fromToken &amp;&amp;
			fromToken.range[0] &gt;= range[0] &amp;&amp;
			fromToken.range[1] &lt;= range[1];
		const fromTokenDescriptor =
			fromTokenIsInRange &amp;&amp; this._getOffsetDescriptor(fromToken);

		// First, remove any existing nodes in the range from the map.
		this._indexMap.deleteRange(range[0] + 1, range[1]);

		// Insert a new node into the map for this range
		this._indexMap.insert(range[0], descriptorToInsert);

		/*
		 * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,
		 * even if it&#039;s in the current range.
		 */
		if (fromTokenIsInRange) {
			this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);
			this._indexMap.insert(fromToken.range[1], descriptorToInsert);
		}

		/*
		 * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following
		 * tokens the same as it was before.
		 */
		this._indexMap.insert(range[1], descriptorAfterRange);
	}

	/**
	 * Gets the desired indent of a token
	 * @param {Token} token The token
	 * @returns {string} The desired indent of the token
	 */
	getDesiredIndent(token) {
		if (!this._desiredIndentCache.has(token)) {
			if (this._ignoredTokens.has(token)) {
				/*
				 * If the token is ignored, use the actual indent of the token as the desired indent.
				 * This ensures that no errors are reported for this token.
				 */
				this._desiredIndentCache.set(
					token,
					this._tokenInfo.getTokenIndent(token),
				);
			} else if (this._lockedFirstTokens.has(token)) {
				const firstToken = this._lockedFirstTokens.get(token);

				this._desiredIndentCache.set(
					token,

					// (indentation for the first element&#039;s line)
					this.getDesiredIndent(
						this._tokenInfo.getFirstTokenOfLine(firstToken),
					) +
						// (space between the start of the first element&#039;s line and the first element)
						this._indentType.repeat(
							firstToken.loc.start.column -
								this._tokenInfo.getFirstTokenOfLine(firstToken)
									.loc.start.column,
						),
				);
			} else {
				const offsetInfo = this._getOffsetDescriptor(token);
				const offset =
					offsetInfo.from &amp;&amp;
					offsetInfo.from.loc.start.line === token.loc.start.line &amp;&amp;
					!/^\s*?\n/u.test(token.value) &amp;&amp;
					!offsetInfo.force
						? 0
						: offsetInfo.offset * this._indentSize;

				this._desiredIndentCache.set(
					token,
					(offsetInfo.from
						? this.getDesiredIndent(offsetInfo.from)
						: &quot;&quot;) + this._indentType.repeat(offset),
				);
			}
		}
		return this._desiredIndentCache.get(token);
	}

	/**
	 * Ignores a token, preventing it from being reported.
	 * @param {Token} token The token
	 * @returns {void}
	 */
	ignoreToken(token) {
		if (this._tokenInfo.isFirstTokenOfLine(token)) {
			this._ignoredTokens.add(token);
		}
	}

	/**
	 * Gets the first token that the given token&#039;s indentation is dependent on
	 * @param {Token} token The token
	 * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
	 */
	getFirstDependency(token) {
		return this._getOffsetDescriptor(token).from;
	}
}

const ELEMENT_LIST_SCHEMA = {
	oneOf: [
		{
			type: &quot;integer&quot;,
			minimum: 0,
		},
		{
			enum: [&quot;first&quot;, &quot;off&quot;],
		},
	],
};

/** @type {import(&#039;../types&#039;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin-js&quot;,
						url: &quot;https://eslint.style/packages/js&quot;,
					},
					rule: {
						name: &quot;indent&quot;,
						url: &quot;https://eslint.style/rules/js/indent&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description: &quot;Enforce consistent indentation&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/indent&quot;,
		},

		fixable: &quot;whitespace&quot;,

		schema: [
			{
				oneOf: [
					{
						enum: [&quot;tab&quot;],
					},
					{
						type: &quot;integer&quot;,
						minimum: 0,
					},
				],
			},
			{
				type: &quot;object&quot;,
				properties: {
					SwitchCase: {
						type: &quot;integer&quot;,
						minimum: 0,
						default: 0,
					},
					VariableDeclarator: {
						oneOf: [
							ELEMENT_LIST_SCHEMA,
							{
								type: &quot;object&quot;,
								properties: {
									var: ELEMENT_LIST_SCHEMA,
									let: ELEMENT_LIST_SCHEMA,
									const: ELEMENT_LIST_SCHEMA,
								},
								additionalProperties: false,
							},
						],
					},
					outerIIFEBody: {
						oneOf: [
							{
								type: &quot;integer&quot;,
								minimum: 0,
							},
							{
								enum: [&quot;off&quot;],
							},
						],
					},
					MemberExpression: {
						oneOf: [
							{
								type: &quot;integer&quot;,
								minimum: 0,
							},
							{
								enum: [&quot;off&quot;],
							},
						],
					},
					FunctionDeclaration: {
						type: &quot;object&quot;,
						properties: {
							parameters: ELEMENT_LIST_SCHEMA,
							body: {
								type: &quot;integer&quot;,
								minimum: 0,
							},
						},
						additionalProperties: false,
					},
					FunctionExpression: {
						type: &quot;object&quot;,
						properties: {
							parameters: ELEMENT_LIST_SCHEMA,
							body: {
								type: &quot;integer&quot;,
								minimum: 0,
							},
						},
						additionalProperties: false,
					},
					StaticBlock: {
						type: &quot;object&quot;,
						properties: {
							body: {
								type: &quot;integer&quot;,
								minimum: 0,
							},
						},
						additionalProperties: false,
					},
					CallExpression: {
						type: &quot;object&quot;,
						properties: {
							arguments: ELEMENT_LIST_SCHEMA,
						},
						additionalProperties: false,
					},
					ArrayExpression: ELEMENT_LIST_SCHEMA,
					ObjectExpression: ELEMENT_LIST_SCHEMA,
					ImportDeclaration: ELEMENT_LIST_SCHEMA,
					flatTernaryExpressions: {
						type: &quot;boolean&quot;,
						default: false,
					},
					offsetTernaryExpressions: {
						type: &quot;boolean&quot;,
						default: false,
					},
					ignoredNodes: {
						type: &quot;array&quot;,
						items: {
							type: &quot;string&quot;,
							not: {
								pattern: &quot;:exit$&quot;,
							},
						},
					},
					ignoreComments: {
						type: &quot;boolean&quot;,
						default: false,
					},
				},
				additionalProperties: false,
			},
		],
		messages: {
			wrongIndentation:
				&quot;Expected indentation of {{expected}} but found {{actual}}.&quot;,
		},
	},

	create(context) {
		const DEFAULT_VARIABLE_INDENT = 1;
		const DEFAULT_PARAMETER_INDENT = 1;
		const DEFAULT_FUNCTION_BODY_INDENT = 1;

		let indentType = &quot;space&quot;;
		let indentSize = 4;
		const options = {
			SwitchCase: 0,
			VariableDeclarator: {
				var: DEFAULT_VARIABLE_INDENT,
				let: DEFAULT_VARIABLE_INDENT,
				const: DEFAULT_VARIABLE_INDENT,
			},
			outerIIFEBody: 1,
			FunctionDeclaration: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT,
			},
			FunctionExpression: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT,
			},
			StaticBlock: {
				body: DEFAULT_FUNCTION_BODY_INDENT,
			},
			CallExpression: {
				arguments: DEFAULT_PARAMETER_INDENT,
			},
			MemberExpression: 1,
			ArrayExpression: 1,
			ObjectExpression: 1,
			ImportDeclaration: 1,
			flatTernaryExpressions: false,
			ignoredNodes: [],
			ignoreComments: false,
		};

		if (context.options.length) {
			if (context.options[0] === &quot;tab&quot;) {
				indentSize = 1;
				indentType = &quot;tab&quot;;
			} else {
				indentSize = context.options[0];
				indentType = &quot;space&quot;;
			}

			if (context.options[1]) {
				Object.assign(options, context.options[1]);

				if (
					typeof options.VariableDeclarator === &quot;number&quot; ||
					options.VariableDeclarator === &quot;first&quot;
				) {
					options.VariableDeclarator = {
						var: options.VariableDeclarator,
						let: options.VariableDeclarator,
						const: options.VariableDeclarator,
					};
				}
			}
		}

		const sourceCode = context.sourceCode;
		const tokenInfo = new TokenInfo(sourceCode);
		const offsets = new OffsetStorage(
			tokenInfo,
			indentSize,
			indentType === &quot;space&quot; ? &quot; &quot; : &quot;\t&quot;,
			sourceCode.text.length,
		);
		const parameterParens = new WeakSet();

		/**
		 * Creates an error message for a line, given the expected/actual indentation.
		 * @param {number} expectedAmount The expected amount of indentation characters for this line
		 * @param {number} actualSpaces The actual number of indentation spaces that were found on this line
		 * @param {number} actualTabs The actual number of indentation tabs that were found on this line
		 * @returns {string} An error message for this line
		 */
		function createErrorMessageData(
			expectedAmount,
			actualSpaces,
			actualTabs,
		) {
			const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? &quot;&quot; : &quot;s&quot;}`; // e.g. &quot;2 tabs&quot;
			const foundSpacesWord = `space${actualSpaces === 1 ? &quot;&quot; : &quot;s&quot;}`; // e.g. &quot;space&quot;
			const foundTabsWord = `tab${actualTabs === 1 ? &quot;&quot; : &quot;s&quot;}`; // e.g. &quot;tabs&quot;
			let foundStatement;

			if (actualSpaces &gt; 0) {
				/*
				 * Abbreviate the message if the expected indentation is also spaces.
				 * e.g. &#039;Expected 4 spaces but found 2&#039; rather than &#039;Expected 4 spaces but found 2 spaces&#039;
				 */
				foundStatement =
					indentType === &quot;space&quot;
						? actualSpaces
						: `${actualSpaces} ${foundSpacesWord}`;
			} else if (actualTabs &gt; 0) {
				foundStatement =
					indentType === &quot;tab&quot;
						? actualTabs
						: `${actualTabs} ${foundTabsWord}`;
			} else {
				foundStatement = &quot;0&quot;;
			}
			return {
				expected: expectedStatement,
				actual: foundStatement,
			};
		}

		/**
		 * Reports a given indent violation
		 * @param {Token} token Token violating the indent rule
		 * @param {string} neededIndent Expected indentation string
		 * @returns {void}
		 */
		function report(token, neededIndent) {
			const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
			const numSpaces = actualIndent.filter(char =&gt; char === &quot; &quot;).length;
			const numTabs = actualIndent.filter(char =&gt; char === &quot;\t&quot;).length;

			context.report({
				node: token,
				messageId: &quot;wrongIndentation&quot;,
				data: createErrorMessageData(
					neededIndent.length,
					numSpaces,
					numTabs,
				),
				loc: {
					start: { line: token.loc.start.line, column: 0 },
					end: {
						line: token.loc.start.line,
						column: token.loc.start.column,
					},
				},
				fix(fixer) {
					const range = [
						token.range[0] - token.loc.start.column,
						token.range[0],
					];
					const newText = neededIndent;

					return fixer.replaceTextRange(range, newText);
				},
			});
		}

		/**
		 * Checks if a token&#039;s indentation is correct
		 * @param {Token} token Token to examine
		 * @param {string} desiredIndent Desired indentation of the string
		 * @returns {boolean} `true` if the token&#039;s indentation is correct
		 */
		function validateTokenIndent(token, desiredIndent) {
			const indentation = tokenInfo.getTokenIndent(token);

			return (
				indentation === desiredIndent ||
				// To avoid conflicts with no-mixed-spaces-and-tabs, don&#039;t report mixed spaces and tabs.
				(indentation.includes(&quot; &quot;) &amp;&amp; indentation.includes(&quot;\t&quot;))
			);
		}

		/**
		 * Check to see if the node is a file level IIFE
		 * @param {ASTNode} node The function node to check.
		 * @returns {boolean} True if the node is the outer IIFE
		 */
		function isOuterIIFE(node) {
			/*
			 * Verify that the node is an IIFE
			 */
			if (
				!node.parent ||
				node.parent.type !== &quot;CallExpression&quot; ||
				node.parent.callee !== node
			) {
				return false;
			}

			/*
			 * Navigate legal ancestors to determine whether this IIFE is outer.
			 * A &quot;legal ancestor&quot; is an expression or statement that causes the function to get executed immediately.
			 * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.
			 */
			let statement = node.parent &amp;&amp; node.parent.parent;

			while (
				(statement.type === &quot;UnaryExpression&quot; &amp;&amp;
					[&quot;!&quot;, &quot;~&quot;, &quot;+&quot;, &quot;-&quot;].includes(statement.operator)) ||
				statement.type === &quot;AssignmentExpression&quot; ||
				statement.type === &quot;LogicalExpression&quot; ||
				statement.type === &quot;SequenceExpression&quot; ||
				statement.type === &quot;VariableDeclarator&quot;
			) {
				statement = statement.parent;
			}

			return (
				(statement.type === &quot;ExpressionStatement&quot; ||
					statement.type === &quot;VariableDeclaration&quot;) &amp;&amp;
				statement.parent.type === &quot;Program&quot;
			);
		}

		/**
		 * Counts the number of linebreaks that follow the last non-whitespace character in a string
		 * @param {string} string The string to check
		 * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,
		 * or the total number of linebreaks if the string is all whitespace.
		 */
		function countTrailingLinebreaks(string) {
			const trailingWhitespace = string.match(/\s*$/u)[0];
			const linebreakMatches = trailingWhitespace.match(
				astUtils.createGlobalLinebreakMatcher(),
			);

			return linebreakMatches === null ? 0 : linebreakMatches.length;
		}

		/**
		 * Check indentation for lists of elements (arrays, objects, function params)
		 * @param {ASTNode[]} elements List of elements that should be offset
		 * @param {Token} startToken The start token of the list that element should be aligned against, e.g. &#039;[&#039;
		 * @param {Token} endToken The end token of the list, e.g. &#039;]&#039;
		 * @param {number|string} offset The amount that the elements should be offset
		 * @returns {void}
		 */
		function addElementListIndent(elements, startToken, endToken, offset) {
			/**
			 * Gets the first token of a given element, including surrounding parentheses.
			 * @param {ASTNode} element A node in the `elements` list
			 * @returns {Token} The first token of this element
			 */
			function getFirstToken(element) {
				let token = sourceCode.getTokenBefore(element);

				while (
					astUtils.isOpeningParenToken(token) &amp;&amp;
					token !== startToken
				) {
					token = sourceCode.getTokenBefore(token);
				}
				return sourceCode.getTokenAfter(token);
			}

			// Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)
			offsets.setDesiredOffsets(
				[startToken.range[1], endToken.range[0]],
				startToken,
				typeof offset === &quot;number&quot; ? offset : 1,
			);
			offsets.setDesiredOffset(endToken, startToken, 0);

			// If the preference is &quot;first&quot; but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.
			if (offset === &quot;first&quot; &amp;&amp; elements.length &amp;&amp; !elements[0]) {
				return;
			}
			elements.forEach((element, index) =&gt; {
				if (!element) {
					// Skip holes in arrays
					return;
				}
				if (offset === &quot;off&quot;) {
					// Ignore the first token of every element if the &quot;off&quot; option is used
					offsets.ignoreToken(getFirstToken(element));
				}

				// Offset the following elements correctly relative to the first element
				if (index === 0) {
					return;
				}
				if (
					offset === &quot;first&quot; &amp;&amp;
					tokenInfo.isFirstTokenOfLine(getFirstToken(element))
				) {
					offsets.matchOffsetOf(
						getFirstToken(elements[0]),
						getFirstToken(element),
					);
				} else {
					const previousElement = elements[index - 1];
					const firstTokenOfPreviousElement =
						previousElement &amp;&amp; getFirstToken(previousElement);
					const previousElementLastToken =
						previousElement &amp;&amp;
						sourceCode.getLastToken(previousElement);

					if (
						previousElement &amp;&amp;
						previousElementLastToken.loc.end.line -
							countTrailingLinebreaks(
								previousElementLastToken.value,
							) &gt;
							startToken.loc.end.line
					) {
						offsets.setDesiredOffsets(
							[previousElement.range[1], element.range[1]],
							firstTokenOfPreviousElement,
							0,
						);
					}
				}
			});
		}

		/**
		 * Check and decide whether to check for indentation for blockless nodes
		 * Scenarios are for or while statements without braces around them
		 * @param {ASTNode} node node to examine
		 * @returns {void}
		 */
		function addBlocklessNodeIndent(node) {
			if (node.type !== &quot;BlockStatement&quot;) {
				const lastParentToken = sourceCode.getTokenBefore(
					node,
					astUtils.isNotOpeningParenToken,
				);

				let firstBodyToken = sourceCode.getFirstToken(node);
				let lastBodyToken = sourceCode.getLastToken(node);

				while (
					astUtils.isOpeningParenToken(
						sourceCode.getTokenBefore(firstBodyToken),
					) &amp;&amp;
					astUtils.isClosingParenToken(
						sourceCode.getTokenAfter(lastBodyToken),
					)
				) {
					firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
					lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
				}

				offsets.setDesiredOffsets(
					[firstBodyToken.range[0], lastBodyToken.range[1]],
					lastParentToken,
					1,
				);
			}
		}

		/**
		 * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)
		 * @param {ASTNode} node A CallExpression or NewExpression node
		 * @returns {void}
		 */
		function addFunctionCallIndent(node) {
			let openingParen;

			if (node.arguments.length) {
				openingParen = sourceCode.getFirstTokenBetween(
					node.callee,
					node.arguments[0],
					astUtils.isOpeningParenToken,
				);
			} else {
				openingParen = sourceCode.getLastToken(node, 1);
			}
			const closingParen = sourceCode.getLastToken(node);

			parameterParens.add(openingParen);
			parameterParens.add(closingParen);

			/*
			 * If `?.` token exists, set desired offset for that.
			 * This logic is copied from `MemberExpression`&#039;s.
			 */
			if (node.optional) {
				const dotToken = sourceCode.getTokenAfter(
					node.callee,
					astUtils.isQuestionDotToken,
				);
				const calleeParenCount = sourceCode.getTokensBetween(
					node.callee,
					dotToken,
					{ filter: astUtils.isClosingParenToken },
				).length;
				const firstTokenOfCallee = calleeParenCount
					? sourceCode.getTokenBefore(node.callee, {
							skip: calleeParenCount - 1,
						})
					: sourceCode.getFirstToken(node.callee);
				const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);
				const offsetBase =
					lastTokenOfCallee.loc.end.line ===
					openingParen.loc.start.line
						? lastTokenOfCallee
						: firstTokenOfCallee;

				offsets.setDesiredOffset(dotToken, offsetBase, 1);
			}

			const offsetAfterToken =
				node.callee.type === &quot;TaggedTemplateExpression&quot;
					? sourceCode.getFirstToken(node.callee.quasi)
					: openingParen;
			const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);

			offsets.setDesiredOffset(openingParen, offsetToken, 0);

			addElementListIndent(
				node.arguments,
				openingParen,
				closingParen,
				options.CallExpression.arguments,
			);
		}

		/**
		 * Checks the indentation of parenthesized values, given a list of tokens in a program
		 * @param {Token[]} tokens A list of tokens
		 * @returns {void}
		 */
		function addParensIndent(tokens) {
			const parenStack = [];
			const parenPairs = [];

			for (let i = 0; i &lt; tokens.length; i++) {
				const nextToken = tokens[i];

				if (astUtils.isOpeningParenToken(nextToken)) {
					parenStack.push(nextToken);
				} else if (astUtils.isClosingParenToken(nextToken)) {
					parenPairs.push({
						left: parenStack.pop(),
						right: nextToken,
					});
				}
			}

			for (let i = parenPairs.length - 1; i &gt;= 0; i--) {
				const leftParen = parenPairs[i].left;
				const rightParen = parenPairs[i].right;

				// We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.
				if (
					!parameterParens.has(leftParen) &amp;&amp;
					!parameterParens.has(rightParen)
				) {
					const parenthesizedTokens = new Set(
						sourceCode.getTokensBetween(leftParen, rightParen),
					);

					parenthesizedTokens.forEach(token =&gt; {
						if (
							!parenthesizedTokens.has(
								offsets.getFirstDependency(token),
							)
						) {
							offsets.setDesiredOffset(token, leftParen, 1);
						}
					});
				}

				offsets.setDesiredOffset(rightParen, leftParen, 0);
			}
		}

		/**
		 * Ignore all tokens within an unknown node whose offset do not depend
		 * on another token&#039;s offset within the unknown node
		 * @param {ASTNode} node Unknown Node
		 * @returns {void}
		 */
		function ignoreNode(node) {
			const unknownNodeTokens = new Set(
				sourceCode.getTokens(node, { includeComments: true }),
			);

			unknownNodeTokens.forEach(token =&gt; {
				if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
					const firstTokenOfLine =
						tokenInfo.getFirstTokenOfLine(token);

					if (token === firstTokenOfLine) {
						offsets.ignoreToken(token);
					} else {
						offsets.setDesiredOffset(token, firstTokenOfLine, 0);
					}
				}
			});
		}

		/**
		 * Check whether the given token is on the first line of a statement.
		 * @param {Token} token The token to check.
		 * @param {ASTNode} leafNode The expression node that the token belongs directly.
		 * @returns {boolean} `true` if the token is on the first line of a statement.
		 */
		function isOnFirstLineOfStatement(token, leafNode) {
			let node = leafNode;

			while (
				node.parent &amp;&amp;
				!node.parent.type.endsWith(&quot;Statement&quot;) &amp;&amp;
				!node.parent.type.endsWith(&quot;Declaration&quot;)
			) {
				node = node.parent;
			}
			node = node.parent;

			return !node || node.loc.start.line === token.loc.start.line;
		}

		/**
		 * Check whether there are any blank (whitespace-only) lines between
		 * two tokens on separate lines.
		 * @param {Token} firstToken The first token.
		 * @param {Token} secondToken The second token.
		 * @returns {boolean} `true` if the tokens are on separate lines and
		 *   there exists a blank line between them, `false` otherwise.
		 */
		function hasBlankLinesBetween(firstToken, secondToken) {
			const firstTokenLine = firstToken.loc.end.line;
			const secondTokenLine = secondToken.loc.start.line;

			if (
				firstTokenLine === secondTokenLine ||
				firstTokenLine === secondTokenLine - 1
			) {
				return false;
			}

			for (
				let line = firstTokenLine + 1;
				line &lt; secondTokenLine;
				++line
			) {
				if (!tokenInfo.firstTokensByLineNumber.has(line)) {
					return true;
				}
			}

			return false;
		}

		const ignoredNodeFirstTokens = new Set();

		const baseOffsetListeners = {
			&quot;ArrayExpression, ArrayPattern&quot;(node) {
				const openingBracket = sourceCode.getFirstToken(node);
				const closingBracket = sourceCode.getTokenAfter(
					[...node.elements].reverse().find(_ =&gt; _) || openingBracket,
					astUtils.isClosingBracketToken,
				);

				addElementListIndent(
					node.elements,
					openingBracket,
					closingBracket,
					options.ArrayExpression,
				);
			},

			&quot;ObjectExpression, ObjectPattern&quot;(node) {
				const openingCurly = sourceCode.getFirstToken(node);
				const closingCurly = sourceCode.getTokenAfter(
					node.properties.length
						? node.properties.at(-1)
						: openingCurly,
					astUtils.isClosingBraceToken,
				);

				addElementListIndent(
					node.properties,
					openingCurly,
					closingCurly,
					options.ObjectExpression,
				);
			},

			ArrowFunctionExpression(node) {
				const maybeOpeningParen = sourceCode.getFirstToken(node, {
					skip: node.async ? 1 : 0,
				});

				if (astUtils.isOpeningParenToken(maybeOpeningParen)) {
					const openingParen = maybeOpeningParen;
					const closingParen = sourceCode.getTokenBefore(
						node.body,
						astUtils.isClosingParenToken,
					);

					parameterParens.add(openingParen);
					parameterParens.add(closingParen);
					addElementListIndent(
						node.params,
						openingParen,
						closingParen,
						options.FunctionExpression.parameters,
					);
				}

				addBlocklessNodeIndent(node.body);
			},

			AssignmentExpression(node) {
				const operator = sourceCode.getFirstTokenBetween(
					node.left,
					node.right,
					token =&gt; token.value === node.operator,
				);

				offsets.setDesiredOffsets(
					[operator.range[0], node.range[1]],
					sourceCode.getLastToken(node.left),
					1,
				);
				offsets.ignoreToken(operator);
				offsets.ignoreToken(sourceCode.getTokenAfter(operator));
			},

			&quot;BinaryExpression, LogicalExpression&quot;(node) {
				const operator = sourceCode.getFirstTokenBetween(
					node.left,
					node.right,
					token =&gt; token.value === node.operator,
				);

				/*
				 * For backwards compatibility, don&#039;t check BinaryExpression indents, e.g.
				 * var foo = bar &amp;&amp;
				 *                   baz;
				 */

				const tokenAfterOperator = sourceCode.getTokenAfter(operator);

				offsets.ignoreToken(operator);
				offsets.ignoreToken(tokenAfterOperator);
				offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
			},

			&quot;BlockStatement, ClassBody&quot;(node) {
				let blockIndentLevel;

				if (node.parent &amp;&amp; isOuterIIFE(node.parent)) {
					blockIndentLevel = options.outerIIFEBody;
				} else if (
					node.parent &amp;&amp;
					(node.parent.type === &quot;FunctionExpression&quot; ||
						node.parent.type === &quot;ArrowFunctionExpression&quot;)
				) {
					blockIndentLevel = options.FunctionExpression.body;
				} else if (
					node.parent &amp;&amp;
					node.parent.type === &quot;FunctionDeclaration&quot;
				) {
					blockIndentLevel = options.FunctionDeclaration.body;
				} else {
					blockIndentLevel = 1;
				}

				/*
				 * For blocks that aren&#039;t lone statements, ensure that the opening curly brace
				 * is aligned with the parent.
				 */
				if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
					offsets.setDesiredOffset(
						sourceCode.getFirstToken(node),
						sourceCode.getFirstToken(node.parent),
						0,
					);
				}

				addElementListIndent(
					node.body,
					sourceCode.getFirstToken(node),
					sourceCode.getLastToken(node),
					blockIndentLevel,
				);
			},

			CallExpression: addFunctionCallIndent,

			&quot;ClassDeclaration[superClass], ClassExpression[superClass]&quot;(node) {
				const classToken = sourceCode.getFirstToken(node);
				const extendsToken = sourceCode.getTokenBefore(
					node.superClass,
					astUtils.isNotOpeningParenToken,
				);

				offsets.setDesiredOffsets(
					[extendsToken.range[0], node.body.range[0]],
					classToken,
					1,
				);
			},

			ConditionalExpression(node) {
				const firstToken = sourceCode.getFirstToken(node);

				// `flatTernaryExpressions` option is for the following style:
				// var a =
				//     foo &gt; 0 ? bar :
				//     foo &lt; 0 ? baz :
				//     /*else*/ qiz ;
				if (
					!options.flatTernaryExpressions ||
					!astUtils.isTokenOnSameLine(node.test, node.consequent) ||
					isOnFirstLineOfStatement(firstToken, node)
				) {
					const questionMarkToken = sourceCode.getFirstTokenBetween(
						node.test,
						node.consequent,
						token =&gt;
							token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;?&quot;,
					);
					const colonToken = sourceCode.getFirstTokenBetween(
						node.consequent,
						node.alternate,
						token =&gt;
							token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;:&quot;,
					);

					const firstConsequentToken =
						sourceCode.getTokenAfter(questionMarkToken);
					const lastConsequentToken =
						sourceCode.getTokenBefore(colonToken);
					const firstAlternateToken =
						sourceCode.getTokenAfter(colonToken);

					offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
					offsets.setDesiredOffset(colonToken, firstToken, 1);

					offsets.setDesiredOffset(
						firstConsequentToken,
						firstToken,
						firstConsequentToken.type === &quot;Punctuator&quot; &amp;&amp;
							options.offsetTernaryExpressions
							? 2
							: 1,
					);

					/*
					 * The alternate and the consequent should usually have the same indentation.
					 * If they share part of a line, align the alternate against the first token of the consequent.
					 * This allows the alternate to be indented correctly in cases like this:
					 * foo ? (
					 *   bar
					 * ) : ( // this &#039;(&#039; is aligned with the &#039;(&#039; above, so it&#039;s considered to be aligned with `foo`
					 *   baz // as a result, `baz` is offset by 1 rather than 2
					 * )
					 */
					if (
						lastConsequentToken.loc.end.line ===
						firstAlternateToken.loc.start.line
					) {
						offsets.setDesiredOffset(
							firstAlternateToken,
							firstConsequentToken,
							0,
						);
					} else {
						/**
						 * If the alternate and consequent do not share part of a line, offset the alternate from the first
						 * token of the conditional expression. For example:
						 * foo ? bar
						 *   : baz
						 *
						 * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up
						 * having no expected indentation.
						 */
						offsets.setDesiredOffset(
							firstAlternateToken,
							firstToken,
							firstAlternateToken.type === &quot;Punctuator&quot; &amp;&amp;
								options.offsetTernaryExpressions
								? 2
								: 1,
						);
					}
				}
			},

			&quot;DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement&quot;:
				node =&gt; addBlocklessNodeIndent(node.body),

			ExportNamedDeclaration(node) {
				if (node.declaration === null) {
					const closingCurly = sourceCode.getLastToken(
						node,
						astUtils.isClosingBraceToken,
					);

					// Indent the specifiers in `export {foo, bar, baz}`
					addElementListIndent(
						node.specifiers,
						sourceCode.getFirstToken(node, { skip: 1 }),
						closingCurly,
						1,
					);

					if (node.source) {
						// Indent everything after and including the `from` token in `export {foo, bar, baz} from &#039;qux&#039;`
						offsets.setDesiredOffsets(
							[closingCurly.range[1], node.range[1]],
							sourceCode.getFirstToken(node),
							1,
						);
					}
				}
			},

			ForStatement(node) {
				const forOpeningParen = sourceCode.getFirstToken(node, 1);

				if (node.init) {
					offsets.setDesiredOffsets(
						node.init.range,
						forOpeningParen,
						1,
					);
				}
				if (node.test) {
					offsets.setDesiredOffsets(
						node.test.range,
						forOpeningParen,
						1,
					);
				}
				if (node.update) {
					offsets.setDesiredOffsets(
						node.update.range,
						forOpeningParen,
						1,
					);
				}
				addBlocklessNodeIndent(node.body);
			},

			&quot;FunctionDeclaration, FunctionExpression&quot;(node) {
				const closingParen = sourceCode.getTokenBefore(node.body);
				const openingParen = sourceCode.getTokenBefore(
					node.params.length ? node.params[0] : closingParen,
				);

				parameterParens.add(openingParen);
				parameterParens.add(closingParen);
				addElementListIndent(
					node.params,
					openingParen,
					closingParen,
					options[node.type].parameters,
				);
			},

			IfStatement(node) {
				addBlocklessNodeIndent(node.consequent);
				if (node.alternate) {
					addBlocklessNodeIndent(node.alternate);
				}
			},

			/*
			 * For blockless nodes with semicolon-first style, don&#039;t indent the semicolon.
			 * e.g.
			 * if (foo)
			 *     bar()
			 * ; [1, 2, 3].map(foo)
			 *
			 * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.
			 */
			&quot;:matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit&quot;(
				node,
			) {
				let nodesToCheck;

				if (node.type === &quot;IfStatement&quot;) {
					nodesToCheck = [node.consequent];
					if (node.alternate) {
						nodesToCheck.push(node.alternate);
					}
				} else {
					nodesToCheck = [node.body];
				}

				for (const nodeToCheck of nodesToCheck) {
					const lastToken = sourceCode.getLastToken(nodeToCheck);

					if (astUtils.isSemicolonToken(lastToken)) {
						const tokenBeforeLast =
							sourceCode.getTokenBefore(lastToken);
						const tokenAfterLast =
							sourceCode.getTokenAfter(lastToken);

						// override indentation of `;` only if its line looks like a semicolon-first style line
						if (
							!astUtils.isTokenOnSameLine(
								tokenBeforeLast,
								lastToken,
							) &amp;&amp;
							tokenAfterLast &amp;&amp;
							astUtils.isTokenOnSameLine(
								lastToken,
								tokenAfterLast,
							)
						) {
							offsets.setDesiredOffset(
								lastToken,
								sourceCode.getFirstToken(node),
								0,
							);
						}
					}
				}
			},

			ImportDeclaration(node) {
				if (
					node.specifiers.some(
						specifier =&gt; specifier.type === &quot;ImportSpecifier&quot;,
					)
				) {
					const openingCurly = sourceCode.getFirstToken(
						node,
						astUtils.isOpeningBraceToken,
					);
					const closingCurly = sourceCode.getLastToken(
						node,
						astUtils.isClosingBraceToken,
					);

					addElementListIndent(
						node.specifiers.filter(
							specifier =&gt; specifier.type === &quot;ImportSpecifier&quot;,
						),
						openingCurly,
						closingCurly,
						options.ImportDeclaration,
					);
				}

				const fromToken = sourceCode.getLastToken(
					node,
					token =&gt;
						token.type === &quot;Identifier&quot; &amp;&amp; token.value === &quot;from&quot;,
				);
				const sourceToken = sourceCode.getLastToken(
					node,
					token =&gt; token.type === &quot;String&quot;,
				);
				const semiToken = sourceCode.getLastToken(
					node,
					token =&gt; token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;;&quot;,
				);

				if (fromToken) {
					const end =
						semiToken &amp;&amp; semiToken.range[1] === sourceToken.range[1]
							? node.range[1]
							: sourceToken.range[1];

					offsets.setDesiredOffsets(
						[fromToken.range[0], end],
						sourceCode.getFirstToken(node),
						1,
					);
				}
			},

			ImportExpression(node) {
				const openingParen = sourceCode.getFirstToken(node, 1);
				const closingParen = sourceCode.getLastToken(node);

				parameterParens.add(openingParen);
				parameterParens.add(closingParen);
				offsets.setDesiredOffset(
					openingParen,
					sourceCode.getTokenBefore(openingParen),
					0,
				);

				addElementListIndent(
					[node.source],
					openingParen,
					closingParen,
					options.CallExpression.arguments,
				);
			},

			&quot;MemberExpression, JSXMemberExpression, MetaProperty&quot;(node) {
				const object =
					node.type === &quot;MetaProperty&quot; ? node.meta : node.object;
				const firstNonObjectToken = sourceCode.getFirstTokenBetween(
					object,
					node.property,
					astUtils.isNotClosingParenToken,
				);
				const secondNonObjectToken =
					sourceCode.getTokenAfter(firstNonObjectToken);

				const objectParenCount = sourceCode.getTokensBetween(
					object,
					node.property,
					{ filter: astUtils.isClosingParenToken },
				).length;
				const firstObjectToken = objectParenCount
					? sourceCode.getTokenBefore(object, {
							skip: objectParenCount - 1,
						})
					: sourceCode.getFirstToken(object);
				const lastObjectToken =
					sourceCode.getTokenBefore(firstNonObjectToken);
				const firstPropertyToken = node.computed
					? firstNonObjectToken
					: secondNonObjectToken;

				if (node.computed) {
					// For computed MemberExpressions, match the closing bracket with the opening bracket.
					offsets.setDesiredOffset(
						sourceCode.getLastToken(node),
						firstNonObjectToken,
						0,
					);
					offsets.setDesiredOffsets(
						node.property.range,
						firstNonObjectToken,
						1,
					);
				}

				/*
				 * If the object ends on the same line that the property starts, match against the last token
				 * of the object, to ensure that the MemberExpression is not indented.
				 *
				 * Otherwise, match against the first token of the object, e.g.
				 * foo
				 *   .bar
				 *   .baz // &lt;-- offset by 1 from `foo`
				 */
				const offsetBase =
					lastObjectToken.loc.end.line ===
					firstPropertyToken.loc.start.line
						? lastObjectToken
						: firstObjectToken;

				if (typeof options.MemberExpression === &quot;number&quot;) {
					// Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.
					offsets.setDesiredOffset(
						firstNonObjectToken,
						offsetBase,
						options.MemberExpression,
					);

					/*
					 * For computed MemberExpressions, match the first token of the property against the opening bracket.
					 * Otherwise, match the first token of the property against the object.
					 */
					offsets.setDesiredOffset(
						secondNonObjectToken,
						node.computed ? firstNonObjectToken : offsetBase,
						options.MemberExpression,
					);
				} else {
					// If the MemberExpression option is off, ignore the dot and the first token of the property.
					offsets.ignoreToken(firstNonObjectToken);
					offsets.ignoreToken(secondNonObjectToken);

					// To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.
					offsets.setDesiredOffset(
						firstNonObjectToken,
						offsetBase,
						0,
					);
					offsets.setDesiredOffset(
						secondNonObjectToken,
						firstNonObjectToken,
						0,
					);
				}
			},

			NewExpression(node) {
				// Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`
				if (
					node.arguments.length &gt; 0 ||
					(astUtils.isClosingParenToken(
						sourceCode.getLastToken(node),
					) &amp;&amp;
						astUtils.isOpeningParenToken(
							sourceCode.getLastToken(node, 1),
						))
				) {
					addFunctionCallIndent(node);
				}
			},

			Property(node) {
				if (!node.shorthand &amp;&amp; !node.method &amp;&amp; node.kind === &quot;init&quot;) {
					const colon = sourceCode.getFirstTokenBetween(
						node.key,
						node.value,
						astUtils.isColonToken,
					);

					offsets.ignoreToken(sourceCode.getTokenAfter(colon));
				}
			},

			PropertyDefinition(node) {
				const firstToken = sourceCode.getFirstToken(node);
				const maybeSemicolonToken = sourceCode.getLastToken(node);
				let keyLastToken;

				// Indent key.
				if (node.computed) {
					const bracketTokenL = sourceCode.getTokenBefore(
						node.key,
						astUtils.isOpeningBracketToken,
					);
					const bracketTokenR = (keyLastToken =
						sourceCode.getTokenAfter(
							node.key,
							astUtils.isClosingBracketToken,
						));
					const keyRange = [
						bracketTokenL.range[1],
						bracketTokenR.range[0],
					];

					if (bracketTokenL !== firstToken) {
						offsets.setDesiredOffset(bracketTokenL, firstToken, 0);
					}
					offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);
					offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);
				} else {
					const idToken = (keyLastToken = sourceCode.getFirstToken(
						node.key,
					));

					if (idToken !== firstToken) {
						offsets.setDesiredOffset(idToken, firstToken, 1);
					}
				}

				// Indent initializer.
				if (node.value) {
					const eqToken = sourceCode.getTokenBefore(
						node.value,
						astUtils.isEqToken,
					);
					const valueToken = sourceCode.getTokenAfter(eqToken);

					offsets.setDesiredOffset(eqToken, keyLastToken, 1);
					offsets.setDesiredOffset(valueToken, eqToken, 1);
					if (astUtils.isSemicolonToken(maybeSemicolonToken)) {
						offsets.setDesiredOffset(
							maybeSemicolonToken,
							eqToken,
							1,
						);
					}
				} else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {
					offsets.setDesiredOffset(
						maybeSemicolonToken,
						keyLastToken,
						1,
					);
				}
			},

			StaticBlock(node) {
				const openingCurly = sourceCode.getFirstToken(node, {
					skip: 1,
				}); // skip the `static` token
				const closingCurly = sourceCode.getLastToken(node);

				addElementListIndent(
					node.body,
					openingCurly,
					closingCurly,
					options.StaticBlock.body,
				);
			},

			SwitchStatement(node) {
				const openingCurly = sourceCode.getTokenAfter(
					node.discriminant,
					astUtils.isOpeningBraceToken,
				);
				const closingCurly = sourceCode.getLastToken(node);

				offsets.setDesiredOffsets(
					[openingCurly.range[1], closingCurly.range[0]],
					openingCurly,
					options.SwitchCase,
				);

				if (node.cases.length) {
					sourceCode
						.getTokensBetween(node.cases.at(-1), closingCurly, {
							includeComments: true,
							filter: astUtils.isCommentToken,
						})
						.forEach(token =&gt; offsets.ignoreToken(token));
				}
			},

			SwitchCase(node) {
				if (
					!(
						node.consequent.length === 1 &amp;&amp;
						node.consequent[0].type === &quot;BlockStatement&quot;
					)
				) {
					const caseKeyword = sourceCode.getFirstToken(node);
					const tokenAfterCurrentCase =
						sourceCode.getTokenAfter(node);

					offsets.setDesiredOffsets(
						[caseKeyword.range[1], tokenAfterCurrentCase.range[0]],
						caseKeyword,
						1,
					);
				}
			},

			TemplateLiteral(node) {
				node.expressions.forEach((expression, index) =&gt; {
					const previousQuasi = node.quasis[index];
					const nextQuasi = node.quasis[index + 1];
					const tokenToAlignFrom =
						previousQuasi.loc.start.line ===
						previousQuasi.loc.end.line
							? sourceCode.getFirstToken(previousQuasi)
							: null;

					offsets.setDesiredOffsets(
						[previousQuasi.range[1], nextQuasi.range[0]],
						tokenToAlignFrom,
						1,
					);
					offsets.setDesiredOffset(
						sourceCode.getFirstToken(nextQuasi),
						tokenToAlignFrom,
						0,
					);
				});
			},

			VariableDeclaration(node) {
				let variableIndent = Object.hasOwn(
					options.VariableDeclarator,
					node.kind,
				)
					? options.VariableDeclarator[node.kind]
					: DEFAULT_VARIABLE_INDENT;

				const firstToken = sourceCode.getFirstToken(node),
					lastToken = sourceCode.getLastToken(node);

				if (options.VariableDeclarator[node.kind] === &quot;first&quot;) {
					if (node.declarations.length &gt; 1) {
						addElementListIndent(
							node.declarations,
							firstToken,
							lastToken,
							&quot;first&quot;,
						);
						return;
					}

					variableIndent = DEFAULT_VARIABLE_INDENT;
				}

				if (
					node.declarations.at(-1).loc.start.line &gt;
					node.loc.start.line
				) {
					/*
					 * VariableDeclarator indentation is a bit different from other forms of indentation, in that the
					 * indentation of an opening bracket sometimes won&#039;t match that of a closing bracket. For example,
					 * the following indentations are correct:
					 *
					 * var foo = {
					 *   ok: true
					 * };
					 *
					 * var foo = {
					 *     ok: true,
					 *   },
					 *   bar = 1;
					 *
					 * Account for when exiting the AST (after indentations have already been set for the nodes in
					 * the declaration) by manually increasing the indentation level of the tokens in this declarator
					 * on the same line as the start of the declaration, provided that there are declarators that
					 * follow this one.
					 */
					offsets.setDesiredOffsets(
						node.range,
						firstToken,
						variableIndent,
						true,
					);
				} else {
					offsets.setDesiredOffsets(
						node.range,
						firstToken,
						variableIndent,
					);
				}

				if (astUtils.isSemicolonToken(lastToken)) {
					offsets.ignoreToken(lastToken);
				}
			},

			VariableDeclarator(node) {
				if (node.init) {
					const equalOperator = sourceCode.getTokenBefore(
						node.init,
						astUtils.isNotOpeningParenToken,
					);
					const tokenAfterOperator =
						sourceCode.getTokenAfter(equalOperator);

					offsets.ignoreToken(equalOperator);
					offsets.ignoreToken(tokenAfterOperator);
					offsets.setDesiredOffsets(
						[tokenAfterOperator.range[0], node.range[1]],
						equalOperator,
						1,
					);
					offsets.setDesiredOffset(
						equalOperator,
						sourceCode.getLastToken(node.id),
						0,
					);
				}
			},

			&quot;JSXAttribute[value]&quot;(node) {
				const equalsToken = sourceCode.getFirstTokenBetween(
					node.name,
					node.value,
					token =&gt; token.type === &quot;Punctuator&quot; &amp;&amp; token.value === &quot;=&quot;,
				);

				offsets.setDesiredOffsets(
					[equalsToken.range[0], node.value.range[1]],
					sourceCode.getFirstToken(node.name),
					1,
				);
			},

			JSXElement(node) {
				if (node.closingElement) {
					addElementListIndent(
						node.children,
						sourceCode.getFirstToken(node.openingElement),
						sourceCode.getFirstToken(node.closingElement),
						1,
					);
				}
			},

			JSXOpeningElement(node) {
				const firstToken = sourceCode.getFirstToken(node);
				let closingToken;

				if (node.selfClosing) {
					closingToken = sourceCode.getLastToken(node, { skip: 1 });
					offsets.setDesiredOffset(
						sourceCode.getLastToken(node),
						closingToken,
						0,
					);
				} else {
					closingToken = sourceCode.getLastToken(node);
				}
				offsets.setDesiredOffsets(
					node.name.range,
					sourceCode.getFirstToken(node),
				);
				addElementListIndent(
					node.attributes,
					firstToken,
					closingToken,
					1,
				);
			},

			JSXClosingElement(node) {
				const firstToken = sourceCode.getFirstToken(node);

				offsets.setDesiredOffsets(node.name.range, firstToken, 1);
			},

			JSXFragment(node) {
				const firstOpeningToken = sourceCode.getFirstToken(
					node.openingFragment,
				);
				const firstClosingToken = sourceCode.getFirstToken(
					node.closingFragment,
				);

				addElementListIndent(
					node.children,
					firstOpeningToken,
					firstClosingToken,
					1,
				);
			},

			JSXOpeningFragment(node) {
				const firstToken = sourceCode.getFirstToken(node);
				const closingToken = sourceCode.getLastToken(node);

				offsets.setDesiredOffsets(node.range, firstToken, 1);
				offsets.matchOffsetOf(firstToken, closingToken);
			},

			JSXClosingFragment(node) {
				const firstToken = sourceCode.getFirstToken(node);
				const slashToken = sourceCode.getLastToken(node, { skip: 1 });
				const closingToken = sourceCode.getLastToken(node);
				const tokenToMatch = astUtils.isTokenOnSameLine(
					slashToken,
					closingToken,
				)
					? slashToken
					: closingToken;

				offsets.setDesiredOffsets(node.range, firstToken, 1);
				offsets.matchOffsetOf(firstToken, tokenToMatch);
			},

			JSXExpressionContainer(node) {
				const openingCurly = sourceCode.getFirstToken(node);
				const closingCurly = sourceCode.getLastToken(node);

				offsets.setDesiredOffsets(
					[openingCurly.range[1], closingCurly.range[0]],
					openingCurly,
					1,
				);
			},

			JSXSpreadAttribute(node) {
				const openingCurly = sourceCode.getFirstToken(node);
				const closingCurly = sourceCode.getLastToken(node);

				offsets.setDesiredOffsets(
					[openingCurly.range[1], closingCurly.range[0]],
					openingCurly,
					1,
				);
			},

			&quot;*&quot;(node) {
				const firstToken = sourceCode.getFirstToken(node);

				// Ensure that the children of every node are indented at least as much as the first token.
				if (firstToken &amp;&amp; !ignoredNodeFirstTokens.has(firstToken)) {
					offsets.setDesiredOffsets(node.range, firstToken, 0);
				}
			},
		};

		const listenerCallQueue = [];

		/*
		 * To ignore the indentation of a node:
		 * 1. Don&#039;t call the node&#039;s listener when entering it (if it has a listener)
		 * 2. Don&#039;t set any offsets against the first token of the node.
		 * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.
		 */
		const offsetListeners = {};

		for (const [selector, listener] of Object.entries(
			baseOffsetListeners,
		)) {
			/*
			 * Offset listener calls are deferred until traversal is finished, and are called as
			 * part of the final `Program:exit` listener. This is necessary because a node might
			 * be matched by multiple selectors.
			 *
			 * Example: Suppose there is an offset listener for `Identifier`, and the user has
			 * specified in configuration that `MemberExpression &gt; Identifier` should be ignored.
			 * Due to selector specificity rules, the `Identifier` listener will get called first. However,
			 * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener
			 * should not have been called at all. Without doing extra selector matching, we don&#039;t know
			 * whether the Identifier matches the `MemberExpression &gt; Identifier` selector until the
			 * `MemberExpression &gt; Identifier` listener is called.
			 *
			 * To avoid this, the `Identifier` listener isn&#039;t called until traversal finishes and all
			 * ignored nodes are known.
			 */
			offsetListeners[selector] = node =&gt;
				listenerCallQueue.push({ listener, node });
		}

		// For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.
		const ignoredNodes = new Set();

		/**
		 * Ignores a node
		 * @param {ASTNode} node The node to ignore
		 * @returns {void}
		 */
		function addToIgnoredNodes(node) {
			ignoredNodes.add(node);
			ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
		}

		const ignoredNodeListeners = options.ignoredNodes.reduce(
			(listeners, ignoredSelector) =&gt;
				Object.assign(listeners, {
					[ignoredSelector]: addToIgnoredNodes,
				}),
			{},
		);

		/*
		 * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation
		 * at the end.
		 *
		 * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears
		 * in `ignoredNodeListeners`. This isn&#039;t a problem because all of the matching nodes will be ignored,
		 * so those listeners wouldn&#039;t be called anyway.
		 */
		return Object.assign(offsetListeners, ignoredNodeListeners, {
			&quot;*:exit&quot;(node) {
				// If a node&#039;s type is nonstandard, we can&#039;t tell how its children should be offset, so ignore it.
				if (!KNOWN_NODES.has(node.type)) {
					addToIgnoredNodes(node);
				}
			},
			&quot;Program:exit&quot;() {
				// If ignoreComments option is enabled, ignore all comment tokens.
				if (options.ignoreComments) {
					sourceCode
						.getAllComments()
						.forEach(comment =&gt; offsets.ignoreToken(comment));
				}

				// Invoke the queued offset listeners for the nodes that aren&#039;t ignored.
				for (let i = 0; i &lt; listenerCallQueue.length; i++) {
					const nodeInfo = listenerCallQueue[i];

					if (!ignoredNodes.has(nodeInfo.node)) {
						nodeInfo.listener(nodeInfo.node);
					}
				}

				// Update the offsets for ignored nodes to prevent their child tokens from being reported.
				ignoredNodes.forEach(ignoreNode);

				addParensIndent(sourceCode.ast.tokens);

				/*
				 * Create a Map from (tokenOrComment) =&gt; (precedingToken).
				 * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.
				 */
				const precedingTokens = new WeakMap();

				for (let i = 0; i &lt; sourceCode.ast.comments.length; i++) {
					const comment = sourceCode.ast.comments[i];

					const tokenOrCommentBefore = sourceCode.getTokenBefore(
						comment,
						{ includeComments: true },
					);
					const hasToken = precedingTokens.has(tokenOrCommentBefore)
						? precedingTokens.get(tokenOrCommentBefore)
						: tokenOrCommentBefore;

					precedingTokens.set(comment, hasToken);
				}

				for (let i = 1; i &lt; sourceCode.lines.length + 1; i++) {
					if (!tokenInfo.firstTokensByLineNumber.has(i)) {
						// Don&#039;t check indentation on blank lines
						continue;
					}

					const firstTokenOfLine =
						tokenInfo.firstTokensByLineNumber.get(i);

					if (firstTokenOfLine.loc.start.line !== i) {
						// Don&#039;t check the indentation of multi-line tokens (e.g. template literals or block comments) twice.
						continue;
					}

					if (astUtils.isCommentToken(firstTokenOfLine)) {
						const tokenBefore =
							precedingTokens.get(firstTokenOfLine);
						const tokenAfter = tokenBefore
							? sourceCode.getTokenAfter(tokenBefore)
							: sourceCode.ast.tokens[0];
						const mayAlignWithBefore =
							tokenBefore &amp;&amp;
							!hasBlankLinesBetween(
								tokenBefore,
								firstTokenOfLine,
							);
						const mayAlignWithAfter =
							tokenAfter &amp;&amp;
							!hasBlankLinesBetween(firstTokenOfLine, tokenAfter);

						/*
						 * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.
						 *
						 * let foo
						 * // comment
						 * ;(async () =&gt; {})()
						 */
						if (
							tokenAfter &amp;&amp;
							astUtils.isSemicolonToken(tokenAfter) &amp;&amp;
							!astUtils.isTokenOnSameLine(
								firstTokenOfLine,
								tokenAfter,
							)
						) {
							offsets.setDesiredOffset(
								firstTokenOfLine,
								tokenAfter,
								0,
							);
						}

						// If a comment matches the expected indentation of the token immediately before or after, don&#039;t report it.
						if (
							(mayAlignWithBefore &amp;&amp;
								validateTokenIndent(
									firstTokenOfLine,
									offsets.getDesiredIndent(tokenBefore),
								)) ||
							(mayAlignWithAfter &amp;&amp;
								validateTokenIndent(
									firstTokenOfLine,
									offsets.getDesiredIndent(tokenAfter),
								))
						) {
							continue;
						}
					}

					// If the token matches the expected indentation, don&#039;t report it.
					if (
						validateTokenIndent(
							firstTokenOfLine,
							offsets.getDesiredIndent(firstTokenOfLine),
						)
					) {
						continue;
					}

					// Otherwise, report the token/comment.
					report(
						firstTokenOfLine,
						offsets.getDesiredIndent(firstTokenOfLine),
					);
				}
			},
		});
	},
};
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
