<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/luxon/src/impl/tokenParser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/luxon/src/impl/tokenParser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">506</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">66.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.79</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { parseMillis, isUndefined, untruncateYear, signedOffset, hasOwnProperty } from &quot;./util.js&quot;;
import Formatter from &quot;./formatter.js&quot;;
import FixedOffsetZone from &quot;../zones/fixedOffsetZone.js&quot;;
import IANAZone from &quot;../zones/IANAZone.js&quot;;
import DateTime from &quot;../datetime.js&quot;;
import { digitRegex, parseDigits } from &quot;./digits.js&quot;;
import { ConflictingSpecificationError } from &quot;../errors.js&quot;;

const MISSING_FTP = &quot;missing Intl.DateTimeFormat.formatToParts support&quot;;

function intUnit(regex, post = (i) =&gt; i) {
  return { regex, deser: ([s]) =&gt; post(parseDigits(s)) };
}

const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, &quot;g&quot;);

function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, &quot;\\.?&quot;).replace(spaceOrNBSPRegExp, spaceOrNBSP);
}

function stripInsensitivities(s) {
  return s
    .replace(/\./g, &quot;&quot;) // ignore dots that were made optional
    .replace(spaceOrNBSPRegExp, &quot; &quot;) // interchange space and nbsp
    .toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join(&quot;|&quot;)),
      deser: ([s]) =&gt;
        strings.findIndex((i) =&gt; stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,
    };
  }
}

function offset(regex, groups) {
  return { regex, deser: ([, h, m]) =&gt; signedOffset(h, m), groups };
}

function simple(regex) {
  return { regex, deser: ([s]) =&gt; s };
}

function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, &quot;\\$&amp;&quot;);
}

/**
 * @param token
 * @param {Locale} loc
 */
function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, &quot;{2}&quot;),
    three = digitRegex(loc, &quot;{3}&quot;),
    four = digitRegex(loc, &quot;{4}&quot;),
    six = digitRegex(loc, &quot;{6}&quot;),
    oneOrTwo = digitRegex(loc, &quot;{1,2}&quot;),
    oneToThree = digitRegex(loc, &quot;{1,3}&quot;),
    oneToSix = digitRegex(loc, &quot;{1,6}&quot;),
    oneToNine = digitRegex(loc, &quot;{1,9}&quot;),
    twoToFour = digitRegex(loc, &quot;{2,4}&quot;),
    fourToSix = digitRegex(loc, &quot;{4,6}&quot;),
    literal = (t) =&gt; ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) =&gt; s, literal: true }),
    unitate = (t) =&gt; {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case &quot;G&quot;:
          return oneOf(loc.eras(&quot;short&quot;), 0);
        case &quot;GG&quot;:
          return oneOf(loc.eras(&quot;long&quot;), 0);
        // years
        case &quot;y&quot;:
          return intUnit(oneToSix);
        case &quot;yy&quot;:
          return intUnit(twoToFour, untruncateYear);
        case &quot;yyyy&quot;:
          return intUnit(four);
        case &quot;yyyyy&quot;:
          return intUnit(fourToSix);
        case &quot;yyyyyy&quot;:
          return intUnit(six);
        // months
        case &quot;M&quot;:
          return intUnit(oneOrTwo);
        case &quot;MM&quot;:
          return intUnit(two);
        case &quot;MMM&quot;:
          return oneOf(loc.months(&quot;short&quot;, true), 1);
        case &quot;MMMM&quot;:
          return oneOf(loc.months(&quot;long&quot;, true), 1);
        case &quot;L&quot;:
          return intUnit(oneOrTwo);
        case &quot;LL&quot;:
          return intUnit(two);
        case &quot;LLL&quot;:
          return oneOf(loc.months(&quot;short&quot;, false), 1);
        case &quot;LLLL&quot;:
          return oneOf(loc.months(&quot;long&quot;, false), 1);
        // dates
        case &quot;d&quot;:
          return intUnit(oneOrTwo);
        case &quot;dd&quot;:
          return intUnit(two);
        // ordinals
        case &quot;o&quot;:
          return intUnit(oneToThree);
        case &quot;ooo&quot;:
          return intUnit(three);
        // time
        case &quot;HH&quot;:
          return intUnit(two);
        case &quot;H&quot;:
          return intUnit(oneOrTwo);
        case &quot;hh&quot;:
          return intUnit(two);
        case &quot;h&quot;:
          return intUnit(oneOrTwo);
        case &quot;mm&quot;:
          return intUnit(two);
        case &quot;m&quot;:
          return intUnit(oneOrTwo);
        case &quot;q&quot;:
          return intUnit(oneOrTwo);
        case &quot;qq&quot;:
          return intUnit(two);
        case &quot;s&quot;:
          return intUnit(oneOrTwo);
        case &quot;ss&quot;:
          return intUnit(two);
        case &quot;S&quot;:
          return intUnit(oneToThree);
        case &quot;SSS&quot;:
          return intUnit(three);
        case &quot;u&quot;:
          return simple(oneToNine);
        case &quot;uu&quot;:
          return simple(oneOrTwo);
        case &quot;uuu&quot;:
          return intUnit(one);
        // meridiem
        case &quot;a&quot;:
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case &quot;kkkk&quot;:
          return intUnit(four);
        case &quot;kk&quot;:
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case &quot;W&quot;:
          return intUnit(oneOrTwo);
        case &quot;WW&quot;:
          return intUnit(two);
        // weekdays
        case &quot;E&quot;:
        case &quot;c&quot;:
          return intUnit(one);
        case &quot;EEE&quot;:
          return oneOf(loc.weekdays(&quot;short&quot;, false), 1);
        case &quot;EEEE&quot;:
          return oneOf(loc.weekdays(&quot;long&quot;, false), 1);
        case &quot;ccc&quot;:
          return oneOf(loc.weekdays(&quot;short&quot;, true), 1);
        case &quot;cccc&quot;:
          return oneOf(loc.weekdays(&quot;long&quot;, true), 1);
        // offset/zone
        case &quot;Z&quot;:
        case &quot;ZZ&quot;:
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case &quot;ZZZ&quot;:
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don&#039;t support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don&#039;t have any way to figure out what they are
        case &quot;z&quot;:
          return simple(/[a-z_+-/]{1,256}?/i);
        // this special-case &quot;token&quot; represents a place where a macro-token expanded into a white-space literal
        // in this case we accept any non-newline white-space
        case &quot; &quot;:
          return simple(/[^\S\n\r]/);
        default:
          return literal(t);
      }
    };

  const unit = unitate(token) || {
    invalidReason: MISSING_FTP,
  };

  unit.token = token;

  return unit;
}

const partTypeStyleToTokenVal = {
  year: {
    &quot;2-digit&quot;: &quot;yy&quot;,
    numeric: &quot;yyyyy&quot;,
  },
  month: {
    numeric: &quot;M&quot;,
    &quot;2-digit&quot;: &quot;MM&quot;,
    short: &quot;MMM&quot;,
    long: &quot;MMMM&quot;,
  },
  day: {
    numeric: &quot;d&quot;,
    &quot;2-digit&quot;: &quot;dd&quot;,
  },
  weekday: {
    short: &quot;EEE&quot;,
    long: &quot;EEEE&quot;,
  },
  dayperiod: &quot;a&quot;,
  dayPeriod: &quot;a&quot;,
  hour12: {
    numeric: &quot;h&quot;,
    &quot;2-digit&quot;: &quot;hh&quot;,
  },
  hour24: {
    numeric: &quot;H&quot;,
    &quot;2-digit&quot;: &quot;HH&quot;,
  },
  minute: {
    numeric: &quot;m&quot;,
    &quot;2-digit&quot;: &quot;mm&quot;,
  },
  second: {
    numeric: &quot;s&quot;,
    &quot;2-digit&quot;: &quot;ss&quot;,
  },
  timeZoneName: {
    long: &quot;ZZZZZ&quot;,
    short: &quot;ZZZ&quot;,
  },
};

function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;

  if (type === &quot;literal&quot;) {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? &quot; &quot; : value,
    };
  }

  const style = formatOpts[type];

  // The user might have explicitly specified hour12 or hourCycle
  // if so, respect their decision
  // if not, refer back to the resolvedOpts, which are based on the locale
  let actualType = type;
  if (type === &quot;hour&quot;) {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? &quot;hour12&quot; : &quot;hour24&quot;;
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === &quot;h11&quot; || formatOpts.hourCycle === &quot;h12&quot;) {
        actualType = &quot;hour12&quot;;
      } else {
        actualType = &quot;hour24&quot;;
      }
    } else {
      // tokens only differentiate between 24 hours or not,
      // so we do not need to check hourCycle here, which is less supported anyways
      actualType = resolvedOpts.hour12 ? &quot;hour12&quot; : &quot;hour24&quot;;
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === &quot;object&quot;) {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val,
    };
  }

  return undefined;
}

function buildRegex(units) {
  const re = units.map((u) =&gt; u.regex).reduce((f, r) =&gt; `${f}(${r.source})`, &quot;&quot;);
  return [`^${re}$`, units];
}

function match(input, regex, handlers) {
  const matches = input.match(regex);

  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal &amp;&amp; h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  const toField = (token) =&gt; {
    switch (token) {
      case &quot;S&quot;:
        return &quot;millisecond&quot;;
      case &quot;s&quot;:
        return &quot;second&quot;;
      case &quot;m&quot;:
        return &quot;minute&quot;;
      case &quot;h&quot;:
      case &quot;H&quot;:
        return &quot;hour&quot;;
      case &quot;d&quot;:
        return &quot;day&quot;;
      case &quot;o&quot;:
        return &quot;ordinal&quot;;
      case &quot;L&quot;:
      case &quot;M&quot;:
        return &quot;month&quot;;
      case &quot;y&quot;:
        return &quot;year&quot;;
      case &quot;E&quot;:
      case &quot;c&quot;:
        return &quot;weekday&quot;;
      case &quot;W&quot;:
        return &quot;weekNumber&quot;;
      case &quot;k&quot;:
        return &quot;weekYear&quot;;
      case &quot;q&quot;:
        return &quot;quarter&quot;;
      default:
        return null;
    }
  };

  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }

  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }

  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }

  if (!isUndefined(matches.h)) {
    if (matches.h &lt; 12 &amp;&amp; matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 &amp;&amp; matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 &amp;&amp; matches.y) {
    matches.y = -matches.y;
  }

  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }

  const vals = Object.keys(matches).reduce((r, k) =&gt; {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});

  return [vals, zone, specificOffset];
}

let dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);

  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

export function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) =&gt; maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

export class TokenParser {
  constructor(locale, format) {
    this.locale = locale;
    this.format = format;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
    this.units = this.tokens.map((t) =&gt; unitForToken(t, locale));
    this.disqualifyingUnit = this.units.find((t) =&gt; t.invalidReason);

    if (!this.disqualifyingUnit) {
      const [regexString, handlers] = buildRegex(this.units);
      this.regex = RegExp(regexString, &quot;i&quot;);
      this.handlers = handlers;
    }
  }

  explainFromTokens(input) {
    if (!this.isValid) {
      return { input, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches] = match(input, this.regex, this.handlers),
        [result, zone, specificOffset] = matches
          ? dateTimeFromMatches(matches)
          : [null, null, undefined];
      if (hasOwnProperty(matches, &quot;a&quot;) &amp;&amp; hasOwnProperty(matches, &quot;H&quot;)) {
        throw new ConflictingSpecificationError(
          &quot;Can&#039;t include meridiem when specifying 24-hour format&quot;
        );
      }
      return {
        input,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset,
      };
    }
  }

  get isValid() {
    return !this.disqualifyingUnit;
  }

  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}

export function explainFromTokens(locale, input, format) {
  const parser = new TokenParser(locale, format);
  return parser.explainFromTokens(input);
}

export function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}

export function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }

  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) =&gt; tokenForPart(p, formatOpts, resolvedOpts));
}
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
