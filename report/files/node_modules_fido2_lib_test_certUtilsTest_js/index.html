<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fido2-lib/test/certUtilsTest.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fido2-lib/test/certUtilsTest.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">514</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">38.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.12</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

const {
	Certificate,
	CertManager,
	CRL,
	helpers: certHelpers,
} = require(&quot;../lib/certUtils&quot;);
const { resolveOid } = certHelpers;
const chai = require(&quot;chai&quot;);
var chaiAsPromised = require(&quot;chai-as-promised&quot;);
chai.use(chaiAsPromised);
var assert = chai.assert;
var h = require(&quot;fido2-helpers&quot;);
const { printHex } = require(&quot;../lib/utils&quot;);
let abEqual = h.functions.abEqual;

describe(&quot;cert utils&quot;, function() {
	afterEach(function() {
		CertManager.removeAll();
	});

	describe(&quot;Certificate&quot;, function() {
		it(&quot;is function&quot;, function() {
			assert.isFunction(Certificate);
		});

		describe(&quot;constructor&quot;, function() {
			it(&quot;can create new cert&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				assert.instanceOf(cert, Certificate);
				assert.isObject(cert._cert);
			});

			it(&quot;throws if no arg to constructor&quot;, function() {
				assert.throws(() =&gt; {
					new Certificate();
				}, TypeError, &quot;could not coerce &#039;certificate&#039; to ArrayBuffer&quot;);
			});

			it(&quot;throws if constructor arg can&#039;t be coerced to ArrayBuffer&quot;, function() {
				assert.throws(() =&gt; {
					new Certificate(3);
				}, TypeError, &quot;could not coerce &#039;certificate&#039; to ArrayBuffer&quot;);
			});

			it(&quot;throws if cert is empty ArrayBuffer&quot;, function() {
				assert.throws(() =&gt; {
					new Certificate([]);
				}, Error, &quot;cert was empty (0 bytes)&quot;);
			});

			it(&quot;can create from PEM&quot;);
		});


		describe(&quot;verify&quot;, function() {
			it(&quot;can verify root cert&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var p = cert.verify();
				assert.instanceOf(p, Promise);
				return p;
			});

			it(&quot;throws if root cert isn&#039;t found&quot;, async function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var p;
				try {
					p = await cert.verify();
				} catch (err) {
					assert.instanceOf(err, Error);
					assert.strictEqual(err.message, &quot;Please provide issuer certificate as a parameter&quot;);
				}
				assert.isUndefined(p);
				return Promise.resolve();
			});

			it(&quot;can verify cert with root cert&quot;, async function() {
				CertManager.addCert(h.certs.yubicoRoot);
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				await cert.verify();
			});
		});

		describe(&quot;getPublicKey&quot;, function() {
			it(&quot;can extract public key of attestation&quot;, function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var p = cert.getPublicKey();
				assert.instanceOf(p, Promise);
				return p.then((jwk) =&gt; {
					assert.isObject(jwk);
					assert.strictEqual(jwk.kty, &quot;EC&quot;);
					assert.strictEqual(jwk.crv, &quot;P-256&quot;);
					assert.strictEqual(jwk.x, &quot;SzMfdz2BRLmZXL5FhVF-F1g6pHYjaVy-haxILIAZ8sk&quot;);
					assert.strictEqual(jwk.y, &quot;uUZ64EWw5m8TGy6jJDyR_aYC4xjz_F2NKnq65yvRQwk&quot;);
				});
			});

			it(&quot;can extract public key of root&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var p = cert.getPublicKey();
				assert.instanceOf(p, Promise);
				return p.then((jwk) =&gt; {
					assert.isObject(jwk);
					assert.strictEqual(jwk.kty, &quot;RSA&quot;);
					assert.strictEqual(jwk.alg, &quot;RS256&quot;);
					assert.strictEqual(jwk.e, &quot;AQAB&quot;);
					assert.strictEqual(jwk.n, &quot;v48GLoQVZamomFhDLK1hYrICfj7TPdXkq6SOEyu1Od5sAiGsEgx8vL1JpOTdigI_Wm70_TT-UjEtYUIt7rMaGBqJ10IHzumV8lAPWvigJKnRZwZ5croEngjnqfBHWRX7GkRbTI5MM-RnM9j8uLyGLwnTBz7cGs9G1bs53rniBM-k50IxOt0Xbds28J3m8ExuWcm3lksG88vgSd-GR3FITwGPPciUF7hNCMzGRXBAWzzUW1hAkSoI6v_6k_Z5gzhVZUkQrdsIqj0s5bsJ_r_rLkBAbFI0xjBHdubSl105DVttcCFm8XkslKE18C7xkusZcEEoDaZNql2MH_Il4O1VmQ&quot;);
				});
			});
		});

		describe(&quot;getSerial&quot;, function() {
			it(&quot;returns correct serial for attestation&quot;, function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var serial = cert.getSerial();
				assert.strictEqual(serial, &quot;Yubico U2F EE Serial 1432534688&quot;);
			});
			it(&quot;returns correct serial for root&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var serial = cert.getSerial();
				assert.strictEqual(serial, &quot;Yubico U2F Root CA Serial 457200631&quot;);
			});
		});

		describe(&quot;getIssuer&quot;, function() {
			it(&quot;returns correct issuer for attestation&quot;, function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var serial = cert.getIssuer();
				assert.strictEqual(serial, &quot;Yubico U2F Root CA Serial 457200631&quot;);
			});

			it(&quot;returns correct issuer for root&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var serial = cert.getIssuer();
				assert.strictEqual(serial, &quot;Yubico U2F Root CA Serial 457200631&quot;);
			});
		});

		describe(&quot;getVersion&quot;, function() {
			it(&quot;returns correct version for attestation&quot;, function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var version = cert.getVersion();
				assert.isNumber(version);
				assert.strictEqual(version, 3);
			});

			it(&quot;returns correct version for root&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var version = cert.getVersion();
				assert.isNumber(version);
				assert.strictEqual(version, 3);
			});
		});

		describe(&quot;getExtensions&quot;, function() {
			it(&quot;returns correct extensions for attestation&quot;, function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var extensions = cert.getExtensions();
				assert.instanceOf(extensions, Map);
				assert.strictEqual(extensions.size, 2);
				assert.isTrue(extensions.has(&quot;yubico-device-id&quot;));
				assert.isTrue(extensions.has(&quot;fido-u2f-transports&quot;));
				assert.strictEqual(extensions.get(&quot;yubico-device-id&quot;), &quot;YubiKey 4/YubiKey 4 Nano&quot;);
				var u2fTransports = extensions.get(&quot;fido-u2f-transports&quot;);
				assert.instanceOf(u2fTransports, Set);
				assert.strictEqual(u2fTransports.size, 1);
				assert.isTrue(u2fTransports.has(&quot;usb&quot;));
			});

			it(&quot;returns correct extensions for root&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var extensions = cert.getExtensions();
				assert.instanceOf(extensions, Map);
				assert.strictEqual(extensions.size, 3);
				assert.isTrue(extensions.has(&quot;subject-key-identifier&quot;));
				assert.isTrue(extensions.has(&quot;basic-constraints&quot;));
				assert.isTrue(extensions.has(&quot;key-usage&quot;));
				assert.instanceOf(extensions.get(&quot;subject-key-identifier&quot;), ArrayBuffer);
				assert.isObject(extensions.get(&quot;basic-constraints&quot;));
				assert.instanceOf(extensions.get(&quot;key-usage&quot;), Set);
				assert.isTrue(extensions.get(&quot;key-usage&quot;).has(&quot;cRLSign&quot;));
				assert.isTrue(extensions.get(&quot;key-usage&quot;).has(&quot;keyCertSign&quot;));
			});

			it(&quot;returns FIDO2 extensions&quot;, function() {
				var cert = new Certificate(h.certs.feitianFido2);
				var extensions = cert.getExtensions();
				assert.instanceOf(cert.warning, Map);
				assert.strictEqual(cert.warning.size, 0);

				assert.instanceOf(extensions, Map);
				assert.strictEqual(extensions.size, 5);

				// subject-key-identifier
				var subjectKeyId = extensions.get(&quot;subject-key-identifier&quot;);
				assert.instanceOf(subjectKeyId, ArrayBuffer);
				assert.strictEqual(subjectKeyId.byteLength, 20);

				// authority-key-identifier
				var authorityKeyId = extensions.get(&quot;authority-key-identifier&quot;);
				assert.instanceOf(authorityKeyId, Map);
				assert.strictEqual(authorityKeyId.size, 1);
				assert.instanceOf(authorityKeyId.get(&quot;key-identifier&quot;), ArrayBuffer);

				// basic-constraints
				var basicConstraints = extensions.get(&quot;basic-constraints&quot;);
				assert.isObject(basicConstraints);
				assert.strictEqual(Object.keys(basicConstraints).length, 1);
				assert.strictEqual(basicConstraints.cA, false);

				// fido-u2f-transports
				var transports = extensions.get(&quot;fido-u2f-transports&quot;);
				assert.instanceOf(transports, Set);
				assert.strictEqual(transports.size, 1);
				assert.isTrue(transports.has(&quot;usb&quot;), &quot;transports has USB&quot;);

				// &#039;fido-u2f-transports&#039; =&gt; Set { &#039;usb&#039; },

				// fido-aaguid
				var aaguid = extensions.get(&quot;fido-aaguid&quot;);
				assert.instanceOf(aaguid, ArrayBuffer);
				var expectedAaguid = new Uint8Array([0x42, 0x38, 0x32, 0x45, 0x44, 0x37, 0x33, 0x43, 0x38, 0x46, 0x42, 0x34, 0x45, 0x35, 0x41, 0x32]).buffer;
				assert.isTrue(abEqual(aaguid, expectedAaguid), &quot;correct aaguid value&quot;);
			});

			it(&quot;returns correct extensions for TPM attestation&quot;, function() {
				var cert = new Certificate(h.certs.tpmAttestation);
				var extensions = cert.getExtensions();
				assert.instanceOf(extensions, Map);
				assert.strictEqual(extensions.size, 8);
				// key usage
				var keyUsage = extensions.get(&quot;key-usage&quot;);
				assert.instanceOf(keyUsage, Set);
				assert.strictEqual(keyUsage.size, 1);
				assert.isTrue(keyUsage.has(&quot;digitalSignature&quot;), &quot;key-usage has digital signature&quot;);
				// basic constraints
				var basicConstraints = extensions.get(&quot;basic-constraints&quot;);
				assert.isObject(basicConstraints);
				assert.strictEqual(Object.keys(basicConstraints).length, 1);
				assert.strictEqual(basicConstraints.cA, false);
				// certificate policies
				var certPolicies = extensions.get(&quot;certificate-policies&quot;);
				assert.isArray(certPolicies);
				assert.strictEqual(certPolicies.length, 1);
				var policyQualifiers = certPolicies[0];
				assert.isObject(policyQualifiers);
				assert.strictEqual(policyQualifiers.id, &quot;policy-qualifiers&quot;);
				assert.isArray(policyQualifiers.value);
				assert.strictEqual(policyQualifiers.value.length, 1);
				var policyQualifier = policyQualifiers.value[0];
				assert.isObject(policyQualifier);
				assert.strictEqual(policyQualifier.id, &quot;policy-qualifier&quot;);
				assert.isArray(policyQualifier.value);
				assert.strictEqual(policyQualifier.value.length, 1);
				assert.strictEqual(policyQualifier.value[0], &quot;TCPA  Trusted  Platform  Identity&quot;);
				// extended key usage
				var extKeyUsage = extensions.get(&quot;ext-key-usage&quot;);
				assert.isArray(extKeyUsage);
				assert.strictEqual(extKeyUsage.length, 1);
				assert.strictEqual(extKeyUsage[0], &quot;tcg-kp-aik-certificate&quot;);
				// alternate name
				var subjAltNames = extensions.get(&quot;subject-alt-name&quot;);
				assert.isArray(subjAltNames);
				assert.strictEqual(subjAltNames.length, 1);
				var subjAltName = subjAltNames[0];
				assert.isObject(subjAltName);
				assert.strictEqual(Object.keys(subjAltName).length, 1);
				var generalNames = subjAltName.directoryName;
				assert.instanceOf(generalNames, Map);
				assert.strictEqual(generalNames.size, 3);
				assert.strictEqual(generalNames.get(&quot;tcg-at-tpm-version&quot;), &quot;id:13&quot;);
				assert.strictEqual(generalNames.get(&quot;tcg-at-tpm-model&quot;), &quot;NPCT6xx&quot;);
				assert.strictEqual(generalNames.get(&quot;tcg-at-tpm-manufacturer&quot;), &quot;id:4E544300&quot;);
				// authority key identifier
				var authKeyId = extensions.get(&quot;authority-key-identifier&quot;);
				assert.instanceOf(authKeyId, Map);
				assert.strictEqual(authKeyId.size, 1);
				authKeyId = authKeyId.get(&quot;key-identifier&quot;);
				assert.instanceOf(authKeyId, ArrayBuffer);
				var expectedAuthKeyId = new Uint8Array([
					0xC2, 0x12, 0xA9, 0x5B, 0xCE, 0xFA, 0x56, 0xF8, 0xC0, 0xC1, 0x6F, 0xB1, 0x5B, 0xDD, 0x03, 0x34,
					0x47, 0xB3, 0x7A, 0xA3,
				]).buffer;
				assert.isTrue(abEqual(authKeyId, expectedAuthKeyId), &quot;got expected authority key identifier&quot;);
				// subject key identifier
				var subjectKeyId = extensions.get(&quot;subject-key-identifier&quot;);
				assert.instanceOf(subjectKeyId, ArrayBuffer);
				var expectedSubjectKeyId = new Uint8Array([
					0xAF, 0xE2, 0x45, 0xD3, 0x48, 0x0F, 0x22, 0xDC, 0xD5, 0x0C, 0xD2, 0xAE, 0x7B, 0x96, 0xB5, 0xA9,
					0x33, 0xCA, 0x7F, 0xE1,
				]).buffer;
				assert.isTrue(abEqual(subjectKeyId, expectedSubjectKeyId), &quot;got expected authority key identifier&quot;);
				// info access
				var infoAccess = extensions.get(&quot;authority-info-access&quot;);
				assert.instanceOf(infoAccess, Map);
				assert.strictEqual(infoAccess.size, 1);
				var certAuthIss = infoAccess.get(&quot;cert-authority-issuers&quot;);
				assert.isObject(certAuthIss);
				assert.strictEqual(Object.keys(certAuthIss).length, 1);
				assert.strictEqual(certAuthIss.uniformResourceIdentifier, &quot;https://azcsprodncuaikpublish.blob.core.windows.net/ncu-ntc-keyid-1591d4b6eaf98d0104864b6903a48dd0026077d3/3b918ae4-07e1-4059-9491-0ad248190818.cer&quot;);
			});
		});

		describe(&quot;getSubject&quot;, function() {
			it(&quot;returns correct extensions for attestation&quot;, function() {
				var cert = new Certificate(h.certs.yubiKeyAttestation);
				var subject = cert.getSubject();
				assert.instanceOf(subject, Map);
				assert.strictEqual(subject.size, 1);
				assert.strictEqual(subject.get(&quot;common-name&quot;), &quot;Yubico U2F EE Serial 1432534688&quot;);

			});

			it(&quot;returns correct extensions for root&quot;, function() {
				var cert = new Certificate(h.certs.yubicoRoot);
				var subject = cert.getSubject();
				assert.instanceOf(subject, Map);
				assert.strictEqual(subject.size, 1);
				assert.strictEqual(subject.get(&quot;common-name&quot;), &quot;Yubico U2F Root CA Serial 457200631&quot;);
			});

			it(&quot;returns correct values for Feitian FIDO2&quot;, function() {
				var cert = new Certificate(h.certs.feitianFido2);
				var subject = cert.getSubject();
				assert.instanceOf(subject, Map);
				assert.strictEqual(subject.size, 4);
				assert.strictEqual(subject.get(&quot;country-name&quot;), &quot;CN&quot;);
				assert.strictEqual(subject.get(&quot;organization-name&quot;), &quot;Feitian Technologies&quot;);
				assert.strictEqual(subject.get(&quot;organizational-unit-name&quot;), &quot;Authenticator Attestation&quot;);
				assert.strictEqual(subject.get(&quot;common-name&quot;), &quot;FT BioPass FIDO2 USB&quot;);
			});
		});
	});

	describe(&quot;helpers&quot;, function() {
		describe(&quot;resolveOid&quot;, function() {
			it(&quot;decodes U2F USB transport type&quot;, function() {
				var ret = resolveOid(
					&quot;1.3.6.1.4.1.45724.2.1.1&quot;,
					new Uint8Array([0x03, 0x02, 0x05, 0x20]).buffer
				);
				assert.isObject(ret);
				assert.strictEqual(ret.id, &quot;fido-u2f-transports&quot;);
				assert.instanceOf(ret.value, Set);
				assert.strictEqual(ret.value.size, 1);
				assert.isTrue(ret.value.has(&quot;usb&quot;));
			});

			it(&quot;decodes U2F Bluetooth Classic transport type&quot;, function() {
				var ret = resolveOid(
					&quot;1.3.6.1.4.1.45724.2.1.1&quot;,
					new Uint8Array([0x03, 0x02, 0x07, 0x80]).buffer
				);
				assert.isObject(ret);
				assert.strictEqual(ret.id, &quot;fido-u2f-transports&quot;);
				assert.instanceOf(ret.value, Set);
				assert.strictEqual(ret.value.size, 1);
				assert.isTrue(ret.value.has(&quot;bluetooth-classic&quot;));
			});

			it(&quot;decodes U2F USB+NFC transport type&quot;, function() {
				var ret = resolveOid(
					&quot;1.3.6.1.4.1.45724.2.1.1&quot;,
					new Uint8Array([0x03, 0x02, 0x04, 0x30]).buffer
				);
				assert.isObject(ret);
				assert.strictEqual(ret.id, &quot;fido-u2f-transports&quot;);
				assert.instanceOf(ret.value, Set);
				assert.strictEqual(ret.value.size, 2);
				assert.isTrue(ret.value.has(&quot;usb&quot;));
				assert.isTrue(ret.value.has(&quot;nfc&quot;));
			});

			it(&quot;decodes U2F USB Internal transport type&quot;, function() {
				var ret = resolveOid(
					&quot;1.3.6.1.4.1.45724.2.1.1&quot;,
					new Uint8Array([0x03, 0x02, 0x03, 0x08]).buffer
				);
				assert.isObject(ret);
				assert.strictEqual(ret.id, &quot;fido-u2f-transports&quot;);
				assert.instanceOf(ret.value, Set);
				assert.strictEqual(ret.value.size, 1);
				assert.isTrue(ret.value.has(&quot;usb-internal&quot;));
			});

			it(&quot;decodes all transport types&quot;, function() {
				var ret = resolveOid(
					&quot;1.3.6.1.4.1.45724.2.1.1&quot;,
					new Uint8Array([0x03, 0x02, 0x03, 0xF8]).buffer
				);
				assert.isObject(ret);
				assert.strictEqual(ret.id, &quot;fido-u2f-transports&quot;);
				assert.instanceOf(ret.value, Set);
				assert.strictEqual(ret.value.size, 5);
				assert.isTrue(ret.value.has(&quot;bluetooth-classic&quot;));
				assert.isTrue(ret.value.has(&quot;bluetooth-low-energy&quot;));
				assert.isTrue(ret.value.has(&quot;usb&quot;));
				assert.isTrue(ret.value.has(&quot;nfc&quot;));
				assert.isTrue(ret.value.has(&quot;usb-internal&quot;));
			});

			it(&quot;decodes YubiKey Nano device type&quot;);
		});
	});

	describe(&quot;CRL&quot;, function() {
		it(&quot;can create mdsRootCrl&quot;, function() {
			var ret = new CRL(h.mds.mdsRootCrl);
			assert.isObject(ret);
			assert.isObject(ret._crl);
		});

		it(&quot;can create ca1Crl&quot;, function() {
			var ret = new CRL(h.mds.ca1Crl);
			assert.isObject(ret);
			assert.isObject(ret._crl);
		});
	});

	describe(&quot;CertManager&quot;, function() {
		it(&quot;is function&quot;, function() {
			assert.isFunction(CertManager);
		});

		it(&quot;has static methods&quot;, function() {
			assert.isFunction(CertManager.addCert);
			assert.isFunction(CertManager.removeAll);
		});

		describe(&quot;addCert&quot;, function() {
			it(&quot;throws if no cert&quot;, function() {
				assert.throws(() =&gt; {
					CertManager.addCert();
				}, TypeError, &quot;could not coerce &#039;certificate&#039; to ArrayBuffer&quot;);
			});

			it(&quot;can add cert&quot;, function() {
				CertManager.addCert(h.certs.yubicoRoot);
			});
		});

		describe(&quot;getCerts&quot;, function() {
			it(&quot;returns empty Map if no certs added&quot;, function() {
				var ret = CertManager.getCerts();
				assert.instanceOf(ret, Map);
				assert.strictEqual(ret.size, 0);
			});

			it(&quot;returns Map with added cert&quot;, function() {
				CertManager.addCert(h.certs.yubicoRoot);
				var ret = CertManager.getCerts();
				assert.instanceOf(ret, Map);
				assert.strictEqual(ret.size, 1);
				assert.isTrue(ret.has(&quot;Yubico U2F Root CA Serial 457200631&quot;));
			});
		});

		describe(&quot;removeAll&quot;, function() {
			it(&quot;can clear all&quot;); // if this didn&#039;t work, afterEach would fail...
		});

		describe(&quot;verifyCertChain&quot;, function() {
			it(&quot;rejects on empty arguments&quot;, function() {
				return assert.isRejected(CertManager.verifyCertChain(), Error, &quot;expected &#039;certs&#039; to be non-empty Array, got: undefined&quot;);
			});

			it(&quot;works for MDS2&quot;, function() {
				var certs = [
					new Certificate(h.mds.mdsSigningCert),
					new Certificate(h.mds.mdsIntermediateCert),
				];
				var trustedRoots = [
					new Certificate(h.mds.mdsRootCert),
				];

				var certRevocationLists = [
					new CRL(h.mds.mdsRootCrl),
					new CRL(h.mds.ca1Crl),
				];

				var ret = CertManager.verifyCertChain(certs, trustedRoots, certRevocationLists);
				assert.instanceOf(ret, Promise);
				return ret;
			});

			it(&quot;works for TPM&quot;);

			it(&quot;will create certs from input arrays&quot;, function() {
				var certs = [
					h.mds.mdsSigningCert,
					h.mds.mdsIntermediateCert,
				];
				var trustedRoots = [
					h.mds.mdsRootCert,
				];

				var certRevocationLists = [
					h.mds.mdsRootCrl,
					h.mds.ca1Crl,
				];

				var ret = CertManager.verifyCertChain(certs, trustedRoots, certRevocationLists);
				assert.instanceOf(ret, Promise);
				return ret;
			});

			it(&quot;rejects on bad value in certs&quot;);
			it(&quot;rejects on bad value in roots&quot;);
			it(&quot;rejects on bad value in CRLs&quot;);
		});
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
