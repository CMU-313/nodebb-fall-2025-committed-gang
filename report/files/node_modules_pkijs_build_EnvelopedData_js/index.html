<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/build/EnvelopedData.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/build/EnvelopedData.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1491</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">172.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">15.29</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
	value: true
});

var _asn1js = require(&quot;asn1js&quot;);

var asn1js = _interopRequireWildcard(_asn1js);

var _pvutils = require(&quot;pvutils&quot;);

var _common = require(&quot;./common.js&quot;);

var _OriginatorInfo = require(&quot;./OriginatorInfo.js&quot;);

var _OriginatorInfo2 = _interopRequireDefault(_OriginatorInfo);

var _RecipientInfo = require(&quot;./RecipientInfo.js&quot;);

var _RecipientInfo2 = _interopRequireDefault(_RecipientInfo);

var _EncryptedContentInfo = require(&quot;./EncryptedContentInfo.js&quot;);

var _EncryptedContentInfo2 = _interopRequireDefault(_EncryptedContentInfo);

var _Attribute = require(&quot;./Attribute.js&quot;);

var _Attribute2 = _interopRequireDefault(_Attribute);

var _AlgorithmIdentifier = require(&quot;./AlgorithmIdentifier.js&quot;);

var _AlgorithmIdentifier2 = _interopRequireDefault(_AlgorithmIdentifier);

var _RSAESOAEPParams = require(&quot;./RSAESOAEPParams.js&quot;);

var _RSAESOAEPParams2 = _interopRequireDefault(_RSAESOAEPParams);

var _KeyTransRecipientInfo = require(&quot;./KeyTransRecipientInfo.js&quot;);

var _KeyTransRecipientInfo2 = _interopRequireDefault(_KeyTransRecipientInfo);

var _IssuerAndSerialNumber = require(&quot;./IssuerAndSerialNumber.js&quot;);

var _IssuerAndSerialNumber2 = _interopRequireDefault(_IssuerAndSerialNumber);

var _RecipientEncryptedKey = require(&quot;./RecipientEncryptedKey.js&quot;);

var _RecipientEncryptedKey2 = _interopRequireDefault(_RecipientEncryptedKey);

var _KeyAgreeRecipientIdentifier = require(&quot;./KeyAgreeRecipientIdentifier.js&quot;);

var _KeyAgreeRecipientIdentifier2 = _interopRequireDefault(_KeyAgreeRecipientIdentifier);

var _KeyAgreeRecipientInfo = require(&quot;./KeyAgreeRecipientInfo.js&quot;);

var _KeyAgreeRecipientInfo2 = _interopRequireDefault(_KeyAgreeRecipientInfo);

var _RecipientEncryptedKeys = require(&quot;./RecipientEncryptedKeys.js&quot;);

var _RecipientEncryptedKeys2 = _interopRequireDefault(_RecipientEncryptedKeys);

var _KEKRecipientInfo = require(&quot;./KEKRecipientInfo.js&quot;);

var _KEKRecipientInfo2 = _interopRequireDefault(_KEKRecipientInfo);

var _KEKIdentifier = require(&quot;./KEKIdentifier.js&quot;);

var _KEKIdentifier2 = _interopRequireDefault(_KEKIdentifier);

var _PBKDF2Params = require(&quot;./PBKDF2Params.js&quot;);

var _PBKDF2Params2 = _interopRequireDefault(_PBKDF2Params);

var _PasswordRecipientinfo = require(&quot;./PasswordRecipientinfo.js&quot;);

var _PasswordRecipientinfo2 = _interopRequireDefault(_PasswordRecipientinfo);

var _ECCCMSSharedInfo = require(&quot;./ECCCMSSharedInfo.js&quot;);

var _ECCCMSSharedInfo2 = _interopRequireDefault(_ECCCMSSharedInfo);

var _OriginatorIdentifierOrKey = require(&quot;./OriginatorIdentifierOrKey.js&quot;);

var _OriginatorIdentifierOrKey2 = _interopRequireDefault(_OriginatorIdentifierOrKey);

var _OriginatorPublicKey = require(&quot;./OriginatorPublicKey.js&quot;);

var _OriginatorPublicKey2 = _interopRequireDefault(_OriginatorPublicKey);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//**************************************************************************************
/**
 * Class from RFC5652
 */
class EnvelopedData {
	//**********************************************************************************
	/**
  * Constructor for EnvelopedData class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {number}
   * @description version
   */
		this.version = (0, _pvutils.getParametersValue)(parameters, &quot;version&quot;, EnvelopedData.defaultValues(&quot;version&quot;));

		if (&quot;originatorInfo&quot; in parameters)
			/**
    * @type {OriginatorInfo}
    * @description originatorInfo
    */
			this.originatorInfo = (0, _pvutils.getParametersValue)(parameters, &quot;originatorInfo&quot;, EnvelopedData.defaultValues(&quot;originatorInfo&quot;));

		/**
   * @type {Array.&lt;RecipientInfo&gt;}
   * @description recipientInfos
   */
		this.recipientInfos = (0, _pvutils.getParametersValue)(parameters, &quot;recipientInfos&quot;, EnvelopedData.defaultValues(&quot;recipientInfos&quot;));
		/**
   * @type {EncryptedContentInfo}
   * @description encryptedContentInfo
   */
		this.encryptedContentInfo = (0, _pvutils.getParametersValue)(parameters, &quot;encryptedContentInfo&quot;, EnvelopedData.defaultValues(&quot;encryptedContentInfo&quot;));

		if (&quot;unprotectedAttrs&quot; in parameters)
			/**
    * @type {Array.&lt;Attribute&gt;}
    * @description unprotectedAttrs
    */
			this.unprotectedAttrs = (0, _pvutils.getParametersValue)(parameters, &quot;unprotectedAttrs&quot;, EnvelopedData.defaultValues(&quot;unprotectedAttrs&quot;));
		//endregion

		//region If input argument array contains &quot;schema&quot; for this object
		if (&quot;schema&quot; in parameters) this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	static defaultValues(memberName) {
		switch (memberName) {
			case &quot;version&quot;:
				return 0;
			case &quot;originatorInfo&quot;:
				return new _OriginatorInfo2.default();
			case &quot;recipientInfos&quot;:
				return [];
			case &quot;encryptedContentInfo&quot;:
				return new _EncryptedContentInfo2.default();
			case &quot;unprotectedAttrs&quot;:
				return [];
			default:
				throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Compare values with default values for all class members
  * @param {string} memberName String name for a class member
  * @param {*} memberValue Value to compare with default value
  */
	static compareWithDefault(memberName, memberValue) {
		switch (memberName) {
			case &quot;version&quot;:
				return memberValue === EnvelopedData.defaultValues(memberName);
			case &quot;originatorInfo&quot;:
				return memberValue.certs.certificates.length === 0 &amp;&amp; memberValue.crls.crls.length === 0;
			case &quot;recipientInfos&quot;:
			case &quot;unprotectedAttrs&quot;:
				return memberValue.length === 0;
			case &quot;encryptedContentInfo&quot;:
				return _EncryptedContentInfo2.default.compareWithDefault(&quot;contentType&quot;, memberValue.contentType) &amp;&amp; _EncryptedContentInfo2.default.compareWithDefault(&quot;contentEncryptionAlgorithm&quot;, memberValue.contentEncryptionAlgorithm) &amp;&amp; _EncryptedContentInfo2.default.compareWithDefault(&quot;encryptedContent&quot;, memberValue.encryptedContent);
			default:
				throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
  * Return value of asn1js schema for current class
  * @param {Object} parameters Input parameters for the schema
  * @returns {Object} asn1js schema object
  */
	static schema(parameters = {}) {
		//EnvelopedData ::= SEQUENCE {
		//    version CMSVersion,
		//    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
		//    recipientInfos RecipientInfos,
		//    encryptedContentInfo EncryptedContentInfo,
		//    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }

		/**
   * @type {Object}
   * @property {string} [blockName]
   * @property {string} [version]
   * @property {string} [originatorInfo]
   * @property {string} [recipientInfos]
   * @property {string} [encryptedContentInfo]
   * @property {string} [unprotectedAttrs]
   */
		const names = (0, _pvutils.getParametersValue)(parameters, &quot;names&quot;, {});

		return new asn1js.Sequence({
			name: names.blockName || &quot;&quot;,
			value: [new asn1js.Integer({ name: names.version || &quot;&quot; }), new asn1js.Constructed({
				name: names.originatorInfo || &quot;&quot;,
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: _OriginatorInfo2.default.schema().valueBlock.value
			}), new asn1js.Set({
				value: [new asn1js.Repeated({
					name: names.recipientInfos || &quot;&quot;,
					value: _RecipientInfo2.default.schema()
				})]
			}), _EncryptedContentInfo2.default.schema(names.encryptedContentInfo || {}), new asn1js.Constructed({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [new asn1js.Repeated({
					name: names.unprotectedAttrs || &quot;&quot;,
					value: _Attribute2.default.schema()
				})]
			})]
		});
	}
	//**********************************************************************************
	/**
  * Convert parsed asn1js object into current class
  * @param {!Object} schema
  */
	fromSchema(schema) {
		//region Clear input data first
		(0, _pvutils.clearProps)(schema, [&quot;version&quot;, &quot;originatorInfo&quot;, &quot;recipientInfos&quot;, &quot;encryptedContentInfo&quot;, &quot;unprotectedAttrs&quot;]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js.compareSchema(schema, schema, EnvelopedData.schema({
			names: {
				version: &quot;version&quot;,
				originatorInfo: &quot;originatorInfo&quot;,
				recipientInfos: &quot;recipientInfos&quot;,
				encryptedContentInfo: {
					names: {
						blockName: &quot;encryptedContentInfo&quot;
					}
				},
				unprotectedAttrs: &quot;unprotectedAttrs&quot;
			}
		}));

		if (asn1.verified === false) throw new Error(&quot;Object&#039;s schema was not verified against input data for EnvelopedData&quot;);
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;

		if (&quot;originatorInfo&quot; in asn1.result) {
			this.originatorInfo = new _OriginatorInfo2.default({
				schema: new asn1js.Sequence({
					value: asn1.result.originatorInfo.valueBlock.value
				})
			});
		}

		this.recipientInfos = Array.from(asn1.result.recipientInfos, element =&gt; new _RecipientInfo2.default({ schema: element }));
		this.encryptedContentInfo = new _EncryptedContentInfo2.default({ schema: asn1.result.encryptedContentInfo });

		if (&quot;unprotectedAttrs&quot; in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element =&gt; new _Attribute2.default({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
  * Convert current object to asn1js object and set correct values
  * @returns {Object} asn1js object
  */
	toSchema() {
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js.Integer({ value: this.version }));

		if (&quot;originatorInfo&quot; in this) {
			outputArray.push(new asn1js.Constructed({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: this.originatorInfo.toSchema().valueBlock.value
			}));
		}

		outputArray.push(new asn1js.Set({
			value: Array.from(this.recipientInfos, element =&gt; element.toSchema())
		}));

		outputArray.push(this.encryptedContentInfo.toSchema());

		if (&quot;unprotectedAttrs&quot; in this) {
			outputArray.push(new asn1js.Constructed({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.unprotectedAttrs, element =&gt; element.toSchema())
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return new asn1js.Sequence({
			value: outputArray
		});
		//endregion
	}
	//**********************************************************************************
	/**
  * Convertion for the class to JSON object
  * @returns {Object}
  */
	toJSON() {
		const _object = {
			version: this.version
		};

		if (&quot;originatorInfo&quot; in this) _object.originatorInfo = this.originatorInfo.toJSON();

		_object.recipientInfos = Array.from(this.recipientInfos, element =&gt; element.toJSON());
		_object.encryptedContentInfo = this.encryptedContentInfo.toJSON();

		if (&quot;unprotectedAttrs&quot; in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element =&gt; element.toJSON());

		return _object;
	}
	//**********************************************************************************
	/**
  * Helpers function for filling &quot;RecipientInfo&quot; based on recipient&#039;s certificate.
  * Problem with WebCrypto is that for RSA certificates we have only one option - &quot;key transport&quot; and
  * for ECC certificates we also have one option - &quot;key agreement&quot;. As soon as Google will implement
  * DH algorithm it would be possible to use &quot;key agreement&quot; also for RSA certificates.
  * @param {Certificate} [certificate] Recipient&#039;s certificate
  * @param {Object} [parameters] Additional parameters neccessary for &quot;fine tunning&quot; of encryption process
  * @param {number} [variant] Variant = 1 is for &quot;key transport&quot;, variant = 2 is for &quot;key agreement&quot;. In fact the &quot;variant&quot; is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: &quot;key transport&quot; for RSA and &quot;key agreement&quot; for ECC certificates.
  */
	addRecipientByCertificate(certificate, parameters, variant) {
		//region Initial variables 
		const encryptionParameters = parameters || {};
		//endregion 

		//region Check type of certificate
		if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(&quot;1.2.840.113549&quot;) !== -1) variant = 1; // For the moment it is the only variant for RSA-based certificates
		else {
				if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(&quot;1.2.840.10045&quot;) !== -1) variant = 2; // For the moment it is the only variant for ECC-based certificates
				else throw new Error(`Unknown type of certificate&#039;s public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
			}
		//endregion 

		//region Initialize encryption parameters 
		if (&quot;oaepHashAlgorithm&quot; in encryptionParameters === false) encryptionParameters.oaepHashAlgorithm = &quot;SHA-512&quot;;

		if (&quot;kdfAlgorithm&quot; in encryptionParameters === false) encryptionParameters.kdfAlgorithm = &quot;SHA-512&quot;;

		if (&quot;kekEncryptionLength&quot; in encryptionParameters === false) encryptionParameters.kekEncryptionLength = 256;
		//endregion 

		//region Add new &quot;recipient&quot; depends on &quot;variant&quot; and certificate type 
		switch (variant) {
			case 1:
				// Key transport scheme
				{
					//region keyEncryptionAlgorithm
					const oaepOID = (0, _common.getOIDByAlgorithm)({
						name: &quot;RSA-OAEP&quot;
					});
					if (oaepOID === &quot;&quot;) throw new Error(&quot;Can not find OID for OAEP&quot;);
					//endregion

					//region RSAES-OAEP-params
					const hashOID = (0, _common.getOIDByAlgorithm)({
						name: encryptionParameters.oaepHashAlgorithm
					});
					if (hashOID === &quot;&quot;) throw new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);

					const hashAlgorithm = new _AlgorithmIdentifier2.default({
						algorithmId: hashOID,
						algorithmParams: new asn1js.Null()
					});

					const rsaOAEPParams = new _RSAESOAEPParams2.default({
						hashAlgorithm,
						maskGenAlgorithm: new _AlgorithmIdentifier2.default({
							algorithmId: &quot;1.2.840.113549.1.1.8&quot;, // id-mgf1
							algorithmParams: hashAlgorithm.toSchema()
						})
					});
					//endregion

					//region KeyTransRecipientInfo
					const keyInfo = new _KeyTransRecipientInfo2.default({
						version: 0,
						rid: new _IssuerAndSerialNumber2.default({
							issuer: certificate.issuer,
							serialNumber: certificate.serialNumber
						}),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier2.default({
							algorithmId: oaepOID,
							algorithmParams: rsaOAEPParams.toSchema()
						}),
						recipientCertificate: certificate
						// &quot;encryptedKey&quot; will be calculated in &quot;encrypt&quot; function
					});
					//endregion

					//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new _RecipientInfo2.default({
						variant: 1,
						value: keyInfo
					}));
					//endregion
				}
				break;
			case 2:
				// Key agreement scheme
				{
					//region RecipientEncryptedKey
					const encryptedKey = new _RecipientEncryptedKey2.default({
						rid: new _KeyAgreeRecipientIdentifier2.default({
							variant: 1,
							value: new _IssuerAndSerialNumber2.default({
								issuer: certificate.issuer,
								serialNumber: certificate.serialNumber
							})
						})
						// &quot;encryptedKey&quot; will be calculated in &quot;encrypt&quot; function
					});
					//endregion

					//region keyEncryptionAlgorithm
					const aesKWoid = (0, _common.getOIDByAlgorithm)({
						name: &quot;AES-KW&quot;,
						length: encryptionParameters.kekEncryptionLength
					});
					if (aesKWoid === &quot;&quot;) throw new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);

					const aesKW = new _AlgorithmIdentifier2.default({
						algorithmId: aesKWoid,
						algorithmParams: new asn1js.Null()
					});
					//endregion

					//region KeyAgreeRecipientInfo
					const ecdhOID = (0, _common.getOIDByAlgorithm)({
						name: &quot;ECDH&quot;,
						kdf: encryptionParameters.kdfAlgorithm
					});
					if (ecdhOID === &quot;&quot;) throw new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`);

					// In fact there is no need in so long UKM, but RFC2631
					// has requirement that &quot;UserKeyMaterial&quot; must be 512 bits long
					const ukmBuffer = new ArrayBuffer(64);
					const ukmView = new Uint8Array(ukmBuffer);
					(0, _common.getRandomValues)(ukmView); // Generate random values in 64 bytes long buffer

					const keyInfo = new _KeyAgreeRecipientInfo2.default({
						version: 3,
						// &quot;originator&quot; will be calculated in &quot;encrypt&quot; function because ephemeral key would be generated there
						ukm: new asn1js.OctetString({ valueHex: ukmBuffer }),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier2.default({
							algorithmId: ecdhOID,
							algorithmParams: aesKW.toSchema()
						}),
						recipientEncryptedKeys: new _RecipientEncryptedKeys2.default({
							encryptedKeys: [encryptedKey]
						}),
						recipientCertificate: certificate
					});
					//endregion

					//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new _RecipientInfo2.default({
						variant: 2,
						value: keyInfo
					}));
					//endregion
				}
				break;
			default:
				throw new Error(`Unknown &quot;variant&quot; value: ${variant}`);
		}
		//endregion 

		return true;
	}
	//**********************************************************************************
	/**
  * Add recipient based on pre-defined data like password or KEK
  * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data
  * @param {Object} parameters Additional parameters neccessary for &quot;fine tunning&quot; of encryption process
  * @param {number} variant Variant = 1 for pre-defined &quot;key encryption key&quot; (KEK). Variant = 2 for password-based encryption.
  */
	addRecipientByPreDefinedData(preDefinedData, parameters, variant) {
		//region Initial variables
		const encryptionParameters = parameters || {};
		//endregion

		//region Check initial parameters
		if (preDefinedData instanceof ArrayBuffer === false) throw new Error(&quot;Please pass \&quot;preDefinedData\&quot; in ArrayBuffer type&quot;);

		if (preDefinedData.byteLength === 0) throw new Error(&quot;Pre-defined data could have zero length&quot;);
		//endregion

		//region Initialize encryption parameters
		if (&quot;keyIdentifier&quot; in encryptionParameters === false) {
			const keyIdentifierBuffer = new ArrayBuffer(16);
			const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
			(0, _common.getRandomValues)(keyIdentifierView);

			encryptionParameters.keyIdentifier = keyIdentifierBuffer;
		}

		if (&quot;hmacHashAlgorithm&quot; in encryptionParameters === false) encryptionParameters.hmacHashAlgorithm = &quot;SHA-512&quot;;

		if (&quot;iterationCount&quot; in encryptionParameters === false) encryptionParameters.iterationCount = 2048;

		if (&quot;keyEncryptionAlgorithm&quot; in encryptionParameters === false) {
			encryptionParameters.keyEncryptionAlgorithm = {
				name: &quot;AES-KW&quot;,
				length: 256
			};
		}

		if (&quot;keyEncryptionAlgorithmParams&quot; in encryptionParameters === false) encryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null();
		//endregion

		//region Add new recipient based on passed variant
		switch (variant) {
			case 1:
				// KEKRecipientInfo
				{
					//region keyEncryptionAlgorithm
					const kekOID = (0, _common.getOIDByAlgorithm)(encryptionParameters.keyEncryptionAlgorithm);
					if (kekOID === &quot;&quot;) throw new Error(&quot;Incorrect value for \&quot;keyEncryptionAlgorithm\&quot;&quot;);
					//endregion

					//region KEKRecipientInfo
					const keyInfo = new _KEKRecipientInfo2.default({
						version: 4,
						kekid: new _KEKIdentifier2.default({
							keyIdentifier: new asn1js.OctetString({ valueHex: encryptionParameters.keyIdentifier })
						}),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier2.default({
							algorithmId: kekOID,
							/*
        For AES-KW params are NULL, but for other algorithm could another situation.
        */
							algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
						}),
						preDefinedKEK: preDefinedData
						// &quot;encryptedKey&quot; would be set in &quot;ecrypt&quot; function
					});
					//endregion

					//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new _RecipientInfo2.default({
						variant: 3,
						value: keyInfo
					}));
					//endregion
				}
				break;
			case 2:
				// PasswordRecipientinfo
				{
					//region keyDerivationAlgorithm
					const pbkdf2OID = (0, _common.getOIDByAlgorithm)({
						name: &quot;PBKDF2&quot;
					});
					if (pbkdf2OID === &quot;&quot;) throw new Error(&quot;Can not find OID for PBKDF2&quot;);
					//endregion

					//region Salt
					const saltBuffer = new ArrayBuffer(64);
					const saltView = new Uint8Array(saltBuffer);
					(0, _common.getRandomValues)(saltView);
					//endregion

					//region HMAC-based algorithm
					const hmacOID = (0, _common.getOIDByAlgorithm)({
						name: &quot;HMAC&quot;,
						hash: {
							name: encryptionParameters.hmacHashAlgorithm
						}
					});
					if (hmacOID === &quot;&quot;) throw new Error(`Incorrect value for &quot;hmacHashAlgorithm&quot;: ${encryptionParameters.hmacHashAlgorithm}`);
					//endregion

					//region PBKDF2-params
					const pbkdf2Params = new _PBKDF2Params2.default({
						salt: new asn1js.OctetString({ valueHex: saltBuffer }),
						iterationCount: encryptionParameters.iterationCount,
						prf: new _AlgorithmIdentifier2.default({
							algorithmId: hmacOID,
							algorithmParams: new asn1js.Null()
						})
					});
					//endregion

					//region keyEncryptionAlgorithm
					const kekOID = (0, _common.getOIDByAlgorithm)(encryptionParameters.keyEncryptionAlgorithm);
					if (kekOID === &quot;&quot;) throw new Error(&quot;Incorrect value for \&quot;keyEncryptionAlgorithm\&quot;&quot;);
					//endregion

					//region PasswordRecipientinfo
					const keyInfo = new _PasswordRecipientinfo2.default({
						version: 0,
						keyDerivationAlgorithm: new _AlgorithmIdentifier2.default({
							algorithmId: pbkdf2OID,
							algorithmParams: pbkdf2Params.toSchema()
						}),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier2.default({
							algorithmId: kekOID,
							/*
        For AES-KW params are NULL, but for other algorithm could be another situation.
        */
							algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
						}),
						password: preDefinedData
						// &quot;encryptedKey&quot; would be set in &quot;ecrypt&quot; function
					});
					//endregion

					//region Final values for &quot;CMS_ENVELOPED_DATA&quot;
					this.recipientInfos.push(new _RecipientInfo2.default({
						variant: 4,
						value: keyInfo
					}));
					//endregion
				}
				break;
			default:
				throw new Error(`Unknown value for &quot;variant&quot;: ${variant}`);
		}
		//endregion
	}
	//**********************************************************************************
	/**
  * Create a new CMS Enveloped Data content with encrypted data
  * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only &quot;AES-CBC&quot; or &quot;AES-GCM&quot; algorithms.
  * @param {ArrayBuffer} contentToEncrypt Content to encrypt
  * @returns {Promise}
  */
	encrypt(contentEncryptionAlgorithm, contentToEncrypt) {
		//region Initial variables
		let sequence = Promise.resolve();

		const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
		const ivView = new Uint8Array(ivBuffer);
		(0, _common.getRandomValues)(ivView);

		const contentView = new Uint8Array(contentToEncrypt);

		let sessionKey;
		let encryptedContent;
		let exportedSessionKey;

		const recipientsPromises = [];

		const _this = this;
		//endregion

		//region Check for input parameters
		const contentEncryptionOID = (0, _common.getOIDByAlgorithm)(contentEncryptionAlgorithm);
		if (contentEncryptionOID === &quot;&quot;) return Promise.reject(&quot;Wrong \&quot;contentEncryptionAlgorithm\&quot; value&quot;);
		//endregion

		//region Get a &quot;crypto&quot; extension
		const crypto = (0, _common.getCrypto)();
		if (typeof crypto === &quot;undefined&quot;) return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion

		//region Generate new content encryption key
		sequence = sequence.then(() =&gt; crypto.generateKey(contentEncryptionAlgorithm, true, [&quot;encrypt&quot;]));
		//endregion
		//region Encrypt content
		sequence = sequence.then(result =&gt; {
			sessionKey = result;

			return crypto.encrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			}, sessionKey, contentView);
		}, error =&gt; Promise.reject(error));
		//endregion
		//region Export raw content of content encryption key
		sequence = sequence.then(result =&gt; {
			//region Create output OCTETSTRING with encrypted content
			encryptedContent = result;
			//endregion

			return crypto.exportKey(&quot;raw&quot;, sessionKey);
		}, error =&gt; Promise.reject(error)).then(result =&gt; {
			exportedSessionKey = result;

			return true;
		}, error =&gt; Promise.reject(error));
		//endregion
		//region Append common information to CMS_ENVELOPED_DATA
		sequence = sequence.then(() =&gt; {
			this.version = 2;
			this.encryptedContentInfo = new _EncryptedContentInfo2.default({
				contentType: &quot;1.2.840.113549.1.7.1&quot;, // &quot;data&quot;
				contentEncryptionAlgorithm: new _AlgorithmIdentifier2.default({
					algorithmId: contentEncryptionOID,
					algorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })
				}),
				encryptedContent: new asn1js.OctetString({ valueHex: encryptedContent })
			});
		}, error =&gt; Promise.reject(error));
		//endregion

		//region Special sub-functions to work with each recipient&#039;s type
		function SubKeyAgreeRecipientInfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();

			let ecdhPublicKey;
			let ecdhPrivateKey;

			let recipientCurve;
			let recipientCurveLength;

			let exportedECDHPublicKey;
			//endregion

			//region Get &quot;namedCurve&quot; parameter from recipient&#039;s certificate
			currentSequence = currentSequence.then(() =&gt; {
				const curveObject = _this.recipientInfos[index].value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;

				if (curveObject instanceof asn1js.ObjectIdentifier === false) return Promise.reject(`Incorrect &quot;recipientCertificate&quot; for index ${index}`);

				const curveOID = curveObject.valueBlock.toString();

				switch (curveOID) {
					case &quot;1.2.840.10045.3.1.7&quot;:
						recipientCurve = &quot;P-256&quot;;
						recipientCurveLength = 256;
						break;
					case &quot;1.3.132.0.34&quot;:
						recipientCurve = &quot;P-384&quot;;
						recipientCurveLength = 384;
						break;
					case &quot;1.3.132.0.35&quot;:
						recipientCurve = &quot;P-521&quot;;
						recipientCurveLength = 528;
						break;
					default:
						return Promise.reject(`Incorrect curve OID for index ${index}`);
				}

				return recipientCurve;
			}, error =&gt; Promise.reject(error));
			//endregion

			//region Generate ephemeral ECDH key
			currentSequence = currentSequence.then(result =&gt; crypto.generateKey({
				name: &quot;ECDH&quot;,
				namedCurve: result
			}, true, [&quot;deriveBits&quot;]), error =&gt; Promise.reject(error));
			//endregion
			//region Export public key of ephemeral ECDH key pair
			currentSequence = currentSequence.then(result =&gt; {
				ecdhPublicKey = result.publicKey;
				ecdhPrivateKey = result.privateKey;

				return crypto.exportKey(&quot;spki&quot;, ecdhPublicKey);
			}, error =&gt; Promise.reject(error));
			//endregion

			//region Import recipient&#039;s public key
			currentSequence = currentSequence.then(result =&gt; {
				exportedECDHPublicKey = result;

				return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
					algorithm: {
						algorithm: {
							name: &quot;ECDH&quot;,
							namedCurve: recipientCurve
						},
						usages: []
					}
				});
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Create shared secret
			currentSequence = currentSequence.then(result =&gt; crypto.deriveBits({
				name: &quot;ECDH&quot;,
				public: result
			}, ecdhPrivateKey, recipientCurveLength), error =&gt; Promise.reject(error));
			//endregion

			//region Apply KDF function to shared secret
			currentSequence = currentSequence.then(
			/**
    * @param {ArrayBuffer} result
    */
			result =&gt; {
				//region Get length of used AES-KW algorithm
				const aesKWAlgorithm = new _AlgorithmIdentifier2.default({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });

				const KWalgorithm = (0, _common.getAlgorithmByOID)(aesKWAlgorithm.algorithmId);
				if (&quot;name&quot; in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
				//endregion

				//region Translate AES-KW length to ArrayBuffer
				let kwLength = KWalgorithm.length;

				const kwLengthBuffer = new ArrayBuffer(4);
				const kwLengthView = new Uint8Array(kwLengthBuffer);

				for (let j = 3; j &gt;= 0; j--) {
					kwLengthView[j] = kwLength;
					kwLength &gt;&gt;= 8;
				}
				//endregion

				//region Create and encode &quot;ECC-CMS-SharedInfo&quot; structure
				const eccInfo = new _ECCCMSSharedInfo2.default({
					keyInfo: new _AlgorithmIdentifier2.default({
						algorithmId: aesKWAlgorithm.algorithmId,
						/*
       Initially RFC5753 says that AES algorithms have absent parameters.
       But since early implementations all put NULL here. Thus, in order to be
       &quot;backward compatible&quot;, index also put NULL here.
       */
						algorithmParams: new asn1js.Null()
					}),
					entityUInfo: _this.recipientInfos[index].value.ukm,
					suppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })
				});

				const encodedInfo = eccInfo.toSchema().toBER(false);
				//endregion

				//region Get SHA algorithm used together with ECDH
				const ecdhAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				return (0, _common.kdf)(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Import AES-KW key from result of KDF function
			currentSequence = currentSequence.then(result =&gt; crypto.importKey(&quot;raw&quot;, result, { name: &quot;AES-KW&quot; }, true, [&quot;wrapKey&quot;]), error =&gt; Promise.reject(error));
			//endregion
			//region Finally wrap session key by using AES-KW algorithm
			currentSequence = currentSequence.then(result =&gt; crypto.wrapKey(&quot;raw&quot;, sessionKey, result, { name: &quot;AES-KW&quot; }), error =&gt; Promise.reject(error));
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt; {
				//region OriginatorIdentifierOrKey
				const asn1 = asn1js.fromBER(exportedECDHPublicKey);

				const originator = new _OriginatorIdentifierOrKey2.default();
				originator.variant = 3;
				originator.value = new _OriginatorPublicKey2.default({ schema: asn1.result });
				// There is option when we can stay with ECParameters, but here index prefer to avoid the params
				if (&quot;algorithmParams&quot; in originator.value.algorithm) delete originator.value.algorithm.algorithmParams;

				_this.recipientInfos[index].value.originator = originator;
				//endregion

				//region RecipientEncryptedKey
				/*
     We will not support using of same ephemeral key for many recipients
     */
				_this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		function SubKeyTransRecipientInfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion

			//region Get recipient&#039;s public key
			currentSequence = currentSequence.then(() =&gt; {
				//region Get current used SHA algorithm
				const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
				const rsaOAEPParams = new _RSAESOAEPParams2.default({ schema });

				const hashAlgorithm = (0, _common.getAlgorithmByOID)(rsaOAEPParams.hashAlgorithm.algorithmId);
				if (&quot;name&quot; in hashAlgorithm === false) return Promise.reject(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
				//endregion

				return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
					algorithm: {
						algorithm: {
							name: &quot;RSA-OAEP&quot;,
							hash: {
								name: hashAlgorithm.name
							}
						},
						usages: [&quot;encrypt&quot;, &quot;wrapKey&quot;]
					}
				});
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Encrypt early exported session key on recipient&#039;s public key
			currentSequence = currentSequence.then(result =&gt; crypto.encrypt(result.algorithm, result, exportedSessionKey), error =&gt; Promise.reject(error));
			//endregion

			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt; {
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		function SubKEKRecipientInfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();
			let kekAlgorithm;
			//endregion

			//region Import KEK from pre-defined data
			currentSequence = currentSequence.then(() =&gt; {
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in kekAlgorithm === false) return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.importKey(&quot;raw&quot;, new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK), kekAlgorithm, true, [&quot;wrapKey&quot;]); // Too specific for AES-KW
			}, error =&gt; Promise.reject(error));
			//endregion

			//region Wrap previously exported session key
			currentSequence = currentSequence.then(result =&gt; crypto.wrapKey(&quot;raw&quot;, sessionKey, result, kekAlgorithm), error =&gt; Promise.reject(error));
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt; {
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		function SubPasswordRecipientinfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();
			let pbkdf2Params;
			let kekAlgorithm;
			//endregion

			//region Check that we have encoded &quot;keyDerivationAlgorithm&quot; plus &quot;PBKDF2_params&quot; in there
			currentSequence = currentSequence.then(() =&gt; {
				if (&quot;keyDerivationAlgorithm&quot; in _this.recipientInfos[index].value === false) return Promise.reject(&quot;Please append encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);

				if (&quot;algorithmParams&quot; in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);

				try {
					pbkdf2Params = new _PBKDF2Params2.default({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });
				} catch (ex) {
					return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
				}

				return Promise.resolve();
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Derive PBKDF2 key from &quot;password&quot; buffer
			currentSequence = currentSequence.then(() =&gt; {
				const passwordView = new Uint8Array(_this.recipientInfos[index].value.password);

				return crypto.importKey(&quot;raw&quot;, passwordView, &quot;PBKDF2&quot;, false, [&quot;deriveKey&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Derive key for &quot;keyEncryptionAlgorithm&quot;
			currentSequence = currentSequence.then(result =&gt; {
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in kekAlgorithm === false) return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				//region Get HMAC hash algorithm
				let hmacHashAlgorithm = &quot;SHA-1&quot;;

				if (&quot;prf&quot; in pbkdf2Params) {
					const algorithm = (0, _common.getAlgorithmByOID)(pbkdf2Params.prf.algorithmId);
					if (&quot;name&quot; in algorithm === false) return Promise.reject(&quot;Incorrect OID for HMAC hash algorithm&quot;);

					hmacHashAlgorithm = algorithm.hash.name;
				}
				//endregion

				//region Get PBKDF2 &quot;salt&quot; value
				const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
				//endregion

				//region Get PBKDF2 iterations count
				const iterations = pbkdf2Params.iterationCount;
				//endregion

				return crypto.deriveKey({
					name: &quot;PBKDF2&quot;,
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations
				}, result, kekAlgorithm, true, [&quot;wrapKey&quot;]); // Usages are too specific for KEK algorithm
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Wrap previously exported session key (Also too specific for KEK algorithm)
			currentSequence = currentSequence.then(result =&gt; crypto.wrapKey(&quot;raw&quot;, sessionKey, result, kekAlgorithm), error =&gt; Promise.reject(error));
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =&gt; {
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });
				//endregion
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		//endregion

		//region Create special routines for each &quot;recipient&quot;
		sequence = sequence.then(() =&gt; {
			for (let i = 0; i &lt; this.recipientInfos.length; i++) {
				//region Initial variables
				let currentSequence = Promise.resolve();
				//endregion

				switch (this.recipientInfos[i].variant) {
					case 1:
						// KeyTransRecipientInfo
						currentSequence = SubKeyTransRecipientInfo(i);
						break;
					case 2:
						// KeyAgreeRecipientInfo
						currentSequence = SubKeyAgreeRecipientInfo(i);
						break;
					case 3:
						// KEKRecipientInfo
						currentSequence = SubKEKRecipientInfo(i);
						break;
					case 4:
						// PasswordRecipientinfo
						currentSequence = SubPasswordRecipientinfo(i);
						break;
					default:
						return Promise.reject(`Uknown recipient type in array with index ${i}`);
				}

				recipientsPromises.push(currentSequence);
			}

			return Promise.all(recipientsPromises);
		}, error =&gt; Promise.reject(error));
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
  * Decrypt existing CMS Enveloped Data content
  * @param {number} recipientIndex Index of recipient
  * @param {Object} parameters Additional parameters
  * @returns {Promise}
  */
	decrypt(recipientIndex, parameters) {
		//region Initial variables
		let sequence = Promise.resolve();

		const decryptionParameters = parameters || {};

		const _this = this;
		//endregion

		//region Check for input parameters
		if (recipientIndex + 1 &gt; this.recipientInfos.length) return Promise.reject(`Maximum value for &quot;index&quot; is: ${this.recipientInfos.length - 1}`);
		//endregion

		//region Get a &quot;crypto&quot; extension
		const crypto = (0, _common.getCrypto)();
		if (typeof crypto === &quot;undefined&quot;) return Promise.reject(&quot;Unable to create WebCrypto object&quot;);
		//endregion

		//region Special sub-functions to work with each recipient&#039;s type
		function SubKeyAgreeRecipientInfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();

			let recipientCurve;
			let recipientCurveLength;

			let curveOID;

			let ecdhPrivateKey;
			//endregion

			//region Get &quot;namedCurve&quot; parameter from recipient&#039;s certificate
			currentSequence = currentSequence.then(() =&gt; {
				if (&quot;recipientCertificate&quot; in decryptionParameters === false) return Promise.reject(&quot;Parameter \&quot;recipientCertificate\&quot; is mandatory for \&quot;KeyAgreeRecipientInfo\&quot;&quot;);

				if (&quot;recipientPrivateKey&quot; in decryptionParameters === false) return Promise.reject(&quot;Parameter \&quot;recipientPrivateKey\&quot; is mandatory for \&quot;KeyAgreeRecipientInfo\&quot;&quot;);

				const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;

				if (curveObject instanceof asn1js.ObjectIdentifier === false) return Promise.reject(`Incorrect &quot;recipientCertificate&quot; for index ${index}`);

				curveOID = curveObject.valueBlock.toString();

				switch (curveOID) {
					case &quot;1.2.840.10045.3.1.7&quot;:
						recipientCurve = &quot;P-256&quot;;
						recipientCurveLength = 256;
						break;
					case &quot;1.3.132.0.34&quot;:
						recipientCurve = &quot;P-384&quot;;
						recipientCurveLength = 384;
						break;
					case &quot;1.3.132.0.35&quot;:
						recipientCurve = &quot;P-521&quot;;
						recipientCurveLength = 528;
						break;
					default:
						return Promise.reject(`Incorrect curve OID for index ${index}`);
				}

				return crypto.importKey(&quot;pkcs8&quot;, decryptionParameters.recipientPrivateKey, {
					name: &quot;ECDH&quot;,
					namedCurve: recipientCurve
				}, true, [&quot;deriveBits&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Import sender&#039;s ephemeral public key
			currentSequence = currentSequence.then(result =&gt; {
				ecdhPrivateKey = result;

				//region Change &quot;OriginatorPublicKey&quot; if &quot;curve&quot; parameter absent
				if (&quot;algorithmParams&quot; in _this.recipientInfos[index].value.originator.value.algorithm === false) _this.recipientInfos[index].value.originator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({ value: curveOID });
				//endregion

				//region Create ArrayBuffer with sender&#039;s public key
				const buffer = _this.recipientInfos[index].value.originator.value.toSchema().toBER(false);
				//endregion

				return crypto.importKey(&quot;spki&quot;, buffer, {
					name: &quot;ECDH&quot;,
					namedCurve: recipientCurve
				}, true, []);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Create shared secret
			currentSequence = currentSequence.then(result =&gt; crypto.deriveBits({
				name: &quot;ECDH&quot;,
				public: result
			}, ecdhPrivateKey, recipientCurveLength), error =&gt; Promise.reject(error));
			//endregion
			//region Apply KDF function to shared secret
			currentSequence = currentSequence.then(
			/**
    * @param {ArrayBuffer} result
    */
			result =&gt; {
				//region Get length of used AES-KW algorithm
				const aesKWAlgorithm = new _AlgorithmIdentifier2.default({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });

				const KWalgorithm = (0, _common.getAlgorithmByOID)(aesKWAlgorithm.algorithmId);
				if (&quot;name&quot; in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
				//endregion

				//region Translate AES-KW length to ArrayBuffer
				let kwLength = KWalgorithm.length;

				const kwLengthBuffer = new ArrayBuffer(4);
				const kwLengthView = new Uint8Array(kwLengthBuffer);

				for (let j = 3; j &gt;= 0; j--) {
					kwLengthView[j] = kwLength;
					kwLength &gt;&gt;= 8;
				}
				//endregion

				//region Create and encode &quot;ECC-CMS-SharedInfo&quot; structure
				const eccInfo = new _ECCCMSSharedInfo2.default({
					keyInfo: new _AlgorithmIdentifier2.default({
						algorithmId: aesKWAlgorithm.algorithmId,
						/*
       Initially RFC5753 says that AES algorithms have absent parameters.
       But since early implementations all put NULL here. Thus, in order to be
       &quot;backward compatible&quot;, index also put NULL here.
       */
						algorithmParams: new asn1js.Null()
					}),
					entityUInfo: _this.recipientInfos[index].value.ukm,
					suppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })
				});

				const encodedInfo = eccInfo.toSchema().toBER(false);
				//endregion

				//region Get SHA algorithm used together with ECDH
				const ecdhAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				return (0, _common.kdf)(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Import AES-KW key from result of KDF function
			currentSequence = currentSequence.then(result =&gt; crypto.importKey(&quot;raw&quot;, result, { name: &quot;AES-KW&quot; }, true, [&quot;unwrapKey&quot;]), error =&gt; Promise.reject(error));
			//endregion
			//region Finally unwrap session key
			currentSequence = currentSequence.then(result =&gt; {
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.unwrapKey(&quot;raw&quot;, _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex, result, { name: &quot;AES-KW&quot; }, contentEncryptionAlgorithm, true, [&quot;decrypt&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		function SubKeyTransRecipientInfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion

			//region Import recipient&#039;s private key
			currentSequence = currentSequence.then(() =&gt; {
				if (&quot;recipientPrivateKey&quot; in decryptionParameters === false) return Promise.reject(&quot;Parameter \&quot;recipientPrivateKey\&quot; is mandatory for \&quot;KeyTransRecipientInfo\&quot;&quot;);

				//region Get current used SHA algorithm
				const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
				const rsaOAEPParams = new _RSAESOAEPParams2.default({ schema });

				const hashAlgorithm = (0, _common.getAlgorithmByOID)(rsaOAEPParams.hashAlgorithm.algorithmId);
				if (&quot;name&quot; in hashAlgorithm === false) return Promise.reject(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
				//endregion

				return crypto.importKey(&quot;pkcs8&quot;, decryptionParameters.recipientPrivateKey, {
					name: &quot;RSA-OAEP&quot;,
					hash: {
						name: hashAlgorithm.name
					}
				}, true, [&quot;decrypt&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Decrypt encrypted session key
			currentSequence = currentSequence.then(result =&gt; crypto.decrypt(result.algorithm, result, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex), error =&gt; Promise.reject(error));
			//endregion
			//region Import decrypted session key
			currentSequence = currentSequence.then(result =&gt; {
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.importKey(&quot;raw&quot;, result, contentEncryptionAlgorithm, true, [&quot;decrypt&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		function SubKEKRecipientInfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();
			let kekAlgorithm;
			//endregion

			//region Import KEK from pre-defined data
			currentSequence = currentSequence.then(() =&gt; {
				if (&quot;preDefinedData&quot; in decryptionParameters === false) return Promise.reject(&quot;Parameter \&quot;preDefinedData\&quot; is mandatory for \&quot;KEKRecipientInfo\&quot;&quot;);

				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in kekAlgorithm === false) return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.importKey(&quot;raw&quot;, decryptionParameters.preDefinedData, kekAlgorithm, true, [&quot;unwrapKey&quot;]); // Too specific for AES-KW
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Unwrap previously exported session key
			currentSequence = currentSequence.then(result =&gt; {
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.unwrapKey(&quot;raw&quot;, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [&quot;decrypt&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		function SubPasswordRecipientinfo(index) {
			//region Initial variables
			let currentSequence = Promise.resolve();
			let pbkdf2Params;
			let kekAlgorithm;
			//endregion

			//region Derive PBKDF2 key from &quot;password&quot; buffer
			currentSequence = currentSequence.then(() =&gt; {
				if (&quot;preDefinedData&quot; in decryptionParameters === false) return Promise.reject(&quot;Parameter \&quot;preDefinedData\&quot; is mandatory for \&quot;KEKRecipientInfo\&quot;&quot;);

				if (&quot;keyDerivationAlgorithm&quot; in _this.recipientInfos[index].value === false) return Promise.reject(&quot;Please append encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);

				if (&quot;algorithmParams&quot; in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);

				try {
					pbkdf2Params = new _PBKDF2Params2.default({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });
				} catch (ex) {
					return Promise.reject(&quot;Incorrectly encoded \&quot;keyDerivationAlgorithm\&quot;&quot;);
				}

				return crypto.importKey(&quot;raw&quot;, decryptionParameters.preDefinedData, &quot;PBKDF2&quot;, false, [&quot;deriveKey&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Derive key for &quot;keyEncryptionAlgorithm&quot;
			currentSequence = currentSequence.then(result =&gt; {
				//region Get WebCrypto form of &quot;keyEncryptionAlgorithm&quot;
				kekAlgorithm = (0, _common.getAlgorithmByOID)(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in kekAlgorithm === false) return Promise.reject(`Incorrect OID for &quot;keyEncryptionAlgorithm&quot;: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				//region Get HMAC hash algorithm
				let hmacHashAlgorithm = &quot;SHA-1&quot;;

				if (&quot;prf&quot; in pbkdf2Params) {
					const algorithm = (0, _common.getAlgorithmByOID)(pbkdf2Params.prf.algorithmId);
					if (&quot;name&quot; in algorithm === false) return Promise.reject(&quot;Incorrect OID for HMAC hash algorithm&quot;);

					hmacHashAlgorithm = algorithm.hash.name;
				}
				//endregion

				//region Get PBKDF2 &quot;salt&quot; value
				const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
				//endregion

				//region Get PBKDF2 iterations count
				const iterations = pbkdf2Params.iterationCount;
				//endregion

				return crypto.deriveKey({
					name: &quot;PBKDF2&quot;,
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations
				}, result, kekAlgorithm, true, [&quot;unwrapKey&quot;]); // Usages are too specific for KEK algorithm
			}, error =&gt; Promise.reject(error));
			//endregion
			//region Unwrap previously exported session key
			currentSequence = currentSequence.then(result =&gt; {
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if (&quot;name&quot; in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.unwrapKey(&quot;raw&quot;, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [&quot;decrypt&quot;]);
			}, error =&gt; Promise.reject(error));
			//endregion

			return currentSequence;
		}

		//endregion

		//region Perform steps, specific to each type of session key encryption
		sequence = sequence.then(() =&gt; {
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion

			switch (this.recipientInfos[recipientIndex].variant) {
				case 1:
					// KeyTransRecipientInfo
					currentSequence = SubKeyTransRecipientInfo(recipientIndex);
					break;
				case 2:
					// KeyAgreeRecipientInfo
					currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);
					break;
				case 3:
					// KEKRecipientInfo
					currentSequence = SubKEKRecipientInfo(recipientIndex);
					break;
				case 4:
					// PasswordRecipientinfo
					currentSequence = SubPasswordRecipientinfo(recipientIndex);
					break;
				default:
					return Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);
			}

			return currentSequence;
		}, error =&gt; Promise.reject(error));
		//endregion

		//region Finally decrypt data by session key
		sequence = sequence.then(result =&gt; {
			//region Get WebCrypto form of content encryption algorithm
			const contentEncryptionAlgorithm = (0, _common.getAlgorithmByOID)(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
			if (&quot;name&quot; in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect &quot;contentEncryptionAlgorithm&quot;: ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
			//endregion

			//region Get &quot;intialization vector&quot; for content encryption algorithm
			const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
			const ivView = new Uint8Array(ivBuffer);
			//endregion

			//region Create correct data block for decryption
			let dataBuffer = new ArrayBuffer(0);

			if (this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.encryptedContentInfo.encryptedContent.valueBlock.value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						const content = _step.value;

						dataBuffer = (0, _pvutils.utilConcatBuf)(dataBuffer, content.valueBlock.valueHex);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}
			//endregion

			return crypto.decrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			}, result, dataBuffer);
		}, error =&gt; Promise.reject(error));
		//endregion

		return sequence;
	}
	//**********************************************************************************
}
exports.default = EnvelopedData; //**************************************************************************************
//# sourceMappingURL=EnvelopedData.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
