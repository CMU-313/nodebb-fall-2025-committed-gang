<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/webpack/lib/FlagDependencyExportsPlugin.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/webpack/lib/FlagDependencyExportsPlugin.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.76</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">424</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.68</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

&quot;use strict&quot;;

const asyncLib = require(&quot;neo-async&quot;);
const Queue = require(&quot;./util/Queue&quot;);

/** @typedef {import(&quot;./Compiler&quot;)} Compiler */
/** @typedef {import(&quot;./DependenciesBlock&quot;)} DependenciesBlock */
/** @typedef {import(&quot;./Dependency&quot;)} Dependency */
/** @typedef {import(&quot;./Dependency&quot;).ExportSpec} ExportSpec */
/** @typedef {import(&quot;./Dependency&quot;).ExportsSpec} ExportsSpec */
/** @typedef {import(&quot;./ExportsInfo&quot;)} ExportsInfo */
/** @typedef {import(&quot;./ExportsInfo&quot;).RestoreProvidedData} RestoreProvidedData */
/** @typedef {import(&quot;./Module&quot;)} Module */
/** @typedef {import(&quot;./Module&quot;).BuildInfo} BuildInfo */

const PLUGIN_NAME = &quot;FlagDependencyExportsPlugin&quot;;
const PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME}`;

class FlagDependencyExportsPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation =&gt; {
			const moduleGraph = compilation.moduleGraph;
			const cache = compilation.getCache(PLUGIN_NAME);
			compilation.hooks.finishModules.tapAsync(
				PLUGIN_NAME,
				(modules, callback) =&gt; {
					const logger = compilation.getLogger(PLUGIN_LOGGER_NAME);
					let statRestoredFromMemCache = 0;
					let statRestoredFromCache = 0;
					let statNoExports = 0;
					let statFlaggedUncached = 0;
					let statNotCached = 0;
					let statQueueItemsProcessed = 0;

					const { moduleMemCaches } = compilation;

					/** @type {Queue&lt;Module&gt;} */
					const queue = new Queue();

					// Step 1: Try to restore cached provided export info from cache
					logger.time(&quot;restore cached provided exports&quot;);
					asyncLib.each(
						modules,
						(module, callback) =&gt; {
							const exportsInfo = moduleGraph.getExportsInfo(module);
							// If the module doesn&#039;t have an exportsType, it&#039;s a module
							// without declared exports.
							if (
								(!module.buildMeta || !module.buildMeta.exportsType) &amp;&amp;
								exportsInfo.otherExportsInfo.provided !== null
							) {
								// It&#039;s a module without declared exports
								statNoExports++;
								exportsInfo.setHasProvideInfo();
								exportsInfo.setUnknownExportsProvided();
								return callback();
							}
							// If the module has no hash, it&#039;s uncacheable
							if (
								typeof (/** @type {BuildInfo} */ (module.buildInfo).hash) !==
								&quot;string&quot;
							) {
								statFlaggedUncached++;
								// Enqueue uncacheable module for determining the exports
								queue.enqueue(module);
								exportsInfo.setHasProvideInfo();
								return callback();
							}
							const memCache = moduleMemCaches &amp;&amp; moduleMemCaches.get(module);
							const memCacheValue = memCache &amp;&amp; memCache.get(this);
							if (memCacheValue !== undefined) {
								statRestoredFromMemCache++;
								exportsInfo.restoreProvided(memCacheValue);
								return callback();
							}
							cache.get(
								module.identifier(),
								/** @type {BuildInfo} */
								(module.buildInfo).hash,
								(err, result) =&gt; {
									if (err) return callback(err);

									if (result !== undefined) {
										statRestoredFromCache++;
										exportsInfo.restoreProvided(result);
									} else {
										statNotCached++;
										// Without cached info enqueue module for determining the exports
										queue.enqueue(module);
										exportsInfo.setHasProvideInfo();
									}
									callback();
								}
							);
						},
						err =&gt; {
							logger.timeEnd(&quot;restore cached provided exports&quot;);
							if (err) return callback(err);

							/** @type {Set&lt;Module&gt;} */
							const modulesToStore = new Set();

							/** @type {Map&lt;Module, Set&lt;Module&gt;&gt;} */
							const dependencies = new Map();

							/** @type {Module} */
							let module;

							/** @type {ExportsInfo} */
							let exportsInfo;

							/** @type {Map&lt;Dependency, ExportsSpec&gt;} */
							const exportsSpecsFromDependencies = new Map();

							let cacheable = true;
							let changed = false;

							/**
							 * @param {DependenciesBlock} depBlock the dependencies block
							 * @returns {void}
							 */
							const processDependenciesBlock = depBlock =&gt; {
								for (const dep of depBlock.dependencies) {
									processDependency(dep);
								}
								for (const block of depBlock.blocks) {
									processDependenciesBlock(block);
								}
							};

							/**
							 * @param {Dependency} dep the dependency
							 * @returns {void}
							 */
							const processDependency = dep =&gt; {
								const exportDesc = dep.getExports(moduleGraph);
								if (!exportDesc) return;
								exportsSpecsFromDependencies.set(dep, exportDesc);
							};

							/**
							 * @param {Dependency} dep dependency
							 * @param {ExportsSpec} exportDesc info
							 * @returns {void}
							 */
							const processExportsSpec = (dep, exportDesc) =&gt; {
								const exports = exportDesc.exports;
								const globalCanMangle = exportDesc.canMangle;
								const globalFrom = exportDesc.from;
								const globalPriority = exportDesc.priority;
								const globalTerminalBinding =
									exportDesc.terminalBinding || false;
								const exportDeps = exportDesc.dependencies;
								if (exportDesc.hideExports) {
									for (const name of exportDesc.hideExports) {
										const exportInfo = exportsInfo.getExportInfo(name);
										exportInfo.unsetTarget(dep);
									}
								}
								if (exports === true) {
									// unknown exports
									if (
										exportsInfo.setUnknownExportsProvided(
											globalCanMangle,
											exportDesc.excludeExports,
											globalFrom &amp;&amp; dep,
											globalFrom,
											globalPriority
										)
									) {
										changed = true;
									}
								} else if (Array.isArray(exports)) {
									/**
									 * merge in new exports
									 * @param {ExportsInfo} exportsInfo own exports info
									 * @param {(ExportSpec | string)[]} exports list of exports
									 */
									const mergeExports = (exportsInfo, exports) =&gt; {
										for (const exportNameOrSpec of exports) {
											let name;
											let canMangle = globalCanMangle;
											let terminalBinding = globalTerminalBinding;
											let exports;
											let from = globalFrom;
											let fromExport;
											let priority = globalPriority;
											let hidden = false;
											if (typeof exportNameOrSpec === &quot;string&quot;) {
												name = exportNameOrSpec;
											} else {
												name = exportNameOrSpec.name;
												if (exportNameOrSpec.canMangle !== undefined)
													canMangle = exportNameOrSpec.canMangle;
												if (exportNameOrSpec.export !== undefined)
													fromExport = exportNameOrSpec.export;
												if (exportNameOrSpec.exports !== undefined)
													exports = exportNameOrSpec.exports;
												if (exportNameOrSpec.from !== undefined)
													from = exportNameOrSpec.from;
												if (exportNameOrSpec.priority !== undefined)
													priority = exportNameOrSpec.priority;
												if (exportNameOrSpec.terminalBinding !== undefined)
													terminalBinding = exportNameOrSpec.terminalBinding;
												if (exportNameOrSpec.hidden !== undefined)
													hidden = exportNameOrSpec.hidden;
											}
											const exportInfo = exportsInfo.getExportInfo(name);

											if (
												exportInfo.provided === false ||
												exportInfo.provided === null
											) {
												exportInfo.provided = true;
												changed = true;
											}

											if (
												exportInfo.canMangleProvide !== false &amp;&amp;
												canMangle === false
											) {
												exportInfo.canMangleProvide = false;
												changed = true;
											}

											if (terminalBinding &amp;&amp; !exportInfo.terminalBinding) {
												exportInfo.terminalBinding = true;
												changed = true;
											}

											if (exports) {
												const nestedExportsInfo =
													exportInfo.createNestedExportsInfo();
												mergeExports(
													/** @type {ExportsInfo} */ (nestedExportsInfo),
													exports
												);
											}

											if (
												from &amp;&amp;
												(hidden
													? exportInfo.unsetTarget(dep)
													: exportInfo.setTarget(
															dep,
															from,
															fromExport === undefined ? [name] : fromExport,
															priority
														))
											) {
												changed = true;
											}

											// Recalculate target exportsInfo
											const target = exportInfo.getTarget(moduleGraph);
											let targetExportsInfo;
											if (target) {
												const targetModuleExportsInfo =
													moduleGraph.getExportsInfo(target.module);
												targetExportsInfo =
													targetModuleExportsInfo.getNestedExportsInfo(
														target.export
													);
												// add dependency for this module
												const set = dependencies.get(target.module);
												if (set === undefined) {
													dependencies.set(target.module, new Set([module]));
												} else {
													set.add(module);
												}
											}

											if (exportInfo.exportsInfoOwned) {
												if (
													/** @type {ExportsInfo} */
													(exportInfo.exportsInfo).setRedirectNamedTo(
														targetExportsInfo
													)
												) {
													changed = true;
												}
											} else if (exportInfo.exportsInfo !== targetExportsInfo) {
												exportInfo.exportsInfo = targetExportsInfo;
												changed = true;
											}
										}
									};
									mergeExports(exportsInfo, exports);
								}
								// store dependencies
								if (exportDeps) {
									cacheable = false;
									for (const exportDependency of exportDeps) {
										// add dependency for this module
										const set = dependencies.get(exportDependency);
										if (set === undefined) {
											dependencies.set(exportDependency, new Set([module]));
										} else {
											set.add(module);
										}
									}
								}
							};

							const notifyDependencies = () =&gt; {
								const deps = dependencies.get(module);
								if (deps !== undefined) {
									for (const dep of deps) {
										queue.enqueue(dep);
									}
								}
							};

							logger.time(&quot;figure out provided exports&quot;);
							while (queue.length &gt; 0) {
								module = /** @type {Module} */ (queue.dequeue());

								statQueueItemsProcessed++;

								exportsInfo = moduleGraph.getExportsInfo(module);

								cacheable = true;
								changed = false;

								exportsSpecsFromDependencies.clear();
								moduleGraph.freeze();
								processDependenciesBlock(module);
								moduleGraph.unfreeze();
								for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {
									processExportsSpec(dep, exportsSpec);
								}

								if (cacheable) {
									modulesToStore.add(module);
								}

								if (changed) {
									notifyDependencies();
								}
							}
							logger.timeEnd(&quot;figure out provided exports&quot;);

							logger.log(
								`${Math.round(
									(100 * (statFlaggedUncached + statNotCached)) /
										(statRestoredFromMemCache +
											statRestoredFromCache +
											statNotCached +
											statFlaggedUncached +
											statNoExports)
								)}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${
									statQueueItemsProcessed - statNotCached - statFlaggedUncached
								} additional calculations due to dependencies)`
							);

							logger.time(&quot;store provided exports into cache&quot;);
							asyncLib.each(
								modulesToStore,
								(module, callback) =&gt; {
									if (
										typeof (
											/** @type {BuildInfo} */
											(module.buildInfo).hash
										) !== &quot;string&quot;
									) {
										// not cacheable
										return callback();
									}
									const cachedData = moduleGraph
										.getExportsInfo(module)
										.getRestoreProvidedData();
									const memCache =
										moduleMemCaches &amp;&amp; moduleMemCaches.get(module);
									if (memCache) {
										memCache.set(this, cachedData);
									}
									cache.store(
										module.identifier(),
										/** @type {BuildInfo} */
										(module.buildInfo).hash,
										cachedData,
										callback
									);
								},
								err =&gt; {
									logger.timeEnd(&quot;store provided exports into cache&quot;);
									callback(err);
								}
							);
						}
					);
				}
			);

			/** @type {WeakMap&lt;Module, RestoreProvidedData&gt;} */
			const providedExportsCache = new WeakMap();
			compilation.hooks.rebuildModule.tap(PLUGIN_NAME, module =&gt; {
				providedExportsCache.set(
					module,
					moduleGraph.getExportsInfo(module).getRestoreProvidedData()
				);
			});
			compilation.hooks.finishRebuildingModule.tap(PLUGIN_NAME, module =&gt; {
				moduleGraph.getExportsInfo(module).restoreProvided(
					/** @type {RestoreProvidedData} */
					(providedExportsCache.get(module))
				);
			});
		});
	}
}

module.exports = FlagDependencyExportsPlugin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
