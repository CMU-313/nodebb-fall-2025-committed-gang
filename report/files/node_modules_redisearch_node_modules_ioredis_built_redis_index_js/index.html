<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/redisearch/node_modules/ioredis/built/redis/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/redisearch/node_modules/ioredis/built/redis/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.70</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">755</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">78.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.34</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const lodash_1 = require(&quot;../utils/lodash&quot;);
const util_1 = require(&quot;util&quot;);
const events_1 = require(&quot;events&quot;);
const Deque = require(&quot;denque&quot;);
const command_1 = require(&quot;../command&quot;);
const commander_1 = require(&quot;../commander&quot;);
const utils_1 = require(&quot;../utils&quot;);
const standard_as_callback_1 = require(&quot;standard-as-callback&quot;);
const eventHandler = require(&quot;./event_handler&quot;);
const connectors_1 = require(&quot;../connectors&quot;);
const ScanStream_1 = require(&quot;../ScanStream&quot;);
const commands_1 = require(&quot;@ioredis/commands&quot;);
const PromiseContainer = require(&quot;../promiseContainer&quot;);
const transaction_1 = require(&quot;../transaction&quot;);
const RedisOptions_1 = require(&quot;./RedisOptions&quot;);
const debug = utils_1.Debug(&quot;redis&quot;);
/**
 * Creates a Redis instance
 *
 * @constructor
 * @param {(number|string|Object)} [port=6379] - Port of the Redis server,
 * or a URL string(see the examples below),
 * or the `options` object(see the third argument).
 * @param {string|Object} [host=localhost] - Host of the Redis server,
 * when the first argument is a URL string,
 * this argument is an object represents the options.
 * @param {Object} [options] - Other options.
 * @param {number} [options.port=6379] - Port of the Redis server.
 * @param {string} [options.host=localhost] - Host of the Redis server.
 * @param {string} [options.family=4] - Version of IP stack. Defaults to 4.
 * @param {string} [options.path=null] - Local domain socket path. If set the `port`,
 * `host` and `family` will be ignored.
 * @param {number} [options.keepAlive=0] - TCP KeepAlive on the socket with a X ms delay before start.
 * Set to a non-number value to disable keepAlive.
 * @param {boolean} [options.noDelay=true] - Whether to disable the Nagle&#039;s Algorithm. By default we disable
 * it to reduce the latency.
 * @param {string} [options.connectionName=null] - Connection name.
 * @param {number} [options.db=0] - Database index to use.
 * @param {string} [options.password=null] - If set, client will send AUTH command
 * with the value of this option when connected.
 * @param {string} [options.username=null] - Similar to `password`, Provide this for Redis ACL support.
 * @param {boolean} [options.dropBufferSupport=false] - Drop the buffer support for better performance.
 * This option is recommended to be enabled when
 * handling large array response and you don&#039;t need the buffer support.
 * @param {boolean} [options.enableReadyCheck=true] - When a connection is established to
 * the Redis server, the server might still be loading the database from disk.
 * While loading, the server not respond to any commands.
 * To work around this, when this option is `true`,
 * ioredis will check the status of the Redis server,
 * and when the Redis server is able to process commands,
 * a `ready` event will be emitted.
 * @param {boolean} [options.enableOfflineQueue=true] - By default,
 * if there is no active connection to the Redis server,
 * commands are added to a queue and are executed once the connection is &quot;ready&quot;
 * (when `enableReadyCheck` is `true`,
 * &quot;ready&quot; means the Redis server has loaded the database from disk, otherwise means the connection
 * to the Redis server has been established). If this option is false,
 * when execute the command when the connection isn&#039;t ready, an error will be returned.
 * @param {number} [options.connectTimeout=10000] - The milliseconds before a timeout occurs during the initial
 * connection to the Redis server.
 * @param {boolean} [options.autoResubscribe=true] - After reconnected, if the previous connection was in the
 * subscriber mode, client will auto re-subscribe these channels.
 * @param {boolean} [options.autoResendUnfulfilledCommands=true] - If true, client will resend unfulfilled
 * commands(e.g. block commands) in the previous connection when reconnected.
 * @param {boolean} [options.lazyConnect=false] - By default,
 * When a new `Redis` instance is created, it will connect to Redis server automatically.
 * If you want to keep the instance disconnected until a command is called, you can pass the `lazyConnect` option to
 * the constructor:
 *
 * ```javascript
 * var redis = new Redis({ lazyConnect: true });
 * // No attempting to connect to the Redis server here.

 * // Now let&#039;s connect to the Redis server
 * redis.get(&#039;foo&#039;, function () {
 * });
 * ```
 * @param {Object} [options.tls] - TLS connection support. See https://github.com/luin/ioredis#tls-options
 * @param {string} [options.keyPrefix=&#039;&#039;] - The prefix to prepend to all keys in a command.
 * @param {function} [options.retryStrategy] - See &quot;Quick Start&quot; section
 * @param {number} [options.maxRetriesPerRequest] - See &quot;Quick Start&quot; section
 * @param {number} [options.maxLoadingRetryTime=10000] - when redis server is not ready, we will wait for
 * `loading_eta_seconds` from `info` command or maxLoadingRetryTime (milliseconds), whichever is smaller.
 * @param {function} [options.reconnectOnError] - See &quot;Quick Start&quot; section
 * @param {boolean} [options.readOnly=false] - Enable READONLY mode for the connection.
 * Only available for cluster mode.
 * @param {boolean} [options.stringNumbers=false] - Force numbers to be always returned as JavaScript
 * strings. This option is necessary when dealing with big numbers (exceed the [-2^53, +2^53] range).
 * @param {boolean} [options.enableTLSForSentinelMode=false] - Whether to support the `tls` option
 * when connecting to Redis via sentinel mode.
 * @param {NatMap} [options.natMap=null] NAT map for sentinel connector.
 * @param {boolean} [options.updateSentinels=true] - Update the given `sentinels` list with new IP
 * addresses when communicating with existing sentinels.
 * @param {boolean} [options.failoverDetector=false] - Detect failover actively by subscribing to the
 * related channels. With this option disabled, ioredis is still able to detect failovers because Redis
 * Sentinel will disconnect all clients whenever a failover happens, so ioredis will reconnect to the new
 * master. This option is useful when you want to detect failover quicker, but it will create more TCP
 * connections to Redis servers in order to subscribe to related channels.
* @param {boolean} [options.enableAutoPipelining=false] - When enabled, all commands issued during an event loop
 * iteration are automatically wrapped in a pipeline and sent to the server at the same time.
 * This can dramatically improve performance.
 * @param {string[]} [options.autoPipeliningIgnoredCommands=[]] - The list of commands which must not be automatically wrapped in pipelines.
 * @param {number} [options.maxScriptsCachingTime=60000] Default script definition caching time.
  * @extends [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)
 * @extends Commander
 * @example
 * ```js
 * var Redis = require(&#039;ioredis&#039;);
 *
 * var redis = new Redis();
 *
 * var redisOnPort6380 = new Redis(6380);
 * var anotherRedis = new Redis(6380, &#039;192.168.100.1&#039;);
 * var unixSocketRedis = new Redis({ path: &#039;/tmp/echo.sock&#039; });
 * var unixSocketRedis2 = new Redis(&#039;/tmp/echo.sock&#039;);
 * var urlRedis = new Redis(&#039;redis://user:password@redis-service.com:6379/&#039;);
 * var urlRedis2 = new Redis(&#039;//localhost:6379&#039;);
 * var urlRedisTls = new Redis(&#039;rediss://user:password@redis-service.com:6379/&#039;);
 * var authedRedis = new Redis(6380, &#039;192.168.100.1&#039;, { password: &#039;password&#039; });
 * ```
 */
exports.default = Redis;
function Redis() {
    if (!(this instanceof Redis)) {
        console.error(new Error(&quot;Calling `Redis()` like a function is deprecated. Using `new Redis()` instead.&quot;).stack.replace(&quot;Error&quot;, &quot;Warning&quot;));
        return new Redis(arguments[0], arguments[1], arguments[2]);
    }
    this.parseOptions(arguments[0], arguments[1], arguments[2]);
    events_1.EventEmitter.call(this);
    commander_1.default.call(this);
    this.resetCommandQueue();
    this.resetOfflineQueue();
    this.connectionEpoch = 0;
    if (this.options.Connector) {
        this.connector = new this.options.Connector(this.options);
    }
    else if (this.options.sentinels) {
        const sentinelConnector = new connectors_1.SentinelConnector(this.options);
        sentinelConnector.emitter = this;
        this.connector = sentinelConnector;
    }
    else {
        this.connector = new connectors_1.StandaloneConnector(this.options);
    }
    this.retryAttempts = 0;
    // Prepare a cache of scripts and setup a interval which regularly clears it
    this._addedScriptHashes = {};
    // Prepare autopipelines structures
    this._autoPipelines = new Map();
    this._runningAutoPipelines = new Set();
    Object.defineProperty(this, &quot;autoPipelineQueueSize&quot;, {
        get() {
            let queued = 0;
            for (const pipeline of this._autoPipelines.values()) {
                queued += pipeline.length;
            }
            return queued;
        },
    });
    // end(or wait) -&gt; connecting -&gt; connect -&gt; ready -&gt; end
    if (this.options.lazyConnect) {
        this.setStatus(&quot;wait&quot;);
    }
    else {
        this.connect().catch(lodash_1.noop);
    }
}
util_1.inherits(Redis, events_1.EventEmitter);
Object.assign(Redis.prototype, commander_1.default.prototype);
/**
 * Create a Redis instance
 *
 * @deprecated
 */
// @ts-ignore
Redis.createClient = function (...args) {
    // @ts-ignore
    return new Redis(...args);
};
/**
 * Default options
 *
 * @var defaultOptions
 * @private
 */
Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
Redis.prototype.resetCommandQueue = function () {
    this.commandQueue = new Deque();
};
Redis.prototype.resetOfflineQueue = function () {
    this.offlineQueue = new Deque();
};
Redis.prototype.parseOptions = function () {
    this.options = {};
    let isTls = false;
    for (let i = 0; i &lt; arguments.length; ++i) {
        const arg = arguments[i];
        if (arg === null || typeof arg === &quot;undefined&quot;) {
            continue;
        }
        if (typeof arg === &quot;object&quot;) {
            lodash_1.defaults(this.options, arg);
        }
        else if (typeof arg === &quot;string&quot;) {
            lodash_1.defaults(this.options, utils_1.parseURL(arg));
            if (arg.startsWith(&quot;rediss://&quot;)) {
                isTls = true;
            }
        }
        else if (typeof arg === &quot;number&quot;) {
            this.options.port = arg;
        }
        else {
            throw new Error(&quot;Invalid argument &quot; + arg);
        }
    }
    if (isTls) {
        lodash_1.defaults(this.options, { tls: true });
    }
    lodash_1.defaults(this.options, Redis.defaultOptions);
    if (typeof this.options.port === &quot;string&quot;) {
        this.options.port = parseInt(this.options.port, 10);
    }
    if (typeof this.options.db === &quot;string&quot;) {
        this.options.db = parseInt(this.options.db, 10);
    }
    if (this.options.parser === &quot;hiredis&quot;) {
        console.warn(&quot;Hiredis parser is abandoned since ioredis v3.0, and JavaScript parser will be used&quot;);
    }
    this.options = utils_1.resolveTLSProfile(this.options);
};
/**
 * Change instance&#039;s status
 * @private
 */
Redis.prototype.setStatus = function (status, arg) {
    // @ts-ignore
    if (debug.enabled) {
        debug(&quot;status[%s]: %s -&gt; %s&quot;, this._getDescription(), this.status || &quot;[empty]&quot;, status);
    }
    this.status = status;
    process.nextTick(this.emit.bind(this, status, arg));
};
Redis.prototype.clearAddedScriptHashesCleanInterval = function () {
    if (this._addedScriptHashesCleanInterval) {
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = null;
    }
};
/**
 * Create a connection to Redis.
 * This method will be invoked automatically when creating a new Redis instance
 * unless `lazyConnect: true` is passed.
 *
 * When calling this method manually, a Promise is returned, which will
 * be resolved when the connection status is ready.
 * @param {function} [callback]
 * @return {Promise&lt;void&gt;}
 * @public
 */
Redis.prototype.connect = function (callback) {
    const _Promise = PromiseContainer.get();
    const promise = new _Promise((resolve, reject) =&gt; {
        if (this.status === &quot;connecting&quot; ||
            this.status === &quot;connect&quot; ||
            this.status === &quot;ready&quot;) {
            reject(new Error(&quot;Redis is already connecting/connected&quot;));
            return;
        }
        // Make sure only one timer is active at a time
        this.clearAddedScriptHashesCleanInterval();
        // Scripts need to get reset on reconnect as redis
        // might have been restarted or some failover happened
        this._addedScriptHashes = {};
        // Start the script cache cleaning
        this._addedScriptHashesCleanInterval = setInterval(() =&gt; {
            this._addedScriptHashes = {};
        }, this.options.maxScriptsCachingTime);
        this.connectionEpoch += 1;
        this.setStatus(&quot;connecting&quot;);
        const { options } = this;
        this.condition = {
            select: options.db,
            auth: options.username
                ? [options.username, options.password]
                : options.password,
            subscriber: false,
        };
        const _this = this;
        standard_as_callback_1.default(this.connector.connect(function (type, err) {
            _this.silentEmit(type, err);
        }), function (err, stream) {
            if (err) {
                _this.flushQueue(err);
                _this.silentEmit(&quot;error&quot;, err);
                reject(err);
                _this.setStatus(&quot;end&quot;);
                return;
            }
            let CONNECT_EVENT = options.tls ? &quot;secureConnect&quot; : &quot;connect&quot;;
            if (options.sentinels &amp;&amp; !options.enableTLSForSentinelMode) {
                CONNECT_EVENT = &quot;connect&quot;;
            }
            _this.stream = stream;
            if (typeof options.keepAlive === &quot;number&quot;) {
                stream.setKeepAlive(true, options.keepAlive);
            }
            if (stream.connecting) {
                stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
                if (options.connectTimeout) {
                    /*
                     * Typically, Socket#setTimeout(0) will clear the timer
                     * set before. However, in some platforms (Electron 3.x~4.x),
                     * the timer will not be cleared. So we introduce a variable here.
                     *
                     * See https://github.com/electron/electron/issues/14915
                     */
                    let connectTimeoutCleared = false;
                    stream.setTimeout(options.connectTimeout, function () {
                        if (connectTimeoutCleared) {
                            return;
                        }
                        stream.setTimeout(0);
                        stream.destroy();
                        const err = new Error(&quot;connect ETIMEDOUT&quot;);
                        // @ts-ignore
                        err.errorno = &quot;ETIMEDOUT&quot;;
                        // @ts-ignore
                        err.code = &quot;ETIMEDOUT&quot;;
                        // @ts-ignore
                        err.syscall = &quot;connect&quot;;
                        eventHandler.errorHandler(_this)(err);
                    });
                    stream.once(CONNECT_EVENT, function () {
                        connectTimeoutCleared = true;
                        stream.setTimeout(0);
                    });
                }
            }
            else if (stream.destroyed) {
                const firstError = _this.connector.firstError;
                if (firstError) {
                    process.nextTick(() =&gt; {
                        eventHandler.errorHandler(_this)(firstError);
                    });
                }
                process.nextTick(eventHandler.closeHandler(_this));
            }
            else {
                process.nextTick(eventHandler.connectHandler(_this));
            }
            if (!stream.destroyed) {
                stream.once(&quot;error&quot;, eventHandler.errorHandler(_this));
                stream.once(&quot;close&quot;, eventHandler.closeHandler(_this));
            }
            if (options.noDelay) {
                stream.setNoDelay(true);
            }
            const connectionReadyHandler = function () {
                _this.removeListener(&quot;close&quot;, connectionCloseHandler);
                resolve();
            };
            var connectionCloseHandler = function () {
                _this.removeListener(&quot;ready&quot;, connectionReadyHandler);
                reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            };
            _this.once(&quot;ready&quot;, connectionReadyHandler);
            _this.once(&quot;close&quot;, connectionCloseHandler);
        });
    });
    return standard_as_callback_1.default(promise, callback);
};
/**
 * Disconnect from Redis.
 *
 * This method closes the connection immediately,
 * and may lose some pending replies that haven&#039;t written to client.
 * If you want to wait for the pending replies, use Redis#quit instead.
 * @public
 */
Redis.prototype.disconnect = function (reconnect) {
    this.clearAddedScriptHashesCleanInterval();
    if (!reconnect) {
        this.manuallyClosing = true;
    }
    if (this.reconnectTimeout &amp;&amp; !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
    }
    if (this.status === &quot;wait&quot;) {
        eventHandler.closeHandler(this)();
    }
    else {
        this.connector.disconnect();
    }
};
/**
 * Disconnect from Redis.
 *
 * @deprecated
 */
Redis.prototype.end = function () {
    this.disconnect();
};
/**
 * Create a new instance with the same options as the current one.
 *
 * @example
 * ```js
 * var redis = new Redis(6380);
 * var anotherRedis = redis.duplicate();
 * ```
 *
 * @public
 */
Redis.prototype.duplicate = function (override) {
    return new Redis(Object.assign({}, this.options, override || {}));
};
Redis.prototype.recoverFromFatalError = function (commandError, err, options) {
    this.flushQueue(err, options);
    this.silentEmit(&quot;error&quot;, err);
    this.disconnect(true);
};
Redis.prototype.handleReconnection = function handleReconnection(err, item) {
    let needReconnect = false;
    if (this.options.reconnectOnError) {
        needReconnect = this.options.reconnectOnError(err);
    }
    switch (needReconnect) {
        case 1:
        case true:
            if (this.status !== &quot;reconnecting&quot;) {
                this.disconnect(true);
            }
            item.command.reject(err);
            break;
        case 2:
            if (this.status !== &quot;reconnecting&quot;) {
                this.disconnect(true);
            }
            if (this.condition.select !== item.select &amp;&amp;
                item.command.name !== &quot;select&quot;) {
                this.select(item.select);
            }
            this.sendCommand(item.command);
            break;
        default:
            item.command.reject(err);
    }
};
/**
 * Flush offline queue and command queue with error.
 *
 * @param {Error} error - The error object to send to the commands
 * @param {object} options
 * @private
 */
Redis.prototype.flushQueue = function (error, options) {
    options = lodash_1.defaults({}, options, {
        offlineQueue: true,
        commandQueue: true,
    });
    let item;
    if (options.offlineQueue) {
        while (this.offlineQueue.length &gt; 0) {
            item = this.offlineQueue.shift();
            item.command.reject(error);
        }
    }
    if (options.commandQueue) {
        if (this.commandQueue.length &gt; 0) {
            if (this.stream) {
                this.stream.removeAllListeners(&quot;data&quot;);
            }
            while (this.commandQueue.length &gt; 0) {
                item = this.commandQueue.shift();
                item.command.reject(error);
            }
        }
    }
};
/**
 * Check whether Redis has finished loading the persistent data and is able to
 * process commands.
 *
 * @param {Function} callback
 * @private
 */
Redis.prototype._readyCheck = function (callback) {
    const _this = this;
    this.info(function (err, res) {
        if (err) {
            return callback(err);
        }
        if (typeof res !== &quot;string&quot;) {
            return callback(null, res);
        }
        const info = {};
        const lines = res.split(&quot;\r\n&quot;);
        for (let i = 0; i &lt; lines.length; ++i) {
            const [fieldName, ...fieldValueParts] = lines[i].split(&quot;:&quot;);
            const fieldValue = fieldValueParts.join(&quot;:&quot;);
            if (fieldValue) {
                info[fieldName] = fieldValue;
            }
        }
        if (!info.loading || info.loading === &quot;0&quot;) {
            callback(null, info);
        }
        else {
            const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;
            const retryTime = _this.options.maxLoadingRetryTime &amp;&amp;
                _this.options.maxLoadingRetryTime &lt; loadingEtaMs
                ? _this.options.maxLoadingRetryTime
                : loadingEtaMs;
            debug(&quot;Redis server still loading, trying again in &quot; + retryTime + &quot;ms&quot;);
            setTimeout(function () {
                _this._readyCheck(callback);
            }, retryTime);
        }
    });
};
/**
 * Emit only when there&#039;s at least one listener.
 *
 * @param {string} eventName - Event to emit
 * @param {...*} arguments - Arguments
 * @return {boolean} Returns true if event had listeners, false otherwise.
 * @private
 */
Redis.prototype.silentEmit = function (eventName) {
    let error;
    if (eventName === &quot;error&quot;) {
        error = arguments[1];
        if (this.status === &quot;end&quot;) {
            return;
        }
        if (this.manuallyClosing) {
            // ignore connection related errors when manually disconnecting
            if (error instanceof Error &amp;&amp;
                (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||
                    // @ts-ignore
                    error.syscall === &quot;connect&quot; ||
                    // @ts-ignore
                    error.syscall === &quot;read&quot;)) {
                return;
            }
        }
    }
    if (this.listeners(eventName).length &gt; 0) {
        return this.emit.apply(this, arguments);
    }
    if (error &amp;&amp; error instanceof Error) {
        console.error(&quot;[ioredis] Unhandled error event:&quot;, error.stack);
    }
    return false;
};
/**
 * Listen for all requests received by the server in real time.
 *
 * This command will create a new connection to Redis and send a
 * MONITOR command via the new connection in order to avoid disturbing
 * the current connection.
 *
 * @param {function} [callback] The callback function. If omit, a promise will be returned.
 * @example
 * ```js
 * var redis = new Redis();
 * redis.monitor(function (err, monitor) {
 *   // Entering monitoring mode.
 *   monitor.on(&#039;monitor&#039;, function (time, args, source, database) {
 *     console.log(time + &quot;: &quot; + util.inspect(args));
 *   });
 * });
 *
 * // supports promise as well as other commands
 * redis.monitor().then(function (monitor) {
 *   monitor.on(&#039;monitor&#039;, function (time, args, source, database) {
 *     console.log(time + &quot;: &quot; + util.inspect(args));
 *   });
 * });
 * ```
 * @public
 */
Redis.prototype.monitor = function (callback) {
    const monitorInstance = this.duplicate({
        monitor: true,
        lazyConnect: false,
    });
    const Promise = PromiseContainer.get();
    return standard_as_callback_1.default(new Promise(function (resolve) {
        monitorInstance.once(&quot;monitoring&quot;, function () {
            resolve(monitorInstance);
        });
    }), callback);
};
transaction_1.addTransactionSupport(Redis.prototype);
/**
 * Send a command to Redis
 *
 * This method is used internally by the `Redis#set`, `Redis#lpush` etc.
 * Most of the time you won&#039;t invoke this method directly.
 * However when you want to send a command that is not supported by ioredis yet,
 * this command will be useful.
 *
 * @method sendCommand
 * @memberOf Redis#
 * @param {Command} command - The Command instance to send.
 * @see {@link Command}
 * @example
 * ```js
 * var redis = new Redis();
 *
 * // Use callback
 * var get = new Command(&#039;get&#039;, [&#039;foo&#039;], &#039;utf8&#039;, function (err, result) {
 *   console.log(result);
 * });
 * redis.sendCommand(get);
 *
 * // Use promise
 * var set = new Command(&#039;set&#039;, [&#039;foo&#039;, &#039;bar&#039;], &#039;utf8&#039;);
 * set.promise.then(function (result) {
 *   console.log(result);
 * });
 * redis.sendCommand(set);
 * ```
 * @private
 */
Redis.prototype.sendCommand = function (command, stream) {
    if (this.status === &quot;wait&quot;) {
        this.connect().catch(lodash_1.noop);
    }
    if (this.status === &quot;end&quot;) {
        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
    }
    if (this.condition.subscriber &amp;&amp;
        !command_1.default.checkFlag(&quot;VALID_IN_SUBSCRIBER_MODE&quot;, command.name)) {
        command.reject(new Error(&quot;Connection in subscriber mode, only subscriber commands may be used&quot;));
        return command.promise;
    }
    if (typeof this.options.commandTimeout === &quot;number&quot;) {
        command.setTimeout(this.options.commandTimeout);
    }
    if (command.name === &quot;quit&quot;) {
        this.clearAddedScriptHashesCleanInterval();
    }
    let writable = this.status === &quot;ready&quot; ||
        (!stream &amp;&amp;
            this.status === &quot;connect&quot; &amp;&amp;
            commands_1.exists(command.name) &amp;&amp;
            commands_1.hasFlag(command.name, &quot;loading&quot;));
    if (!this.stream) {
        writable = false;
    }
    else if (!this.stream.writable) {
        writable = false;
    }
    else if (this.stream._writableState &amp;&amp; this.stream._writableState.ended) {
        // https://github.com/iojs/io.js/pull/1217
        writable = false;
    }
    if (!writable &amp;&amp; !this.options.enableOfflineQueue) {
        command.reject(new Error(&quot;Stream isn&#039;t writeable and enableOfflineQueue options is false&quot;));
        return command.promise;
    }
    if (!writable &amp;&amp; command.name === &quot;quit&quot; &amp;&amp; this.offlineQueue.length === 0) {
        this.disconnect();
        command.resolve(Buffer.from(&quot;OK&quot;));
        return command.promise;
    }
    if (writable) {
        // @ts-ignore
        if (debug.enabled) {
            debug(&quot;write command[%s]: %d -&gt; %s(%o)&quot;, this._getDescription(), this.condition.select, command.name, command.args);
        }
        (stream || this.stream).write(command.toWritable());
        this.commandQueue.push({
            command: command,
            stream: stream,
            select: this.condition.select,
        });
        if (command_1.default.checkFlag(&quot;WILL_DISCONNECT&quot;, command.name)) {
            this.manuallyClosing = true;
        }
    }
    else if (this.options.enableOfflineQueue) {
        // @ts-ignore
        if (debug.enabled) {
            debug(&quot;queue command[%s]: %d -&gt; %s(%o)&quot;, this._getDescription(), this.condition.select, command.name, command.args);
        }
        this.offlineQueue.push({
            command: command,
            stream: stream,
            select: this.condition.select,
        });
    }
    if (command.name === &quot;select&quot; &amp;&amp; utils_1.isInt(command.args[0])) {
        const db = parseInt(command.args[0], 10);
        if (this.condition.select !== db) {
            this.condition.select = db;
            this.emit(&quot;select&quot;, db);
            debug(&quot;switch to db [%d]&quot;, this.condition.select);
        }
    }
    return command.promise;
};
/**
 * Get description of the connection. Used for debugging.
 * @private
 */
Redis.prototype._getDescription = function () {
    let description;
    if (this.options.path) {
        description = this.options.path;
    }
    else if (this.stream &amp;&amp;
        this.stream.remoteAddress &amp;&amp;
        this.stream.remotePort) {
        description = this.stream.remoteAddress + &quot;:&quot; + this.stream.remotePort;
    }
    else {
        description = this.options.host + &quot;:&quot; + this.options.port;
    }
    if (this.options.connectionName) {
        description += ` (${this.options.connectionName})`;
    }
    return description;
};
[
    &quot;scan&quot;,
    &quot;sscan&quot;,
    &quot;hscan&quot;,
    &quot;zscan&quot;,
    &quot;scanBuffer&quot;,
    &quot;sscanBuffer&quot;,
    &quot;hscanBuffer&quot;,
    &quot;zscanBuffer&quot;,
].forEach(function (command) {
    Redis.prototype[command + &quot;Stream&quot;] = function (key, options) {
        if (command === &quot;scan&quot; || command === &quot;scanBuffer&quot;) {
            options = key;
            key = null;
        }
        return new ScanStream_1.default(lodash_1.defaults({
            objectMode: true,
            key: key,
            redis: this,
            command: command,
        }, options));
    };
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
