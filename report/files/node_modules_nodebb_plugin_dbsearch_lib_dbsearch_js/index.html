<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nodebb-plugin-dbsearch/lib/dbsearch.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nodebb-plugin-dbsearch/lib/dbsearch.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">642</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">70.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.78</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const _ = require(&#039;lodash&#039;);

const winston = require.main.require(&#039;winston&#039;);
const nconf = require.main.require(&#039;nconf&#039;);

const db = require.main.require(&#039;./src/database&#039;);
const topics = require.main.require(&#039;./src/topics&#039;);
const posts = require.main.require(&#039;./src/posts&#039;);
const messaging = require.main.require(&#039;./src/messaging&#039;);
const utils = require.main.require(&#039;./src/utils&#039;);
const socketAdmin = require.main.require(&#039;./src/socket.io/admin&#039;);
const batch = require.main.require(&#039;./src/batch&#039;);
const plugins = require.main.require(&#039;./src/plugins&#039;);
const categories = require.main.require(&#039;./src/categories&#039;);
const pubsub = require.main.require(&#039;./src/pubsub&#039;);

const searchModule = require(`./${nconf.get(&#039;database&#039;)}`);

db.searchIndex = searchModule.searchIndex;
db.search = searchModule.search;
db.searchRemove = searchModule.searchRemove;

const languageLookup = {
	da: &#039;danish&#039;,
	nl: &#039;dutch&#039;,
	en: &#039;english&#039;,
	fi: &#039;finnish&#039;,
	fr: &#039;french&#039;,
	de: &#039;german&#039;,
	hu: &#039;hungarian&#039;,
	it: &#039;italian&#039;,
	nb: &#039;norwegian&#039;,
	pt: &#039;portuguese&#039;,
	ro: &#039;romanian&#039;,
	ru: &#039;russian&#039;,
	es: &#039;spanish&#039;,
	sv: &#039;swedish&#039;,
	tr: &#039;turkish&#039;,
};

const defaultPostLimit = 500;
const defaultTopicLimit = 500;

let pluginConfig = {
	postLimit: defaultPostLimit,
	topicLimit: defaultTopicLimit,
	excludeCategories: [],
};

const batchSize = 500;

const search = module.exports;

function convertLanguageName(name) {
	if (nconf.get(&#039;database&#039;) === &#039;postgres&#039;) {
		return languageLookup[name] || languageLookup.en;
	}
	return name;
}

search.init = async function (params) {
	const { router } = params;
	const routeHelpers = require.main.require(&#039;./src/routes/helpers&#039;);
	routeHelpers.setupAdminPageRoute(router, &#039;/admin/plugins/dbsearch&#039;, renderAdmin);

	router.post(&#039;/api/admin/plugins/dbsearch/save&#039;, params.middleware.applyCSRF, save);

	pluginConfig = await getPluginData();
	await searchModule.createIndices(convertLanguageName(pluginConfig ? pluginConfig.indexLanguage || &#039;en&#039; : &#039;en&#039;));

	pubsub.on(&#039;nodebb-plugin-dbsearch:settings:save&#039;, (data) =&gt; {
		Object.assign(pluginConfig, data);
	});
};

search.actionPostSave = async function (data) {
	const isDeleted = await topics.getTopicField(data.post.tid, &#039;deleted&#039;);
	if (!isDeleted) {
		await postsSave([data.post]);
	}
};

search.actionPostRestore = function (data) {
	search.actionPostSave(data);
};

search.actionPostEdit = function (data) {
	search.actionPostSave(data);
};

search.actionPostDelete = function (data) {
	searchRemove(&#039;post&#039;, [data.post.pid]);
};

search.actionPostsPurge = function (data) {
	searchRemove(&#039;post&#039;, data.posts.map(p =&gt; p &amp;&amp; p.pid));
};

search.actionPostMove = async function (data) {
	const topicData = await topics.getTopicFields(data.post.tid, [&#039;cid&#039;, &#039;deleted&#039;]);
	reIndexPids([data.post.pid], topicData);
};

search.actionPostChangeOwner = async function (hookData) {
	const tids = _.uniq(hookData.posts.map(p =&gt; p.tid));
	const topicData = await topics.getTopicsFields(tids, [&#039;deleted&#039;]);
	const tidToTopic = _.zipObject(tids, topicData);
	const posts = hookData.posts.filter(p =&gt; tidToTopic[p.tid] &amp;&amp; !tidToTopic[p.tid].deleted);
	posts.forEach((p) =&gt; {
		p.uid = hookData.toUid;
	});
	await postsSave(posts);
};

search.actionTopicSave = function (data) {
	topicsSave([data.topic]);
};

search.actionTopicRestore = function (data) {
	reIndexTids([data.topic.tid]);
};

search.actionTopicEdit = function (data) {
	search.actionTopicSave(data);
};

search.actionTopicDelete = async function (data) {
	if (!data || !data.topic) {
		return;
	}
	const { tid } = data.topic;
	await Promise.all([
		searchRemove(&#039;topic&#039;, [tid]),
		searchRemove(&#039;post&#039;, [data.topic.mainPid]),
		batch.processSortedSet(`tid:${tid}:posts`, async (pids) =&gt; {
			await searchRemove(&#039;post&#039;, pids);
		}, {
			batch: batchSize,
		}),
	]);
};

search.actionTopicPurge = function (data) {
	search.actionTopicDelete(data);
};

search.actionTopicMove = function (data) {
	reIndexTids([data.tid]);
};

search.actionTopicChangeOwner = function (hookData) {
	hookData.topics.forEach((t) =&gt; {
		t.uid = hookData.toUid;
	});
	topicsSave(hookData.topics);
};

search.actionMessagingSave = async function (hookData) {
	await messagesSave([hookData.message]);
};

search.actionMessagingDelete = async function (hookData) {
	await searchRemove(&#039;chat&#039;, [hookData.message.mid]);
};

search.actionMessagingRestore = async function (hookData) {
	await messagesSave([hookData.message]);
};

search.actionMessagingEdit = async function (hookData) {
	await messagesSave([hookData.message]);
};

search.filterSearchQuery = async function (data) {
	if (!data || !data.index) {
		return data;
	}
	let limit = data.index === &#039;post&#039; ? pluginConfig.postLimit : pluginConfig.topicLimit;
	if (data.limit) {
		limit = data.limit;
	}
	const query = {};
	if (data.hasOwnProperty(&#039;cid&#039;)) {
		query.cid = data.cid;
	}
	if (data.hasOwnProperty(&#039;uid&#039;)) {
		query.uid = data.uid;
	}
	if (data.hasOwnProperty(&#039;content&#039;)) {
		query.content = data.content;
	}
	if (!Object.keys(query).length) {
		return [];
	}
	if (data.hasOwnProperty(&#039;matchWords&#039;)) {
		query.matchWords = data.matchWords;
	}
	query.searchData = data.searchData || {};
	data.ids = data.ids.concat(await db.search(data.index, query, limit));
	return data;
};

search.filterSearchTopic = async function (hookData) {
	if (!hookData.term || !hookData.tid) {
		return hookData;
	}
	const cid = await topics.getTopicField(hookData.tid, &#039;cid&#039;);
	const result = await search.filterSearchQuery({
		index: &#039;post&#039;,
		cid: [cid],
		content: hookData.term,
		ids: [],
	});
	const postData = await posts.getPostsFields(result.ids, [&#039;pid&#039;, &#039;tid&#039;]);
	hookData.ids = hookData.ids.concat(postData.filter(p =&gt; p &amp;&amp; p.tid === parseInt(hookData.tid, 10))
		.map(p =&gt; p.pid));
	return hookData;
};

search.filterMessagingSearchMessages = async function (data) {
	if (!data || !data.content) {
		return data;
	}
	const limit = 100;
	const query = {};
	if (data.hasOwnProperty(&#039;roomId&#039;) &amp;&amp; data.roomId) {
		query.roomId = data.roomId;
	}
	if (data.hasOwnProperty(&#039;uid&#039;) &amp;&amp; data.uid) {
		query.uid = data.uid;
	}
	if (data.hasOwnProperty(&#039;content&#039;) &amp;&amp; data.content) {
		query.content = data.content;
	}
	if (!Object.keys(query).length) {
		return [];
	}
	if (data.hasOwnProperty(&#039;matchWords&#039;)) {
		query.matchWords = data.matchWords;
	}

	data.ids = data.ids.concat(await searchModule.chat.search(query, limit));
	return data;
};

search.reindex = async function () {
	await db.setObject(&#039;nodebb-plugin-dbsearch&#039;, {
		topicsIndexed: 0,
		postsIndexed: 0,
		messagesIndexed: 0,
		working: 1,
	});
	await Promise.all([
		reIndexTopics(),
		reIndexPosts(),
		reIndexMessages(),
	]);
	await db.setObject(&#039;nodebb-plugin-dbsearch&#039;, {
		working: 0,
	});
};

async function reIndexTopics() {
	await batch.processSortedSet(&#039;topics:tid&#039;, async (tids) =&gt; {
		const topicData = await topics.getTopicsFields(tids, [&#039;tid&#039;, &#039;title&#039;, &#039;uid&#039;, &#039;cid&#039;, &#039;deleted&#039;, &#039;timestamp&#039;]);
		await topicsSave(topicData);
	}, {
		batch: batchSize,
	});
}

async function topicsSave(topics) {
	topics = topics.filter(
		t =&gt; t &amp;&amp; utils.isNumber(t.tid) &amp;&amp; parseInt(t.deleted, 10) !== 1 &amp;&amp;
		!pluginConfig.excludeCategories.includes(String(t.cid))
	);

	let data = topics.map((topicData) =&gt; {
		const indexData = {};
		if (topicData.title) {
			indexData.content = topicData.title;
		}
		if (topicData.cid) {
			indexData.cid = topicData.cid;
		}
		if (topicData.uid) {
			indexData.uid = topicData.uid;
		}
		if (topicData.timestamp) {
			indexData.timestamp = topicData.timestamp;
		}
		if (!Object.keys(indexData).length) {
			return null;
		}
		return indexData;
	});

	const tids = topics.filter((t, index) =&gt; !!data[index]).map(t =&gt; t.tid);
	data = data.filter(Boolean);
	if (!data.length) {
		return;
	}

	const result = await plugins.hooks.fire(&#039;filter:search.indexTopics&#039;, { data: data, tids: tids, topics: topics });
	await db.searchIndex(&#039;topic&#039;, result.data, result.tids);
	await db.incrObjectFieldBy(&#039;nodebb-plugin-dbsearch&#039;, &#039;topicsIndexed&#039;, result.tids.length);
}

async function reIndexPosts() {
	await batch.processSortedSet(&#039;posts:pid&#039;, async (pids) =&gt; {
		let postData = await posts.getPostsFields(pids, [&#039;pid&#039;, &#039;content&#039;, &#039;uid&#039;, &#039;tid&#039;, &#039;deleted&#039;, &#039;timestamp&#039;]);
		postData = postData.filter(p =&gt; p &amp;&amp; p.deleted !== 1);
		const tids = _.uniq(postData.map(p =&gt; p.tid));
		const topicData = await topics.getTopicsFields(tids, [&#039;deleted&#039;, &#039;cid&#039;]);
		const tidToTopic = _.zipObject(tids, topicData);
		postData.forEach((post) =&gt; {
			if (post &amp;&amp; tidToTopic[post.tid]) {
				post.cid = tidToTopic[post.tid].cid;
			}
		});
		postData = postData.filter(post =&gt; tidToTopic[post.tid].deleted !== 1);
		await postsSave(postData);
	}, {
		batch: batchSize,
	});
}

async function postsSave(posts) {
	posts = posts.filter(
		p =&gt; p &amp;&amp; utils.isNumber(p.pid) &amp;&amp; parseInt(p.deleted, 10) !== 1 &amp;&amp;
		!pluginConfig.excludeCategories.includes(String(p.cid))
	);

	let data = posts.map((postData) =&gt; {
		const indexData = {};
		if (postData.content) {
			indexData.content = postData.content;
		}
		if (postData.cid) {
			indexData.cid = postData.cid;
		}
		if (postData.uid) {
			indexData.uid = postData.uid;
		}
		if (postData.timestamp) {
			indexData.timestamp = postData.timestamp;
		}
		if (!Object.keys(indexData).length) {
			return null;
		}
		return indexData;
	});

	const pids = posts.filter((p, index) =&gt; !!data[index]).map(p =&gt; p.pid);
	data = data.filter(Boolean);
	if (!data.length) {
		return;
	}

	const result = await plugins.hooks.fire(&#039;filter:search.indexPosts&#039;, { data: data, pids: pids, posts: posts });
	await db.searchIndex(&#039;post&#039;, result.data, result.pids);
	await db.incrObjectFieldBy(&#039;nodebb-plugin-dbsearch&#039;, &#039;postsIndexed&#039;, result.pids.length);
}

async function reIndexMessages() {
	await batch.processSortedSet(`messages:mid`, async (mids) =&gt; {
		let messageData = await messaging.getMessagesFields(mids, [&#039;mid&#039;, &#039;content&#039;, &#039;roomId&#039;, &#039;fromuid&#039;, &#039;deleted&#039;, &#039;system&#039;]);
		messageData = messageData.filter(p =&gt; p &amp;&amp; p.deleted !== 1 &amp;&amp; p.system !== 1);
		await messagesSave(messageData);
	}, {
		batch: batchSize,
	});
}

async function messagesSave(msgs) {
	msgs = msgs.filter(m =&gt; m &amp;&amp; utils.isNumber(m.mid) &amp;&amp; parseInt(m.deleted, 10) !== 1 &amp;&amp; parseInt(m.system, 10) !== 1);

	let data = msgs.map((msgData) =&gt; {
		const indexData = {};
		if (msgData.content) {
			indexData.content = msgData.content;
		}
		if (msgData.roomId) {
			indexData.roomId = msgData.roomId;
		}
		if (msgData.fromuid) {
			indexData.uid = msgData.fromuid;
		}
		if (!Object.keys(indexData).length) {
			return null;
		}
		return indexData;
	});

	const mids = msgs.filter((msg, index) =&gt; !!data[index]).map(msg =&gt; msg.mid);
	data = data.filter(Boolean);
	if (!data.length) {
		return;
	}

	const result = await plugins.hooks.fire(&#039;filter:search.indexMessages&#039;, { data: data, mids: mids, messages: msgs });
	await searchModule.chat.index(result.data, result.mids);
	await db.incrObjectFieldBy(&#039;nodebb-plugin-dbsearch&#039;, &#039;messagesIndexed&#039;, result.mids.length);
}

async function searchRemove(key, ids) {
	ids = ids.filter(id =&gt; id &amp;&amp; utils.isNumber(id));
	await db.searchRemove(key, ids);
	if (key === &#039;topic&#039;) {
		await db.incrObjectFieldBy(&#039;nodebb-plugin-dbsearch&#039;, &#039;topicsIndexed&#039;, -ids.length);
	} else if (key === &#039;post&#039;) {
		await db.incrObjectFieldBy(&#039;nodebb-plugin-dbsearch&#039;, &#039;postsIndexed&#039;, -ids.length);
	} else if (key === &#039;chat&#039;) {
		await db.incrObjectFieldBy(&#039;nodebb-plugin-dbsearch&#039;, &#039;messagesIndexed&#039;, -ids.length);
	}
}

async function reIndexTids(tids) {
	if (!Array.isArray(tids) || !tids.length) {
		return;
	}

	let topicData = await topics.getTopicsFields(tids, [&#039;tid&#039;, &#039;title&#039;, &#039;uid&#039;, &#039;cid&#039;, &#039;deleted&#039;, &#039;mainPid&#039;, &#039;timestamp&#039;]);
	topicData = topicData.filter(t =&gt; t.tid &amp;&amp; t.deleted !== 1);
	if (!topicData.length) {
		return;
	}

	async function reIndexTopicsPids(topicData) {
		await Promise.all(topicData.map(t =&gt; reIndexTopicPids(t)));
	}

	async function reIndexTopicPids(topic) {
		await reIndexPids([topic.mainPid], topic);
		await batch.processSortedSet(`tid:${topic.tid}:posts`, async (pids) =&gt; {
			await reIndexPids(pids, topic);
		}, {
			batch: batchSize,
		});
	}

	await Promise.all([
		topicsSave(topicData),
		reIndexTopicsPids(topicData),
	]);
}

async function reIndexPids(pids, topic) {
	if (!Array.isArray(pids) || !pids.length) {
		winston.warn(&#039;[nodebb-plugin-dbsearch] invalid-pid, skipping&#039;);
		return;
	}
	if (parseInt(topic.deleted, 10) === 1) {
		return;
	}
	const postData = await posts.getPostsFields(pids, [&#039;pid&#039;, &#039;content&#039;, &#039;uid&#039;, &#039;tid&#039;, &#039;deleted&#039;, &#039;timestamp&#039;]);
	postData.forEach((post) =&gt; {
		if (post &amp;&amp; topic) {
			post.cid = topic.cid;
		}
	});
	await postsSave(postData);
}

async function renderAdmin(req, res) {
	const results = await getGlobalAndPluginData();
	results.plugin.progressData = await getProgress();
	results.plugin.title = &#039;DB Search&#039;;
	res.render(&#039;admin/plugins/dbsearch&#039;, results.plugin);
}

async function save(req, res) {
	if (utils.isNumber(req.body.postLimit) &amp;&amp; utils.isNumber(req.body.topicLimit)) {
		const data = {
			postLimit: req.body.postLimit,
			topicLimit: req.body.topicLimit,
			excludeCategories: JSON.stringify(req.body.excludeCategories || []),
		};

		await db.setObject(&#039;nodebb-plugin-dbsearch&#039;, data);

		pluginConfig.postLimit = data.postLimit;
		pluginConfig.topicLimit = data.topicLimit;
		pluginConfig.excludeCategories = req.body.excludeCategories || [];
		pubsub.publish(&#039;nodebb-plugin-dbsearch:settings:save&#039;, pluginConfig);
		res.json(&#039;Settings saved!&#039;);
	}
}

socketAdmin.plugins.dbsearch = {};
socketAdmin.plugins.dbsearch.checkProgress = async function () {
	return await getProgress();
};

async function getPluginData() {
	const data = await db.getObject(&#039;nodebb-plugin-dbsearch&#039;) || {};
	data.topicsIndexed = parseInt(data.topicsIndexed, 10) || 0;
	data.postsIndexed = parseInt(data.postsIndexed, 10) || 0;
	data.messagesIndexed = parseInt(data.messagesIndexed, 10) || 0;
	data.excludeCategories = data.excludeCategories || &#039;[]&#039;;
	data.postLimit = data.postLimit || defaultPostLimit;
	data.topicLimit = data.topicLimit || defaultTopicLimit;
	data.indexLanguage = data.indexLanguage || &#039;en&#039;;
	data.working = data.working || 0;

	try {
		data.excludeCategories = JSON.parse(data.excludeCategories);
	} catch (err) {
		winston.error(err);
		data.excludeCategories = [];
	}
	return data;
}

async function getGlobalAndPluginData() {
	const [global, plugin, allCategories] = await Promise.all([
		db.getObjectFields(&#039;global&#039;, [&#039;topicCount&#039;, &#039;postCount&#039;, &#039;messageCount&#039;]),
		getPluginData(),
		categories.buildForSelectAll([&#039;value&#039;, &#039;text&#039;]),
	]);

	const languageSupported = nconf.get(&#039;database&#039;) === &#039;mongo&#039; || nconf.get(&#039;database&#039;) === &#039;postgres&#039;;
	const languages = Object.keys(languageLookup).map(
		code =&gt; ({ name: languageLookup[code], value: code, selected: false })
	);

	plugin.languageSupported = languageSupported;
	plugin.languages = languages;

	plugin.allCategories = allCategories;
	plugin.topicCount = parseInt(global.topicCount, 10);
	plugin.postCount = parseInt(global.postCount, 10);
	plugin.messageCount = parseInt(global.messageCount, 10);
	plugin.topicLimit = plugin.topicLimit || defaultTopicLimit;
	plugin.postLimit = plugin.postLimit || defaultPostLimit;
	plugin.topicsIndexed = plugin.topicsIndexed &gt; plugin.topicCount ? plugin.topicCount : plugin.topicsIndexed;
	plugin.postsIndexed = plugin.postsIndexed &gt; plugin.postCount ? plugin.postCount : plugin.postsIndexed;
	plugin.messagesIndexed = plugin.messagesIndexed &gt; plugin.messageCount ? plugin.messageCount : plugin.messagesIndexed;
	plugin.languageSupported = languageSupported;
	plugin.languages = languages;
	plugin.indexLanguage = plugin.indexLanguage || &#039;en&#039;;
	plugin.languages.forEach((language) =&gt; {
		language.selected = language &amp;&amp; language.value === plugin.indexLanguage;
	});

	plugin.allCategories.forEach((category) =&gt; {
		category.selected = category &amp;&amp; plugin.excludeCategories.includes(String(category.value));
	});

	return { global: global, plugin: plugin, allCategories: allCategories };
}

async function getProgress() {
	const [global, pluginData] = await Promise.all([
		db.getObjectFields(&#039;global&#039;, [&#039;topicCount&#039;, &#039;postCount&#039;, &#039;messageCount&#039;]),
		getPluginData(),
	]);
	const topicCount = parseInt(global.topicCount, 10);
	const postCount = parseInt(global.postCount, 10);
	const messageCount = parseInt(global.messageCount, 10);
	const topicsPercent = topicCount ? (pluginData.topicsIndexed / topicCount) * 100 : 0;
	const postsPercent = postCount ? (pluginData.postsIndexed / postCount) * 100 : 0;
	const messagesPercent = messageCount ? (pluginData.messagesIndexed / messageCount) * 100 : 0;
	return {
		topicsPercent: Math.max(0, Math.min(100, topicsPercent.toFixed(2))),
		postsPercent: Math.max(0, Math.min(100, postsPercent.toFixed(2))),
		messagesPercent: Math.max(0, Math.min(100, messagesPercent.toFixed(2))),
		topicsIndexed: topicsPercent &gt;= 100 ? topicCount : Math.max(0, pluginData.topicsIndexed),
		postsIndexed: postsPercent &gt;= 100 ? postCount : Math.max(0, pluginData.postsIndexed),
		messagesIndexed: messagesPercent &gt;= 100 ? messageCount : Math.max(0, pluginData.messagesIndexed),
		working: pluginData.working,
	};
}

socketAdmin.plugins.dbsearch.reindex = function (socket, data, callback) {
	setTimeout(async () =&gt; {
		try {
			await search.reindex();
		} catch (err) {
			winston.error(err);
		}
	}, 0);
	callback();
};

socketAdmin.plugins.dbsearch.clearIndex = async function () {
	setTimeout(async () =&gt; {
		try {
			await clearIndex();
		} catch (err) {
			winston.error(err.stack);
		}
	}, 0);
};

async function clearIndex() {
	await db.setObject(&#039;nodebb-plugin-dbsearch&#039;, {
		working: 1,
	});

	await Promise.all([
		clearSet(&#039;topics:tid&#039;, &#039;topic&#039;),
		clearSet(&#039;posts:pid&#039;, &#039;post&#039;),
		clearSet(&#039;messages:mid&#039;, &#039;chat&#039;),
	]);

	await db.setObject(&#039;nodebb-plugin-dbsearch&#039;, {
		postsIndexed: 0,
		topicsIndexed: 0,
		messagesIndexed: 0,
		working: 0,
	});
}

async function clearSet(set, key) {
	await batch.processSortedSet(set, async (ids) =&gt; {
		await searchRemove(key, ids);
	}, {
		batch: batchSize,
	});
}

socketAdmin.plugins.dbsearch.changeLanguage = async function (socket, language) {
	await searchModule.changeIndexLanguage(convertLanguageName(language));
	await db.setObject(&#039;nodebb-plugin-dbsearch&#039;, { indexLanguage: language });
};

const admin = {};
admin.menu = function (custom_header, callback) {
	custom_header.plugins.push({
		route: &#039;/plugins/dbsearch&#039;,
		icon: &#039;fa-search&#039;,
		name: &#039;DB Search&#039;,
	});

	callback(null, custom_header);
};

search.admin = admin;
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
