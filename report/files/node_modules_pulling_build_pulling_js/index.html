<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pulling/build/pulling.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pulling/build/pulling.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">567</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">97.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.26</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function (global, factory) {
	typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? module.exports = factory() :
	typeof define === &#039;function&#039; &amp;&amp; define.amd ? define(&#039;pulling&#039;, factory) :
	(global.Pulling = factory());
}(this, (function () { &#039;use strict&#039;;

function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function assertArg(condition, message) {
    if (!condition) {
        throw TypeError(&quot;Invalid arguments: &quot; + message);
    }
}
function polyfill() {
    Element.prototype.matches = Element.prototype.matches ||
        // @ts-ignore: Property does not exist
        Element.prototype.matchesSelector ||
        // @ts-ignore: Property does not exist
        Element.prototype.webkitMatchesSelector ||
        // @ts-ignore: Property does not exist
        Element.prototype.mozMatchesSelector ||
        // @ts-ignore: Property does not exist
        Element.prototype.msMatchesSelector ||
        // @ts-ignore: Property does not exist
        Element.prototype.oMatchesSelector;
    Object.entries = /* Object.entries || */ (function (obj) {
        return Object.keys(obj).map(function (key) { return [key, obj[key]]; });
    });
    Object.values = /* Object.values || */ (function (obj) {
        return Object.keys(obj).map(function (key) { return obj[key]; });
    });
    Object.assign = Object.assign || (function (first) {
        var objects = [];
        for (var _i = 1; _i &lt; arguments.length; _i++) {
            objects[_i - 1] = arguments[_i];
        }
        for (var _a = 0, objects_1 = objects; _a &lt; objects_1.length; _a++) {
            var obj = objects_1[_a];
            for (var _b = 0, _c = Object.entries(obj); _b &lt; _c.length; _b++) {
                var _d = _c[_b], key = _d[0], val = _d[1];
                first[key] = val;
            }
        }
        return first;
    });
    Array.prototype.includes = function includes(value) {
        return this.indexOf(value) !== -1;
    };
}

var timingFunctions = [
    &#039;linear&#039;, &#039;ease&#039;, &#039;ease-in&#039;, &#039;ease-out&#039;,
    &#039;ease-in-out&#039;, &#039;step-start&#039;, &#039;step-end&#039;,
];
var Pulling = /** @class */ (function () {
    function Pulling(options) {
        var _this = this;
        this.styles = {
            base: {
                menu: {},
                panel: {},
            },
            open: {
                menu: {},
                panel: {},
            },
            closed: {
                menu: {},
                panel: {},
            },
        };
        this.handlers = {
            beforeclose: [],
            closed: [],
            beforeopen: [],
            opened: [],
            touchstart: [],
            touchmove: [],
            touchend: [],
        };
        this.state = {
            opened: false,
            opening: false,
            closed: true,
            closing: false,
        };
        this.disabled = false;
        if (!Object.values(Pulling.modes).some(function (x) { return _this instanceof x; })) {
            throw TypeError(&#039;Calling this constructor is not allowed. &#039; +
                &#039;Use `Pulling.create` instead&#039;);
        }
        var menu = options.menu, panel = options.panel, side = options.side, mode = options.mode, margin = options.margin, timing = options.timing, timingFunction = options.timingFunction, width = options.width, sensitivity = options.sensitivity, slope = options.slope, touch = options.touch, openPanelClass = options.openPanelClass;
        this.menu = menu;
        this.panel = panel;
        this.side = side || &#039;left&#039;;
        this.mode = mode || &#039;drawer&#039;;
        this.margin = margin || 25, this.timing = timing || 200;
        this.timingFunction = timingFunction || &#039;ease&#039;;
        this.width = width || 256;
        this.sensitivity = sensitivity || 0.25;
        this.slope = slope || 0.5;
        this.openPanelClass = openPanelClass || null;
        assertArg(menu instanceof Element, &#039;`menu` must be of type `Element`&#039;);
        assertArg(panel instanceof Element, &#039;`panel` must be of type `Element`&#039;);
        assertArg(this.side === &#039;left&#039; || this.side === &#039;right&#039;, &#039;`side` must be equal to &quot;left&quot; or &quot;right&quot;&#039;);
        assertArg(typeof this.margin === &#039;number&#039;, &#039;`margin` must be of type &quot;number&quot;&#039;);
        assertArg(typeof this.timing === &#039;number&#039;, &#039;`timing` must be of type &quot;number&quot;&#039;);
        assertArg(timingFunctions.includes(this.timingFunction), &#039;`timingFunction`&#039; + &quot; must be one of &quot; + timingFunctions.map(function (x) { return &quot;\&quot;&quot; + x + &quot;\&quot;&quot;; }).join(&#039;, &#039;));
        assertArg(typeof this.width === &#039;number&#039;, &#039;`width` must be of type &quot;number&quot;&#039;);
        assertArg(typeof this.sensitivity === &#039;number&#039;, &#039;`sensitivity` must be of type &quot;number&quot;&#039;);
        assertArg(typeof this.slope === &#039;number&#039;, &#039;`slope` must be of type &quot;number&quot;&#039;);
    }
    Pulling.create = function (options) {
        var mode = options.mode || Object.keys(Pulling.modes)[0] || &#039;drawer&#039;;
        if (!Pulling.modes[mode]) {
            var modes = Object.keys(Pulling.modes).map(function (x) { return &quot;\&quot;&quot; + x + &quot;\&quot;&quot;; }).join(&#039;, &#039;);
            throw TypeError(&#039;`mode`&#039; + &quot; must be one of &quot; + modes);
        }
        return new Pulling.modes[mode](options);
    };
    /** Trigger event listeners for the event */
    Pulling.prototype.emit = function (eventName, e) {
        var _this = this;
        this.handlers[eventName].forEach(function (handler) { return handler.call(_this, e); });
    };
    /** Add an event handler for the event */
    Pulling.prototype.on = function (eventName, handler) {
        this.handlers[eventName].push(handler);
        return this;
    };
    /** Remove all event handlers for an event */
    Pulling.prototype.off = function (eventName, handler) {
        if (handler) {
            this.handlers[eventName] = this.handlers[eventName].filter(function (handle) {
                return handle !== handler;
            });
        }
        else {
            this.handlers[eventName] = [];
        }
        return this;
    };
    /** Open the menu */
    Pulling.prototype.open = function (e) {
        var _this = this;
        this.emit(&#039;beforeopen&#039;, e);
        if (this.disabled) {
            return this;
        }
        if (this.state.opened) {
            return this;
        }
        this.state.closed = false;
        this.state.closing = false;
        this.state.opening = true;
        this.state.opened = false;
        if (this.openPanelClass) {
            document.documentElement.classList.add(this.openPanelClass);
        }
        var offset = this.offset();
        if (offset &gt; 0) {
            var duration = this.timing * (1 - offset / this.width) + &quot;ms&quot;;
            this.menu.style.transitionDuration = duration;
            this.panel.style.transitionDuration = duration;
        }
        Object.assign(this.menu.style, this.styles.open.menu);
        Object.assign(this.panel.style, this.styles.open.panel);
        var after = function () {
            _this.state.opening = false;
            _this.state.opened = true;
            Object.assign(_this.menu.style, _this.styles.open.menu);
            Object.assign(_this.panel.style, _this.styles.open.panel);
            _this.emit(&#039;opened&#039;);
        };
        if (offset === this.width) {
            after();
        }
        else {
            this.afterTransitionend(after);
        }
        return this;
    };
    /** Close the menu */
    Pulling.prototype.close = function (e) {
        var _this = this;
        this.emit(&#039;beforeclose&#039;, e);
        if (this.disabled) {
            return this;
        }
        if (this.state.closed) {
            this.state.closing = false;
            return this;
        }
        this.state.closed = false;
        this.state.closing = true;
        this.state.opening = false;
        this.state.opened = false;
        var offset = this.offset();
        if (offset &gt; 0) {
            var duration = this.timing * offset / this.width + &quot;ms&quot;;
            this.menu.style.transitionDuration = duration;
            this.panel.style.transitionDuration = duration;
        }
        Object.assign(this.menu.style, this.styles.closed.menu);
        Object.assign(this.panel.style, this.styles.closed.panel);
        var after = function () {
            _this.state.closing = false;
            _this.state.closed = true;
            Object.assign(_this.menu.style, _this.styles.closed.menu);
            Object.assign(_this.panel.style, _this.styles.closed.panel);
            if (_this.openPanelClass) {
                document.documentElement.classList.remove(_this.openPanelClass);
            }
            _this.emit(&#039;closed&#039;);
        };
        if (offset === 0) {
            after();
        }
        else {
            this.afterTransitionend(after);
        }
        return this;
    };
    Pulling.prototype.toggle = function (condition) {
        if (condition === true) {
            this.open();
        }
        else if (condition === false) {
            this.close();
        }
        else {
            this.toggle(this.state.closed || this.state.closing);
        }
        return this;
    };
    /** Disable the menu functionality */
    Pulling.prototype.disable = function () {
        this.disabled = true;
        return this;
    };
    /** Enabled to menu functionality */
    Pulling.prototype.enable = function () {
        this.disabled = false;
        return this;
    };
    Pulling.prototype.afterTransitionend = function (callback) { };
    /** get offset from the default (closed) position */
    Pulling.prototype.offset = function () {
        return 0;
    };
    Pulling.modes = {};
    return Pulling;
}());

var TouchPulling$1 = /** @class */ (function (_super) {
    __extends(TouchPulling, _super);
    function TouchPulling(options) {
        var _this = _super.call(this, options) || this;
        _this.touched = false;
        _this.ignores = [];
        _this.ignoreSelector = &#039;&#039;;
        _this.touch = options.touch !== false;
        _this.ignoreScrollables = options.ignoreScrollables !== false;
        if (_this.touch) {
            _this.addTouchEvents();
        }
        return _this;
    }
    /** set offset */
    TouchPulling.prototype.applyOffset = function (offset) { };
    TouchPulling.prototype.initTouchEvents = function () {
        var _this = this;
        // tslint:disable-next-line no-this-assignment
        var _a = this, width = _a.width, margin = _a.margin, side = _a.side, slope = _a.slope, sensitivity = _a.sensitivity, menu = _a.menu, panel = _a.panel;
        var sign = (side === &#039;left&#039; ? 1 : -1);
        var startClientX = 0;
        var startClientY = 0;
        var lastClientX = 0;
        var startOffset = 0;
        var prevTime = 0;
        var lastTime = 0;
        var prevClientX = 0;
        var firstMove = false;
        var scrollable = function (elem) {
            if (!elem ||
                elem === document.documentElement ||
                elem === document.body) {
                return false;
            }
            var _a = getComputedStyle(elem), overflowX = _a.overflowX, overflowY = _a.overflowY;
            return overflowX === &#039;auto&#039; ||
                overflowX === &#039;scroll&#039; ||
                (overflowX === &#039;visible&#039; &amp;&amp; overflowY !== &#039;visible&#039;) ||
                scrollable(elem.parentElement);
        };
        var onTouchstart = function (e) {
            var target = e.target;
            if (_this.ignoreSelector &amp;&amp; (target).matches(_this.ignoreSelector)) {
                return;
            }
            // ignore when the element is scrollable
            if (_this.ignoreScrollables &amp;&amp; scrollable(target)) {
                return;
            }
            _this.emit(&#039;touchstart&#039;, e);
            if (_this.disabled) {
                return;
            }
            _this.touched = false;
            if (e.touches.length !== 1) {
                return;
            }
            var _a = e.touches[0], clientX = _a.clientX, clientY = _a.clientY;
            var offset = _this.offset();
            var region = margin + offset;
            if (side === &#039;left&#039; &amp;&amp; clientX &lt;= region ||
                side === &#039;right&#039; &amp;&amp; window.innerWidth - clientX &lt;= region) {
                _this.touched = true;
                startClientX = clientX;
                startClientY = clientY;
                lastClientX = clientX;
                startOffset = offset;
                lastTime = Date.now();
                firstMove = true;
            }
        };
        var onTouchmove = function (e) {
            _this.emit(&#039;touchmove&#039;, e);
            if (_this.disabled || !_this.touched) {
                return;
            }
            var _a = e.touches[0], clientX = _a.clientX, clientY = _a.clientY;
            var diffX = (clientX - startClientX) * sign;
            if (Math.abs(diffX) &lt; 10) {
                return;
            }
            if (firstMove) {
                var diffY = clientY - startClientY;
                var currentSlope = Math.abs(diffY / diffX);
                if (currentSlope &gt; slope) {
                    _this.touched = false;
                    return;
                }
                if (_this.state.closed &amp;&amp; diffX &gt; 0) {
                    _this.emit(&#039;beforeopen&#039;);
                }
                else if (_this.state.opened) {
                    _this.emit(&#039;beforeopen&#039;);
                }
                menu.style.transition = &#039;&#039;;
                panel.style.transition = &#039;&#039;;
            }
            if (_this.state.opened &amp;&amp; diffX &gt; 0 || _this.state.closed &amp;&amp; diffX &lt; 0) {
                lastClientX = clientX;
                lastTime = Date.now();
                return;
            }
            _this.state.opened = false;
            _this.state.closed = false;
            var dx = (clientX - lastClientX) * sign;
            var opening = dx &gt; 0;
            _this.state.opening = opening;
            _this.state.closing = !opening;
            var offset = Math.min(Math.max(0, startOffset + diffX), width);
            _this.applyOffset(offset);
            prevClientX = lastClientX;
            lastClientX = clientX;
            prevTime = lastTime;
            lastTime = Date.now();
            firstMove = false;
        };
        var onTouchend = function (e) {
            if (!_this.touched) {
                return;
            }
            _this.touched = false;
            if (firstMove) {
                return;
            }
            _this.emit(&#039;touchend&#039;, e);
            Object.assign(_this.panel.style, _this.styles.base.panel);
            Object.assign(_this.menu.style, _this.styles.base.menu);
            var offset = _this.offset();
            var clientX = e.changedTouches[0].clientX;
            var x1;
            var t1;
            if (clientX === lastClientX) {
                x1 = prevClientX;
                t1 = prevTime;
            }
            else {
                x1 = lastClientX;
                t1 = lastTime;
            }
            var x2 = clientX;
            var t2 = Date.now();
            var speed = (x2 - x1) / (t2 - t1) * sign;
            if (offset &gt; width / 2 &amp;&amp;
                speed &gt; -sensitivity ||
                speed &gt; sensitivity) {
                _this.open(e);
            }
            else {
                _this.close(e);
            }
        };
        return {
            onTouchstart: onTouchstart,
            onTouchmove: onTouchmove,
            onTouchend: onTouchend,
        };
    };
    TouchPulling.prototype.addTouchEvents = function () {
        if (!this.touchEvents) {
            this.touchEvents = this.initTouchEvents();
        }
        document.documentElement.addEventListener(&#039;touchstart&#039;, this.touchEvents.onTouchstart, false);
        document.documentElement.addEventListener(&#039;touchmove&#039;, this.touchEvents.onTouchmove, false);
        document.documentElement.addEventListener(&#039;touchend&#039;, this.touchEvents.onTouchend, false);
    };
    TouchPulling.prototype.removeTouchEvents = function () {
        document.documentElement.removeEventListener(&#039;touchstart&#039;, this.touchEvents.onTouchstart);
        document.documentElement.removeEventListener(&#039;touchmove&#039;, this.touchEvents.onTouchmove);
        document.documentElement.removeEventListener(&#039;touchend&#039;, this.touchEvents.onTouchend);
    };
    /** Ignore touch events from elements matching a given selector */
    TouchPulling.prototype.ignore = function (selector) {
        this.ignores.push(selector);
        this.ignoreSelector = this.ignores.join(&#039;, &#039;);
        return this;
    };
    /**
     * Remove selector from ignore list
     * _Does not_ override `ignore`
     */
    TouchPulling.prototype.unignore = function (selector) {
        this.ignores = this.ignores.filter(function (s) { return s !== selector; });
        this.ignoreSelector = this.ignores.join(&#039;, &#039;);
        return this;
    };
    /** enable touch functionality */
    TouchPulling.prototype.enableTouch = function () {
        if (!this.touch) {
            this.addTouchEvents();
            this.touch = true;
        }
        return this;
    };
    /** disable touch functionality */
    TouchPulling.prototype.disableTouch = function () {
        if (this.touch) {
            this.removeTouchEvents();
            this.touch = false;
        }
        return this;
    };
    return TouchPulling;
}(Pulling));

var Reveal = /** @class */ (function (_super) {
    __extends(Reveal, _super);
    function Reveal(options) {
        var _a;
        var _this = _super.call(this, options) || this;
        _this.styles.base.menu = (_a = {
                overflowX: &#039;hidden&#039;,
                overflowY: &#039;auto&#039;,
                position: &#039;fixed&#039;
            }, _a[_this.side] = &#039;0&#039;, _a.top = &#039;0&#039;, _a.bottom = &#039;0&#039;, _a.width = _this.width + &quot;px&quot;, _a);
        _this.styles.base.panel = {
            transition: &quot;transform &quot; + _this.timing + &quot;ms &quot; + _this.timingFunction,
        };
        _this.styles.open.panel = {
            transform: &quot;translateX(&quot; + (_this.side === &#039;right&#039; ? &#039;-&#039; : &#039;&#039;) + _this.width + &quot;px)&quot;,
        };
        _this.styles.closed.panel = {
            transform: &quot;translateX(0)&quot;,
        };
        Object.assign(_this.menu.style, _this.styles.base.menu, _this.styles.closed.menu);
        Object.assign(_this.panel.style, _this.styles.base.panel, _this.styles.closed.panel);
        _this.initTransitionend();
        return _this;
    }
    Reveal.prototype.offset = function () {
        var panelPos = this.panel.getBoundingClientRect();
        return Math.abs(panelPos.left);
    };
    Reveal.prototype.applyOffset = function (offset) {
        var sign = (this.side === &#039;left&#039; ? 1 : -1);
        this.panel.style.transform = &quot;translateX(&quot; + offset * sign + &quot;px)&quot;;
    };
    Reveal.prototype.afterTransitionend = function (callback) {
        this.onTransitionend = callback;
    };
    Reveal.prototype.initTransitionend = function () {
        var _this = this;
        this.panel.addEventListener(&#039;transitionend&#039;, function () {
            if (_this.onTransitionend) {
                _this.onTransitionend();
            }
            _this.onTransitionend = null;
        }, false);
    };
    return Reveal;
}(TouchPulling$1));
TouchPulling$1.modes[&#039;reveal&#039;] = Reveal;

var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer(options) {
        var _a;
        var _this = _super.call(this, options) || this;
        _this.styles.base.menu = (_a = {
                transition: &quot;transform &quot; + _this.timing + &quot;ms &quot; + _this.timingFunction,
                overflowX: &#039;hidden&#039;,
                overflowY: &#039;auto&#039;,
                position: &#039;fixed&#039;
            }, _a[_this.side] = &quot;-&quot; + _this.width + &quot;px&quot;, _a.top = &#039;0&#039;, _a.bottom = &#039;0&#039;, _a.width = _this.width + &quot;px&quot;, _a.zIndex = &#039;1&#039;, _a);
        _this.styles.open.menu = {
            transform: &quot;translateX(&quot; + (_this.side === &#039;right&#039; ? &#039;-&#039; : &#039;&#039;) + _this.width + &quot;px)&quot;,
        };
        _this.styles.closed.menu = {
            transform: &quot;translateX(0)&quot;,
        };
        Object.assign(_this.menu.style, _this.styles.base.menu, _this.styles.closed.menu);
        Object.assign(_this.panel.style, _this.styles.base.panel, _this.styles.closed.panel);
        _this.initTransitionend();
        return _this;
    }
    Drawer.prototype.offset = function () {
        var menuPos = this.menu.getBoundingClientRect();
        if (this.side === &#039;left&#039;) {
            return menuPos.left + this.width;
        }
        return window.innerWidth - menuPos.left;
    };
    Drawer.prototype.applyOffset = function (offset) {
        var sign = (this.side === &#039;left&#039; ? 1 : -1);
        this.menu.style.transform = &quot;translateX(&quot; + offset * sign + &quot;px)&quot;;
    };
    Drawer.prototype.afterTransitionend = function (callback) {
        this.onTransitionend = callback;
    };
    Drawer.prototype.initTransitionend = function () {
        var _this = this;
        this.menu.addEventListener(&#039;transitionend&#039;, function () {
            if (_this.onTransitionend) {
                _this.onTransitionend();
            }
            _this.onTransitionend = null;
        }, false);
    };
    return Drawer;
}(TouchPulling$1));
TouchPulling$1.modes[&#039;drawer&#039;] = Drawer;

polyfill();

return TouchPulling$1;

})));
//# sourceMappingURL=pulling.js.map
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
