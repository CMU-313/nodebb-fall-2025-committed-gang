<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/pkijs/build/CertificateChainValidationEngine.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/pkijs/build/CertificateChainValidationEngine.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">45.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1748</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">207.23</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

Object.defineProperty(exports, &quot;__esModule&quot;, {
	value: true
});

var _pvutils = require(&quot;pvutils&quot;);

var _common = require(&quot;./common.js&quot;);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(&quot;next&quot;, value); }, function (err) { step(&quot;throw&quot;, err); }); } } return step(&quot;next&quot;); }); }; }

//**************************************************************************************
class CertificateChainValidationEngine {
	//**********************************************************************************
	/**
  * Constructor for CertificateChainValidationEngine class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	constructor(parameters = {}) {
		//region Internal properties of the object
		/**
   * @type {Array.&lt;Certificate&gt;}
   * @description Array of pre-defined trusted (by user) certificates
   */
		this.trustedCerts = (0, _pvutils.getParametersValue)(parameters, &quot;trustedCerts&quot;, this.defaultValues(&quot;trustedCerts&quot;));
		/**
   * @type {Array.&lt;Certificate&gt;}
   * @description Array with certificate chain. Could be only one end-user certificate in there!
   */
		this.certs = (0, _pvutils.getParametersValue)(parameters, &quot;certs&quot;, this.defaultValues(&quot;certs&quot;));
		/**
   * @type {Array.&lt;CertificateRevocationList&gt;}
   * @description Array of all CRLs for all certificates from certificate chain
   */
		this.crls = (0, _pvutils.getParametersValue)(parameters, &quot;crls&quot;, this.defaultValues(&quot;crls&quot;));
		/**
   * @type {Array}
   * @description Array of all OCSP responses
   */
		this.ocsps = (0, _pvutils.getParametersValue)(parameters, &quot;ocsps&quot;, this.defaultValues(&quot;ocsps&quot;));
		/**
   * @type {Date}
   * @description The date at which the check would be
   */
		this.checkDate = (0, _pvutils.getParametersValue)(parameters, &quot;checkDate&quot;, this.defaultValues(&quot;checkDate&quot;));
		/**
   * @type {Function}
   * @description The date at which the check would be
   */
		this.findOrigin = (0, _pvutils.getParametersValue)(parameters, &quot;findOrigin&quot;, this.defaultValues(&quot;findOrigin&quot;));
		/**
   * @type {Function}
   * @description The date at which the check would be
   */
		this.findIssuer = (0, _pvutils.getParametersValue)(parameters, &quot;findIssuer&quot;, this.defaultValues(&quot;findIssuer&quot;));
		//endregion
	}
	//**********************************************************************************
	static defaultFindOrigin(certificate, validationEngine) {
		//region Firstly encode TBS for certificate
		if (certificate.tbs.byteLength === 0) certificate.tbs = certificate.encodeTBS();
		//endregion

		//region Search in Intermediate Certificates
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = validationEngine.certs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				const localCert = _step.value;

				//region Firstly encode TBS for certificate
				if (localCert.tbs.byteLength === 0) localCert.tbs = localCert.encodeTBS();
				//endregion

				if ((0, _pvutils.isEqualBuffer)(certificate.tbs, localCert.tbs)) return &quot;Intermediate Certificates&quot;;
			}
			//endregion

			//region Search in Trusted Certificates
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = validationEngine.trustedCerts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				const trustedCert = _step2.value;

				//region Firstly encode TBS for certificate
				if (trustedCert.tbs.byteLength === 0) trustedCert.tbs = trustedCert.encodeTBS();
				//endregion

				if ((0, _pvutils.isEqualBuffer)(certificate.tbs, trustedCert.tbs)) return &quot;Trusted Certificates&quot;;
			}
			//endregion
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		return &quot;Unknown&quot;;
	}
	//**********************************************************************************
	defaultFindIssuer(certificate, validationEngine) {
		return _asyncToGenerator(function* () {
			//region Initial variables
			let result = [];

			let keyIdentifier = null;

			let authorityCertIssuer = null;
			let authorityCertSerialNumber = null;
			//endregion

			//region Speed-up searching in case of self-signed certificates
			if (certificate.subject.isEqual(certificate.issuer)) {
				try {
					const verificationResult = yield certificate.verify();
					if (verificationResult === true) return [certificate];
				} catch (ex) {}
			}
			//endregion

			//region Find values to speed-up search
			if (&quot;extensions&quot; in certificate) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = certificate.extensions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						const extension = _step3.value;

						if (extension.extnID === &quot;2.5.29.35&quot;) // AuthorityKeyIdentifier
							{
								if (&quot;keyIdentifier&quot; in extension.parsedValue) keyIdentifier = extension.parsedValue.keyIdentifier;else {
									if (&quot;authorityCertIssuer&quot; in extension.parsedValue) authorityCertIssuer = extension.parsedValue.authorityCertIssuer;

									if (&quot;authorityCertSerialNumber&quot; in extension.parsedValue) authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
								}

								break;
							}
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}
			//endregion

			//region Aux function
			function checkCertificate(possibleIssuer) {
				//region Firstly search for appropriate extensions
				if (keyIdentifier !== null) {
					if (&quot;extensions&quot; in possibleIssuer) {
						let extensionFound = false;

						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;

						try {
							for (var _iterator4 = possibleIssuer.extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								const extension = _step4.value;

								if (extension.extnID === &quot;2.5.29.14&quot;) // SubjectKeyIdentifier
									{
										extensionFound = true;

										if ((0, _pvutils.isEqualBuffer)(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex)) result.push(possibleIssuer);

										break;
									}
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) {
									_iterator4.return();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}

						if (extensionFound) return;
					}
				}
				//endregion

				//region Now search for authorityCertSerialNumber
				let authorityCertSerialNumberEqual = false;

				if (authorityCertSerialNumber !== null) authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
				//endregion

				//region And at least search for Issuer data
				if (authorityCertIssuer !== null) {
					if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
						if (authorityCertSerialNumberEqual) result.push(possibleIssuer);
					}
				} else {
					if (certificate.issuer.isEqual(possibleIssuer.subject)) result.push(possibleIssuer);
				}
				//endregion
			}
			//endregion

			//region Search in Trusted Certificates
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = validationEngine.trustedCerts[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					const trustedCert = _step5.value;

					checkCertificate(trustedCert);
				} //endregion

				//region Search in Intermediate Certificates
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = validationEngine.certs[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					const intermediateCert = _step6.value;

					checkCertificate(intermediateCert);
				} //endregion

				//region Now perform certificate verification checking
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 &amp;&amp; _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			for (let i = 0; i &lt; result.length; i++) {
				try {
					const verificationResult = yield certificate.verify(result[i]);
					if (verificationResult === false) result.splice(i, 1);
				} catch (ex) {
					result.splice(i, 1); // Something wrong, remove the certificate
				}
			}
			//endregion

			return result;
		})();
	}
	//**********************************************************************************
	/**
  * Return default values for all class members
  * @param {string} memberName String name for a class member
  */
	defaultValues(memberName) {
		switch (memberName) {
			case &quot;trustedCerts&quot;:
				return [];
			case &quot;certs&quot;:
				return [];
			case &quot;crls&quot;:
				return [];
			case &quot;ocsps&quot;:
				return [];
			case &quot;checkDate&quot;:
				return new Date();
			case &quot;findOrigin&quot;:
				return CertificateChainValidationEngine.defaultFindOrigin;
			case &quot;findIssuer&quot;:
				return this.defaultFindIssuer;
			default:
				throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
		}
	}
	//**********************************************************************************
	sort() {
		var _this2 = this;

		return _asyncToGenerator(function* () {
			//endregion

			//region Building certificate path
			let buildPath = (() =&gt; {
				var _ref = _asyncToGenerator(function* (certificate) {
					const result = [];

					//region Aux function checking array for unique elements
					function checkUnique(array) {
						let unique = true;

						for (let i = 0; i &lt; array.length; i++) {
							for (let j = 0; j &lt; array.length; j++) {
								if (j === i) continue;

								if (array[i] === array[j]) {
									unique = false;
									break;
								}
							}

							if (!unique) break;
						}

						return unique;
					}

					//endregion

					const findIssuerResult = yield _this.findIssuer(certificate, _this);
					if (findIssuerResult.length === 0) throw new Error(&quot;No valid certificate paths found&quot;);

					for (let i = 0; i &lt; findIssuerResult.length; i++) {
						if ((0, _pvutils.isEqualBuffer)(findIssuerResult[i].tbs, certificate.tbs)) {
							result.push([findIssuerResult[i]]);
							continue;
						}

						const buildPathResult = yield buildPath(findIssuerResult[i]);

						for (let j = 0; j &lt; buildPathResult.length; j++) {
							const copy = buildPathResult[j].slice();
							copy.splice(0, 0, findIssuerResult[i]);

							if (checkUnique(copy)) result.push(copy);else result.push(buildPathResult[j]);
						}
					}

					return result;
				});

				return function buildPath(_x) {
					return _ref.apply(this, arguments);
				};
			})();
			//endregion

			//region Find CRL for specific certificate


			let findCRL = (() =&gt; {
				var _ref2 = _asyncToGenerator(function* (certificate) {
					//region Initial variables
					const issuerCertificates = [];
					const crls = [];
					const crlsAndCertificates = [];
					//endregion

					//region Find all possible CRL issuers
					issuerCertificates.push(...localCerts.filter(function (element) {
						return certificate.issuer.isEqual(element.subject);
					}));
					if (issuerCertificates.length === 0) {
						return {
							status: 1,
							statusMessage: &quot;No certificate&#039;s issuers&quot;
						};
					}
					//endregion

					//region Find all CRLs for crtificate&#039;s issuer
					crls.push(..._this.crls.filter(function (element) {
						return element.issuer.isEqual(certificate.issuer);
					}));
					if (crls.length === 0) {
						return {
							status: 1,
							statusMessage: &quot;No CRLs for specific certificate issuer&quot;
						};
					}
					//endregion

					//region Find specific certificate of issuer for each CRL
					for (let i = 0; i &lt; crls.length; i++) {
						//region Check &quot;nextUpdate&quot; for the CRL
						// The &quot;nextUpdate&quot; is older than &quot;checkDate&quot;.
						// Thus we should do have another, updated CRL.
						// Thus the CRL assumed to be invalid.
						if (crls[i].nextUpdate.value &lt; _this.checkDate) continue;
						//endregion

						for (let j = 0; j &lt; issuerCertificates.length; j++) {
							try {
								const result = yield crls[i].verify({ issuerCertificate: issuerCertificates[j] });
								if (result) {
									crlsAndCertificates.push({
										crl: crls[i],
										certificate: issuerCertificates[j]
									});

									break;
								}
							} catch (ex) {}
						}
					}
					//endregion

					if (crlsAndCertificates.length) {
						return {
							status: 0,
							statusMessage: &quot;&quot;,
							result: crlsAndCertificates
						};
					}

					return {
						status: 1,
						statusMessage: &quot;No valid CRLs found&quot;
					};
				});

				return function findCRL(_x2) {
					return _ref2.apply(this, arguments);
				};
			})();
			//endregion

			//region Find OCSP for specific certificate


			let findOCSP = (() =&gt; {
				var _ref3 = _asyncToGenerator(function* (certificate, issuerCertificate) {
					//region Get hash algorithm from certificate
					const hashAlgorithm = (0, _common.getAlgorithmByOID)(certificate.signatureAlgorithm.algorithmId);
					if (&quot;name&quot; in hashAlgorithm === false) return 1;
					if (&quot;hash&quot; in hashAlgorithm === false) return 1;
					//endregion

					//region Search for OCSP response for the certificate
					for (let i = 0; i &lt; _this.ocsps.length; i++) {
						const result = yield _this.ocsps[i].getCertificateStatus(certificate, issuerCertificate);
						if (result.isForCertificate) {
							if (result.status === 0) return 0;

							return 1;
						}
					}
					//endregion

					return 2;
				});

				return function findOCSP(_x3, _x4) {
					return _ref3.apply(this, arguments);
				};
			})();
			//endregion

			//region Check for certificate to be CA


			let checkForCA = (() =&gt; {
				var _ref4 = _asyncToGenerator(function* (certificate, needToCheckCRL = false) {
					//region Initial variables
					let isCA = false;
					let mustBeCA = false;
					let keyUsagePresent = false;
					let cRLSign = false;
					//endregion

					if (&quot;extensions&quot; in certificate) {
						for (let j = 0; j &lt; certificate.extensions.length; j++) {
							if (certificate.extensions[j].critical === true &amp;&amp; &quot;parsedValue&quot; in certificate.extensions[j] === false) {
								return {
									result: false,
									resultCode: 6,
									resultMessage: `Unable to parse critical certificate extension: ${certificate.extensions[j].extnID}`
								};
							}

							if (certificate.extensions[j].extnID === &quot;2.5.29.15&quot;) // KeyUsage
								{
									keyUsagePresent = true;

									const view = new Uint8Array(certificate.extensions[j].parsedValue.valueBlock.valueHex);

									if ((view[0] &amp; 0x04) === 0x04) // Set flag &quot;keyCertSign&quot;
										mustBeCA = true;

									if ((view[0] &amp; 0x02) === 0x02) // Set flag &quot;cRLSign&quot;
										cRLSign = true;
								}

							if (certificate.extensions[j].extnID === &quot;2.5.29.19&quot;) // BasicConstraints
								{
									if (&quot;cA&quot; in certificate.extensions[j].parsedValue) {
										if (certificate.extensions[j].parsedValue.cA === true) isCA = true;
									}
								}
						}

						if (mustBeCA === true &amp;&amp; isCA === false) {
							return {
								result: false,
								resultCode: 3,
								resultMessage: &quot;Unable to build certificate chain - using \&quot;keyCertSign\&quot; flag set without BasicConstaints&quot;
							};
						}

						if (keyUsagePresent === true &amp;&amp; isCA === true &amp;&amp; mustBeCA === false) {
							return {
								result: false,
								resultCode: 4,
								resultMessage: &quot;Unable to build certificate chain - \&quot;keyCertSign\&quot; flag was not set&quot;
							};
						}

						// noinspection OverlyComplexBooleanExpressionJS
						if (isCA === true &amp;&amp; keyUsagePresent === true &amp;&amp; needToCheckCRL &amp;&amp; cRLSign === false) {
							return {
								result: false,
								resultCode: 5,
								resultMessage: &quot;Unable to build certificate chain - intermediate certificate must have \&quot;cRLSign\&quot; key usage flag&quot;
							};
						}
					}

					if (isCA === false) {
						return {
							result: false,
							resultCode: 7,
							resultMessage: &quot;Unable to build certificate chain - more than one possible end-user certificate&quot;
						};
					}

					return {
						result: true,
						resultCode: 0,
						resultMessage: &quot;&quot;
					};
				});

				return function checkForCA(_x5) {
					return _ref4.apply(this, arguments);
				};
			})();
			//endregion

			//region Basic check for certificate path


			let basicCheck = (() =&gt; {
				var _ref5 = _asyncToGenerator(function* (path, checkDate) {
					//region Check that all dates are valid
					for (let i = 0; i &lt; path.length; i++) {
						if (path[i].notBefore.value &gt; checkDate || path[i].notAfter.value &lt; checkDate) {
							return {
								result: false,
								resultCode: 8,
								resultMessage: &quot;The certificate is either not yet valid or expired&quot;
							};
						}
					}
					//endregion

					//region Check certificate name chain

					// We should have at least two certificates: end entity and trusted root
					if (path.length &lt; 2) {
						return {
							result: false,
							resultCode: 9,
							resultMessage: &quot;Too short certificate path&quot;
						};
					}

					for (let i = path.length - 2; i &gt;= 0; i--) {
						//region Check that we do not have a &quot;self-signed&quot; certificate
						if (path[i].issuer.isEqual(path[i].subject) === false) {
							if (path[i].issuer.isEqual(path[i + 1].subject) === false) {
								return {
									result: false,
									resultCode: 10,
									resultMessage: &quot;Incorrect name chaining&quot;
								};
							}
						}
						//endregion
					}
					//endregion

					//region Check each certificate (except &quot;trusted root&quot;) to be non-revoked
					if (_this.crls.length !== 0 || _this.ocsps.length !== 0) // If CRLs and OCSPs are empty then we consider all certificates to be valid
						{
							for (let i = 0; i &lt; path.length - 2; i++) {
								//region Initial variables
								let ocspResult;
								let crlResult;
								//endregion

								//region Check OCSPs first
								if (_this.ocsps.length !== 0) {
									ocspResult = yield findOCSP(path[i], path[i + 1]);

									switch (ocspResult) {
										case 0:
											continue;
										case 1:
											return {
												result: false,
												resultCode: 12,
												resultMessage: &quot;One of certificates was revoked via OCSP response&quot;
											};
										case 2:
											// continue to check the certificate with CRL
											break;
										default:
									}
								}
								//endregion

								//region Check CRLs
								if (_this.crls.length !== 0) {
									crlResult = yield findCRL(path[i]);
									if (crlResult.status) {
										throw {
											result: false,
											resultCode: 11,
											resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
										};
									}

									for (let j = 0; j &lt; crlResult.result.length; j++) {
										//region Check that the CRL issuer certificate have not been revoked
										const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[i]);
										if (isCertificateRevoked) {
											return {
												result: false,
												resultCode: 12,
												resultMessage: &quot;One of certificates had been revoked&quot;
											};
										}
										//endregion

										//region Check that the CRL issuer certificate is a CA certificate
										const isCertificateCA = yield checkForCA(crlResult.result[j].certificate, true);
										if (isCertificateCA.result === false) {
											return {
												result: false,
												resultCode: 13,
												resultMessage: &quot;CRL issuer certificate is not a CA certificate or does not have crlSign flag&quot;
											};
										}
										//endregion
									}
								} else {
									if (ocspResult === 2) {
										return {
											result: false,
											resultCode: 11,
											resultMessage: &quot;No revocation values found for one of certificates&quot;
										};
									}
								}
								//endregion
							}
						}
					//endregion

					//region Check each certificate (except &quot;end entity&quot;) in the path to be a CA certificate
					for (let i = 1; i &lt; path.length; i++) {
						const result = yield checkForCA(path[i]);
						if (result.result === false) {
							return {
								result: false,
								resultCode: 14,
								resultMessage: &quot;One of intermediate certificates is not a CA certificate&quot;
							};
						}
					}
					//endregion

					return {
						result: true
					};
				});

				return function basicCheck(_x6, _x7) {
					return _ref5.apply(this, arguments);
				};
			})();
			//endregion

			//region Do main work
			//region Initialize &quot;localCerts&quot; by value of &quot;_this.certs&quot; + &quot;_this.trustedCerts&quot; arrays


			//region Initial variables
			const localCerts = [];
			const _this = _this2;localCerts.push(..._this.trustedCerts);
			localCerts.push(..._this.certs);
			//endregion

			//region Check all certificates for been unique
			for (let i = 0; i &lt; localCerts.length; i++) {
				for (let j = 0; j &lt; localCerts.length; j++) {
					if (i === j) continue;

					if ((0, _pvutils.isEqualBuffer)(localCerts[i].tbs, localCerts[j].tbs)) {
						localCerts.splice(j, 1);
						i = 0;
						break;
					}
				}
			}
			//endregion

			//region Initial variables
			let result;
			const certificatePath = [localCerts[localCerts.length - 1]]; // The &quot;end entity&quot; certificate must be the least in &quot;certs&quot; array
			//endregion

			//region Build path for &quot;end entity&quot; certificate
			result = yield buildPath(localCerts[localCerts.length - 1]);
			if (result.length === 0) {
				return {
					result: false,
					resultCode: 60,
					resultMessage: &quot;Unable to find certificate path&quot;
				};
			}
			//endregion

			//region Exclude certificate paths not ended with &quot;trusted roots&quot;
			for (let i = 0; i &lt; result.length; i++) {
				let found = false;

				for (let j = 0; j &lt; result[i].length; j++) {
					const certificate = result[i][j];

					for (let k = 0; k &lt; _this.trustedCerts.length; k++) {
						if ((0, _pvutils.isEqualBuffer)(certificate.tbs, _this.trustedCerts[k].tbs)) {
							found = true;
							break;
						}
					}

					if (found) break;
				}

				if (!found) {
					result.splice(i, 1);
					i = 0;
				}
			}

			if (result.length === 0) {
				throw {
					result: false,
					resultCode: 97,
					resultMessage: &quot;No valid certificate paths found&quot;
				};
			}
			//endregion

			//region Find shortest certificate path (for the moment it is the only criteria)
			let shortestLength = result[0].length;
			let shortestIndex = 0;

			for (let i = 0; i &lt; result.length; i++) {
				if (result[i].length &lt; shortestLength) {
					shortestLength = result[i].length;
					shortestIndex = i;
				}
			}
			//endregion

			//region Create certificate path for basic check
			for (let i = 0; i &lt; result[shortestIndex].length; i++) certificatePath.push(result[shortestIndex][i]);
			//endregion

			//region Perform basic checking for all certificates in the path
			result = yield basicCheck(certificatePath, _this.checkDate);
			if (result.result === false) throw result;
			//endregion

			return certificatePath;
			//endregion
		})();
	}
	//**********************************************************************************
	/**
  * Major verification function for certificate chain.
  * @param {{initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms}} [parameters]
  * @returns {Promise}
  */
	verify(parameters = {}) {
		var _this3 = this;

		return _asyncToGenerator(function* () {
			//region Auxiliary functions for name constraints checking
			function compareDNSName(name, constraint) {
				/// &lt;summary&gt;Compare two dNSName values&lt;/summary&gt;
				/// &lt;param name=&quot;name&quot; type=&quot;String&quot;&gt;DNS from name&lt;/param&gt;
				/// &lt;param name=&quot;constraint&quot; type=&quot;String&quot;&gt;Constraint for DNS from name&lt;/param&gt;
				/// &lt;returns type=&quot;Boolean&quot;&gt;Boolean result - valid or invalid the &quot;name&quot; against the &quot;constraint&quot;&lt;/returns&gt;

				//region Make a &quot;string preparation&quot; for both name and constrain
				const namePrepared = (0, _common.stringPrep)(name);
				const constraintPrepared = (0, _common.stringPrep)(constraint);
				//endregion

				//region Make a &quot;splitted&quot; versions of &quot;constraint&quot; and &quot;name&quot;
				const nameSplitted = namePrepared.split(&quot;.&quot;);
				const constraintSplitted = constraintPrepared.split(&quot;.&quot;);
				//endregion

				//region Length calculation and additional check
				const nameLen = nameSplitted.length;
				const constrLen = constraintSplitted.length;

				if (nameLen === 0 || constrLen === 0 || nameLen &lt; constrLen) return false;
				//endregion

				//region Check that no part of &quot;name&quot; has zero length
				for (let i = 0; i &lt; nameLen; i++) {
					if (nameSplitted[i].length === 0) return false;
				}
				//endregion

				//region Check that no part of &quot;constraint&quot; has zero length
				for (let i = 0; i &lt; constrLen; i++) {
					if (constraintSplitted[i].length === 0) {
						if (i === 0) {
							if (constrLen === 1) return false;

							continue;
						}

						return false;
					}
				}
				//endregion

				//region Check that &quot;name&quot; has a tail as &quot;constraint&quot;

				for (let i = 0; i &lt; constrLen; i++) {
					if (constraintSplitted[constrLen - 1 - i].length === 0) continue;

					if (nameSplitted[nameLen - 1 - i].localeCompare(constraintSplitted[constrLen - 1 - i]) !== 0) return false;
				}
				//endregion

				return true;
			}

			function compareRFC822Name(name, constraint) {
				/// &lt;summary&gt;Compare two rfc822Name values&lt;/summary&gt;
				/// &lt;param name=&quot;name&quot; type=&quot;String&quot;&gt;E-mail address from name&lt;/param&gt;
				/// &lt;param name=&quot;constraint&quot; type=&quot;String&quot;&gt;Constraint for e-mail address from name&lt;/param&gt;
				/// &lt;returns type=&quot;Boolean&quot;&gt;Boolean result - valid or invalid the &quot;name&quot; against the &quot;constraint&quot;&lt;/returns&gt;

				//region Make a &quot;string preparation&quot; for both name and constrain
				const namePrepared = (0, _common.stringPrep)(name);
				const constraintPrepared = (0, _common.stringPrep)(constraint);
				//endregion

				//region Make a &quot;splitted&quot; versions of &quot;constraint&quot; and &quot;name&quot;
				const nameSplitted = namePrepared.split(&quot;@&quot;);
				const constraintSplitted = constraintPrepared.split(&quot;@&quot;);
				//endregion

				//region Splitted array length checking
				if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length &lt; constraintSplitted.length) return false;
				//endregion

				if (constraintSplitted.length === 1) {
					const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);

					if (result) {
						//region Make a &quot;splitted&quot; versions of domain name from &quot;constraint&quot; and &quot;name&quot;
						const ns = nameSplitted[1].split(&quot;.&quot;);
						const cs = constraintSplitted[0].split(&quot;.&quot;);
						//endregion

						if (cs[0].length === 0) return true;

						return ns.length === cs.length;
					}

					return false;
				}

				return namePrepared.localeCompare(constraintPrepared) === 0;
			}

			function compareUniformResourceIdentifier(name, constraint) {
				/// &lt;summary&gt;Compare two uniformResourceIdentifier values&lt;/summary&gt;
				/// &lt;param name=&quot;name&quot; type=&quot;String&quot;&gt;uniformResourceIdentifier from name&lt;/param&gt;
				/// &lt;param name=&quot;constraint&quot; type=&quot;String&quot;&gt;Constraint for uniformResourceIdentifier from name&lt;/param&gt;
				/// &lt;returns type=&quot;Boolean&quot;&gt;Boolean result - valid or invalid the &quot;name&quot; against the &quot;constraint&quot;&lt;/returns&gt;

				//region Make a &quot;string preparation&quot; for both name and constrain
				let namePrepared = (0, _common.stringPrep)(name);
				const constraintPrepared = (0, _common.stringPrep)(constraint);
				//endregion

				//region Find out a major URI part to compare with
				const ns = namePrepared.split(&quot;/&quot;);
				const cs = constraintPrepared.split(&quot;/&quot;);

				if (cs.length &gt; 1) // Malformed constraint
					return false;

				if (ns.length &gt; 1) // Full URI string
					{
						for (let i = 0; i &lt; ns.length; i++) {
							if (ns[i].length &gt; 0 &amp;&amp; ns[i].charAt(ns[i].length - 1) !== &quot;:&quot;) {
								const nsPort = ns[i].split(&quot;:&quot;);
								namePrepared = nsPort[0];
								break;
							}
						}
					}
				//endregion

				const result = compareDNSName(namePrepared, constraintPrepared);

				if (result) {
					//region Make a &quot;splitted&quot; versions of &quot;constraint&quot; and &quot;name&quot;
					const nameSplitted = namePrepared.split(&quot;.&quot;);
					const constraintSplitted = constraintPrepared.split(&quot;.&quot;);
					//endregion

					if (constraintSplitted[0].length === 0) return true;

					return nameSplitted.length === constraintSplitted.length;
				}

				return false;
			}

			function compareIPAddress(name, constraint) {
				/// &lt;summary&gt;Compare two iPAddress values&lt;/summary&gt;
				/// &lt;param name=&quot;name&quot; type=&quot;in_window.org.pkijs.asn1.OCTETSTRING&quot;&gt;iPAddress from name&lt;/param&gt;
				/// &lt;param name=&quot;constraint&quot; type=&quot;in_window.org.pkijs.asn1.OCTETSTRING&quot;&gt;Constraint for iPAddress from name&lt;/param&gt;
				/// &lt;returns type=&quot;Boolean&quot;&gt;Boolean result - valid or invalid the &quot;name&quot; against the &quot;constraint&quot;&lt;/returns&gt;

				//region Common variables
				const nameView = new Uint8Array(name.valueBlock.valueHex);
				const constraintView = new Uint8Array(constraint.valueBlock.valueHex);
				//endregion

				//region Work with IPv4 addresses
				if (nameView.length === 4 &amp;&amp; constraintView.length === 8) {
					for (let i = 0; i &lt; 4; i++) {
						if ((nameView[i] ^ constraintView[i]) &amp; constraintView[i + 4]) return false;
					}

					return true;
				}
				//endregion

				//region Work with IPv6 addresses
				if (nameView.length === 16 &amp;&amp; constraintView.length === 32) {
					for (let i = 0; i &lt; 16; i++) {
						if ((nameView[i] ^ constraintView[i]) &amp; constraintView[i + 16]) return false;
					}

					return true;
				}
				//endregion

				return false;
			}

			function compareDirectoryName(name, constraint) {
				/// &lt;summary&gt;Compare two directoryName values&lt;/summary&gt;
				/// &lt;param name=&quot;name&quot; type=&quot;in_window.org.pkijs.simpl.RDN&quot;&gt;directoryName from name&lt;/param&gt;
				/// &lt;param name=&quot;constraint&quot; type=&quot;in_window.org.pkijs.simpl.RDN&quot;&gt;Constraint for directoryName from name&lt;/param&gt;
				/// &lt;param name=&quot;any&quot; type=&quot;Boolean&quot;&gt;Boolean flag - should be comparision interrupted after first match or we need to match all &quot;constraints&quot; parts&lt;/param&gt;
				/// &lt;returns type=&quot;Boolean&quot;&gt;Boolean result - valid or invalid the &quot;name&quot; against the &quot;constraint&quot;&lt;/returns&gt;

				//region Initial check
				if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0) return true;

				if (name.typesAndValues.length &lt; constraint.typesAndValues.length) return false;
				//endregion

				//region Initial variables
				let result = true;
				let nameStart = 0;
				//endregion

				for (let i = 0; i &lt; constraint.typesAndValues.length; i++) {
					let localResult = false;

					for (let j = nameStart; j &lt; name.typesAndValues.length; j++) {
						localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);

						if (name.typesAndValues[j].type === constraint.typesAndValues[i].type) result = result &amp;&amp; localResult;

						if (localResult === true) {
							if (nameStart === 0 || nameStart === j) {
								nameStart = j + 1;
								break;
							} else // Structure of &quot;name&quot; must be the same with &quot;constraint&quot;
								return false;
						}
					}

					if (localResult === false) return false;
				}

				return nameStart === 0 ? false : result;
			}
			//endregion

			try {
				//region Initial checks
				if (_this3.certs.length === 0) throw &quot;Empty certificate array&quot;;
				//endregion

				//region Get input variables
				let initialPolicySet = [];
				initialPolicySet.push(&quot;2.5.29.32.0&quot;); // &quot;anyPolicy&quot;

				let initialExplicitPolicy = false;
				let initialPolicyMappingInhibit = false;
				let initialInhibitPolicy = false;

				let initialPermittedSubtreesSet = []; // Array of &quot;simpl.x509.GeneralSubtree&quot;
				let initialExcludedSubtreesSet = []; // Array of &quot;simpl.x509.GeneralSubtree&quot;
				let initialRequiredNameForms = []; // Array of &quot;simpl.x509.GeneralSubtree&quot;

				if (&quot;initialPolicySet&quot; in parameters) initialPolicySet = parameters.initialPolicySet;

				if (&quot;initialExplicitPolicy&quot; in parameters) initialExplicitPolicy = parameters.initialExplicitPolicy;

				if (&quot;initialPolicyMappingInhibit&quot; in parameters) initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;

				if (&quot;initialInhibitPolicy&quot; in parameters) initialInhibitPolicy = parameters.initialInhibitPolicy;

				if (&quot;initialPermittedSubtreesSet&quot; in parameters) initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;

				if (&quot;initialExcludedSubtreesSet&quot; in parameters) initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;

				if (&quot;initialRequiredNameForms&quot; in parameters) initialRequiredNameForms = parameters.initialRequiredNameForms;

				let explicitPolicyIndicator = initialExplicitPolicy;
				let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
				let inhibitAnyPolicyIndicator = initialInhibitPolicy;

				const pendingConstraints = new Array(3);
				pendingConstraints[0] = false; // For &quot;explicitPolicyPending&quot;
				pendingConstraints[1] = false; // For &quot;policyMappingInhibitPending&quot;
				pendingConstraints[2] = false; // For &quot;inhibitAnyPolicyPending&quot;

				let explicitPolicyPending = 0;
				let policyMappingInhibitPending = 0;
				let inhibitAnyPolicyPending = 0;

				let permittedSubtrees = initialPermittedSubtreesSet;
				let excludedSubtrees = initialExcludedSubtreesSet;
				const requiredNameForms = initialRequiredNameForms;

				let pathDepth = 1;
				//endregion

				//region Sorting certificates in the chain array
				_this3.certs = yield _this3.sort();
				//endregion

				//region Work with policies
				//region Support variables
				const allPolicies = []; // Array of all policies (string values)
				allPolicies.push(&quot;2.5.29.32.0&quot;); // Put &quot;anyPolicy&quot; at first place

				const policiesAndCerts = []; // In fact &quot;array of array&quot; where rows are for each specific policy, column for each certificate and value is &quot;true/false&quot;

				const anyPolicyArray = new Array(_this3.certs.length - 1); // Minus &quot;trusted anchor&quot;
				for (let ii = 0; ii &lt; _this3.certs.length - 1; ii++) anyPolicyArray[ii] = true;

				policiesAndCerts.push(anyPolicyArray);

				const policyMappings = new Array(_this3.certs.length - 1); // Array of &quot;PolicyMappings&quot; for each certificate
				const certPolicies = new Array(_this3.certs.length - 1); // Array of &quot;CertificatePolicies&quot; for each certificate

				let explicitPolicyStart = explicitPolicyIndicator ? _this3.certs.length - 1 : -1;
				//endregion

				//region Gather all neccessary information from certificate chain
				for (let i = _this3.certs.length - 2; i &gt;= 0; i--, pathDepth++) {
					if (&quot;extensions&quot; in _this3.certs[i]) {
						//region Get information about certificate extensions
						for (let j = 0; j &lt; _this3.certs[i].extensions.length; j++) {
							//region CertificatePolicies
							if (_this3.certs[i].extensions[j].extnID === &quot;2.5.29.32&quot;) {
								certPolicies[i] = _this3.certs[i].extensions[j].parsedValue;

								//region Remove entry from &quot;anyPolicies&quot; for the certificate
								for (let s = 0; s &lt; allPolicies.length; s++) {
									if (allPolicies[s] === &quot;2.5.29.32.0&quot;) {
										delete policiesAndCerts[s][i];
										break;
									}
								}
								//endregion

								for (let k = 0; k &lt; _this3.certs[i].extensions[j].parsedValue.certificatePolicies.length; k++) {
									let policyIndex = -1;

									//region Try to find extension in &quot;allPolicies&quot; array
									for (let s = 0; s &lt; allPolicies.length; s++) {
										if (_this3.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[s]) {
											policyIndex = s;
											break;
										}
									}
									//endregion

									if (policyIndex === -1) {
										allPolicies.push(_this3.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);

										const certArray = new Array(_this3.certs.length - 1);
										certArray[i] = true;

										policiesAndCerts.push(certArray);
									} else policiesAndCerts[policyIndex][i] = true;
								}
							}
							//endregion

							//region PolicyMappings
							if (_this3.certs[i].extensions[j].extnID === &quot;2.5.29.33&quot;) {
								if (policyMappingInhibitIndicator) {
									return {
										result: false,
										resultCode: 98,
										resultMessage: &quot;Policy mapping prohibited&quot;
									};
								}

								policyMappings[i] = _this3.certs[i].extensions[j].parsedValue;
							}
							//endregion

							//region PolicyConstraints
							if (_this3.certs[i].extensions[j].extnID === &quot;2.5.29.36&quot;) {
								if (explicitPolicyIndicator === false) {
									//region requireExplicitPolicy
									if (_this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy === 0) {
										explicitPolicyIndicator = true;
										explicitPolicyStart = i;
									} else {
										if (pendingConstraints[0] === false) {
											pendingConstraints[0] = true;
											explicitPolicyPending = _this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy;
										} else explicitPolicyPending = explicitPolicyPending &gt; _this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy ? _this3.certs[i].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;
									}
									//endregion

									//region inhibitPolicyMapping
									if (_this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping === 0) policyMappingInhibitIndicator = true;else {
										if (pendingConstraints[1] === false) {
											pendingConstraints[1] = true;
											policyMappingInhibitPending = _this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1;
										} else policyMappingInhibitPending = policyMappingInhibitPending &gt; _this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 ? _this3.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
									}
									//endregion
								}
							}
							//endregion

							//region InhibitAnyPolicy
							if (_this3.certs[i].extensions[j].extnID === &quot;2.5.29.54&quot;) {
								if (inhibitAnyPolicyIndicator === false) {
									if (_this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec === 0) inhibitAnyPolicyIndicator = true;else {
										if (pendingConstraints[2] === false) {
											pendingConstraints[2] = true;
											inhibitAnyPolicyPending = _this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec;
										} else inhibitAnyPolicyPending = inhibitAnyPolicyPending &gt; _this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec ? _this3.certs[i].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
									}
								}
							}
							//endregion
						}
						//endregion

						//region Check &quot;inhibitAnyPolicyIndicator&quot;
						if (inhibitAnyPolicyIndicator === true) {
							let policyIndex = -1;

							//region Find &quot;anyPolicy&quot; index
							for (let searchAnyPolicy = 0; searchAnyPolicy &lt; allPolicies.length; searchAnyPolicy++) {
								if (allPolicies[searchAnyPolicy] === &quot;2.5.29.32.0&quot;) {
									policyIndex = searchAnyPolicy;
									break;
								}
							}
							//endregion

							if (policyIndex !== -1) delete policiesAndCerts[0][i]; // Unset value to &quot;undefined&quot; for &quot;anyPolicies&quot; value for current certificate
						}
						//endregion

						//region Process with &quot;pending constraints&quot;
						if (explicitPolicyIndicator === false) {
							if (pendingConstraints[0] === true) {
								explicitPolicyPending--;
								if (explicitPolicyPending === 0) {
									explicitPolicyIndicator = true;
									explicitPolicyStart = i;

									pendingConstraints[0] = false;
								}
							}
						}

						if (policyMappingInhibitIndicator === false) {
							if (pendingConstraints[1] === true) {
								policyMappingInhibitPending--;
								if (policyMappingInhibitPending === 0) {
									policyMappingInhibitIndicator = true;
									pendingConstraints[1] = false;
								}
							}
						}

						if (inhibitAnyPolicyIndicator === false) {
							if (pendingConstraints[2] === true) {
								inhibitAnyPolicyPending--;
								if (inhibitAnyPolicyPending === 0) {
									inhibitAnyPolicyIndicator = true;
									pendingConstraints[2] = false;
								}
							}
						}
						//endregion
					}
				}
				//endregion

				//region Working with policy mappings
				for (let i = 0; i &lt; _this3.certs.length - 1; i++) {
					//region Check that there is &quot;policy mapping&quot; for level &quot;i + 1&quot;
					if (i &lt; _this3.certs.length - 2 &amp;&amp; typeof policyMappings[i + 1] !== &quot;undefined&quot;) {
						for (let k = 0; k &lt; policyMappings[i + 1].mappings.length; k++) {
							//region Check that we do not have &quot;anyPolicy&quot; in current mapping
							if (policyMappings[i + 1].mappings[k].issuerDomainPolicy === &quot;2.5.29.32.0&quot; || policyMappings[i + 1].mappings[k].subjectDomainPolicy === &quot;2.5.29.32.0&quot;) {
								return {
									result: false,
									resultCode: 99,
									resultMessage: &quot;The \&quot;anyPolicy\&quot; should not be a part of policy mapping scheme&quot;
								};
							}
							//endregion

							//region Initial variables
							let issuerDomainPolicyIndex = -1;
							let subjectDomainPolicyIndex = -1;
							//endregion

							//region Search for index of policies indedes
							for (let n = 0; n &lt; allPolicies.length; n++) {
								if (allPolicies[n] === policyMappings[i + 1].mappings[k].issuerDomainPolicy) issuerDomainPolicyIndex = n;

								if (allPolicies[n] === policyMappings[i + 1].mappings[k].subjectDomainPolicy) subjectDomainPolicyIndex = n;
							}
							//endregion

							//region Delete existing &quot;issuerDomainPolicy&quot; because on the level we mapped the policy to another one
							if (typeof policiesAndCerts[issuerDomainPolicyIndex][i] !== &quot;undefined&quot;) delete policiesAndCerts[issuerDomainPolicyIndex][i];
							//endregion

							//region Check all policies for the certificate
							for (let j = 0; j &lt; certPolicies[i].certificatePolicies.length; j++) {
								if (policyMappings[i + 1].mappings[k].subjectDomainPolicy === certPolicies[i].certificatePolicies[j].policyIdentifier) {
									//region Set mapped policy for current certificate
									if (issuerDomainPolicyIndex !== -1 &amp;&amp; subjectDomainPolicyIndex !== -1) {
										for (let m = 0; m &lt;= i; m++) {
											if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== &quot;undefined&quot;) {
												policiesAndCerts[issuerDomainPolicyIndex][m] = true;
												delete policiesAndCerts[subjectDomainPolicyIndex][m];
											}
										}
									}
									//endregion
								}
							}
							//endregion
						}
					}
					//endregion
				}
				//endregion

				//region Working with &quot;explicitPolicyIndicator&quot; and &quot;anyPolicy&quot;
				for (let i = 0; i &lt; allPolicies.length; i++) {
					if (allPolicies[i] === &quot;2.5.29.32.0&quot;) {
						for (let j = 0; j &lt; explicitPolicyStart; j++) delete policiesAndCerts[i][j];
					}
				}
				//endregion

				//region Create &quot;set of authorities-constrained policies&quot;
				const authConstrPolicies = [];

				for (let i = 0; i &lt; policiesAndCerts.length; i++) {
					let found = true;

					for (let j = 0; j &lt; _this3.certs.length - 1; j++) {
						let anyPolicyFound = false;

						if (j &lt; explicitPolicyStart &amp;&amp; allPolicies[i] === &quot;2.5.29.32.0&quot; &amp;&amp; allPolicies.length &gt; 1) {
							found = false;
							break;
						}

						if (typeof policiesAndCerts[i][j] === &quot;undefined&quot;) {
							if (j &gt;= explicitPolicyStart) {
								//region Search for &quot;anyPolicy&quot; in the policy set
								for (let k = 0; k &lt; allPolicies.length; k++) {
									if (allPolicies[k] === &quot;2.5.29.32.0&quot;) {
										if (policiesAndCerts[k][j] === true) anyPolicyFound = true;

										break;
									}
								}
								//endregion
							}

							if (!anyPolicyFound) {
								found = false;
								break;
							}
						}
					}

					if (found === true) authConstrPolicies.push(allPolicies[i]);
				}
				//endregion

				//region Create &quot;set of user-constrained policies&quot;
				let userConstrPolicies = [];

				if (initialPolicySet.length === 1 &amp;&amp; initialPolicySet[0] === &quot;2.5.29.32.0&quot; &amp;&amp; explicitPolicyIndicator === false) userConstrPolicies = initialPolicySet;else {
					if (authConstrPolicies.length === 1 &amp;&amp; authConstrPolicies[0] === &quot;2.5.29.32.0&quot;) userConstrPolicies = initialPolicySet;else {
						for (let i = 0; i &lt; authConstrPolicies.length; i++) {
							for (let j = 0; j &lt; initialPolicySet.length; j++) {
								if (initialPolicySet[j] === authConstrPolicies[i] || initialPolicySet[j] === &quot;2.5.29.32.0&quot;) {
									userConstrPolicies.push(authConstrPolicies[i]);
									break;
								}
							}
						}
					}
				}
				//endregion

				//region Combine output object
				const policyResult = {
					result: userConstrPolicies.length &gt; 0,
					resultCode: 0,
					resultMessage: userConstrPolicies.length &gt; 0 ? &quot;&quot; : &quot;Zero \&quot;userConstrPolicies\&quot; array, no intersections with \&quot;authConstrPolicies\&quot;&quot;,
					authConstrPolicies,
					userConstrPolicies,
					explicitPolicyIndicator,
					policyMappings,
					certificatePath: _this3.certs
				};

				if (userConstrPolicies.length === 0) return policyResult;
				//endregion
				//endregion

				//region Work with name constraints
				//region Check a result from &quot;policy checking&quot; part
				if (policyResult.result === false) return policyResult;
				//endregion

				//region Check all certificates, excluding &quot;trust anchor&quot;
				pathDepth = 1;

				for (let i = _this3.certs.length - 2; i &gt;= 0; i--, pathDepth++) {
					//region Support variables
					let subjectAltNames = [];

					let certPermittedSubtrees = [];
					let certExcludedSubtrees = [];
					//endregion

					if (&quot;extensions&quot; in _this3.certs[i]) {
						for (let j = 0; j &lt; _this3.certs[i].extensions.length; j++) {
							//region NameConstraints
							if (_this3.certs[i].extensions[j].extnID === &quot;2.5.29.30&quot;) {
								if (&quot;permittedSubtrees&quot; in _this3.certs[i].extensions[j].parsedValue) certPermittedSubtrees = certPermittedSubtrees.concat(_this3.certs[i].extensions[j].parsedValue.permittedSubtrees);

								if (&quot;excludedSubtrees&quot; in _this3.certs[i].extensions[j].parsedValue) certExcludedSubtrees = certExcludedSubtrees.concat(_this3.certs[i].extensions[j].parsedValue.excludedSubtrees);
							}
							//endregion

							//region SubjectAltName
							if (_this3.certs[i].extensions[j].extnID === &quot;2.5.29.17&quot;) subjectAltNames = subjectAltNames.concat(_this3.certs[i].extensions[j].parsedValue.altNames);
							//endregion
						}
					}

					//region Checking for &quot;required name forms&quot;
					let formFound = requiredNameForms.length &lt;= 0;

					for (let j = 0; j &lt; requiredNameForms.length; j++) {
						switch (requiredNameForms[j].base.type) {
							case 4:
								// directoryName
								{
									if (requiredNameForms[j].base.value.typesAndValues.length !== _this3.certs[i].subject.typesAndValues.length) continue;

									formFound = true;

									for (let k = 0; k &lt; _this3.certs[i].subject.typesAndValues.length; k++) {
										if (_this3.certs[i].subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type) {
											formFound = false;
											break;
										}
									}

									if (formFound === true) break;
								}
								break;
							default: // ??? Probably here we should reject the certificate ???
						}
					}

					if (formFound === false) {
						policyResult.result = false;
						policyResult.resultCode = 21;
						policyResult.resultMessage = &quot;No neccessary name form found&quot;;

						throw policyResult;
					}
					//endregion

					//region Checking for &quot;permited sub-trees&quot;
					//region Make groups for all types of constraints
					const constrGroups = []; // Array of array for groupped constraints
					constrGroups[0] = []; // rfc822Name
					constrGroups[1] = []; // dNSName
					constrGroups[2] = []; // directoryName
					constrGroups[3] = []; // uniformResourceIdentifier
					constrGroups[4] = []; // iPAddress

					for (let j = 0; j &lt; permittedSubtrees.length; j++) {
						switch (permittedSubtrees[j].base.type) {
							//region rfc822Name
							case 1:
								constrGroups[0].push(permittedSubtrees[j]);
								break;
							//endregion
							//region dNSName
							case 2:
								constrGroups[1].push(permittedSubtrees[j]);
								break;
							//endregion
							//region directoryName
							case 4:
								constrGroups[2].push(permittedSubtrees[j]);
								break;
							//endregion
							//region uniformResourceIdentifier
							case 6:
								constrGroups[3].push(permittedSubtrees[j]);
								break;
							//endregion
							//region iPAddress
							case 7:
								constrGroups[4].push(permittedSubtrees[j]);
								break;
							//endregion
							//region default
							default:
							//endregion
						}
					}
					//endregion

					//region Check name constraints groupped by type, one-by-one
					for (let p = 0; p &lt; 5; p++) {
						let groupPermitted = false;
						let valueExists = false;
						const group = constrGroups[p];

						for (let j = 0; j &lt; group.length; j++) {
							switch (p) {
								//region rfc822Name
								case 0:
									if (subjectAltNames.length &gt; 0) {
										for (let k = 0; k &lt; subjectAltNames.length; k++) {
											if (subjectAltNames[k].type === 1) // rfc822Name
												{
													valueExists = true;
													groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
												}
										}
									} else // Try to find out &quot;emailAddress&quot; inside &quot;subject&quot;
										{
											for (let k = 0; k &lt; _this3.certs[i].subject.typesAndValues.length; k++) {
												if (_this3.certs[i].subject.typesAndValues[k].type === &quot;1.2.840.113549.1.9.1&quot; || // PKCS#9 e-mail address
												_this3.certs[i].subject.typesAndValues[k].type === &quot;0.9.2342.19200300.100.1.3&quot;) // RFC1274 &quot;rfc822Mailbox&quot; e-mail address
													{
														valueExists = true;
														groupPermitted = groupPermitted || compareRFC822Name(_this3.certs[i].subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
													}
											}
										}
									break;
								//endregion
								//region dNSName
								case 1:
									if (subjectAltNames.length &gt; 0) {
										for (let k = 0; k &lt; subjectAltNames.length; k++) {
											if (subjectAltNames[k].type === 2) // dNSName
												{
													valueExists = true;
													groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
												}
										}
									}
									break;
								//endregion
								//region directoryName
								case 2:
									valueExists = true;
									groupPermitted = compareDirectoryName(_this3.certs[i].subject, group[j].base.value);
									break;
								//endregion
								//region uniformResourceIdentifier
								case 3:
									if (subjectAltNames.length &gt; 0) {
										for (let k = 0; k &lt; subjectAltNames.length; k++) {
											if (subjectAltNames[k].type === 6) // uniformResourceIdentifier
												{
													valueExists = true;
													groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
												}
										}
									}
									break;
								//endregion
								//region iPAddress
								case 4:
									if (subjectAltNames.length &gt; 0) {
										for (let k = 0; k &lt; subjectAltNames.length; k++) {
											if (subjectAltNames[k].type === 7) // iPAddress
												{
													valueExists = true;
													groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
												}
										}
									}
									break;
								//endregion
								//region default
								default:
								//endregion
							}

							if (groupPermitted) break;
						}

						if (groupPermitted === false &amp;&amp; group.length &gt; 0 &amp;&amp; valueExists) {
							policyResult.result = false;
							policyResult.resultCode = 41;
							policyResult.resultMessage = &quot;Failed to meet \&quot;permitted sub-trees\&quot; name constraint&quot;;

							throw policyResult;
						}
					}
					//endregion
					//endregion

					//region Checking for &quot;excluded sub-trees&quot;
					let excluded = false;

					for (let j = 0; j &lt; excludedSubtrees.length; j++) {
						switch (excludedSubtrees[j].base.type) {
							//region rfc822Name
							case 1:
								if (subjectAltNames.length &gt;= 0) {
									for (let k = 0; k &lt; subjectAltNames.length; k++) {
										if (subjectAltNames[k].type === 1) // rfc822Name
											excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								} else // Try to find out &quot;emailAddress&quot; inside &quot;subject&quot;
									{
										for (let k = 0; k &lt; _this3.certs[i].subject.typesAndValues.length; k++) {
											if (_this3.certs[i].subject.typesAndValues[k].type === &quot;1.2.840.113549.1.9.1&quot; || // PKCS#9 e-mail address
											_this3.certs[i].subject.typesAndValues[k].type === &quot;0.9.2342.19200300.100.1.3&quot;) // RFC1274 &quot;rfc822Mailbox&quot; e-mail address
												excluded = excluded || compareRFC822Name(_this3.certs[i].subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);
										}
									}
								break;
							//endregion
							//region dNSName
							case 2:
								if (subjectAltNames.length &gt; 0) {
									for (let k = 0; k &lt; subjectAltNames.length; k++) {
										if (subjectAltNames[k].type === 2) // dNSName
											excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region directoryName
							case 4:
								excluded = excluded || compareDirectoryName(_this3.certs[i].subject, excludedSubtrees[j].base.value);
								break;
							//endregion
							//region uniformResourceIdentifier
							case 6:
								if (subjectAltNames.length &gt; 0) {
									for (let k = 0; k &lt; subjectAltNames.length; k++) {
										if (subjectAltNames[k].type === 6) // uniformResourceIdentifier
											excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region iPAddress
							case 7:
								if (subjectAltNames.length &gt; 0) {
									for (let k = 0; k &lt; subjectAltNames.length; k++) {
										if (subjectAltNames[k].type === 7) // iPAddress
											excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);
									}
								}
								break;
							//endregion
							//region default
							default: // No action, but probably here we need to create a warning for &quot;malformed constraint&quot;
							//endregion
						}

						if (excluded) break;
					}

					if (excluded === true) {
						policyResult.result = false;
						policyResult.resultCode = 42;
						policyResult.resultMessage = &quot;Failed to meet \&quot;excluded sub-trees\&quot; name constraint&quot;;

						throw policyResult;
					}
					//endregion

					//region Append &quot;cert_..._subtrees&quot; to &quot;..._subtrees&quot;
					permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
					excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
					//endregion
				}
				//endregion

				return policyResult;
				//endregion
			} catch (error) {
				if (error instanceof Object) {
					if (&quot;resultMessage&quot; in error) return error;

					if (&quot;message&quot; in error) {
						return {
							result: false,
							resultCode: -1,
							resultMessage: error.message
						};
					}
				}

				return {
					result: false,
					resultCode: -1,
					resultMessage: error
				};
			}
		})();
	}
	//**********************************************************************************
}
exports.default = CertificateChainValidationEngine; //**************************************************************************************
//# sourceMappingURL=CertificateChainValidationEngine.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
