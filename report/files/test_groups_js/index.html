<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/groups.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/groups.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1385</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const fs = require(&#039;fs&#039;);
const path = require(&#039;path&#039;);
const nconf = require(&#039;nconf&#039;);

const db = require(&#039;./mocks/databasemock&#039;);
const helpers = require(&#039;./helpers&#039;);
const Groups = require(&#039;../src/groups&#039;);
const User = require(&#039;../src/user&#039;);
const plugins = require(&#039;../src/plugins&#039;);
const utils = require(&#039;../src/utils&#039;);
const socketGroups = require(&#039;../src/socket.io/groups&#039;);
const apiGroups = require(&#039;../src/api/groups&#039;);
const meta = require(&#039;../src/meta&#039;);
const navigation = require(&#039;../src/navigation/admin&#039;);


describe(&#039;Groups&#039;, () =&gt; {
	let adminUid;
	let testUid;
	before(async () =&gt; {
		// Attach an emailer hook so related requests do not error
		plugins.hooks.register(&#039;emailer-test&#039;, {
			hook: &#039;static:email.send&#039;,
			method: dummyEmailerHook,
		});

		const navData = require(&#039;../install/data/navigation.json&#039;);
		await navigation.save(navData);

		await Groups.create({
			name: &#039;Test&#039;,
			description: &#039;Foobar!&#039;,
		});

		await Groups.create({
			name: &#039;PrivateNoJoin&#039;,
			description: &#039;Private group&#039;,
			private: 1,
			disableJoinRequests: 1,
		});

		await Groups.create({
			name: &#039;PrivateCanJoin&#039;,
			description: &#039;Private group&#039;,
			private: 1,
			disableJoinRequests: 0,
		});

		await Groups.create({
			name: &#039;PrivateNoLeave&#039;,
			description: &#039;Private group&#039;,
			private: 1,
			disableLeave: 1,
		});

		await Groups.create({
			name: &#039;Global Moderators&#039;,
			userTitle: &#039;Global Moderator&#039;,
			description: &#039;Forum wide moderators&#039;,
			hidden: 0,
			private: 1,
			disableJoinRequests: 1,
		});

		// Also create a hidden group
		await Groups.join(&#039;Hidden&#039;, &#039;Test&#039;);
		// create another group that starts with test for search/sort
		await Groups.create({ name: &#039;Test2&#039;, description: &#039;Foobar!&#039; });

		testUid = await User.create({
			username: &#039;testuser&#039;,
			email: &#039;b@c.com&#039;,
		});

		adminUid = await User.create({
			username: &#039;admin&#039;,
			email: &#039;admin@admin.com&#039;,
			password: &#039;123456&#039;,
		});
		await Groups.join(&#039;administrators&#039;, adminUid);
	});

	async function dummyEmailerHook(data) {
		// pretend to handle sending emails
	}

	after(async () =&gt; {
		plugins.hooks.unregister(&#039;emailer-test&#039;, &#039;static:email.send&#039;);
	});

	describe(&#039;.list()&#039;, () =&gt; {
		it(&#039;should list the groups present&#039;, (done) =&gt; {
			Groups.getGroupsFromSet(&#039;groups:visible:createtime&#039;, 0, -1, (err, groups) =&gt; {
				assert.ifError(err);
				assert.equal(groups.length, 5);
				done();
			});
		});
	});

	describe(&#039;.get()&#039;, () =&gt; {
		before((done) =&gt; {
			Groups.join(&#039;Test&#039;, testUid, done);
		});

		it(&#039;with no options, should show group information&#039;, (done) =&gt; {
			Groups.get(&#039;Test&#039;, {}, (err, groupObj) =&gt; {
				assert.ifError(err);
				assert.equal(typeof groupObj, &#039;object&#039;);
				assert(Array.isArray(groupObj.members));
				assert.strictEqual(groupObj.name, &#039;Test&#039;);
				assert.strictEqual(groupObj.description, &#039;Foobar!&#039;);
				assert.strictEqual(groupObj.memberCount, 1);
				assert.equal(typeof groupObj.members[0], &#039;object&#039;);

				done();
			});
		});

		it(&#039;should return null if group does not exist&#039;, (done) =&gt; {
			Groups.get(&#039;doesnotexist&#039;, {}, (err, groupObj) =&gt; {
				assert.ifError(err);
				assert.strictEqual(groupObj, null);
				done();
			});
		});
	});

	describe(&#039;.search()&#039;, () =&gt; {
		const socketGroups = require(&#039;../src/socket.io/groups&#039;);

		it(&#039;should return empty array if query is falsy&#039;, (done) =&gt; {
			Groups.search(null, {}, (err, groups) =&gt; {
				assert.ifError(err);
				assert.equal(0, groups.length);
				done();
			});
		});

		it(&#039;should return the groups when search query is empty&#039;, (done) =&gt; {
			socketGroups.search({ uid: adminUid }, { query: &#039;&#039; }, (err, groups) =&gt; {
				assert.ifError(err);
				assert.equal(5, groups.length);
				done();
			});
		});

		it(&#039;should return the &quot;Test&quot; group when searched for&#039;, (done) =&gt; {
			socketGroups.search({ uid: adminUid }, { query: &#039;test&#039; }, (err, groups) =&gt; {
				assert.ifError(err);
				assert.equal(2, groups.length);
				assert.strictEqual(&#039;Test&#039;, groups[0].name);
				done();
			});
		});

		it(&#039;should return the &quot;Test&quot; group when searched for and sort by member count&#039;, (done) =&gt; {
			Groups.search(&#039;test&#039;, { filterHidden: true, sort: &#039;count&#039; }, (err, groups) =&gt; {
				assert.ifError(err);
				assert.equal(2, groups.length);
				assert.strictEqual(&#039;Test&#039;, groups[0].name);
				done();
			});
		});

		it(&#039;should return the &quot;Test&quot; group when searched for and sort by creation time&#039;, (done) =&gt; {
			Groups.search(&#039;test&#039;, { filterHidden: true, sort: &#039;date&#039; }, (err, groups) =&gt; {
				assert.ifError(err);
				assert.equal(2, groups.length);
				assert.strictEqual(&#039;Test&#039;, groups[1].name);
				done();
			});
		});

		it(&#039;should return all users if no query&#039;, async () =&gt; {
			async function createAndJoinGroup(username, email) {
				const uid = await User.create({ username: username, email: email });
				await Groups.join(&#039;Test&#039;, uid);
			}
			await createAndJoinGroup(&#039;newuser&#039;, &#039;newuser@b.com&#039;);
			await createAndJoinGroup(&#039;bob&#039;, &#039;bob@b.com&#039;);
			const { users } = await apiGroups.listMembers({ uid: adminUid }, { slug: &#039;test&#039;, query: &#039;&#039; });
			assert.equal(users.length, 3);
		});

		it(&#039;should search group members&#039;, async () =&gt; {
			const { users } = await apiGroups.listMembers({ uid: adminUid }, { slug: &#039;test&#039;, query: &#039;test&#039; });
			assert.strictEqual(&#039;testuser&#039;, users[0].username);
		});

		it(&#039;should not return hidden groups&#039;, async () =&gt; {
			await Groups.create({
				name: &#039;hiddenGroup&#039;,
				hidden: &#039;1&#039;,
			});
			const result = await socketGroups.search({ uid: testUid }, { query: &#039;hiddenGroup&#039; });
			assert.equal(result.length, 0);
		});
	});

	describe(&#039;.isMember()&#039;, () =&gt; {
		it(&#039;should return boolean true when a user is in a group&#039;, async () =&gt; {
			const isMember = await Groups.isMember(1, &#039;Test&#039;);
			assert.strictEqual(isMember, true);
		});

		it(&#039;should return boolean false when a user is not in a group&#039;, async () =&gt; {
			const isMember = await Groups.isMember(2, &#039;Test&#039;);
			assert.strictEqual(isMember, false);
		});

		it(&#039;should return true for uid 0 and guests group&#039;, async () =&gt; {
			const isMember = await Groups.isMember(0, &#039;guests&#039;);
			assert.strictEqual(isMember, true);
		});

		it(&#039;should return false for uid 0 and spiders group&#039;, async () =&gt; {
			const isMember = await Groups.isMember(0, &#039;spiders&#039;);
			assert.strictEqual(isMember, false);
		});

		it(&#039;should return true for uid -1 and spiders group&#039;, async () =&gt; {
			const isMember = await Groups.isMember(-1, &#039;spiders&#039;);
			assert.strictEqual(isMember, true);
		});

		it(&#039;should return false for uid -1 and guests group&#039;, async () =&gt; {
			const isMember = await Groups.isMember(-1, &#039;guests&#039;);
			assert.strictEqual(isMember, false);
		});

		it(&#039;should return true for uid 0, false for uid -1 with guests group&#039;, async () =&gt; {
			const isMembers = await Groups.isMembers([1, 0, -1], &#039;guests&#039;);
			assert.deepStrictEqual(isMembers, [false, true, false]);
		});

		it(&#039;should return false for uid 0, true for uid -1 with spiders group&#039;, async () =&gt; {
			const isMembers = await Groups.isMembers([1, 0, -1], &#039;spiders&#039;);
			assert.deepStrictEqual(isMembers, [false, false, true]);
		});

		it(&#039;should return true for uid 0 and guests group&#039;, async () =&gt; {
			const isMembers = await Groups.isMemberOfGroups(0, [&#039;guests&#039;, &#039;registered-users&#039;, &#039;spiders&#039;]);
			assert.deepStrictEqual(isMembers, [true, false, false]);
		});

		it(&#039;should return true for uid -1 and spiders group&#039;, async () =&gt; {
			const isMembers = await Groups.isMemberOfGroups(-1, [&#039;guests&#039;, &#039;registered-users&#039;, &#039;spiders&#039;]);
			assert.deepStrictEqual(isMembers, [false, false, true]);
		});
	});

	describe(&#039;.isMemberOfGroupList&#039;, () =&gt; {
		it(&#039;should report that a user is part of a groupList, if they are&#039;, (done) =&gt; {
			Groups.isMemberOfGroupList(1, &#039;Hidden&#039;, (err, isMember) =&gt; {
				assert.ifError(err);
				assert.strictEqual(isMember, true);
				done();
			});
		});

		it(&#039;should report that a user is not part of a groupList, if they are not&#039;, (done) =&gt; {
			Groups.isMemberOfGroupList(2, &#039;Hidden&#039;, (err, isMember) =&gt; {
				assert.ifError(err);
				assert.strictEqual(isMember, false);
				done();
			});
		});
	});

	describe(&#039;.exists()&#039;, () =&gt; {
		it(&#039;should verify that the test group exists&#039;, (done) =&gt; {
			Groups.exists(&#039;Test&#039;, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(exists, true);
				done();
			});
		});

		it(&#039;should verify that a fake group does not exist&#039;, (done) =&gt; {
			Groups.exists(&#039;Derp&#039;, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(exists, false);
				done();
			});
		});

		it(&#039;should check if group exists using an array&#039;, (done) =&gt; {
			Groups.exists([&#039;Test&#039;, &#039;Derp&#039;], (err, groupsExists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(groupsExists[0], true);
				assert.strictEqual(groupsExists[1], false);
				done();
			});
		});
	});

	describe(&#039;.create()&#039;, () =&gt; {
		it(&#039;should create another group&#039;, (done) =&gt; {
			Groups.create({
				name: &#039;foo&#039;,
				description: &#039;bar&#039;,
			}, (err) =&gt; {
				assert.ifError(err);
				Groups.get(&#039;foo&#039;, {}, done);
			});
		});

		it(&#039;should create a hidden group if hidden is 1&#039;, (done) =&gt; {
			Groups.create({
				name: &#039;hidden group&#039;,
				hidden: &#039;1&#039;,
			}, (err) =&gt; {
				assert.ifError(err);
				db.isSortedSetMember(&#039;groups:visible:memberCount&#039;, &#039;visible group&#039;, (err, isMember) =&gt; {
					assert.ifError(err);
					assert(!isMember);
					done();
				});
			});
		});

		it(&#039;should create a visible group if hidden is 0&#039;, (done) =&gt; {
			Groups.create({
				name: &#039;visible group&#039;,
				hidden: &#039;0&#039;,
			}, (err) =&gt; {
				assert.ifError(err);
				db.isSortedSetMember(&#039;groups:visible:memberCount&#039;, &#039;visible group&#039;, (err, isMember) =&gt; {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it(&#039;should create a visible group if hidden is not passed in&#039;, (done) =&gt; {
			Groups.create({
				name: &#039;visible group 2&#039;,
			}, (err) =&gt; {
				assert.ifError(err);
				db.isSortedSetMember(&#039;groups:visible:memberCount&#039;, &#039;visible group 2&#039;, (err, isMember) =&gt; {
					assert.ifError(err);
					assert(isMember);
					done();
				});
			});
		});

		it(&#039;should fail to create group with duplicate group name&#039;, (done) =&gt; {
			Groups.create({ name: &#039;foo&#039; }, (err) =&gt; {
				assert(err);
				assert.equal(err.message, &#039;[[error:group-already-exists]]&#039;);
				done();
			});
		});

		it(&#039;should fail to create group if slug is empty&#039;, (done) =&gt; {
			Groups.create({ name: &#039;&gt;&gt;&gt;&gt;&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
				done();
			});
		});

		it(&#039;should fail if group name is invalid&#039;, (done) =&gt; {
			Groups.create({ name: &#039;not/valid&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
				done();
			});
		});

		it(&#039;should fail if group name is invalid&#039;, (done) =&gt; {
			Groups.create({ name: [&#039;array/&#039;] }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
				done();
			});
		});

		it(&#039;should fail if group name is invalid&#039;, async () =&gt; {
			try {
				await apiGroups.create({ uid: adminUid }, { name: [&#039;test&#039;, &#039;administrators&#039;] });
			} catch (err) {
				return assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
			assert(false);
		});

		it(&#039;should not create a system group&#039;, async () =&gt; {
			await apiGroups.create({ uid: adminUid }, { name: &#039;mysystemgroup&#039;, system: true });
			const data = await Groups.getGroupData(&#039;mysystemgroup&#039;);
			assert.strictEqual(data.system, 0);
		});

		it(&#039;should fail if group name is invalid&#039;, (done) =&gt; {
			Groups.create({ name: &#039;not:valid&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
				done();
			});
		});

		it(&#039;should return falsy for userTitleEnabled&#039;, (done) =&gt; {
			Groups.create({ name: &#039;userTitleEnabledGroup&#039; }, (err) =&gt; {
				assert.ifError(err);
				Groups.setGroupField(&#039;userTitleEnabledGroup&#039;, &#039;userTitleEnabled&#039;, 0, (err) =&gt; {
					assert.ifError(err);
					Groups.getGroupData(&#039;userTitleEnabledGroup&#039;, (err, data) =&gt; {
						assert.ifError(err);
						assert.strictEqual(data.userTitleEnabled, 0);
						done();
					});
				});
			});
		});
	});

	describe(&#039;.hide()&#039;, () =&gt; {
		it(&#039;should mark the group as hidden&#039;, async () =&gt; {
			await Groups.hide(&#039;foo&#039;);
			const groupObj = await Groups.get(&#039;foo&#039;, {});
			assert.strictEqual(1, groupObj.hidden);
			const isMember = await db.isSortedSetMember(&#039;groups:visible:createtime&#039;, &#039;foo&#039;);
			assert.strictEqual(isMember, false);
		});
	});

	describe(&#039;.update()&#039;, () =&gt; {
		before((done) =&gt; {
			Groups.create({
				name: &#039;updateTestGroup&#039;,
				description: &#039;bar&#039;,
				system: 0,
				hidden: 0,
			}, done);
		});

		it(&#039;should change an aspect of a group&#039;, (done) =&gt; {
			Groups.update(&#039;updateTestGroup&#039;, {
				description: &#039;baz&#039;,
			}, (err) =&gt; {
				assert.ifError(err);

				Groups.get(&#039;updateTestGroup&#039;, {}, (err, groupObj) =&gt; {
					assert.ifError(err);
					assert.strictEqual(&#039;baz&#039;, groupObj.description);
					done();
				});
			});
		});

		it(&#039;should rename a group and not break navigation routes&#039;, async () =&gt; {
			await Groups.update(&#039;updateTestGroup&#039;, {
				name: &#039;updateTestGroup?&#039;,
			});

			const groupObj = await Groups.get(&#039;updateTestGroup?&#039;, {});
			assert.strictEqual(&#039;updateTestGroup?&#039;, groupObj.name);
			assert.strictEqual(&#039;updatetestgroup&#039;, groupObj.slug);

			const navItems = await navigation.get();
			assert.strictEqual(navItems[0].route, &#039;&amp;#x2F;categories&#039;);
		});

		it(&#039;should fail if system groups is being renamed&#039;, (done) =&gt; {
			Groups.update(&#039;administrators&#039;, {
				name: &#039;administrators_fail&#039;,
			}, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:not-allowed-to-rename-system-group]]&#039;);
				done();
			});
		});

		it(&#039;should fail to rename if group name is invalid&#039;, async () =&gt; {
			try {
				await apiGroups.update({ uid: adminUid }, { slug: [&#039;updateTestGroup?&#039;], values: {} });
			} catch (err) {
				return assert.strictEqual(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
			assert(false);
		});

		it(&#039;should fail to rename if group name is too short&#039;, async () =&gt; {
			try {
				const slug = await Groups.getGroupField(&#039;updateTestGroup?&#039;, &#039;slug&#039;);
				await apiGroups.update({ uid: adminUid }, { slug: slug, name: &#039;&#039; });
			} catch (err) {
				return assert.strictEqual(err.message, &#039;[[error:group-name-too-short]]&#039;);
			}
			assert(false);
		});

		it(&#039;should fail to rename if group name is invalid&#039;, async () =&gt; {
			try {
				const slug = await Groups.getGroupField(&#039;updateTestGroup?&#039;, &#039;slug&#039;);
				await apiGroups.update({ uid: adminUid }, { slug: slug, name: [&#039;invalid&#039;] });
			} catch (err) {
				return assert.strictEqual(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
			assert(false);
		});

		it(&#039;should fail to rename if group name is invalid&#039;, async () =&gt; {
			try {
				const slug = await Groups.getGroupField(&#039;updateTestGroup?&#039;, &#039;slug&#039;);
				await apiGroups.update({ uid: adminUid }, { slug: slug, name: &#039;cid:0:privileges:ban&#039; });
			} catch (err) {
				return assert.strictEqual(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
			assert(false);
		});

		it(&#039;should fail to rename if group name is too long&#039;, async () =&gt; {
			try {
				const slug = await Groups.getGroupField(&#039;updateTestGroup?&#039;, &#039;slug&#039;);
				await apiGroups.update({ uid: adminUid }, { slug: slug, name: &#039;verylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstringverylongstring&#039; });
			} catch (err) {
				return assert.strictEqual(err.message, &#039;[[error:group-name-too-long]]&#039;);
			}
			assert(false);
		});

		it(&#039;should fail to rename if group name is invalid&#039;, async () =&gt; {
			const slug = await Groups.getGroupField(&#039;updateTestGroup?&#039;, &#039;slug&#039;);
			const invalidNames = [&#039;test:test&#039;, &#039;another/test&#039;, &#039;---&#039;];
			for (const name of invalidNames) {
				try {
					// eslint-disable-next-line no-await-in-loop
					await apiGroups.update({ uid: adminUid }, { slug: slug, name: name });
					assert(false);
				} catch (err) {
					assert.strictEqual(err.message, &#039;[[error:invalid-group-name]]&#039;);
				}
			}
		});

		it(&#039;should fail to rename group to an existing group&#039;, (done) =&gt; {
			Groups.create({
				name: &#039;group2&#039;,
				system: 0,
				hidden: 0,
			}, (err) =&gt; {
				assert.ifError(err);
				Groups.update(&#039;group2&#039;, {
					name: &#039;updateTestGroup?&#039;,
				}, (err) =&gt; {
					assert.equal(err.message, &#039;[[error:group-already-exists]]&#039;);
					done();
				});
			});
		});
	});

	describe(&#039;.destroy()&#039;, () =&gt; {
		before((done) =&gt; {
			Groups.join(&#039;foobar?&#039;, 1, done);
		});

		it(&#039;should destroy a group&#039;, (done) =&gt; {
			Groups.destroy(&#039;foobar?&#039;, (err) =&gt; {
				assert.ifError(err);

				Groups.get(&#039;foobar?&#039;, {}, (err, groupObj) =&gt; {
					assert.ifError(err);
					assert.strictEqual(groupObj, null);
					done();
				});
			});
		});

		it(&#039;should also remove the members set&#039;, (done) =&gt; {
			db.exists(&#039;group:foo:members&#039;, (err, exists) =&gt; {
				assert.ifError(err);
				assert.strictEqual(false, exists);
				done();
			});
		});

		it(&#039;should remove group from privilege groups&#039;, async () =&gt; {
			const privileges = require(&#039;../src/privileges&#039;);
			const cid = 1;
			const groupName = &#039;1&#039;;
			const uid = 1;
			await Groups.create({ name: groupName });
			await privileges.categories.give([&#039;groups:topics:create&#039;], cid, groupName);
			let isMember = await Groups.isMember(groupName, &#039;cid:1:privileges:groups:topics:create&#039;);
			assert(isMember);
			await Groups.destroy(groupName);
			isMember = await Groups.isMember(groupName, &#039;cid:1:privileges:groups:topics:create&#039;);
			assert(!isMember);
			isMember = await Groups.isMember(uid, &#039;registered-users&#039;);
			assert(isMember);
		});
	});

	describe(&#039;.join()&#039;, () =&gt; {
		before((done) =&gt; {
			Groups.leave(&#039;Test&#039;, testUid, done);
		});

		it(&#039;should add a user to a group&#039;, (done) =&gt; {
			Groups.join(&#039;Test&#039;, testUid, (err) =&gt; {
				assert.ifError(err);

				Groups.isMember(testUid, &#039;Test&#039;, (err, isMember) =&gt; {
					assert.ifError(err);
					assert.strictEqual(true, isMember);

					done();
				});
			});
		});

		it(&#039;should fail to add user to admin group&#039;, async () =&gt; {
			const oldValue = meta.config.allowPrivateGroups;
			try {
				meta.config.allowPrivateGroups = false;
				const newUid = await User.create({ username: &#039;newadmin&#039; });
				await apiGroups.join({ uid: newUid }, { slug: [&#039;test&#039;, &#039;administrators&#039;], uid: newUid }, 1);
				const isMember = await Groups.isMember(newUid, &#039;administrators&#039;);
				assert(!isMember);
			} catch (err) {
				assert.strictEqual(err.message, &#039;[[error:no-group]]&#039;);
			}
			meta.config.allowPrivateGroups = oldValue;
		});

		it(&#039;should fail to add user to group if group name is invalid&#039;, (done) =&gt; {
			Groups.join(0, 1, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				Groups.join(null, 1, (err) =&gt; {
					assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
					Groups.join(undefined, 1, (err) =&gt; {
						assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
						done();
					});
				});
			});
		});

		it(&#039;should fail to add user to group if uid is invalid&#039;, (done) =&gt; {
			Groups.join(&#039;Test&#039;, 0, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-uid]]&#039;);
				Groups.join(&#039;Test&#039;, null, (err) =&gt; {
					assert.equal(err.message, &#039;[[error:invalid-uid]]&#039;);
					Groups.join(&#039;Test&#039;, undefined, (err) =&gt; {
						assert.equal(err.message, &#039;[[error:invalid-uid]]&#039;);
						done();
					});
				});
			});
		});

		it(&#039;should add user to Global Moderators group&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;glomod&#039; });
			const slug = await Groups.getGroupField(&#039;Global Moderators&#039;, &#039;slug&#039;);
			await apiGroups.join({ uid: adminUid }, { slug: slug, uid: uid });
			const isGlobalMod = await User.isGlobalModerator(uid);
			assert.strictEqual(isGlobalMod, true);
		});

		it(&#039;should add user to multiple groups&#039;, (done) =&gt; {
			const groupNames = [&#039;test-hidden1&#039;, &#039;Test&#039;, &#039;test-hidden2&#039;, &#039;empty group&#039;];
			Groups.create({ name: &#039;empty group&#039; }, (err) =&gt; {
				assert.ifError(err);
				Groups.join(groupNames, testUid, (err) =&gt; {
					assert.ifError(err);
					Groups.isMemberOfGroups(testUid, groupNames, (err, isMembers) =&gt; {
						assert.ifError(err);
						assert(isMembers.every(Boolean));
						db.sortedSetScores(&#039;groups:visible:memberCount&#039;, groupNames, (err, memberCounts) =&gt; {
							assert.ifError(err);
							// hidden groups are not in &quot;groups:visible:memberCount&quot; so they are null
							assert.deepEqual(memberCounts, [null, 3, null, 1]);
							done();
						});
					});
				});
			});
		});

		it(&#039;should set group title when user joins the group&#039;, (done) =&gt; {
			const groupName = &#039;this will be title&#039;;
			User.create({ username: &#039;needstitle&#039; }, (err, uid) =&gt; {
				assert.ifError(err);
				Groups.create({ name: groupName }, (err) =&gt; {
					assert.ifError(err);
					Groups.join([groupName], uid, (err) =&gt; {
						assert.ifError(err);
						User.getUserData(uid, (err, data) =&gt; {
							assert.ifError(err);
							assert.equal(data.groupTitle, `[&quot;${groupName}&quot;]`);
							assert.deepEqual(data.groupTitleArray, [groupName]);
							done();
						});
					});
				});
			});
		});

		it(&#039;should fail to add user to system group&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;eviluser&#039; });
			const oldValue = meta.config.allowPrivateGroups;
			meta.config.allowPrivateGroups = 0;
			async function test(groupName) {
				let err;
				try {
					const slug = await Groups.getGroupField(groupName, &#039;slug&#039;);
					await apiGroups.join({ uid: uid }, { slug: slug, uid: uid });
					const isMember = await Groups.isMember(uid, groupName);
					assert.strictEqual(isMember, false);
				} catch (_err) {
					err = _err;
				}
				assert.strictEqual(err.message, &#039;[[error:not-allowed]]&#039;);
			}
			const groups = [&#039;Global Moderators&#039;, &#039;verified-users&#039;, &#039;unverified-users&#039;];
			for (const g of groups) {
				// eslint-disable-next-line no-await-in-loop
				await test(g);
			}
			meta.config.allowPrivateGroups = oldValue;
		});

		it(&#039;should fail to add user to group if calling uid is non-self and non-admin&#039;, async () =&gt; {
			const uid1 = await User.create({ username: utils.generateUUID().slice(0, 8) });
			const uid2 = await User.create({ username: utils.generateUUID().slice(0, 8) });

			await assert.rejects(
				apiGroups.join({ uid: uid1 }, { slug: &#039;test&#039;, uid: uid2 }),
				{ message: &#039;[[error:not-allowed]]&#039; }
			);
		});

		it(&#039;should allow admins to join private groups&#039;, async () =&gt; {
			await apiGroups.join({ uid: adminUid }, { uid: adminUid, slug: &#039;global-moderators&#039; });
			assert(await Groups.isMember(adminUid, &#039;Global Moderators&#039;));
		});
	});

	describe(&#039;.leave()&#039;, () =&gt; {
		it(&#039;should remove a user from a group&#039;, (done) =&gt; {
			Groups.leave(&#039;Test&#039;, testUid, (err) =&gt; {
				assert.ifError(err);

				Groups.isMember(testUid, &#039;Test&#039;, (err, isMember) =&gt; {
					assert.ifError(err);
					assert.strictEqual(false, isMember);

					done();
				});
			});
		});
	});

	describe(&#039;.leaveAllGroups()&#039;, () =&gt; {
		it(&#039;should remove a user from all groups&#039;, async () =&gt; {
			await Groups.leaveAllGroups(testUid);
			const groups = [&#039;Test&#039;, &#039;Hidden&#039;];
			const isMembers = await Groups.isMemberOfGroups(testUid, groups);
			assert(!isMembers.includes(true));
		});
	});

	describe(&#039;.show()&#039;, () =&gt; {
		it(&#039;should make a group visible&#039;, async () =&gt; {
			await Groups.show(&#039;Test&#039;);
			const isMember = await db.isSortedSetMember(&#039;groups:visible:createtime&#039;, &#039;Test&#039;);
			assert.strictEqual(isMember, true);
		});
	});

	describe(&#039;socket/api methods&#039;, () =&gt; {
		it(&#039;should error if data is null&#039;, (done) =&gt; {
			socketGroups.before({ uid: 0 }, &#039;groups.join&#039;, null, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should not error if data is valid&#039;, (done) =&gt; {
			socketGroups.before({ uid: 0 }, &#039;groups.join&#039;, {}, (err) =&gt; {
				assert.ifError(err);
				done();
			});
		});

		it(&#039;should return error if not logged in&#039;, async () =&gt; {
			try {
				await apiGroups.join({ uid: 0 }, {});
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:invalid-uid]]&#039;);
			}
		});

		it(&#039;should return error if group name is special&#039;, async () =&gt; {
			try {
				await apiGroups.join({ uid: testUid }, { slug: &#039;administrators&#039;, uid: testUid });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:not-allowed]]&#039;);
			}
		});

		it(&#039;should error if group does not exist&#039;, async () =&gt; {
			try {
				await apiGroups.join({ uid: adminUid }, { slug: &#039;doesnotexist&#039;, uid: adminUid });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:no-group]]&#039;);
			}
		});

		it(&#039;should join test group&#039;, async () =&gt; {
			meta.config.allowPrivateGroups = 0;
			await apiGroups.join({ uid: adminUid }, { slug: &#039;test&#039;, uid: adminUid });
			const isMember = await Groups.isMember(adminUid, &#039;Test&#039;);
			assert(isMember);
		});

		it(&#039;should error if not logged in&#039;, async () =&gt; {
			try {
				await apiGroups.leave({ uid: 0 }, {});
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:invalid-uid]]&#039;);
			}
		});

		it(&#039;should return error if group name is special&#039;, async () =&gt; {
			try {
				await apiGroups.leave({ uid: adminUid }, { slug: &#039;administrators&#039;, uid: adminUid });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:cant-remove-self-as-admin]]&#039;);
			}
		});

		it(&#039;should leave test group&#039;, async () =&gt; {
			await apiGroups.leave({ uid: adminUid }, { slug: &#039;test&#039;, uid: adminUid });
			const isMember = await Groups.isMember(adminUid, &#039;Test&#039;);
			assert(!isMember);
		});

		it(&#039;should fail to join if group is private and join requests are disabled&#039;, async () =&gt; {
			meta.config.allowPrivateGroups = 1;
			try {
				await apiGroups.join({ uid: testUid }, { slug: &#039;privatenojoin&#039;, uid: testUid });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:group-join-disabled]]&#039;);
			}
		});

		it(&#039;should fail to leave if group is private and leave is disabled&#039;, async () =&gt; {
			await Groups.join(&#039;PrivateNoLeave&#039;, testUid);
			const isMember = await Groups.isMember(testUid, &#039;PrivateNoLeave&#039;);
			assert(isMember);
			try {
				await apiGroups.leave({ uid: testUid }, { slug: &#039;privatenoleave&#039;, uid: testUid });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:group-leave-disabled]]&#039;);
			}
		});

		it(&#039;should join if user is admin&#039;, async () =&gt; {
			await apiGroups.join({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: adminUid });
			const isMember = await Groups.isMember(adminUid, &#039;PrivateCanJoin&#039;);
			assert(isMember);
		});

		it(&#039;should request membership for regular user&#039;, async () =&gt; {
			await apiGroups.join({ uid: testUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			const isPending = await Groups.isPending(testUid, &#039;PrivateCanJoin&#039;);
			assert(isPending);
		});

		it(&#039;should reject membership of user&#039;, async () =&gt; {
			await apiGroups.reject({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			const invited = await Groups.isInvited(testUid, &#039;PrivateCanJoin&#039;);
			assert.equal(invited, false);
		});

		it(&#039;should error if not owner or admin&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.accept({ uid: 0 }, { slug: &#039;privatecanjoin&#039;, uid: testUid }),
				{ message: &#039;[[error:no-privileges]]&#039; }
			);
		});

		it(&#039;should accept membership of user&#039;, async () =&gt; {
			await apiGroups.join({ uid: testUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			await apiGroups.accept({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			const isMember = await Groups.isMember(testUid, &#039;PrivateCanJoin&#039;);
			assert(isMember);
		});

		it(&#039;should issue invite to user&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;invite1&#039; });
			await apiGroups.issueInvite({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid });
			const isInvited = await Groups.isInvited(uid, &#039;PrivateCanJoin&#039;);
			assert(isInvited);
		});

		it(&#039;should rescind invite&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;invite3&#039; });
			await apiGroups.issueInvite({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid });
			await apiGroups.rejectInvite({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid });

			const isInvited = await Groups.isInvited(uid, &#039;PrivateCanJoin&#039;);
			assert(!isInvited);
		});

		it(&#039;should fail to rescind last owner&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;lastgroupowner&#039; });
			await Groups.create({
				name: &#039;last owner&#039;,
				description: &#039;Foobar!&#039;,
				ownerUid: uid,
			});
			await assert.rejects(
				apiGroups.rescind({ uid: adminUid }, { slug: &#039;last-owner&#039;, uid: uid }),
				{ message: &#039;[[error:group-needs-owner]]&#039; },
			);
		});

		it(&#039;should error if user is not invited&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.acceptInvite({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: adminUid }),
				{ message: &#039;[[error:not-invited]]&#039; }
			);
		});

		it(&#039;should accept invite&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;invite4&#039; });
			await apiGroups.issueInvite({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid });
			await apiGroups.acceptInvite({ uid }, { slug: &#039;privatecanjoin&#039;, uid });
			const isMember = await Groups.isMember(uid, &#039;PrivateCanJoin&#039;);
			assert(isMember);
		});

		it(&#039;should reject invite&#039;, async () =&gt; {
			const uid = await User.create({ username: &#039;invite5&#039; });
			await apiGroups.issueInvite({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid });
			await apiGroups.rejectInvite({ uid }, { slug: &#039;privatecanjoin&#039;, uid });
			const isInvited = await Groups.isInvited(uid, &#039;PrivateCanJoin&#039;);
			assert(!isInvited);
		});

		it(&#039;should grant ownership to user&#039;, async () =&gt; {
			await apiGroups.grant({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			const isOwner = await Groups.ownership.isOwner(testUid, &#039;PrivateCanJoin&#039;);
			assert(isOwner);
		});

		it(&#039;should rescind ownership from user&#039;, async () =&gt; {
			await apiGroups.rescind({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			const isOwner = await Groups.ownership.isOwner(testUid, &#039;PrivateCanJoin&#039;);
			assert(!isOwner);
		});

		it(&#039;should fail to kick user with invalid data&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.leave({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: 8721632 }),
				{ message: &#039;[[error:group-not-member]]&#039; }
			);
		});

		it(&#039;should kick user from group&#039;, async () =&gt; {
			await apiGroups.leave({ uid: adminUid }, { slug: &#039;privatecanjoin&#039;, uid: testUid });
			const isMember = await Groups.isMember(testUid, &#039;PrivateCanJoin&#039;);
			assert(!isMember);
		});

		it(&#039;should fail to create group with invalid data&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.create({ uid: 0 }, {}),
				{ message: &#039;[[error:no-privileges]]&#039; }
			);
		});

		it(&#039;should fail to create group if group creation is disabled&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.create({ uid: testUid }, { name: &#039;avalidname&#039; }),
				{ message: &#039;[[error:no-privileges]]&#039; }
			);
		});

		it(&#039;should fail to create group if name is privilege group&#039;, async () =&gt; {
			try {
				await apiGroups.create({ uid: 1 }, { name: &#039;cid:1:privileges:groups:find&#039; });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
		});

		it(&#039;should create/update group&#039;, async () =&gt; {
			const groupData = await apiGroups.create({ uid: adminUid }, { name: &#039;createupdategroup&#039; });
			assert(groupData);
			const data = {
				slug: &#039;createupdategroup&#039;,
				name: &#039;renamedupdategroup&#039;,
				description: &#039;cat group&#039;,
				userTitle: &#039;cats&#039;,
				userTitleEnabled: 1,
				disableJoinRequests: 1,
				hidden: 1,
				private: 0,
			};
			await apiGroups.update({ uid: adminUid }, data);
			const updatedData = await Groups.get(&#039;renamedupdategroup&#039;, {});
			assert.equal(updatedData.name, &#039;renamedupdategroup&#039;);
			assert.equal(updatedData.userTitle, &#039;cats&#039;);
			assert.equal(updatedData.description, &#039;cat group&#039;);
			assert.equal(updatedData.hidden, true);
			assert.equal(updatedData.disableJoinRequests, true);
			assert.equal(updatedData.private, false);
		});

		it(&#039;should fail to create a group with name guests&#039;, async () =&gt; {
			try {
				await apiGroups.create({ uid: adminUid }, { name: &#039;guests&#039; });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
		});

		it(&#039;should fail to rename guests group&#039;, async () =&gt; {
			const data = {
				slug: &#039;guests&#039;,
				name: &#039;guests2&#039;,
			};

			try {
				await apiGroups.update({ uid: adminUid }, data);
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
		});

		it(&#039;should delete group&#039;, async () =&gt; {
			await apiGroups.delete({ uid: adminUid }, { slug: &#039;renamedupdategroup&#039; });
			const exists = await Groups.exists(&#039;renamedupdategroup&#039;);
			assert(!exists);
		});

		it(&#039;should fail to delete group if name is special&#039;, async () =&gt; {
			const specialGroups = [
				&#039;administrators&#039;, &#039;registered-users&#039;, &#039;verified-users&#039;,
				&#039;unverified-users&#039;, &#039;global-moderators&#039;,
			];
			for (const slug of specialGroups) {
				try {
					// eslint-disable-next-line no-await-in-loop
					await apiGroups.delete({ uid: adminUid }, { slug: slug });
					assert(false);
				} catch (err) {
					assert.equal(err.message, &#039;[[error:not-allowed]]&#039;);
				}
			}
		});

		it(&#039;should fail to delete group if name is special&#039;, async () =&gt; {
			try {
				await apiGroups.delete({ uid: adminUid }, { slug: &#039;guests&#039; });
				assert(false);
			} catch (err) {
				assert.equal(err.message, &#039;[[error:invalid-group-name]]&#039;);
			}
		});

		it(&#039;should load initial set of groups when passed no arguments&#039;, async () =&gt; {
			const { groups } = await apiGroups.list({ uid: adminUid }, {});
			assert(Array.isArray(groups));
		});

		it(&#039;should load more groups&#039;, async () =&gt; {
			const { groups } = await apiGroups.list({ uid: adminUid }, { after: 0, sort: &#039;count&#039; });
			assert(Array.isArray(groups));
		});

		it(&#039;should load initial set of group members when passed no arguments&#039;, async () =&gt; {
			const { users } = await apiGroups.listMembers({ uid: adminUid }, {});
			assert(users);
			assert(Array.isArray(users));
		});

		it(&#039;should load more members&#039;, async () =&gt; {
			const { users } = await apiGroups.listMembers({ uid: adminUid }, { after: 0, groupName: &#039;PrivateCanJoin&#039; });
			assert(Array.isArray(users));
		});
	});

	describe(&#039;api methods&#039;, () =&gt; {
		const apiGroups = require(&#039;../src/api/groups&#039;);
		it(&#039;should fail to create group with invalid data&#039;, async () =&gt; {
			let err;
			try {
				await apiGroups.create({ uid: adminUid }, null);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:invalid-data]]&#039;);
		});

		it(&#039;should fail to create group if group name is privilege group&#039;, async () =&gt; {
			let err;
			try {
				await apiGroups.create({ uid: adminUid }, { name: &#039;cid:1:privileges:read&#039; });
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:invalid-group-name]]&#039;);
		});

		it(&#039;should create a group&#039;, async () =&gt; {
			const groupData = await apiGroups.create({ uid: adminUid }, { name: &#039;newgroup&#039;, description: &#039;group created by admin&#039; });
			assert.equal(groupData.name, &#039;newgroup&#039;);
			assert.equal(groupData.description, &#039;group created by admin&#039;);
			assert.equal(groupData.private, 1);
			assert.equal(groupData.hidden, 0);
			assert.equal(groupData.memberCount, 1);
		});

		it(&#039;should fail to join with invalid data&#039;, async () =&gt; {
			let err;
			try {
				await apiGroups.join({ uid: adminUid }, null);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:invalid-data]]&#039;);
		});

		it(&#039;should add user to group&#039;, async () =&gt; {
			await apiGroups.join({ uid: adminUid }, { uid: testUid, slug: &#039;newgroup&#039; });
			const isMember = await Groups.isMember(testUid, &#039;newgroup&#039;);
			assert(isMember);
		});

		it(&#039;should not error if user is already member&#039;, async () =&gt; {
			await apiGroups.join({ uid: adminUid }, { uid: testUid, slug: &#039;newgroup&#039; });
		});

		it(&#039;it should fail with invalid data&#039;, async () =&gt; {
			let err;
			try {
				await apiGroups.leave({ uid: adminUid }, null);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:invalid-data]]&#039;);
		});

		it(&#039;it should fail if admin tries to remove self&#039;, async () =&gt; {
			let err;
			try {
				await apiGroups.leave({ uid: adminUid }, { uid: adminUid, slug: &#039;administrators&#039; });
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:cant-remove-self-as-admin]]&#039;);
		});

		it(&#039;should error if user is not member&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.leave({ uid: adminUid }, { uid: 3, slug: &#039;newgroup&#039; }),
				{ message: &#039;[[error:group-not-member]]&#039; }
			);
		});

		it(&#039;should fail if trying to remove someone else from group&#039;, async () =&gt; {
			await assert.rejects(
				apiGroups.leave({ uid: testUid }, { uid: adminUid, slug: &#039;newgroup&#039; }),
				{ message: &#039;[[error:no-privileges]]&#039; },
			);
		});

		it(&#039;should remove user from group if caller is admin&#039;, async () =&gt; {
			await apiGroups.leave({ uid: adminUid }, { uid: testUid, slug: &#039;newgroup&#039; });
			const isMember = await Groups.isMember(testUid, &#039;newgroup&#039;);
			assert(!isMember);
		});

		it(&#039;should remove user from group if caller is a global moderator&#039;, async () =&gt; {
			const globalModUid = await User.getUidByUsername(&#039;glomod&#039;);
			await apiGroups.join({ uid: adminUid }, { uid: testUid, slug: &#039;newgroup&#039; });

			await apiGroups.leave({ uid: globalModUid }, { uid: testUid, slug: &#039;newgroup&#039; });
			const isMember = await Groups.isMember(testUid, &#039;newgroup&#039;);
			assert(!isMember);
		});

		it(&#039;should fail with invalid data&#039;, async () =&gt; {
			let err;
			try {
				await apiGroups.update({ uid: adminUid }, null);
			} catch (_err) {
				err = _err;
			}
			assert.strictEqual(err.message, &#039;[[error:invalid-data]]&#039;);
		});

		it(&#039;should update group&#039;, async () =&gt; {
			const data = {
				slug: &#039;newgroup&#039;,
				name: &#039;renamedgroup&#039;,
				description: &#039;cat group&#039;,
				userTitle: &#039;cats&#039;,
				userTitleEnabled: 1,
				disableJoinRequests: 1,
				hidden: 1,
				private: 0,
			};
			await apiGroups.update({ uid: adminUid }, data);
			const groupData = await Groups.get(&#039;renamedgroup&#039;, {});
			assert.equal(groupData.name, &#039;renamedgroup&#039;);
			assert.equal(groupData.userTitle, &#039;cats&#039;);
			assert.equal(groupData.description, &#039;cat group&#039;);
			assert.equal(groupData.hidden, true);
			assert.equal(groupData.disableJoinRequests, true);
			assert.equal(groupData.private, false);
		});
	});

	describe(&#039;groups cover&#039;, () =&gt; {
		const socketGroups = require(&#039;../src/socket.io/groups&#039;);
		let regularUid;
		const logoPath = path.join(__dirname, &#039;../test/files/test.png&#039;);
		const imagePath = path.join(__dirname, &#039;../test/files/groupcover.png&#039;);
		before(async () =&gt; {
			regularUid = await User.create({ username: &#039;regularuser&#039;, password: &#039;123456&#039; });
			await Groups.join(&#039;Test&#039;, adminUid);
			await Groups.join(&#039;Test&#039;, regularUid);
			await helpers.copyFile(logoPath, imagePath);
		});

		it(&#039;should fail if user is not logged in or not owner&#039;, (done) =&gt; {
			socketGroups.cover.update({ uid: 0 }, { imageData: &#039;asd&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
				socketGroups.cover.update({ uid: regularUid }, { groupName: &#039;Test&#039;, imageData: &#039;asd&#039; }, (err) =&gt; {
					assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
					done();
				});
			});
		});

		it(&#039;should upload group cover image from file&#039;, (done) =&gt; {
			const data = {
				groupName: &#039;Test&#039;,
				file: {
					path: imagePath,
					type: &#039;image/png&#039;,
				},
			};
			Groups.updateCover({ uid: adminUid }, data, (err, data) =&gt; {
				assert.ifError(err);
				Groups.getGroupFields(&#039;Test&#039;, [&#039;cover:url&#039;], (err, groupData) =&gt; {
					assert.ifError(err);
					assert.equal(nconf.get(&#039;relative_path&#039;) + data.url, groupData[&#039;cover:url&#039;]);
					if (nconf.get(&#039;relative_path&#039;)) {
						assert(!data.url.startsWith(nconf.get(&#039;relative_path&#039;)));
						assert(groupData[&#039;cover:url&#039;].startsWith(nconf.get(&#039;relative_path&#039;)), groupData[&#039;cover:url&#039;]);
					}
					done();
				});
			});
		});


		it(&#039;should upload group cover image from data&#039;, (done) =&gt; {
			const data = {
				groupName: &#039;Test&#039;,
				imageData: &#039;data:image/png;base64,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&#039;,
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err, data) =&gt; {
				assert.ifError(err);
				Groups.getGroupFields(&#039;Test&#039;, [&#039;cover:url&#039;], (err, groupData) =&gt; {
					assert.ifError(err);
					assert.equal(nconf.get(&#039;relative_path&#039;) + data.url, groupData[&#039;cover:url&#039;]);
					done();
				});
			});
		});

		it(&#039;should fail to upload group cover with invalid image&#039;, (done) =&gt; {
			const data = {
				groupName: &#039;Test&#039;,
				file: {
					path: imagePath,
					type: &#039;image/png&#039;,
				},
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should fail to upload group cover with invalid image&#039;, (done) =&gt; {
			const data = {
				groupName: &#039;Test&#039;,
				imageData: &#039;data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAABwA&#039;,
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err, data) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-image]]&#039;);
				done();
			});
		});

		it(&#039;should update group cover position&#039;, (done) =&gt; {
			const data = {
				groupName: &#039;Test&#039;,
				position: &#039;50% 50%&#039;,
			};
			socketGroups.cover.update({ uid: adminUid }, data, (err) =&gt; {
				assert.ifError(err);
				Groups.getGroupFields(&#039;Test&#039;, [&#039;cover:position&#039;], (err, groupData) =&gt; {
					assert.ifError(err);
					assert.equal(&#039;50% 50%&#039;, groupData[&#039;cover:position&#039;]);
					done();
				});
			});
		});

		it(&#039;should fail to update cover position if group name is missing&#039;, (done) =&gt; {
			Groups.updateCoverPosition(&#039;&#039;, &#039;50% 50%&#039;, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
				done();
			});
		});

		it(&#039;should fail to remove cover if not logged in&#039;, (done) =&gt; {
			socketGroups.cover.remove({ uid: 0 }, { groupName: &#039;Test&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
				done();
			});
		});

		it(&#039;should fail to remove cover if not owner&#039;, (done) =&gt; {
			socketGroups.cover.remove({ uid: regularUid }, { groupName: &#039;Test&#039; }, (err) =&gt; {
				assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
				done();
			});
		});

		it(&#039;should remove cover&#039;, async () =&gt; {
			const fields = [&#039;cover:url&#039;, &#039;cover:thumb:url&#039;];
			const values = await Groups.getGroupFields(&#039;Test&#039;, fields);
			await socketGroups.cover.remove({ uid: adminUid }, { groupName: &#039;Test&#039; });

			fields.forEach((field) =&gt; {
				const filename = values[field].split(&#039;/&#039;).pop();
				const filePath = path.join(nconf.get(&#039;upload_path&#039;), &#039;files&#039;, filename);
				assert.strictEqual(fs.existsSync(filePath), false);
			});

			const groupData = await db.getObjectFields(&#039;group:Test&#039;, [&#039;cover:url&#039;]);
			assert(!groupData[&#039;cover:url&#039;]);
		});
	});

	describe(&#039;isPrivilegeGroup&#039;, () =&gt; {
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;cid:1:privileges:topics:find&#039;), true);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;cid:1:privileges:groups:topics:find&#039;), true);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;cid:0:privileges:groups:search:users&#039;), true);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;cid:admin:privileges:admin:users&#039;), true);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;cid::privileges:admin:users&#039;), false);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;cid:string:privileges:admin:users&#039;), false);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;admin&#039;), false);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;registered-users&#039;), false);
		assert.strictEqual(Groups.isPrivilegeGroup(&#039;&#039;), false);
		assert.strictEqual(Groups.isPrivilegeGroup(null), false);
		assert.strictEqual(Groups.isPrivilegeGroup(undefined), false);
		assert.strictEqual(Groups.isPrivilegeGroup(false), false);
		assert.strictEqual(Groups.isPrivilegeGroup(true), false);
	});
});
</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
